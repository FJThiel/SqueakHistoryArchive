'From Squeak 2.2 of Sept 23, 1998 on 14 October 1998 at 11:12:08 pm'!"Change Set:		jhmMIDIInputDate:			14 October 1998Author:			John MaloneyImproves the MIDI facilities in a number of ways, including the abilityto parse, filter, and process incoming MIDI commands. Includes the beginningof a simple MIDI-controlled synthesizer. One can also create slidersto control for various MIDI parameters, can play an external MIDI devicevia an on-screen keyboard, can select MIDI ports by name, and more."!AlignmentMorph subclass: #MIDIControllerMorph	instanceVariableNames: 'channel controller midiPort lastValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!Object subclass: #MIDIInputParser	instanceVariableNames: 'cmdActionTable midiPort received rawDataBuffer sysExBuffer ignoreSysEx startTime timeNow state lastSelector lastCmdByte argByte1 argByte2 '	classVariableNames: 'DefaultMidiTable '	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #MIDISynth	instanceVariableNames: 'midiParser channels process '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #MIDISynthChannel	instanceVariableNames: 'channel instrument masterVolume channelVolume pitchBend activeSounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!PianoKeyboardMorph subclass: #MIDIPianoKeyboardMorph	instanceVariableNames: 'midiPort channel velocity '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!AlignmentMorph subclass: #ScorePlayerMorph	instanceVariableNames: 'scorePlayer trackInstNames instrumentSelector '	classVariableNames: 'LastMIDIPort '	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #SimpleMIDIPort	instanceVariableNames: 'portNumber accessSema lastCommandByteOut '	classVariableNames: 'DefaultPortNumber InterfaceClockRate '	poolDictionaries: ''	category: 'Music-Scores'!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 10/14/1998 16:04'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 3) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 10/14/1998 16:26'!originalSamplingRate	^ originalSamplingRate! !!MIDIControllerMorph reorganize!('initialization' initialize)('accessing' channel channel: controller controller: midiPort midiPort:)('menu' addCustomMenuItems:hand: controllerList controllerName: setChannel: setController:)('other' newSliderValue: updateLabel)!!MIDIControllerMorph methodsFor: 'initialization' stamp: 'jm 9/28/1998 22:38'!initialize	| slider |	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ vResizing _ #shrinkWrap.	self color: (Color r: 0.484 g: 0.613 b: 0.0).	self borderWidth: 1.	channel _ 0.	controller _ 7.  "channel volume"	slider _ SimpleSliderMorph new		target: self;		actionSelector: #newSliderValue:;		minVal: 0;		maxVal: 127;		extent: 128@10.	self addMorphBack: slider.	self addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!channel	^ channel! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!channel: anInteger	channel _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!controller	^ controller! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!controller: anInteger	controller _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:54'!midiPort	^ midiPort! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:55'!midiPort: anInteger	midiPort _ anInteger.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set channel' action: #setChannel:.	aCustomMenu add: 'set controller' action: #setController:.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!controllerList	"Answer a list of controller name, number pairs to be used in the menu."	^ #((1 modulation)		(2 'breath control')		(7 volume)		(10 pan)		(11 expression)		(92 'tremolo depth')		(93 'chorus depth')		(94 'celeste depth')		(95 'phaser depth'))! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:09'!controllerName: controllerNumber	"Answer a name for the given controller. If no name is available, use the form 'CC5' (CC is short for 'continuous controller')."	self controllerList do: [:pair |		pair first = controllerNumber ifTrue: [^ pair last]].	^ 'CC', controllerNumber asString! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:46'!setChannel: evt	| menu |	menu _ MenuMorph new.	1 to: 16 do: [:chan |		menu add: chan printString			target: self			selector: #channel:			argumentList: (Array with: chan - 1)].	menu popUpAt: evt hand position event: evt.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!setController: evt	| menu |	menu _ MenuMorph new.	self controllerList do: [:pair |		menu add: (pair last)			target: self			selector: #controller:			argumentList: (Array with: pair first)].	menu popUpAt: evt hand position event: evt.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 10/12/1998 16:02'!newSliderValue: newValue	"Send a control command out the MIDI port."	| val |	midiPort ifNil: [^ self].	val _ newValue asInteger.	lastValue = val ifTrue: [^ self].	lastValue _ val.	midiPort midiCmd: 16rB0 channel: channel byte: controller byte: val.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 9/29/1998 09:10'!updateLabel	| label |	(label _ self findA: StringMorph) ifNil: [^ self].	label contents: (self controllerName: controller), ', ch: ', (channel + 1) printString.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/27/1998 21:44'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	((chunkSize < 6) or: [chunkSize > 100])		ifTrue: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/27/1998 22:15'!metaEventAt: ticks	"Read a meta event. Event types appear roughly in order of expected frequency."	| type length tempo |	type _ trackStream next.	length _ self readVarLengthIntFrom: trackStream.	type = 16r51 ifTrue: [  "tempo"		tempo _ 0.		length timesRepeat: [tempo _ (tempo bitShift: 8) + trackStream next].		track add: (TempoEvent new tempo: tempo; time: ticks).		^ self].	type = 16r2F ifTrue: [  "end of track"		length = 0 ifFalse: [self error: 'length of end-of-track chunk should be zero'].		self endAllNotesAt: ticks.		trackStream skip: length.		^ self].	type = 16r58 ifTrue: [  "time signature"		length = 4 ifFalse: [self error: 'length of time signature chunk should be four'].		trackStream skip: length.		^ self].	type = 16r59 ifTrue: [  "key signature"		length = 2 ifFalse: [self error: 'length of key signature chunk should be two'].		trackStream skip: length.		^ self].	((type >= 1) and: [type <= 7]) ifTrue: [  "string"		strings add: (trackStream next: length) asString.		^ self].	(  type = 16r21 or:   "mystery; found in MIDI files but not in MIDI File 1.0 Spec"	 [(type = 16r7F) or:  "sequencer specific meta event"	 [(type = 16r00) or:  "sequence number"	 [(type = 16r20)]]])  "MIDI channel prefix"		ifTrue: [			trackStream skip: length.			^ self].	type = 16r54 ifTrue: [		"SMPTE offset"		self report: 'Ignoring SMPTE offset'.		trackStream skip: length.		^ self].	"skip unrecognized meta event"	self report:		'skipping unrecognized meta event: ', (type printStringBase: 16),		' (', length printString, ' bytes)'.	trackStream skip: length.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIInputParser commentStamp: '<historical>' prior: 0!I am a parser for a MIDI data stream. I support:	real-time MIDI recording,	overdubbing (recording while playing),	monitoring incoming MIDI, and	interactive MIDI performances.Note: MIDI controllers such as pitch benders and breath controllers generate large volumes of data which consume processor time. In cases where this information is not of interest to the program using it, it is best to filter it out as soon as possible. I support various options for doing this filtering, including filtering by MIDI channel and/or by command type.!!MIDIInputParser reorganize!('midi filtering' ignoreChannel: ignoreCommand: ignoreSysEx: ignoreTuneAndRealTimeCommands noFiltering recordOnlyChannels:)('recording' clearBuffers processMIDIData received)('real-time processing' midiDo: midiDoUntilMouseDown:)('midi monitor' monitor printCmd:with:with:)('private-state machine' endSysExclusive: ignoreOne: ignoreTwo: ignoreZero: processByte: recordOne: recordTwo: recordZero: startSysExclusive: undefined:)('private-other' setMIDIPort:)!!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:39'!ignoreChannel: channel	"Don't record any events arriving on the given MIDI channel (in the range 1-16)."	((channel isInteger not) | (channel < 1) | (channel > 16))		ifTrue: [^ self error: 'bad MIDI channel number', channel printString].	"two-arg channel messages"	#(128 144 160 176 224) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreTwo:].	"one-arg channel messages"	#(192 208) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreOne:].! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:40'!ignoreCommand: midiCmd	"Don't record the given MIDI command on any channel."	| cmd sel | 	((midiCmd isInteger not) | (midiCmd < 128) | (midiCmd > 255))		ifTrue: [^ self error: 'bad MIDI command'].	midiCmd < 240 ifTrue: [  "channel commands; ignore on all channels"		cmd _ midiCmd bitAnd: 2r11110000.		sel _ (#(128 144 160 176 224) includes: cmd)			ifTrue: [#ignoreTwo:]			ifFalse: [#ignoreOne:].		 1 to: 16 do: [:ch | cmdActionTable at: (cmd bitOr: ch - 1) put: sel].		^ self].	(#(240 241 244 245 247 249 253) includes: midiCmd) ifTrue: [		^ self error: 'You can''t ignore the undefined MIDI command: ', midiCmd printString].	midiCmd = 242 ifTrue: [  "two-arg command"		cmdActionTable at: midiCmd put: #ignoreTwo:.		 ^ self].	midiCmd = 243 ifTrue: [  "one-arg command"		cmdActionTable at: midiCmd put: #ignoreOne:.		^ self].	(#(246 248 250 251 252 254 255) includes: midiCmd) ifTrue:	[  "zero-arg command"		cmdActionTable at: midiCmd put: #ignore.		 ^ self].	"we should not get here"	self error: 'implementation error'.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:38'!ignoreSysEx: aBoolean	"If the argument is true, then ignore incoming system exclusive message."	ignoreSysEx _ aBoolean.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:46'!ignoreTuneAndRealTimeCommands	"Ignore tuning requests and real-time commands."	cmdActionTable at: 246 put: #ignoreZero:.	"tune request"	cmdActionTable at: 248 put: #ignoreZero:.	"timing clock"	cmdActionTable at: 250 put: #ignoreZero:.	"start"	cmdActionTable at: 251 put: #ignoreZero:.		"continue"	cmdActionTable at: 252 put: #ignoreZero:.	"stop/Clock"	cmdActionTable at: 254 put: #ignoreZero:.	"active sensing"	cmdActionTable at: 255 put: #ignoreZero:.	"system reset"! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:37'!noFiltering	"Revert to accepting all MIDI commands on all channels. This undoes any earlier request to filter the incoming MIDI stream."	cmdActionTable _ DefaultMidiTable deepCopy.	ignoreSysEx _ false.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:50'!recordOnlyChannels: channelList	"Record only MIDI data arriving on the given list of channel numbers (in the range 1-16)."	channelList do: [:ch |		((ch isInteger not) | (ch < 1) | (ch > 16))			ifTrue: [^ self error: 'bad Midi channel specification: ', ch printString]].	1 to: 16 do: [:ch | (channelList includes: ch) ifFalse: [self ignoreChannel: ch]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/9/1998 07:52'!clearBuffers	"Clear the MIDI record buffers. This should be called at the start of recording or real-time MIDI processing."		received _ received species new: 5000.	rawDataBuffer _ ByteArray new: 1000.	sysExBuffer _ WriteStream on: (ByteArray new: 100).	midiPort ensureOpen; flushInput.	startTime _ Time millisecondClockValue.	state _ #idle.! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 21:06'!processMIDIData	"Process all MIDI data that has arrived since the last time this method was executed. This method should be called frequently to process, filter, and timestamp MIDI data as it arrives."	| bytesRead |	[(bytesRead _ midiPort readInto: rawDataBuffer) > 0] whileTrue: [		timeNow _ (midiPort bufferTimeStampFrom: rawDataBuffer) - startTime.		5 to: bytesRead do: [:i | self processByte: (rawDataBuffer at: i)]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 20:24'!received	"Answer my current collection of all MIDI commands received. Items in this list have the form (<time><cmd byte>[<arg1>[<arg2>]]). Note that the real-time processing facility, midiDo:, removes items from this list as it processes them."	^ received! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/9/1998 07:53'!midiDo: aBlock	"Poll the incoming MIDI stream in real time and call the given block for each complete command that has been received. The block takes one argument, which is an array of the form (<time><cmd byte>[<arg1>[<arg2>]]). The number of arguments depends on the command byte. For system exclusive commands, the argument is a ByteArray containing the system exclusive message."	self processMIDIData.	[received isEmpty] whileFalse:		[aBlock value: received removeFirst].! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/8/1998 21:21'!midiDoUntilMouseDown: midiActionBlock	"Process the incoming MIDI stream in real time by calling midiActionBlock for each MIDI event. This block takes three arguments: the MIDI command byte and two argument bytes. One or both argument bytes may be nil, depending on the MIDI command. If not nil, evaluatue idleBlock regularly whether MIDI data is available or not. Pressing any mouse button terminates the interaction."	| time cmd arg1 arg2 |	self clearBuffers.	[Sensor anyButtonPressed] whileFalse: [		self midiDo: [:item |			time _ item at: 1.			cmd _ item at: 2.			arg1 _ arg2 _ nil.			item size > 2 ifTrue: [				arg1 _ item at: 3.				item size > 3 ifTrue: [arg2 _ item at: 4]].				midiActionBlock value: cmd value: arg1 value: arg2]].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/8/1998 21:22'!monitor	"Print MIDI messages to the transcript until any mouse button is pressed."	self midiDoUntilMouseDown: [:cmd :arg1 :arg2 |		self printCmd: cmd with: arg1 with: arg2].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/9/1998 10:19'!printCmd: cmdByte with: arg1 with: arg2	"Print the given MIDI command."	| cmd ch bend |	cmdByte < 240		ifTrue: [  "channel message" 			cmd _ cmdByte bitAnd: 2r11110000.			ch _ (cmdByte bitAnd: 2r00001111) + 1]		ifFalse: [cmd _ cmdByte].  "system message"	cmd = 128 ifTrue: [		^ Transcript show: ('key up ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 144 ifTrue: [		^ Transcript show: ('key down: ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 160 ifTrue: [		^ Transcript show: ('key pressure: ', arg1 printString, ' val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 176 ifTrue: [		^ Transcript show: ('CC', arg1 printString, ': val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 192 ifTrue: [		^ Transcript show: ('prog: ', (arg1 + 1) printString, ' chan: ', ch printString); cr].	cmd = 208 ifTrue: [		^ Transcript show: ('channel pressure ', arg1 printString, ' chan: ', ch printString); cr].	cmd = 224 ifTrue: [		bend _ ((arg2 bitShift: 7) + arg1) - 8192.		^ Transcript show: ('bend: ', bend printString, ' chan: ', ch printString); cr].	cmd = 240 ifTrue: [		^ Transcript show: ('system exclusive: ', (arg1 at: 1) printString, ' (', arg1 size printString, ' bytes)'); cr].	Transcript show: 'cmd: ', cmd printString, ' arg1: ', arg1 printString, ' arg2: ', arg2 printString; cr.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 18:34'!endSysExclusive: cmdByte	"Error!! Received 'end system exclusive' command when not receiving system exclusive data."	self error: 'unexpected ''End of System Exclusive'' command'.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreOne: cmdByte	"Ignore a one argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreOne:.	state _ #ignore1.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreTwo: cmdByte	"Ignore a two argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreTwo:.	state _ #ignore2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:45'!ignoreZero: cmdByte	"Ignore a zero argument command, such as tune request or a real-time message. Stay in the current and don't change active status. Note that real-time messages can arrive between data bytes without disruption."		"do nothing"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:36'!processByte: aByte	"Process the given incoming MIDI byte and record completed commands."	"Details: Because this must be fast, it has been hand-tuned. Be careful!!"	aByte > 247 ifTrue: [  "real-time message; can arrive at any time"		^ self perform: (cmdActionTable at: aByte) with: aByte].	#idle = state ifTrue: [		aByte >= 128			ifTrue: [  "command byte in idle state: start new command"				^ self perform: (cmdActionTable at: aByte) with: aByte]			ifFalse: [  "data byte in idle state: use running status if possible"				lastCmdByte ifNil: [^ self].  "running status unknown; skip byte"				"process this data as if it had the last command byte in front of it"				 self perform: lastSelector with: lastCmdByte.				"the previous line put us into a new state; we now 'fall through'				 to process the data byte given this new state."]].	#ignore1 = state ifTrue: [^ state _ #idle].	#ignore2 = state ifTrue: [^ state _ #ignore1].	#want1of2 = state ifTrue: [		argByte1 _ aByte.		^ state _ #want2of2].	#want2of2 = state ifTrue: [		argByte2 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1 with: argByte2).		^ state _ #idle].	#want1only = state ifTrue: [		argByte1 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1).		^ state _ #idle].	#sysExclusive = state ifTrue: [		aByte < 128 ifTrue: [			"record a system exclusive data byte"			ignoreSysEx ifFalse: [sysExBuffer nextPut: aByte].			^ self]		ifFalse: [			aByte < 248 ifTrue: [				"a system exclusive message is terminated by any non-real-time command byte"				ignoreSysEx ifFalse: [					received addLast: (Array with: timeNow with: lastCmdByte with: sysExBuffer contents)].				state _ #idle.				aByte = 247					ifTrue: [^ self]							"endSysExclusive command, nothing left to do"					ifFalse: [^ self processByte: aByte]]]].  	"no endSysExclusive; just start the next command"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordOne: cmdByte	"Record a one argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordOne:.	state _ #want1only.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordTwo: cmdByte	"Record a two argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordTwo:.	state _ #want1of2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:43'!recordZero: cmdByte	"Record a zero-byte message, such as tune request or a real-time message. Don't change active status. Note that real-time messages can arrive between data bytes without disruption."		received addLast: (Array with: timeNow with: cmdByte).! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:38'!startSysExclusive: cmdByte	"The beginning of a variable length 'system exclusive' command."	sysExBuffer resetContents.	lastCmdByte _ nil.  "system exclusive commands clear running status"	lastSelector _ nil.	state _ #sysExclusive.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 17:12'!undefined: cmdByte	"We have received an unexpected MIDI byte (e.g., a data byte when we were expecting a command). This should never happen."	self error: 'unexpected MIDI byte ', cmdByte printString.! !!MIDIInputParser methodsFor: 'private-other' stamp: 'jm 10/9/1998 07:56'!setMIDIPort: aMIDIPort	"Initialize this instance for recording from the given MIDI port. Tune and real-time commands are filtered out by default; the client can send noFiltering to receive these messages."	midiPort _ aMIDIPort.	received _ OrderedCollection new.	self noFiltering.  "initializes cmdActionTable"	self ignoreTuneAndRealTimeCommands.! !!MIDIInputParser class methodsFor: 'class initialization' stamp: 'jm 10/9/1998 07:35'!initialize	"Build the default MIDI command-byte action table. This table maps MIDI command bytes to the action to be performed when that is received. Note that MIDI data bytes (bytes whose value is < 128) are never used to index into this table."	"MIDIInputParser initialize"	DefaultMidiTable _ Array new: 255 withAll: #undefined:.	128 to: 143 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key off"	144 to: 159 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key on"	160 to: 175 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"polyphonic after-touch"	176 to: 191 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"control change"	192 to: 207 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"program change"	208 to: 223 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"channel after-touch"	224 to: 239 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"pitch bend"	DefaultMidiTable at: 240 put: #startSysExclusive:.		"start a system exclusive block"	DefaultMidiTable at: 241 put: #recordOne:.			"MIDI time code quarter frame"	DefaultMidiTable at: 242 put: #recordTwo:.			"song position select"	DefaultMidiTable at: 243 put: #recordOne:.			"song select"	DefaultMidiTable at: 244 put: #undefined:.	DefaultMidiTable at: 245 put: #undefined:.	DefaultMidiTable at: 246 put: #recordZero:.			"tune request"	DefaultMidiTable at: 247 put: #endSysExclusive:.		"end a system exclusive block"	DefaultMidiTable at: 248 put: #recordZero:.			"timing clock"	DefaultMidiTable at: 249 put: #undefined:.	DefaultMidiTable at: 250 put: #recordZero:.			"start"	DefaultMidiTable at: 251 put: #recordZero:.			"continue"	DefaultMidiTable at: 252 put: #recordZero:.			"stop/Clock"	DefaultMidiTable at: 253 put: #undefined:.	DefaultMidiTable at: 254 put: #recordZero:.			"active sensing"	DefaultMidiTable at: 255 put: #recordZero:.			"system reset"! !!MIDIInputParser class methodsFor: 'instance creation' stamp: 'jm 10/8/1998 20:29'!on: aSimpleMIDIPort	"Answer a new MIDI parser on the given port."	^ super new setMIDIPort: aSimpleMIDIPort! !!MIDISynth commentStamp: 'jm 10/14/1998 22:45' prior: 0!I implement a simple real-time MIDI synthesizer on platforms that support MIDI input. I work best on platforms that allow the sound buffer to be made very short--under 50 milliseconds is good and under 20 milliseconds is preferred (see below). The buffer size is changed by modifying the class initialization method of SoundPlayer and executing the do-it there to re-start the sound player.Each instance of me takes input from a single MIDI input port. Multiple instances of me can be used to handle multiple MIDI input ports. I distribute incoming commands among my sixteen MIDISynthChannel objects. Most of the interpretation of the MIDI commands is done by these channel objects. Buffer size notes: At the moment, most fast PowerPC Macintosh computers can probably work with buffer sizes down to 50 milliseconds, and the Powerbook G3 works down to about 15 milliseconds. You will need to experiment to discover the minimum buffer size that does not result in clicking during sound output. (Hint: Be sure to turn off power cycling on your Powerbook. Other applications and extensions can steal cycles from Squeak, causing intermittent clicking. Experimentation may be necessary to find a configuration that works for you.)!!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 22:16'!channel: i	^ channels at: i! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 11:46'!masterVolume: aNumber	| vol |	vol _ (aNumber asFloat min: 1.0) max: 0.0.	channels do: [:ch | ch masterVolume: vol].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 21:52'!midiParser	^ midiParser! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 12:09'!midiTrackingLoop	midiParser clearBuffers.	[true] whileTrue: [		self processMIDI ifFalse: [(Delay forMilliseconds: 5) wait]].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:07'!on: aSimpleMIDIPort	"Prepare the receiver to process MIDI arriving on the given port."	midiParser _ MIDIInputParser on: aSimpleMIDIPort.	channels _ (1 to: 16) collect: [:ch | MIDISynthChannel new initialize].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:13'!processMIDI	"Process some MIDI commands. Answer true if any commands were processed."	| didSomething cmdByte byte1 byte2 cmd chan |	didSomething _ false.	midiParser midiDo: [:item |		didSomething _ true.		cmdByte _ item at: 2.		byte1 _ byte2 _ nil.		item size > 2 ifTrue: [			byte1 _ item at: 3.			item size > 3 ifTrue: [byte2 _ item at: 4]].		cmdByte < 240			ifTrue: [  "channel message" 				cmd _ cmdByte bitAnd: 2r11110000.				chan _ (cmdByte bitAnd: 2r00001111) + 1.				(channels at: chan) doChannelCmd: cmd byte1: byte1 byte2: byte2]			ifFalse: [  "system message"				"process system messages here"			]].	^ didSomething! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/14/1998 14:14'!processMIDIUntilMouseDown	"Used for debugging. Do MIDI processing until the mouse is pressed."	midiParser clearBuffers.	[Sensor anyButtonPressed] whileFalse: [self processMIDI].! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 11:37'!startMIDITracking	midiParser ifNil: [^ self].	self stopMIDITracking.	process _ [self midiTrackingLoop] newProcess.	process priority: Processor userInterruptPriority.	process resume.! !!MIDISynth methodsFor: 'all' stamp: 'jm 10/13/1998 11:21'!stopMIDITracking	process ifNotNil: [		process terminate.		process _ nil].! !!MIDISynth class reorganize!('examples' example)!!MIDISynth class methodsFor: 'examples' stamp: 'jm 10/14/1998 22:53'!example	"Here's one way to run the MIDI synth. It will get a nice Morphic UI later. Click the mouse to stop running it. (Mac users note: be sure you have MIDI interface adaptor plugged in, or Squeak will hang waiting for the external clock signal.)."	| portNum synth |	portNum _ SimpleMIDIPort inputPortNumFromUser.	portNum ifNil: [^ self].	synth _ MIDISynth new on:		(SimpleMIDIPort openOnPortNumber: portNum).	synth midiParser ignoreCommand: 224.  "filter out pitch bends"	1 to: 16 do: [:i |		(synth channel: i) instrument: 			 (AbstractSound soundNamed: 'oboe1')].	synth masterVolume: 0.2.	synth processMIDIUntilMouseDown.! !!MIDISynthChannel commentStamp: 'jm 10/14/1998 13:56' prior: 0!I implement one polyphonic channel of a 16-channel MIDI synthesizer. Many MIDI commands effect all the notes played on a particular channel, so I record the state for a single channel, including a list of notes currently playing.This initial implementation is extremely spartan, having just enough functionality to play notes. Things that are not implemented include:  1. program changes  2. sustain pedal  3. aftertouch (either kind)  4. most controllers  5. portamento  6. mono-mode!!MIDISynthChannel reorganize!('initialization' initialize)('accessing' instrument instrument: masterVolume masterVolume:)('midi dispatching' channelPressure: control:value: doChannelCmd:byte1:byte2: key:pressure: keyDown:vel: keyUp:vel: pitchBend: programChange:)('other' adjustPitch: convertVelocity: newVolume:)!!MIDISynthChannel methodsFor: 'initialization' stamp: 'jm 10/14/1998 13:15'!initialize	instrument _ FMSound default.	masterVolume _ 1.0.	channelVolume _ 1.0.	pitchBend _ 0.0.	activeSounds _ OrderedCollection new.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument	^ instrument! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument: aSound	instrument _ aSound.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:47'!masterVolume	^ masterVolume! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 11:49'!masterVolume: aNumber	"Set the master volume the the given value (0.0 to 1.0)."	masterVolume _ aNumber asFloat.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:40'!channelPressure: newPressure	"Handle a channel pressure (channel aftertouch) change."	self newVolume: newPressure.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:48'!control: control value: newValue	"Handle a continuous controller change."	control = 2 ifTrue: [self newVolume: newValue].  "breath controller"! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:44'!doChannelCmd: cmdByte byte1: byte1 byte2: byte2	"Dispatch a channel command with the given arguments."	"Details: Cases appear in order of expected frequency, most frequent cases first."	cmdByte = 144 ifTrue: [		byte2 = 0			ifTrue: [^ self keyUp: byte1 vel: 0]			ifFalse: [^ self keyDown: byte1 vel: byte2]].	cmdByte = 128 ifTrue: [^ self keyUp: byte1 vel: byte2].	cmdByte = 224 ifTrue: [^ self pitchBend: ((byte2 bitShift: 7) + byte1) - 8192].	cmdByte = 176 ifTrue: [^ self control: byte1 value: byte2].	cmdByte = 208 ifTrue: [^ self channelPressure: byte1].	cmdByte = 160 ifTrue: [^ self key: byte1 pressure: byte2].	cmdByte = 192 ifTrue: [^ self programChange: byte1].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!key: key pressure: press	"Handle a key pressure (polyphonic aftertouch) change. Rarely implemented."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:09'!keyDown: key vel: vel	"Handle a key down event with non-zero velocity."	| pitch snd |	pitch _ AbstractSound pitchForMIDIKey: key.	snd _ instrument		soundForPitch: pitch		dur: 10000.0  "sustain a long time, or until turned off"		loudness: masterVolume * channelVolume * (self convertVelocity: vel).	SoundPlayer resumePlaying: snd quickStart: false.	activeSounds add: (Array with: key with: snd with: pitch).! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!keyUp: key vel: vel	"Handle a key up event."	| snd |	activeSounds copy do: [:entry |		(entry at: 1) = key ifTrue: [			snd _ entry at: 2.			snd stopGracefully.			activeSounds remove: entry]].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 21:45'!pitchBend: bend	"Handle a pitch-bend change."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:50'!programChange: newProgram	"Handle a program (instrument) change."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 21:45'!adjustPitch: bend	"Handle a pitch-bend change."	| snd pitchAdj centerPitch |	pitchBend _ bend.	pitchAdj _ 2.0 raisedTo: (bend asFloat / 8192.0) / 6.0.	activeSounds copy do: [:entry |		snd _ entry at: 2.		centerPitch _ entry at: 3.		snd pitch: pitchAdj * centerPitch.		snd internalizeModulationAndRatio].! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:43'!convertVelocity: valueByte	"Map a value in the range 0..127 to a volume in the range 0.0..1.0."	"Details: A quadratic function seems to give a good keyboard feel."	| r |	r _ (valueByte * valueByte) / 12000.0.	r > 1.0 ifTrue: [^ 1.0].	r < 0.08 ifTrue: [^ 0.08].	^ r! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:41'!newVolume: valueByte	"Set the channel volume to the level given by the given number in the range 0..127."	| snd newVolume |	channelVolume _ valueByte asFloat / 127.0.	newVolume _ masterVolume * channelVolume.	activeSounds do: [:entry |		snd _ entry at: 2.		snd adjustVolumeTo: newVolume overMSecs: 10].! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:16'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/24/1998 18:27'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 23.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!MIDIPianoKeyboardMorph commentStamp: 'jm 10/12/1998 18:32' prior: 0!I implement a piano keyboard that can be played with the mouse. I can output to a MIDI port, if MIDI is supported on this platform. I can also spawn controllers for other MIDI parameters, such as pitch bend.!!MIDIPianoKeyboardMorph reorganize!('all' addCustomMenuItems:hand: closeMIDIPort initialize makeMIDIController: mouseDownEvent:noteMorph:pitch: mouseUpEvent:noteMorph:pitch: openMIDIPort turnOffNote turnOnNote:)!!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:13'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	midiPort		ifNil: [aCustomMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aCustomMenu add: 'play via built in synth' action: #closeMIDIPort.			aCustomMenu add: 'new MIDI controller' action: #makeMIDIController:].! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:57'!closeMIDIPort	midiPort _ nil.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:30'!initialize	super initialize.	SimpleMIDIPort midiIsSupported		ifTrue: [midiPort _ SimpleMIDIPort openDefault].	channel _ 1.	velocity _ 100.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:11'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: midiPort).! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:25'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	midiPort ifNil: [^ super mouseDownEvent: event noteMorph: noteMorph pitch: midiKey - 1].	noteMorph color: playingKeyColor.	soundPlaying		ifNil: [midiPort ensureOpen]		ifNotNil: [self turnOffNote].	self turnOnNote: midiKey + 23.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:43'!mouseUpEvent: event noteMorph: noteMorph pitch: midiKey	midiPort ifNil: [		^ super mouseUpEvent: event noteMorph: noteMorph pitch: midiKey].	noteMorph color:		((#(0 1 3 5 6 8 10) includes: midiKey \\ 12)			ifTrue: [whiteKeyColor]			ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [self turnOffNote].! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 15:44'!turnOffNote	midiPort notNil & soundPlaying notNil ifTrue: [		soundPlaying isInteger ifTrue: [			midiPort midiCmd: 16r90 channel: channel byte: soundPlaying byte: 0]].	soundPlaying _ nil.! !!MIDIPianoKeyboardMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:25'!turnOnNote: midiKey	midiPort midiCmd: 16r90 channel: channel byte: midiKey byte: velocity.	soundPlaying _ midiKey.! !!PianoRollNoteMorph reorganize!('all' drawOn: newBounds:color:image:)!!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 10/6/1998 23:47'!buildSmallOrchestra	"Example of how to build a skeleton orchestra that uses less memory."	"SampledInstrument buildSmallOrchestra"	AbstractSound unloadSampledTimbres.	#(clarinet oboe bassoon trombone tympani) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: 'Tosh:Sample Library:Orchestra'.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 1].	#(flute bass) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: 'Tosh:Sample Library:Orchestra'.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 2].	AbstractSound soundNamed: 'trumpet-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'horn-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'violin-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'viola-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'cello-f' put: (AbstractSound soundNamed: 'bass-f').! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 17:13'!closeMIDIPort	"Stop using MIDI for output. Music will be played using the built-in sound synthesis."	self pause.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/24/1998 22:33'!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 5.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 15:56'!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:58'!midiPort	^ midiPort! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/14/1998 15:53'!atTrack: trackIndex from: aPopUpChoice selectInstrument: selection	| oldSnd name snd |	oldSnd _ scorePlayer instrumentForTrack: trackIndex.	(selection beginsWith: 'edit ') ifTrue: [		name _ selection copyFrom: 6 to: selection size.		aPopUpChoice contentsClipped: name.		(oldSnd isKindOf: FMSound) | (oldSnd isKindOf: LoopedSampledSound) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd title: name].		(oldSnd isKindOf: SampledInstrument) ifTrue: [			EnvelopeEditorMorph openOn: oldSnd allNotes first title: name].		^ self].	snd _ nil.	1 to: instrumentSelector size do: [:i |		((trackIndex ~= i) and:		 [selection = (instrumentSelector at: i) contents])			ifTrue: [snd _ scorePlayer instrumentForTrack: i]].  "use existing instrument prototype"	snd ifNil: [		selection = 'clink'			ifTrue: [				snd _ (SampledSound					samples: SampledSound coffeeCupClink					samplingRate: 11025) copy]			ifFalse: [snd _ (AbstractSound soundNamed: selection) copy]].	scorePlayer instrumentForTrack: trackIndex put: snd.	(instrumentSelector at: trackIndex) contentsClipped: selection.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 17:14'!closeMIDIPort	scorePlayer closeMIDIPort.	LastMIDIPort _ nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:06'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu add: 'reload instruments' action: #updateInstrumentsFromLibrary.	scorePlayer midiPort		ifNil: [			aMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aMenu add: 'play via built in synth' action: #closeMIDIPort.			aMenu add: 'new MIDI controller' action: #makeMIDIController:].	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/28/1998 23:05'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: scorePlayer midiPort).! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 16:31'!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer reset.	self addMorph: self makeControls.	instrumentSelector _ Array new: scorePlayer score tracks size.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].	LastMIDIPort ifNotNil: [		"use the most recently set MIDI port"		scorePlayer openMIDIPort: LastMIDIPort].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	scorePlayer openMIDIPort: portNum.	LastMIDIPort _ portNum.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 10/12/1998 17:18'!rewind	scorePlayer pause; reset.! !!ScorePlayerMorph class methodsFor: 'all' stamp: 'jm 10/12/1998 16:29'!openOn: aScore title: aString	| player |	player _ ScorePlayer onScore: aScore.	(self new onScorePlayer: player title: aString) openInWorld.! !!SimpleMIDIPort reorganize!('open/close' close ensureOpen openOnPortNumber: portNumber)('output' midiCmd:channel:byte: midiCmd:channel:byte:byte: midiOutput:)('input' bufferTimeStampFrom: flushInput readInto:)('primitives' primMIDIClosePort: primMIDIOpenPort:readSemaIndex:interfaceClockRate: primMIDIReadPort:into: primMIDIWritePort:from:at:)!!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 16:06'!close	"Close this MIDI port."	portNumber ifNil: [^ self].	self primMIDIClosePort: portNumber.	accessSema _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 16:06'!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	portNumber ifNil: [^ self error: 'Use "openOn:" to open a MIDI port initially'].	self close.	self openOnPortNumber: portNumber.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 16:13'!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	self primMIDIClosePort: portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	portNumber _ portNum.	accessSema _ Semaphore forMutualExclusion.	lastCommandByteOut _ Array new: 16 withAll: 0.  "initialize running status state for output"! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 15:48'!portNumber	"Answer my port number."	^ portNumber! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte1					with: dataByte2)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber from: aByteArray at: 0].! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:47'!bufferTimeStampFrom: aByteArray	"Return the timestamp from the given MIDI input buffer. Assume the given buffer is at least 4 bytes long."	^ ((aByteArray at: 1) bitShift: 24) +	  ((aByteArray at: 2) bitShift: 16) +	  ((aByteArray at: 3) bitShift: 8) +	   (aByteArray at: 4)! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:53'!flushInput	"Read any lingering MIDI data from this port's input buffer."	| buf |	buf _ ByteArray new: 1000.	[(self readInto: buf) > 0] whileTrue.! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/12/1998 15:49'!readInto: aByteArray	"Read any data from this port into the given buffer."	^ self primMIDIReadPort: portNumber into: aByteArray! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/12/1998 16:04'!primMIDIClosePort: portNum	"Close the given MIDI port. Don't fail if port is already closed."	<primitive: 521>! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:48'!primMIDIReadPort: portNum into: byteArray	"Read any available MIDI data into the given buffer (up to the size of the buffer) and answer the number of bytes read."	<primitive: 528>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:49'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	"Queue the given data to be sent through the given MIDI port at the given time. If midiClockValue is zero, send the data immediately."	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class reorganize!('class initialization' initialize)('instance creation' openDefault openOnPortNumber:)('utilities' closeAllPorts inputPortNumFromUser midiIsSupported outputPortNumFromUser portDescription:)('primitives' primPortCount primPortDirectionalityOf: primPortNameOf:)!!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 10/12/1998 16:36'!openOnPortNumber: portNum	"Answer a new instance of me for the given MIDI port number."	"Details: All clients of a particular MIDI port should share the same instance of me. This allows accesses to the port to be serialized and shared port-related state state to be maintained."	SimpleMIDIPort allInstancesDo: [:p |		p portNumber = portNum ifTrue: [			"share the existing port object for this port number"			^ p]].	^ super new openOnPortNumber: portNum! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:27'!closeAllPorts	"Close all MIDI ports."	"SimpleMIDIPort closeAllPorts"	| n |	n _ self primPortCount.	0 to: n - 1 do: [:portNum | self basicNew primMIDIClosePort: portNum].! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:57'!inputPortNumFromUser	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort inputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for input:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 1) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:10'!midiIsSupported	"Answer true if this platform supports MIDI."	^ self primPortCount > 0! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:58'!outputPortNumFromUser	"Prompt the user for a MIDI output port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort outputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for output:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 2) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:46'!portDescription: portNum	"Answer a string indicating the directionality of the given MIDI port."	"(0 to: SimpleMIDIPort primPortCount - 1) collect:		[:i | SimpleMIDIPort portDescription: i]"	| portName dir |	portName _ self primPortNameOf: portNum.	dir _ self primPortDirectionalityOf: portNum.	dir = 1 ifTrue: [^ portName, ' (in)'].	dir = 2 ifTrue: [^ portName, ' (out)'].	dir = 3 ifTrue: [^ portName, ' (in/out)'].	^ self error: 'unknown MIDI port directionality'! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:22'!primPortCount	"Answer the number of MIDI ports supported by this platform, or zero if this primitive is not implemented."	<primitive: 523>	^ 0! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:27'!primPortDirectionalityOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 524>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:23'!primPortNameOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 525>	self primitiveFailed.! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 10/14/1998 23:03'!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate _ 22050.	BufferMSecs _ 100.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !MIDIInputParser initialize!MIDISynth removeSelector: #initialize!MIDISynth removeSelector: #removePort:!MIDISynth removeSelector: #addPort:!MIDISynth removeSelector: #midiPlayLoop!MIDISynth removeSelector: #removeAllPorts!MIDISynth class removeSelector: #new!MIDISynthChannel removeSelector: #channel!MIDISynthChannel removeSelector: #keyUp:vel:chan:!MIDISynthChannel removeSelector: #channel:!MIDIPianoKeyboardMorph removeSelector: #openMIDIPort0!MIDIPianoKeyboardMorph removeSelector: #midiPort:!MIDIPianoKeyboardMorph removeSelector: #openMIDIPort1!MIDIPianoKeyboardMorph removeSelector: #openMIDIPort:!ScorePlayerMorph removeSelector: #openMIDIPort0!ScorePlayerMorph removeSelector: #closeMIDI!ScorePlayerMorph removeSelector: #openMIDIPort1!SimpleMIDIPort removeSelector: #isOpen!SimpleMIDIPort removeSelector: #setPortNumber:!SimpleMIDIPort class removeSelector: #inputPortFromUser!SimpleMIDIPort class removeSelector: #outputPortFromUser!SimpleMIDIPort class removeSelector: #openOutputPortFromUser!SimpleMIDIPort class removeSelector: #primMIDIGetPortCount!SimpleMIDIPort class removeSelector: #portCount!SimpleMIDIPort class removeSelector: #openInputPortFromUser!SimpleMIDIPort class removeSelector: #portNameOf:!SimpleMIDIPort class removeSelector: #portDirectionalityOf:!SoundPlayer initialize!Smalltalk removeClassNamed: #SimpleMIDISynth!Smalltalk removeClassNamed: #SimpleMIDISynth!