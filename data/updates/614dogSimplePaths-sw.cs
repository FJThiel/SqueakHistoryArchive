'From Squeak 2.3 of January 14, 1999 on 28 January 1999 at 4:24:22 pm'!"Change Set:		dogSimplePaths-swDate:			28 January 1999Author:			Scott WallacePreliminary work to allow a simple way that any morph can have a path of points associated with it, with facilities for defining them, removing them, requesting that the morph follow the path, and for tile-scripting a morph to do so.At present some rather arbitrary limits are hard-coded concerning how many points comprise the path, sampling rate, etc.  Eventually this stuff might be parameterized."!!Morph methodsFor: 'e-toy support' stamp: 'sw 1/28/1999 16:13'!definePath	| points lastPoint aForm offset currentPoint dwell ownerPosition |	points _ OrderedCollection new: 70.	lastPoint _ nil.	aForm _ self imageForm.	offset _ aForm extent // 2.	ownerPosition _ owner position.	Cursor move show.	Sensor waitButton.	[Sensor anyButtonPressed and: [points size < 100]] whileTrue:		[currentPoint _ Sensor cursorPoint.		dwell _ 0.		currentPoint = lastPoint			ifTrue:				[dwell _ dwell + 1.				((dwell \\ 1000) = 0) ifTrue:					[self beep]]			ifFalse:				[self position: (currentPoint - offset).				self world displayWorld.				(Delay forMilliseconds: 20) wait.				points add: currentPoint.				lastPoint _ currentPoint]].	points size > 1		ifFalse:			[self inform: 'no path obtained']		ifTrue:			[points size = 100 ifTrue: [self playSoundNamed: 'croak'].			Transcript cr; show: 'path defined with', points size printString, ' points'.			self renderedMorph setProperty: #pathPoints toValue: 				(points collect: [:p | p - ownerPosition])].	Cursor normal show		! !!Morph methodsFor: 'e-toy support' stamp: 'sw 1/5/1999 10:05'!deletePath	self removeProperty: #pathPoints! !!Morph methodsFor: 'e-toy support' stamp: 'sw 1/5/1999 17:16'!followPath	| pathPoints offset |	(pathPoints _ self renderedMorph valueOfProperty: #pathPoints) ifNil: [^ self beep].	offset _ owner position - (self extent // 2).	pathPoints do:		[:aPoint |			self position: aPoint + offset.			self world displayWorld.			(Delay forMilliseconds: 20) wait]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 1/5/1999 11:14'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == owner "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	menu addLine.	menu add: 'draw new path' action: #definePath.	(argMorph hasProperty: #pathPoints) ifTrue:		[menu add: 'follow path' action: #followPath.		menu add: 'delete path' action: #deletePath].	menu addLine.	argMorph player ifNotNil: [argMorph player addPlayerMenuItemsTo: menu hand: self].	menu defaultTarget: self.	Preferences noviceMode ifFalse:		[argMorph addDebuggingItemsTo: menu hand: self].	^ menu! !!Player methodsFor: 'slots-kernel' stamp: 'sw 1/5/1999 10:18'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString isWorld |	isWorld _ self hasCostumeOfClass: WorldMorph.	(aCategory = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(aCategory = 'scripts') ifTrue:		[^ self tileScriptCommands].	(aCategory = 'basic') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))]			ifTrue:				[#((script beep:))]].	(aCategory = 'tests') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot isOverColor) (slot isUnderMouse) (slot colorSees))]			ifTrue:				[#()]].	(aCategory = 'color & border') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))]			ifTrue:				[#((slot color))]].	(aCategory = 'geometry') ifTrue:		[aList _ #((slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(aCategory = 'miscellaneous') ifTrue:		[aList _ isWorld			ifFalse:				[#((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]			ifTrue:				[#((script startScript:) (script stopScript:) (script pauseScript:))]].	(aCategory = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script followPath) (script goToRightOf:))].	(aCategory = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(aCategory = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(aCategory = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(aCategory = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(aCategory = 'playfield') ifTrue:		[aList _ #((script initiatePainting) (slot cursor) (slot valueAtCursor) (slot mouseX) (slot mouseY)(script roundUpStrays) (script unhideHiddenObjects))].	(aCategory = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: aCategory)			ifTrue:				[self tilePhraseSpecsForPlayerCategory: aCategory]			ifFalse:				[self error: 'faulty category: ', aCategory.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 1/5/1999 10:19'!followPath	self costume followPath! !!StandardScriptingSystem methodsFor: 'universal slots & scripts' stamp: 'sw 1/5/1999 10:21'!initStandardScriptInfo	"ScriptingSystem initStandardScriptInfo"	StandardScriptInfo _ Dictionary new.	#(	(command beep: sound)		(command bounce: sound)		(command clearTurtleTrails)		(command forward: number)		(command followPath)		(command goToNextCard)		(command goToPreviousCard)		(command goToRightOf: player)		(command hide)		(command initiatePainting)		(command liftAllPens)		(command lowerAllPens)		(command makeNewDrawingIn: player)		(command moveToward: player)		(command pauseScript: string)		(command roundUpStrays)		(command show)		(command startScript: string)		(command stopScript: string)		(command turn: number)		(command unhideHiddenObjects)		(command wearCostumeOf: player)		(command wrap)		(command newCard)		(command deleteCard)		(command initiatePainting)		(command nextPage)		(command previousPage)		(command firstPage)		(command lastPage)		(command goto: player ))	do:		[:anArray | StandardScriptInfo at: anArray second put: anArray]! !"Postscript:"ScriptingSystem initStandardScriptInfo.!