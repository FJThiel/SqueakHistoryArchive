'From Squeak 2.3 of January 14, 1999 on 2 April 1999 at 3:30:48 pm'!"Change Set:		MorphicErrors-arDate:			2 April 1999Author:			Andreas RaabThis change set adds error handling for morphic drawing methods. It also adds two menu items to a morphs debug menu that allow to resume drawing/stepping after an error has occured. It also fixes a problem in MorphExtension>>printOn: due to using nil>>size.To test the changes:* go to a morphic project* from the 'experimental' morphs choose a DrawErrorMorph (will immediately result in a drawing error)* Open an inspector on the DrawErrorMorph and select 'self' (will result in an error in the step method of the inspector.* Try to resume drawing from the DrawErrorMorphs debug menu or stepping from the Inspectors SystemWindows debug menu."!Morph subclass: #DrawErrorMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!Morph methodsFor: 'drawing' stamp: 'ar 4/2/1999 13:13'!drawErrorOn: aCanvas	"The morph (or one of its submorphs) had an error in its drawing method."	aCanvas		frameAndFillRectangle: bounds		fillColor: Color red		borderWidth: 1		borderColor: Color yellow.	aCanvas line: bounds topLeft to: bounds bottomRight width: 1 color: Color yellow.	aCanvas line: bounds topRight to: bounds bottomLeft width: 1 color: Color yellow.! !!Morph methodsFor: 'drawing' stamp: 'ar 4/2/1999 15:09'!fullDrawOn: aCanvas	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	submorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!Morph methodsFor: 'debug and other' stamp: 'ar 4/2/1999 15:10'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	(self hasProperty: #errorOnDraw) ifTrue:[		aMenu add:'start drawing again' target: self action:#resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:[		aMenu add:'start stepping again' target: self action:#resumeAfterStepError.		aMenu addLine].	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	World ifNil:		[aMenu add: 'inspect morph (in MVC)' action: #inspectArgument.		aMenu add: 'inspect morph' action: #inspectArgumentInMorphic]		ifNotNil:		[aMenu add: 'inspect morph' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu addLine.	aMenu add: 'call #tempCommand' action: #callTempCommand.	aMenu add: 'define #tempCommand' action: #defineTempCommand.	aMenu addLine.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'ar 4/2/1999 15:11'!resumeAfterDrawError	self changed.	self removeProperty:#errorOnDraw.	self changed.! !!Morph methodsFor: 'debug and other' stamp: 'ar 4/2/1999 15:22'!resumeAfterStepError	"Resume stepping after an error has occured."	self startStepping. "Will #step"	self removeProperty:#errorOnStep. "Will remove prop only if #step was okay"! !!DrawErrorMorph commentStamp: 'ar 4/2/1999 12:12' prior: 0!This morph simply invokes errors during drawing and stepping.!!DrawErrorMorph methodsFor: 'drawing' stamp: 'ar 4/2/1999 12:13'!drawOn: aCanvas	aCanvas error:'DrawErrorMorph drawOn: invoked'! !!DrawErrorMorph methodsFor: 'printing' stamp: 'ar 4/2/1999 12:15'!printOn: aStream	"Indirectly invokes an error during stepping in an Inspector"	aStream error:'DrawErrorMorph>>printOn: invoked'! !!MorphExtension methodsFor: 'other' stamp: 'ar 4/2/1999 15:19'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == false ifTrue: [aStream nextPutAll: '[not visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties ifNil:[^self].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !!MorphWorldView methodsFor: 'all' stamp: 'ar 4/2/1999 12:19'!displayView	"This method is called by the system when the top view is framed or moved."	| topView |	model viewBox: self insetDisplayBox.	topView _ self topView.	(topView == ScheduledControllers scheduledControllers first view		or: [topView cacheBitsAsTwoTone not])		ifTrue: [model displayWorldSafely]		ifFalse: [model displayWorldAsTwoTone].  "just restoring the screen"! !!WorldMorph methodsFor: 'install / exit' stamp: 'ar 4/2/1999 12:19'!install	self viewBox: Display boundingBox.	hands do: [:h | h initForEvents].	self installFlaps.	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!WorldMorph methodsFor: 'drawing' stamp: 'ar 4/2/1999 15:08'!displayWorldSafely	"Update this world's display and keep track of errors during draw methods."	| oldHandler errCtx errMorph |	oldHandler _ Processor activeProcess errorHandler.	[self displayWorld] ifError:[:err :rcvr|		"Handle a drawing error"		errCtx _ thisContext.		[errCtx _ errCtx sender.		"Search the sender chain to find the morph causing the problem"		[errCtx notNil and:[(errCtx receiver isKindOf: Morph) not]] 			whileTrue:[errCtx _ errCtx sender].		"If we're at the root of the context chain then we have a fatal drawing problem"		errCtx == nil ifTrue:[^self handleFatalDrawingError: err].		errMorph _ errCtx receiver.		"If the morph causing the problem has already the #drawError flag set,		then search for the next morph above in the caller chain."		errMorph hasProperty: #errorOnDraw] whileTrue.		errMorph setProperty: #errorOnDraw toValue: true.		"Install the old error handler, so we can re-raise the error"		Processor activeProcess errorHandler: oldHandler.		rcvr error: err.	].! !!WorldMorph methodsFor: 'drawing' stamp: 'ar 4/2/1999 12:59'!handleFatalDrawingError: errMsg	"Handle a fatal drawing error."	Smalltalk isMorphic ifFalse:[^self error: errMsg]. "Can still handle it from MVC"	Display deferUpdates: false. "Just in case"	self primitiveError: errMsg.	"Hm... we should jump into a 'safe' project here, but how do we find it?!!"! !!WorldMorph methodsFor: 'stepping' stamp: 'ar 4/2/1999 15:08'!runStepMethods	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == self			ifTrue: [				wakeupTime <= now					ifTrue: [						morphToStep step.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse: [				deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]].	] ifError:[:err :rcvr|		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"	].	deletions ifNotNil: [		deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ar 4/2/1999 12:19'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."	"process user input events, but only for remote hands"	hands do: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			activeHand _ h.			h processEvents.			activeHand _ nil]].	self runStepMethods.	self displayWorldSafely.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ar 4/2/1999 12:19'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	hands do: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorldSafely.! !