'From Squeak3.0 of 4 February 2001 [latest update: #3414] on 6 February 2001 at 11:23:36 am'!"Change Set:		macintoshVM3.0.2UpdatesJMMDate:			6 February 2001Author:			johnmci@smalltalkconsulting.comUpdate the macintosh source to match the V3.02VM"!!FFIPlugin class methodsFor: 'C support code' stamp: 'JMM 2/6/2001 10:55'!sqMacFFIPPCFile^'/*****************************************************************************   PROJECT: Squeak foreign function interface*   FILE:    sqMacFFIPPC.c*   CONTENT: Mac/PPC specific support for the foreign function interface**   AUTHOR:  Andreas Raab (ar)*   ADDRESS: Walt Disney Imagineering, Glendale, CA*   EMAIL:   Andreas.Raab@disney.com*   RCSID:   $Id$**   NOTES:******************************************************************************/#include "sq.h"#include "sqFFI.h"/* note: LONGLONG is usually declared by universal headers */#ifndef LONGLONG#define LONGLONG long long#endifextern struct VirtualMachine *interpreterProxy;#define primitiveFail() interpreterProxy->primitiveFail();#define GP_MAX_REGS 8#define FP_MAX_REGS 13/* Values passed in GPR3-GPR10 */static int GPRegs[8];/* Nr of GPRegs used so far */static int gpRegCount = 0;/* Values passed in FPR1-FPR13 */static double FPRegs[13];/* Nr of FPRegs used so far */static int fpRegCount = 0;/* Max stack size */#define FFI_MAX_STACK 512/* The stack used to assemble the arguments for a call */static int   ffiStack[FFI_MAX_STACK];/* The stack pointer while filling the stack */static int   ffiStackIndex = 0;/* The area for temporarily allocated strings */static char *ffiTempStrings[FFI_MAX_STACK];/* The number of temporarily allocated strings */static int   ffiTempStringCount = 0;/* The return values for calls */static int      intReturnValue;static LONGLONG longReturnValue;static double   floatReturnValue;static int *structReturnValue = NULL;/**************************************************************/#define ARG_CHECK() if(gpRegCount >= GP_MAX_REGS && ffiStackIndex >= FFI_MAX_STACK) return primitiveFail();#define ARG_PUSH(value) { \	ARG_CHECK(); \	if(gpRegCount < GP_MAX_REGS) GPRegs[gpRegCount++] = value; \	ffiStack[ffiStackIndex++] = value; \}/*****************************************************************************//*****************************************************************************//*  ffiInitialize:	Announce that the VM is about to do an external function call. */int ffiInitialize(void){	ffiStackIndex = 0;	gpRegCount = 0;	fpRegCount = 0;	floatReturnValue = 0.0;	return 1;}/*  ffiSupportsCallingConvention:	Return true if the support code supports the given calling convention. */int ffiSupportsCallingConvention(int callType){	if(callType == FFICallTypeCDecl) return 1;	if(callType == FFICallTypeApi) return 1;	return 0;}int ffiAlloc(int byteSize){	return (int) malloc(byteSize);}int ffiFree(int ptr){	if(ptr) free((void*)ptr);	return 1;}/*****************************************************************************//*****************************************************************************/int ffiPushSignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedChar(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedByte(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedShort(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushUnsignedInt(int value) { 	ARG_PUSH(value); 	return 1; }int ffiPushSignedLongLong(int low, int high){	ARG_PUSH(high);	ARG_PUSH(low);	return 1;}int ffiPushUnsignedLongLong(int low, int high) { 	ARG_PUSH(high); 	ARG_PUSH(low); 	return 1; }int ffiPushSingleFloat(double value){	float floatValue = (float) value;	if(fpRegCount < FP_MAX_REGS) {		/* Still space in FPRegs - so we use the more accurate double value */		FPRegs[fpRegCount++] = value;	}	/* Note: Even for args that are passed in FPRegs 	   we pass the actual 32bit value in either GPRegs	   or stack frame for varargs calls. */	ARG_PUSH(*(int*)(&floatValue));	return 1;}int ffiPushDoubleFloat(double value){	if(fpRegCount < FP_MAX_REGS) {		/* Still space in FPRegs */		FPRegs[fpRegCount++] = value;	}	/* Note: Even for args that are passed in FPRegs 	   we pass the actual 64bit value in either GPRegs	   or stack frame for varargs calls. */	ARG_PUSH(((int*)(&value))[1]);	ARG_PUSH(((int*)(&value))[0]);	return 1;}int ffiPushStructureOfLength(int pointer, int *structSpec, int specSize){	int i, typeSpec;	int *data = (int*) pointer;	for(i = 0; i<specSize; i++) {		typeSpec = structSpec[i];		if(typeSpec & FFIFlagPointer) {			ARG_PUSH(*data);			data++;		} else if(typeSpec & FFIFlagStructure) {			/* embedded structure */		} else {			/* atomic type */			int atomicType = (typeSpec & FFIAtomicTypeMask) >> FFIAtomicTypeShift;			switch(atomicType) {				case FFITypeUnsignedChar:				case FFITypeUnsignedByte:					ffiPushUnsignedByte(*(unsigned char*)data);					break;				case FFITypeSignedChar:				case FFITypeSignedByte:					ffiPushSignedByte(*(signed char*)data);					break;				case FFITypeUnsignedShort:					ffiPushUnsignedShort(*(unsigned short*)data);					break;				case FFITypeSignedShort:					ffiPushSignedShort(*(signed short*)data);					break;				case FFITypeUnsignedInt:					ffiPushUnsignedInt(*(unsigned int*)data);					break;				case FFITypeSignedInt:					ffiPushSignedInt(*(signed int*)data);					break;				case FFITypeUnsignedLongLong:					ffiPushUnsignedLongLong( ((unsigned int*)data)[1], ((unsigned int*)data)[0]);					break;				case FFITypeSignedLongLong:					ffiPushSignedLongLong( ((signed int*)data)[1], ((signed int*)data)[0]);					break;				case FFITypeSingleFloat:					ffiPushSingleFloat( *(float*)data);					break;				case FFITypeDoubleFloat:					{ double fArg;					  ((int*)&fArg)[0] = ((int*)data)[0];					  ((int*)&fArg)[1] = ((int*)data)[1];					  ffiPushDoubleFloat(fArg);					}					break;				default:					return primitiveFail();			}			data = (int*) ((int)data + (typeSpec & FFIStructSizeMask));		}	}	return 1;}int ffiPushPointer(int pointer){	ARG_PUSH(pointer);	return 1;}int ffiPushStringOfLength(int srcIndex, int length){	char *ptr;	ARG_CHECK(); /* fail before allocating */	ptr = (char*) malloc(length+1);	if(!!ptr) return primitiveFail();	memcpy(ptr, (void*)srcIndex, length);	ptr[length] = 0;	ffiTempStrings[ffiTempStringCount++] = ptr;	ARG_PUSH((int)ptr);	return 1;}/*****************************************************************************//*****************************************************************************//*  ffiCanReturn:	Return true if the support code can return the given type. */int ffiCanReturn(int *structSpec, int specSize){	int header = *structSpec;	if(header & FFIFlagPointer) return 1;	if(header & FFIFlagStructure) {		/* structs are always returned as pointers to hidden structures */		int structSize = header & FFIStructSizeMask;		structReturnValue = malloc(structSize);		if(!!structReturnValue) return 0;		ARG_PUSH((int)structReturnValue);	}	return 1;}/*  ffiReturnFloatValue:	Return the value from a previous ffi call with float return type. */double ffiReturnFloatValue(void){	return floatReturnValue;}/*  ffiLongLongResultLow:	Return the low 32bit from the 64bit result of a call to an external function */int ffiLongLongResultLow(void){	return ((int*) &longReturnValue)[1];}/*  ffiLongLongResultHigh:	Return the high 32bit from the 64bit result of a call to an external function */int ffiLongLongResultHigh(void){	return ((int*) &longReturnValue)[0];}/*  ffiStoreStructure:	Store the structure result of a previous ffi call into the given address. */int ffiStoreStructure(int address, int structSize){	if(structReturnValue) {		memcpy((void*)address, (void*)structReturnValue, structSize);	} else {		memcpy((void*)address, (void*)&intReturnValue, structSize);  	}  	return 1;}/*  ffiCleanup:	Cleanup after a foreign function call has completed.	The generic support code only frees the temporarily	allocated strings. */int ffiCleanup(void){	int i;	for(i=0; i<ffiTempStringCount; i++)		free(ffiTempStrings[i]);	ffiTempStringCount = 0;	if(structReturnValue) {		free(structReturnValue);		structReturnValue = NULL;	}	return 1;}/*****************************************************************************//*****************************************************************************/asm int ffiCallAddressOf(int);#if TARGET_CPU_PPCasm int ffiCallAddressOf(int addr) {	/* Save link register */	mflr r0	stw r0, 8(SP)	/* get stack index and preserve it for copying stuff later */	lwz r4, ffiStackIndex(RTOC)	/* compute frame size */	rlwinm r5, r4, 2, 0, 29  /* ffiStackIndex words to bytes (e.g., "slwi r5, r4, 2") */	addi r5, r5, 24 /* linkage area */	neg  r5, r5     /* stack goes down */	/* adjust stack frame */	stwux SP, SP, r5	/* load the stack frame area */	/* note: r4 == ffiStackIndex */	addi r5, SP, 24         /* dst = SP + linkage area */	lwz r6, ffiStack(RTOC)  /* src = ffiStack */	li r7, 0                /* i = 0 */	b nextItemcopyItem:	rlwinm r8, r7, 2, 0, 29 /* r8 = i << 2 (e.g., "slwi r8, r7, 2") */	lwzx r0, r6, r8         /* r0 = ffiStack[r8] */	addi r7, r7, 1          /* i = i + 1 */	stwx r0, r5, r8         /* dst[r8] = r0 */nextItem:	cmpw r7, r4             /* i < ffiStackIndex ? */	blt copyItem	/* Keep addr in GPR0 so we can load all regs beforehand */	mr r0, r3	/* load all the floating point registers */	lwz r3, fpRegCount	lwz r12, FPRegs(RTOC)	cmpwi r3, 0     /* skip all fpregs if no FP values used */	blt _0_fpregs	cmpwi r3, 8	blt _7_fpregs   /* skip last N fpregs if unused */_all_fpregs:	lfd  fp8, 56(r12)	lfd  fp9, 64(r12)	lfd fp10, 72(r12)	lfd fp11, 80(r12)	lfd fp12, 88(r12)	lfd fp13, 96(r12)_7_fpregs:	lfd  fp1,  0(r12)	lfd  fp2,  8(r12)	lfd  fp3, 16(r12)	lfd  fp4, 24(r12)	lfd  fp5, 32(r12)	lfd  fp6, 40(r12)	lfd  fp7, 48(r12)_0_fpregs:	/* load all the general purpose registers */	lwz  r3, gpRegCount	lwz  r12, GPRegs(RTOC)	cmpwi r3, 4	blt _4_gpregs    /* skip last four gpregs if unused */_all_gpregs:	lwz  r7, 16(r12)	lwz  r8, 20(r12)	lwz  r9, 24(r12)	lwz r10, 28(r12)_4_gpregs:	lwz  r3,  0(r12)	lwz  r4,  4(r12)	lwz  r5,  8(r12)	lwz  r6, 12(r12)_0_gpregs:	/* go calling out */	mr r12, r0      /* tvector into GPR12 */	/* Note: The code below is nearly identical to to what''s described in		"MacOS Runtime Architectures"		Chapter 2, Listing 2-2, pp. 2-11	*/	lwz r0, 0(r12)  /* get entry point */	stw r2, 20(SP)  /* save GPR2 */	mtctr r0        /* move entry point into count register */	lwz r2, 4(r12)  /* new base pointer */	bctrl           /* jump through count register and link */	lwz r2, 20(SP)  /* restore GPR2 */	lwz SP, 0(SP)   /* restore frame */	/* store the result of the call */	stw r3, intReturnValue(RTOC)	lwz r12, longReturnValue(RTOC)	stw r3, 0(r12)	stw r4, 4(r12)	stfd fp1, floatReturnValue(RTOC)	/* and get out of here */	lwz r0, 8(SP)	mtlr r0	blr}#elseasm int ffiCallAddressOf(int addr) {}#endifint ffiCallAddressOfWithPointerReturn(int fn, int callType){	return ffiCallAddressOf(fn);}int ffiCallAddressOfWithStructReturn(int fn, int callType, int* structSpec, int specSize){	return ffiCallAddressOf(fn);}int ffiCallAddressOfWithReturnType(int fn, int callType, int typeSpec){	return ffiCallAddressOf(fn);}/*****************************************************************************//*****************************************************************************//*****************************************************************************//************ Test functions for the foreign function interface **************//*****************************************************************************//*****************************************************************************//*****************************************************************************/#ifndef NO_FFI_TESTtypedef struct ffiTestPoint2 {	int x;	int y;} ffiTestPoint2;typedef struct ffiTestPoint4 {	int x;	int y;	int z;	int w;} ffiTestPoint4;#pragma export onEXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4);EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4);EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4);EXPORT(float) ffiTestFloats(float f1, float f2);EXPORT(double) ffiTestDoubles(double d1, double d2);EXPORT(char *) ffiPrintString(char *string);EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2);EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2);EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2);EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2);#pragma export off/* test passing characters */EXPORT(char) ffiTestChars(char c1, char c2, char c3, char c4) {	printf("4 characters came in as\nc1 = %c (%x)\nc2 = %c (%x)\nc3 = %c (%x)\nc4 = %c (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return ''C'';}/* test passing shorts */EXPORT(short) ffiTestShorts(short c1, short c2, short c3, short c4) {	printf("4 shorts came in as\ns1 = %d (%x)\ns2 = %d (%x)\ns3 = %d (%x)\ns4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return -42;}/* test passing ints */EXPORT(int) ffiTestInts(int c1, int c2, int c3, int c4) {	printf("4 ints came in as\ni1 = %d (%x)\ni2 = %d (%x)\ni3 = %d (%x)\ni4 = %d (%x)\n", c1, c1, c2, c2, c3, c3, c4, c4);	return 42;}/* test passing and returning floats */EXPORT(float) ffiTestFloats(float f1, float f2) {	printf("The two floats are %f and %f\n", f1, f2);	return (float) (f1 + f2);}/* test passing and returning doubles */EXPORT(double) ffiTestDoubles(double d1, double d2) {	printf("The two floats are %f and %f\n", (float)d1, (float)d2);	return d1+d2;}/* test passing and returning strings */EXPORT(char*) ffiPrintString(char *string) {	printf("%s\n", string);	return string;}/* test passing and returning 64bit structures */EXPORT(ffiTestPoint2) ffiTestStruct64(ffiTestPoint2 pt1, ffiTestPoint2 pt2) {	ffiTestPoint2 result;	printf("pt1.x = %d\npt1.y = %d\npt2.x = %d\npt2.y = %d\n",			pt1.x, pt1.y, pt2.x, pt2.y);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	return result;}/* test passing and returning large structures */EXPORT(ffiTestPoint4) ffiTestStructBig(ffiTestPoint4 pt1, ffiTestPoint4 pt2) {	ffiTestPoint4 result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1.x, pt1.y, pt1.z, pt1.w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2.x, pt2.y, pt2.z, pt2.w);	result.x = pt1.x + pt2.x;	result.y = pt1.y + pt2.y;	result.z = pt1.z + pt2.z;	result.w = pt1.w + pt2.w;	return result;}/* test passing and returning pointers */EXPORT(ffiTestPoint4*) ffiTestPointers(ffiTestPoint4 *pt1, ffiTestPoint4 *pt2) {	ffiTestPoint4 *result;	printf("pt1.x = %d\npt1.y = %d\npt1.z = %d\npt1.w = %d\n",			pt1->x, pt1->y, pt1->z, pt1->w);	printf("pt2.x = %d\npt2.y = %d\npt2.z = %d\npt2.w = %d\n",			pt2->x, pt2->y, pt2->z, pt2->w);	result = (ffiTestPoint4*) malloc(sizeof(ffiTestPoint4));	result->x = pt1->x + pt2->x;	result->y = pt1->y + pt2->y;	result->z = pt1->z + pt2->z;	result->w = pt1->w + pt2->w;	return result;}/* test passing and returning longlongs */EXPORT(LONGLONG) ffiTestLongLong(LONGLONG i1, LONGLONG i2) {	return i1 + i2;}#endif /* NO_FFI_TEST */'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/6/2001 11:14'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		Clipboard clipboardText: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 91 184 0 0 0 114 0 10 0 0 0 114 140 111 0 43 0 5 1 24 2 0 0 0 0 0 0 0 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 0 0 0 0 13 31 0 0 0 0 0 13 218 2 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 186 192 77 77 80 82 67 87 73 69 1 0 4 47 0 245 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 0 114 0 0 25 110 0 0 0 0 0 16 49 217 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 220 45 77 77 80 82 67 87 73 69 1 0 4 110 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 59 0 16 181 174 127 194 181 175 1 132 0 0 13 31 0 0 27 191 0 0 0 0 0 11 26 238 0 0 2 170 0 0 1 124 0 0 0 0 15 0 83 113 117 101 97 107 65 112 112 46 114 0 1 48 155 84 69 88 84 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 104 0 0 0 0 15 0 66 193 212 165 47 158 104 38 183 219 249 217 33 168 151 12 136 53 189 184 158 14 233 171 185 188 252 36 85 186 68 105 32 221 147 163 179 129 148 246 162 31 24 235 185 98 218 101 160 56 155 179 209 51 153 16 169 186 131 139 49 67 115 239 159 135 201 102 194 30 232 134 74 94 72 73 53 209 51 0 164 170 218 80 239 206 105 215 91 90 51 83 245 201 43 25 56 235 71 7 130 202 80 0 66 193 212 157 170 210 35 52 27 93 136 197 106 52 54 31 166 122 205 231 32 32 112 160 40 138 126 3 77 99 4 251 242 199 125 87 169 103 99 226 123 60 70 128 113 18 28 85 6 189 121 109 31 26 249 161 83 169 157 62 74 239 8 51 45 186 94 58 49 252 46 209 169 153 202 106 248 205 178 15 4 139 59 160 209 168 125 168 73 48 103 120 110 199 109 171 159 179 239 33 94 118 136 247 133 234 179 177 46 218 151 77 116 44 159 93 94 44 99 70 93 125 137 53 84 131 32 59 239 13 28 34 65 92 91 104 119 79 119 174 134 219 228 67 30 37 182 200 207 220 0 237 187 20 146 233 200 152 182 39 167 14 242 53 180 240 195 154 154 94 91 182 52 134 249 136 119 67 194 147 228 97 60 211 48 22 65 190 202 99 103 114 208 10 131 161 3 87 31 64 250 4 254 133 169 217 77 183 225 106 142 240 240 180 146 248 39 192 170 88 102 69 95 13 89 148 174 206 78 162 131 133 161 167 150 32 158 248 178 173 101 227 217 102 143 206 171 62 75 41 237 239 9 58 126 14 226 107 122 250 208 40 209 10 252 105 101 26 155 10 18 126 136 104 210 186 8 64 134 82 245 212 110 151 241 61 69 16 181 128 165 251 123 137 63 121 161 161 183 56 176 164 4 136 161 23 48 88 225 129 48 129 37 151 67 233 215 152 90 89 82 27 227 240 224 102 238 138 80 14 201 181 17 19 136 193 127 207 108 171 212 101 238 237 175 10 248 251 8 248 107 203 87 203 119 235 140 103 161 208 168 170 55 199 88 185 214 52 170 233 214 179 94 170 196 230 181 174 40 0 165 165 165 165 1 0 0 62 0 0 181 174 119 219 182 165 137 55 0 0 25 110 0 0 41 81 0 0 0 0 0 14 76 182 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 65 112 112 46 114 115 114 99 0 1 22 98 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 40 109 0 0 13 34 0 0 0 0 15 0 66 193 213 19 32 207 221 161 198 69 165 49 49 163 44 68 182 220 208 98 3 104 90 104 50 121 149 179 221 229 227 218 24 177 155 55 76 59 170 223 31 186 42 107 230 227 232 78 210 112 78 144 78 101 153 20 100 21 113 34 86 121 4 82 215 232 227 236 158 8 177 190 230 223 83 84 237 148 7 170 219 251 49 107 209 121 95 19 142 221 245 229 208 93 102 171 66 93 51 91 15 192 115 41 146 47 38 44 128 149 206 19 73 214 243 63 134 185 162 63 190 209 118 46 232 38 160 233 103 92 179 67 170 147 238 96 5 178 108 31 198 142 27 71 0 252 18 157 84 217 115 240 55 138 8 134 100 181 201 91 154 43 221 56 198 203 54 203 223 246 78 211 75 62 202 147 101 108 145 98 255 87 81 19 116 84 105 20 53 35 186 106 250 114 137 91 30 167 101 76 166 46 241 174 167 210 92 15 66 47 106 89 111 95 216 169 157 97 204 203 175 67 131 100 228 115 101 202 102 201 85 197 128 102 224 152 248 208 22 182 13 65 185 43 236 146 8 103 164 68 199 167 90 161 44 115 100 75 148 212 133 205 185 240 91 254 62 54 53 239 150 84 98 211 70 114 120 183 103 103 115 93 178 126 224 111 251 255 187 2 190 193 166 28 139 27 108 150 55 252 38 95 40 204 61 106 168 57 178 195 169 32 120 204 107 253 57 197 232 114 108 33 166 115 221 202 25 154 147 237 211 246 212 49 74 55 186 91 190 105 219 116 226 226 36 175 193 108 174 164 118 229 107 74 31 1 243 123 184 154 227 118 219 112 165 164 185 116 70 7 186 27 160 3 238 43 56 239 52 158 217 130 219 45 109 54 78 222 17 74 25 52 114 1 227 42 217 72 253 223 216 56 77 220 203 181 240 246 146 55 97 58 137 154 1 231 100 197 96 17 176 142 199 47 194 252 250 110 162 91 79 145 135 5 163 208 132 42 60 79 75 147 68 55 152 119 214 213 47 14 149 84 134 76 87 74 254 254 151 9 229 163 207 208 179 60 92 174 14 37 241 171 44 103 246 230 215 87 171 209 190 75 21 18 75 230 51 212 212 246 83 245 155 110 81 206 16 192 47 216 206 4 63 65 137 214 29 239 126 119 2 182 31 164 239 106 133 29 66 19 226 251 232 134 56 34 119 125 65 232 112 67 184 175 168 244 226 251 181 77 6 213 211 204 202 161 6 92 48 93 184 21 51 155 250 118 21 207 76 43 130 241 200 165 82 167 22 21 167 179 103 220 7 4 88 240 101 176 206 116 162 241 135 0 10 115 20 211 77 153 10 46 91 217 20 19 204 10 213 236 16 129 111 2 83 111 212 51 126 164 234 96 193 148 6 235 82 208 152 211 189 130 119 188 170 223 28 40 0 149 33 254 222 30 77 113 122 236 51 226 61 0 56 8 192 109 143 26 152 21 232 232 237 44 110 163 84 50 168 238 201 160 223 48 127 162 72 254 221 64 197 228 169 224 61 18 69 244 153 213 228 229 105 198 64 71 105 193 141 62 155 13 181 202 60 90 237 125 155 116 93 50 112 251 186 62 254 11 160 151 67 238 90 170 23 8 180 61 134 236 106 155 7 71 192 91 199 44 198 20 2 194 108 41 250 103 76 91 134 173 18 128 52 181 167 20 31 161 38 104 165 178 4 82 104 44 59 107 131 0 98 93 113 119 73 254 60 247 86 212 76 120 247 123 137 227 100 233 18 218 72 67 84 113 35 137 4 20 221 154 119 125 62 154 120 102 246 163 167 196 173 90 209 241 240 73 119 50 74 93 203 76 86 158 233 219 98 194 198 43 14 118 88 249 224 19 225 236 202 101 54 70 49 59 12 235 33 236 132 28 121 19 159 182 142 176 8 122 128 22 189 222 111 146 240 249 142 48 131 252 116 82 38 55 112 138 39 245 215 200 255 27 73 219 240 40 155 140 98 171 166 240 76 205 232 154 208 101 67 79 119 38 9 20 47 254 27 154 227 188 0 29 212 245 218 157 14 3 108 78 55 11 31 76 99 11 45 135 246 213 52 131 107 5 147 139 169 12 26 85 161 207 255 47 109 126 240 162 245 24 131 78 151 27 124 170 80 72 5 225 243 208 159 32 94 134 175 143 52 228 207 123 18 237 238 69 69 150 84 30 182 215 91 1 95 173 65 216 194 245 65 252 39 54 213 19 204 211 162 186 15 228 51 221 165 167 111 102 55 199 58 255 168 223 203 4 223 37 108 103 155 70 74 229 178 212 114 235 171 248 64 219 52 168 74 188 136 5 134 27 13 137 111 213 188 158 51 1 1 226 201 163 195 162 219 54 140 207 153 244 245 197 136 65 119 87 171 227 161 24 44 65 78 240 61 184 88 64 127 160 8 239 63 87 123 114 253 165 97 184 143 244 70 251 69 168 165 198 250 68 173 221 66 74 182 136 167 157 187 101 0 3 199 99 178 72 133 14 59 43 186 126 51 129 78 136 86 143 155 102 81 205 64 175 219 215 12 103 151 53 166 130 123 106 195 248 67 57 149 223 215 246 249 18 134 52 150 9 142 135 56 239 47 65 237 180 8 113 145 97 91 215 194 122 173 191 233 108 175 117 27 99 144 199 126 167 78 230 118 66 144 20 6 41 0 253 43 221 224 131 240 3 162 133 12 142 236 115 65 34 172 198 53 30 25 10 228 215 86 142 192 150 102 112 81 93 67 233 34 141 36 87 22 80 124 111 242 175 115 193 226 115 144 213 135 77 188 28 15 23 147 159 179 215 81 137 182 133 174 133 14 17 183 160 204 9 194 161 33 144 243 90 25 19 244 183 35 58 74 137 171 59 86 58 216 154 236 255 67 224 120 168 186 119 74 174 65 8 248 3 176 94 237 144 124 82 237 91 171 54 5 250 176 80 67 219 126 99 115 4 19 227 203 109 190 143 102 247 227 111 125 109 76 22 76 252 234 114 214 54 168 56 28 249 192 7 149 130 161 180 245 169 139 169 18 137 139 178 111 194 50 46 207 239 25 75 75 143 91 111 134 106 151 164 67 224 252 164 193 252 244 207 90 156 117 129 175 152 146 90 178 51 168 143 202 151 134 154 71 108 132 77 150 212 195 165 20 220 107 22 95 77 113 170 253 78 244 163 54 38 138 170 225 211 74 219 114 241 194 53 34 209 194 83 204 209 244 138 228 116 200 239 147 125 118 91 177 252 6 89 219 176 197 212 8 79 5 155 94 75 82 162 201 88 49 17 141 96 121 127 192 132 64 167 181 125 91 199 4 86 70 126 49 114 84 197 24 186 55 37 252 237 43 87 237 122 115 26 237 53 227 173 210 253 120 4 209 96 62 200 30 167 249 175 251 164 108 194 60 9 222 26 109 230 182 164 36 143 252 9 27 70 34 0 231 120 38 36 19 213 50 165 169 248 104 62 3 94 20 114 73 134 76 120 15 34 192 61 229 148 49 168 179 226 151 112 158 101 59 184 136 79 7 58 251 228 103 90 169 106 122 152 249 217 144 206 213 58 120 22 25 229 166 136 17 17 122 60 245 55 112 210 225 124 53 162 134 178 160 165 184 100 193 76 85 154 214 17 144 152 95 80 239 120 173 249 6 199 233 37 32 17 54 231 188 237 140 74 71 218 131 12 62 142 234 143 16 248 249 231 76 60 200 79 234 134 249 88 18 99 50 90 176 104 41 43 218 15 59 166 211 92 16 50 6 61 85 236 190 246 11 187 211 219 213 212 81 50 171 45 96 17 148 149 158 183 22 84 153 244 219 89 142 38 48 246 225 23 99 32 222 191 145 18 167 218 172 153 79 167 203 55 40 151 41 101 150 182 108 202 25 129 187 162 74 68 67 147 158 88 141 249 169 62 71 26 105 210 133 80 110 136 141 198 67 131 137 10 220 31 103 89 57 206 216 111 119 195 246 170 236 57 168 66 189 109 146 34 160 67 145 77 145 105 150 52 203 68 194 98 140 20 143 198 224 255 79 26 171 241 163 171 180 218 154 70 252 131 216 212 239 118 198 156 11 177 95 190 127 244 179 113 203 201 230 72 177 202 108 221 202 79 208 149 211 99 49 181 112 50 242 111 208 127 4 94 197 244 131 150 227 186 250 13 102 136 2 250 102 25 18 198 153 197 56 73 15 38 151 1 102 219 103 177 154 43 217 73 21 36 222 41 170 165 86 198 174 1 245 202 180 165 126 23 136 212 223 72 139 49 103 112 25 121 27 62 82 78 187 78 62 230 75 176 122 26 255 169 179 10 196 25 79 183 108 129 76 70 141 218 126 7 187 72 86 185 102 176 204 23 223 99 207 236 176 213 194 10 21 172 136 60 74 237 252 73 96 132 190 88 248 238 75 19 119 132 150 36 58 200 73 26 235 206 250 102 189 29 175 212 54 150 18 66 109 71 9 86 77 211 223 79 181 195 173 104 123 188 116 168 177 245 198 135 186 99 182 127 237 46 116 234 31 142 131 59 159 45 130 141 226 179 68 22 163 150 44 71 96 48 103 167 184 249 187 138 141 39 135 200 71 161 179 222 149 167 80 168 158 133 170 184 73 1 75 70 100 147 246 103 94 185 151 62 87 193 17 239 68 22 153 27 59 182 97 170 32 48 191 144 221 48 113 36 155 179 97 231 241 110 199 231 245 85 148 163 153 90 16 119 193 176 66 29 110 105 209 186 239 58 143 195 85 43 33 153 175 149 117 254 53 100 114 25 198 93 82 162 215 13 39 105 7 204 187 90 136 213 94 47 58 117 53 68 129 167 153 238 139 164 248 78 76 62 16 51 106 196 100 75 106 86 2 216 218 186 202 233 244 215 184 88 67 191 203 155 208 9 81 159 25 65 243 181 35 27 250 23 110 139 42 26 16 228 1 139 180 89 97 202 255 21 237 159 70 3 211 14 157 103 49 54 217 142 65 202 129 28 227 169 167 2 133 91 225 132 241 103 65 54 193 45 21 4 58 195 107 191 155 69 70 113 101 96 91 6 5 169 96 110 82 240 103 42 200 45 221 49 103 55 159 246 127 58 217 38 179 214 14 28 187 218 4 188 229 172 243 121 41 220 229 137 241 195 133 206 7 53 174 70 28 205 101 69 189 115 227 107 207 252 84 69 35 32 41 141 140 62 172 128 37 65 164 38 126 120 250 255 42 22 122 214 135 67 112 134 123 230 178 253 223 110 144 105 71 165 225 195 211 133 46 143 247 137 137 106 239 117 12 93 175 115 147 18 66 179 84 96 222 29 206 241 142 232 172 31 52 118 75 20 28 201 202 188 219 22 81 156 190 111 117 102 134 80 91 66 108 241 106 237 184 83 219 185 57 153 215 60 127 249 113 121 236 12 161 251 129 230 174 148 76 235 142 127 217 23 89 196 250 170 121 70 249 182 249 28 203 117 230 50 57 51 48 158 24 88 46 137 138 241 124 198 154 38 201 51 2 253 154 14 121 78 8 101 145 50 128 29 141 92 238 168 55 116 56 252 121 166 136 70 158 118 4 67 139 112 151 82 247 214 216 148 1 18 140 66 122 57 172 165 102 54 179 171 166 223 105 154 20 50 86 112 149 170 65 151 103 162 181 81 187 25 40 94 144 233 90 251 50 178 226 146 119 119 175 136 24 136 113 66 126 186 16 152 101 163 250 123 101 66 203 163 55 156 232 242 127 145 195 218 217 17 10 203 2 166 140 135 143 172 53 205 172 194 134 160 189 50 69 223 148 146 247 124 22 80 98 69 33 25 57 107 31 212 95 133 172 128 115 238 143 127 228 34 148 151 135 114 5 60 70 60 47 58 65 239 247 249 148 102 27 115 107 208 225 253 200 213 220 53 103 156 23 219 121 243 246 107 184 64 126 232 17 207 237 227 214 224 58 237 169 62 82 119 158 119 83 77 98 66 189 71 251 33 40 116 222 1 73 119 10 57 121 238 118 5 99 177 207 238 49 139 101 138 178 173 231 196 41 82 0 125 44 64 121 203 1 67 169 33 46 12 95 213 33 90 120 111 252 130 142 143 78 25 240 151 6 220 165 180 95 119 145 221 7 168 83 199 98 141 39 128 151 198 229 136 187 216 103 96 109 141 195 184 39 209 114 174 245 134 244 162 49 232 82 206 102 199 74 44 189 133 113 179 179 250 6 182 52 196 165 68 174 31 51 53 30 242 181 169 202 136 40 38 18 240 19 56 142 0 210 94 199 40 66 84 51 2 145 5 50 15 90 114 172 190 222 7 59 178 16 30 36 191 209 173 76 223 255 83 248 190 163 22 125 202 252 151 198 100 236 125 64 153 250 156 243 197 101 244 165 40 30 61 122 52 208 127 156 114 61 199 13 89 138 159 240 195 221 161 146 237 244 107 108 73 111 225 37 83 114 234 120 130 241 157 150 46 14 135 221 189 17 187 128 100 191 174 140 12 5 131 85 38 226 51 66 34 167 252 94 110 69 29 224 61 248 155 69 44 44 101 81 42 54 238 127 225 51 177 153 45 88 22 201 188 207 65 110 151 234 50 225 125 33 236 201 220 31 55 98 57 194 155 87 53 42 64 18 186 117 150 178 236 214 78 77 249 70 14 51 118 254 135 115 121 249 241 121 19 16 218 75 207 184 219 235 41 254 96 11 159 7 119 93 205 89 243 176 249 55 206 18 115 56 232 232 219 62 225 2 166 106 102 2 201 150 21 3 63 74 229 3 9 83 52 160 219 211 215 136 8 248 193 225 57 146 129 173 83 91 141 140 253 56 25 87 192 76 174 89 3 131 149 165 10 1 7 95 135 12 234 151 63 102 160 174 87 199 111 188 219 169 203 166 90 240 4 2 84 175 234 115 206 81 11 183 35 177 105 0 221 121 6 243 192 180 223 211 134 246 54 6 63 3 83 26 93 88 251 171 148 189 32 179 2 180 150 255 116 7 23 182 105 24 111 71 4 68 174 113 58 171 81 75 99 0 95 43 62 214 50 191 183 16 148 190 244 44 235 225 211 191 245 28 204 111 49 227 122 95 17 73 165 121 136 239 28 117 108 172 214 179 179 132 141 78 81 202 202 88 114 229 220 10 153 166 156 39 216 171 63 249 21 178 62 149 57 183 184 195 244 27 49 44 213 107 25 153 201 236 91 107 139 1 79 108 248 190 43 62 12 220 66 119 191 60 92 102 0 98 182 15 78 112 229 105 93 47 100 238 84 177 149 191 11 191 250 212 114 34 11 239 210 155 81 31 80 114 105 215 22 222 242 182 173 194 108 84 116 149 87 115 56 61 212 254 124 106 48 182 74 249 145 174 245 163 67 157 243 165 115 60 204 123 135 205 95 205 84 9 215 55 86 246 47 171 138 193 74 144 28 234 105 34 41 176 250 83 228 210 187 99 161 166 228 80 79 88 19 21 132 179 53 135 196 42 51 142 81 248 171 217 231 231 191 165 80 174 4 138 77 222 16 6 157 54 185 133 244 213 111 43 225 77 247 2 88 113 236 215 59 127 253 92 128 215 19 187 132 200 51 84 120 153 105 106 96 7 242 149 0 165 165 165 165 1 0 0 68 0 0 181 174 119 219 181 183 37 82 0 0 27 191 0 0 41 253 0 0 0 0 0 20 125 247 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 67 97 114 98 111 110 65 112 112 46 114 115 114 99 0 1 121 204 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 84 136 0 0 1 56 0 0 0 54 0 0 0 0 15 0 66 193 212 120 70 64 63 99 16 59 255 97 202 132 145 70 204 255 242 147 131 117 178 216 188 111 47 148 73 157 252 231 185 213 153 225 248 22 106 46 220 74 229 99 130 75 44 98 229 175 219 67 79 64 165 165 165 165 1 0 0 62 0 16 182 165 138 4 182 165 138 4 0 0 41 81 0 0 74 44 0 0 0 0 0 14 74 124 0 9 242 64 0 0 31 205 0 0 0 0 15 0 83 113 117 101 97 107 80 114 111 53 46 120 109 108 0 0 99 190 84 69 88 84 67 87 73 69 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 66 193 212 204 180 38 117 254 26 147 52 91 19 98 60 233 64 29 255 187 35 223 153 172 250 209 29 127 59 137 133 210 30 248 244 194 251 242 194 193 106 117 179 131 79 208 174 81 57 76 36 234 134 29 163 244 242 243 85 233 38 93 145 224 123 82 70 82 252 239 217 207 12 107 57 44 243 114 16 73 122 139 120 27 223 177 227 158 134 46 118 225 158 44 164 173 29 199 143 101 120 24 170 132 45 31 65 229 76 98 75 242 231 92 211 111 248 226 96 136 16 103 16 153 1 235 17 112 85 28 108 66 254 117 135 217 77 139 143 26 148 71 68 227 208 189 131 140 70 133 152 21 31 237 58 132 40 251 95 199 101 0 177 34 251 139 142 4 229 126 244 238 118 73 217 254 33 86 15 175 58 139 31 3 121 37 54 155 65 150 223 229 42 35 114 72 146 133 57 119 213 47 96 35 87 34 151 237 11 57 111 141 15 140 96 237 170 68 224 238 42 135 81 121 212 62 207 234 60 34 251 156 90 101 21 227 75 50 19 175 109 73 43 88 56 113 17 21 129 161 96 192 17 241 164 227 35 30 49 157 220 57 25 148 30 78 20 97 55 153 114 248 58 88 245 118 61 182 164 188 35 126 64 134 223 153 1 205 183 96 201 111 210 174 253 99 213 90 29 180 148 10 32 223 176 200 244 255 195 186 144 22 191 106 173 61 153 24 8 243 248 85 133 47 168 70 89 214 100 81 64 133 85 66 121 130 217 85 78 169 101 153 176 191 116 7 134 243 147 170 93 164 242 3 145 148 63 95 214 160 185 57 210 102 115 79 28 30 43 23 179 219 0 104 218 131 66 20 17 67 251 86 151 5 159 108 55 141 191 60 41 19 40 96 98 51 156 249 146 105 145 105 220 167 93 191 158 36 234 60 16 191 143 247 125 14 27 237 218 23 110 160 125 136 182 92 90 248 181 243 170 249 251 217 179 209 197 50 148 135 208 133 108 120 21 220 65 228 210 91 147 85 59 24 209 124 3 106 182 82 105 29 9 69 243 154 217 110 232 98 218 218 90 249 197 157 26 232 249 170 193 202 242 239 121 63 56 34 194 215 135 81 184 2 107 158 226 50 165 74 158 183 252 84 62 250 130 242 157 52 104 216 206 93 227 167 178 13 38 194 81 69 35 170 38 181 251 79 106 92 213 61 66 103 202 37 157 135 221 95 76 225 20 121 207 17 67 99 103 215 232 190 52 6 218 13 99 240 79 70 135 183 18 176 116 203 10 120 189 249 125 116 120 75 163 56 155 146 192 168 99 57 137 224 86 110 227 123 176 51 221 35 33 0 46 36 121 99 35 213 196 12 228 123 90 224 57 156 124 202 171 178 97 16 106 152 129 173 165 22 64 113 228 47 1 94 106 79 35 66 12 54 200 104 182 253 24 209 201 94 183 16 97 247 55 50 218 169 110 31 157 23 5 235 201 149 224 106 182 2 185 88 185 140 18 20 207 119 226 133 131 52 179 1 207 97 213 233 147 196 26 24 137 169 35 175 92 193 211 156 46 132 43 110 56 220 112 11 108 162 86 144 145 62 184 70 26 128 190 75 155 163 85 41 54 216 84 239 187 140 47 149 133 219 99 211 246 69 182 134 217 12 180 121 210 133 9 114 22 49 126 196 167 104 30 208 203 231 116 242 190 110 17 146 7 13 32 224 246 110 100 16 176 233 230 93 134 116 164 183 206 13 218 146 248 250 253 247 123 252 108 58 55 120 126 242 203 59 68 2 71 13 61 109 242 141 228 205 81 172 111 224 21 205 240 153 45 43 66 189 70 183 236 114 11 234 202 236 216 172 96 73 42 192 189 146 95 133 76 137 112 154 15 223 200 52 2 166 106 197 221 250 228 68 138 1 27 50 230 5 76 186 35 78 133 232 250 237 218 126 128 168 80 238 218 16 60 161 247 89 216 141 149 218 1 213 141 188 153 132 66 110 39 100 110 227 13 252 173 112 24 25 132 117 43 172 27 173 126 72 212 27 107 248 37 206 47 80 107 120 129 41 197 100 102 140 8 207 131 215 64 3 232 194 40 62 203 241 109 143 18 217 101 205 221 37 113 225 232 212 253 202 232 27 205 66 189 6 217 219 114 234 110 206 117 142 67 108 210 219 120 203 129 178 95 99 103 118 243 39 251 74 10 169 175 226 124 80 208 240 2 85 0 61 159 85 151 103 34 190 195 237 224 174 22 166 236 43 89 242 23 207 182 147 217 147 253 13 254 115 242 109 220 176 36 107 174 207 65 96 104 143 210 212 172 101 155 142 61 240 62 212 23 115 242 189 123 169 11 156 138 128 51 39 49 130 252 97 207 228 86 58 91 9 169 215 56 122 11 120 222 100 43 38 152 10 246 147 11 85 25 26 75 70 219 153 11 66 125 85 195 253 39 199 52 223 105 35 115 145 183 7 233 150 232 93 79 81 215 243 252 128 230 31 236 158 118 94 252 2 84 213 57 215 9 240 218 56 162 158 103 190 165 208 80 45 138 10 69 6 230 2 199 7 183 211 25 97 36 153 236 139 173 205 117 3 147 40 234 190 14 55 23 130 105 209 116 167 223 142 114 26 82 237 147 29 92 129 233 198 63 210 168 80 95 169 15 200 103 35 202 235 218 188 193 242 62 59 102 17 133 169 195 235 166 41 156 41 136 45 132 198 178 53 214 42 61 134 39 78 177 33 232 115 83 216 250 77 91 233 18 231 223 163 4 168 192 189 55 219 211 165 84 91 171 173 182 162 229 120 73 209 102 153 205 124 244 218 247 108 30 77 61 206 155 24 108 243 168 223 90 21 55 42 56 131 28 5 16 24 41 57 226 138 178 158 225 236 136 124 13 171 123 10 188 138 214 119 153 164 195 153 89 241 68 99 219 154 198 129 75 78 144 129 111 100 22 65 27 12 214 235 162 8 148 197 132 191 12 244 248 3 213 30 7 51 201 19 130 154 228 119 191 170 109 193 132 117 179 15 239 129 101 115 174 216 75 240 1 202 108 29 11 236 205 21 67 186 45 12 89 239 238 68 125 97 222 218 121 247 89 147 110 132 202 244 19 229 89 76 77 188 74 139 233 251 144 236 4 218 56 28 36 76 79 240 74 72 158 38 117 2 77 179 24 119 233 221 44 0 32 160 2 63 110 19 96 177 144 29 203 93 171 166 189 100 76 198 232 199 148 16 81 204 14 165 199 235 50 188 156 59 150 109 107 61 190 170 120 54 28 98 87 179 63 137 23 169 42 136 25 0 152 46 70 229 12 95 133 236 97 184 178 147 209 22 143 19 109 233 224 27 134 74 183 151 74 116 176 86 130 254 28 203 227 186 85 214 236 111 106 36 50 69 186 217 111 122 117 1 157 162 31 177 213 223 213 196 232 104 54 223 37 233 96 12 200 180 215 163 217 44 246 103 145 157 169 31 240 23 21 44 70 72 82 186 116 134 166 21 58 136 56 36 8 42 191 6 158 254 108 50 188 105 172 148 14 104 135 191 97 28 44 4 240 164 5 129 190 123 94 101 133 136 219 114 228 161 33 46 114 42 211 30 221 140 248 112 198 81 237 227 82 215 169 123 159 172 86 232 12 92 112 223 114 77 16 84 39 98 36 93 72 99 177 249 27 108 6 102 50 52 234 131 54 121 224 250 37 198 114 208 52 60 68 11 243 227 115 35 80 110 239 180 28 156 4 113 93 23 59 74 218 110 133 6 230 2 179 230 103 137 176 218 104 208 40 10 231 197 114 122 115 131 230 72 179 252 219 151 197 37 112 56 69 223 189 113 4 85 247 68 138 192 27 137 184 74 99 147 50 18 254 178 248 76 107 150 118 68 250 172 174 221 208 135 156 205 231 143 4 34 161 7 195 204 135 60 19 39 10 243 141 76 94 11 67 158 232 45 109 112 32 134 155 39 8 99 56 60 64 80 218 14 58 143 61 14 117 236 149 133 90 102 166 8 147 117 32 118 65 86 21 46 187 150 171 15 56 2 185 45 151 128 181 62 140 167 184 97 101 63 215 125 5 229 199 41 203 243 15 88 169 36 163 44 110 98 249 129 233 148 157 178 5 221 209 115 148 133 70 209 13 43 78 241 8 192 241 126 234 239 235 232 239 176 102 235 59 142 137 42 210 248 213 6 107 59 57 254 20 183 216 9 18 10 197 19 186 183 15 210 6 153 17 100 26 196 44 37 114 22 45 176 89 0 185 58 229 140 181 24 50 209 158 97 251 40 167 144 238 252 152 156 49 151 76 206 206 30 211 166 149 148 100 246 94 64 32 51 142 69 210 105 125 38 63 89 93 39 50 89 181 4 5 198 99 195 49 21 75 21 252 160 57 239 248 205 47 166 136 24 74 179 141 175 142 169 235 22 180 11 101 121 231 57 1 133 206 217 123 243 137 10 66 31 29 2 49 84 178 246 62 174 149 130 94 48 247 190 104 179 182 195 113 125 243 112 164 84 98 132 135 216 57 161 56 169 97 12 122 66 55 120 212 176 41 216 24 45 33 25 72 222 15 107 19 151 31 136 16 61 174 217 130 3 26 26 208 88 117 132 156 68 253 237 25 141 64 203 56 76 40 113 206 158 11 203 156 86 89 211 171 181 17 26 245 15 201 94 17 205 202 99 110 13 234 185 19 240 85 74 27 181 26 80 94 190 148 88 70 153 242 246 214 11 103 89 138 97 242 237 232 93 80 188 98 229 158 4 229 24 44 13 78 177 183 73 82 108 71 86 183 200 6 166 121 98 145 159 7 98 177 130 90 41 24 49 71 131 4 139 206 136 131 20 178 212 103 246 230 49 28 84 186 195 120 191 208 233 254 103 219 162 163 124 52 87 87 228 17 169 96 106 155 176 0 28 255 190 11 232 109 192 67 199 69 230 90 3 74 149 131 211 186 226 7 72 36 34 117 59 33 81 154 165 218 203 157 211 254 56 126 56 75 176 27 173 143 133 77 116 200 153 152 204 143 110 148 252 151 12 113 147 246 214 77 142 72 191 197 217 169 202 193 162 6 79 173 238 24 136 88 151 181 95 35 204 163 161 60 73 6 157 127 125 196 46 238 169 89 232 17 88 200 174 239 172 131 76 162 4 17 207 123 35 223 211 116 25 0 100 152 94 165 148 205 119 242 144 85 141 137 241 26 198 228 155 117 148 139 40 6 229 234 27 199 215 204 247 91 42 125 93 251 178 209 132 92 73 139 73 85 184 156 142 255 31 114 183 91 140 251 40 72 224 112 195 192 101 205 206 5 210 34 138 221 71 117 237 249 80 247 108 230 56 42 181 227 106 112 229 139 214 55 115 231 36 163 221 112 135 139 13 112 66 137 249 225 35 71 123 162 229 104 120 77 173 183 241 141 182 181 138 171 41 67 83 190 163 62 236 225 177 85 173 81 193 204 153 116 9 96 111 16 226 178 213 205 246 109 57 39 39 71 130 171 21 121 133 7 191 218 201 9 64 233 131 105 199 246 247 24 4 237 77 246 255 62 200 63 19 138 176 52 132 48 64 223 136 192 152 206 95 127 224 2 150 213 229 181 250 251 221 247 177 82 92 183 26 69 76 35 113 150 29 107 104 251 176 48 89 76 206 203 85 144 40 156 35 150 4 59 46 88 16 53 19 145 200 57 31 16 189 80 169 32 146 212 11 75 219 52 190 107 221 166 121 251 214 65 243 210 86 230 107 53 86 160 37 89 233 140 200 24 233 51 43 8 120 162 238 255 160 103 47 173 145 4 111 142 157 12 181 144 96 248 98 37 190 225 228 228 4 1 205 181 191 216 195 80 152 88 198 1 102 64 220 98 31 33 148 144 86 115 234 147 82 179 232 139 47 27 3 154 126 240 180 217 65 245 211 148 10 224 253 145 32 19 25 13 98 230 99 101 47 49 202 246 70 48 108 222 186 127 175 228 214 218 0 167 85 89 148 12 204 249 71 246 248 222 48 187 35 184 212 230 47 149 122 36 38 203 188 156 192 179 178 31 38 192 34 213 105 156 238 53 39 124 162 207 20 220 155 13 167 174 216 214 99 106 31 155 230 236 135 241 244 168 4 124 71 158 208 56 76 226 128 199 163 234 245 91 53 72 138 151 124 253 217 108 153 252 65 180 253 199 227 40 123 134 115 146 160 179 236 245 115 63 95 121 120 151 147 177 181 167 30 24 212 95 81 126 165 226 203 186 175 167 47 244 108 101 158 188 217 211 53 237 87 141 40 209 186 213 185 35 125 12 2 231 65 253 144 235 158 153 154 224 120 162 68 32 233 140 55 48 100 67 135 96 30 181 84 237 219 125 194 20 145 17 200 49 115 195 40 96 193 36 97 31 146 28 181 155 16 15 65 147 137 73 36 235 117 96 138 36 155 166 245 43 208 90 34 63 246 155 55 93 163 233 180 88 22 152 74 72 166 255 49 138 45 1 24 13 206 198 41 75 177 54 90 109 102 101 231 117 237 223 172 174 149 158 15 23 141 169 139 114 226 211 17 57 55 186 49 209 229 252 109 19 9 149 165 69 55 181 51 107 217 255 63 230 136 4 82 167 189 138 69 40 66 183 45 223 173 45 39 54 51 21 120 46 118 76 241 106 65 217 120 219 60 196 36 118 21 248 255 7 116 213 1 118 67 198 187 67 146 181 152 161 209 225 78 247 166 24 107 118 187 143 217 72 40 105 28 255 62 3 30 0 134 203 193 14 244 214 250 88 149 170 186 252 46 205 251 167 198 221 214 121 201 254 73 158 161 212 247 30 5 91 116 246 126 6 143 36 16 18 204 82 23 124 11 144 93 31 21 169 34 33 207 83 19 238 236 242 104 17 253 105 213 237 210 6 169 57 63 187 23 61 248 70 75 11 159 111 100 59 194 83 62 62 244 60 183 40 6 56 140 116 156 15 134 24 168 120 230 214 29 186 210 102 111 52 87 228 116 169 91 159 192 234 59 40 24 85 154 231 179 67 215 42 70 211 106 225 116 29 117 255 96 176 213 245 101 67 252 124 224 89 165 182 22 148 176 104 140 80 61 89 229 16 145 170 120 223 249 7 183 18 235 253 100 175 111 205 172 30 229 87 40 43 137 176 73 50 5 198 74 43 114 217 228 18 221 143 173 136 133 97 21 31 95 238 181 41 27 164 7 133 162 97 29 134 137 1 130 42 132 107 240 91 195 100 72 76 213 2 161 164 246 180 140 130 246 65 30 77 4 209 2 223 150 89 106 32 97 52 88 11 250 72 63 64 110 150 213 178 183 241 168 124 134 243 176 14 92 49 144 114 62 93 233 168 53 100 240 169 1 144 169 50 168 19 57 157 61 0 26 228 124 122 200 80 144 178 98 19 35 162 49 244 87 223 208 3 236 181 230 118 130 52 231 140 212 140 181 165 127 191 154 32 178 73 39 117 227 238 19 16 176 100 97 151 67 141 9 183 233 74 131 128 21 212 44 158 117 93 140 89 40 92 97 155 65 235 171 192 254 124 76 49 167 157 85 166 68 107 1 21 15 206 122 24 11 53 151 79 134 199 238 95 76 125 82 38 38 10 31 65 80 179 22 208 123 15 253 109 25 178 23 75 113 229 138 223 198 210 147 138 230 96 38 80 251 106 208 122 23 160 179 232 234 1 69 79 75 54 211 47 52 242 251 220 25 91 98 79 70 8 137 221 22 188 165 13 95 187 223 72 218 68 59 224 223 197 154 184 106 54 134 167 236 135 118 221 184 110 50 154 135 119 154 71 226 1 193 106 113 12 175 16 205 52 176 130 19 40 14 6 243 97 247 141 191 121 151 13 16 69 135 247 28 174 164 230 34 7 84 148 237 71 30 229 37 50 208 247 184 107 113 11 154 17 146 211 9 85 30 77 33 137 165 186 175 161 55 206 74 154 71 62 121 56 99 144 161 120 79 59 234 199 234 8 136 136 167 92 156 130 12 38 183 113 217 195 30 221 188 248 164 25 125 200 91 210 213 78 151 232 29 96 171 51 148 17 68 166 140 60 0 56 205 124 50 240 179 171 26 98 224 139 202 24 90 217 138 22 32 255 136 119 180 90 48 242 155 189 90 44 197 198 245 169 29 231 214 23 69 151 77 211 187 254 52 193 11 94 247 32 22 185 241 94 232 222 106 154 170 253 2 52 152 76 167 13 114 34 236 151 218 68 20 119 227 101 158 20 53 11 198 194 237 29 247 30 30 102 244 21 63 203 68 219 194 44 83 201 186 179 50 90 193 216 78 131 251 23 169 209 165 71 166 206 206 154 98 127 128 7 204 254 57 1 183 111 44 156 191 253 101 255 169 117 239 65 162 140 104 211 85 71 243 175 225 13 84 181 163 162 209 129 80 128 177 51 18 95 97 121 240 153 204 38 66 88 78 207 165 233 247 126 187 102 26 143 78 11 50 120 58 200 190 88 22 119 220 149 188 154 0 41 174 17 97 204 143 180 38 47 206 42 111 103 61 113 27 132 27 193 209 192 89 207 94 126 35 135 137 21 223 111 73 6 126 107 27 0 110 23 220 203 137 130 62 244 211 232 250 246 37 38 179 135 64 162 195 241 249 66 112 117 199 121 58 130 121 171 200 95 195 62 106 240 178 111 68 210 219 125 49 65 167 250 167 106 38 117 27 100 49 192 166 226 18 253 122 135 188 238 112 24 117 179 182 240 145 12 242 72 190 53 246 131 110 139 151 158 65 181 139 243 99 138 167 84 241 105 225 70 104 157 24 149 39 135 169 136 94 186 26 236 47 174 43 116 84 36 36 75 251 68 114 118 44 190 64 2 128 188 158 4 66 221 248 66 169 22 117 201 88 56 193 142 123 184 128 154 237 127 17 43 50 225 164 74 181 147 97 215 187 173 61 244 91 138 216 133 160 228 46 164 61 171 218 242 181 30 144 179 138 186 71 162 218 112 24 113 46 161 227 207 70 180 147 5 76 9 100 155 162 88 133 235 32 187 251 8 13 255 44 143 226 127 96 208 105 55 134 135 141 201 94 211 11 82 62 2 143 34 80 132 28 8 139 218 114 13 140 246 241 122 84 18 83 87 186 219 119 82 69 104 97 57 99 169 243 209 122 173 70 61 153 54 55 61 210 205 35 65 55 238 78 148 37 199 106 100 50 36 77 226 33 90 210 212 238 45 46 107 241 100 66 143 28 67 94 76 150 9 53 184 57 187 43 140 13 248 188 199 240 23 199 87 62 43 163 17 50 213 206 197 212 93 197 116 214 150 90 78 53 119 52 60 131 94 30 15 107 164 140 186 42 108 184 107 17 240 82 198 143 247 41 2 252 105 77 151 25 19 229 107 111 75 66 16 99 146 3 201 39 223 7 137 159 32 102 149 57 196 157 120 227 219 128 60 17 97 19 55 135 51 206 170 15 174 0 139 49 47 82 176 67 224 212 51 212 2 172 138 235 60 112 161 75 48 199 159 59 235 204 180 163 228 124 9 150 131 111 153 148 30 56 26 217 232 56 83 113 84 99 14 185 222 229 128 161 236 243 2 76 95 160 111 238 228 103 122 123 13 92 0 19 111 208 105 76 252 96 35 120 237 15 85 232 177 48 135 37 216 248 140 231 116 123 117 30 5 25 239 109 42 3 225 116 209 94 72 90 21 81 138 157 58 235 230 248 0 111 235 53 133 242 123 36 190 175 18 182 92 113 122 255 42 129 248 33 92 168 233 254 112 86 66 129 80 22 235 126 5 169 9 130 116 37 8 85 227 233 249 166 171 115 48 193 123 58 129 66 196 168 44 149 84 15 18 2 171 41 144 96 180 58 117 5 71 47 166 89 36 128 42 193 122 238 45 174 240 55 228 25 240 185 118 218 75 245 28 200 249 116 217 250 14 68 20 80 157 133 31 219 211 3 213 77 178 137 57 8 120 178 47 247 95 36 83 96 84 110 97 255 183 40 113 34 55 135 182 243 210 170 175 165 223 54 254 146 168 89 123 34 244 17 175 119 85 13 76 42 255 140 179 125 187 179 101 25 181 177 83 35 57 107 96 84 56 112 84 146 35 22 223 134 173 203 166 190 245 103 255 196 177 88 50 164 46 36 121 48 91 78 3 84 136 121 174 234 45 178 98 96 180 34 212 114 90 212 185 84 111 42 69 51 70 143 142 137 69 248 207 149 119 119 197 11 76 11 25 176 243 54 190 60 229 85 34 21 194 100 145 255 95 223 91 165 100 86 112 109 181 49 32 158 182 240 184 51 200 128 44 56 209 94 239 138 140 38 104 102 216 249 202 61 157 227 154 45 199 241 164 117 164 178 133 165 16 155 123 188 115 128 157 28 216 152 161 243 234 166 57 143 37 251 5 188 182 212 183 29 100 16 5 119 183 152 6 25 252 143 248 25 168 255 91 133 71 76 199 82 130 147 87 185 60 69 156 82 61 106 62 136 199 233 135 68 199 86 183 192 89 246 186 36 118 249 200 11 87 211 119 79 219 69 125 197 239 41 252 142 79 221 35 38 19 169 25 47 155 58 254 151 59 193 103 175 46 95 180 148 195 79 9 166 158 215 66 141 146 122 108 182 67 12 227 215 85 147 29 105 170 125 1 176 175 195 138 136 166 96 79 226 159 241 29 243 82 214 250 181 234 151 237 70 72 197 219 32 25 221 48 216 190 154 241 149 242 140 31 30 13 78 111 151 121 150 109 76 181 114 174 178 255 209 149 37 70 1 233 89 136 31 218 198 144 6 53 142 117 7 138 124 30 53 162 114 210 239 10 228 198 4 227 54 119 245 45 50 18 247 109 231 65 45 98 56 217 255 133 15 245 28 218 158 243 43 114 249 103 181 175 110 4 100 101 152 134 103 152 168 44 27 82 165 177 66 211 236 230 207 27 206 61 164 44 31 189 141 120 124 132 72 75 228 181 38 180 26 197 116 57 104 105 70 92 32 108 77 192 206 227 183 79 162 218 249 180 223 188 121 141 81 216 150 116 210 124 81 173 90 181 72 113 116 85 125 225 253 165 67 52 235 23 63 215 163 229 39 129 231 248 139 89 168 84 56 142 9 33 155 42 221 121 126 210 185 117 160 210 236 61 190 173 35 159 181 56 179 122 226 19 78 97 155 249 209 194 235 22 196 96 223 32 160 135 19 79 209 162 186 241 85 87 161 83 100 178 161 99 204 13 9 185 218 26 8 91 158 238 198 129 241 143 92 222 190 60 148 193 201 153 192 14 248 55 125 140 235 212 125 52 7 80 12 205 196 181 141 38 169 79 60 137 238 85 153 197 138 191 111 235 96 147 12 136 76 195 187 254 39 195 139 191 89 181 68 236 61 19 107 243 122 249 98 210 70 117 39 38 122 78 154 67 129 200 176 116 240 188 143 166 63 61 242 4 69 120 107 229 134 134 234 55 188 15 117 218 254 40 241 66 77 97 128 143 117 115 206 150 202 96 221 206 7 214 135 255 252 4 224 195 40 18 185 185 176 151 59 175 71 23 114 36 67 69 246 245 0 78 18 223 32 126 130 20 95 174 251 181 81 27 123 217 169 116 52 74 182 27 147 190 85 145 46 187 247 159 139 214 142 185 144 64 24 195 9 113 254 199 226 47 64 68 196 86 39 214 64 234 41 194 80 244 246 142 219 26 27 88 4 169 1 164 86 63 173 170 160 144 106 233 105 44 220 4 29 60 77 161 239 79 120 80 111 18 74 174 214 156 109 149 64 194 229 177 202 59 72 229 80 173 53 55 156 89 38 50 253 239 120 43 241 127 250 245 37 57 107 47 88 93 250 203 62 203 12 165 138 119 206 234 53 175 87 203 2 218 175 49 123 51 247 94 57 225 187 217 36 133 167 37 127 150 203 18 23 125 126 97 103 57 244 73 144 123 53 250 133 74 73 110 158 32 217 77 136 70 12 174 238 62 72 68 103 219 23 49 149 42 9 132 81 12 98 146 242 56 192 143 88 178 112 136 70 244 82 254 203 190 150 60 115 128 19 93 104 142 105 187 28 143 122 182 187 150 111 171 114 110 39 67 177 234 26 240 39 127 87 116 199 225 199 135 119 143 70 207 55 247 89 213 79 133 17 252 176 12 232 37 21 145 33 185 135 56 23 14 188 107 105 133 41 217 160 116 87 206 220 37 123 54 16 144 106 137 76 96 250 176 226 81 58 61 51 90 185 103 117 95 166 92 53 36 123 60 37 186 100 98 200 21 245 57 56 116 34 181 26 180 23 200 94 179 172 162 171 84 149 68 158 233 173 129 213 204 180 249 81 48 237 211 25 28 48 106 210 110 231 97 72 49 211 210 20 14 29 164 170 96 225 102 15 82 234 117 193 205 48 219 47 145 77 169 205 156 27 6 128 211 28 112 109 244 183 62 153 204 88 125 135 230 213 254 164 18 213 47 79 248 173 101 203 212 243 241 37 59 198 232 7 30 53 23 241 127 212 217 177 159 235 88 209 133 83 193 201 252 214 215 34 61 225 204 246 170 91 90 76 49 79 121 143 244 87 239 156 163 72 226 173 160 137 45 190 184 241 46 227 166 240 207 164 20 129 67 84 109 48 38 225 58 113 113 35 51 246 46 41 53 111 59 106 94 73 208 56 123 152 142 249 7 196 7 139 243 10 226 144 129 245 203 144 152 32 87 24 208 103 66 137 76 147 25 242 166 114 58 250 98 50 139 86 252 101 210 42 180 48 55 227 35 39 180 99 49 3 17 217 53 185 167 152 86 90 136 38 127 176 72 178 184 7 40 249 90 34 113 49 180 61 219 65 193 61 20 145 78 82 244 159 179 213 63 211 54 236 128 15 201 138 187 174 173 48 101 219 148 14 27 154 45 115 187 188 130 185 50 113 23 219 199 205 222 101 236 68 110 82 79 54 76 128 0 52 39 1 147 135 93 136 63 248 207 180 87 55 121 132 121 242 219 252 232 55 237 146 85 114 32 54 52 36 36 130 106 15 104 251 78 58 255 162 176 139 99 96 19 139 25 89 255 117 245 118 145 22 64 113 128 241 9 153 96 19 240 96 87 102 54 72 240 148 25 83 233 131 68 7 32 72 109 68 136 79 83 239 192 226 200 170 212 49 156 160 16 119 137 63 120 160 191 136 128 223 107 188 123 75 148 166 35 227 126 146 186 204 112 224 94 92 144 57 126 138 46 59 29 56 110 162 101 109 21 23 5 207 230 214 99 82 78 122 208 76 6 36 24 145 170 4 174 135 156 144 191 236 64 207 73 194 10 206 6 221 104 170 104 123 146 204 186 192 149 150 12 101 208 107 194 102 49 83 196 190 203 19 15 243 81 152 94 195 213 20 255 33 79 3 233 118 196 216 150 202 101 162 243 75 106 18 246 67 19 220 79 151 37 81 28 84 12 75 140 114 189 140 26 131 3 165 48 116 199 163 119 189 16 53 86 28 35 120 106 103 177 210 92 127 41 27 100 63 16 127 216 202 14 64 213 111 94 32 183 177 154 136 220 2 143 171 56 10 170 120 20 37 180 218 57 36 253 230 38 74 23 89 83 201 91 222 189 224 59 221 133 67 16 232 148 251 48 234 56 189 176 227 209 219 157 200 236 120 82 91 214 83 245 220 211 223 52 212 220 213 17 78 154 109 211 82 115 105 199 2 88 43 71 65 163 95 107 56 130 152 247 13 254 151 154 232 178 183 140 198 146 243 241 251 105 198 100 103 109 176 6 132 19 221 31 212 94 209 31 223 109 213 123 163 226 79 77 20 59 90 93 138 108 36 132 7 153 57 88 193 228 109 100 122 5 248 86 213 145 51 203 187 223 44 154 100 196 172 188 222 65 52 11 161 42 145 123 49 86 219 82 236 73 164 235 131 38 121 61 192 166 76 12 161 156 59 92 137 231 28 235 12 19 221 12 46 85 134 47 93 250 245 232 25 49 56 47 77 238 77 225 125 146 158 235 121 179 158 187 162 136 212 202 237 48 161 248 171 165 228 123 75 60 24 126 85 100 94 147 85 220 91 43 129 103 76 222 108 109 19 76 50 39 104 209 185 141 219 98 255 209 18 30 212 49 204 58 155 251 65 137 196 238 235 173 139 170 129 159 162 27 18 227 160 250 3 97 205 69 84 224 160 193 76 78 118 93 157 66 114 147 221 121 33 210 88 122 227 84 211 222 182 117 107 211 91 163 233 181 36 112 139 252 99 153 141 234 67 143 190 127 175 25 65 150 100 131 176 156 225 81 195 76 21 79 18 239 45 105 4 141 31 9 152 197 226 111 45 15 226 102 109 77 234 21 237 40 95 223 209 115 211 173 227 125 94 98 54 3 179 26 228 38 204 126 93 81 107 162 111 160 101 107 199 116 254 105 11 27 229 115 57 62 87 129 42 205 142 13 196 247 220 15 104 10 3 29 146 32 10 125 71 161 117 71 253 248 223 183 93 0 255 176 252 230 178 90 72 222 178 225 26 188 161 89 217 230 182 247 238 208 247 34 111 193 215 26 232 90 117 24 226 212 135 115 61 175 140 38 51 254 43 103 48 166 101 206 194 59 116 169 205 46 242 32 193 42 236 115 149 212 227 45 40 157 25 42 93 39 234 34 218 13 45 162 231 245 244 48 143 198 26 66 110 173 182 151 160 53 154 95 118 57 81 243 143 146 79 180 188 126 27 39 255 185 154 254 210 102 208 109 182 131 102 91 127 141 97 65 161 224 1 229 208 13 166 86 232 182 96 34 234 7 1 225 77 54 101 203 33 73 254 99 178 173 32 193 80 112 24 29 65 57 103 113 47 72 207 248 20 108 41 131 215 58 139 253 91 61 175 161 250 55 72 126 82 200 209 105 125 193 250 114 127 243 138 58 132 131 27 150 108 84 216 32 79 42 120 95 198 232 218 38 238 78 54 9 79 71 137 142 112 146 39 57 7 1 63 186 97 212 59 109 93 138 135 113 201 174 219 90 80 65 55 100 229 92 89 2 214 219 243 102 188 248 111 203 0 198 127 110 208 125 96 181 45 61 188 229 81 246 230 52 196 110 24 176 26 172 225 254 211 58 41 109 183 212 249 40 216 231 148 229 20 236 93 221 103 166 79 196 91 83 35 62 114 33 67 128 245 70 225 168 241 236 234 250 159 188 65 121 253 52 137 88 37 60 127 9 149 36 143 84 121 14 44 152 222 254 139 115 79 183 204 98 95 17 89 234 250 220 127 206 133 234 187 143 131 39 62 95 53 242 185 47 115 40 63 177 24 11 45 238 109 20 143 35 192 121 57 37 73 188 153 113 22 214 103 28 135 31 233 59 49 154 219 43 62 235 46 55 66 217 131 115 159 81 182 143 186 86 83 74 140 61 190 176 178 250 23 54 41 243 78 224 188 142 200 113 3 33 9 152 154 205 150 209 244 78 235 245 215 227 37 55 178 224 94 124 121 215 99 4 34 38 12 219 175 251 160 194 46 91 146 55 247 78 172 192 22 72 1 110 82 252 174 61 72 155 31 171 141 87 246 207 227 179 132 155 25 32 190 168 184 116 242 40 8 62 71 172 15 223 152 115 114 209 122 18 150 36 66 178 168 191 170 111 197 144 31 141 157 20 193 101 139 19 174 7 74 130 188 220 234 90 184 117 230 182 75 72 141 111 98 95 71 213 160 91 31 116 255 106 60 254 21 86 145 22 118 58 190 126 150 108 201 17 150 18 230 232 12 80 23 70 102 35 209 86 20 123 40 147 174 83 74 235 109 166 45 192 167 73 99 27 50 177 34 197 72 239 50 101 178 131 42 100 63 48 102 3 238 94 25 219 236 19 227 236 19 218 151 48 77 92 98 187 6 8 98 140 210 18 41 44 31 215 160 222 247 200 9 209 175 212 111 231 167 73 151 71 200 173 192 116 111 79 126 91 130 181 88 164 98 9 6 176 116 245 97 125 116 225 239 80 247 179 201 89 184 236 110 85 41 226 208 211 126 43 30 188 87 173 30 27 224 86 198 40 123 24 79 195 39 147 39 232 118 119 35 18 182 37 92 161 37 207 172 195 131 11 19 255 114 178 75 223 46 114 5 19 2 37 11 177 181 227 237 50 117 88 10 66 160 78 25 230 34 142 238 45 120 106 59 47 43 253 228 186 237 140 67 4 217 104 174 129 159 68 218 204 188 95 225 31 26 26 153 194 242 17 198 188 107 196 58 184 31 120 205 164 59 236 238 144 251 225 87 208 44 112 100 91 73 105 155 54 192 44 141 250 64 238 140 145 225 3 15 79 210 44 198 199 86 166 41 200 23 103 150 98 25 214 107 215 90 167 66 208 214 89 216 53 176 93 206 87 246 173 238 39 204 156 108 192 53 180 241 73 63 214 20 179 11 33 214 153 109 8 19 208 142 83 11 230 42 242 255 70 244 217 218 225 154 209 122 64 152 101 105 178 216 117 39 33 237 120 177 136 142 117 170 245 80 68 94 185 244 209 105 99 232 243 43 135 246 145 30 3 111 12 89 36 126 184 1 159 3 105 159 222 145 224 14 179 134 6 58 152 160 105 115 189 28 137 30 6 40 253 219 103 149 208 165 102 65 25 150 75 151 6 216 217 178 6 77 207 38 113 22 255 132 98 198 98 146 115 34 2 196 238 51 53 143 228 26 8 34 129 158 45 179 169 200 251 237 159 73 25 184 240 23 59 53 207 7 151 126 55 80 121 28 167 94 222 64 228 217 3 136 85 173 239 5 231 252 159 178 176 223 241 47 150 97 31 108 224 213 249 69 32 233 201 229 185 223 179 73 150 190 90 17 192 19 7 65 39 164 245 70 206 41 0 112 95 227 209 238 187 129 244 200 64 179 245 18 139 115 243 158 102 144 107 78 23 220 24 126 108 167 253 38 118 195 46 72 210 213 217 239 116 244 221 202 112 125 188 253 47 241 33 21 98 19 248 248 43 72 42 248 244 9 172 62 3 14 55 0 78 184 145 125 229 220 95 73 12 218 234 233 95 189 77 131 116 38 225 117 7 36 50 138 100 162 142 137 71 80 99 223 227 181 65 194 113 201 173 212 16 168 240 252 231 218 5 53 31 249 221 175 196 232 226 56 86 141 198 122 197 113 199 47 159 20 98 118 190 240 252 69 158 61 97 132 93 179 25 175 5 106 113 252 251 166 100 124 205 14 47 110 194 160 104 210 200 62 201 58 207 11 73 238 175 43 166 215 204 52 50 100 33 52 53 102 72 81 185 243 216 14 99 158 85 169 184 254 29 238 94 108 229 231 3 183 67 244 168 0 150 68 248 13 182 207 151 2 27 78 139 8 236 102 27 137 232 133 250 158 5 234 98 95 186 250 252 3 110 39 33 125 78 150 169 154 205 114 139 99 63 177 204 88 13 72 200 140 127 83 11 170 78 218 199 55 188 25 213 11 125 71 125 85 63 190 230 102 169 226 218 142 7 20 204 128 99 132 221 254 129 133 19 107 123 123 226 194 233 255 188 94 176 213 143 167 194 117 179 119 130 35 55 24 243 82 250 243 33 48 185 146 244 39 184 65 4 94 193 217 149 155 148 218 215 147 200 166 105 203 229 206 202 223 16 18 198 93 136 203 96 190 203 168 35 149 124 156 59 47 84 62 194 182 32 124 170 38 96 210 31 131 1 167 72 219 114 231 193 106 165 213 15 252 56 228 180 253 191 9 62 34 50 82 85 179 155 157 9 229 217 136 91 9 141 53 81 89 81 72 53 221 8 141 206 199 146 148 217 4 19 126 238 93 125 213 2 104 139 26 0 232 226 96 220 103 22 17 172 170 214 15 156 55 192 172 248 17 28 227 113 88 207 35 1 253 31 237 94 70 22 44 131 80 93 233 211 244 233 244 135 86 39 72 150 188 214 155 210 110 217 125 125 43 3 146 45 68 241 240 115 190 19 128 28 224 17 251 58 247 93 69 140 33 109 147 156 210 87 92 216 69 177 94 7 30 48 154 71 228 160 103 2 51 85 184 205 205 97 141 100 84 155 226 223 229 23 32 135 223 235 91 92 60 66 67 9 85 188 5 28 168 84 131 3 188 52 221 72 173 198 35 152 101 164 241 135 215 102 64 174 111 10 142 135 124 185 51 134 208 78 238 195 182 218 205 130 214 117 101 197 188 118 153 41 126 201 6 209 76 178 132 76 160 2 204 64 158 102 72 149 80 63 170 171 123 126 220 219 178 223 43 66 82 255 136 249 166 180 179 57 159 129 11 6 74 146 181 80 252 255 192 161 150 86 210 227 86 179 53 249 63 24 69 66 237 117 163 148 21 225 255 98 204 136 59 42 68 33 24 168 77 132 109 109 195 123 171 0 165 165 165 165 1 0 0 68 0 0 180 207 51 128 181 226 121 208 0 0 41 253 0 0 76 45 0 0 0 0 0 20 100 184 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 70 22 114 115 114 99 82 83 69 68 1 0 4 0 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 253 0 0 1 139 0 0 0 0 15 0 66 193 212 234 64 99 97 40 139 5 15 124 31 121 65 120 124 5 209 222 215 202 219 70 63 149 145 58 91 213 211 217 14 50 219 241 228 200 108 206 241 68 87 56 81 94 67 216 10 185 113 8 54 44 91 72 133 214 1 9 217 36 188 156 127 217 145 82 30 13 220 162 101 146 21 18 118 68 165 85 249 234 123 238 133 147 241 151 101 226 2 245 63 213 194 85 62 166 155 14 154 190 5 182 186 123 107 140 113 178 194 109 119 57 22 9 134 61 61 201 238 228 201 105 212 13 184 231 166 180 150 40 13 172 224 240 147 177 130 171 101 159 159 80 188 31 9 203 180 64 121 217 218 100 45 157 22 195 225 39 152 168 149 76 114 119 57 234 24 233 17 46 21 205 35 43 217 253 175 60 163 230 50 88 158 154 82 251 35 46 63 207 4 234 169 188 105 184 153 60 116 126 213 111 56 245 131 183 85 137 39 105 132 178 125 191 240 244 108 66 24 87 153 113 215 39 9 197 57 109 185 190 143 9 26 115 148 120 202 254 191 249 71 53 115 9 201 152 87 249 0 48 34 179 234 86 65 96 99 181 185 55 150 229 1 124 139 110 134 174 255 43 136 124 242 127 169 73 211 17 36 13 248 43 157 38 145 250 23 45 87 86 186 221 10 4 32 71 168 176 172 14 28 101 15 156 6 57 187 239 5 125 174 248 198 64 142 75 192 233 43 94 114 19 26 26 185 65 223 110 132 204 226 242 82 187 97 79 234 64 48 238 212 68 86 219 176 194 20 222 223 137 96 197 219 210 130 204 111 121 149 43 67 178 102 209 56 76 210 50 207 158 124 49 189 39 90 34 12 29 129 76 47 136 37 122 130 177 167 14 38 2 99 54 160 165 165 165 165 1 0 0 62 0 16 181 144 51 21 182 158 25 127 0 0 74 44 0 0 86 190 0 0 0 0 0 14 60 205 0 0 37 20 0 0 9 183 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 99 0 1 249 212 84 69 88 84 67 87 73 69 1 0 1 128 1 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 106 0 0 0 0 15 0 66 193 212 138 116 88 41 37 231 118 79 249 86 183 220 132 46 254 232 41 247 30 227 235 77 37 179 12 90 43 107 44 138 242 222 2 96 103 88 27 32 201 132 54 237 183 235 255 215 239 51 204 227 87 179 148 14 198 103 239 96 150 61 94 131 150 112 227 56 116 70 64 172 52 12 70 80 33 174 194 229 165 120 50 4 6 101 209 88 159 220 31 236 26 249 161 231 6 103 183 7 71 63 240 88 0 66 193 212 132 70 70 86 227 229 250 240 216 108 46 2 127 7 118 93 193 98 100 220 19 200 129 89 135 89 82 22 238 49 159 133 108 171 14 212 223 34 215 77 208 114 160 164 237 185 214 129 65 199 201 45 211 163 103 203 58 2 85 140 45 151 178 152 115 9 199 215 95 96 151 105 218 21 183 124 139 66 246 165 122 233 239 249 49 33 230 241 98 152 155 66 5 97 56 210 80 40 74 50 161 38 49 191 246 13 248 37 22 30 82 47 247 193 20 8 253 47 112 160 72 112 53 215 204 3 97 248 96 8 243 221 18 149 108 14 129 125 171 25 125 64 92 146 29 121 208 175 185 114 183 252 116 88 47 20 203 91 54 195 197 212 254 215 49 246 175 214 179 20 62 218 106 240 184 65 250 38 189 140 67 51 74 95 30 3 237 219 189 131 26 139 234 59 182 38 237 228 223 81 228 70 109 151 93 182 102 227 203 12 157 152 107 15 98 148 171 41 204 102 172 62 195 233 155 129 52 241 31 197 124 118 99 45 58 83 248 22 215 210 251 42 253 224 32 223 130 124 29 99 117 213 224 39 13 123 115 248 26 221 26 239 139 238 20 111 20 56 127 75 111 87 227 74 59 31 173 85 118 51 26 21 56 145 199 107 6 134 163 54 13 38 143 9 8 177 101 138 176 126 236 42 83 222 165 174 137 128 18 108 62 172 104 206 82 31 153 2 182 57 73 14 84 208 156 251 177 59 232 160 12 252 203 218 179 103 69 40 108 127 129 76 239 43 241 84 12 202 12 118 247 134 247 28 5 26 17 8 152 197 86 37 168 231 169 178 114 72 86 108 222 32 244 59 133 232 143 193 13 133 147 126 127 149 24 121 2 38 68 52 152 209 111 150 184 27 137 253 238 123 197 0 118 134 239 237 36 138 92 9 194 243 159 213 60 212 20 229 59 28 20 233 18 161 31 106 165 1 110 83 216 106 180 249 207 9 174 17 94 185 168 244 3 4 168 140 63 65 99 190 250 119 64 70 17 171 160 166 169 104 159 33 175 236 14 164 90 174 65 175 124 152 30 15 87 146 118 109 236 131 130 220 219 214 112 125 170 137 231 54 250 21 145 43 231 188 66 60 145 144 78 191 182 237 122 40 55 70 174 38 200 113 225 103 84 13 29 121 130 211 114 223 222 52 197 13 242 137 125 59 249 152 208 14 117 204 232 95 173 10 254 158 64 113 32 71 211 118 10 37 152 22 6 193 1 255 147 16 255 96 95 2 197 244 163 41 80 165 64 231 82 177 26 111 196 195 16 244 124 241 119 42 72 98 152 240 138 13 187 140 50 8 203 25 228 139 176 231 43 188 185 2 244 190 171 127 194 95 139 23 204 75 146 60 62 27 80 38 93 38 145 109 19 117 6 190 225 110 85 211 48 214 67 194 48 118 230 103 121 110 231 193 135 164 195 102 232 253 49 148 47 128 195 236 125 10 219 186 74 154 99 167 196 60 86 195 220 106 181 140 85 69 75 218 24 134 11 31 42 184 151 115 226 63 107 52 127 87 90 27 209 125 49 244 52 72 106 47 168 194 221 133 102 80 172 93 30 180 148 98 219 250 1 131 80 231 16 175 251 155 120 51 58 133 74 44 194 98 69 220 203 116 191 232 6 60 149 104 160 232 101 60 176 56 85 193 184 154 196 187 176 181 220 6 241 108 26 22 183 125 180 240 179 101 192 98 125 237 3 89 114 235 91 209 164 113 1 58 129 69 227 29 19 29 199 223 52 106 86 210 28 98 88 130 229 148 120 16 129 14 17 4 222 44 49 251 34 155 53 1 122 248 192 61 173 28 105 15 199 20 82 30 53 37 81 146 117 100 246 78 108 152 234 93 106 164 44 100 57 126 9 134 155 27 184 21 148 185 94 106 50 113 228 79 94 34 151 21 160 54 33 4 249 230 134 176 70 241 249 85 152 252 212 193 251 181 238 242 57 219 252 62 154 74 65 219 88 115 39 77 236 5 188 230 126 109 127 233 91 10 224 186 224 60 237 252 238 150 54 161 201 94 8 244 145 47 44 217 137 239 234 201 42 8 178 49 89 199 176 56 165 31 101 19 109 234 101 137 162 10 229 183 144 68 242 150 52 133 117 88 173 140 84 230 109 53 133 118 31 127 28 54 7 230 85 169 251 254 192 6 169 172 189 140 22 174 91 19 91 125 223 162 84 237 230 213 183 153 250 131 177 111 6 84 183 247 13 76 39 186 31 198 85 4 65 32 19 1 99 145 201 225 227 243 17 214 185 26 33 101 205 44 160 34 195 147 137 18 207 88 193 239 159 19 49 180 186 110 34 91 81 126 47 101 10 118 12 117 42 111 147 156 94 195 157 204 248 229 229 155 103 232 66 107 220 242 138 252 243 151 217 136 131 173 212 193 219 166 253 173 88 80 220 63 46 109 88 232 90 249 96 67 199 255 136 27 154 43 84 216 241 187 178 227 175 65 114 73 13 15 98 255 39 134 162 119 232 163 16 23 93 129 62 166 157 15 154 27 26 22 115 8 168 226 84 233 64 121 6 75 60 59 127 229 225 29 214 193 226 73 79 102 74 60 56 130 137 229 133 2 50 59 52 230 115 36 203 162 101 18 167 216 183 101 153 45 171 24 125 246 212 22 150 51 149 179 153 191 89 161 218 135 97 19 194 50 34 223 113 101 103 136 83 76 55 48 36 80 56 226 27 48 120 156 42 19 32 20 17 57 39 33 219 123 249 192 127 10 182 75 171 92 189 220 14 220 60 159 227 228 14 241 235 112 90 20 251 157 160 3 36 236 95 173 58 230 127 69 243 123 75 97 113 205 83 246 125 11 125 96 36 176 106 177 61 42 181 20 175 94 167 143 126 251 254 160 166 65 77 62 9 249 97 143 85 228 244 116 212 36 139 27 39 2 205 126 120 142 16 221 171 238 9 71 136 127 183 207 62 15 86 53 15 2 102 101 179 61 141 49 213 40 141 163 67 190 184 255 243 129 31 131 167 254 204 179 48 58 103 182 95 167 251 52 47 18 107 18 137 227 164 93 85 188 234 111 109 2 84 181 250 201 87 56 179 139 122 116 9 72 150 26 201 3 16 131 116 158 40 94 162 107 116 254 167 70 163 135 76 238 186 199 185 34 229 206 216 82 176 11 88 86 57 139 30 2 208 123 57 141 221 171 211 186 142 118 126 139 154 109 57 79 1 35 167 40 44 39 213 242 211 220 168 159 200 169 179 212 88 68 78 200 147 37 40 78 169 30 98 229 242 15 101 5 179 4 239 182 164 66 15 21 205 242 169 118 60 166 24 139 110 88 102 100 95 76 164 156 185 94 78 122 188 84 74 244 3 153 155 54 89 214 52 181 186 49 248 74 61 63 130 1 251 48 92 241 131 25 214 90 146 245 111 208 0 200 130 56 240 165 169 148 206 222 128 170 66 144 165 235 199 35 41 172 79 16 73 84 79 60 126 86 20 84 57 189 173 108 83 108 81 41 110 196 34 198 64 130 167 53 95 252 127 145 160 17 25 107 30 200 4 122 235 171 27 245 83 163 114 251 243 83 92 90 202 225 71 136 233 48 236 166 227 153 9 44 86 152 46 157 33 106 211 38 217 131 189 158 77 118 186 137 83 106 231 38 183 90 52 35 137 96 149 252 106 81 140 59 206 123 111 194 70 128 243 110 236 189 248 13 44 218 175 155 189 61 117 24 11 169 190 120 244 49 97 84 33 238 113 123 121 234 200 117 143 213 164 67 118 136 81 156 181 97 170 195 15 90 84 197 162 128 180 123 146 157 140 166 23 62 191 219 207 52 11 47 102 15 132 239 222 55 33 195 105 219 7 235 139 152 116 60 25 96 195 178 61 14 158 181 173 197 130 3 51 243 102 76 103 143 10 245 92 220 236 141 223 116 227 66 7 57 153 114 238 10 230 232 176 12 175 132 255 205 252 18 152 205 169 191 124 59 188 115 70 80 37 198 61 238 169 19 8 73 36 110 103 133 105 74 11 15 219 222 225 80 37 208 46 80 225 212 115 148 86 235 203 83 7 141 117 136 142 4 23 62 124 10 94 45 49 81 53 68 172 40 141 44 61 248 53 189 171 93 232 151 125 187 242 44 48 78 122 14 155 71 149 26 249 110 4 137 252 232 107 95 133 111 248 39 32 216 250 139 71 199 65 188 109 185 222 173 38 154 41 26 203 164 65 78 224 92 171 208 90 72 55 177 173 76 81 231 243 216 204 118 128 229 102 224 120 76 223 0 232 167 190 139 96 143 251 23 60 117 73 185 52 25 41 30 92 16 109 65 55 254 254 173 95 201 191 193 56 212 8 23 212 173 150 167 92 25 22 96 99 170 165 164 40 36 195 183 62 219 4 67 46 22 63 222 5 189 85 231 135 117 193 81 183 28 185 150 204 45 138 16 29 249 195 34 17 152 49 55 161 150 67 67 238 114 100 72 91 0 22 231 161 15 143 49 222 113 6 12 169 143 119 228 135 153 170 60 177 165 119 120 180 81 178 118 192 182 42 171 188 123 62 224 76 89 178 221 232 21 1 32 55 48 174 83 32 204 196 152 115 160 94 162 76 36 234 130 46 208 158 156 130 16 2 200 63 214 12 68 238 216 11 69 230 210 144 197 49 0 137 72 242 7 201 79 14 15 92 223 226 57 137 113 156 96 94 22 62 239 156 25 246 159 72 150 236 47 148 93 81 82 160 65 193 218 226 5 173 68 149 131 185 38 21 54 28 45 163 133 100 249 71 53 193 81 236 219 46 36 117 122 241 67 70 160 158 137 200 28 140 228 117 216 92 197 139 107 45 76 132 225 120 25 241 135 183 155 93 124 61 178 162 153 124 169 222 88 143 122 87 102 247 47 37 141 255 232 110 183 43 235 205 24 115 77 112 204 130 226 183 244 107 237 88 133 215 112 156 91 244 40 149 126 211 18 61 248 243 242 234 1 67 155 205 165 46 241 183 45 57 192 220 209 108 240 103 75 84 225 56 241 98 50 22 74 38 110 229 178 174 113 149 105 219 99 204 9 187 142 57 11 80 19 222 31 78 163 164 81 225 238 93 139 39 45 77 116 191 122 147 93 63 47 1 43 54 59 33 120 183 197 115 221 125 55 140 107 197 207 252 168 189 93 204 160 15 6 92 87 21 69 13 171 60 68 240 229 169 136 185 10 16 114 157 62 4 62 98 10 25 57 208 210 238 206 221 244 23 46 24 203 6 182 53 192 196 161 244 15 113 51 114 84 111 207 79 49 240 83 61 153 132 114 177 48 194 95 237 67 44 187 237 135 159 159 33 223 31 214 108 74 197 120 50 91 204 64 45 244 193 54 170 53 199 41 10 70 220 145 68 218 10 32 158 205 48 186 18 120 100 158 47 3 157 62 91 7 54 31 217 83 233 226 95 125 28 51 6 123 194 39 147 63 52 100 201 220 96 226 242 131 85 96 214 22 71 194 69 5 99 37 88 48 22 245 153 70 245 85 38 116 133 224 61 191 197 143 169 70 94 167 89 162 114 248 119 73 40 186 97 52 83 229 239 50 37 67 25 0 165 165 165 165 1 0 0 70 0 16 181 144 51 13 182 158 25 125 0 0 76 45 0 0 89 108 0 0 0 0 0 22 155 185 0 0 3 180 0 0 1 205 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 67 97 114 98 111 110 46 112 99 104 0 1 219 219 84 69 88 84 67 87 73 69 1 0 0 16 0 16 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 105 0 0 0 0 15 0 66 193 212 165 47 158 104 105 246 72 249 217 33 168 151 12 136 51 226 207 102 181 53 202 25 16 235 64 88 127 6 22 64 66 107 35 181 106 81 159 250 120 157 225 190 117 56 184 123 226 1 162 155 83 159 110 50 8 162 205 115 40 84 111 26 78 200 205 117 204 12 184 23 122 92 240 56 200 244 242 229 151 241 158 208 94 3 39 131 254 152 253 250 205 136 73 62 145 39 154 192 103 139 78 0 66 193 212 247 142 41 244 252 170 32 131 125 120 226 219 34 155 40 95 65 156 245 152 111 218 35 102 116 216 131 145 17 84 107 97 158 240 249 195 150 60 120 140 104 228 134 193 204 31 57 215 166 99 44 206 176 32 16 144 208 6 248 187 61 109 226 227 51 211 25 218 191 40 12 114 22 28 230 0 112 11 172 202 32 219 160 175 46 72 139 187 24 169 29 138 113 109 138 194 65 131 26 203 70 229 19 88 5 218 129 23 174 244 179 27 110 213 99 88 249 52 149 107 131 128 11 191 219 77 60 140 147 221 41 5 154 71 244 111 11 122 216 102 224 199 124 224 181 243 197 90 177 66 36 17 3 41 236 155 135 117 157 197 125 86 112 49 216 189 27 139 184 235 236 11 77 248 224 96 79 164 194 90 103 41 162 119 82 173 71 116 83 120 63 237 133 59 95 243 179 182 38 66 89 112 120 57 175 247 2 86 164 221 215 242 66 72 241 206 94 82 185 213 183 84 158 243 111 184 131 123 154 113 69 129 63 216 193 18 183 237 229 86 226 139 223 239 210 173 153 53 67 49 7 198 215 211 213 85 237 110 87 144 203 47 169 210 32 17 124 119 167 84 218 32 64 80 64 213 139 46 73 67 237 85 242 129 68 80 18 116 121 38 21 132 110 38 88 152 155 85 234 152 132 14 186 223 127 213 177 161 118 126 164 93 140 86 9 39 140 158 128 15 121 128 22 82 198 32 125 160 105 176 229 213 67 60 105 93 166 53 20 133 196 110 63 239 200 252 182 252 210 104 194 171 61 38 193 140 109 223 92 105 43 228 169 222 61 252 104 255 66 238 34 62 131 239 211 193 88 118 48 247 65 45 181 8 92 165 55 106 219 2 60 38 114 62 64 145 43 151 179 227 59 232 214 164 43 226 209 187 193 230 212 51 34 107 155 72 0 26 242 4 241 9 64 80 182 179 217 254 181 123 67 245 13 80 221 209 230 9 60 229 105 10 138 253 27 231 68 155 196 137 233 97 229 82 175 213 222 96 165 165 165 165 1 0 0 64 0 16 181 144 51 13 182 158 25 127 0 0 86 190 0 0 0 0 0 0 0 0 0 16 69 17 0 0 3 20 0 0 1 114 0 0 0 0 15 0 109 121 77 97 99 72 101 97 100 101 114 115 46 112 99 104 0 1 88 119 84 69 88 84 67 87 73 69 1 0 0 192 2 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 104 0 0 0 0 15 0 66 193 212 165 47 158 101 143 90 111 232 62 137 252 56 69 246 55 232 246 98 189 188 255 155 198 30 90 243 42 211 241 167 187 69 222 101 24 237 121 87 7 53 149 235 121 156 11 206 152 4 15 178 205 229 134 94 221 0 104 164 75 198 79 15 171 162 91 37 201 38 158 230 189 202 224 145 29 141 0 165 155 181 193 14 221 65 190 41 163 119 242 145 171 87 56 6 98 40 104 89 188 100 0 66 193 212 154 175 240 32 110 231 176 220 75 122 67 45 140 218 152 26 188 19 16 70 46 100 12 102 162 171 207 147 232 46 129 230 224 142 44 70 162 102 82 16 65 169 232 58 197 1 226 230 247 241 20 175 215 67 32 203 217 208 134 187 150 162 63 110 169 185 56 142 225 246 180 33 114 124 5 37 84 212 128 30 164 229 208 216 224 187 2 126 209 51 142 7 56 139 220 232 168 56 210 119 197 236 95 113 121 147 62 5 16 6 102 148 120 76 237 88 4 46 152 207 227 190 58 105 25 63 228 30 242 145 30 205 193 119 28 65 161 6 85 113 254 35 25 218 241 155 57 46 34 101 87 219 177 175 90 37 23 192 16 110 135 14 201 90 113 155 204 60 215 16 232 111 135 218 123 36 119 224 93 163 67 233 232 62 127 241 177 118 93 131 253 225 94 147 211 226 106 223 56 140 40 243 210 212 240 205 25 69 158 223 23 7 45 121 161 103 21 93 76 191 131 11 37 220 95 159 108 53 71 237 228 38 192 96 36 234 168 14 101 68 218 187 125 239 67 136 208 224 145 202 41 73 44 92 125 93 164 127 252 148 199 42 76 2 0 50 102 61 155 95 144 49 242 226 212 139 39 169 250 165 133 244 188 11 198 113 244 133 255 208 95 234 165 90 112 27 52 250 90 78 166 0 202 127 35 59 223 131 14 154 81 218 181 53 29 254 103 48 33 191 225 6 186 233 121 161 97 169 147 218 120 247 111 39 193 212 57 27 102 129 167 141 48 58 146 236 83 180 135 36 193 196 77 181 97 218 24 94 119 88 225 88 61 107 38 42 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/6/2001 10:52'!macDirectoryFile	^ '/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism.  Feb 2nd 2001, JMM rewrote, using more current file manager logic. */#include "sq.h"#include "FilePlugin.h"/* End of adjustments for pluginized VM */#include <Files.h>#include <Strings.h>#include <path2fss.h>/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;FSSpec lastSpec;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown);int recordPath(char *pathString, int pathStringLength, FSSpec *spec);void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name);OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec);OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo);int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name, Boolean doAlias, Boolean *isFolder);int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown);pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec);OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec);									 pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath);OSErr __path2fss(const char * pathName, FSSpecPtr spec){    return lookupPath((char *) pathName, strlen(pathName),spec,true);}									 								 int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}void makePascalStringFromSqName(char *pathString, int pathStringLength,unsigned char *name){	/* copy file name into a Pascal string */		name[0] = pathStringLength;	strncpy((char *)name+1,pathString,pathStringLength);} OSErr makeFSSpec(char *pathString, int pathStringLength,FSSpec *spec){		char name[256];		if (pathStringLength > 255 || (!!plugInAllowAccessToFilePath(pathString, pathStringLength))) 	    return -1;       strncpy((char *) name,pathString,pathStringLength);    name[pathStringLength] = 0x00;    return __path2fss((char *) name, spec);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */    //JMM tests create file in Vm directory, other place, other volume        FSSpec spec;    OSErr  err;    long  createdDirID;        if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDirCreate(&spec,smSystemScript,&createdDirID) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */    FSSpec spec;    OSErr  err;    if ((err = makeFSSpec(pathString, pathStringLength,&spec)) == -1)        return false;           	return FSpDelete(&spec) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay;	HVolumeParam volumeParams;	CInfoPBRec dirParams;    FSSpec      spec;    Boolean     isFolder;    OSErr       err;    	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return NO_MORE_ENTRIES;	}	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			err = lookupPath(pathString, pathStringLength, &spec,false);			if (err == noErr) 				recordPath(pathString, pathStringLength, &spec);			else 				return BAD_PATH;		}	    spec = lastSpec;		okay = fetchFileInfo(&dirParams,index,&spec,(unsigned char *) name,true,&isFolder);		if (okay) {			CopyPascalStringToC((ConstStr255Param) name,name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if (((dirParams.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0) || isFolder) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else			return NO_MORE_ENTRIES;	}}OSErr getSpecAndFInfo(char *filename, int filenameSize,FSSpec *spec,FInfo *finderInfo) {    OSErr err;        if ((err = makeFSSpec(filename, filenameSize,spec)) !!= noErr)        return err;            if ((err= FSpGetFInfo(spec,finderInfo)) !!= noErr)         return err;            return noErr;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	    return FSpSetFInfo(&spec,&finderInfo) == noErr;}dir_GetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Get the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */    FSSpec spec;    FInfo   finderInfo;        if (getSpecAndFInfo(filename,filenameSize,&spec,&finderInfo) !!= noErr)        return false;       	*((int *) fType) = finderInfo.fdType;	*((int *) fCreator) = finderInfo.fdCreator;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}/*JMM 2001/02/02 rewrote */int lookupPath(char *pathString, int pathStringLength, FSSpec *spec,Boolean noDrillDown) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return error if the path is bad. */	CInfoPBRec      pb;	Str255          tempName; 	OSErr		    err,err2;    Boolean         isFolder,isAlias;    /* First locate by farily normal methods, with perhaps an alias lookup */        err = FSpLocationFromFullPath(pathStringLength,  pathString, spec);    err2 = ResolveAliasFile(spec,true,&isFolder,&isAlias);    if (err == noErr && !!isAlias)         return noErr;        /* Than failed, we might have an alias change, or other issue so     first setup for directory or file then do it the hard way */        strncpy((char *)tempName,pathString,pathStringLength);    if (noDrillDown) {        tempName[pathStringLength] = 0x00;    }    else {        tempName[pathStringLength] = '':'';        tempName[pathStringLength+1] = 0x00;    }    err = doItTheHardWay(tempName,spec,&pb,noDrillDown);    return err;}/* This method is used to lookup paths, chunk by chunk. It builds specs for each chuck and fetchs the file information, Note the special case when noDrilldown */int doItTheHardWay(unsigned char *pathString,FSSpec *spec,CInfoPBRec *pb,Boolean noDrillDown) {    char *token;    Str63 lookup;    Boolean ignore,firstTime=true;    OSErr   err;        token = strtok((char*) pathString,":");    if (token == 0) return -1;    while (token)     {        if (firstTime) {            strncpy((char*) lookup+1,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[lookup[0]] = '':'';            firstTime = false;        } else {            strncpy((char*) lookup+2,(char*) token,63);            lookup[0] = strlen(token)+1;            lookup[1] = '':'';        }        if ((err = FSMakeFSSpecCompat(spec->vRefNum,spec->parID, lookup, spec)) !!= noErr)             return err;                fetchFileInfo(pb,0,spec,spec->name,true,&ignore);        token = strtok(NULL,":");     }   if (noDrillDown)        spec->parID = pb->dirInfo.ioDrParID;     return noErr;}/*Get the file ID that unique IDs this file or directory, also resolve any alias if required */int fetchFileInfo(CInfoPBRec *pb,int dirIndex,FSSpec *spec,unsigned char *name,Boolean doAlias,Boolean *isFolder) {    int i;    for(i=0;i<sizeof(CInfoPBRec);i++)         ((char *) pb)[i] = 0x00;    *isFolder = false;    pb->hFileInfo.ioNamePtr = name;	pb->hFileInfo.ioFVersNum = 0;	pb->hFileInfo.ioFDirIndex = dirIndex;	pb->hFileInfo.ioVRefNum = spec->vRefNum;	pb->hFileInfo.ioDirID = spec->parID;	if (PBGetCatInfoSync(pb) == noErr) {		if ((pb->hFileInfo.ioFlFndrInfo.fdFlags & kIsAlias) && doAlias) {		    FSSpec spec2;		    Boolean isAlias;		    OSErr   err;		    		    err = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, name,&spec2);			err = ResolveAliasFile(&spec2,false,isFolder,&isAlias);            if (err == noErr) {            	if (dirIndex == 0) {            	    fetchFileInfo(pb,dirIndex,&spec2,spec2.name,false,isFolder);            	    *spec = spec2;            	}        		return true;			}		}        spec->parID = pb->hFileInfo.ioDirID;		return true;	}	return false;}int recordPath(char *pathString, int pathStringLength, FSSpec *spec) {	/* Copy the given Squeak string into the lastPath cache. */	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastSpec = *spec;		return;	}	strncpy(lastPath,pathString,pathStringLength);	lastPath[pathStringLength] = 0; /* string terminator */	lastPathValid = true;	lastSpec = *spec;}pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath){	OSErr		result;	FSSpec		spec;		*fullPathLength = 0;	*fullPath = NULL;		result = FSMakeFSSpecCompat(vRefNum, dirID, name, &spec);	if ( (result == noErr) || (result == fnfErr) )	{		result = FSpGetFullPath(&spec, fullPathLength, fullPath);	}		return ( result );}pascal	OSErr	FSpGetFullPath(const FSSpec *spec,							   short *fullPathLength,							   Handle *fullPath){	OSErr		result;	OSErr		realResult;	FSSpec		tempSpec;	CInfoPBRec	pb;		*fullPathLength = 0;	*fullPath = NULL;			/* Default to noErr */	realResult = result = noErr;	#if 0//The following code doesn''t seem to work in OS X, the BlockMoveData crashes the// machine, the the FSMakeFSSpecCompat works, so go figure...  KG 4/1/01	/* work around Nav Services "bug" (it returns invalid FSSpecs with empty names) */	if ( spec->name[0] == 0 )	{		result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	}	else	{		/* Make a copy of the input FSSpec that can be modified */		BlockMoveData(spec, &tempSpec, sizeof(FSSpec));	}#endif 0	result = FSMakeFSSpecCompat(spec->vRefNum, spec->parID, spec->name, &tempSpec);	if ( result == noErr )	{		if ( tempSpec.parID == fsRtParID )		{			/* The object is a volume */						/* Add a colon to make it a full pathname */			++tempSpec.name[0];			tempSpec.name[tempSpec.name[0]] = '':'';						/* We''re done */			result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);			*fullPathLength = tempSpec.name[0];		}		else		{			/* The object isn''t a volume */						/* Is the object a file or a directory? */			pb.dirInfo.ioNamePtr = tempSpec.name;			pb.dirInfo.ioVRefNum = tempSpec.vRefNum;			pb.dirInfo.ioDrDirID = tempSpec.parID;			pb.dirInfo.ioFDirIndex = 0;			result = PBGetCatInfoSync(&pb);			// Allow file/directory name at end of path to not exist.			realResult = result;			if ( (result == noErr) || (result == fnfErr) )			{				/* if the object is a directory, append a colon so full pathname ends with colon */				if ( (result == noErr) && (pb.hFileInfo.ioFlAttrib & kioFlAttribDirMask) !!= 0 )				{					++tempSpec.name[0];					tempSpec.name[tempSpec.name[0]] = '':'';				}								/* Put the object name in first */				result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);				*fullPathLength = tempSpec.name[0];				if ( result == noErr )				{					/* Get the ancestor directory names */					pb.dirInfo.ioNamePtr = tempSpec.name;					pb.dirInfo.ioVRefNum = tempSpec.vRefNum;					pb.dirInfo.ioDrParID = tempSpec.parID;					do	/* loop until we have an error or find the root directory */					{						pb.dirInfo.ioFDirIndex = -1;						pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;						result = PBGetCatInfoSync(&pb);						if ( result == noErr )						{							/* Append colon to directory name */							++tempSpec.name[0];							tempSpec.name[tempSpec.name[0]] = '':'';														/* Add directory name to beginning of fullPath */							(void) Munger(*fullPath, 0, NULL, 0, &tempSpec.name[1], tempSpec.name[0]);							*fullPathLength += tempSpec.name[0];							result = MemError();						}					} while ( (result == noErr) && (pb.dirInfo.ioDrDirID !!= fsRtDirID) );				}			}		}	}		if ( result == noErr )	{		/* Return the length *////		*fullPathLength = GetHandleSize(*fullPath);		result = realResult;	// return realResult in case it was fnfErr	}	else	{		/* Dispose of the handle and return NULL and zero length */		if ( *fullPath !!= NULL )		{			DisposeHandle(*fullPath);		}		*fullPath = NULL;		*fullPathLength = 0;	}		return ( result );}pascal	OSErr	FSMakeFSSpecCompat(short vRefNum,								   long dirID,								   ConstStr255Param fileName,								   FSSpec *spec){	OSErr	result;		/* Let the file system create the FSSpec if it can since it does the job */	/* much more efficiently than I can. */	result = FSMakeFSSpec(vRefNum, dirID, fileName, spec);	/* Fix a bug in Macintosh PC Exchange''s MakeFSSpec code where 0 is */	/* returned in the parID field when making an FSSpec to the volume''s */	/* root directory by passing a full pathname in MakeFSSpec''s */	/* fileName parameter. Fixed in Mac OS 8.1 */	if ( (result == noErr) && (spec->parID == 0) )		spec->parID = fsRtParID;	return ( result );}OSErr FSpLocationFromFullPath(short fullPathLength,									 const void *fullPath,									 FSSpec *spec){	AliasHandle	alias;	OSErr		result;	Boolean		wasChanged;	Str32		nullString;		/* Create a minimal alias from the full pathname */	nullString[0] = 0;	/* null string to indicate no zone or server name */	result = NewAliasMinimalFromFullPath(fullPathLength, fullPath, nullString, nullString, &alias);	if ( result == noErr )	{		/* Let the Alias Manager resolve the alias. */		result = ResolveAlias(NULL, alias, spec, &wasChanged);				/* work around Alias Mgr sloppy volume matching bug */		if ( spec->vRefNum == 0 )		{			/* invalidate wrong FSSpec */			spec->parID = 0;			spec->name[0] =  0;			result = nsvErr;		}		DisposeHandle((Handle)alias);	/* Free up memory used */	}	return ( result );}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 2/6/2001 10:53'!macWindowFile	^ '#include "sq.h"#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include <sound.h>#include <Math64.h>#include <cstddef>#include <processes.h>#include <OpenTransport.h>#include <stddef.h>/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//#define IHAVENOHEAD//Aug 7th 2000,JMM Added logic for interrupt driven dispatching//Sept 1st 2000, JMM fix problem with modifier information being passed back incorrectly.//Sept 1st 2000, JMM use floating point for time versus 64bit math (faster!!)//Sept 1st 2000, JMM watch mouse movement foreground only, ignore when squeak in background.//Sept 18th 2000, JMM fix to cmpSize //Sept 19th 2000, JMM Sept 1st fix to keyboard modifier info broke cmd shift//Sept 27 2000, JMM fix to documentPath//Nov 13 2000, JMM logic to read/write image from VM. //Nov 22 2000, JMM Bob Arning found a bug with the duplicate mouse event logic (we were altering the event then recording the altered value)//Nov 30 2000, JMM Use Open Transport clock versus upTime, solves some issues for jitter and it''s faster//Dec 5th 2000, JMM poll 60 times a second... do event polling via checkForInterrupts and drive semaphore//Dec 6th 2000, JMM added logic to interface with power manger (1997 was there but dropped..., back again for ibooks)//Jan 14th 2001, KG Did some carbon porting.//Feb 2nd 2001, JMM added zoom window support, full path support#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline Rect *GetRegionBounds(RgnHandle region, Rect * bounds) { *bounds = (*region)->rgnBBox; return &(*region)->rgnBBox;}        inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;OTTimeStamp     timeStart;Boolean         gTapPowerManager=false;Boolean         gDisablePowerManager=false;const long      gDisableIdleTickCount=60*10;long            gDisableIdleTickLimit=0;/*** Variables -- Event Recording ***/#define MAX_EVENT_BUFFER 1024int inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;/* declaration of the event message hook */typedef int (*eventMessageHook)(EventRecord* event);eventMessageHook messageHook = NULL;eventMessageHook postMessageHook = NULL;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);void SqueakTerminate();void ExitCleanup();int calculateStartLocationForImage();extern int dropInit(void);Boolean RunningOnCarbonX(void);void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax);GDHandle getDominateDevice(WindowPtr theWindow,Rect *windRect);OSStatus GetApplicationDirectory(short *vRefNum, long *dirID);extern pascal	OSErr	GetFullPath(short vRefNum,							long dirID,							ConstStr255Param name,							short *fullPathLength,							Handle *fullPath);/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);WindowPtr getSTWindow(void);int setMessageHook(eventMessageHook theHook);int setPostMessageHook(eventMessageHook theHook);void PowerMgrCheck(void);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */    int                 checkValueForEmbeddedImage;    OSErr               err;	Str32                name; 	/* record path to VM''s home folder */	short vRefNum;	long dirID;	// Get the Volume ref and Directory id of the Application''s directory.    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;	// Convert that to a full path string.	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);	checkValueForEmbeddedImage = calculateStartLocationForImage();	if (checkValueForEmbeddedImage == 0) {	    /* use default image name in same directory as the VM */	    strcpy(shortImageName, "squeak.image");	    return noErr;	}	if (err !!= noErr) {		strcpy(shortImageName, "squeak.image");	    return noErr;	}		CopyPascalStringToC(name,shortImageName);	StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);    return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, long refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;	char 		tempShortName[SHORTIMAGE_NAME_SIZE + 1];		short vRefNum;	long dirID;		reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */    err = GetApplicationDirectory(&vRefNum, &dirID);    if (err !!= noErr) return err;    	PathToWorkingDir(vmPath, VMPATH_SIZE, vRefNum, dirID);		/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {#ifdef IHAVENOHEAD		/* get image name */		err = AEGetNthPtr(&fileList, 1, typeFSS,						  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);		if (err) goto done;				err = FSpGetFInfo(&fileSpec,&finderInformation);		if (err) goto done;					CopyPascalStringToC(fileSpec.name,tempShortName);		if (finderInformation.fdType == ''SOBJ'') {			StoreFullPathForLocalNameInto(tempShortName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		}#endif		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	} else {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, long refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	static EventRecord oldEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if((messageHook) && (messageHook(&theEvent))) {        return ok;    }	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));    				if(postMessageHook) postMessageHook(&theEvent);					return false;				}				recordModifierButtons(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;#ifndef IHAVENOHEAD			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				GetPortBounds(GetWindowPort(stWindow),&bounds);				InvalWindowRect(stWindow,&bounds);			break;#endif			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex && windowActive && 		    !!((oldEvent.what == theEvent.what) &&  		    (oldEvent.message == theEvent.message) && 		    ((oldEvent.where.v == theEvent.where.v) && (oldEvent.where.h == theEvent.where.h)) && 		    (oldEvent.modifiers == theEvent.modifiers))) {    		oldEvent = theEvent; //JMM Nov 11th 2000 bug fix 			recordMouseEvent(&theEvent,MouseModifierState(&theEvent)); 		} 		else		 oldEvent = theEvent;	}	if(postMessageHook) postMessageHook(&theEvent); 	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent) {    BitMap      bmap;	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;#ifndef IHAVENOHEAD		case inDrag:			GetQDGlobalsScreenBits(&bmap);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &bmap.bounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inZoomIn:		case inZoomOut:			if (theWindow == stWindow) {					DoZoomWindow(theEvent,stWindow, windowCode,10000, 10000);				}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;#endif	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask))	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};#ifndef IHAVENOHEAD	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, zoomDocProc, (WindowPtr) -1L, false, 0);#endif}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);#ifndef IHAVENOHEAD	SetWTitle(stWindow, tempTitle);#endif}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordDragDropEvent(EventRecord *theEvent, int theButtonState, int numberOfItems, int dragType) {	sqDragDropFilesEvent *evt;		evt = (sqDragDropFilesEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeDragDropFiles;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	evt->numFiles = numberOfItems;	evt->dragType = dragType;		/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if (((modifierBits >> 3) & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return false;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return true;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;        	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	#ifdef PLUGIN	strcat(pluginDirPath, ":Plugins");#else	strcat(pluginDirPath, "Plugins");#endif 	        libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;#ifndef PLUGIN	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;#endif    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPCint ioMicroMSecs(void) {	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. */		register long check;		if((Ptr)OTElapsedMilliseconds!!=(Ptr)kUnresolvedCFragSymbolAddress){    	check = OTElapsedMilliseconds(&timeStart);    	if (check !!= -1)     	    return check;    	OTGetTimeStamp(&timeStart);	    return ioMicroMSecs();	}else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = CLOCKS_PER_SEC/60, nextPowerCheckOffset=CLOCKS_PER_SEC/2; 	static clock_t nextPollTick = 0, nextPowerCheck;	long    clockTime;#ifndef PLUGIN	if (clock() >= nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		        clockTime = clock();                if (gDisablePowerManager && gTapPowerManager) {            if (clockTime > gDisableIdleTickLimit)                gDisableIdleTickLimit = IdleUpdate() + gDisableIdleTickCount;                #if TARGET_CPU_PPC            if (clockTime > nextPowerCheck) {                 UpdateSystemActivity(UsrActivity);                 nextPowerCheck = clockTime + nextPowerCheckOffset;            }#endif        }        		/* wait a while before trying again */		nextPollTick = clockTime + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */       microSeconds;	ioProcessEvents();  /* process all pending events */}int ioScreenDepth(void) {    Rect ignore;        GDHandle mainDevice = getDominateDevice(stWindow,&ignore);    if (mainDevice == null)         return 8;        return (*(*mainDevice)->gdPMap)->pixelSize;}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    #ifndef IHAVENOHEAD	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}#endif	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;#ifndef IHAVENOHEAD	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}#endif}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect screen,portRect;	BitMap bmap;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;				GetQDGlobalsScreenBits(&bmap);    screen = bmap.bounds;    	if (fullScreen) {		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}#endifint ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);#if TARGET_API_MAC_CARBON	QDFlushPortBuffer (GetWindowPort(stWindow), maskRect);#endif	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short volumeNumber,long directoryID) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length, volumeNumber, directoryID);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*****************************************************************************************GetApplicationDirectoryGet the volume reference number and directory id of this application.Code taken from Apple:	Technical Q&As: FL 14 - Finding your application''s directory (19-June-2000)Karl Goiser 14/01/01*****************************************************************************************/        /* GetApplicationDirectory returns the volume reference number        and directory ID for the current application''s directory. */    OSStatus GetApplicationDirectory(short *vRefNum, long *dirID) {        ProcessSerialNumber PSN;        ProcessInfoRec pinfo;        FSSpec pspec;        OSStatus err;            /* valid parameters */        if (vRefNum == NULL || dirID == NULL) return paramErr;            /* set up process serial number */        PSN.highLongOfPSN = 0;        PSN.lowLongOfPSN = kCurrentProcess;            /* set up info block */        pinfo.processInfoLength = sizeof(pinfo);        pinfo.processName = NULL;        pinfo.processAppSpec = &pspec;            /* grab the vrefnum and directory */        err = GetProcessInformation(&PSN, &pinfo);        if (err == noErr) {            *vRefNum = pspec.vRefNum;            *dirID = pspec.parID;        }        return err;    }/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	short	fullPathLength;	Handle	fullPathHandle;	if (GetFullPath(volumeNumber, directoryID, nil, &fullPathLength, &fullPathHandle) !!= noErr) {		//Some sort of random guff for failure:		pathName[0] = 1;		pathName[1] = (char)":";		return 1;	}	strncpy((char *) pathName, (char *) *fullPathHandle, fullPathLength);	DisposeHandle(fullPathHandle);	return fullPathLength;}/*****************************************************************************/int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif	PowerMgrCheck();	SetUpClipboard();	SetUpPixmap();	dropInit();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	pathString; pathStringLength;	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;     FInfo fileInfo;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {        err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);        if (err !!= noErr) return 0; //This should not happen                //On the mac we start at location 0 if this isn''t an VM            	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')){    		/* truncate non-VM file if opening in write mode */    		err = SetEOF(fRefNum, 0);    		if (err !!= 0) {    			FSClose(fRefNum);    			return null;    		}	    }	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}int calculateStartLocationForImage() { 	Handle cfrgResource;  	long	memberCount,i;	CFragResourceMember *target;		cfrgResource = GetResource(kCFragResourceType,0); 	if (cfrgResource == nil || ResError() !!= noErr) { return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {        ReleaseResource(cfrgResource);	    return 0; //Need FAT to get counters right	}		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {					    ReleaseResource(cfrgResource);		    return target->offset;		}		target = NextCFragResourceMemberPtr(target); 	}    ReleaseResource(cfrgResource);	return 0;}int sqImageFileStartLocation(int fileRef, char *filename, int imageSize){    FInfo fileInfo;	Str255 tempPascalFileName;	OSErr   err;     int     resFileRef;	Handle  cfrgResource,newcfrgResource;  	UInt32	maxOffset=0,maxOffsetLength,targetOffset;	long    memberCount,i;	CFragResourceMember *target;      	CopyCStringToPascal(filename,tempPascalFileName);    err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);    if (err !!= noErr) return 0; //This should not happen        //On the mac we start at location 0 if this isn''t an VM    	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')) return 0;        //Ok we have an application file, open the resource part and attempt to find the crfg        resFileRef = HOpenResFile(0,0,tempPascalFileName,fsWrPerm);    if (resFileRef == -1) return 0;    	cfrgResource = GetResource(kCFragResourceType,0);	if (cfrgResource == nil || ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};  //Need FAT to get counters right		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {		    targetOffset = target->offset;		    target->length = imageSize;		    ChangedResource(cfrgResource);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		    UpdateResFile(resFileRef);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};             ReleaseResource(cfrgResource); 		    CloseResFile(resFileRef);			return targetOffset;		}		if (target->offset > maxOffset) {			maxOffset = target->offset;			maxOffsetLength = target->length;		}		target = NextCFragResourceMemberPtr(target);	}		//Ok at this point we need to alter the crfg to add the new tag for the image part		newcfrgResource = cfrgResource;	err = HandToHand(&newcfrgResource);	if (err !!= noErr || MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 	SetHandleSize(newcfrgResource,GetHandleSize(cfrgResource)+AlignToFour(kBaseCFragResourceMemberSize + 1));	if (MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		target = &((CFragResource *)(*newcfrgResource))->firstMember; 	for(i=0;i<memberCount;i++) {		target = NextCFragResourceMemberPtr(target); 	}    target->architecture = ''FAST'';    target->reservedA = 0;                  /* !! Must be zero!!*/    target->reservedB = 0;                  /* !! Must be zero!!*/    target->updateLevel = 0;    target->currentVersion = 0;    target->oldDefVersion = 0;    target->uUsage1.appStackSize = 0;    target->uUsage2.appSubdirID = 0;    target->uUsage2.libFlags = 0;    target->usage = kApplicationCFrag;    target->where = kDataForkCFragLocator;    target->offset = maxOffset + maxOffsetLength;    targetOffset = target->offset;    target->length = imageSize;    target->uWhere1.spaceID = 0;    target->extensionCount = 0;             /* The number of extensions beyond the name.*/    target->memberSize = AlignToFour(kBaseCFragResourceMemberSize + 1);   /* Size in bytes, includes all extensions.*/    target->name[0] = 0x00;	((CFragResource *)(*newcfrgResource))->memberCount = memberCount+1;	RemoveResource(cfrgResource);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  	AddResource(newcfrgResource,kCFragResourceType,0,nil);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     UpdateResFile(resFileRef);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     CloseResFile(resFileRef);    	return targetOffset;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */		minHeapSize;	return NewPtr(desiredHeapSize);;}#endifvoid PowerMgrCheck(void) {	long pmgrAttributes;		gTapPowerManager = false;	gDisablePowerManager = false;	if (!! Gestalt(gestaltPowerMgrAttr, &pmgrAttributes))		if ((pmgrAttributes & (1<<gestaltPMgrExists)) 		    && (pmgrAttributes & (1<<gestaltPMgrDispatchExists))		    && (PMSelectorCount() >= 0x24)) {		    gTapPowerManager = true;			gDisableIdleTickLimit = clock();		}}int ioDisablePowerManager(int disableIfNonZero) {    gDisablePowerManager = disableIfNonZero;}Boolean RunningOnCarbonX(void){    UInt32 response;        return (Gestalt(gestaltSystemVersion,                     (SInt32 *) &response) == noErr)                && (response >= 0x01000);}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	short vRefNum;	long dirID;	OSErr err;	InitMacintosh();	PowerMgrCheck();		SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	dropInit();	SetEventMask(everyEvent); // also get key up events	#if TARGET_CPU_PPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif 	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		err = GetApplicationDirectory(&vRefNum, &dirID);		if (err !!= noErr) error("Could not obtain default directory");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE, vRefNum, dirID);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	if (RunningOnCarbonX())	    availableMemory = 100*1024*1024 - reservedMemory;	else     	availableMemory = MaxBlock() - reservedMemory;		/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500 for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSizeStartingAt(f, availableMemory, calculateStartLocationForImage());	sqImageFileClose(f);#ifndef IHAVENOHEAD	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);#endif	/* run Squeak */	interpret();}#endifvoid SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}WindowPtr getSTWindow(void) {    return stWindow;}int setMessageHook(eventMessageHook theHook) {    messageHook = theHook;}int setPostMessageHook(eventMessageHook theHook) {    postMessageHook = theHook;}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of while (*s++ = *t++) because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif#define rectWidth(aRect) ((aRect).right - (aRect).left)#define rectHeight(aRect) ((aRect).bottom - (aRect).top)#define MinWindowWidth(foo) 72*3#define MinWindowHeight(foo) 72*3#define max(X, Y) ( ((X)>(Y)) ? (X) : (Y) )#define min(X, Y) (  ((X)>(Y)) ? (Y) : (X) )#define pin(VALUE, MIN, MAX) ( ((VALUE) < (MIN)) ? (MIN) : ( ((VALUE) > (MAX)) ? (MAX) : (VALUE) ) )void DoZoomWindow (EventRecord* theEvent, WindowPtr theWindow, short zoomDir, short hMax, short vMax){	Rect				*zoomRect,windRect;	Rect				globalPortRect, dGDRect,bounds,zoomRectStorage;	GDHandle			dominantGDevice;    RgnHandle           windowRegion;    BitMap              bmap;        zoomRect = &zoomRectStorage;	if (TrackBox(theWindow, theEvent->where, zoomDir)) {		SetPortWindowPort(theWindow);		GetPortBounds(GetWindowPort(stWindow),&bounds);		EraseRect(&bounds);	// recommended for cosmetic reasons		if (zoomDir == inZoomOut) {			/*			 *	ZoomWindow() is a good basic tool, but it doesn''t do everything necessary to			 *	implement a good human interface when zooming. In fact it''s not even close for			 *	more high-end hardware configurations. We must help it along by calculating an			 *	appropriate window size and location any time a window zooms out.			 */            dominantGDevice = getDominateDevice(theWindow,&windRect);			/*			 *	At this point, we know the dimensions of the window we''re zooming, and we know			 *	what screen we''re going to put it on. To be more specific, however, we need a			 *	rectangle which defines the maximum dimensions of the resized window''s contents.			 *	This rectangle accounts for the thickness of the window frame, the menu bar, and			 *	one or two pixels around the edges for cosmetic compatibility with ZoomWindow().			 */			if (dominantGDevice !!= nil) {				dGDRect = (**dominantGDevice).gdRect;				if (dominantGDevice == GetMainDevice())		// account for menu bar on main device					dGDRect.top += GetMBarHeight();			}			else {				GetQDGlobalsScreenBits(&bmap);				dGDRect = bmap.bounds;				// if no gDevice, use default monitor				dGDRect.top += GetMBarHeight();			}			GetPortBounds(GetWindowPort(theWindow),&globalPortRect);			LocalToGlobal(&topLeft(globalPortRect));		// calculate the window''s portRect			LocalToGlobal(&botRight(globalPortRect));		// in global coordinates			// account for the window frame and inset it a few pixels			dGDRect.left	+= 2 + globalPortRect.left - windRect.left;			dGDRect.top		+= 2 + globalPortRect.top - windRect.top;			dGDRect.right	-= 1 + windRect.right - globalPortRect.right;			dGDRect.bottom	-= 1 + windRect.bottom - globalPortRect.bottom;			/*			 *	Now we know exactly what our limits are, and since there are input parameters			 *	specifying the dimensions we''d like to see, we can move and resize the zoom			 *	state rectangle for the best possible results. We have three goals in this:			 *	1. Display the window entirely visible on a single device.			 *	2. Resize the window to best represent the dimensions of the document itself.			 *	3. Move the window as short a distance as possible to achieve #1 and #2.			 */			GetWindowStandardState(theWindow, zoomRect);			/*			 *	Initially set the zoom rectangle to the size requested by the input parameters,			 *	although not smaller than a minimum size. We do this without moving the origin.			 */			zoomRect->right = (zoomRect->left = globalPortRect.left) +									max(hMax, MinWindowWidth(theWindow));			zoomRect->bottom = (zoomRect->top = globalPortRect.top) +									max(vMax, MinWindowHeight(theWindow));			// Shift the entire rectangle if necessary to bring its origin inside dGDRect.			OffsetRect(zoomRect,						max(dGDRect.left - zoomRect->left, 0),						max(dGDRect.top - zoomRect->top, 0));			/*			 *	Shift the rectangle up and/or to the left if necessary to accomodate the view,			 *	and if it is possible to do so. The rectangle may not be moved such that its			 *	origin would fall outside of dGDRect.			 */			OffsetRect(zoomRect,						-pin(zoomRect->right - dGDRect.right, 0, zoomRect->left - dGDRect.left),						-pin(zoomRect->bottom - dGDRect.bottom, 0, zoomRect->top - dGDRect.top));			// Clip expansion to dGDRect, in case view is larger than dGDRect.			zoomRect->right = min(zoomRect->right, dGDRect.right);			zoomRect->bottom = min(zoomRect->bottom, dGDRect.bottom);		}		ZoomWindow(theWindow, zoomDir, false);		// all it needed was a brain transplant	}}GDHandle getDominateDevice( WindowPtr theWindow,Rect *windRect) {	GDHandle			nthDevice, dominantGDevice;	long				sectArea, greatestArea;    long                quickDrawAttributes;	Rect				theSect;    RgnHandle           windowRegion;    #if TARGET_API_MAC_CARBON			windowRegion = NewRgn();			GetWindowRegion(theWindow,kWindowStructureRgn,windowRegion);			GetRegionBounds(windowRegion,windRect);#else			windRect = &(**((WindowPeek) theWindow)->strucRgn).rgnBBox;#endif			dominantGDevice = nil;    	    if (!! Gestalt(gestaltQuickdrawFeatures, &quickDrawAttributes) &&     	        (quickDrawAttributes & (1<<gestaltHasColor))) {				/*				 *	Color QuickDraw implies the possibility of multiple monitors. This is where				 *	zooming becomes more interesting. One should zoom onto the monitor containing				 *	the greatest portion of the window. This requires walking the gDevice list.				 */				nthDevice = GetDeviceList();				greatestArea = 0;				while (nthDevice !!= nil) {					if (TestDeviceAttribute(nthDevice, screenDevice)) {						if (TestDeviceAttribute(nthDevice, screenActive)) {							SectRect(windRect, &(**nthDevice).gdRect, &theSect);							sectArea = (long) rectWidth(theSect) * (long) rectHeight(theSect);							if (sectArea > greatestArea) {								greatestArea = sectArea;		// save the greatest intersection								dominantGDevice = nthDevice;	// and which device it belongs to							}						}					}					nthDevice = GetNextDevice(nthDevice);				}			}    return dominantGDevice;}'! !