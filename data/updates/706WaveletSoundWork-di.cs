'From Squeak 2.3 of January 14, 1999 on 8 March 1999 at 9:38:18 am'!"Change Set:		WaveletSoundWorkDate:			8 March 1999Author:			Dan IngallsThis changSet improves the WaveletCodec by preserving more information on non-truncated samples and generally simplifying the run-coded valuesIt also restores the sound trimming feature of the SoundRecorder, which had been broken by the changes to support silence suppression in speech."!!AbstractSound methodsFor: 'copying' stamp: 'di 3/4/1999 21:29'!sounds	"Allows simple sounds to behave as, eg, sequential sounds"	^ Array with: self! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 3/4/1999 22:38'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'results' stamp: 'di 3/4/1999 21:40'!condensedSamples	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."	| sz newBuf i |	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ SoundBuffer new: 0].	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	newBuf _ SoundBuffer newMonoSampleCount: sz.	i _ 1.	recordedBuffers do: [:b |		1 to: b size do: [:j |			newBuf at: i put: (b at: j).			i _ i + 1]].	recordedBuffers _ nil.	^ newBuf! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:13'!scanForStartThreshold: threshold dcOffset: dcOffset minDur: duration startingAt: startPlace	"Beginning at startPlace, this routine will find the first sound that exceeds threshold, such that if you look duration samples later you will find another sound over threshold within the following block of duration samples.	Return the place that is duration samples prior to that first sound.	If no sound is found, return endPlace."	| soundPlace lookPlace nextSoundPlace thirdPlace |	soundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: startPlace.	[soundPlace = self endPlace ifTrue: [^ soundPlace].	"Found a sound -- look duration later"	lookPlace _ self place: soundPlace plus: duration.	nextSoundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: lookPlace.	thirdPlace _ self place: lookPlace plus: duration.	nextSoundPlace first < thirdPlace first		or: [nextSoundPlace first = thirdPlace first			and: [nextSoundPlace second < thirdPlace second]]]		whileFalse: [soundPlace _ nextSoundPlace].	"Yes, there is sound in the next interval as well"	^ self place: soundPlace plus: 0-duration! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 21:26'!segmentsAbove: threshold normalizedVolume: percentOfMaxVolume	"Break the current recording up into a sequence of sound segments separated by silences."	| max min sum totalSamples bufSize s dcOffset firstPlace endPlace resultBuf nFactor lastPlace segments gapSize minDur minLull soundSize restSize |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	(recordedSound == nil or: [recordedSound sounds isEmpty]) ifTrue:[^ self].	"Reconstruct buffers so old trimming code will work"	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	soundSize _ restSize _ 0.	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	minDur _ (samplingRate/20.0) asInteger.  " 1/20 second "	minLull _ (samplingRate/4.0) asInteger.  " 1/2 second "	segments _ SequentialSound new.	endPlace _ self endPlace.	lastPlace _ #(1 1).	[firstPlace _ self scanForStartThreshold: threshold						dcOffset: dcOffset						minDur: minDur						startingAt: lastPlace.	firstPlace = endPlace]		whileFalse:		[firstPlace = lastPlace ifFalse:			["Add a silence equal to the gap size"			"Wasteful but simple way to get gap size..."			gapSize _ (self copyFrom: lastPlace to: firstPlace						normalize: 1000 dcOffset: dcOffset) size - 2.			"... -2 makes up for overlap of one sample on either end"			segments add: (RestSound dur: gapSize asFloat / samplingRate).			restSize _ restSize + gapSize."Transcript cr; print: firstPlace; space; print: lastPlace; space; print: gapSize; space; show: 'gap'."			].		lastPlace _ self scanForEndThreshold: threshold						dcOffset: dcOffset						minLull: minLull + minDur						startingAt: firstPlace.		"Allow room for lead time of next sound"		lastPlace _ self place: lastPlace plus: minDur negated.		nFactor _ self normalizeFactorFor: percentOfMaxVolume						min: min max: max dcOffset: dcOffset.		resultBuf _ self copyFrom: firstPlace to: lastPlace						normalize: nFactor dcOffset: dcOffset.		soundSize _ soundSize + resultBuf size."Transcript cr; print: firstPlace; space; print: lastPlace; space; print: resultBuf size; space; show: 'sound'."		segments add: (codec == nil			ifTrue: [SampledSound new setSamples: resultBuf samplingRate: samplingRate]			ifFalse: [codec compressSound: (SampledSound new setSamples: resultBuf samplingRate: samplingRate)])].	"Final gap for consistency"	gapSize _ (self copyFrom: lastPlace to: self endPlace				normalize: 1000 dcOffset: dcOffset) size - 1.	segments add: (RestSound dur: gapSize asFloat / samplingRate).	restSize _ restSize + gapSize.	PopUpMenu notify: ((soundSize+restSize/samplingRate) roundTo: 0.1) printString , ' secs reduced to ' , ((soundSize/samplingRate) roundTo: 0.1) printString.	recordedBuffers _ nil.	^ segments! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:52'!trim: threshold normalizedVolume: percentOfMaxVolume	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ self].	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	"a place is an array of <buffer index><index of sample in buffer>"	startPlace _ self scanForStartThreshold: threshold					dcOffset: dcOffset					minDur: (samplingRate/60.0) asInteger "at least 1/60th of a second"					startingAt: #(1 1).	startPlace = self endPlace ifTrue:		["no samples above threshold"		recordedBuffers _ nil.  ^ self].	endPlace _ self scanForEndThreshold: threshold					dcOffset: dcOffset					minLull: (samplingRate/5) asInteger					startingAt: startPlace.	nFactor _ self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.	resultBuf _ self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.	recordedSound _ SampledSound new setSamples: resultBuf samplingRate: samplingRate.	recordedBuffers _ nil! !!WaveletCodec commentStamp: 'di 3/8/1999 08:26' prior: 0!The Wavelet codec performs a wavelet transform on the original data.  It then achieves its compression by thresholding the transformed data, converting all values below a given magnitude to zero, and then run-coding the resulting data.  The run-coding provides automatic variable compression depending on the parameters chosen.As is, this codec achieves reasonable reproduction at 10:1 compression, although the quality from the GSMCodec is definitely better.  I feel that the quality would be comparable if uLaw scaling were introduced prior to thresholding.The nice thing about using wavelets is there are numerous factors to play with for better performance:	nLevels - the "order" of the transform performed	alpha and beta - these specify the wavelet shape (some are better for speech)	the actual threshold usedBy simply changing these parameters, one can easily vary the compression achieved from 5:1 to 50:1, and listen to the quality at each step.The specific format for an encoded buffer is as follows:	4 bytes: frameCount.	4 bytes: samplesPerFrame.	4 bytes: nLevels.	4 bytes: alpha asIEEE32BitWord.	4 bytes: beta asIEEE32BitWord.	frameCount occurrences of...		2 bytes: frameSize in bytes, not including these 2			may be = 0 for complete silence, meaning no scale even.		4 bytes: scale asIEEE32BitWord.		A series of 1- or 2-byte values encoded as follows:			0-111: 	a run of N+1 consecutive 0's;			112-127:	a run of (N-112)*256 + nextByte + 1 consecutive 0's;			128-255:	a 15-bit signed value = (N*256 + nextByte) - 32768 - 16384.!!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'di 3/8/1999 08:20'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffArray scale i c nullCount samples sourceFrameEnd frameSize inStream val |	inStream _ ReadStream on: srcByteArray from: srcIndex to: srcByteArray size.	"frameCount _ " inStream nextNumber: 4.	samplesPerFrame _ inStream nextNumber: 4.	nLevels _ inStream nextNumber: 4.	alpha _ Float fromIEEE32Bit: (inStream nextNumber: 4).	beta _ Float fromIEEE32Bit: (inStream nextNumber: 4).	fwt ifNil:		["NOTE: This should read parameters from the encoded data"		fwt _ FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	frameBase _ dstIndex.	coeffArray _ fwt coeffs.  "A copy that we can modify"	1 to: frameCount do:		[:frame | 		"Decode the scale for this frame"		frameSize _ inStream nextNumber: 2.		sourceFrameEnd _ frameSize + inStream position.		scale _ Float fromIEEE32Bit: (inStream nextNumber: 4).		"Expand run-coded samples to scaled float values."		i _ 5.		[i <= coeffArray size]			whileTrue:			[c _ inStream next.			c < 128				ifTrue: [nullCount _ c < 112							ifTrue: [c + 1]							ifFalse: [(c-112)*256 + inStream next + 1].						i to: i + nullCount - 1 do: [:j | coeffArray at: j put: 0.0].						i _ i + nullCount]				ifFalse: [val _ (c*256 + inStream next) - 32768 - 16384.						coeffArray at: i put: val * scale.						i _ i + 1]].		"Copy float values into the wavelet sample array"					fwt coeffs: coeffArray.		"Compute the transform"		fwt transformForward: false.		"Determine the scale for this frame"		samples _ fwt samples.		samples size = samplesPerFrame ifFalse: [self error: 'frame size error'].		1 to: samples size do:			[:j | dstSoundBuffer at: frameBase + j - 1 put: (samples at: j) asInteger].		inStream position = sourceFrameEnd ifFalse: [self error: 'frame size error'].		frameBase _ frameBase + samplesPerFrame].	^ Array with: inStream position + 1 - srcIndex			with: frameBase - dstIndex! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'di 3/8/1999 09:12'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffs maxVal minVal c scale nullCount frameI outFrameSize threshold sm outStream cMin val |	threshold _ 2000.	fwt ifNil:		[samplesPerFrame _ self samplesPerFrame.		nLevels _ 8.		"Here are some sample mother wavelets, with the compression achieved on a		sample of my voice at a threshold of 2000:									compression achieved "		alpha _ 0.0.  beta _ 0.0.		"12.1"		alpha _ 1.72.  beta _ 1.51.	"14.0"		alpha _ -1.86.  beta _ -1.53.	"14.4"		alpha _ 1.28.  beta _ -0.86.	"15.9"		alpha _ -1.15.  beta _ 0.69.	"16.0"		fwt _ FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	(outStream _ WriteStream on: dstByteArray from: dstIndex to: dstByteArray size)		nextNumber: 4 put: frameCount;		nextNumber: 4 put: samplesPerFrame;		nextNumber: 4 put: nLevels;		nextNumber: 4 put: alpha asIEEE32BitWord;		nextNumber: 4 put: beta asIEEE32BitWord.	frameBase _ srcIndex.	1 to: frameCount do:		[:frame | 		"Copy float values into the wavelet sample array"				fwt samples: ((frameBase to: frameBase + samplesPerFrame-1) 				collect: [:i | (srcSoundBuffer at: i) asFloat]).		"Compute the transform"		fwt transformForward: true.		frameI _ outStream position+1.  "Reserve space for frame size"		outStream nextNumber: 2 put: 0.		"Determine and output the scale for this frame"		coeffs _ fwt coeffs.		maxVal _ 0.0.  minVal _ 0.0.		5 to: coeffs size do:			[:i | c _ coeffs at: i.			c > maxVal ifTrue: [maxVal _ c].			c < minVal ifTrue: [minVal _ c]].		scale _ (maxVal max: minVal negated) / 16000.0.  "Will scale all to -16k..16k: 15 bits"		outStream nextNumber: 4 put: scale asIEEE32BitWord.		"Copy scaled values, with run-coded sequences of 0's, to destByteArray"		nullCount _ 0.		cMin _ threshold / scale.		5 to: coeffs size do:			[:i | c _ (coeffs at: i) / scale.			c abs < cMin			ifTrue: ["Below threshold -- count nulls."					nullCount _ nullCount + 1]			ifFalse: ["Above threshold -- emit prior null count and this sample."					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1].						nullCount _ 0].						val _ c asInteger + 16384 + 32768.  "Map -16k..16k into 32k..64k"						outStream nextNumber: 2 put: val]].					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1]].		outFrameSize _ outStream position+1 - frameI - 2.  "Write frame size back at the beginning"		(WriteStream on: dstByteArray from: frameI to: dstByteArray size)			nextNumber: 2 put: outFrameSize.		frameBase _ frameBase + samplesPerFrame]."This displays a temporary indication of compression achieved"sm _ TextMorph new contents: (((frameBase - srcIndex) *2.0 / (outStream position+1 - dstIndex) truncateTo: 0.1) printString , ' : 1') asText allBold.sm position: Sensor cursorPoint + (-20@30).World addMorph: sm; doOneCycleNow.sm delete.	outStream position > dstByteArray size ifTrue:		["The calling routine only provides buffer space for compression of 2:1 or better.  If you are just testing things, you can increase it to, eg, codeFrameSize _ frameSize*3, which would be sufficient for a threshold of 0 (lossless conversion)."		self error: 'Buffer overrun'].	^ Array with: frameBase - srcIndex			with: outStream position+1 - dstIndex! !!WriteStream methodsFor: 'accessing' stamp: 'di 3/8/1999 09:02'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection at: position put: anObject]! !SoundRecorder removeSelector: #scanForEndThreshold:dcOffset:!SoundRecorder removeSelector: #scanForStartThreshold:dcOffset:!Smalltalk removeClassNamed: #WaveletCodecTest!Smalltalk removeClassNamed: #WaveletCodecTest2!