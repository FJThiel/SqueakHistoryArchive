'From Squeak3.1alpha of 4 February 2001 [latest update: #3779] on 4 March 2001 at 10:31:27 pm'!"Change Set:		JPEGDecoderDate:			4 March 2001Author:			Andreas RaabSeveral improvements for JPEG reading. Provides a plugin for three critical methods in the decoder speeding things up roughly by a factor of 15 (there is probably another speedup of 2-3 in the prims itself but right now I can't be bothered to go looking for it). Even the simulated version is about 10% faster. Test results against a 1280x1024 picture resulted in:Old: 	56 seconds.New: 	49 seconds (without plugin)		3.3 seconds (with plugin)Also provides primitives for reading 32bit signed integers from word-indexed objects (e.g., IntegerArray). The above values were based on a VM that *did* have those primitives; otherwise the results of the simulation would be WAY slower."!Object subclass: #JPEGColorComponent	instanceVariableNames: 'id hSampleFactor vSampleFactor dctSize qTableIndex dcTableIndex acTableIndex widthInBlocks heightInBlocks mcuWidth mcuHeight mcuBlocks currentX currentY priorDCValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Files'!!JPEGColorComponent commentStamp: '<historical>' prior: 0!I represent a single component of color in JPEG YCbCr color space.  I can accept a list of blocks in my component from the current MCU, then stream the samples from this block for use in color conversion.  I also store the running DC sample value for my component, used by the Huffman decoder.The following layout is fixed for the JPEG primitives to work:	currentX 		<SmallInteger>	currentY 		<SmallInteger>	hSampleFactor 	<SmallInteger>	vSampleFactor 	<SmallInteger>	mcuBlocks 		<Array of: <IntegerArray of: DCTSize2 * Integer>>	widthInBlocks 	<SmallInteger>	heightInBlocks 	<SmallInteger>	dctSize 			<SmallInteger>	mcuWidth 		<SmallInteger>	mcuHeight 		<SmallInteger>	priorDCValue 	<SmallInteger>!ReadStream subclass: #JPEGReadStream	instanceVariableNames: 'bitBuffer bitsInBuffer '	classVariableNames: 'MaxBits '	poolDictionaries: ''	category: 'Graphics-Files'!!JPEGReadStream commentStamp: '<historical>' prior: 0!Encapsulates huffman encoded access to JPEG data.The following layout is fixed for the JPEG primitives to work:	collection	<ByteArray | String>	position		<SmallInteger>	readLimit	<SmallInteger>	bitBuffer	<SmallInteger>	bitsInBuffer	<SmallInteger>!ImageReadWriter subclass: #JPEGReadWriter	instanceVariableNames: 'width height components currentComponents qTable hACTable hDCTable bitBuffer bitsInBuffer lookahead restartInterval restartsToGo mcuWidth mcuHeight mcusPerRow mcuRowsInScan mcuMembership mcuSampleBuffer mcuImageBuffer majorVersion minorVersion dataPrecision densityUnit xDensity yDensity ss se ah al sosSeen redResidual greenResidual blueResidual ditherMask residuals '	classVariableNames: 'ConstBits DCTK1 DCTK2 DCTK3 DCTK4 DCTSize DCTSize2 DitherMasks FIXn0n298631336 FIXn0n34414 FIXn0n390180644 FIXn0n541196100 FIXn0n71414 FIXn0n765366865 FIXn0n899976223 FIXn1n175875602 FIXn1n40200 FIXn1n501321110 FIXn1n77200 FIXn1n847759065 FIXn1n961570560 FIXn2n053119869 FIXn2n562915447 FIXn3n072711026 FloatSampleOffset HuffmanTableSize JFIFMarkerParser JPEGNaturalOrder MaxSample Pass1Bits Pass1Div Pass2Div QTableScaleFactor QuantizationTableSize SampleOffset '	poolDictionaries: ''	category: 'Graphics-Files'!InterpreterPlugin subclass: #JPEGReaderPlugin	instanceVariableNames: 'yComponent crComponent cbComponent ySampleStream crSampleStream cbSampleStream yBlocks crBlocks cbBlocks residuals ditherMask jpegBits jpegBitsSize jpegNaturalOrder jsCollection jsPosition jsReadLimit jsBitBuffer jsBitCount acTable dcTable acTableSize dcTableSize '	classVariableNames: 'BlockWidthIndex BlueIndex ConstBits CurrentXIndex CurrentYIndex DCTSize DCTSize2 FIXn0n298631336 FIXn0n34414 FIXn0n390180644 FIXn0n541196100 FIXn0n71414 FIXn0n765366865 FIXn0n899976223 FIXn1n175875602 FIXn1n40200 FIXn1n501321110 FIXn1n77200 FIXn1n847759065 FIXn1n961570560 FIXn2n053119869 FIXn2n562915447 FIXn3n072711026 GreenIndex HScaleIndex LookaheadBitsIndex LookaheadSymbolIndex MCUBlockIndex MCUWidthIndex MaxBits MaxMCUBlocks MaxSample MaxcodeIndex MinComponentSize Pass1Bits Pass1Div Pass2Div PriorDCValueIndex RedIndex SampleOffset VScaleIndex '	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!JPEGReaderPlugin commentStamp: '<historical>' prior: 0!JPEGReaderPlugin translate.JPEGReaderPlugin browseAllCallsOn: #halt.!!B3DPrimitiveRasterizerData methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:41'!integerAt: index	"Return the integer at the given index"	| word |	<primitive: 165>	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:41'!integerAt: index	"Return the integer at the given index"	| word |	<primitive: 165>	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:42'!integerAt: index put: anInteger	"Store the integer at the given index"	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!Interpreter methodsFor: 'sound primitives' stamp: 'ar 3/4/2001 15:54'!primitiveIntegerAt	"Return the 32bit signed integer contents of a words receiver"	| index rcvr sz addr value |	index _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	(self isIntegerObject: rcvr) ifTrue:[^self success: false].	(self isWords: rcvr) ifFalse:[^self success: false].	sz _ self lengthOf: rcvr.  "number of fields"	self success: ((index >= 1) and: [index <= sz]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize - 4 "for zero indexing" + (index * 4).		value _ self cCode:'*((int *) addr)' inSmalltalk:[self integerAt: addr].		self pop: 2.  "pop rcvr, index"		"push element value"		(self isIntegerValue: value)			ifTrue:[self pushInteger: value]			ifFalse:[self push: (self signed32BitIntegerFor: value)].	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'ar 3/4/2001 15:54'!primitiveIntegerAtPut	"Return the 32bit signed integer contents of a words receiver"	| index rcvr sz addr value valueOop |	valueOop _ self stackValue: 0.	index _ self stackIntegerValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: rcvr) ifTrue:[^self success: false].	(self isWords: rcvr) ifFalse:[^self success: false].	sz _ self lengthOf: rcvr.  "number of fields"	((index >= 1) and: [index <= sz]) ifFalse:[^self success: false].	(self isIntegerObject: valueOop)		ifTrue:[value _ self integerValueOf: valueOop]		ifFalse:[value _ self signed32BitValueOf: valueOop].	successFlag ifTrue:[		addr _ rcvr + BaseHeaderSize - 4 "for zero indexing" + (index * 4).		value _ self cCode:'*((int *) addr) = value' inSmalltalk:[self integerAt: addr put: value].		self pop: 3 thenPush: valueOop. "pop all; return value"	].! !!Interpreter class methodsFor: 'initialization' stamp: 'ar 3/3/2001 22:26'!initializePrimitiveTable 	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveGetNextEvent)				"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveObsoleteIndexedPrimitive)	"primitiveCopyBits"		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveObsoleteIndexedPrimitive)	"primitiveDrawLoop"		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveChangeClass)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveCalloutToFFI)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		"NOTE: When removing the obsolete indexed primitives,		the following two should go become #primitiveIntegerAt / atPut"		(146 primitiveObsoleteIndexedPrimitive)	"primitiveReadJoystick"		(147 primitiveObsoleteIndexedPrimitive)	"primitiveWarpBits"		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169) - NO LONGER INDEXED"		(150 164 primitiveObsoleteIndexedPrimitive)		(165 primitiveIntegerAt)		"hacked in here for now"		(166 primitiveIntegerAtPut)		(167 168 primitiveFail)		(169 primitiveObsoleteIndexedPrimitive)		"Sound Primitives (170-199) - NO LONGER INDEXED"		(170 185 primitiveObsoleteIndexedPrimitive)		(186 188 primitiveFail)		(189 194 primitiveObsoleteIndexedPrimitive)		(195 199 primitiveFail)		"Networking Primitives (200-229) - NO LONGER INDEXED"		(200 225 primitiveObsoleteIndexedPrimitive)		(226 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primitiveObsoleteIndexedPrimitive) "primBitmapdecompressfromByteArrayat"		(235 primitiveObsoleteIndexedPrimitive) "primStringcomparewithcollated"		(236 primitiveObsoleteIndexedPrimitive) "primSampledSoundconvert8bitSignedFromto16Bit"		(237 primitiveObsoleteIndexedPrimitive) "primBitmapcompresstoByteArray"		(238 241 primitiveObsoleteIndexedPrimitive) "serial port primitives"		(242 primitiveFail)		(243 primitiveObsoleteIndexedPrimitive) "primStringtranslatefromtotable"		(244 primitiveObsoleteIndexedPrimitive) "primStringfindFirstInStringinSetstartingAt"		(245 primitiveObsoleteIndexedPrimitive) "primStringindexOfAsciiinStringstartingAt"		(246 primitiveObsoleteIndexedPrimitive) "primStringfindSubstringinstartingAtmatchTable"		(247 primitiveSnapshotEmbedded)		(248 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539) - NO LONGER INDEXED"		(520 529 primitiveObsoleteIndexedPrimitive)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives - NO LONGER INDEXED"		(540 545 primitiveObsoleteIndexedPrimitive)		(546 547 primitiveFail)		"Pen Tablet Primitives - NO LONGER INDEXED"		(548 primitiveObsoleteIndexedPrimitive)		(549 primitiveObsoleteIndexedPrimitive)		"Sound Codec Primitives - NO LONGER INDEXED"		(550 553 primitiveObsoleteIndexedPrimitive)		(554 569 primitiveFail)		"External primitive support primitives"		(570 primitiveFlushExternalPrimitives)		(571 primitiveUnloadModule)		(572 primitiveListBuiltinModule)		(573 primitiveListExternalModule)		(574 primitiveFail) "reserved for addl. external support prims"		"Unassigned Primitives"		(575 700 primitiveFail)).! !!Interpreter class methodsFor: 'translation' stamp: 'ar 3/4/2001 22:11'!translate: fileName doInlining: inlineFlag forBrowserPlugin: pluginFlag	"Note: The pluginFlag is meaningless on Windows and Unix. On these platforms Squeak runs as it's own process and doesn't need any special attention from the VMs point of view. Meaning that NONE of the required additional functions will be supported. In other words, the pluginFlag is not needed and not supported."	"Translate the Smalltalk description of the virtual machine into C. If inlineFlag is true,small method bodies are inlined to reduce procedure call overhead. On the PPC, this results in a factor of three speedup with only 30% increase in code size. If pluginFlag is true, generate code for an interpreter that runs as a browser plugin (Netscape or IE)."	| doInlining cg exports |	doInlining _ inlineFlag.	pluginFlag ifTrue: [doInlining _ true].  "must inline when generating browser plugin"	Interpreter initialize.	ObjectMemory initialize.	GenerateBrowserPlugin _ pluginFlag.	cg _ CCodeGenerator new initialize.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	"Get all the named prims from the VM.	Note: the format of exports is:		pluginName -> Array of: primitiveName.	so we can generate a nice table from it."	exports _ Array with: '' -> cg exportedPrimitiveNames asArray.	cg storeCodeOnFile: fileName doInlining: doInlining.	"Add our plugins"	{		"Graphics"			"Note: BitBltSimulation should go first, 			because three of it's entries might be 			looked up quite often (due to refs from 			InterpreterProxy). This will go away at			some point but for now it's a good idea			to have those entries early in the table."		BitBltSimulation.			BalloonEnginePlugin. 		SurfacePlugin. "To support OS surfaces through FXBlt"		"I/O subsystems"		FilePlugin.		SocketPlugin.		MIDIPlugin. 		SerialPlugin. 		JoystickTabletPlugin. 		AsynchFilePlugin. 		"Sound"		SoundPlugin. 		SoundGenerationPlugin.		ADPCMCodecPlugin.		KlattSynthesizerPlugin.		SoundCodecPlugin.	 	"Numerics"		LargeIntegersPlugin.		FFTPlugin. 		FloatArrayPlugin. 		Matrix2x3Plugin. 		"Compression"		DeflatePlugin.		"Others"		B3DEnginePlugin.		DSAPlugin.		DropPlugin. 		MiscPrimitivePlugin.		SecurityPlugin.		JPEGReaderPlugin.		"Note: Optionally, you can translate the following as builtins.		As of Squeak 2.7 they are not builtins by default:			FFIPlugin.		"	} do:[:plugin|		cg _ plugin translate: plugin moduleName, '.c'					doInlining: doInlining					locally: true.		exports _ exports copyWith: 			(plugin moduleName -> cg exportedPrimitiveNames asArray).	].	self storeExports: exports on: 'sqNamedPrims.h'.! !!InterpreterSimulator methodsFor: 'memory access' stamp: 'ar 3/3/2001 22:31'!integerAt: byteAddress	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory integerAt: (byteAddress // 4) + 1! !!InterpreterSimulator methodsFor: 'memory access' stamp: 'ar 3/3/2001 22:31'!integerAt: byteAddress put: a32BitValue	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory integerAt: (byteAddress // 4) + 1 put: a32BitValue! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'ar 3/4/2001 01:19'!mcuWidth: mw mcuHeight: mh dctSize: ds	mcuWidth _ mw.	mcuHeight _ mh.	dctSize _ ds.	hSampleFactor _ mcuWidth // widthInBlocks.	vSampleFactor _ mcuHeight // heightInBlocks! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'ar 3/4/2001 22:16'!nextSample	| dx dy blockIndex sampleIndex sample |	dx _ currentX // hSampleFactor.	dy _ currentY // vSampleFactor.	blockIndex _ dy // dctSize * widthInBlocks + (dx // dctSize) + 1.	sampleIndex _ dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.	sample _ (mcuBlocks at: blockIndex) at: sampleIndex.	currentX _ currentX + 1.	currentX < (mcuWidth * dctSize)		ifFalse:			[currentX _ 0.			currentY _ currentY + 1].	^ sample! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 20:42'!fillBuffer	| byte |	[bitsInBuffer <= 16]		whileTrue:[			byte _ self next.			(byte = 16rFF and: [(self peekFor: 16r00) not])					ifTrue:						[self position: self position - 1.						^0].			bitBuffer _ (bitBuffer bitShift: 8) bitOr: byte.			bitsInBuffer _ bitsInBuffer + 8].	^ bitsInBuffer! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 18:43'!getBits: requestedBits	| value |	requestedBits > bitsInBuffer ifTrue:[		self fillBuffer.		requestedBits > bitsInBuffer ifTrue:[			self error: 'not enough bits available to decode']].	value _ bitBuffer bitShift: (requestedBits - bitsInBuffer).	bitBuffer _ bitBuffer bitAnd: (1 bitShift: (bitsInBuffer - requestedBits)) -1.	bitsInBuffer _ bitsInBuffer - requestedBits.	^ value! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 17:40'!reset	super reset.	self resetBitBuffer! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 18:44'!resetBitBuffer	bitBuffer _ 0.	bitsInBuffer _ 0.! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 21:06'!buildLookupTable: values counts: counts	| min max |	min _ max _ nil.	1 to: counts size do:[:i|		(counts at: i) = 0 ifFalse:[			min ifNil:[min _ i-1].			max _ i]].	^self		createHuffmanTables: values 		counts: {0},counts 		from: min+1 		to: max.! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:46'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table _ WordArray new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart _ 2. "See above"	tableSize _ 1 bitShift: minBits.	tableEnd _ tableStart + tableSize.	"Store the terminal symbols"	valueIndex _ (counts at: minBits+1).	tableIndex _ 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex _ tableIndex + 1].	"Fill up remaining entries with invalid entries"	tableStack _ OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex _ valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues _ counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable _ tableStack last.			lastTableStart _ lastTable at: 2.			lastTableIndex _ lastTable at: 3.			deltaBits _ bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize _ 1 bitShift: deltaBits.			tableStart _ tableEnd.			tableEnd _ tableEnd + tableSize.			[tableEnd > table size ]				whileTrue:[table _ self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) = 0]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: lastTableIndex+1.			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries _ numValues min: tableSize.			tableIndex _ 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex _ valueIndex + 1.				numValues _ numValues - 1.				tableIndex _ tableIndex+1].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:44'!decodeValueFrom: table	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value |	bitsNeeded _ (table at: 1) bitShift: -24.	"Initial bits needed"	tableIndex _ 2.							"First real table"	[bits _ self getBits: bitsNeeded.			"Get bits"	value _ table at: (tableIndex + bits).		"Lookup entry in table"	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"		whileFalse:["Fetch sub table"			tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"			bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].	^value! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:21'!growHuffmanTable: table	| newTable |	newTable _ table species new: table size * 2.	newTable replaceFrom: 1 to: table size with: table startingAt: 1.	^newTable! !!JPEGReadStream class methodsFor: 'class initialization' stamp: 'ar 3/4/2001 18:32'!initialize	"JPEGReadStream initialize"	MaxBits _ 16.! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 3/4/2001 21:29'!nextImageDitheredToDepth: depth	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	residuals _ WordArray new: 3.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 3/4/2001 17:26'!setStream: aStream	"Feed it in from an existing source"	stream _ JPEGReadStream on: aStream upToEnd.! !!JPEGReadWriter methodsFor: 'testing' stamp: 'ar 3/4/2001 00:50'!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/4/2001 18:38'!initialSOSSetup	mcuWidth _ (components detectMax: [:c | c widthInBlocks]) widthInBlocks.	mcuHeight _ (components detectMax: [:c | c heightInBlocks]) heightInBlocks.	components do:[:c |		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].	stream resetBitBuffer.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/4/2001 18:36'!parseHuffmanTable	| length markerStart index bits count huffVal isACTable hTable |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[index _ self next.		isACTable _ (index bitAnd: 16r10) ~= 0.		index _ (index bitAnd: 16r0F) + 1.		index > HuffmanTableSize			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,				' quantization tables'].		bits _ self next: 16.		count _ bits sum.		(count > 256 or: [(count > (length - (self position - markerStart)))])			ifTrue: [self error: 'Huffman Table count is incorrect'].		huffVal _ self next: count.		hTable _ stream buildLookupTable: huffVal counts: bits.		isACTable			ifTrue:				[self hACTable at: index put: hTable]			ifFalse:				[self hDCTable at: index put: hTable]].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/3/2001 22:19'!parseQuantizationTable	| length markerStart n prec value table |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[value _ self next.		n _ (value bitAnd: 16r0F) + 1.		prec _ (value >> 4) > 0.		n > QuantizationTableSize			 ifTrue: [self error: 'image has more than ',				QuantizationTableSize printString,				' quantization tables'].		table _ IntegerArray new: DCTSize2.		1 to: DCTSize2 do:			[:i |			value _ (prec				ifTrue: [self nextWord]				ifFalse: [self next]).			table at: (JPEGNaturalOrder at: i) put: value].		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].		self qTable at: n put: table]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/3/2001 22:19'!perScanSetup	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership _ OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | IntegerArray new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer _ Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: 32.	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 20:55'!decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC	| byte i zeroCount |	byte _ stream decodeValueFrom: huffmanDC.	byte ~= 0 ifTrue: [byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].	byte _ aColorComponent updateDCValue: byte.	anArray atAllPut: 0.	anArray at: 1 put: byte.	i _ 2.	[i <= DCTSize2] whileTrue:		[byte _ stream decodeValueFrom: huffmanAC.		zeroCount _ byte >> 4.		byte _ byte bitAnd: 16r0F.		byte ~= 0			ifTrue:				[i _ i + zeroCount.				byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.				anArray at:	 (JPEGNaturalOrder at: i) put: byte]			ifFalse:				[zeroCount = 15 ifTrue: [i _ i + zeroCount] ifFalse: [^ self]].		i _ i + 1]		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 21:37'!decodeMCU	| comp |	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].	mcuMembership withIndexDo:		[:ci :i |		comp _ currentComponents at: ci.		self			primDecodeBlockInto: (mcuSampleBuffer at: i)			component: comp			dcTable: (hDCTable at: comp dcTableIndex)			acTable: (hACTable at: comp acTableIndex)			stream: stream.	].	restartsToGo _ restartsToGo - 1.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 17:27'!getBits: requestedBits	^stream getBits: requestedBits! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 21:32'!primDecodeBlockInto: sampleBuffer component: comp dcTable: dcTable acTable: acTable stream: jpegStream	<primitive: 'primitiveDecodeMCU' module: 'JPEGReaderPlugin'>	^self decodeBlockInto: sampleBuffer component: comp dcTable: dcTable acTable: acTable! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 17:40'!processRestart	stream resetBitBuffer.	self parseNextMarker.	currentComponents do: [:c | c priorDCValue: 0].	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 01:17'!scaleAndSignExtend: aNumber inFieldWidth: w	aNumber < (1 bitShift: (w - 1))		ifTrue: [^aNumber - (1 bitShift: w) + 1]		ifFalse: [^aNumber]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:35'!idctBlockInt: anArray component: aColorComponent	^self idctBlockInt: anArray qt: (self qTable at: aColorComponent qTableIndex)! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:34'!idctBlockInt: anArray qt: qt	|  ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 shift |	ws _ Array new: DCTSize2.	"Pass 1: process columns from anArray, store into work array"	shift _ 1 bitShift: ConstBits - Pass1Bits.	1 to: DCTSize do:		[:i |		anACTerm _ nil.		1 to: DCTSize-1 do:[:row|			anACTerm ifNil:[				(anArray at: row * DCTSize + i) = 0 ifFalse:[anACTerm _ row]]].		anACTerm == nil			ifTrue:				[dcval _ (anArray at: i) * (qt at: 1) bitShift: Pass1Bits.				0 to: DCTSize-1 do: [:j | ws at: (j * DCTSize + i) put: dcval]]			ifFalse:				[z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).				z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).				z1 _ (z2 + z3) * FIXn0n541196100.				t2 _ z1 + (z3 * FIXn1n847759065 negated).				t3 _ z1 + (z2 * FIXn0n765366865).				z2 _ (anArray at: i) * (qt at: i).				z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).				t0 _ (z2 + z3) bitShift: ConstBits.				t1 _ (z2 - z3) bitShift: ConstBits.				t10 _ t0 + t3.				t13 _ t0 - t3.				t11 _ t1 + t2.				t12 _ t1 - t2.				t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).				t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).				t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).				t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).				z1 _ t0 + t3.				z2 _ t1 + t2.				z3 _ t0 + t2.				z4 _ t1 + t3.				z5 _ (z3 + z4) * FIXn1n175875602.				t0 _ t0 * FIXn0n298631336.				t1 _ t1 * FIXn2n053119869.				t2 _ t2 * FIXn3n072711026.				t3 _ t3 * FIXn1n501321110.				z1 _ z1 * FIXn0n899976223 negated.				z2 _ z2 * FIXn2n562915447 negated.				z3 _ z3 * FIXn1n961570560 negated.				z4 _ z4 * FIXn0n390180644 negated.				z3 _ z3 + z5.				z4 _ z4 + z5.				t0 _ t0 + z1 + z3.				t1 _ t1 +z2 +z4.				t2 _ t2 + z2 + z3.				t3 _ t3 + z1 + z4.				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 7 + i) put: (t10 - t3) // shift.				ws at: (DCTSize * 1 + i) put: (t11 + t2) // shift.				ws at: (DCTSize * 6 + i) put: (t11 - t2) // shift.				ws at: (DCTSize * 2 + i) put: (t12 + t1) // shift.				ws at: (DCTSize * 5 + i) put: (t12 - t1) // shift.				ws at: (DCTSize * 3 + i) put: (t13 + t0) // shift.				ws at: (DCTSize * 4 + i) put: (t13 - t0) // shift]].	"Pass 2: process rows from work array, store back into anArray"	shift _ 1 bitShift: ConstBits + Pass1Bits + 3.	0 to: DCTSize2-DCTSize by: DCTSize do:		[:i |		z2 _ ws at: i + 3.		z3 _ ws at: i + 7.		z1 _ (z2 + z3) * FIXn0n541196100.		t2 _ z1 + (z3 * FIXn1n847759065 negated).		t3 _ z1 + (z2 * FIXn0n765366865).		t0 _ (ws at: (i + 1)) + (ws at: (i + 5)) bitShift: ConstBits.		t1 _ (ws at: (i + 1)) - (ws at: (i + 5)) bitShift: ConstBits.		t10 _ t0 + t3.		t13 _ t0 - t3.		t11 _ t1 + t2.		t12 _ t1 -t2.		t0 _ ws at: (i + 8).		t1 _ ws at: (i + 6).		t2 _ ws at: (i + 4).		t3 _ ws at: (i + 2).		z1 _ t0 + t3.		z2 _ t1 + t2.		z3 _ t0 + t2.		z4 _ t1 + t3.		z5 _ (z3 + z4) * FIXn1n175875602.		t0 _ t0 * FIXn0n298631336.		t1 _ t1 * FIXn2n053119869.		t2 _ t2 * FIXn3n072711026.		t3 _ t3 * FIXn1n501321110.		z1 _ z1 * FIXn0n899976223 negated.		z2 _ z2 * FIXn2n562915447 negated.		z3 _ z3 * FIXn1n961570560 negated.		z4 _ z4 * FIXn0n390180644 negated.		z3 _ z3 + z5.		z4 _ z4 + z5.		t0 _ t0 + z1 + z3.		t1 _ t1 + z2 + z4.		t2 _ t2 + z2 + z3.		t3 _ t3 + z1 + z4.		anArray at: (i + 1) put: (self sampleRangeLimit: (t10 + t3) // shift + SampleOffset).		anArray at: (i + 8) put: (self sampleRangeLimit: (t10 - t3) // shift + SampleOffset).		anArray at: (i + 2) put: (self sampleRangeLimit: (t11 + t2) // shift + SampleOffset).		anArray at: (i + 7) put: (self sampleRangeLimit: (t11 - t2) // shift + SampleOffset).		anArray at: (i + 3) put: (self sampleRangeLimit: (t12 + t1) // shift + SampleOffset).		anArray at: (i + 6) put: (self sampleRangeLimit: (t12 - t1) // shift + SampleOffset).		anArray at: (i + 4) put: (self sampleRangeLimit: (t13 + t0) // shift + SampleOffset).		anArray at: (i + 5) put: (self sampleRangeLimit: (t13 - t0) // shift + SampleOffset)].! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:37'!idctMCU	| comp |	self useFloatingPoint		ifTrue:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockFloat: (mcuSampleBuffer at: i) component: comp]]		ifFalse:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self primIdctBlockInt: (mcuSampleBuffer at: i) component: comp]]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:37'!primIdctBlockInt: anArray component: aColorComponent	^self primIdctInt: anArray qt: (self qTable at: aColorComponent qTableIndex)! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:35'!primIdctInt: anArray qt: qt	<primitive: 'primitiveIdctInt' module: 'JPEGReaderPlugin'>	^self idctBlockInt: anArray qt: qt! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:18'!colorConvertFloatYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - FloatSampleOffset.		cr _ crSampleStream nextSample - FloatSampleOffset.		red _ self sampleFloatRangeLimit: (y + (1.40200 * cr)).		green _ self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).		blue _ self sampleFloatRangeLimit: (y + (1.77200 * cb)).		bits at: i put: 16rFF000000 + (red << 16) + (green << 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:17'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream _ currentComponents at: 1.	ySampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ (ySampleStream nextSample) + (residuals at: 2).		y > MaxSample ifTrue: [y _ MaxSample].		residuals at: 2 put: (y bitAnd: ditherMask).		y _ y bitAnd: MaxSample - ditherMask.		y < 1 ifTrue: [y _ 1].		bits at: i put: 16rFF000000 + (y<<16) + (y<<8) + y].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:18'!colorConvertIntYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - SampleOffset.		cr _ crSampleStream nextSample - SampleOffset.		red _ y + ((FIXn1n40200 * cr) // 65536) + (residuals at: 1).		red > MaxSample			ifTrue: [red _ MaxSample]			ifFalse: [red < 0 ifTrue: [red _ 0]].		residuals at: 1 put: (red bitAnd: ditherMask).		red _ red bitAnd: MaxSample - ditherMask.		red < 1 ifTrue: [red _ 1].		green _ y - ((FIXn0n34414 * cb) // 65536) -			((FIXn0n71414 * cr) // 65536) + (residuals at: 2).		green > MaxSample			ifTrue: [green _ MaxSample]			ifFalse: [green < 0 ifTrue: [green _ 0]].		residuals at: 2 put: (green bitAnd: ditherMask).		green _ green bitAnd: MaxSample - ditherMask.		green < 1 ifTrue: [green _ 1].		blue _ y + ((FIXn1n77200 * cb) // 65536) + (residuals at: 3).		blue > MaxSample			ifTrue: [blue _ MaxSample]			ifFalse: [blue < 0 ifTrue: [blue _ 0]].		residuals at: 3 put: (blue bitAnd: ditherMask).		blue _ blue bitAnd: MaxSample - ditherMask.		blue < 1 ifTrue: [blue _ 1].		bits at: i put: 16rFF000000 + (red bitShift: 16) + (green bitShift: 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:26'!colorConvertMCU	^ currentComponents size = 3		ifTrue:			[self useFloatingPoint				ifTrue: [self colorConvertFloatYCbCrMCU]				ifFalse: [self primColorConvertIntYCbCrMCU]]		ifFalse: [self primColorConvertGrayscaleMCU]! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:19'!primColorConvertGrayscaleMCU	self primColorConvertGrayscaleMCU: (currentComponents at: 1)			bits: mcuImageBuffer bits			residuals: residuals			ditherMask: ditherMask.! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:26'!primColorConvertGrayscaleMCU: componentArray bits: bits residuals: residualArray ditherMask: mask	<primitive: 'primitiveColorConvertGrayscaleMCU' module: 'JPEGReaderPlugin'>	JPEGReaderPlugin doPrimitive: #primitiveColorConvertGrayscaleMCU.	^self colorConvertGrayscaleMCU! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 21:36'!primColorConvertIntYCbCrMCU	self primColorConvertYCbCrMCU: currentComponents			bits: mcuImageBuffer bits			residuals: residuals			ditherMask: ditherMask.! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 21:36'!primColorConvertYCbCrMCU: componentArray bits: bits residuals: residualArray ditherMask: mask	<primitive: 'primitiveColorConvertMCU' module: 'JPEGReaderPlugin'>	^self colorConvertIntYCbCrMCU! !!JPEGReadWriter methodsFor: 'private' stamp: 'ar 3/4/2001 17:34'!on: aStream	super on: aStream.	stream _ JPEGReadStream on: stream upToEnd.! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:30'!nextImageDitheredToDepth: depth	"Overwritten to yield every now and then."	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	residuals _ WordArray new: 3.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		"self isStreaming ifTrue:[Processor yield]."		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!JPEGReadWriter class methodsFor: 'initialization' stamp: 'ar 3/3/2001 23:07'!initialize	"JPEGReadWriter initialize"	"general constants"	DCTSize _ 8.	MaxSample _ (2 raisedToInteger: DCTSize) - 1.	SampleOffset _ MaxSample // 2.	FloatSampleOffset _ SampleOffset asFloat.	DCTSize2 _ DCTSize squared.	QuantizationTableSize _ 4.	HuffmanTableSize _ 4.	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"	ConstBits _ 13.	Pass1Bits _ 2.	DCTK1 _ 2 sqrt.	DCTK2 _ 1.847759065.	DCTK3 _ 1.082392200.	DCTK4 _ -2.613125930.	Pass1Div _ 1 bitShift: ConstBits - Pass1Bits.	Pass2Div _ 1 bitShift: ConstBits + Pass1Bits + 3.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 _ 2446.	FIXn0n390180644 _ 3196.	FIXn0n541196100 _ 4433.	FIXn0n765366865 _ 6270.	FIXn0n899976223 _ 7373.	FIXn1n175875602 _ 9633.	FIXn1n501321110 _ 12299.	FIXn1n847759065 _ 15137.	FIXn1n961570560 _ 16069.	FIXn2n053119869 _ 16819.	FIXn2n562915447 _ 20995.	FIXn3n072711026 _ 25172.	"fixed-point color conversion constants"	FIXn0n34414 _ 22554.	FIXn0n71414 _ 46802.	FIXn1n40200 _ 91881.	FIXn1n77200 _  116130.	"reordering table from JPEG zig-zag order"	JPEGNaturalOrder _ #(		1 2 9 17 10 3 4 11		18 25 33 26 19 12 5 6		13 20 27 34 41 49 42 35		28 21 14 7 8 15 22 29		36 43 50 57 58 51 44 37		30 23 16 24 31 38 45 52		59 60 53 46 39 32 40 47		54 61 62 55 48 56 63 64).	"scale factors for the values in the Quantization Tables"	QTableScaleFactor _ (0 to: DCTSize-1) collect:		[:k | k = 0			ifTrue: [1.0]			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].	"dithering masks"	(DitherMasks _ Dictionary new)		add: 0 -> 0;		add: 1 -> 127;		add: 2 -> 63;		add: 4 -> 63;		add: 8 -> 31;		add: 16 -> 7;		add: 32 -> 0.	"dictionary of marker parsers"	(JFIFMarkerParser _ Dictionary new)		add: (16r01 -> #parseNOP);		add: (16rC0 -> #parseStartOfFile);		add: (16rC4 -> #parseHuffmanTable);		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);		add: (16rD8 -> #parseStartOfInput);		add: (16rD9 -> #parseEndOfInput);		add: (16rDA -> #parseStartOfScan);		add: (16rDB -> #parseQuantizationTable);		add: (16rDD -> #parseDecoderRestartInterval);		add: (16rE0 -> #parseAPPn);		add: (16rE1 -> #parseAPPn)! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'ar 3/4/2001 22:21'!primitiveColorConvertGrayscaleMCU	"Requires:		JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	"	| arrayOop |	self export: true.	self stInit.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	ditherMask _ interpreterProxy stackIntegerValue: 0.	arrayOop _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop) and:[(interpreterProxy slotSizeOf: arrayOop) = 3])		ifFalse:[^interpreterProxy primitiveFail].	residuals _ interpreterProxy firstIndexableField: arrayOop.	arrayOop _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop)		ifFalse:[^interpreterProxy primitiveFail].	jpegBitsSize _ interpreterProxy slotSizeOf: arrayOop.	jpegBits _ interpreterProxy firstIndexableField: arrayOop.	arrayOop _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self yColorComponentFrom: arrayOop)		ifFalse:[^interpreterProxy primitiveFail].	self colorConvertGrayscaleMCU.	interpreterProxy pop: 4.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'ar 3/4/2001 21:13'!primitiveColorConvertMCU	"Requires:		Array with: 3*JPEGColorComponent		bits		WordArray with: 3*Integer (residuals)		ditherMask	"	| arrayOop |	self export: true.	self stInit.	interpreterProxy methodArgumentCount = 4		ifFalse:[^interpreterProxy primitiveFail].	ditherMask _ interpreterProxy stackIntegerValue: 0.	arrayOop _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop) and:[(interpreterProxy slotSizeOf: arrayOop) = 3])		ifFalse:[^interpreterProxy primitiveFail].	residuals _ interpreterProxy firstIndexableField: arrayOop.	arrayOop _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop)		ifFalse:[^interpreterProxy primitiveFail].	jpegBitsSize _ interpreterProxy slotSizeOf: arrayOop.	jpegBits _ interpreterProxy firstIndexableField: arrayOop.	arrayOop _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isPointers: arrayOop) and:[(interpreterProxy slotSizeOf: arrayOop) = 3])		ifFalse:[^interpreterProxy primitiveFail].	(self yColorComponentFrom: (interpreterProxy fetchPointer: 0 ofObject: arrayOop))		ifFalse:[^interpreterProxy primitiveFail].	(self cbColorComponentFrom: (interpreterProxy fetchPointer: 1 ofObject: arrayOop))		ifFalse:[^interpreterProxy primitiveFail].	(self crColorComponentFrom: (interpreterProxy fetchPointer: 2 ofObject: arrayOop))		ifFalse:[^interpreterProxy primitiveFail].	self colorConvertMCU.	interpreterProxy pop: 4.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'ar 3/4/2001 21:21'!primitiveDecodeMCU	"In:		anArray 		WordArray of: DCTSize2		aColorComponent JPEGColorComponent		dcTable			WordArray		acTable			WordArray		stream			JPEGStream	"	| arrayOop oop anArray |	self export: true.	self var: #anArray type: 'int *'.	self cCode:'' inSmalltalk:[self stInit].	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	oop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self loadJPEGStreamFrom: oop)		ifFalse:[^interpreterProxy primitiveFail].	arrayOop _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop)		ifFalse:[^interpreterProxy primitiveFail].	acTableSize _ interpreterProxy slotSizeOf: arrayOop.	acTable _ interpreterProxy firstIndexableField: arrayOop.	arrayOop _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop)		ifFalse:[^interpreterProxy primitiveFail].	dcTableSize _ interpreterProxy slotSizeOf: arrayOop.	dcTable _ interpreterProxy firstIndexableField: arrayOop.	oop _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self colorComponent: yComponent from: oop)		ifFalse:[^interpreterProxy primitiveFail].	arrayOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: arrayOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: arrayOop) = DCTSize2		ifFalse:[^interpreterProxy primitiveFail].	anArray _ interpreterProxy firstIndexableField: arrayOop.	interpreterProxy failed ifTrue:[^nil].	self decodeBlockInto: anArray component: yComponent.	interpreterProxy failed ifTrue:[^nil].	self storeJPEGStreamOn: (interpreterProxy stackValue: 0).	interpreterProxy 		storeInteger: PriorDCValueIndex 		ofObject: (interpreterProxy stackValue: 3) 		withValue: (yComponent at: PriorDCValueIndex).	interpreterProxy pop: 5.! !!JPEGReaderPlugin methodsFor: 'primitives' stamp: 'ar 3/4/2001 21:14'!primitiveIdctInt	"In:		anArray: IntegerArray new: DCTSize2		qt: IntegerArray new: DCTSize2.	"	| arrayOop anArray qt |	self export: true.	self var: #anArray type: 'int *'.	self var: #qt type: 'int *'.	self cCode:'' inSmalltalk:[self stInit].	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	arrayOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop) and:[(interpreterProxy slotSizeOf: arrayOop) = DCTSize2])		ifFalse:[^interpreterProxy primitiveFail].	qt _ interpreterProxy firstIndexableField: arrayOop.	arrayOop _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	((interpreterProxy isWords: arrayOop) and:[(interpreterProxy slotSizeOf: arrayOop) = DCTSize2])		ifFalse:[^interpreterProxy primitiveFail].	anArray _ interpreterProxy firstIndexableField: arrayOop.	self idctBlockInt: anArray qt: qt.	interpreterProxy pop: 2.! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:11'!cbColorComponentFrom: oop	^(self colorComponent: cbComponent from: oop)		and:[self colorComponentBlocks: cbBlocks from: oop]! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 20:08'!colorComponent: aColorComponent from: oop	self var: #aColorComponent type: 'int *'.	(interpreterProxy isIntegerObject: oop) ifTrue:[^false].	(interpreterProxy isPointers: oop) ifFalse:[^false].	(interpreterProxy slotSizeOf: oop) < MinComponentSize ifTrue:[^false].	aColorComponent at: CurrentXIndex put: 		(interpreterProxy fetchInteger: CurrentXIndex ofObject: oop).	aColorComponent at: CurrentYIndex put: 		(interpreterProxy fetchInteger: CurrentYIndex ofObject: oop).	aColorComponent at: HScaleIndex put: 		(interpreterProxy fetchInteger: HScaleIndex ofObject: oop).	aColorComponent at: VScaleIndex put: 		(interpreterProxy fetchInteger: VScaleIndex ofObject: oop).	aColorComponent at: BlockWidthIndex put: 		(interpreterProxy fetchInteger: BlockWidthIndex ofObject: oop).	aColorComponent at: MCUWidthIndex put: 		(interpreterProxy fetchInteger: MCUWidthIndex ofObject: oop).	aColorComponent at: PriorDCValueIndex put: 		(interpreterProxy fetchInteger: PriorDCValueIndex ofObject: oop).	^interpreterProxy failed not! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 20:08'!colorComponentBlocks: blocks from: oop	| arrayOop max blockOop |	self var: #blocks type: 'int **'.	(interpreterProxy isIntegerObject: oop) ifTrue:[^false].	(interpreterProxy isPointers: oop) ifFalse:[^false].	(interpreterProxy slotSizeOf: oop) < MinComponentSize ifTrue:[^false].	arrayOop _ interpreterProxy fetchPointer: MCUBlockIndex ofObject: oop.	(interpreterProxy isIntegerObject: arrayOop) ifTrue:[^false].	(interpreterProxy isPointers: arrayOop) ifFalse:[^false].	max _ interpreterProxy slotSizeOf: arrayOop.	max > MaxMCUBlocks ifTrue:[^false].	0 to: max-1 do:[:i|		blockOop _ interpreterProxy fetchPointer: i ofObject: arrayOop.		(interpreterProxy isIntegerObject: blockOop) ifTrue:[^false].		(interpreterProxy isWords: blockOop) ifFalse:[^false].		(interpreterProxy slotSizeOf: blockOop) = DCTSize2 ifFalse:[^false].		blocks at: i put: (interpreterProxy firstIndexableField: blockOop).	].	^interpreterProxy failed not! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 22:24'!colorConvertGrayscaleMCU	| y |	yComponent at: CurrentXIndex put: 0.	yComponent at: CurrentYIndex put: 0.	0 to: jpegBitsSize-1 do:[:i|		y _ self nextSampleY.		y _ y + (residuals at: GreenIndex).		y _ y min: MaxSample.		residuals at: GreenIndex put: (y bitAnd: ditherMask).		y _ y bitAnd: MaxSample - ditherMask.		y _ y max: 1.		jpegBits at: i put: 16rFF000000 + (y<<16) + (y<<8) + y.	].! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:11'!colorConvertMCU	| y cb cr red green blue |	yComponent at: CurrentXIndex put: 0.	yComponent at: CurrentYIndex put: 0.	cbComponent at: CurrentXIndex put: 0.	cbComponent at: CurrentYIndex put: 0.	crComponent at: CurrentXIndex put: 0.	crComponent at: CurrentYIndex put: 0.	0 to: jpegBitsSize-1 do:[:i|		y _ self nextSampleY.		cb _ self nextSampleCb.		cb _ cb - SampleOffset.		cr _ self nextSampleCr.		cr _ cr - SampleOffset.		red _ y + ((FIXn1n40200 * cr) // 65536) + (residuals at: RedIndex).		red _ red min: MaxSample. red _ red max: 0.		residuals at: RedIndex put: (red bitAnd: ditherMask).		red _ red bitAnd: MaxSample - ditherMask.		red _ red max: 1.		green _ y - ((FIXn0n34414 * cb) // 65536) -			((FIXn0n71414 * cr) // 65536) + (residuals at: GreenIndex).		green _ green min: MaxSample. green _ green max: 0.		residuals at: GreenIndex put: (green bitAnd: ditherMask).		green _ green bitAnd: MaxSample - ditherMask.		green _ green max: 1.		blue _ y + ((FIXn1n77200 * cb) // 65536) + (residuals at: BlueIndex).		blue _ blue min: MaxSample. blue _ blue max: 0.		residuals at: BlueIndex put: (blue bitAnd: ditherMask).		blue _ blue bitAnd: MaxSample - ditherMask.		blue _ blue max: 1.		jpegBits at: i put: 16rFF000000 + (red bitShift: 16) + (green bitShift: 8) + blue.	].! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:11'!crColorComponentFrom: oop	^(self colorComponent: crComponent from: oop)		and:[self colorComponentBlocks: crBlocks from: oop]! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:17'!decodeBlockInto: anArray component: aColorComponent	| byte zeroCount bits index |	self var: #anArray type: 'int *'.	self var: #aColorComponent type: 'int *'.	byte _ self jpegDecodeValueFrom: dcTable size: dcTableSize.	byte < 0 ifTrue:[^interpreterProxy primitiveFail].	byte ~= 0 ifTrue: [		bits _ self getBits: byte.		byte _ self scaleAndSignExtend: bits inFieldWidth: byte].	byte _ aColorComponent 				at: PriorDCValueIndex 				put: (aColorComponent at: PriorDCValueIndex) + byte.	anArray at: 0 put: byte.	1 to: DCTSize2 - 1 do:[:i| anArray at: i put: 0].	index _ 1.	[index < DCTSize2] whileTrue:[		byte _ self jpegDecodeValueFrom: acTable size: acTableSize.		byte < 0 ifTrue:[^interpreterProxy primitiveFail].		zeroCount _ byte >> 4.		byte _ byte bitAnd: 16r0F.		byte ~= 0 ifTrue:[			index _ index + zeroCount.			bits _  self getBits: byte.			byte _ self scaleAndSignExtend: bits inFieldWidth: byte.			(index < 0 or:[index >= DCTSize2]) ifTrue:[^interpreterProxy primitiveFail].			anArray at:	 (jpegNaturalOrder at: index) put: byte.		] ifFalse:[			zeroCount = 15 ifTrue: [index _ index + zeroCount] ifFalse: [^ nil].		].		index _ index + 1	].! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:16'!idctBlockInt: anArray qt: qt	| ws anACTerm dcval z2 z3 z1 t2 t3 t0 t1 t10 t13 t11 t12 z4 z5 v |	self var: #anArray type:'int *'.	self var: #qt type:'int *'.	self var: #ws declareC:'int ws[64]'.	self cCode:'' inSmalltalk:[ws _ CArrayAccessor on: (IntegerArray new: 64)].	"Pass 1: process columns from anArray, store into work array"	0 to: DCTSize-1 do:[:i |		anACTerm _ -1.		1 to: DCTSize-1 do:[:row|			anACTerm = -1 ifTrue:[				(anArray at: row * DCTSize + i) = 0 ifFalse:[anACTerm _ row]]].		anACTerm = -1 ifTrue:[			dcval _ (anArray at: i) * (qt at: 0) bitShift: Pass1Bits.			0 to: DCTSize-1 do: [:j | ws at: (j * DCTSize + i) put: dcval]		] ifFalse:[			z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).			z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).			z1 _ (z2 + z3) * FIXn0n541196100.			t2 _ z1 + (z3 * (0 - FIXn1n847759065)).			t3 _ z1 + (z2 * FIXn0n765366865).			z2 _ (anArray at: i) * (qt at: i).			z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).			t0 _ (z2 + z3) bitShift: ConstBits.			t1 _ (z2 - z3) bitShift: ConstBits.			t10 _ t0 + t3.			t13 _ t0 - t3.			t11 _ t1 + t2.			t12 _ t1 - t2.			t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).			t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).			t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).			t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).			z1 _ t0 + t3.			z2 _ t1 + t2.			z3 _ t0 + t2.			z4 _ t1 + t3.			z5 _ (z3 + z4) * FIXn1n175875602.			t0 _ t0 * FIXn0n298631336.			t1 _ t1 * FIXn2n053119869.			t2 _ t2 * FIXn3n072711026.			t3 _ t3 * FIXn1n501321110.			z1 _ z1 * (0 - FIXn0n899976223).			z2 _ z2 * (0 - FIXn2n562915447).			z3 _ z3 * (0 - FIXn1n961570560).			z4 _ z4 * (0 - FIXn0n390180644).			z3 _ z3 + z5.			z4 _ z4 + z5.			t0 _ t0 + z1 + z3.			t1 _ t1 +z2 +z4.			t2 _ t2 + z2 + z3.			t3 _ t3 + z1 + z4.			ws at: i put: (t10 + t3) // Pass1Div.			ws at: (DCTSize * 7 + i) put: (t10 - t3) // Pass1Div.			ws at: (DCTSize * 1 + i) put: (t11 + t2) // Pass1Div.			ws at: (DCTSize * 6 + i) put: (t11 - t2) // Pass1Div.			ws at: (DCTSize * 2 + i) put: (t12 + t1) // Pass1Div.			ws at: (DCTSize * 5 + i) put: (t12 - t1) // Pass1Div.			ws at: (DCTSize * 3 + i) put: (t13 + t0) // Pass1Div.			ws at: (DCTSize * 4 + i) put: (t13 - t0) // Pass1Div]].	"Pass 2: process rows from work array, store back into anArray"	0 to: DCTSize2-DCTSize by: DCTSize do:[:i |		z2 _ ws at: i + 2.		z3 _ ws at: i + 6.		z1 _ (z2 + z3) * FIXn0n541196100.		t2 _ z1 + (z3 * (0-FIXn1n847759065)).		t3 _ z1 + (z2 * FIXn0n765366865).		t0 _ (ws at: i) + (ws at: (i + 4)) bitShift: ConstBits.		t1 _ (ws at: i) - (ws at: (i + 4)) bitShift: ConstBits.		t10 _ t0 + t3.		t13 _ t0 - t3.		t11 _ t1 + t2.		t12 _ t1 -t2.		t0 _ ws at: (i + 7).		t1 _ ws at: (i + 5).		t2 _ ws at: (i + 3).		t3 _ ws at: (i + 1).		z1 _ t0 + t3.		z2 _ t1 + t2.		z3 _ t0 + t2.		z4 _ t1 + t3.		z5 _ (z3 + z4) * FIXn1n175875602.		t0 _ t0 * FIXn0n298631336.		t1 _ t1 * FIXn2n053119869.		t2 _ t2 * FIXn3n072711026.		t3 _ t3 * FIXn1n501321110.		z1 _ z1 * (0-FIXn0n899976223).		z2 _ z2 * (0-FIXn2n562915447).		z3 _ z3 * (0-FIXn1n961570560).		z4 _ z4 * (0-FIXn0n390180644).		z3 _ z3 + z5.		z4 _ z4 + z5.		t0 _ t0 + z1 + z3.		t1 _ t1 + z2 + z4.		t2 _ t2 + z2 + z3.		t3 _ t3 + z1 + z4.		v _ (t10 + t3) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: i put: v.		v _ (t10 - t3) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 7) put: v.		v _ (t11 + t2) // Pass2Div + SampleOffset. 		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 1) put: v.		v _ (t11 - t2) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 6) put: v.		v _  (t12 + t1) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 2) put: v.		v _  (t12 - t1) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 5) put: v.		v _ (t13 + t0) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 3) put: v.		v _ (t13 - t0) // Pass2Div + SampleOffset.		v _ v min: MaxSample. v _ v max: 0.		anArray at: (i + 4) put: v].! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:11'!nextSampleCb	| dx dy blockIndex sampleIndex sample curX sx sy |	self inline: true.	dx _ curX _ cbComponent at: CurrentXIndex.	dy _ cbComponent at: CurrentYIndex.	sx _ cbComponent at: HScaleIndex.	sy _ cbComponent at: VScaleIndex.	(sx = 0 and:[sy = 0]) ifFalse:[		dx _ dx // sx.		dy _ dy // sy.	].	blockIndex _ (dy bitShift: -3) * (cbComponent at: BlockWidthIndex) + (dx bitShift: -3).	sampleIndex _ ((dy bitAnd: 7) bitShift: 3) + (dx bitAnd: 7).	sample _ (cbBlocks at: blockIndex) at: sampleIndex.	curX _ curX + 1.	curX < ((cbComponent at: MCUWidthIndex) * 8) ifTrue:[		cbComponent at: CurrentXIndex put: curX.	] ifFalse:[		cbComponent at: CurrentXIndex put: 0.		cbComponent at: CurrentYIndex put: (cbComponent at: CurrentYIndex) + 1.	].	^ sample! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:11'!nextSampleCr	| dx dy blockIndex sampleIndex sample curX sx sy |	self inline: true.	dx _ curX _ crComponent at: CurrentXIndex.	dy _ crComponent at: CurrentYIndex.	sx _ crComponent at: HScaleIndex.	sy _ crComponent at: VScaleIndex.	(sx = 0 and:[sy = 0]) ifFalse:[		dx _ dx // sx.		dy _ dy // sy.	].	blockIndex _ (dy bitShift: -3) * (crComponent at: BlockWidthIndex) + (dx bitShift: -3).	sampleIndex _ ((dy bitAnd: 7) bitShift: 3) + (dx bitAnd: 7).	sample _ (crBlocks at: blockIndex) at: sampleIndex.	curX _ curX + 1.	curX < ((crComponent at: MCUWidthIndex) * 8) ifTrue:[		crComponent at: CurrentXIndex put: curX.	] ifFalse:[		crComponent at: CurrentXIndex put: 0.		crComponent at: CurrentYIndex put: (crComponent at: CurrentYIndex) + 1.	].	^ sample! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:16'!nextSampleFrom: aComponent blocks: aBlockArray	| dx dy blockIndex sampleIndex sample curX sx sy |	self var: #aComponent type: 'int *'.	self var: #aBlockArray type: 'int **'.	self inline: true.	dx _ curX _ aComponent at: CurrentXIndex.	dy _ aComponent at: CurrentYIndex.	sx _ aComponent at: HScaleIndex.	sy _ aComponent at: VScaleIndex.	(sx = 0 and:[sy = 0]) ifFalse:[		dx _ dx // sx.		dy _ dy // sy.	].	blockIndex _ (dy bitShift: -3) * (aComponent at: BlockWidthIndex) + (dx bitShift: -3).	sampleIndex _ ((dy bitAnd: 7) bitShift: 3) + (dx bitAnd: 7).	sample _ (aBlockArray at: blockIndex) at: sampleIndex.	curX _ curX + 1.	curX < ((aComponent at: MCUWidthIndex) * 8) ifTrue:[		aComponent at: CurrentXIndex put: curX.	] ifFalse:[		aComponent at: CurrentXIndex put: 0.		aComponent at: CurrentYIndex put: (aComponent at: CurrentYIndex) + 1.	].	^ sample! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:10'!nextSampleY	| dx dy blockIndex sampleIndex sample curX sx sy |	self inline: true.	dx _ curX _ yComponent at: CurrentXIndex.	dy _ yComponent at: CurrentYIndex.	sx _ yComponent at: HScaleIndex.	sy _ yComponent at: VScaleIndex.	(sx = 0 and:[sy = 0]) ifFalse:[		dx _ dx // sx.		dy _ dy // sy.	].	blockIndex _ (dy bitShift: -3) * (yComponent at: BlockWidthIndex) + (dx bitShift: -3).	sampleIndex _ ((dy bitAnd: 7) bitShift: 3) + (dx bitAnd: 7).	sample _ (yBlocks at: blockIndex) at: sampleIndex.	curX _ curX + 1.	curX < ((yComponent at: MCUWidthIndex) * 8) ifTrue:[		yComponent at: CurrentXIndex put: curX.	] ifFalse:[		yComponent at: CurrentXIndex put: 0.		yComponent at: CurrentYIndex put: (yComponent at: CurrentYIndex) + 1.	].	^ sample! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 17:16'!scaleAndSignExtend: aNumber inFieldWidth: w	self inline: true.	aNumber < (1 bitShift: (w - 1))		ifTrue: [^aNumber - (1 bitShift: w) + 1]		ifFalse: [^aNumber]! !!JPEGReaderPlugin methodsFor: 'decoding' stamp: 'ar 3/4/2001 21:10'!yColorComponentFrom: oop	^(self colorComponent: yComponent from: oop)		and:[self colorComponentBlocks: yBlocks from: oop]! !!JPEGReaderPlugin methodsFor: 'initialize' stamp: 'ar 3/4/2001 21:10'!stInit	self cCode:'' inSmalltalk:[		yComponent _ CArrayAccessor on: (IntegerArray new: MinComponentSize).		cbComponent _ CArrayAccessor on: (IntegerArray new: MinComponentSize).		crComponent _ CArrayAccessor on: (IntegerArray new: MinComponentSize).		yBlocks _ CArrayAccessor on: (Array new: MaxMCUBlocks).		crBlocks _ CArrayAccessor on: (Array new: MaxMCUBlocks).		cbBlocks _ CArrayAccessor on: (Array new: MaxMCUBlocks).		jpegNaturalOrder _ CArrayAccessor on: #(			0 1 8 16 9 2 3 10 			17 24 32 25 18 11 4 5 			12 19 26 33 40 48 41 34 			27 20 13 6 7 14 21 28 			35 42 49 56 57 50 43 36 			29 22 15 23 30 37 44 51 			58 59 52 45 38 31 39 46 			53 60 61 54 47 55 62 63).	].! !!JPEGReaderPlugin methodsFor: 'stream support' stamp: 'ar 3/4/2001 20:44'!fillBuffer	| byte |	[jsBitCount <= 16] whileTrue:[		jsPosition < jsReadLimit ifFalse:[^jsBitCount].		byte _ jsCollection at: jsPosition.		jsPosition _ jsPosition + 1.		byte = 16rFF ifTrue:["peek for 00"			((jsPosition < jsReadLimit) and:[(jsCollection at: jsPosition) = 16r00]) ifFalse:[				jsPosition _ jsPosition - 1.				^jsBitCount].			jsPosition _ jsPosition + 1].		jsBitBuffer _ (jsBitBuffer bitShift: 8) bitOr: byte.		jsBitCount _ jsBitCount + 8].	^jsBitCount! !!JPEGReaderPlugin methodsFor: 'stream support' stamp: 'ar 3/4/2001 21:22'!getBits: requestedBits	| value |	requestedBits > jsBitCount ifTrue:[		self fillBuffer.		requestedBits > jsBitCount ifTrue:[^-1]].	value _ jsBitBuffer bitShift: (requestedBits - jsBitCount).	jsBitBuffer _ jsBitBuffer bitAnd: (1 bitShift: (jsBitCount - requestedBits)) -1.	jsBitCount _ jsBitCount - requestedBits.	^ value! !!JPEGReaderPlugin methodsFor: 'stream support' stamp: 'ar 3/4/2001 21:22'!jpegDecodeValueFrom: table size: tableSize	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value index |	self var: #table declareC:'unsigned int *table'.	bitsNeeded _ (table at: 0) bitShift: -24.	"Initial bits needed"	bitsNeeded > MaxBits ifTrue:[^-1].	tableIndex _ 2.							"First real table"	[true] whileTrue:[		bits _ self getBits: bitsNeeded.		"Get bits"		bits < 0 ifTrue:[^-1].		index _ tableIndex + bits - 1.		index >= tableSize ifTrue:[^-1].		value _ table at: index.					"Lookup entry in table"		(value bitAnd: 16r3F000000) = 0 ifTrue:[^value]. "Check if it is a leaf node"		"Fetch sub table"		tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"		bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"		bitsNeeded > MaxBits ifTrue:[^-1]].	^-1! !!JPEGReaderPlugin methodsFor: 'stream support' stamp: 'ar 3/4/2001 19:12'!loadJPEGStreamFrom: streamOop	| oop sz |	(interpreterProxy slotSizeOf: streamOop) < 5 ifTrue:[^false].	(interpreterProxy isPointers: streamOop) ifFalse:[^false].	oop _ interpreterProxy fetchPointer: 0 ofObject: streamOop.	(interpreterProxy isIntegerObject: oop) ifTrue:[^false].	(interpreterProxy isBytes: oop) ifFalse:[^false].	jsCollection _ interpreterProxy firstIndexableField: oop.	sz _ interpreterProxy byteSizeOf: oop.	jsPosition _ interpreterProxy fetchInteger: 1 ofObject: streamOop.	jsReadLimit _ interpreterProxy fetchInteger: 2 ofObject: streamOop.	jsBitBuffer _ interpreterProxy fetchInteger: 3 ofObject: streamOop.	jsBitCount _ interpreterProxy fetchInteger: 4 ofObject: streamOop.	interpreterProxy failed ifTrue:[^false].	sz < jsReadLimit ifTrue:[^false].	(jsPosition < 0 or:[jsPosition >= jsReadLimit]) ifTrue:[^false].	^true! !!JPEGReaderPlugin methodsFor: 'stream support' stamp: 'ar 3/4/2001 19:04'!storeJPEGStreamOn: streamOop	interpreterProxy storeInteger: 1 ofObject: streamOop withValue: jsPosition.	interpreterProxy storeInteger: 3 ofObject: streamOop withValue: jsBitBuffer.	interpreterProxy storeInteger: 4 ofObject: streamOop withValue: jsBitCount.! !!JPEGReaderPlugin class methodsFor: 'class initialization' stamp: 'ar 3/4/2001 19:13'!initialize	"JPEGReaderPlugin initialize"	DCTSize _ 8.	MaxSample _ (2 raisedToInteger: DCTSize) - 1.	SampleOffset _ MaxSample // 2.	DCTSize2 _ DCTSize squared.	ConstBits _ 13.	Pass1Bits _ 2.	Pass1Div _ 1 bitShift: ConstBits - Pass1Bits.	Pass2Div _ 1 bitShift: ConstBits + Pass1Bits + 3.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 _ 2446.	FIXn0n390180644 _ 3196.	FIXn0n541196100 _ 4433.	FIXn0n765366865 _ 6270.	FIXn0n899976223 _ 7373.	FIXn1n175875602 _ 9633.	FIXn1n501321110 _ 12299.	FIXn1n847759065 _ 15137.	FIXn1n961570560 _ 16069.	FIXn2n053119869 _ 16819.	FIXn2n562915447 _ 20995.	FIXn3n072711026 _ 25172.	"fixed-point color conversion constants"	FIXn0n34414 _ 22554.	FIXn0n71414 _ 46802.	FIXn1n40200 _ 91881.	FIXn1n77200 _  116130.	CurrentXIndex _ 0.	CurrentYIndex _ 1.	HScaleIndex _ 2.	VScaleIndex _ 3.	MCUBlockIndex _ 4.	BlockWidthIndex _ 5.	MCUWidthIndex _ 8.	PriorDCValueIndex _ 10.	MinComponentSize _ 11.	RedIndex _ 0.	GreenIndex _ 1.	BlueIndex _ 2.	MaxMCUBlocks _ 128.	MaxBits _ 16.! !!JPEGReaderPlugin class methodsFor: 'translation' stamp: 'ar 3/4/2001 21:13'!declareCVarsIn: cg	cg var: 'yComponent'		declareC: 'int yComponent[' , MinComponentSize printString , ']'.	cg var: 'crComponent'		declareC: 'int crComponent[' , MinComponentSize printString , ']'.	cg var: 'cbComponent'		declareC: 'int cbComponent[' , MinComponentSize printString , ']'.	cg var: 'yBlocks'		declareC: 'int *yBlocks[' , MaxMCUBlocks printString , ']'.	cg var: 'crBlocks'		declareC: 'int *crBlocks[' , MaxMCUBlocks printString  , ']'.	cg var: 'cbBlocks'		declareC: 'int *cbBlocks[' , MaxMCUBlocks printString  , ']'.	cg var: 'residuals'		declareC: 'int *residuals'.	cg var: 'jpegBits'		declareC: 'int *jpegBits'.	cg var: 'jpegNaturalOrder'		declareC: 'int jpegNaturalOrder[64] = {	0, 1, 8, 16, 9, 2, 3, 10, 	17, 24, 32, 25, 18, 11, 4, 5, 	12, 19, 26, 33, 40, 48, 41, 34, 	27, 20, 13, 6, 7, 14, 21, 28, 	35, 42, 49, 56, 57, 50, 43, 36, 	29, 22, 15, 23, 30, 37, 44, 51, 	58, 59, 52, 45, 38, 31, 39, 46, 	53, 60, 61, 54, 47, 55, 62, 63}'.	cg var: 'jsCollection' 		declareC:'unsigned char *jsCollection'.	cg var: 'acTable' 		declareC:'int *acTable'.	cg var: 'dcTable' 		declareC:'int *dcTable'.! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:43'!integerAt: index	"Return the integer at the given index"	^self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:43'!integerAt: index put: value	"Return the integer at the given index"	^self at: index put: value! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:41'!integerAt: index	"Return the integer at the given index"	| word |	<primitive: 165>	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:42'!integerAt: index put: anInteger	"Store the integer at the given index"	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index	| word |	<primitive: 165>	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index put: anInteger	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 23:34'!atAllPut: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self primFill: word.! !!IntegerArray methodsFor: 'private' stamp: 'ar 3/3/2001 23:34'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!SketchMorph class methodsFor: 'instance creation' stamp: 'ar 3/4/2001 20:59'!fromFile: aFileName	^self fromStream: (FileStream readOnlyFileNamed: aFileName)! !!SketchMorph class methodsFor: 'instance creation' stamp: 'ar 3/4/2001 21:00'!fromStream: aStream	^self withForm: (ImageReadWriter formFromStream: aStream)! !JPEGReaderPlugin initialize!JPEGReadWriter initialize!JPEGReadWriter removeSelector: #decodeByteWithTable:!JPEGReadWriter removeSelector: #fillBuffer!JPEGReadWriter removeSelector: #peekBits:!ImageReadWriter subclass: #JPEGReadWriter	instanceVariableNames: 'width height components currentComponents qTable hACTable hDCTable restartInterval restartsToGo mcuWidth mcuHeight mcusPerRow mcuRowsInScan mcuMembership mcuSampleBuffer mcuImageBuffer majorVersion minorVersion dataPrecision densityUnit xDensity yDensity ss se ah al sosSeen residuals ditherMask '	classVariableNames: 'ConstBits DCTK1 DCTK2 DCTK3 DCTK4 DCTSize DCTSize2 DitherMasks FIXn0n298631336 FIXn0n34414 FIXn0n390180644 FIXn0n541196100 FIXn0n71414 FIXn0n765366865 FIXn0n899976223 FIXn1n175875602 FIXn1n40200 FIXn1n501321110 FIXn1n77200 FIXn1n847759065 FIXn1n961570560 FIXn2n053119869 FIXn2n562915447 FIXn3n072711026 FloatSampleOffset HuffmanTableSize JFIFMarkerParser JPEGNaturalOrder MaxSample Pass1Bits Pass1Div Pass2Div QTableScaleFactor QuantizationTableSize SampleOffset '	poolDictionaries: ''	category: 'Graphics-Files'!JPEGReadStream initialize!Object subclass: #JPEGColorComponent	instanceVariableNames: 'currentX currentY hSampleFactor vSampleFactor mcuBlocks widthInBlocks heightInBlocks dctSize mcuWidth mcuHeight priorDCValue id qTableIndex dcTableIndex acTableIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Files'!