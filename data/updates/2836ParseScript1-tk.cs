'From Squeak2.9alpha of 16 June 2000 [latest update: #2882] on 23 October 2000 at 1:43:16 pm'!"Change Set:		SyntaxMorphDate:			23 Oct 2000Author:			Ted Kaehler, Bob ArningTiles for any method in the system.  In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.  Dragging a statement removes it from a block.  Dragging anything else drags off a copy. Yellow menu in white space beside method header lets you see the code generated, or accept the method.Based on Bob Arning's version 3 of SyntaxMorph."!TextMorph subclass: #NonEditableTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Syntax'!ParseNode subclass: #BlockArgsNode	instanceVariableNames: 'temporaries '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!ParseNode subclass: #CommentNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!MessageNode subclass: #BobsMessageNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Syntax'!ParseNode subclass: #MethodTempsNode	instanceVariableNames: 'temporaries '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!MenuMorph subclass: #SyntaxMenuMorph	instanceVariableNames: 'whenDone '	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Syntax'!AlignmentMorph subclass: #SyntaxMorph	instanceVariableNames: 'parseNode explanation parsedInClass getMenuBlock minBorderWidth markerMorph debugger '	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Syntax'!!SyntaxMorph commentStamp: 'tk 10/23/2000 13:34' prior: 0!A single class of morph that holds any piece of Smalltalk, and allows it to be a tile.  Tiles can be dragged in or out of a method. In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.Dragging a statement removes it from a block.  Dragging anything else drags off a copy.  (Can't drag out the original -- it leaves an illegal hole.)Each SyntaxMorph points at a ParseNode.  After editing, the parseNode is only good as a part-of-speech indicator.  Only the classes of the parseNodes are important.  It's state is not kept up to date with the tile edits (but maybe it should be).The correspondence with parseNodes in not one-to-one.  Several extra levels of SyntaxMorph were added as aligners to make the horizontal and vertical layout right.  These have nil for the parseNode.To accept, pass over the tree of SyntaxMorphs, gathering their printStrings and inserting punctuation.  See (SyntaxMorph>>printOn:indent:).  Accept that.  Pretty print to make it look better.Things to do:[ ] Add in a SelectorNode to first line to store the method header and arguments.[ ] Up/down arrows and extend arrow on tiles.  [ ] Why extra SyntaxMorph layer just above leafNodes?  Get rid of them.[ ] Invent fake parseNodes for the alignment morphs needed for multiple keywords, cascading, etc.[ ] In large statements, make tile be narrow on left, expanding out to tall on the right.[ ] Keep the parseNodes legal and up to date as editing occurs.  Go from parse tree directly to byteCodes.[ ] When user retypes a selector with more colons, split it and put in arg2.  Allow dropping in extra keywords and extra args.[ ] Dan's pretty green slider code when dropping in new line.  Also indicate places in existing tiles where the new tile could drop.[ ] if drop in an illegal place, keep in hand[ ] Undo!!Based on Bob Arning's SyntaxMorph exploration in early 2000.!TextStream subclass: #SyntaxMorphStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Bob-Syntax'!!BlockContext methodsFor: 'tiles' stamp: 'RAA 8/16/1999 13:52'!valueWithPossibleArgs: anArray 	self numArgs = 0 ifTrue: [^self value].	self numArgs = anArray size ifTrue: [^self valueWithArguments: anArray].	self numArgs > anArray size ifTrue: [		^self valueWithArguments: anArray,				(Array new: (self numArgs - anArray size))	].	^self valueWithArguments: (anArray copyFrom: 1 to: self numArgs)! !!Integer methodsFor: 'tiles' stamp: 'RAA 8/24/1999 15:32'!asPrecedenceName	^#('unary' 'binary' 'keyword') at: self! !!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 10/20/2000 13:12'!submorphAfter	"Return the submorph after (behind) me, or nil"	| ii |	owner ifNil: [^ nil].	^ (ii _ owner submorphIndexOf: self) = owner submorphs size 		ifTrue: [nil]		ifFalse: [owner submorphs at: ii+1].	! !!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 10/20/2000 13:13'!submorphBefore	"Return the submorph after (behind) me, or nil"	| ii |	owner ifNil: [^ nil].	^ (ii _ owner submorphIndexOf: self) = 1 		ifTrue: [nil]		ifFalse: [owner submorphs at: ii-1].	! !!NonEditableTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/1999 16:27'!mouseDown: evt	^owner mouseDown: evt! !!ParseNode methodsFor: 'printing' stamp: 'tk 10/16/2000 13:57'!nodePrintOn: aStrm indent: nn	| var aaStrm myLine |	"Show just the sub nodes and the code."	(aaStrm _ aStrm) ifNil: [aaStrm _ WriteStream on: (String new: 500)].	nn timesRepeat: [aaStrm tab].	aaStrm nextPutAll: self class name; space.	myLine _ self printString copyWithout: Character cr.	myLine _ myLine copyFrom: 1 to: (myLine size min: 70).	aaStrm nextPutAll: myLine; cr.	1 to: self class instSize do: [:ii | 		var _ self instVarAt: ii.		(var respondsTo: #asReturnNode) ifTrue: [var nodePrintOn: aaStrm indent: nn+1]].	1 to: self class instSize do: [:ii | 		var _ self instVarAt: ii.		(var isKindOf: SequenceableCollection) ifTrue: [				var do: [:aNode | 					(aNode respondsTo: #asReturnNode) ifTrue: [						aNode nodePrintOn: aaStrm indent: nn+1]]]].	^ aaStrm! !!ParseNode methodsFor: 'tiles' stamp: 'tk 10/22/2000 17:16'!addCommentToMorph: aMorph	| row stream |	(comment isNil or: [comment isEmpty]) ifTrue: [^self].	stream _ SyntaxMorphStream on: (Text new: 400).	self printCommentOn: stream indent: 1.	row _ aMorph addTextRow: stream contents asString.	row explanation: 'This is simply a comment'.	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 12:24'!asMorphicSyntaxIn: parent	| morph |	"Default for missing implementations"	morph _ parent addColumn: #error on: self.	morph addTextRow: self class printString.	^morph	! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 13:06'!currentValueIn: aContext	^nil! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 18:18'!explanation	^self class printString! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 12:36'!getMenuItemsIn: aContext	^{		{'inspect node'. [self inspect]}.		{'explore node'. [self explore]}	}! !!AssignmentNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 10:37'!asMorphicSyntaxIn: parent	| row |	row _ parent addRow: #assignment on: self.	variable asMorphicSyntaxIn: row.	row addTextRow: ' _ '.	value asMorphicSyntaxIn: row.	^row! !!AssignmentNode methodsFor: 'tiles' stamp: 'RAA 8/15/1999 16:31'!explanation	^'The value of ',value explanation,' is being stored in ',variable explanation! !!BlockNode methodsFor: 'tiles' stamp: 'tk 10/22/2000 16:11'!asMorphicSyntaxIn: parent	| len shown row column |	(column _ parent addColumn: #block on: self) inset: 4; minBorderWidth: 1.		"level _ 1 max: levelOrZero."	self addCommentToMorph: column.	len _ shown _ statements size.	column explanation: 'A block of ',len printString,' Smalltalk statements',(		arguments size = 0 ifTrue: [''] ifFalse: [' and ',arguments size printString,' arguments']	).		"(levelOrZero = 0 and: [statements last isReturnSelf]) ifTrue: [shown _ 1 max: shown - 1]."	arguments size = 0 ifFalse: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		arguments do: [:arg | 			(arg asMorphicSyntaxIn: row) color: #blockarg2		].	].	(statements copyFrom: 1 to: shown) do: [ :each | 		(each asMorphicSyntaxIn: column) borderWidth: 0.		each addCommentToMorph: column.	] separatedBy: [		column addMorphBack: (			AlignmentMorph newRow 				vResizing: #rigid; 				color: Color transparent;				extent: 2@2		).			].	^column! !!BraceNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 10:37'!asMorphicSyntaxIn: parent	| row |	row _ parent addRow: #brace on: self.	row addTextRow: (String streamContents: [ :aStream | self printOn: aStream indent: 0]).	^row! !!CascadeNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 12:02'!asMorphicSyntaxIn: parent	| cascadeMorph exp row |	exp _ 'A series of ',messages size printString,' messages sent to the same receiver'.	row _ parent addRow: #cascade on: self.	receiver asMorphicSyntaxIn: row.	cascadeMorph _ row addColumn: #cascade2 on: self.	messages do: [ :m | 		 m asMorphicSyntaxIn: cascadeMorph.	].	cascadeMorph explanation: exp.	row explanation: exp,' ',receiver explanation."expr addCommentToMorph: morph."	^row! !!CascadeNode methodsFor: 'accessing' stamp: 'tk 10/22/2000 16:55'!receiver	^receiver! !!Encoder methodsFor: 'source mapping' stamp: 'RAA 8/21/1999 06:52'!rawSourceRanges	^ sourceRanges ! !!LeafNode methodsFor: 'copying' stamp: 'tk 10/20/2000 11:45'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.key _ deepCopier references at: key ifAbsent: [key].! !!LeafNode methodsFor: 'copying' stamp: 'tk 10/20/2000 11:41'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."key _ key.		Weakly copied"code _ code veryDeepCopyWith: deepCopier.! !!LiteralNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 10:44'!asMorphicSyntaxIn: parent	| row |	row _ parent addColumn: #literal on: self.	(key isMemberOf: Association) ifFalse: [		^row addTextRow: key storeString	].	key key isNil ifTrue: [		^row addTextRow: ('###',key value soleInstance name)	] ifFalse: [		^row addTextRow: ('##', key key)	].	! !!LiteralNode methodsFor: 'tiles' stamp: 'RAA 8/15/1999 18:45'!explanation	(key isMemberOf: Association) ifFalse: [		^'Literal ', key storeString	].	key key isNil ifTrue: [		^'Literal ', ('###',key value soleInstance name) 	] ifFalse: [		^'Literal ', ('##', key key) 	].	! !!MessageNode methodsFor: 'printing' stamp: 'RAA 6/9/2000 18:06'!asMorphicCaseOn: parent indent: ignored	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise |	braceNode _ arguments first.	otherwise _ arguments last.	((arguments size = 1) or: [otherwise isJustCaseError]) ifTrue: [		self morphFromKeywords: #caseOf: arguments: {braceNode} on: parent indent: nil.		^parent	].	self morphFromKeywords: #caseOf:otherwise: arguments: arguments on: parent indent: nil.	^parent! !!MessageNode methodsFor: 'tiles' stamp: 'tk 10/22/2000 19:48'!asMorphicSyntaxIn: parent	| printer substitute row sel |	sel _ #message.	parent ifNodeClass: CascadeNode then: [sel _ #keyword2].	row _ parent addRow: sel on: self.	special > 0 ifTrue: [printer _ MacroPrinters at: special].	substitute _ self as: BobsMessageNode.	(printer == #printCaseOn:indent:) ifTrue: [		self asMorphicCaseOn: row indent: nil.		^parent 	"morph?"	].	(special > 0)		ifTrue: 			[substitute perform: printer with: row with: nil]		ifFalse: 			[substitute 				printKeywords: selector key				arguments: arguments				on: row				indent: nil]."expr addCommentToMorph: morph."	^row! !!MessageNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 12:37'!buildMenuForClass: aClass andSelector: aSelector	| myOwnItems |	myOwnItems _ OrderedCollection new.	myOwnItems add: {'Senders'. [Smalltalk browseAllCallsOn: aSelector]}.	myOwnItems add: {'Implementors'. [Smalltalk browseAllImplementorsOf: aSelector]}.	myOwnItems add: {'Local Implementors'. 			[Utilities methodHierarchyBrowserForClass: aClass selector: aSelector]}.	^(self getMenuItemsIn: nil),{nil},myOwnItems	! !!MessageNode methodsFor: 'tiles' stamp: 'tk 10/19/2000 16:26'!morphFromKeywords: key arguments: args on: parent indent: ignored	| keywords arg thisKey column row selType explanation receiverString getMenuBlock |	getMenuBlock _ [ :aClass | self buildMenuForClass: aClass andSelector: key].	receiver ifNotNil: [	"i.e. not a cascade"		receiver asMorphicSyntaxIn: parent.	].	parent getMenuBlock: getMenuBlock.	keywords _ key keywords.	selType _ precedence asPrecedenceName.	receiverString _ receiver ifNil: [		''	] ifNotNil: [		' sent to ',receiver explanation	].	args size = 0 ifTrue: [		row _ parent 			addTextRow: key getMenuBlock: getMenuBlock explanation: nil.		parent explanation: selType,' message #',keywords first,receiverString.		^ row parseNode: selector.	].	args size = 1 ifTrue: [		row _ parent 			addTextRow: keywords first  			getMenuBlock: getMenuBlock			explanation: selType,' selector'.		row parseNode: selector.		args first asMorphicSyntaxIn: parent.		parent explanation: selType,' message #', keywords first, ' with an argument ',					args first explanation, receiverString.		"(args first asMorphicSyntaxIn: parent)			explanation: selType,' message #',keywords first,' with an argument ',					args first explanation,receiverString."		^self	].		explanation _ 'A keyword message #',key,				' with ',keywords size printString,' arguments'.	column _ parent addColumn: #keyword1 on: self.	column explanation: explanation;  getMenuBlock: getMenuBlock.	1 to: keywords size do: [:part |		arg _ args at: part.		thisKey _ keywords at: part.		(row _ column addRow: #keyword2 on: self)			borderWidth: 0;			parseNode: nil.		row addTextRow: thisKey.		arg asMorphicSyntaxIn: row.	].	explanation _ explanation,receiverString.	parent explanation: explanation.! !!BobsMessageNode methodsFor: 'trickery' stamp: 'RAA 6/9/2000 18:25'!printIfNilNotNil: aMorph indent: level	| newNode |	newNode _ aMorph parseNode clone.	newNode receiver ifNotNil:		[newNode receiver: newNode receiver ifNilReceiver].	"fudge so it prints right"	(arguments first isJust: NodeNil) ifTrue:		[^ newNode morphFromKeywords: #ifNotNil:				arguments: { arguments second }				on: aMorph indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ newNode morphFromKeywords: #ifNil:				arguments: { arguments first }				on: aMorph indent: level].	^ newNode morphFromKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aMorph indent: level! !!BobsMessageNode methodsFor: 'trickery' stamp: 'BJP 6/9/2000 12:37'!printIfOn: aStream indent: level "Just copied the old MessageNode one down here."	(arguments last isJust: NodeNil)		ifTrue: [^ self				printKeywords: #ifTrue:				arguments: (Array with: arguments first)				on: aStream				indent: level].	(arguments last isJust: NodeFalse)		ifTrue: [^ self				printKeywords: #and:				arguments: (Array with: arguments first)				on: aStream				indent: level].	(arguments first isJust: NodeNil)		ifTrue: [^ self				printKeywords: #ifFalse:				arguments: (Array with: arguments last)				on: aStream				indent: level].	(arguments first isJust: NodeTrue)		ifTrue: [^ self				printKeywords: #or:				arguments: (Array with: arguments last)				on: aStream				indent: level].	self		printKeywords: #ifTrue:ifFalse:		arguments: arguments		on: aStream		indent: level! !!BobsMessageNode methodsFor: 'trickery' stamp: 'RAA 8/15/1999 16:23'!printKeywords: key arguments: args on: morph indent: level	^morph parseNode		morphFromKeywords: key 		arguments: args 		on: morph 		indent: level! !!BobsMessageNode methodsFor: 'trickery' stamp: 'RAA 6/9/2000 15:32'!printReceiver: rcvr on: aMorph indent: level						"I don't think we need this to do anything since we already printed the receiver ourself"! !!BobsMessageNode methodsFor: 'trickery' stamp: 'RAA 6/9/2000 16:50'!printToDoOn: aMorph indent: level	| limitNode |		limitNode _ (arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [arguments first]		ifFalse: [arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aMorph indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aMorph indent: level]! !!BobsMessageNode methodsFor: 'trickery' stamp: 'RAA 6/9/2000 17:15'!printWhileOn: aMorph indent: level	(arguments first isJust: NodeNil) ifTrue: [		selector _ SelectorNode new			key: (selector key == #whileTrue:				ifTrue: [#whileTrue] ifFalse: [#whileFalse])			code: #macro.		arguments _ Array new	].	self printKeywords: selector key arguments: arguments		on: aMorph indent: level! !!MethodNode methodsFor: 'tiles' stamp: 'tk 10/22/2000 16:20'!asMorphicSyntaxIn: morph	| args header tempMorph |	header _ morph addRow: Color white on: 		(selectorOrFalse class == SelectorNode ifTrue: [selectorOrFalse] ifFalse: [nil]).	header explanation: precedence asPrecedenceName,' message header for: #',self selector.	precedence = 1 ifTrue: [		header addTextRow: self selector	] ifFalse: [		args _ ReadStream on: arguments.		self selector keywords do: [:s | 			header addTextRow: s.			(args next asMorphicSyntaxIn: header) color: #blockarg2		].	].	self addCommentToMorph: morph.	temporaries size > 0 ifTrue: [		tempMorph _ morph addRow: #tempVariable on: (MethodTempsNode new).		tempMorph 			color: tempMorph color darker;			explanation: 'These temporary variables are defined for the duration of this method'.		temporaries do: [:temp | 			temp asMorphicSyntaxIn: tempMorph		] separatedBy: [			tempMorph addMorphBack: (tempMorph transparentSpacerOfSize: 4@1)		].	].	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue: [		" Dont decompile <prim> for, eg, ^ self "		(morph addTextRow: (String streamContents: [ :strm | self printPrimitiveOn: strm]))			explanation: 'A primitive is in the VM. This is where all the hard stuff happens'.	].	block asMorphicSyntaxIn: morph.	^morph! !!MethodNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 12:21'!asMorphicSyntaxUsing: aClass		| morph |	(morph _ aClass 		column: #method 		on: self)		borderWidth: 0.	^self asMorphicSyntaxIn: morph! !!MethodNode methodsFor: 'tiles' stamp: 'RAA 8/20/1999 19:56'!rawSourceRanges	self generate: #(0 0 0 0).	^encoder rawSourceRanges! !!Rectangle methodsFor: 'FMP' stamp: 'RAA 6/1/1999 17:41'!deltaToEnsureInOrCentered: r extra: aNumber	| dX dY halfXDiff halfYDiff |	dX _ dY _ 0.	halfXDiff _ (r width - self width * aNumber) truncated.	halfYDiff _ (r height - self height  * aNumber) truncated.	self left < r left		ifTrue: [dX _ self left - r left - halfXDiff]		ifFalse: [self right > r right ifTrue: [dX _ self right - r right + halfXDiff]].	self top < r top		ifTrue: [dY _ self top - r top - halfYDiff]		ifFalse: [self bottom > r bottom ifTrue: [dY _ self bottom - r bottom + halfYDiff]].	^dX @ dY! !!ReturnNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 10:46'!asMorphicSyntaxIn: parent	| row |	row _ parent addRow: #return on: self.	row addTextRow: '^ '.	expr asMorphicSyntaxIn: row.	expr addCommentToMorph: row.	^row! !!ReturnNode methodsFor: 'tiles' stamp: 'RAA 8/15/1999 19:31'!explanation	^'Exit this method returning the value of ',expr explanation! !!ScrollBar methodsFor: 'scrolling' stamp: 'RAA 8/24/1999 18:19'!scrollByPage: event	"Fix for hhorizontal scrollbars - 24 Aug 1999 - Bob Arning"	nextPageDirection == nil ifTrue: [		nextPageDirection _ bounds isWide ifTrue: [			event cursorPoint x >= slider center x		]		ifFalse: [			event cursorPoint y >= slider center y		]	].	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!StringHolder methodsFor: 'tiles' stamp: 'RAA 8/17/1999 08:30'!openBobsSyntaxView	"Open Bob's syntax view on the current method"	| class selector |	(selector _ self selectedMessageName) ifNotNil: [		class _ self selectedClassOrMetaClass.		SyntaxMorph testClass: class andMethod: selector.	]! !!Browser methodsFor: 'message functions' stamp: 'tk 10/16/2000 20:34'!messageListMenu: aMenu shifted: shifted	| aList |	aList _ shifted		ifFalse: [#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			-			('fileOut'								fileOutMessage)			('printOut'								printOutMessage)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('tile scriptor'							openBobsSyntaxView)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			-			('more...'								shiftedYellowButtonActivity))]		ifTrue: [#(			('method pane' 							makeIsolatedCodePane)			"('make a scriptor'						makeScriptor)"			('toggle diffing'							toggleDiffing)			('implementors of sent messages'			browseAllMessages)			-			('sample instance'						makeSampleInstance)			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)			-			('remove from this browser'				removeMessageFromBrowser)			('change category...'					changeCategory)			-			('change sets with this method'			findMethodInChangeSets)			('revert to previous version'				revertToPreviousVersion)			('remove from current change set'		removeFromCurrentChanges)			('revert and forget'						revertAndForget)			-			('fetch documentation'					fetchDocPane)			('more...' 								unshiftedYellowButtonActivity))].	^ aMenu addList: aList! !!SyntaxMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/1999 16:19'!delete	whenDone ifNotNil: [whenDone value. whenDone _ nil].	super delete.! !!SyntaxMenuMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/17/2000 11:44'!mouseUp: evt	"since we are mucking around with the selected item"	self delete "deleteIfPopUp"! !!SyntaxMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/1999 16:18'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | true] ifNone: [nil].	self position: aPoint.	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: (selectedItem ifNil: [self]).	self changed! !!SyntaxMenuMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/1999 15:39'!whenDone: aBlock	whenDone _ aBlock! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 22:04'!accept	| cls |	"Turn my current state into the text of a method.  Compile it in my class.  I am a method node."	(cls _ self parsedInClass) ifNil: [^ self].	cls compile: self decompile notifying: nil.	"Maybe refresh this view based on the new source?"! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 21:22'!acceptDroppingMorph: aMorph event: evt	| itNoun |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	(parseNode class == BlockNode) & itNoun ifTrue: [		 (aMorph parseNode class == TempVariableNode) 			ifTrue: ["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse: [						self addToBlock: aMorph event: evt]]	"if already declared, start new line of code with it"			ifFalse: [^ self addToBlock: aMorph event: evt]].				"If I am a BlockNode and it is a noun add it as a new line"	(parseNode class == BlockNode) ifTrue: [		 (aMorph parseNode class == ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	owner parseNode class == AssignmentNode ifTrue: [		(owner submorphIndexOf: self) = 1 ifTrue: [			(#(TempVariableNode VariableNode) includes: aMorph parseNode class name) ifFalse: [				^ self]]].	"Can't put statement, literal, assignment, or cascade into left side of assignment"	owner replaceSubmorph: self by: aMorph.	"do the normal replacement"	aMorph owner layoutChanged.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/23/2000 08:46'!addBlockArg: aMorph	| tempHolder tt var nn row |	"Add a temporary to a block or the method.  Return true if succeed"	owner parseNode class == MethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not insided the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph class == SyntaxMorph 				ifTrue: [tt firstSubmorph parseNode class == TempVariableNode 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ aMorph firstSubmorph firstSubmorph contents.	"name"	tempHolder ifNil: ["make whole row"		row _ self addRow: #blockarg1 on: (BlockArgsNode new).		var _ row addColumn: #tempVariable on: aMorph parseNode.		self addMorphFront: row.		var addTextRow: nn.		^ true].	tempHolder ifNotNil: [		"If this variable is not present, add it"		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].				"is present. caller adds the temp as a new line of code to be extended"		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var addTextRow: nn.		^ true].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/17/2000 11:55'!addColumn: aColorOrSymbol on: aNode	| row |	self addMorphBack: (row _ self class column: aColorOrSymbol on: aNode).	"Transcript show: aColorOrSymbol; cr."	aColorOrSymbol == #keyword1 		ifTrue: [row inset: 0]		ifFalse: [row inset: -1].	^row! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:12'!addRow: aColorOrSymbol on: aNode	| row |	self addMorphBack: (row _ self class row: aColorOrSymbol on: aNode).	^row! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/23/2000 08:46'!addTempVar: aMorph 	| tempHolder ii tt var nn tempMorph |	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.					tt firstSubmorph class == SyntaxMorph						ifTrue: [tt firstSubmorph parseNode class == TempVariableNode								ifTrue: [tt]]].	nn _ aMorph firstSubmorph firstSubmorph contents.	tempHolder ifNil: [		tempMorph _ owner addRow: #tempVariable on: MethodTempsNode new.		owner addMorph: tempMorph inFrontOf: self.		tempMorph color: tempMorph color darker;			 explanation: 'These temporary variables are defined for the duration of this method'.		aMorph parseNode asMorphicSyntaxIn: tempMorph.		^ true].	tempHolder ifNotNil: [		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var addTextRow: nn.		^ true]! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 17:18'!addTextRow: aStringLikeItem	| row text |	(row _ self class row: #text on: nil) borderWidth: 0.	text _ "NonEditableTextMorph" StringMorph new contents: 		(aStringLikeItem copyWithout: Character cr).	row addMorph: text.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/17/2000 11:23'!addTextRow: aStringLikeItem getMenuBlock: aBlock explanation: aString	| row text |	(row _ self class row: #text on: nil) borderWidth: 0.	"row inset: 0.  horizontal"	text _ "NonEditableTextMorph" StringMorph new contents: aStringLikeItem.	row addMorph: text.	"text top: text top - 2."	self addMorphBack: row.	row		getMenuBlock: aBlock;		explanation: aString.	^row! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 21:16'!addToBlock: aMorph event: evt	"Insert a new line of code"	| whereDropped dropBefore |	whereDropped _ "self pointFromWorld:" evt cursorPoint.	dropBefore _ self submorphs 		detect: [ :each | (each isKindOf: SyntaxMorph) and: 							[whereDropped y < each center y]] 		ifNone: [nil].	(aMorph parseNode class == ReturnNode) ifTrue: [dropBefore _ nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [self addMorph: aMorph inFrontOf: dropBefore].	self addMorph: (			AlignmentMorph newRow 				vResizing: #rigid; 				color: Color transparent;				extent: 2@2)		behind: aMorph.	self layoutChanged.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 17:57'!balloonText	^(('Value: ',(self getCurrentValue ifNil: [^nil])) 		withNoLineLongerThan: 35) truncateWithElipsisTo: 300! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/1999 09:09'!borderWidth: x	"for the benefit of nodes which should never go to zero"	super borderWidth: (x max: (minBorderWidth ifNil: [0]))! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:14'!color: aColorOrSymbol	^super color: (self class translateColor: aColorOrSymbol)! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/1999 07:30'!debugger: x	debugger _ x! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/21/2000 23:44'!decompile	| stream |	"Produce Smalltalk code.  We have a tree of SyntaxMorphs, but not a tree of ParseNodes.  The user has dragged in many SyntaxMorphs, each with its own parseNode, but those nodes are not sewn together in a tree.  The only data we get from a ParseNode is its class.	We produce really ugly code.  But we compile it and decompile (prettyPrint) again for user to see."	stream _ DialectStream on: (Text new: 400).	stream setDialect: #ST80.	self printOn: stream indent: 1.	"Tree walk and produce text of the code"	^ stream contents! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/1999 16:35'!explanation: x		explanation _ x			! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/20/2000 07:58'!externalName	parseNode ifNil: [^ 'Syntax -- (extra layer)'].	^ self parseNode class printString! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 13:08'!getCurrentValue	parseNode ifNil: [^nil].	^parseNode currentValueIn: self hostContext! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/1999 18:50'!getExplanation	explanation ifNotNil: [^explanation].	parseNode ifNotNil: [^parseNode explanation].	^nil! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/1999 17:14'!getMenuBlock	getMenuBlock ifNil: [^nil "owner getMenuBlock"].	^getMenuBlock valueWithPossibleArgs: {self parsedInClass}! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/1999 16:36'!getMenuBlock: x		getMenuBlock _ x			! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:37'!getMenuItemsIn: aContext	^self getMenuBlock ifNil: [(parseNode ifNil: [owner]) getMenuItemsIn: aContext]! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/19/2000 16:47'!handlesMouseDown: evt	"Yes, except if drag and I don't have a node."	^ evt yellowButtonPressed | (parseNode ~~ nil)! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:35'!hostContext	^nil		"we don't have one"! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 16:31'!ifNodeClass: aParseNodeClass then: aBlock	"If my parseNode is of that class, do the block"	parseNode ifNil: [^ self].	parseNode class == aParseNodeClass ifTrue: [aBlock value].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/21/2000 23:20'!implant	| subs |	"install my data into my node.  Collect the nodes of my submorphs, instead of believing the subnodes of my node.  Return my corrected node."	subs _ submorphs collect: [:ss | 		(ss respondsTo: #implant) ifTrue: [ss implant] 			ifFalse: ["(parseNode isKindOf: LeafNode) ifTrue: [parseNode key]"				ss class == StringMorph ifTrue: [ss contents] ifFalse: [nil]  ]].	subs select: [:ss | ss notNil].	parseNode ifNotNil: [parseNode loadFrom: subs].	^ parseNode! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/1999 08:42'!inAScrollPane	| widget |	widget _ TwoWayScrollPane new.	widget		extent: 10@10;		borderWidth: 1;		color: Color white.	widget scroller addMorph: self.	widget setScrollDeltas.	^widget! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/19/2000 22:03'!isNoun	"Consider these to be nouns:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	(#(TempVariableNode LiteralNode VariableNode CascadeNode AssignmentNode) includes:		(parseNode class name)) ifTrue: [^ true].	parseNode class == MessageNode ifTrue: [^ parseNode receiver notNil].	^ false! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/1999 09:09'!minBorderWidth: x	"for the benefit of nodes which should never go to zero"	minBorderWidth _ x! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/20/2000 14:49'!mouseDown: evt 	| kind dup spacer |	evt yellowButtonPressed		ifTrue: [^ self showMenu: evt].	spacer _ self submorphAfter.	(owner respondsTo: #parseNode)		ifTrue: [			(kind _ owner parseNode class) == BlockNode				ifTrue: [evt hand attachMorph: self.					self left: self left + (self width//2) + 7.					^ spacer class == AlignmentMorph ifTrue: [spacer delete]].			kind == MethodNode				ifTrue: ["evt hand attachMorph: self.					self left: self left + (self width//2) + 7.					^ spacer class == AlignmentMorph ifTrue: [spacer delete]"					^ self].	"can't take anything out of a MethodNode"			evt hand attachMorph: (dup _ self duplicate).			^ dup left: dup left + (dup width//2) + 7]		ifFalse: [			parseNode class == MethodNode				ifTrue: [^ self "whole method not draggable"].			"bare, out in the world"			evt hand attachMorph: self.			^ self left: self left + (self width//2) + 7].	"no more cases"! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 16:28'!openInWindow	| window widget sel |	sel _ self firstSubmorph firstSubmorph firstSubmorph contents.	window _ (SystemWindow labelled: 'Tiles for ', parsedInClass printString, '>>',sel).	widget _ self inAScrollPane.	window		addMorph: widget		frame: (0@0 extent: 1.0@1.0).	window openInWorldExtent: (		self extent + (20@40) min: (Display boundingBox extent * 0.8) rounded	)! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/1999 16:23'!parseNode		^parseNode			! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/1999 16:11'!parseNode: x		parseNode _ x			! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/17/2000 13:40'!parsedInClass	^ parsedInClass ifNil: [		owner class == SyntaxMorph ifTrue: [owner parsedInClass]			ifFalse: [(owner respondsTo: #parsedInClass) 				ifTrue: [owner parsedInClass]				ifFalse: [nil]]]! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/1999 13:44'!parsedInClass: x	parsedInClass _ x! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 20:43'!printOn: strm	super printOn: strm.	strm space; nextPutAll: parseNode class name.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 19:52'!printOn: strm indent: level 	| lev type first |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(type _ parseNode class) == BlockNode ifTrue: [		(owner respondsTo: #parseNode) ifTrue: [			owner parseNode class == MethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	type == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $( ]].	type == MethodTempsNode ifTrue: [strm nextPut: $|; space].	first _ true.	submorphs do: [:sub |		(sub respondsTo: #printOn:indent:) ifTrue: [			type == CascadeNode & first not ifTrue: [				color = (SyntaxMorph translateColor: #cascade2) ifTrue: [strm nextPut: $;; space ]].			type == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.			(type == BlockNode) & (sub parseNode class == BlockArgsNode) not	& 				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(type == BlockNode) & (sub parseNode class == BlockArgsNode) not					ifTrue: [strm crtab: lev]				ifFalse: [type == MethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			first _ false].		sub class == StringMorph ifTrue: [strm nextPutAll: sub contents].		"return indent for ifTrue: ifFalse:"].	type == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $) ]].	type  == BlockNode ifTrue: [		(owner respondsTo: #parseNode) ifTrue: [			owner parseNode class == MethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	type == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	type == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	type == MethodNode ifTrue: [strm skip: -1].	"erase last period"! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 21:46'!showCode	"Turn my current state into the text of a method.  Put it in a window."	(Workspace new contents: self decompile) openLabel: self printString,' code'	! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 21:42'!showMenu: evt	| exp oldColor oldWidth menu val |	exp _ self getExplanation ifNil: [^owner mouseDown: evt].	oldColor _ self borderColor.	oldWidth _ self borderWidth.	self borderWidth: 1.	self borderColor: Color red.	World displayWorldSafely.	exp _ exp withNoLineLongerThan: 35.	(val _ self getCurrentValue) ifNotNil: [		exp _ exp,'Value: ',((val withNoLineLongerThan: 35) truncateWithElipsisTo: 300).	].	menu _ "MenuMorph" SyntaxMenuMorph new.	menu title: exp.	menu add: 'OK' target: self selector: #yourself.	menu addLine.	(self getMenuItemsIn: self hostContext) do: [ :each |		each ifNil: [menu addLine] ifNotNil: [			menu 				add: each first				target: each second 				selector: #valueWithPossibleArgs:				argument: {self parsedInClass}		].	].	parseNode class == MethodNode ifTrue: [		menu add: 'accept method' target: self selector: #accept.		menu add: 'show code' target: self selector: #showCode].	menu whenDone: [		self borderColor: oldColor.		self borderWidth: oldWidth].	menu 		popUpAt: evt hand position x @ (self pointInWorld: self bounds bottomLeft) y		forHand: evt hand in: World.! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/1999 07:39'!testForNode: targetNode andDo: aBlock	targetNode == parseNode ifTrue: [aBlock value: self].	self submorphsDo: [ :each | 		(each isKindOf: SyntaxMorph) ifTrue: [			each testForNode: targetNode andDo: aBlock		].	].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 15:05'!update: aSymbol	| bingo saveOwner newMorph |	debugger ifNil: [^super update: aSymbol].	aSymbol == #contents ifTrue: [		saveOwner _ owner.		debugger removeDependent: self.		markerMorph ifNotNil: [markerMorph delete. markerMorph _ nil].		newMorph _ debugger createSyntaxMorph.		self delete.		saveOwner addMorph: newMorph.		saveOwner owner setScrollDeltas.		newMorph update: #contentsSelection.	].	aSymbol == #contentsSelection ifTrue: [		markerMorph ifNil: [			markerMorph _ RectangleMorph new.			markerMorph				color: Color transparent;				borderWidth: 2;				borderColor: Color red;				lock.			owner addMorphFront: markerMorph.		].		bingo _ parseNode rawSourceRanges keyAtValue: debugger pcRange ifAbsent: [nil].		self testForNode: bingo andDo: [ :foundMorph | 			markerMorph				position: foundMorph position;				extent: foundMorph extent.			owner owner scrollIntoView: foundMorph bounds extra: 0.5.			^self		].	].	super update: aSymbol! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'tk 10/20/2000 14:25'!wantsDroppedMorph: aMorph event: evt	| meNoun itNoun |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks."        (aMorph isKindOf: SyntaxMorph) ifFalse: [^ false].	"If nodes are of equal class, replace me with new one."	parseNode class == MessageNode ifFalse: [		parseNode class == aMorph parseNode class ifTrue: [^ true]].	meNoun _ self isNoun.	itNoun _ aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & (aMorph parseNode class == BlockNode) ifTrue: [							^ true].	(parseNode class == BlockNode) & itNoun ifTrue: [^ true].				"If I am a BlockNode, and it is a TempVariableNode, add it into list"				"If I am a BlockNode, and it is a noun, add it as a new line"	(parseNode class == BlockNode) ifTrue: [		 (aMorph parseNode class == ReturnNode) ifTrue: [			^ (self submorphs detect: [:mm | 					((mm isKindOf: SyntaxMorph) and: [mm parseNode class == ReturnNode])]				ifNone: [nil]) isNil]].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"	(parseNode class == MethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	^ false "otherwise reject"! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:26'!column: aColor on: aParseNode	| c color |	color _ self translateColor: aColor.	c _ self newColumn		inset: self standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1;		borderColor: color darker;		color: color;		centering: #topLeft;		parseNode: aParseNode.	^c! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:26'!row: aColor on: aParseNode	| r color |	color _ self translateColor: aColor.	r _ self newRow		inset: self standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1;		borderColor: color darker;		color: color;		centering: #center;		parseNode: aParseNode.	^r! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:26'!standardInset	^2! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 11:59'!test"SyntaxMorph test"	self testClass: MessageNode andMethod: #asMorphicSyntaxIn:.	"self testClass: MethodNode andMethod: #asMorphicSyntaxIn:."! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:23'!testAll	| source tree total count |"SyntaxMorph testAll"	count _ total _ 0.	Smalltalk allBehaviorsDo: [ :aClass | total _ total + 1].'Testing all behaviors'	displayProgressAt: Sensor cursorPoint	from: 0 to: total	during: [ :bar |		Smalltalk allBehaviorsDo: [ :aClass |			bar value: (count _ count + 1).			aClass selectors do: [ :aSelector |				source _ (aClass compiledMethodAt: aSelector) getSourceFromFile.				tree _ Compiler new 					parse: source 					in: aClass 					notifying: nil.				tree asMorphicSyntaxUsing: SyntaxMorph.			].		].	].! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/24/1999 12:22'!testClass: aClass andMethod: aSelector	| tree source |	source _ (aClass compiledMethodAt: aSelector) getSourceFromFile.	tree _ Compiler new 		parse: source 		in: aClass 		notifying: nil.	(tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass;		getMenuBlock: [nil];		openInWindow.! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 10/22/2000 19:42'!translateColor: aColorOrSymbol	aColorOrSymbol == #assignment  ifTrue: [^ Color paleGreen].	aColorOrSymbol == #block  ifTrue: [^ Color lightBlue darker].	aColorOrSymbol == #keyword1  ifTrue: [^ Color paleBuff].	aColorOrSymbol == #keyword2  ifTrue: [^ Color paleBuff lighter].	aColorOrSymbol == #cascade  ifTrue: [^ Color paleYellow darker].	aColorOrSymbol == #cascade2  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #literal  ifTrue: [^ Color paleMagenta].	aColorOrSymbol == #message  ifTrue: [^ Color paleYellow].	aColorOrSymbol == #method  ifTrue: [^ Color white].	aColorOrSymbol == #text  ifTrue: [^ Color transparent].	aColorOrSymbol == #error  ifTrue: [^ Color red].	aColorOrSymbol == #return  ifTrue: [^ Color lightGray].	aColorOrSymbol == #variable  ifTrue: [^ Color paleTan].	aColorOrSymbol == #brace  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #tempVariable  ifTrue: [^ Color paleYellow mixed: 0.75 with: Color paleGreen		"Color yellow lighter lighter"].	aColorOrSymbol == #blockarg2  ifTrue: [			^ Color paleYellow mixed: 0.75 with: Color paleGreen].	"arg itself"	aColorOrSymbol == #blockarg1  ifTrue: [^ Color paleRed].	"container"		"yellow mixed: 0.5 with: Color white"	aColorOrSymbol == #comment  ifTrue: [^ Color blue lighter].	^aColorOrSymbol! !!SyntaxMorphStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/9/2000 14:49'!dialect	^#ST80! !!SyntaxMorphStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/9/2000 14:57'!withStyleFor: elementType do: aBlock	"ignore DialectStream preferences for now"	^aBlock value! !!SystemDictionary methodsFor: 'copying' stamp: 'tk 10/20/2000 11:35'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!SystemWindow methodsFor: 'panes' stamp: 'RAA 6/9/2000 17:22'!replacePane: oldPane with: newPane	newPane		position: oldPane position;		extent: oldPane extent.	oldPane visible: false; lock: true; extent: 10@10.	newPane visible: true; lock: false.	(submorphs includes: newPane) ifFalse: [self addMorph: newPane].	paneMorphs _ paneMorphs collect: [ :each |		each == oldPane ifTrue: [newPane] ifFalse: [each]	].	self changed.! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/13/1999 14:50'!extent: newExtent	super extent: (newExtent max: 36@16).	self resizeScrollBar; resizeScroller; setScrollDeltas! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/13/1999 15:56'!leftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	^ self totalScrollRange - (self innerBounds extent * 3 // 4) max: 0@0! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/24/1999 18:13'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component. Used by scrollIntoView:"	| r newOffset |	newOffset _ (scroller offset - delta max: 0@0) min: self leftoverScrollRange.	scroller offset: newOffset.	r _ self leftoverScrollRange.	r y = 0		ifTrue: [yScrollBar value: 0.0]		ifFalse: [yScrollBar value: newOffset y asFloat / r y].	r x = 0		ifTrue: [xScrollBar value: 0.0]		ifFalse: [xScrollBar value: newOffset x asFloat / r x].! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/21/1999 10:17'!scrollIntoView: desiredRectangle extra: anumber	| shift |	shift _ desiredRectangle deltaToEnsureInOrCentered: (		scroller offset extent: scroller bounds extent	)  extra: anumber.	shift = (0 @ 0) ifFalse: [self scrollBy: (0@0) - shift].! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/13/1999 15:44'!setScrollDeltas	| range scrollerBounds scrollDelta totalRange innerBounds |	totalRange _ self totalScrollRange ifNil: [^self].	range _ self leftoverScrollRange.	innerBounds _ self innerBounds.	scrollerBounds _ scroller submorphBounds.	scrollDelta _ 10@10.	range x = 0 ifTrue: [		xScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0	] ifFalse: [		xScrollBar 			scrollDelta: (scrollDelta x / range x) asFloat 			pageDelta: (innerBounds width - scrollDelta x / range x) asFloat.		xScrollBar interval: (innerBounds width - scrollDelta x / totalRange x) asFloat.	].	range y = 0 ifTrue: [		yScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0	] ifFalse: [		yScrollBar 			scrollDelta: (scrollDelta y / range y) asFloat 			pageDelta: (innerBounds height - scrollDelta y / range y) asFloat.		yScrollBar interval: (innerBounds height - scrollDelta y / totalRange y) asFloat.	].	"	scrollBar scrollDelta: (self scrollDeltaHeight / range) asFloat 			pageDelta: ((self innerBounds height - self scrollDeltaHeight) / range) asFloat.	scrollBar interval: ((self innerBounds height - self scrollDeltaHeight) / self totalScrollRange) "! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/13/1999 15:43'!totalScrollRange	"Return the entire scrolling range."	^ ((scroller submorphBounds ifNil: [^nil]) encompass: 0@0) extent! !!TwoWayScrollPane methodsFor: 'retractable scroll bar' stamp: 'RAA 6/9/2000 15:05'!hideOrShowScrollBar	^self		"we don't support retractable at the moment"! !!TwoWayScrollPane methodsFor: 'pane events' stamp: 'tk 10/18/2000 13:35'!rejectsEvent: anEvent	^self visible not		"ignore locked status"! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 8/24/1999 16:01'!xScrollBarValue: scrollValue 	"although there appear to be no senders, see Slider>>setValue:"	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: self leftoverScrollRange x * scrollValue @ scroller offset y! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 8/13/1999 15:55'!yScrollBarValue: scrollValue	"although there appear to be no senders, see Slider>>setValue:"	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: scroller offset x @ (self leftoverScrollRange y * scrollValue)! !!TwoWayScrollPane methodsFor: 'as yet unclassified' stamp: 'RAA 10/20/2000 19:29'!layoutChanged	scroller ifNotNil: [self setScrollDeltas].	^super layoutChanged! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 10:47'!asMorphicSyntaxIn: parent	| column |	column _ parent addColumn: #variable on: self.	column addTextRow: name.	^column! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 16:34'!currentValueIn: aContext	aContext ifNil: [^nil].	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) value printString	! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/16/1999 12:36'!explanation	self isSelfPseudoVariable ifTrue: [^'the pseudo variable <self> (refers to the receiver)'].	^(#('instance' 'temporary' 'LIT3' 'global') 			at: self type 			ifAbsent: ['UNK',self type printString]),' variable <',name,'>'			"LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4."! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 17:54'!getMenuItemsIn: aContext	| myOwnItems standardPart getter |	standardPart _ super getMenuItemsIn: aContext.	myOwnItems _ OrderedCollection new.	self type = 2 ifTrue: [		aContext ifNil: [^standardPart].		(getter _ self variableGetterBlockIn: aContext) ifNotNil: [			myOwnItems add: {'Inspect ',name. [ :aClass | getter value inspect]}.			myOwnItems add: {'Explore ',name. [ :aClass | getter value explore]}.		].	].	self type = 1 ifTrue: [		myOwnItems add: {'References to ',name. [ :aClass | aClass browseAllAccessesTo: key]}.		(getter _ self variableGetterBlockIn: aContext) ifNotNil: [			myOwnItems add: {'Inspect ',name. [ :aClass | getter value inspect]}.			myOwnItems add: {'Explore ',name. [ :aClass | getter value explore]}.		].	].	(self type = 4 and: [key isKindOf: Association]) ifTrue: [		myOwnItems add: {'Inspect ',name. [key value inspect]}.		myOwnItems add: {'Explore ',name. [key value explore]}.		key value isBehavior ifTrue: [			myOwnItems add: {'Browse ',name. [key value browse]}.		].		myOwnItems add: {'References to ',name. [Smalltalk browseAllCallsOn: key]}.	].	^standardPart,{nil},myOwnItems			"LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4."! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 17:56'!variableGetterBlockIn: aContext	| temps index ivars |	(self type = 4 and: [key isKindOf: Association]) ifTrue: [		^[key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars _ aContext receiver class allInstVarNames.		index _ ivars indexOf: name ifAbsent: [^nil].		^[aContext receiver instVarAt: index]	].	self type = 2 ifTrue: [		temps _ aContext tempNames.		index _ temps indexOf: name ifAbsent: [^nil].		^[aContext tempAt: index]	].	^nil! !!TempVariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 10:46'!asMorphicSyntaxIn: parent	| column |	column _ parent addColumn: #tempVariable on: self.	column addTextRow: name.	^column! !!TempVariableNode methodsFor: 'tiles' stamp: 'RAA 8/16/1999 12:34'!explanation	^(self isArg ifTrue: ['Method argument'] ifFalse: ['Temporary variable']),' <',name,'>'! !SyntaxMorph removeSelector: #initialize!SyntaxMorph removeSelector: #printOn:indent:parentPrecedence:!LeafNode removeSelector: #loadFrom:!