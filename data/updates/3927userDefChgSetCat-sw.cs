'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 28 February 2001 update 3923] on 11 April 2001 at 8:24:14 pm'!"Change Set:		userDefChgSetCat-swDate:			11 April 2001Author:			Scott WallaceAdds the ability to maintain user-defined change-set-categories.  A new item in the change-set-list menu of a change-sorter, 'category functions...', offers the ability to:	¥	Add a new change-set-category	¥	Delete an existing change-set category	¥	Rename an existing change-set category	¥	Add a change set to an existing change-set-category	¥	Delete a change set from an existing change-set-categoryThree other recently-added change-set-category-related commands have now also been moved into this new categories submenu.Also fixes the find-change-set command in change sorters such that it only offers change sets that reside in the current category; this circumvents the former problem that a change sorter could have a selected change set which was not in its list.Also a couple of further bug fixes and cleanups relating to change-set categories."!ChangeSetCategory subclass: #StaticChangeSetCategory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!StaticChangeSetCategory commentStamp: 'sw 4/11/2001 13:03' prior: 0!StaticChangeSetCategory is a user-defined change-set category that has in it only those change sets specifically placed there.!!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:30'!addToCategoryOpposite	"Add the current change set to the category viewed on the opposite side, if it's of the sort to accept things like that"	| categoryOpposite |	categoryOpposite _ (parent other: self) changeSetCategory.	categoryOpposite acceptsManualAdditions		ifTrue:			[categoryOpposite addChangeSet: myChangeSet.			categoryOpposite reconstituteList.			self update]		ifFalse:			[self inform: 'sorry, this command only makes senseif the category showing on the oppositeside is a static category whosemembers are manually maintained']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 20:06'!categorySubmenu: aMenu  shifted: shiftedIgnored	"Fill aMenu with less-frequently-needed category items"		aMenu title: 'Change set category'.	aMenu add: 'make a new category...' action: #makeNewCategory.	aMenu balloonTextForLastItem:'Creates a new change-set-category (you will be asked to supply a name) which will start out its life with this change set in it'.	aMenu add: 'rename this category' action: #renameCategory.	aMenu balloonTextForLastItem:'Rename this change-set category.   Only applies when the current category being shown is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.'.	aMenu add: 'remove this category' action: #removeCategory.	aMenu balloonTextForLastItem:'Remove this change-set category.   Only applies when the current category being shown is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.'.	aMenu addLine.	parent ifNotNil:		[aMenu add: 'add change set to category opposite' action: #addToCategoryOpposite.		aMenu balloonTextForLastItem:	'Adds this change set to the category on the other side of the change sorter.  Only applies if the category shown on the opposite side is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.'].	aMenu add: 'remove change set from this category' action: #removeFromCategory.	aMenu balloonTextForLastItem:'Removes this change set from the current category.  Only applies when the current category being shown is a manually-maintained, user-defined category, such as you can create for yourself by choosing "make a new category..." from this same menu.'.	aMenu addLine.	aMenu add: 'file out category''s change sets' action: #fileOutAllChangeSets.	aMenu balloonTextForLastItem:'File out every change set in this category that has anything in it.  The usual checks for slips are suppressed when this command is done.'.	aMenu add: 'set recent-updates marker' action: #setRecentUpdatesMarker.	aMenu balloonTextForLastItem:'Allows you to specify a number that will demarcate which updates are considered "recent" and which are not.  This will govern which updates are included in the RecentUpdates category in a change sorter'.	aMenu add: 'fill aggregate change set' action: #fillAggregateChangeSet.	aMenu balloonTextForLastItem:'Creates a change-set named Aggregate into which all the changes in all the change sets in this category will be copied.'.	aMenu addLine.	aMenu add: 'back to main menu' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the shifted change-set menu.'.	aMenu add: 'back to shifted menu' action: #offerShiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 17:57'!changeSetMenu: aMenu shifted: isShifted 	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"	isShifted ifTrue: [^ self shiftedChangeSetMenu: aMenu].	Smalltalk isMorphic		ifTrue:			[aMenu title: 'Change Set'.			aMenu addStayUpItemSpecial]		ifFalse:			[aMenu title: 'Change Set:' , myChangeSet name].	aMenu add: 'make changes go to me (m)' action: #newCurrent.	aMenu addLine.	aMenu add: 'new change set... (n)' action: #newSet.	aMenu add: 'find...(f)' action: #findCngSet.	aMenu add: 'show category... (s)' action:  #chooseChangeSetCategory.	aMenu balloonTextForLastItem:'Lets you choose which change sets should be listed in this change sorter'.	aMenu add: 'select change set...' action: #chooseCngSet.	aMenu addLine.	aMenu add: 'rename change set (r)' action: #rename.	aMenu add: 'file out (o)' action: #fileOut.	aMenu add: 'mail to list' action: #mailOut.	aMenu add: 'browse methods (b)' action: #browseChangeSet.	aMenu add: 'browse change set (B)' action: #openChangeSetBrowser.	aMenu addLine.	parent		ifNotNil: 			[aMenu add: 'copy all to other side (c)' action: #copyAllToOther.			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.			aMenu add: 'subtract other side' action: #subtractOtherSide.			aMenu addLine].	myChangeSet hasPreamble		ifTrue: 			[aMenu add: 'edit preamble (p)' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse: [aMenu add: 'add preamble (p)' action: #addPreamble].	myChangeSet hasPostscript		ifTrue: 			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.	aMenu add: 'category functions...' action: #offerCategorySubmenu.	aMenu balloonTextForLastItem:'Various commands relating to change-set-categories'.	aMenu addLine.	aMenu add: 'destroy change set (x)' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/10/2001 23:49'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates nameList |	self okToChange ifFalse: [^ self].	pattern _ FillInTheBlank request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	nameList _ self changeSetList.	candidates _ AllChangeSets select:			[:c | (nameList includes: c name) and: 				[c name includesSubstring: pattern caseSensitive: false]].	candidates size = 0 ifTrue: [^ self beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index _ (PopUpMenu labels: 		(candidates collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:43'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName _ FillInTheBlank request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName _ catName asSymbol.	(ChangeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory _ StaticChangeSetCategory new categoryName: catName.	ChangeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:26'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[self changeSetCategory acceptsManualAdditions ifTrue:			[changeSetCategory addChangeSet: aSet].		self update.		(changeSetCategory includesChangeSet: aSet) ifTrue:			[self showChangeSet: aSet].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 17:41'!offerCategorySubmenu	"Offer a menu of category-related items"	self offerMenuFrom: #categorySubmenu:shifted: shifted: false! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 20:03'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only remove manually-added categories.'].	(self confirm: 'Really remove the change-set-categorynamed ', (itsName _ changeSetCategory categoryName), '?') ifFalse: [^ self].	ChangeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 16:31'!removeFromCategory	"Add the current change set to the category viewed on the opposite side, if it's of the sort to accept things like that"	| aCategory |	(aCategory _ self changeSetCategory) acceptsManualAdditions		ifTrue:			[aCategory removeElementAt: myChangeSet name.			aCategory reconstituteList.			self update]		ifFalse:			[self inform: 'sorry, this command only makessense for static categories whosemembers are manually maintained']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 18:18'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only rename manually-added categories.'].	catName _ FillInTheBlank request: 'Please give the new category a name' initialAnswer:  (oldName _ changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName _ catName asSymbol) = oldName ifTrue: [^ self inform: 'no change.'].	(ChangeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	ChangeSetCategories removeElementAt: oldName.	ChangeSetCategories elementAt: catName put: changeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 4/11/2001 17:57'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	Smalltalk isMorphic ifTrue:		[aMenu title: 'Change set (shifted)'.		aMenu addStayUpItemSpecial].	"CONFLICTS SECTION"	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	parent ifNotNil:		[aMenu add: 'conflicts with change set opposite' action: #methodConflictsWithOtherSide.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'.			aMenu add: 'conflicts with category opposite' action: #methodConflictsWithOppositeCategory.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in ANY change set in the category list on the opposite side of this change sorter, other of course than this change set itself.  (Caution -- this could be VERY slow)'].	aMenu addLine.	"CHECKS SECTION"	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'promote to top of list' action: #promoteToTopChangeSet.	aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'expunge uniclasses' action: #expungeUniclasses.	aMenu balloonTextForLastItem:'Remove from the change set all memory of uniclasses, e.g. classes added on behalf of etoys, fabrik, etc., whose classnames end with a digit.'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'file into new...' action: #fileIntoNewChangeSet.	aMenu balloonTextForLastItem: 'Load a fileout from disk and place its changes into a new change set (seldom needed -- much better to do this from a file-list browser these days.)'.	aMenu add: 'reorder all change sets' action: #reorderChangeSets.	aMenu balloonTextForLastItem:'Applies a standard reordering of all change-sets in the system -- at the bottom will come the sets that come with the release; next will come all the numbered updates; finally, at the top, will come all other change sets'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ElementCategory methodsFor: 'elements' stamp: 'sw 4/11/2001 20:08'!removeElementAt: aKey	"Remove the element at the given key"	elementDictionary removeKey: aKey ifAbsent: [^ self].	keysInOrder remove: aKey ifAbsent: []! !!ChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/11/2001 16:11'!acceptsManualAdditions	"Answer whether the user is allowed manually to manipulate the contents of the change-set-category."	^ false! !!StaticChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/11/2001 16:10'!acceptsManualAdditions	"Answer whether the user is allowed manually to manipulate the contents of the change-set-category."	^ true! !!StaticChangeSetCategory methodsFor: 'queries' stamp: 'sw 4/11/2001 16:00'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ elementDictionary includesKey: aChangeSet name! !!StaticChangeSetCategory methodsFor: 'add' stamp: 'sw 4/11/2001 15:58'!addChangeSet: aChangeSet	"Add the change set manually"	self elementAt: aChangeSet name put: aChangeSet! !!StaticChangeSetCategory methodsFor: 'updating' stamp: 'sw 4/11/2001 16:36'!reconstituteList	"Reformulate the list.  Here, since we have a manually-maintained list, at this juncture we only make sure change-set-names are still up to date, and we purge moribund elements"	|  survivors |	survivors _ elementDictionary select: [:aChangeSet | aChangeSet isMoribund not].	self clear.	(survivors asSortedCollection: [:a :b | a name <= b name]) reverseDo:		[:aChangeSet | self addChangeSet: aChangeSet]! !!StaticChangeSetCategory reorganize!('queries' acceptsManualAdditions includesChangeSet:)('add' addChangeSet:)('updating' reconstituteList)!