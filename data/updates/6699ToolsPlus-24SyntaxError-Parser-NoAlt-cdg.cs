'From Squeak3.9alpha of 4 July 2005 [latest update: #6693] on 31 October 2005 at 9:46:12 pm'!Scanner subclass: #Parser	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag category'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!!Parser methodsFor: 'public access' stamp: 'CdG 10/31/2005 21:45'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         | methNode repeatNeeded myStream parser s p |		category := aCategory.		parser := self.        myStream := sourceStream.        [repeatNeeded := false.	   p := myStream position.	   s := myStream upToEnd.	   myStream position: p.        parser init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag := noPattern.        failBlock := aBlock.        [methNode := parser method: noPattern context: ctxt                                encoder: (Encoder new init: class context: ctxt notifying: parser)]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded  := (requestor isKindOf: TextMorphEditor) not.                        myStream  := ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder  := failBlock  := requestor  := parseNode  := nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!Parser methodsFor: 'public access' stamp: 'md 8/14/2005 17:54'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         | methNode repeatNeeded myStream s p |         myStream  := sourceStream.        [repeatNeeded  := false.	   p  := myStream position.	   s  := myStream upToEnd.	   myStream position: p.        self init: myStream notifying: req failBlock: [^ aBlock value].        doitFlag  := noPattern.        failBlock := aBlock.        [methNode  := self method: noPattern context: ctxt                                encoder: (Encoder new init: class context: ctxt notifying: self)]                 on: ParserRemovedUnusedTemps                 do:                         [ :ex | repeatNeeded  := (requestor isKindOf: TextMorphEditor) not.                        myStream  := ReadStream on: requestor text string.                        ex resume].        repeatNeeded] whileTrue.        encoder  := failBlock  := requestor  := parseNode  := nil. "break cycles & mitigate refct overflow"	   methNode sourceText: s.        ^ methNode! !!Parser methodsFor: 'error handling' stamp: 'LC 1/6/2002 14:30'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxErrorNotification					inClass: encoder classEncoding					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !