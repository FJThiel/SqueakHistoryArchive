'From Squeak2.9alpha of 13 June 2000 [latest update: #3003] on 12 November 2000 at 5:58:33 pm'!"Change Set:		FasterLayouts-arDate:			12 November 2000Author:			Andreas RaabSpeeds up the common layouts by roughly a factor of five."!!ScrollPane methodsFor: 'initialization' stamp: 'ar 11/12/2000 12:22'!initialize	retractableScrollBar _ (Preferences valueOfFlag: #inboardScrollbars) not.	scrollBarOnLeft _ (Preferences valueOfFlag: #scrollBarsOnRight) not.	super initialize.	hasFocus _ false.	borderWidth _ 2.	borderColor _ Color black.	scrollBar := ScrollBar new model: self slotName: 'scrollBar'.	scrollBar borderWidth: 1; borderColor: Color black.	scroller := TransformMorph new color: Color transparent.	scroller offset: -3@0.	self addMorph: scroller.	retractableScrollBar ifFalse: [self addMorph: scrollBar].	self on: #mouseEnter send: #mouseEnter: to: self.	self on: #mouseLeave send: #mouseLeave: to: self.	self extent: 150@120! !!Morph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 17:47'!changed	"Report that the area occupied by this morph should be redrawn."	fullBounds ifNotNil:[^self invalidRect: self fullBounds].	self layoutPolicy ifNil:[^self invalidRect: self fullBounds].	^self invalidRect: (self priorFullBounds ifNil:[self bounds]).! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:33'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	| layout |	layout _ self layoutPolicy.	layout ifNil:[^self addMorph: aMorph].	self privateAddMorph: aMorph 		atIndex: (layout indexForInserting: aMorph at: evt position in: self).! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:34'!adjustLayoutBounds	"Adjust the receivers bounds depending on the resizing strategy imposed"	| hFit vFit box myExtent extent |	hFit _ self hResizing.	vFit _ self vResizing.	(hFit == #shrinkWrap or:[vFit == #shrinkWrap]) ifFalse:[^self]. "not needed"	box _ self layoutBounds.	myExtent _ box extent.	extent _ self submorphBounds corner - box origin.	hFit == #shrinkWrap ifTrue:[myExtent _ extent x @ myExtent y].	vFit == #shrinkWrap ifTrue:[myExtent _ myExtent x @ extent y].	"Make sure we don't get smaller than minWidth/minHeight"	myExtent x < self minWidth ifTrue:[		myExtent _ (myExtent x max: 			(self minWidth - self bounds width + self layoutBounds width)) @ myExtent y].	myExtent y < self minHeight ifTrue:[		myExtent _ myExtent x @ (myExtent y max:			(self minHeight - self bounds height + self layoutBounds height))].	self layoutBounds: (box origin extent: myExtent).! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:46'!doLayoutIn: layoutBounds	"Compute a new layout based on the given layout bounds."	| layout box |	"Send #ownerChanged to our children"	submorphs size > 0 		ifTrue:[submorphs do:[:m| m ownerChanged]].	layout _ self layoutPolicy.	layout ifNotNil:[layout layout: self in: layoutBounds].	self adjustLayoutBounds.	fullBounds _ self privateFullBounds.	layout ifNotNil:[		box _ self priorFullBounds.		self priorFullBounds: nil.		box == nil			ifTrue:[self invalidRect: fullBounds]			ifFalse:[box = fullBounds				ifFalse:[self invalidRect: (box quickMerge: fullBounds)]]].! !!Morph methodsFor: 'layout' stamp: 'ar 11/11/2000 17:27'!fullBounds	"Return the bounding box of the receiver and all its children. Recompute the layout if necessary."	fullBounds ifNotNil:[^fullBounds].	self doLayoutIn: self layoutBounds.	^fullBounds! !!Morph methodsFor: 'layout' stamp: 'ar 10/30/2000 15:42'!layoutBounds	"Return the bounds for laying out children of the receiver"	| inset box |	inset _ self layoutInset.	box _ self innerBounds.	^box insetBy: inset.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:45'!layoutChanged	fullBounds ifNil:[^self]. "layout will be recomputed so don't bother"	self layoutPolicy ifNotNil:[self priorFullBounds: fullBounds].	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	"note: does not send #ownerChanged here - we'll do this when computing the new layout"! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 00:06'!layoutInBounds: cellBounds	"Layout specific. Apply the given bounds to the receiver after being layed out in its owner."	| box aSymbol |	fullBounds ifNil:["We are getting new bounds here but we haven't computed the receiver's layout yet. Although the receiver has reported its minimal size before the actual size it has may differ from what would be after the layout. Normally, this isn't a real problem, but if we have #shrinkWrap constraints then the receiver's bounds may be larger than the cellBounds. THAT is a problem because the centering may not work correctly if the receiver shrinks after the owner layout has been computed. To avoid this problem, we compute the receiver's layout now. Note that the layout computation is based on the new cell bounds rather than the receiver's current bounds."		cellBounds origin = self bounds origin			ifFalse:[self privateFullMoveBy: (cellBounds origin - self bounds origin)]. "sigh..."		box _ cellBounds origin extent: "adjust for #rigid receiver"			(self hResizing == #rigid ifTrue:[self bounds extent x] ifFalse:[cellBounds extent x]) @			(self vResizing == #rigid ifTrue:[self bounds extent y] ifFalse:[cellBounds extent y]).		"Compute inset of layout bounds"		box _ box origin - (self bounds origin - self layoutBounds origin) corner:					box corner - (self bounds corner - self layoutBounds corner).		"And do the layout within the new bounds"		self layoutBounds: box.		self doLayoutIn: box].	cellBounds = bounds ifTrue:[^self]. "already up to date"	cellBounds extent = bounds extent "nice fit"		ifTrue:[^self position: cellBounds origin].	box _ bounds.	"match #spaceFill constraints"	self hResizing == #spaceFill 		ifTrue:[box _ box origin extent: cellBounds width @ box height].	self vResizing == #spaceFill		ifTrue:[box _ box origin extent: box width @ cellBounds height].	"align accordingly"	aSymbol _ (owner ifNil:[self]) cellPositioning.	box _ box align: (box perform: aSymbol) with: (cellBounds perform: aSymbol).	"and install new bounds"	self bounds: box.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:35'!layoutProportionallyIn: newBounds	"Layout specific. Apply the given bounds to the receiver."	| box frame |	frame _ self layoutFrame ifNil:[^self].	"before applying the proportional values make sure the receiver's layout is computed"	self fullBounds. "sigh..."	"compute the cell size the receiver has given its layout frame"	box _ frame layout: self bounds in: newBounds.	(box = self bounds) ifTrue:[^self]. "no change"	^self layoutInBounds: box.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:43'!minExtent	"Layout specific. Return the minimum size the receiver can be represented in.	Implementation note: When this message is sent from an owner trying to lay out its children it will traverse down the morph tree and recompute the minimal arrangement of the morphs based on which the minimal extent is returned. When a morph with some layout strategy is encountered, the morph will ask its strategy to compute the new arrangement. However, since the final size given to the receiver is unknown at the point of the query, the assumption is made that the current bounds of the receiver are the base on which the layout should be computed. This scheme prevents strange layout changes when for instance, a table is contained in another table. Unless the inner table has been resized manually (which means its bounds are already enlarged) the arrangement of the inner table will not change here. Thus the entire layout computation is basically an iterative process which may have different results depending on the incremental changes applied."	| layout minExtent extra hFit vFit |	hFit _ self hResizing.	vFit _ self vResizing.	(hFit == #spaceFill or:[vFit == #spaceFill]) ifFalse:[		"The receiver will not adjust to parents layout by growing or shrinking,		which means that an accurate layout defines the minimum size."		^self fullBounds extent].	"An exception -- a receiver with #shrinkWrap constraints but no children is being treated #rigid (the equivalent to a #spaceFill receiver in a non-layouting owner)"	self hasSubmorphs ifFalse:[		hFit == #shrinkWrap ifTrue:[hFit _ #rigid].		vFit == #shrinkWrap ifTrue:[vFit _ #rigid]].	layout _ self layoutPolicy.	layout == nil		ifTrue:[minExtent _ 0@0]		ifFalse:[minExtent _ layout minExtentOf: self in: self layoutBounds].	hFit == #rigid		ifTrue:[	minExtent _ self fullBounds extent x @ minExtent y]		ifFalse:[	extra _ self bounds width - self layoutBounds width.				minExtent _ (minExtent x + extra) @ minExtent y].	vFit == #rigid		ifTrue:[minExtent _ minExtent x @ self fullBounds extent y]		ifFalse:[extra _ self bounds height - self layoutBounds height.				minExtent _ minExtent x @ (minExtent y + extra)].	minExtent _ minExtent max: (self minWidth@self minHeight).	^minExtent! !!Morph methodsFor: 'layout' stamp: 'ar 11/11/2000 23:46'!minHeight	extension == nil ifTrue:[^2].	^self valueOfProperty: #minHeight ifAbsent:[2]! !!Morph methodsFor: 'layout' stamp: 'ar 11/11/2000 23:46'!minWidth	extension == nil ifTrue:[^2].	^self valueOfProperty: #minWidth ifAbsent:[2]! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:50'!privateFullBounds	"Private. Compute the actual full bounds of the receiver"	| box |	box _ self bounds copy.	self hasDropShadow ifTrue:[box _ self expandFullBoundsForDropShadow: box].	self hasRolloverBorder ifTrue:[box _ self expandFullBoundsForRolloverBorder: box].	submorphs size > 0 ifTrue: [		self clipSubmorphs			ifTrue:[box _ box quickMerge: (self submorphBounds intersect: self clippingBounds)]			ifFalse:[box _ box quickMerge: self submorphBounds]].	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/11/2000 23:41'!disableTableLayout	"Layout specific. Disable laying out the receiver in table layout"	extension == nil ifTrue:[^false].	^self valueOfProperty: #disableTableLayout ifAbsent:[false]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/11/2000 23:38'!hResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	extension == nil ifTrue:[^#rigid].	^self valueOfProperty: #hResizing ifAbsent:[#rigid]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/11/2000 23:39'!vResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	extension == nil ifTrue:[^#rigid].	^self valueOfProperty: #vResizing ifAbsent:[#rigid]! !!MenuMorph methodsFor: 'private' stamp: 'ar 11/12/2000 17:52'!positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset sub delta |	self fullBounds. "force layout"	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	self right > aWorld worldBounds right		ifTrue: [self left: self left - self width + 4].	"Make sure that the menu fits in the world."	delta _ self bounds amountToTranslateWithin: aWorld worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!Presenter methodsFor: 'viewer' stamp: 'ar 11/12/2000 17:54'!viewMorph: aMorph	| aPlayer aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ (topItem _ aMorph topRendererOrSelf) assuredPlayer.	aViewer _ self nascentPartsViewer.	"19 sept 2000 - allow flaps in any paste up"	flapLoc _ associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: aPlayer barHeight: 0.		aViewer enforceTileColorPolicy.		aViewer fullBounds. "force layout"		associatedMorph addMorph: aViewer.		flapLoc hideViewerFlapsOtherThanFor: aPlayer.		aFlapTab _ flapLoc viewerFlapTabFor: topItem.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		^ flapLoc startSteppingSubmorphsOf: aViewer].			aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds. "force layout"	Preferences automaticViewerPlacement ifTrue:		[aPoint _ aMorph bounds right @ 			(aMorph center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		associatedMorph addMorph: aViewer.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ self].	aMorph primaryHand attachMorph: (aViewer visible: true)! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/12/2000 17:28'!layout: aMorph in: box	"Compute the layout for the given morph based on the new bounds"	| cells arrangement horizontal newBounds |	aMorph hasSubmorphs ifFalse:[^self].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(aMorph wrapDirection == #none and:[aMorph cellSpacing == #none]) ifTrue:[		"get into the fast lane"		aMorph listCentering == #justified ifFalse:["can't deal with that"			aMorph listDirection == #leftToRight 				ifTrue:[^self layoutLeftToRight: aMorph in: newBounds].			aMorph listDirection == #topToBottom				ifTrue:[^self layoutTopToBottom: aMorph in: newBounds].		].	].	(aMorph listDirection == #topToBottom or:[aMorph listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal 						target: aMorph.	"Step 3: Compute the extra spacing for each cell"	self computeExtraSpacing: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.	"Step 4: Place the children within the cells accordingly"	self placeCells: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/11/2000 21:30'!minExtentOf: aMorph in: box	"Return the minimal size aMorph's children would require given the new bounds"	| cells arrangement horizontal newBounds minX minY minExtent dir |	aMorph hasSubmorphs ifFalse:[^0@0].	(aMorph wrapDirection == #none and:[aMorph cellSpacing == #none]) ifTrue:[		"Get into the fast lane"		dir _ aMorph listDirection.		(dir == #leftToRight or:[dir == #rightToLeft])			ifTrue:[^self minExtentHorizontal: aMorph].		(dir == #topToBottom or:[dir == #bottomToTop])			ifTrue:[^self minExtentVertical: aMorph].	].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(aMorph listDirection == #topToBottom or:[aMorph listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal						target: aMorph.	"Step 3: Extract the minimum size out of the arrangement"	minX _ minY _ 0.	arrangement do:[:cell|		minX _ minX max: cell cellSize x + cell extraSpace x.		minY _ minY + cell cellSize y + cell extraSpace y].	horizontal 		ifTrue:[minExtent _ minX@minY]		ifFalse:[minExtent _ minY@minX].	^minExtent! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/12/2000 12:32'!layoutLeftToRight: aMorph in: newBounds	"An optimized left-to-right list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell |	size _ aMorph minCellSize asPoint. minX _ size x. minY _ size y.	size _ aMorph maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ aMorph cellInset asPoint x.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|		m disableTableLayout ifFalse:[			n _ n + 1.			cell _ LayoutCell new target: m.			(m hResizing == #spaceFill) ifTrue:[				cell hSpaceFill: true.				extra _ m spaceFillWeight.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell hSpaceFill: false].			(m vResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeX.			last ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	aMorph reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	n > 1 ifTrue:[width _ width + (n-1 * inset)].	(aMorph hResizing == #shrinkWrap and:[aMorph rubberBandCells or:[sum isZero]])		ifTrue:[extent _ width @ (extent y max: height)].	(aMorph vResizing == #shrinkWrap and:[aMorph rubberBandCells or:[vFill not]])		ifTrue:[extent _ (extent x max: width) @ height].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			height _ extent y.		] ifFalse:[			centering _ aMorph wrapCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)]		].	].	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ aMorph listCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		width _ cell cellSize.		(extraPerCell > 0 and:[cell hSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			width _ width + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posX _ posX + width + inset.		cell _ cell nextCell.	].! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/12/2000 12:36'!layoutTopToBottom: aMorph in: newBounds	"An optimized top-to-bottom list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell |	size _ aMorph minCellSize asPoint. minX _ size x. minY _ size y.	size _ aMorph maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ aMorph cellInset asPoint y.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|		m disableTableLayout ifFalse:[			n _ n + 1.			cell _ LayoutCell new target: m.			(m vResizing == #spaceFill) ifTrue:[				cell vSpaceFill: true.				extra _ m spaceFillWeight.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell vSpaceFill: false].			(m hResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeY.			first ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	aMorph reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	n > 1 ifTrue:[height _ height + (n-1 * inset)].	(aMorph vResizing == #shrinkWrap and:[aMorph rubberBandCells or:[sum isZero]])		ifTrue:[extent _ (extent x max: width) @ height].	(aMorph hResizing == #shrinkWrap and:[aMorph rubberBandCells or:[vFill not]])		ifTrue:[extent _ width @ (extent y max: height)].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			width _ extent x.		] ifFalse:[			centering _ aMorph wrapCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)]		].	].	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ aMorph listCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		height _ cell cellSize.		(extraPerCell > 0 and:[cell vSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			height _ height + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posY _ posY + height + inset.		cell _ cell nextCell.	].! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/11/2000 23:20'!minExtentHorizontal: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ aMorph minCellSize asPoint. minX _ size x. minY _ size y.	size _ aMorph maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ aMorph cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	n > 1 ifTrue:[width _ width + (n-1 * inset x)].	^width @ height! !!TableLayout methodsFor: 'optimized' stamp: 'ar 11/11/2000 23:21'!minExtentVertical: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ aMorph minCellSize asPoint. minX _ size x. minY _ size y.	size _ aMorph maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ aMorph cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	n > 1 ifTrue:[height _ height + (n-1 * inset y)].	^width @ height! !Morph removeSelector: #adjustBounds!