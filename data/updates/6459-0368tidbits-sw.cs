'From Squeakland 3.8.5976 of 25 August 2004 [latest update: #367] on 16 November 2004 at 7:32:27 pm'!"Change Set:		tidbits-swDate:			16 November 2004Author:			Scott WallaceA few methods skimmed from Vancouver updates...From 0269blackDotFixes, fixups for two methods that still used the old black-dot string:	FilecontentsBrowser>>infoViewContents	StackMorph class>>stackHelpWindowFrom 0312CallScriptSpeed-tk, an adaptation of a performance improvement by Ted for ScriptInstantiation>>runIfTicking:Also neutralized the devastating effect that an m17n change had on the object-names of AlignmentMorph subclasses."!!AlignmentMorph class methodsFor: 'scripting' stamp: 'sw 11/16/2004 00:44'!defaultNameStemForInstances	"The code just below, now commented out, resulted in every instance of every sublcass of AlignmentMorph being given a default name of the form 'Alignment1', rather than the desired 'MoviePlayer1', 'ScriptEditor2', etc."	"^ 'Alignment'"	^ super defaultNameStemForInstances! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'sw 10/7/2004 23:13'!infoViewContents	"Answer the string to show in the info view"	| theClass stamp exists |	editSelection == #newClass ifTrue: [^ self packageInfo: self selectedPackage].	self selectedClass isNil ifTrue: [^ ''].	theClass _ Smalltalk at: self selectedClass name asSymbol ifAbsent: [].	editSelection == #editClass ifTrue:		[^ theClass notNil			ifTrue: ['Class exists already in the system' translated]			ifFalse: ['New class' translated]].	editSelection == #editMessage ifFalse: [^ ''].	(theClass notNil and: [self metaClassIndicated])		ifTrue: [theClass _ theClass class].	stamp _ self selectedClassOrMetaClass stampAt: self selectedMessageName.	exists _ theClass notNil and: [theClass includesSelector: self selectedMessageName].	^ stamp = 'methodWasRemoved'		ifTrue:			[exists				ifTrue:					['Existing method removed  by this change-set' translated]				ifFalse:					['Removal request for a method that is not present in this image' translated]]		ifFalse:			[stamp, ' ¦Ç¬ ',				(exists 					ifTrue: ['Method already exists' translated , self extraInfo]					ifFalse: ['New method' translated])]! !!ScriptInstantiation methodsFor: 'running' stamp: 'sw 11/16/2004 13:55'!runIfTicking: nowTick 	"If the receiver is meant to be ticking, run it if it's time"	| ticks rate |	status == #ticking ifFalse: [^self].	rate := self tickingRate.	ticks := (lastTick isNil or: [nowTick < lastTick]) 				ifTrue: 					[lastTick := nowTick.					1]				ifFalse: [((nowTick - lastTick) * rate * 0.001) asInteger].	ticks <= 0 ifTrue: [^self].	"Scripts which have been out of the world and then return can have a huge number of ticks accumulated. A better fix would be to reset <lastTick> when a script leaves/enters the world. Also, if the system is falling behind, this attempt to catch up can result in falling further behind, leading to sluggish behavior and termination of ticking status. Whether the user really wants this catch up behavior needs to be determined (often she will not, I suspect) and better ways of doing it need to be found.  (This comment inserted by Bob Arning on 3/5/2001)"	ticks := 1.	1 to: ticks * self frequency do: [:i | player triggerScript: selector].	lastTick := nowTick.	ticks > 10 		ifTrue: 			["check if we're lagging behind"			ticks <= ((Time millisecondClockValue - lastTick) * rate / 1000) asInteger 				ifTrue: 					["e.g., time to run script is higher than number of ticks"					self status: #paused.					self updateAllStatusMorphs]]! !!StackMorph class methodsFor: 'parts bin' stamp: 'sw 11/16/2004 19:30'!stackHelpWindow	"Put up a window with help for stack use"	^ (Workspace new contents: 'A "stack" is a place where you can create, store, view and retrieve data "fields" from a set of "cards".  Data that you want to occur on every card (such as a name and an address in an Address Stack) are represented by objects such as "Simple Text", "Fancy Text", and "Scrolling Text" that you obtain from the Stack Tools flap.When you look at a card in a Stack, you may be seeing three different kinds of material.  Press the ¦Ç¬ß button in the stack''s controls to see the current designations, and use the "explain designations" to get a reminder of what the three different colors mean.¦Ç¬  Things that are designated to be seen on every card, and have the same contents whichever card is being shown. (green)¦Ç¬  Things that are designated to be seen on every card, with each card having its own value for them. (orange)¦Ç¬  Things that are designated to occur only on the particular card at hand. (red)Use the "stack/cards" menu (in an object''s halo menu) to change the designation of any object.  For example, if you have an object that is private to just one card, and you want to make it visible on all cards, use "place onto background".  If you further want it to hold a separate value for each separate card, use "start holding separate data for each instance".The normal sequence to define a Stack''s structure is to obtain a blank Stack, then create your fields by grabbing what you want from the Stack Tools flap and dropping it where you want it in the stack.  For easiest use, give a name to each field (by editing the name in its halo) *before* you put it onto the background..  Those fields that you want to represent the basic data of the stack need to be given names, placed on the background, and then told to hold separate data.When you hit the + button in a stack''s controls, a new card is created with default values in all the fields.  You can arrange for a particular default value to be used in a field -- do this either for one field at a time with "be default value on new card", or you can request that the all the values seen on a particular card serve as default by choosing "be defaults for new cards" from the stack''s ¦Ç¬ menu.It is also possible to have multiple "backgrounds" in the same stack -- each different background defines a different data structure, and cards from multiple backgrounds can be freely mixed in the same stack.Besides text fields, it is also possible to have picture-valued fields -- and potentially fields with data values of any other type as well.')	embeddedInMorphicWindowLabeled: 'Stack Help' translated	"StackMorph stackHelpWindow"! !