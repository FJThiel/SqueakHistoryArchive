'From Squeak 2.3 of January 14, 1999 on 16 February 1999 at 5:05:25 pm'!"Change Set:		BBBOptimizationDate:			12 February 1999Author:			Andreas RaabThis change set includes BBB ('B'alloon-'B'it'B'lt) optimizations,by checking if the current transformation in a BalloonCanvasis close enough to a pure translation so that an optimized version(from FormCanvas) can be used.NOTE: This is not yet finished - currently there is a possible problem,	when drawing anti-aliased, non-rectangular shapes."!!Canvas methodsFor: 'initialization' stamp: 'ar 2/9/1999 06:29'!flush! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 05:40'!fillColor: c	"Note: This always fills, even if the color is transparent."	"Note2: To achieve the above we must make sure that c is NOT transparent"	self frameAndFillRectangle: form boundingBox 		fillColor: (c alpha: 1.0)		borderWidth: 0		borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 05:51'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw a filled and outlined oval"	"Note: The optimization test below should actually read:		self ifNoTransformWithIn: (r insetBy: borderWidth // 2)	but since borderWidth is assumed to be very small related to r we don't check it."	(self ifNoTransformWithIn: r)		ifTrue:[^super fillOval: r color: c borderWidth: borderWidth borderColor: borderColor].	^self drawOval: (r insetBy: borderWidth // 2) 			color: c 			borderWidth: borderWidth 			borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 05:40'!fillRectangle: r color: c	"Fill the rectangle with the given color"	^self frameAndFillRectangle: r			fillColor: c			borderWidth: 0			borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 06:26'!frameAndFillRectangle: r fillColor: c borderWidth: borderWidth borderColor: borderColor	"Draw a filled and outlined rectangle"	"Note: The optimization test below should actually read:		self ifNoTransformWithIn: (r insetBy: borderWidth // 2)	but since borderWidth is assumed to be very small related to r we don't check it."	(self ifNoTransformWithIn: r)		ifTrue:[^super frameAndFillRectangle: r fillColor: c borderWidth: borderWidth borderColor: borderColor].	^self drawRectangle: (r insetBy: borderWidth // 2) 			color: c 			borderWidth: borderWidth 			borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 05:52'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw a beveled or raised rectangle"	| bw |	"Note: The optimization test below should actually read:		self ifNoTransformWithIn: (r insetBy: borderWidth // 2)	but since borderWidth is assumed to be very small related to r we don't check it."	(self ifNoTransformWithIn: r)		ifTrue:[^super frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor].	"Fill rectangle and draw top and left border"	bw _ borderWidth // 2.	self drawRectangle: (r insetBy: bw)		color: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now draw bottom right border."	self drawPolygon: (Array with: r topRight + (bw negated@bw) 							with: r bottomRight - bw asPoint							with: r bottomLeft + (bw@bw negated))		color: nil		borderWidth: borderWidth		borderColor: bottomRightColor.! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 05:41'!frameRectangle: r width: w color: c	"Draw a frame around the given rectangle"	^self frameAndFillRectangle: r			fillColor: nil			borderWidth: w			borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/12/1999 17:45'!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(self ifNoTransformWithIn:(pt1 rect: pt2))		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 2/13/1999 01:04'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	| warp dstRect srcQuad dstOffset center |	(self ifNoTransformWithIn: sourceRect) & false		ifTrue:[^super image: aForm at: aPoint sourceRect: sourceRect rule: rule].	dstRect _ (transform localBoundsToGlobal: (aForm boundingBox translateBy: aPoint)).	dstOffset _ 0@0. "dstRect origin."	"dstRect _ 0@0 corner: dstRect extent."	center _ 0@0."transform globalPointToLocal: dstRect origin."	srcQuad _ transform globalPointsToLocal: (dstRect innerCorners).	srcQuad _ srcQuad collect:[:pt| pt - aPoint].	warp _ (WarpBlt toForm: Display)			sourceForm: aForm;			cellSize: 2;  "installs a new colormap if cellSize > 1"			combinationRule: Form over.	warp copyQuad: srcQuad toRect: (dstRect translateBy: dstOffset).	self frameRectangle: (aForm boundingBox translateBy: aPoint) color: Color green.	"... TODO ... create a bitmap fill style from the form and use it for a simple rectangle."! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 2/9/1999 05:46'!line: point1 to: point2 brushForm: brush	"Who's gonna use this?"	| pt1 pt2 |	self flush. "Sorry, but necessary..."	transform 		ifNil:[pt1 _ point1. pt2 _ point2]		ifNotNil:[pt1 _ transform localPointToGlobal: point1.				pt2 _ transform localPointToGlobal: point2].	^super line: pt1 to: pt2 brushForm: brush! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 2/9/1999 05:46'!paragraph: para bounds: bounds color: c	(self ifNoTransformWithIn: bounds)		ifTrue:[^super paragraph: para bounds: bounds color: c].! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 2/9/1999 05:38'!text: s bounds: boundsRect font: fontOrNil color: c	(self ifNoTransformWithIn: boundsRect)		ifTrue:[^super text: s bounds: boundsRect font: fontOrNil color: c]! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 2/9/1999 06:24'!drawColor: c	(c isNil or:[c isColor and:[c isTransparent]]) ifTrue:[^nil].	^shadowDrawing		ifTrue:[Color gray]		ifFalse:[c]! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 2/9/1999 06:29'!ifNoTransformWithIn: box	"Return true if the current transformation does not affect the given bounding box"	| delta |	"false ifFalse:[^false]."	transform isNil ifTrue:[^true].	delta _ (transform localPointToGlobal: box origin) - box origin.	^(transform localPointToGlobal: box corner) - box corner = delta! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 2/13/1999 00:43'!newTransformationMorph	^MatrixTransformMorph new	"^TransformationMorph new"! !!WorldMorph methodsFor: 'drawing' stamp: 'ar 2/9/1999 06:28'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		hands do: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	canvas flush.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: viewBox origin)]]		ifFalse: [canvas showAt: viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !