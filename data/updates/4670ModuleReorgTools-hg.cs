'From Squeak3.2alpha of 8 October 2001 [latest update: #4418] on 16 October 2001 at 4:21:31 pm'!"Change Set:		ModuleReorgToolsDate:			3 September 2001Author:			Henrik GedenrydCode and tools for analyzing and reorganizing the system under the modules scheme to remove dependencies. Very much a work in progress."!ObjectExplorer subclass: #ModuleExplorer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Modules'!ObjectExplorerWrapper subclass: #ModuleExplorerWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Modules'!Object subclass: #ModuleRefactorer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Modules'!!ModuleRefactorer commentStamp: '<historical>' prior: 0!This class holds code for refactoring the modular image. All system categories from an older image will reside in the Squeak subtree #(Squeak <...>) in the new virtual module hierarchy.Create subclasses of me, residing in the submodule Refactorings, that will take an image from one version of the Squeak module subtree to another. This is to allow the image to evolve in an orderly manner through successive refactorings, contributed by various Squeakers.!ModuleRefactorer subclass: #FromVersion0p0000to0001	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Modules-Refactorings'!!FromVersion0p0000to0001 commentStamp: '<historical>' prior: 0!These are a first rough set of refactorings. Look at Morphic to get a glimpse of the intended onion-skin architecture where major subsystems are divided into Core/Library/Application/Demo/Test.!Object subclass: #ModuleReference	instanceVariableNames: 'module name specifiedVersion importNames '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Modules'!!Dictionary methodsFor: 'simple caching' stamp: 'hg 9/11/2001 15:03'!addWillGrow	"Keep array at least 1/4 free for decent hash behavior"	^array size - tally - 2 < (array size // 4 max: 1)! !!Dictionary methodsFor: 'simple caching' stamp: 'hg 9/12/2001 15:49'!at: key ifAbsentCache: aBlock 	| slot assoc old |	"Return the value at the given key. 	If key is not included in the receiver, cache value by	evaluating aBlock which should store into the cached association. 	(This clunky solution to allow non-local returns from the ifAbsent... block.)"	slot _ self findElementOrNil: key.	(assoc _ array at: slot) ifNotNil: [^ assoc value].	assoc _ key->nil.	self addWillGrow 		ifFalse: [self add: assoc]		ifTrue: [			"find a position to put anObject in. 			 a simple strategy that was the best out of a few that were tried"			[	slot _ slot - 1. 				slot < 1 ifTrue: [slot _ array size].				(array at: slot) isNil			] whileTrue.			old _ array at: slot.			array at: slot put: assoc].	aBlock value: assoc.	"restore old value into cache if no value was returned"	(assoc value isNil and: [old notNil]) ifTrue: [array at: slot put: old].	^assoc value" To calibrate the size of your cache, for different sizes graph either times or hit rates of a critical operation.(20 to: 200 by: 40) collect: [:size |	range _ 1000.	nrOfAccessses _ 10000.	cache _ IdentityDictionary new: size.	distribution _ (1 to: range), ((1 to: range) collect: [:i | ((i / range) squared squared * range) asInteger]).	accesses _ ((1 to: (nrOfAccessses/distribution size) truncated) 					inject: #() into: [:all :i | all, distribution]) shuffled.	misses _ 0.	time _ MessageTally time: [		accesses do: [:i |			cache at: i ifAbsentCache: [:assoc | misses_misses+1]]].	total _ accesses size.	hitRate _ 1- (misses/total).	{size. (hitRate roundTo: 1/1000) asFloat. (cache size/range roundTo: 1/1000) asFloat.	(hitRate / (cache size/range) roundTo: 1/1000) asFloat. time}] "! !!MethodReference methodsFor: 'printing' stamp: 'hg 9/2/2001 22:18'!moduleExplorerContents 	^Array with: (		ModuleExplorerWrapper 					with: (self actualClass sourceCodeAt: self methodSelector)					name: ''					model: self)	! !!Module methodsFor: 'changing defined names' stamp: 'hg 10/1/2001 13:11'!moveName: oldName toModule: newModule	| value export |	value _ definedNames at: oldName.	export _ self exportsName: oldName.	self removeName: oldName.	newModule defineName: oldName as: value export: export.	(value respondsTo: #module:) ifTrue: [value module: newModule].	self invalidateCaches ! !!Module methodsFor: 'user interface' stamp: 'hg 9/2/2001 19:58'!explore	^ModuleExplorer new openExplorerFor: self! !!Module methodsFor: 'user interface' stamp: 'hg 9/25/2001 16:18'!moduleExplorerContents	| list |	list _ OrderedCollection new.	list add: 			(ModuleExplorerWrapper 				with: self neighborModuleRefs				name: 'neighbor modules'				model: self);		add: 			(ModuleExplorerWrapper 				with: self definedNames				name: 'defined names'				model: self);		add: 			(ModuleExplorerWrapper 				with: self exportedNames				name: 'exported names'				model: self).	repository ifNotNil: [		list add: 			(ModuleExplorerWrapper 				with: self repository				name: 'repository'				model: self)].	self annotations associationsDo: [:assoc |		list _ list copyWith: 			(ModuleExplorerWrapper 					with: assoc value					name: assoc key					model: assoc)].	^list			! !!Module methodsFor: 'code analysis' stamp: 'hg 10/3/2001 19:42'!deepIncomingRefsFromOutside: module 	"(Module fromPath: #(EToy Experimental)) localUniqueMessagesToOutside: (Module fromPath: #(EToy))"	| refs insideModules n total |	refs _ IdentityDictionary new.	insideModules _ IdentitySet new.	module deepSubmodulesDo: [:mod | 		insideModules add: mod].	self deepSubmodulesDo: [:mod | 		mod definedNames keysDo: [:key | refs at: key put: Set new]].	total _ 0.	self class root deepClassesDo: [:cl | total _ total + 1].	'Locating outside references to global definitions ...'		displayProgressAt: Sensor cursorPoint		from: 0 to: total		during:		[:bar | n _ 0.			self class root deepClassesDo: [:cl | 				bar value: (n_ n+1).				(insideModules includes: cl module) ifFalse: [					cl selectorsAndMethodsDo: [:sel :cm | 						cm literals do: [:lit | 							(lit respondsTo: #key) ifTrue: [ 								refs at: lit key ifPresent: [:set |									set  add: (MethodReference new									setStandardClass: cl 									methodSymbol: sel)]]]]]]].	refs copy keysAndValuesDo:  [:key :value | 		value isEmpty ifTrue: [refs removeKey: key]].	^refs! !!Module methodsFor: 'code analysis' stamp: 'hg 9/7/2001 18:00'!deepUniqueMessagesToOutside: module 	"all methods on the outside that are only reached by sends from within this Module"	"(Module fromPath: #(EToy Experimental)) localUniqueMessagesToOutside: (Module fromPath: #(EToy))"	| refs insideModules n selectors total all foreign |	refs _ IdentityDictionary new.	selectors _ IdentitySet new.	insideModules _ IdentitySet new.	module deepSubmodulesDo: [:mod | insideModules add: mod].	total _ 0.	self class root deepClassesDo: [:cl | total _ total + 1].	self deepClassesDo: [:cl | 		cl methodDict keysAndValuesDo: [:sel :cm | 			cm messages do: [:lit | selectors add: lit]]].	'Locating foreign methods ...'		displayProgressAt: Sensor cursorPoint		from: 0 to: total		during:		[:bar | n _ 0.			self class root deepClassesDo: [:cl | 				bar value: (n_ n+1).				(insideModules includes: cl module) ifFalse: [					cl methodDict keysAndValuesDo: [:s :cm | 						cm messages do: [:selector | 							selectors remove: selector ifAbsent: []]]]]].	selectors do: [:sel |		all _ Smalltalk allImplementorsOf: sel.		foreign _ all reject: [:mref | insideModules includes: mref actualClass module].		foreign isEmpty ifFalse: [refs at: sel put: foreign]].	^refs! !!Module methodsFor: 'code analysis' stamp: 'hg 9/24/2001 22:47'!deepUnresolvedRefs  	| list n total localList |	total _ 0.	self deepSubmodulesDo: [:mod | total _ total + 1].	list _ OrderedCollection new.	self resetOutOfScopeCache.	'Locating methods with unresolved global references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: total		during:		[:bar | n _ 0.		self deepSubmodulesBottomUpDo: [:mod | 			bar value: (n_ n+1).			localList _ mod localUnresolvedRefs.			list addAll: localList.			mod setUnresolvedCount: localList size.]].	self zeroOutOfScopeCache.	^list asSortedCollection! !!Module methodsFor: 'code analysis' stamp: 'hg 9/3/2001 14:14'!localIncomingRefsFromOutside: module 	"all references from outside to globals defined in this Module"	"(Module fromPath: #(EToy Experimental)) localIncomingRefsFromOutside: (Module fromPath: #(EToy))"	| refs all foreign insideModules |	refs _ IdentityDictionary new.	insideModules _ IdentitySet new.	module deepSubmodulesDo: [:mod | insideModules add: mod].		self definedNames associationsDo: [:assoc |		all _ Smalltalk allCallsOn: assoc.		foreign _ all select: [:mref | 			(insideModules includes: mref actualClass module) not].		refs at: assoc key put: foreign].	^refs! !!Module methodsFor: 'code analysis' stamp: 'hg 9/24/2001 22:36'!localUnresolvedRefs  	"all unresolved global references from code in this Module"	"(Module fromPath: #(Morphic)) localUnresolvedRefs"	| lits list allClasses found |	list _ OrderedCollection new.	allClasses _ OrderedCollection new.	self allClassesDo: [:cls | allClasses addLast: cls; addLast: cls class].		allClasses do: [:cl | 		cl methodDict keysAndValuesDo: [:sel :cm | 			lits _ cm literals.			found _  lits detect:				[:lit | lit isVariableBinding and: [(lit value == cl or: [						self scopedLookup: lit key inClass: cl cachedIn: OutOfScopeCache]) not]]				ifNone: [nil].			found ifNotNil: [				list add: (					MethodReference new						setStandardClass: cl 						methodSymbol: sel)]			]].	^list! !!Module methodsFor: 'code analysis' stamp: 'hg 9/24/2001 23:00'!resetOutOfScopeCache	"empirically estimated wrt declareExternalRefs"	OutOfScopeCache _ IdentityDictionary new: 500. ! !!Module methodsFor: 'code analysis' stamp: 'hg 9/24/2001 22:34'!scopedLookup: aSymbol inClass: cl cachedIn: cache	"for efficiency, cache scope lookups here" 	| assoc |	assoc _ cache at: aSymbol ifAbsentCache: [:cachedAssoc |		Preferences strongModules 			ifTrue: [cl strongScopeHas: aSymbol ifTrue: [:ass | assoc _ ass]] 			ifFalse: [cl weakScopeHas: aSymbol ifTrue: [:ass | assoc _ ass]].		assoc ifNotNil: [cachedAssoc value: assoc value]].	^assoc notNil! !!Module methodsFor: 'code analysis' stamp: 'hg 9/24/2001 18:40'!setUnresolvedCount: localCount	| subCounts |	subCounts _ 0.	self annotationAt: #localUnresolved put: localCount.	self submodulesDo: [:mod | 		subCounts _ subCounts + 			(mod annotationAt: #deepUnresolved ifAbsent: [0])].	self annotationAt: #deepUnresolved put: subCounts + localCount.! !!Module methodsFor: 'code analysis' stamp: 'hg 9/10/2001 12:27'!viewDeepUnresolvedRefs  	"Root viewDeepUnresolvedRefs"	SystemDictionary new 		browseMessageList: self deepUnresolvedRefs		name: 'Unresolved Global References from ', self pathAsMessages 		autoSelect: nil! !!Module methodsFor: 'code analysis' stamp: 'hg 9/24/2001 22:45'!zeroOutOfScopeCache	"empirically, sizes above 100 yield diminishing speed gains for declareExternalRefs"	OutOfScopeCache _ nil. ! !!Module methodsFor: 'system conversion' stamp: 'hg 10/10/2001 15:08'!collectUpstreamMethodsOutside: homeModule	"find all methods in all systemwide classes outside homeModule that contain references to names defined by this module, then add to this module DeltaModules with classes referring to those methods. This does not at all affect the actual classes or methods."	| incoming deltaModule deltaClass method n |	incoming _ self deepIncomingRefsFromOutside: homeModule.	Smalltalk newChanges: (ChangeSet basicNewNamed: self name, 'Reorganization', Time now printString).	ChangeSorter initialize.	'Collecting upstream definitions ...'		displayProgressAt: Sensor cursorPoint		from: 0 to: incoming size		during:		[:bar | n _ 0.		incoming keysAndValuesDo:  [:key	:upstreamMethodRefs |			bar value: (n _ n + 1).			upstreamMethodRefs do: [:mref |				deltaModule _ self deltaModuleForBase: mref actualClass module								forceCreate: true asActive: true.				deltaClass _ deltaModule deltaClassFor: mref actualClass forceCreate: true.				method _ mref actualClass compiledMethodAt: mref methodSymbol.				deltaModule 					defineSelector: mref methodSymbol 					asMethod: method 					previousVersion: nil 					inClass: deltaClass]]].		^incoming! !!Module methodsFor: 'system conversion' stamp: 'hg 9/24/2001 22:46'!declareExternalRefs   	"Root declareExternalRefs"	"For all classes in this module, identify all references to unresolved globals.	For each of these, call another method to declare the global's defining module."	| n refsList |	refsList _ self deepUnresolvedRefs.	self resetOutOfScopeCache.	'Declaring all external references in source code...'		displayProgressAt: Sensor cursorPoint		from: 0 to: refsList size		during:		[:bar | n _ 0.		refsList do:			[:ref | bar value: (n_ n+1).			ref actualClass module declareExternalRefsForSelector: ref methodSymbol inClass: ref actualClass]].	self zeroOutOfScopeCache.	^refsList size! !!Module methodsFor: 'system conversion' stamp: 'hg 9/24/2001 22:34'!declareExternalRefsForSelector: selector inClass: aClass	"for all unresolved globals in the method of the given selector and class, declare the global's defining module as one of my external modules"	| varName definingModule cm lits |	cm _ aClass compiledMethodAt: selector.	lits _ cm literals.	lits do: [:lit | 		lit isVariableBinding ifTrue: [			varName _ lit key.			(lit value == aClass or: [self scopedLookup: varName inClass: aClass cachedIn: OutOfScopeCache]) ifFalse: [				definingModule _ Module root moduleDefining: varName.				definingModule ifNotNil: [					"ensure that defining module exports it"					"definingModule exportName: varName."					self ensureExternalModule: definingModule]]]]! !!Module methodsFor: 'system conversion' stamp: 'hg 9/25/2001 17:56'!importIntoParent	(self parentModule refForNeighborModule: self)		importNames: true.! !!Module methodsFor: 'system conversion' stamp: 'hg 10/2/2001 21:13'!rewriteIndirectRefs   	"Root rewriteIndirectRefs"	"For all classes, identify all methods with references to globals outside their direct access path.	For each of these, call another method to rewrite the source with proper references."	| n refsList |	"Allow compiler to compile refs to globals out of the direct reference path"	Preferences strongModules ifTrue: [		Preferences enable: #lenientScopeForGlobals].	refsList _ self deepIndirectRefs.	self resetOutOfScopeCache.	'Updating indirect global references in source code...'		displayProgressAt: Sensor cursorPoint		from: 0 to: refsList size		during:		[:bar | n _ 0.		refsList do:			[:ref | bar value: (n_ n+1).			self rewriteSourceForSelector: ref methodSymbol inClass: ref actualClass]].	self zeroOutOfScopeCache.	Preferences strongModules ifTrue: [		Preferences disable: #lenientScopeForGlobals].! !!Module methodsFor: 'system conversion' stamp: 'hg 9/24/2001 22:36'!rewriteSourceForSelector: selector inClass: aClass	"Rewrite the source code for the method in question so that all out-of-scope references are converted to explicit references to the defining module (which is added as an import of this module). This is done by parsing the source with a lenient parser able to find variables in any module.  Then the parse tree is consulted for the source code ranges of each reference that needs to be rewritten and the pattern to which it should be rewritten.  Note that assignments, which will take the form	envt setValueOf: #GlobalName to: ...may generate spurious message due to agglutination of keywords with the value expression."	| code methodNode edits varName definingModule |	code _ aClass sourceCodeAt: selector.	methodNode _ Compiler new parse: code in: aClass notifying: nil.	edits _ OrderedCollection new.	methodNode encoder globalSourceRanges do:		[:tuple |   "{ varName. srcRange. store }"		(aClass scopeHas: (varName _ tuple first asSymbol) ifTrue: [:ignored]) ifFalse:			["This is a remote global.  Add it as reference to be edited."			edits addLast: { varName. tuple at: 2. tuple at: 3 }]].	"Sort the edits by source position."	edits _ edits asSortedCollection: [:a :b | a second first < b second first].	edits reverseDo: [:edit | 		varName _ edit first.		"if name isn't defined in this module"		(self scopedLookup: varName inClass: aClass cachedIn: OutOfScopeCache) ifFalse: [			"look in all modules in the system"			definingModule _ Module root moduleDefining: varName.			definingModule ifNotNil: [				"ensure that defining module exports it"				definingModule exportName: varName.				self ensureExternalModule: definingModule. 				"Replace access out of scope with a full-path remote reference"				code _ code copyReplaceFrom: edit second first							to: edit second last							with: definingModule pathAsMessages, ' ' , varName]]].	aClass compile: code classified: (aClass organization categoryOfElement: selector)! !!Module class methodsFor: 'virtual hierarchy' stamp: 'hg 9/10/2001 18:34'!moduleForCategory: catString forceCreate: create	"Return the module corresponding to the given system category"	| mod |	mod _ Module fromPath: (self pathFromCategory: catString) forceCreate: create.	mod ifNil: [self error: 'No module for category ', catString].	^ mod! !!Module class methodsFor: 'virtual hierarchy' stamp: 'hg 9/29/2001 22:28'!pathFromCategory: catString	"Module pathFromCategory:'Morphic-Demo'"	"Convert a category name into a module path, taking dashes and spaces as level separators.	 Put it under top-level module Squeak"	| categoryPath alphaNumeric isSqueakModule |	(catString includes: $ ) ifTrue: [		PopUpMenu confirm: 'Bad category name: ''', catString, '''. Module names should be proper symbols. OK to strip non-alphanumerical characters?' orCancel: [self halt]].	alphaNumeric _ catString select: [:c | c isAlphaNumeric | (c = $-)].	categoryPath _ (alphaNumeric findTokens: '- ') collect: [:str | str capitalized asSymbol].	isSqueakModule _ 		Module squeak submodules anySatisfy: [:mod | 			mod name = categoryPath first].	^isSqueakModule		ifTrue: [self squeak path , categoryPath]		ifFalse: [categoryPath]! !!Module class methodsFor: 'system conversion' stamp: 'hg 9/10/2001 18:01'!aRefactorer	^ModuleRefactorer new! !!Module class methodsFor: 'system conversion' stamp: 'hg 10/3/2001 23:04'!convertSystemOrganizationToModules	"Module convertSystemOrganizationToModules."	Preferences strongModules ifTrue: [		^PopUpMenu inform:'It is not recommended that you convert the system while the strongModules preference is true. Change it to false and then run this method again.'].	"Fix non-conforming system category names"	self fixProperCategoryNames.	self resetWeakModules.		self createTopLevels.	"The version of the overall hierarchy structure (top level modules)"	Module root version: 0.1.		self modulesFromSystemCategories.		Module smalltalk moveOutOfTheWay.		ModularSystemOrganizer install.	Preferences enable: #lenientScopeForGlobals.	Preferences enable: #browserShowsPackagePane.! !!Module class methodsFor: 'system conversion' stamp: 'hg 9/7/2001 17:58'!createTopLevels	self generateSubmodules: Module topLevelModuleList for: self root! !!Module class methodsFor: 'system conversion' stamp: 'hg 9/10/2001 18:16'!fixProperCategoryNames	"make category names suitable for conversion to hierarchical modules	 remove spaces from specified list, the replace all spaces with dashes '-'"		| pairs |	pairs _ self properCategoryNames.	pairs pairsDo: [:oldName :properName |		SystemOrganization renameCategory: oldName toBe: properName].	SystemOrganization categories do: [:cat |		SystemOrganization 			renameCategory: cat 			toBe: (cat copyReplaceAll: ' ' with: '-' asTokens: false)].! !!Module class methodsFor: 'system conversion' stamp: 'hg 10/9/2001 12:33'!generateSubmodules: moduleList for: mod	"a utility method, see Module>>topLevelModuleList"	| modName submods submod |	moduleList do: [:item |		item class == Array			ifFalse: [modName _ item. submods _ #()]			ifTrue: [modName _ item first. submods _ item second].		mod localAssocFor: modName ifAbsent: [			mod addSubmoduleNamed: modName importNames: false].		submod _ mod definitionFor: modName ifAbsent: [self error: 'module not found'].		self generateSubmodules: submods for: submod].! !!Module class methodsFor: 'system conversion' stamp: 'hg 10/3/2001 23:05'!modulesFromSystemCategories	"this is run before dropping the old-style SystemOrganization"	| mod refactorer |	Module squeak version: 0.0.	"This creates version zero of the class library organization"	Module smalltalk allClassesDo: [:cl | cl module: Module smalltalk].	refactorer _ self aRefactorer.	SystemOrganization categories do:		[:cat | 			mod _ Module moduleForCategory: 'Squeak-', cat forceCreate: true.			refactorer				transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)				from: Module smalltalk to: mod.		].		Module root deepSubmodulesDo: [:m |		m == Module smalltalk ifFalse: [			m allClassesDo: [:cl | cl module == m ifFalse: [				self error: 'Module of class not properly set. Probably the problem is that Class>>module: and Class>>module need to be recompiled before running this method.']]]].! !!Module class methodsFor: 'system conversion' stamp: 'hg 9/10/2001 18:05'!properCategoryNames	"Consider dashes ('-') and spaces to separate hierarchical levels in category names.	Thus here remove all spaces from the insides of level names"	^#(		'Kernel-ST80 Remnants' 'Kernel-ST80Remnants'		'Graphics-Display Objects' 'Graphics-DisplayObjects'		'Speech-Phoneme Recognizer' 'Speech-PhonemeRecognizer'		'Tools-File Contents Browser' 'Tools-FileContentsBrowser'		'Tools-Process Browser' 'Tools-ProcessBrowser'		'System-Digital Signatures' 'System-DigitalSignatures'		'System-Object Storage' 'System-ObjectStorage'		'System-Serial Port' 'System-SerialPort'		'Network-EToy Communications' 'Network-EToyCommunications'		'Network-TelNet WordNet' 'Network-TelNetWordNet'		'Network-Web Browser' 'Network-WebBrowser'		'Network-Mail Reader' 'Network-MailReader'		'Network-IRC Chat' 'Network-IRCChat'		'Network-Audio Chat' 'Network-AudioChat'		'Network-Pluggable Web Server' 'Network-PluggableWebServer'		'VMConstruction-Translation to C' 'VMConstruction-TranslationToC'		'ST80-Pluggable Views' 'ST80-PluggableViews'		'Morphic-Text Support' 'Morphic-TextSupport'		'Morphic-Tile Scriptors' 'Morphic-TileScriptors'		'Balloon3D-Demo Morphs' 'Balloon3D-DemoMorphs')! !!Module class methodsFor: 'system conversion' stamp: 'hg 9/10/2001 23:59'!topLevelModuleList	"return a list of names for the top level modules of the virtual hierarchy.	 Items are either symbols or pairs of a symbol and a list of subitems.	 Note that the hierarchy at the same time organizes modules inside the image,	 organizes the contributions of the Squeak community wrt each other,	 and provides a structure for repository storage of modules.	 E.g. providing its path should be enough for downloading and installing any package."	^#(		(Squeak			"For official system frameworks. Everything in the old image under here."			 ("MVC Morphic etc"))		(Project 		"A place to reserve unique names for various projects."			("e.g. Whisker"))		(Org ()) (Com ()) "For organizations to reserve name spaces in"		(People ())		"Allow for personal prefs & configuration stored on the net.			 		 use people's method signature initials for names here"		(Image 			"For holding various images and their configurations"			(StandardRelease "SWT Headless PDA Squeakland etc"))		(VM			"Compiled VMs and VM-related (platform-specific) sources"			("Mac Windows Acorn Unix Cocoa etc"))		(Temporary	())	"For throwaway modules, sandbox modules, etc., 						may be held weakly or emptied e.g. on shutdown."	)! !!ModuleExplorer methodsFor: 'as yet unclassified' stamp: 'hg 9/7/2001 12:54'!doItReceiver	| selectedObject |	currentSelection ifNil: [^rootObject].	selectedObject _ currentSelection withoutListWrapper.	^(selectedObject isKindOf: ModuleReference)		ifTrue: [selectedObject module]		ifFalse: [selectedObject]! !!ModuleExplorer methodsFor: 'as yet unclassified' stamp: 'hg 9/2/2001 19:57'!getList	^Array with: (ModuleExplorerWrapper with: rootObject name: 'top' model: self)! !!ModuleExplorer methodsFor: 'as yet unclassified' stamp: 'hg 10/1/2001 15:23'!trash	"some example expressions to try"	^'NOTE: You may close this window at any time.<Module root explore> will get a new one"try these on some modules (cmd-p / cmd-I)..."self deepDeclareExternalRefs.self viewDeepUnresolvedRefs. self pathself deepIncomingRefsFromOutside: self self deepIncomingRefsFromOutside: parentModuleself deepUniqueMessagesToOutside: selfself defineClassExtensionsOutside: selfself repository beStandalone  self repository directory urlself repository repositoryToUse ensureDeepUploadModuleInstaller fullyInstallFromPath: #(Temporary TestModule)ModuleInstaller unload: selfRepository importChangesFromFileNamed: ''sample.cs'' intoModuleAt:  #(Temporary TestModule)'! !!ModuleExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'hg 9/2/2001 19:43'!contents		^(item respondsTo: #moduleExplorerContents)		ifTrue: [item moduleExplorerContents]		ifFalse: [super contents]! !!ModuleRefactorer methodsFor: 'versions' stamp: 'hg 10/1/2001 15:10'!ensurePrerequisiteVersions	"simple default: just increment the version for #(Squeak), ie. the version of the Squeak standard class library"		Module squeak version = self fromVersion ifFalse: [		self error: 'These refactorings should only be applied to version ', self fromVersion , ' of the Squeak modules'].! !!ModuleRefactorer methodsFor: 'versions' stamp: 'hg 9/28/2001 15:12'!fromVersion	"return the version of the Squeak hierarchy to start with"	self subclassResponsibility ! !!ModuleRefactorer methodsFor: 'versions' stamp: 'hg 10/1/2001 15:15'!incrementVersions	"simple default: minimally increment the version for #(Squeak), ie. the version of the Squeak standard class library"		self toVersion		ifNil: [Module squeak incrementVersion]		ifNotNil: [Module squeak version: self toVersion]! !!ModuleRefactorer methodsFor: 'versions' stamp: 'hg 10/1/2001 15:13'!toVersion	"return the resulting number of the resulting Squeak hierarchy, if nil then make minimal increase"	^nil! !!ModuleRefactorer methodsFor: 'test setup' stamp: 'hg 9/10/2001 15:49'!createTopLevels	self generateSubmodules: Module topLevelModuleList for: self root! !!ModuleRefactorer methodsFor: 'public' stamp: 'hg 10/8/2001 16:58'!runRefactorings	"Trigger the whole set of refactorings in this class."	Preferences strongModules ifTrue: [		Module smalltalk newChanges: 			(ChangeSet basicNewNamed: self class name, ' Reorganization')].	self ensurePrerequisiteVersions.	self moveModules; reorderModules.	self moveGlobalsToModules.	self installModuleDeclarations.	self refactorClasses.	self convertPools.	self removeModules.	self installRepositories.		self incrementVersions.		Preferences strongModules 		ifTrue: [			Module root rewriteIndirectRefs.			Module smalltalk newChanges: (ChangeSet basicNewNamed: 'PostReorganization').			ChangeSorter initialize]! !!ModuleRefactorer methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:41'!modulesToRemove	"return a list of paths to modules to remove"	^#()! !!ModuleRefactorer methodsFor: 'moving modules' stamp: 'hg 9/25/2001 17:21'!moveModules		| moveList mod ref afterParentPath afterParent |	moveList _ self newPlacesForModules.	moveList pairsDo: [:before :after |		mod _ Module fromPath: before forceCreate: false.		mod ifNotNil: [			ref _ mod parentModule removeNeighborModule: mod.			afterParentPath _ after allButLast.			afterParent _ Module fromPath: afterParentPath forceCreate: true.			afterParent 				submodule: mod name: after last 				version: ref specifiedVersion importNames: ref importNames]].		! !!ModuleRefactorer methodsFor: 'moving modules' stamp: 'hg 10/8/2001 17:27'!removeModules	"remove a list of modules. Note that this is done silently as it is assumed that you know what you are doing :-)"	| removeList mod |	removeList _ self modulesToRemove.	removeList do: [:path |		mod _ Module fromPath: path.		mod parentModule removeNeighborModule: mod].	! !!ModuleRefactorer methodsFor: 'moving modules' stamp: 'hg 10/8/2001 16:59'!reorderModules	"send reordering messages from here"	^self! !!ModuleRefactorer methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 21:44'!modulesForGlobals	"system categories to associate Smalltalk globals with.	Provided here as pairs of GlobalName ModulePath, e.g.		Display 		#(Graphics DisplayObjects)				"		^#()	"default: nothing to move"! !!ModuleRefactorer methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 16:46'!moveGlobalsToModules	"move non-class globals from Smalltalk"		self modulesForGlobals pairsDo: [:globalName :path |		self transferBindingsNamedIn: (Array with: globalName) 			from: Module smalltalk to: Module @ path]! !!ModuleRefactorer methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 21:56'!refactorClasses	"refactor classes by running all my methods with selector 'refactor*Classes'"	| reorgSelectors |	reorgSelectors _ self class selectors select: [:selector | 		(selector beginsWith: 'refactor') and: [selector endsWith: 'Classes']].	reorgSelectors do: [:selector |		self perform: selector]! !!ModuleRefactorer methodsFor: 'external module declarations' stamp: 'hg 9/24/2001 19:29'!clearDeclaredModules	"remove all module declarations everywhere"	"ModuleRefactorer new clearDeclaredModules"	Module root deepSubmodulesDo: [:mod | mod clearDeclaredModules]! !!ModuleRefactorer methodsFor: 'external module declarations' stamp: 'hg 10/11/2001 09:25'!copyDeclarationsFromParent: module	module parentModule ifNotNil: [		module parentModule neighborModuleRefs do: [:ref |			ref refersToExternalModule ifTrue: [				module addNeighborModule: ref export: module shouldExportExternalModules]]]! !!ModuleRefactorer methodsFor: 'external module declarations' stamp: 'hg 9/24/2001 19:32'!declarationsByDefault: mod	self copyDeclarationsFromParent: mod.	mod path size > 2 ifTrue: [mod importIntoParent].! !!ModuleRefactorer methodsFor: 'external module declarations' stamp: 'hg 10/3/2001 20:38'!installModuleDeclarations	"do nothing by default"! !!ModuleRefactorer methodsFor: 'external module declarations' stamp: 'hg 10/3/2001 20:38'!installModuleDeclarationsFromMethods	| installSelector name |	Module root deepSubmodulesDo: [:mod |		name _ mod longName.		installSelector _ ('declarationsFor', name, ':') asSymbol.		(self respondsTo: installSelector) 			ifFalse: [installSelector _ #declarationsByDefault:].		self perform: installSelector with: mod]! !!ModuleRefactorer methodsFor: 'converting pools' stamp: 'hg 10/31/2001 14:51'!convertPoolNamed: poolName inModule: homePath toPoolModule: poolModuleName	"pool dictionaries are now redundant, as modules can be used to collect shared variables. Change current pools to modules"	| poolModule users homeModule poolDictionary |	homeModule _ Module fromPath: homePath forceCreate: true.	poolDictionary _ homeModule definitionFor: poolName ifAbsent: [nil].	homeModule removeName: poolName.	poolModule _ Module fromPath: (homePath copyWith: poolModuleName) forceCreate: true.	"Make pool module name reachable, e.g. TextConstants"	poolModuleName = #Constants ifFalse: [		poolModule parentModule exportName: poolModuleName].	"defeat capitalization check for the Alice pool"	[poolDictionary associationsDo: [:ass |		poolModule defineName: ass key as: ass value export: true].	] on: Warning do: [:ex | ex resume: true].	users _ Set new.	Module root deepClassesDo: [:class | 		(class sharedPools identityIncludes: poolDictionary) ifTrue: [users add: class]].	users do: [:class |		(class module hasNeighborModule: poolModule) ifFalse: [			class module externalModule: poolModule alias: nil version: nil importNames: true].		class privateRemoveSharedPool: poolDictionary].	self testRecompileClasses: users.	"methodRefs _ Smalltalk allCallsOn: (Smalltalk associationAt: k)"! !!ModuleRefactorer methodsFor: 'converting pools' stamp: 'hg 10/8/2001 17:30'!convertPools	"pool dictionaries are now redundant, as modules can be used to collect shared variables. Change current pools to modules"	self newModulesForPools isEmpty ifFalse: [		(Transcript openAsMorphLabel: 'Transcript') openInWorld].   	self newModulesForPools do: [:triplet |		self convertPoolNamed: triplet first inModule: triplet second toPoolModule: triplet third].! !!ModuleRefactorer methodsFor: 'converting pools' stamp: 'hg 9/19/2001 21:03'!newModulesForPools	"For each pool, list pairs of its name the path of the module to convert it to."		^#()! !!ModuleRefactorer methodsFor: 'utilities' stamp: 'hg 9/28/2001 14:36'!installRepositories	VirtualRootRepository initialize! !!ModuleRefactorer methodsFor: 'utilities' stamp: 'hg 9/19/2001 20:57'!testRecompileClass: class	"run thru recompiling all methods of class and subclasses, raising a notification window if compilation fails. useful as a post-change verification"	| total n |	total _ class withAllSubclasses inject: 0 into: [:sum :cl | sum + cl selectors size].	'Testing that all (sub-)methods of ', class name, ' compile ok...'		displayProgressAt: Sensor cursorPoint		from: 0 to: total		during:		[:bar | n _ 0.			class withAllSubclasses do: [:cl |				cl selectors do: [:sel |					n _ n + 1. bar value: n.					cl compilerClass new						compile: (cl sourceCodeAt: sel)						in: cl						notifying: (SyntaxError new category: 'trial recompile failed')						ifFail: []]]]. ! !!ModuleRefactorer methodsFor: 'utilities' stamp: 'hg 9/20/2001 10:08'!testRecompileClasses: classes	"run thru recompiling all methods of classes and subclasses, raising a notification window if compilation fails. useful as a post-change verification"	| n all |	all _ Set newFrom: classes.	classes do: [:class | all addAll: class subclasses].	'Testing pool conversions...'		displayProgressAt: Sensor cursorPoint		from: 0 to: all size		during:		[:bar | n _ 0.			all do: [:class |				n _ n + 1. bar value: n.				class selectors do: [:sel |					class compilerClass new						compile: (class sourceCodeAt: sel)						in: class						notifying: (SyntaxError new category: 'trial recompile failed')						ifFail: []]]]. ! !!ModuleRefactorer methodsFor: 'utilities' stamp: 'hg 10/3/2001 23:27'!transferBindingsNamedIn: nameList from: oldModule to: newModule	| assoc |	nameList do: [:aName |		assoc _ oldModule localAssocFor: aName ifAbsent: [self error: 'name not found'].		"Under weak modules, leave Smalltalk intact"		oldModule = Module smalltalk & Preferences strongModules not			ifFalse: [oldModule removeName: aName]			ifTrue: [oldModule exportedNames removeKey: aName asSymbol ifAbsent: []].		newModule redefineName: assoc key as: assoc value export: true.		(assoc value isKindOf: Class) ifTrue: [assoc value module: newModule]]! !!FromVersion0p0000to0001 methodsFor: 'versions' stamp: 'hg 10/1/2001 15:12'!fromVersion	"start from the auto-converted system categories"	^0.0! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/25/2001 17:58'!declarationsByDefault: mod	mod path size > 2 ifTrue: [mod importIntoParent].		mod parentModule = Module squeak 		ifTrue: [			mod externalModule: (Module fromPath: #(Squeak Kernel)) 				alias: nil version: nil importNames: true.			mod externalModule: (Module fromPath: #(Squeak Collections)) 				alias: nil version: nil importNames: true]		ifFalse: [			self copyDeclarationsFromParent: mod].! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/25/2001 12:45'!declarationsForBalloon3D: mod	self declarationsByDefault: mod.	mod externalModule: (Module fromPath: #(Squeak Graphics)) alias: nil version: nil importNames: true.! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/25/2001 12:45'!declarationsForBalloon: mod	self declarationsByDefault: mod.	mod externalModule: (Module fromPath: #(Squeak Graphics)) alias: nil version: nil importNames: true.! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/25/2001 12:45'!declarationsForCollections: mod	mod externalModule: (Module fromPath: #(Squeak Kernel)) alias: nil version: nil importNames: true.! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/10/2001 16:10'!declarationsForKernel: module	^self	"no default declarations"! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/25/2001 12:45'!declarationsForMorphicEssenceKernel: mod	self declarationsByDefault: mod.	mod externalModule: (Module fromPath: #(Squeak Graphics)) alias: nil version: nil importNames: true.	! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/24/2001 19:36'!declarationsForRoot: mod	"these will be copied down to all children who want them"		^self! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 9/25/2001 17:55'!declarationsForSqueak: mod	"these will be copied down to all children who want them"		^self! !!FromVersion0p0000to0001 methodsFor: 'external module declarations' stamp: 'hg 10/3/2001 20:39'!installModuleDeclarations	self clearDeclaredModules.	self installModuleDeclarationsFromMethods ! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:41'!modulesToRemove	"return a list of paths to modules to remove"	^#(	"	#(Squeak ST80)"	)! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:24'!newPlacesForEToyModules	"For each module, list pairs of its path before and after moving it."	"The intention is that Morphic eventually should be strippable to a small core.	 This is a rough first attempt at separating eToy from Morphic,	 and more thought will need to go into how Morphic should be reorganized. 	 Ideally eToy should be broken out by the people who developed it 	 and who therefore understand its structure."		^#(		(Squeak Morphic Experimental) (Squeak EToy Experimental)		(Squeak Morphic UserObjects) (Squeak EToy UserObjects)		(Squeak Morphic GeeMail) (Squeak EToy GeeMail)		(Squeak Morphic TileScriptors) (Squeak EToy TileScriptors)		(Squeak Morphic Stacks) (Squeak EToy Stacks)		(Squeak Morphic Navigators) (Squeak EToy Navigators)		(Squeak Morphic Outliner) (Squeak EToy Outliner)		(Squeak Morphic Imported) (Squeak EToy Imported)		(Squeak Morphic Buttons) (Squeak EToy Buttons)		(Squeak Morphic PartsBin) (Squeak EToy PartsBin)		(Squeak Morphic Remote) (Squeak EToy Remote)		(Squeak Morphic Flaps) (Squeak EToy Flaps)		(Squeak Morphic Collaborative) (Squeak EToy Collaborative)		(Squeak Morphic Scripting) (Squeak EToy Scripting)		"Note that the whole tree is moved at once. These have already been moved:		  (Squeak Morphic Scripting Support) (Squeak EToy Scripting Support)		  (Squeak Morphic Scripting Tiles) (Squeak EToy Scripting Tiles)"	)! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 23:11'!newPlacesForMVC	"For each module, here are pairs of its path before and after moving it."	"This is unfinished"	^#(		(Squeak ST80) (Squeak MVC)		(Squeak Kernel ST80Remnants) (Squeak MVC FromKernel)		(Squeak Tools Menus) (Squeak MVC Menus)	)! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/30/2001 15:17'!newPlacesForModules	"For each module, list pairs of its path before and after moving it."		^#(	"This is just a very sketchy beginning, much more needs to be done."	) ,	self newPlacesForMVC,	self newPlacesForMorphicKernel,	self newPlacesForMorphicLibrary,	self newPlacesForMorphicApplications,	self newPlacesForMorphicDemo,	self newPlacesForEToyModules,	(Array with: Module smalltalk path with: (Module root path copyWith: #InterimSmalltalk)).! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:25'!newPlacesForMorphicApplications	"For each module, here are pairs of its path before and after moving it."	"The intention is that Morphic eventually should be strippable to a small core.	 More thought will need to go into how Morphic should be reorganized. 	 "		^#(		(Squeak Morphic Books) (Squeak Morphic Applications Books)		(Squeak Morphic PDA) (Squeak Morphic Applications PDA)		(Squeak Morphic Media) (Squeak Morphic Applications Media)	)! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:26'!newPlacesForMorphicDemo	"For each module, here are pairs of its path before and after moving it."	"The intention is that Morphic eventually should be strippable to a small core.	 More thought will need to go into how Morphic should be reorganized. 	 "		^#(		(Squeak Morphic Components) (Squeak Morphic Demo Components)		(Squeak Morphic Games) (Squeak Morphic Demo Games)	)! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:28'!newPlacesForMorphicKernel	"For each such module, here are pairs of its path before and after moving it."	"The intention is that Morphic eventually should be strippable to a small core.	 More thought will need to go into how Morphic should be reorganized. 	 "		^#(		(Squeak Morphic Kernel) (Squeak Morphic Core Foundation)		(Squeak Morphic Basic) (Squeak Morphic Core Basic)		(Squeak Morphic Worlds) (Squeak Morphic Core Worlds)		(Squeak Morphic Support) (Squeak Morphic Core Support)		(Squeak Morphic TextSupport) (Squeak Morphic Core TextSupport)		(Squeak Morphic Events) (Squeak Morphic Core Events)		(Squeak Morphic Layouts) (Squeak Morphic Core Layouts)		(Squeak Morphic Undo) (Squeak Morphic Core Undo)	)! !!FromVersion0p0000to0001 methodsFor: 'moving modules' stamp: 'hg 9/10/2001 21:30'!newPlacesForMorphicLibrary	"For each module, here are pairs of its path before and after moving it."	"The intention is that Morphic eventually should be strippable to a small core.	 More thought will need to go into how Morphic should be reorganized. 	 "		^#(		(Squeak Morphic Widgets) (Squeak Morphic Library Widgets)		(Squeak Morphic Models) (Squeak Morphic Library Models)		(Squeak Morphic Windows) (Squeak Morphic Library Windows)		(Squeak Morphic Menus) (Squeak Morphic Library Menus)		(Squeak Morphic Palettes) (Squeak Morphic Library Palettes)		(Squeak Morphic Postscript) (Squeak Morphic Library PostScript)		(Squeak Genie) (Squeak Morphic Library Genie)	)! !!FromVersion0p0000to0001 methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 23:18'!modulesForGlobals	"modules to move Smalltalk globals to"		^#(		ActiveEvent	#(Squeak Morphic Core Events)		ActiveHand	#(Squeak Morphic Core Foundation)		ActiveWorld	#(Squeak Morphic Core Foundation)		AliceConstants	#(Squeak Balloon3D Alice Cast)		B3DEngineConstants	#(Squeak Balloon3D Engine)		BalloonEngineConstants	#(Squeak Balloon Engine)		Display	#(Squeak Graphics DisplayObjects)		EventSensorConstants	#(Squeak Kernel Processes)		FFIConstants	#(Squeak FFI Kernel)		GZipConstants	#(Squeak System Compression)		ImageImports	#(Squeak EToy Scripting)		KlattResonatorIndices	#(Squeak Speech Klatt)		Processor	#(Squeak Kernel Processes)		References	#(Squeak EToy Scripting)		ScheduledControllers	#(Squeak MVC FromKernel)		ScriptingSystem	#(Squeak EToy Scripting)		Sensor	#(Squeak Kernel Processes)		SourceFiles	#(Squeak System Files)		SystemOrganization	#(Squeak Kernel Classes)		TextConstants	#(Squeak Collections Text)		Transcript	#(Squeak Collections Streams)		Undeclared	#(Squeak System Modules)		WonderlandConstants	#(Squeak Balloon3D Wonderland Core)		World	#(Squeak Morphic Core Foundation)		ZipFileConstants	#(Squeak System Compression)		ZipConstants	#(Squeak System Compression)	)! !!FromVersion0p0000to0001 methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 21:57'!refactorGraphicsClasses	"this one is merely just started"	self transferBindingsNamedIn: #(TextPrinter TextLineInterval ) 		from: Module @ #(Squeak Graphics Text) to: Module @ #(Squeak MVC Support)! !!FromVersion0p0000to0001 methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 21:58'!refactorMVCClasses	self transferBindingsNamedIn: #(OneOnSwitch Button Switch) 		from: Module @ #(Squeak MVC Menus) to: Module @ #(Squeak MVC Editors)		! !!FromVersion0p0000to0001 methodsFor: 'moving definitions' stamp: 'hg 9/10/2001 21:59'!refactorMorphicClasses	"self transferBindingsNamedIn: #(NewParagraph TextLine) 		from: Module @ #(Squeak Morphic Core TextSupport) to: Module @ #(Squeak Graphics Text)"! !!FromVersion0p0000to0001 methodsFor: 'converting pools' stamp: 'hg 9/20/2001 15:24'!newModulesForPools	"For each pool, list triplets of its name, home module and name of pool module."		^#(			(AliceConstants (Squeak Balloon3D Alice Cast) Constants)		(B3DEngineConstants (Squeak Balloon3D Engine) Constants)		(BalloonEngineConstants (Squeak Balloon Engine) Constants)		(EventSensorConstants (Squeak Kernel Processes) EventSensorConstants)		(FFIConstants (Squeak FFI Kernel) Constants)		(GZipConstants	(Squeak System Compression) GZipConstants)		(KlattResonatorIndices	(Squeak Speech Klatt) ResonatorIndices)		(TextConstants	(Squeak Collections Text) TextConstants)		(WonderlandConstants	(Squeak Balloon3D Wonderland Core) Constants)		(ZipFileConstants	(Squeak System Compression) ZipFileConstants)		(ZipConstants	(Squeak System Compression) ZipConstants)	)! !!FromVersion0p0000to0001 methodsFor: 'utilities' stamp: 'hg 9/28/2001 14:51'!installRepositories	VirtualRootRepository initialize.	"Make sure that top-level modules get their own standalone repositories."	Module root submodulesDo: [:mod | Repository standaloneOn: mod].	Module squeak submodulesDo: [:mod | Repository standaloneOn: mod].	Module @ #(Squeak Morphic) 		submodulesDo: [:mod | Repository standaloneOn: mod].! !!ModuleRefactorer class methodsFor: 'public' stamp: 'hg 9/10/2001 23:17'!run	"Trigger the whole set of refactorings in this class."	self new runRefactorings! !!ModuleReference methodsFor: 'printing' stamp: 'hg 9/25/2001 12:21'!explorerContents	^self module moduleExplorerContents ! !!TransitionalSmalltalkModule methodsFor: 'system conversion' stamp: 'hg 10/8/2001 17:04'!moveOutOfTheWay	"ensure that I am the last module to be scanned for names"	| currentLast |	currentLast _ Module root neighborModuleRefs last.	currentLast = self ifTrue: [^self].	Module root 		moveModule: self 		toAfter: Module root neighborModuleRefs last module.! !!FromVersion0p0000to0001 reorganize!('public')('versions' fromVersion)('external module declarations' declarationsByDefault: declarationsForBalloon3D: declarationsForBalloon: declarationsForCollections: declarationsForKernel: declarationsForMorphicEssenceKernel: declarationsForRoot: declarationsForSqueak: installModuleDeclarations)('moving modules' modulesToRemove newPlacesForEToyModules newPlacesForMVC newPlacesForModules newPlacesForMorphicApplications newPlacesForMorphicDemo newPlacesForMorphicKernel newPlacesForMorphicLibrary)('moving definitions' modulesForGlobals refactorGraphicsClasses refactorMVCClasses refactorMorphicClasses)('converting pools' newModulesForPools)('utilities' installRepositories)!!ModuleRefactorer reorganize!('versions' ensurePrerequisiteVersions fromVersion incrementVersions toVersion)('test setup' createTopLevels)('public' runRefactorings)('moving modules' modulesToRemove moveModules removeModules reorderModules)('moving definitions' modulesForGlobals moveGlobalsToModules refactorClasses)('external module declarations' clearDeclaredModules copyDeclarationsFromParent: declarationsByDefault: installModuleDeclarations installModuleDeclarationsFromMethods)('converting pools' convertPoolNamed:inModule:toPoolModule: convertPools newModulesForPools)('utilities' installRepositories testRecompileClass: testRecompileClasses: transferBindingsNamedIn:from:to:)!!Module class reorganize!('instance creation' new)('class initialization' createModularClassDefinitionsPreference createStrongModulesPreference initialize resetWeakModules)('virtual hierarchy' @ fromPath: fromPath:forceCreate: moduleForCategory:forceCreate: pathFromCategory: root smalltalk squeak)('fileIn/Out' metaPrerequisites)('system conversion' aRefactorer convertSystemOrganizationToModules createTopLevels fixProperCategoryNames generateSubmodules:for: modulesFromSystemCategories properCategoryNames topLevelModuleList)('pool conversion')!"Postscript:Open a ModuleExplorer."Module root explore!