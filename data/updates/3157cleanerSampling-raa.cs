'From Squeak2.9alpha of 17 July 2000 [latest update: #3215] on 2 January 2001 at 3:46:30 pm'!"Change Set:		cleanerSamplingDate:			30 December 2000Author:			Bob Arning- a little cleaner version of my previous submission- substituted GSM for ADPCM in the EventRecorderMorph for hgher compression."!!EventRecorderMorph methodsFor: 'initialization' stamp: 'RAA 1/2/2001 10:35'!addVoiceControls 	| levelSlider r meterBox |	voiceRecorder _ SoundRecorder new		desiredSampleRate: 11025.0;		"<==try real hard to get the low rate"		codec: (GSMCodec new).		"<--this should compress better than ADPCM.. is it too slow?"		"codec: (ADPCMCodec new initializeForBitsPerSample: 4 samplesPerFrame: 0)."	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: voiceRecorder;		actionSelector: #recordLevel:;		adjustToValue: voiceRecorder recordLevel.	r _ AlignmentMorph newRow		color: color;		layoutInset: 0;		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.	meterBox _ Morph new extent: 102@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: meterBox topLeft + (1@1).	meterBox addMorph: recordMeter.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: meterBox.	self addMorphBack: r.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'RAA 1/2/2001 15:45'!step	(state == #record and: [voiceRecorder notNil]) ifTrue: [		recordMeter width: (voiceRecorder meterLevel + 1).	].! !!EventRecorderMorph methodsFor: 'commands' stamp: 'RAA 1/2/2001 10:28'!stepTime	^500! !!EventRecorderMorph methodsFor: 'commands' stamp: 'RAA 1/2/2001 15:45'!stop	state = #record ifTrue:		[tape _ tapeStream contents.		saved _ false].	journalFile ifNotNil:		[journalFile close].	self pauseIn: self world.	tapeStream _ nil.	state _ nil.	statusLight color: Color green.	recordMeter ifNotNil: [recordMeter width: 1].	self checkTape.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'RAA 1/2/2001 10:25'!wantsSteps	^true! !!SoundBuffer methodsFor: 'utilities' stamp: 'RAA 12/30/2000 18:26'!averageEvery: nSamples from: anotherBuffer upTo: inCount	| fromIndex sum |	fromIndex _ 1.	1 to: inCount // nSamples do: [ :i |		sum _ 0.		nSamples timesRepeat: [			sum _ sum + (anotherBuffer at: fromIndex).			fromIndex _ fromIndex + 1.		].		self at: i put: sum // nSamples.	].! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'RAA 12/30/2000 18:20'!averageEvery: nSamples from: anotherBuffer upTo: inCount	^(self newMonoSampleCount: inCount // nSamples)		averageEvery: nSamples 		from: anotherBuffer 		upTo: inCount! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'RAA 1/2/2001 10:17'!compressSound: aSound atRate: desiredSampleRate	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels samples newRate ratio buffer |	compressed _ CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		(desiredSampleRate isNil or: 				[(ratio _ aSound originalSamplingRate // desiredSampleRate) <= 1]) ifTrue: [			samples _ aSound samples.			newRate _ aSound originalSamplingRate.		] ifFalse: [			buffer _ aSound samples.			samples _ SoundBuffer 				averageEvery: ratio 				from: buffer 				upTo: buffer monoSampleCount.			newRate _ aSound originalSamplingRate / ratio.		].		channels _ Array new: 1.		channels at: 1 put: (self encodeSoundBuffer: samples).		compressed			channels: channels;			samplingRate: newRate;			firstSample: 1;			loopEnd: samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels _ Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels _ Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundRecorder methodsFor: 'private' stamp: 'RAA 1/2/2001 10:17'!emitBuffer: buffer	| sound ratio resultBuf |	"since some sound recording devices cannot (or will not) record below a certain sample rate,	trim the samples down if the user really wanted fewer samples"	(desiredSampleRate isNil or: [(ratio _ samplingRate // desiredSampleRate) <= 1]) ifTrue: [		sound _ SampledSound new setSamples: buffer samplingRate: samplingRate.	] ifFalse: [		resultBuf _ SoundBuffer 			averageEvery: ratio 			from: buffer 			upTo: buffer monoSampleCount.		sound _ SampledSound new setSamples: resultBuf samplingRate: samplingRate / ratio.	].	recordedSound add: (codec ifNil: [sound] ifNotNil: [codec compressSound: sound])! !