'From Squeak2.9alpha of 17 July 2000 [latest update: #3127] on 4 December 2000 at 2:06:04 pm'!"Change Set:		flexiZoomDate:			1 December 2000Author:			Bob ArningNew multi-resolution capability:In a first step to supporting objects with different resolutions, the following scenario works:- open a SBBM- drop in the background image- create a second image (MUST be a SketchMorph for now)- shrink it down (a huge shrink helps with the demo)- drop it in- zoom in the SBBM. While the background should get fuzzier and fuzzier, the sketch in the foreground should get clearer as it gets larger until it gets to the full size of its original.New script creation capability:Use the standard controls to maneuver the camera to the desired starting position/scale. The camera position and scale are displayed in a yellow box on the controller. Drag it (from somewhere the numbers are NOT, for now) to the desktop. This becomes a script. Now manuever the camera to the next desired position. Drag the yellow box again and drop it in the script. When two or more positions appear in the script, a step count will appear between. Change this by clicking and typing. You can add more positions and rearrange them as desired. When complete, choose 'save script' from the script's red menu and give it a name. Now, from the controller's red menu, you can run this script or edit it to make corrections/copies.More changes:- holding zoom and tilt keys simultaneously now works.- display of scale and camera location added to aid in building scripted actions.- simple UI for changing keys: choose 'change tilt and zoom keys' from the red menu then press 4 keys as prompted- simple programmatic motion included: choose 'TEST SCROLLING PROGRAM' from the red menu (works with beach artwork and standard sized StoryboargBookMorph. The is as yet no UI for building these actions. See ZoomAndScrollControllerMorph>>test for example of how this was created.EXPERIMENTAL changes to zoom and scroll behavior- mouse movement is for PAN only- use up/down arrow keys to TILT- use left/right arrow keys to ZOOMAlso, a neutral zone is displayed on the controller while the mouse is down.rate of zoom is adjustable using the slider (beforehand, obviously)"!FormCanvas subclass: #MultiResolutionCanvas	instanceVariableNames: 'deferredMorphs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!BookMorph subclass: #StoryboardBookMorph	instanceVariableNames: 'alansSliders panAndTiltFactor zoomFactor zoomController '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Books'!AlignmentMorph subclass: #ZASMCameraMarkMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!PasteUpMorph subclass: #ZASMScriptMorph	instanceVariableNames: 'somethingChanged '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!StringMorph subclass: #ZASMStepsMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!RectangleMorph subclass: #ZoomAndScrollControllerMorph	instanceVariableNames: 'mouseDownPoint mouseMovePoint panAndTiltFactor zoomFactor target hasFocus currentKeyDown upDownCodes changeKeysState programmedMoves '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!PasteUpMorph subclass: #ZoomAndScrollMorph	instanceVariableNames: 'sourceRectangle mouseDownPoint usingBalloon cachedImage image mouseMovePoint panAndTiltFactor zoomFactor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!Morph methodsFor: 'testing' stamp: 'RAA 12/4/2000 10:44'!canDrawAtHigherResolution	^false! !!MultiResolutionCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 12/4/2000 12:00'!deferredMorphs	^deferredMorphs! !!MultiResolutionCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 12/4/2000 11:58'!deferredMorphs: aCollection	deferredMorphs _ aCollection! !!MultiResolutionCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 12/4/2000 12:00'!fullDraw: aMorph	aMorph canDrawAtHigherResolution ifTrue: [		deferredMorphs ifNil: [deferredMorphs _ OrderedCollection new].		deferredMorphs add: aMorph.	] ifFalse: [		super fullDraw: aMorph	].! !!Player methodsFor: 'slots-kernel' stamp: 'RAA 12/2/2000 16:10'!tileForArgType: typeSymbol inViewer: aViewer	"Answer a tile to represent a value of the given type in the given viewer"	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ (CategoryViewer new) tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #point ifTrue: [^ TileMorph new setLiteral: 0@0; typeColor: aColor].	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	typeSymbol == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol].	typeSymbol == #text ifTrue: [^ ("(TextMorph new contents: 'setup')" 'aborning' newTileMorphRepresentative) typeColor:  aColor].	self error: 'Unrecognized type'! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 12/2/2000 14:48'!cameraPoint	^ self costume cameraPoint! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 12/2/2000 14:49'!cameraPoint: pt	self costume cameraPoint: pt! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 12/2/2000 15:58'!getCameraPoint	^ self costume cameraPoint! !!Player methodsFor: 'slot getters/setters' stamp: 'RAA 12/2/2000 15:58'!setCameraPoint: pt	self costume cameraPoint: pt! !!SketchMorph methodsFor: 'drawing' stamp: 'RAA 12/4/2000 13:51'!drawHighResolutionOn: aCanvas in: aRectangle| r |"Smalltalk at: #Q7 put: OrderedCollection new"	r _ aRectangle translateBy: aCanvas origin.	(WarpBlt toForm: aCanvas form)		clipRect: (r intersect: (aCanvas clipRect translateBy: aCanvas origin));		sourceForm: originalForm;		cellSize: 2;  "installs a colormap"		combinationRule: Form paint;		copyQuad: originalForm boundingBox innerCorners 		toRect: r.! !!SketchMorph methodsFor: 'other' stamp: 'RAA 12/4/2000 10:56'!canDrawAtHigherResolution		| pt |	pt _ self scalePoint.	^pt x < 1.0 or: [pt y < 1.0]! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:22'!initialize	newPagePrototype _ ZoomAndScrollMorph new extent: Display extent // 3.	zoomController _ ZoomAndScrollControllerMorph new			setBalloonText: 'Drag in here to zoom, tilt and pan the page above'.	super initialize.	self addMorphBack: zoomController.	alansSliders _ {		{#changeTiltFactor: . #getTiltFactor . 'Pan and tilt sensitivity'}.		{#changeZoomFactor: . #getZoomFactor . 'Zoom sensitivity'}.	} collect: [ :sData |		{			SimpleSliderMorph new				extent: 150@10;				color: Color orange;				sliderColor: Color gray;				target: self; 				actionSelector: sData first;				setBalloonText: sData third;				adjustToValue: (self perform: sData second).			sData second		}	].	alansSliders do: [ :each | self addMorphBack: each first]! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:20'!insertPageMorphInCorrectSpot: aPageMorph	self addMorph: (currentPage _ aPageMorph) behind: submorphs second.	self changeTiltFactor: self getTiltFactor.	self changeZoomFactor: self getZoomFactor.	zoomController target: currentPage.! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 12/4/2000 13:57'!drawSubmorphsOn: aCanvas	| r1 fullG r2 actualCanvas possibleHigherRes newClip where |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	useRegularWarpBlt == true ifTrue: [		^aCanvas 			transformBy: transform			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) rounded			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	r1 _ self innerBounds intersect: aCanvas clipRect.	r1 area = 0 ifTrue: [^self].	fullG _ (transform localBoundsToGlobal: self firstSubmorph fullBounds) rounded.	r2 _ r1 intersect: fullG.	r2 area = 0 ifTrue: [^self].	newClip _ (r2 expandBy: 1) rounded intersect: self innerBounds rounded.	possibleHigherRes _ false.	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: newClip		during: [:myCanvas |			self scale > 1.0 ifTrue: [				possibleHigherRes _ true.				actualCanvas _ myCanvas as: MultiResolutionCanvas.				actualCanvas deferredMorphs: OrderedCollection new.			] ifFalse: [				actualCanvas _ myCanvas.			].			submorphs reverseDo:[:m | actualCanvas fullDrawMorph: m].		]		smoothing: smoothing.	possibleHigherRes ifTrue: [		(actualCanvas deferredMorphs ifNil: [#()]) do: [ :each |			where _ each bounds: each fullBounds in: self.			each drawHighResolutionOn: aCanvas in: where.		].	].! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 10:09'!cameraPoint: aPoint cameraScale: aNumber controller: aController	self setProperty: #cameraPoint toValue: aPoint.	self setProperty: #cameraScale toValue: aNumber.	self setProperty: #cameraController toValue: aController.	self addMorph: (		StringMorph contents: aPoint printString,'  ',(aNumber roundTo: 0.001) printString	) lock.! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 10:25'!initialize	super initialize.	color _ Color paleYellow.	self borderColor: Color black.	self borderWidth: 1.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 10:26'!justDroppedInto: aMorph event: anEvent	| holder |	aMorph isWorldMorph ifTrue: [		holder _ ZASMScriptMorph new.		holder 			position: self position;			setProperty: #cameraController toValue: (self valueOfProperty: #cameraController).		self world addMorph: holder.		holder addMorph: self.		holder startStepping.	].	! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 09:56'!acceptDroppingMorph: aMorph event: evt	super acceptDroppingMorph: aMorph event: evt.	somethingChanged _ true.	! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 10:18'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'save script' action: #saveScript.! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:18'!compileScript	| newScript prevMark prevSteps data |	self fixup.	newScript _ OrderedCollection new.	prevMark _ prevSteps _ nil.	submorphs do: [ :each |		(each isKindOf: ZASMCameraMarkMorph) ifTrue: [			prevMark ifNotNil: [				data _ Dictionary new.				data 					at: #steps put: prevSteps;					at: #startPoint put: (prevMark valueOfProperty: #cameraPoint);					at: #endPoint put: (each valueOfProperty: #cameraPoint);					at: #startZoom put: (prevMark valueOfProperty: #cameraScale);					at: #endZoom put: (each valueOfProperty: #cameraScale).				newScript add: data.			].			prevMark _ each.		].		(each isKindOf: ZASMStepsMorph) ifTrue: [			prevSteps _ each getStepCount.		].	].	^newScript! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 12:03'!decompileScript: aScript named: aString for: aController	| newMorphs prevPt prevScale cameraPoint cameraScale mark |	self removeAllMorphs.	self setProperty: #cameraController toValue: aController.	self setProperty: #cameraScriptName toValue: aString.	newMorphs _ OrderedCollection new.	prevPt _ prevScale _ nil.	aScript do: [ :each |		cameraPoint _ each at: #startPoint ifAbsent: [nil].		cameraScale _ each at: #startZoom ifAbsent: [nil].		(prevPt = cameraPoint and: [prevScale = cameraScale]) ifFalse: [			mark _ ZASMCameraMarkMorph new.			mark cameraPoint: cameraPoint cameraScale: cameraScale controller: aController.			newMorphs add: mark.		].		newMorphs add: (ZASMStepsMorph new setStepCount: (each at: #steps ifAbsent: [10])).		cameraPoint _ each at: #endPoint ifAbsent: [nil].		cameraScale _ each at: #endZoom ifAbsent: [nil].		mark _ ZASMCameraMarkMorph new.		mark cameraPoint: cameraPoint cameraScale: cameraScale controller: aController.		newMorphs add: mark.		prevPt _ cameraPoint.		prevScale _ cameraScale.	].	self addAllMorphs: newMorphs.! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:16'!fixup	| newMorphs state fixed |	somethingChanged _ false.	newMorphs _ OrderedCollection new.	state _ #new.	fixed _ false.	submorphs do: [ :each |		(each isKindOf: ZASMCameraMarkMorph) ifTrue: [			state == #mark ifTrue: [				newMorphs add: (					ZASMStepsMorph new setStepCount: 10				).				fixed _ true.			].			newMorphs add: each.			state _ #mark.		].		(each isKindOf: ZASMStepsMorph) ifTrue: [			state == #steps ifTrue: [				fixed _ true.			] ifFalse: [				newMorphs add: each.				state _ #steps.			].		].	].	fixed ifTrue: [		self removeAllMorphs.		self addAllMorphs: newMorphs.	].! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 10:21'!initialize	somethingChanged _ true.	super initialize.	self dragEnabled: true.	borderWidth _ 2.	self layoutPolicy: TableLayout new.	self listDirection: #topToBottom.	self wrapCentering: #topLeft.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self layoutInset: 6.	color _ Color lightBlue.	self borderColor: Color blue.	self rubberBandCells: true. "default"! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 09:33'!layoutChanged	super layoutChanged.	somethingChanged _ true.	! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 12:02'!saveScript	| newScript scriptName |	newScript _ self compileScript.	scriptName _ FillInTheBlank 		request: 'Name this script' 		initialAnswer: (self valueOfProperty: #cameraScriptName ifAbsent: ['']).	scriptName isEmptyOrNil ifTrue: [^self].	(self valueOfProperty: #cameraController)		saveScript: newScript		as: scriptName.	self delete.! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 10:36'!step	super step.	somethingChanged ifFalse: [^self].	self fixup.! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 09:53'!stepTime	^500! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 09:02'!wantsDroppedMorph: aMorph event: evt	^aMorph isKindOf: ZASMCameraMarkMorph! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 09:49'!wantsSteps	^true! !!ZASMStepsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:24'!getStepCount	^[self contents asNumber] ifError: [ :a :b | 10]	! !!ZASMStepsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:29'!handlesMouseDown: evt	^ true! !!ZASMStepsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:25'!initialize	super initialize.	color _ Color black.! !!ZASMStepsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:28'!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	self launchMiniEditor: evt! !!ZASMStepsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:24'!setStepCount: n	self contents: n printString.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:59'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'change tilt and zoom keys' action: #changeKeys.	aCustomMenu add: 'run an existing camera script' action: #runAScript.	aCustomMenu add: 'edit an existing camera script' action: #editAScript.	aCustomMenu add: 'TEST SCROLLING PROGRAM' action: #test.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 15:45'!cameraPoint	target ifNil: [^0@0].	^target cameraPoint! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 15:48'!cameraPoint: aPoint	target ifNil: [^self].	target cameraPoint: aPoint! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 16:27'!cameraScale	target ifNil: [^1.0].	^target scale! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:14'!changeKeys	upDownCodes _ Dictionary new.	changeKeysState _ #(up down in out).	self changed.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 16:06'!deadZoneWidth	^8! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 19:10'!doProgrammedMoves"Smalltalk at: #Q put: OrderedCollection new."	| thisMove steps stepsRemaining startPoint endPoint startZoom endZoom newScale newPoint |	programmedMoves ifNil: [^self].	programmedMoves isEmpty ifTrue: [^programmedMoves _ nil].	thisMove _ programmedMoves first.	steps _ thisMove at: #steps ifAbsentPut: [1].	stepsRemaining _ thisMove at: #stepsRemaining ifAbsentPut: [steps].	stepsRemaining < 1 ifTrue: ["Q add: '----------'."		^programmedMoves removeFirst.	].	stepsRemaining _ stepsRemaining - 1.	startPoint _ thisMove at: #startPoint ifAbsentPut: [self cameraPoint].	endPoint _ thisMove at: #endPoint ifAbsentPut: [self cameraPoint].	startZoom _ thisMove at: #startZoom ifAbsentPut: [self cameraScale].	endZoom _ thisMove at: #endZoom ifAbsentPut: [self cameraScale].	newScale _ endZoom - (endZoom - startZoom / steps * stepsRemaining).	newPoint _ (endPoint - (endPoint - startPoint / steps * stepsRemaining)) rounded.	target changeScaleTo: newScale.	target cameraPoint: newPoint."Q add: {Time millisecondClockValue. newScale.  self cameraScale. newPoint. self cameraPoint}."	thisMove at: #stepsRemaining put: stepsRemaining.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:24'!drawOn: aCanvas	| dw bullsEye f |	super drawOn: aCanvas.	changeKeysState ifNotNil: [		f _ (			StringMorph contents: 'Press the key to be used for "',changeKeysState first,'"'		) imageForm.		aCanvas paintImage: f at: self center - (f extent // 2).		^self	].	mouseDownPoint ifNil: [^self].	dw _ self deadZoneWidth.	bullsEye _ mouseDownPoint - (dw@dw//2) extent: dw@dw.	aCanvas 		fillRectangle: (bullsEye left @ self top corner: bullsEye right @ self bottom) 		color: (Color red alpha: 0.3).	aCanvas 		fillRectangle: (self left @ bullsEye top corner: self right @ bullsEye bottom) 		color: (Color red alpha: 0.3).	aCanvas 		fillRectangle: bullsEye 		color: (Color red alpha: 0.4).! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 12:03'!editAScript	| d names reply s |	d _ self targetScriptDictionary.	names _ d keys asSortedCollection.	reply _ (SelectionMenu labelList: names selections: names) startUpWithCaption: 'Script to edit?'.	reply ifNil: [^ self].	(s _ ZASMScriptMorph new)		decompileScript: (d at: reply) named: reply for: self;		fullBounds;		align: s center with: self center;		openInWorld	! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 08:51'!grabCameraPositionEvent: anEvent morph: aMorph	| mark |	mark _ ZASMCameraMarkMorph new.	mark cameraPoint: self cameraPoint cameraScale: self cameraScale controller: self.	anEvent hand attachMorph: mark.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 16:21'!handlesKeyboard: evt	^true! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:22'!handlesMouseDown: evt	^true! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 16:21'!handlesMouseOver: evt	^true! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 16:24'!hasFocus	^ hasFocus! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 08:44'!initialize	| displayer dataMorph |	super initialize.	hasFocus _ true.	currentKeyDown _ Set new.	upDownCodes _ Dictionary new.	upDownCodes		at: 126 put: #up;		at: 125 put: #down;		at: 123 put: #out;		at: 124 put: #in.	color _ Color lightBlue.	self extent: 40@40.	self vResizing: #rigid.	self hResizing: #spaceFill.	self borderWidth: 0.	self borderColor: Color transparent.	self setBalloonText: 'Drag in here to zoom, tilt and pan the page above'.	dataMorph _ AlignmentMorph newColumn.	dataMorph 		color: Color yellow;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	dataMorph on: #mouseDown send: #grabCameraPositionEvent:morph: to: self. 	displayer _ UpdatingStringMorph new		getSelector: #cameraPoint;		target: self;		growable: true;		putSelector: nil.	dataMorph addMorph: displayer. 	displayer _ UpdatingStringMorph new		getSelector: #cameraScale;		target: self;		growable: true;		floatPrecision: 0.001;		putSelector: nil.	dataMorph addMorph: displayer.	self addMorph: dataMorph.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:22'!keyDown: anEvent	changeKeysState ifNotNil: [		upDownCodes at: anEvent keyValue put: changeKeysState first.		changeKeysState _ changeKeysState allButFirst.		changeKeysState isEmpty ifTrue: [changeKeysState _ nil].		currentKeyDown _ Set new.		^self changed	].	currentKeyDown add: anEvent keyValue.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 16:58'!keyStroke: anEvent	"currentKeyDown _ anEvent keyCharacter.	'  ',currentKeyDown asciiValue printString ,'   ' displayAt: 0@20."! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:21'!keyUp: anEvent	currentKeyDown remove: anEvent keyValue ifAbsent: [].! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:23'!mouseDown: evt	mouseDownPoint _ evt cursorPoint.	self changed.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 18:23'!mouseEnter: evt	evt hand newKeyboardFocus: self.	currentKeyDown _ Set new.	hasFocus _ true.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:25'!mouseLeave: evt	evt hand releaseKeyboardFocus: self.	currentKeyDown _ Set new.	hasFocus _ false.	mouseMovePoint _ mouseDownPoint _ nil.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:23'!mouseMove: evt	mouseMovePoint _ evt cursorPoint.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:23'!mouseUp: evt	mouseMovePoint _ mouseDownPoint _ nil.	self changed.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:45'!runAScript	| d names reply |	d _ self targetScriptDictionary.	names _ d keys asSortedCollection.	reply _ (SelectionMenu labelList: names selections: names) startUpWithCaption: 'Script to run?'.	reply ifNil: [^ self].	programmedMoves _ (d at: reply) veryDeepCopy.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:34'!saveScript: newScript as: scriptName	self targetScriptDictionary at: scriptName put: newScript.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/4/2000 14:05'!step	| delta halfDW action |	super step.	self doProgrammedMoves.	(currentKeyDown ifNil: [#()]) do: [ :each |		action _ upDownCodes at: each ifAbsent: [#fugeddaboutit].		action == #in ifTrue: [			target scaleImageBy: -10.		].		action == #out ifTrue: [			target scaleImageBy: 10.		].		action == #up ifTrue: [			target tiltImageBy: -20.		].		action == #down ifTrue: [			target tiltImageBy: 20.		].	].	mouseMovePoint ifNil: [^self].	mouseDownPoint ifNil: [^self].	target ifNil: [^self].	halfDW _ self deadZoneWidth // 2.	delta _ mouseMovePoint - mouseDownPoint.	delta x abs <= halfDW ifTrue: [delta _ 0@delta y].	delta y abs <= halfDW ifTrue: [delta _ delta x@0].		target panImageBy: delta x.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:28'!stepTime	^10! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:20'!target: x	target _ x! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:34'!targetScriptDictionary	| scriptDict |	target ifNil: [^Dictionary new].	^target 		valueOfProperty: #namedCameraScripts 		ifAbsent: [			scriptDict _ Dictionary new.			target setProperty: #namedCameraScripts toValue: scriptDict.			scriptDict		].! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 19:10'!test	| thisMove |	programmedMoves _ OrderedCollection new.	thisMove _ Dictionary new.	thisMove 		at: #steps put: 100;		at: #startPoint put: 194@134;		at: #endPoint put: 675@134;		at: #startZoom put: 0.856;		at: #endZoom put: 0.856.	programmedMoves add: thisMove.	thisMove _ Dictionary new.	thisMove 		at: #steps put: 100;		at: #startPoint put: 770@185;		at: #endPoint put: 784@173;		at: #startZoom put: 0.856;		at: #endZoom put: 2.686.	programmedMoves add: thisMove.! !!ZoomAndScrollControllerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:48'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((#storyboard			(	(slot cameraPoint 'the camera point' point readWrite player cameraPoint player cameraPoint:)			)	))! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 15:54'!changeOffsetBy: aPoint	| transform |	transform _ self firstSubmorph.	self changeOffsetTo: transform offset + aPoint.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 15:54'!changeOffsetTo: aPoint	| transform trialOffset innerPasteup keepWidth keepHeight |	transform _ self firstSubmorph.	keepWidth _ transform width "// 4".	keepHeight _ transform height "// 4".	innerPasteup _ transform firstSubmorph.	trialOffset _ aPoint.	trialOffset _ 		(trialOffset x 			min: (innerPasteup width * transform scale) - keepWidth 			max: keepWidth - transform width) @ 		(trialOffset y 			min: (innerPasteup height * transform scale) - keepHeight 			max: keepHeight - transform height).	transform offset: trialOffset.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 16:45'!changeScaleTo: aNumber	| transform innerPasteup min1 min2 newScale scaleR oldScale |	transform _ self firstSubmorph.	oldScale _ transform scale.	innerPasteup _ transform firstSubmorph.	min1 _ transform width / innerPasteup width asFloat.	min2 _ transform height / innerPasteup height asFloat.	newScale _ (aNumber max: min1) max: min2.	transform scale: newScale.	scaleR _ newScale / oldScale.	self changeOffsetBy: scaleR * (transform offset) - transform offset."- - - - - - - - - - - - - "	"half _ transform extent // 2.	self changeOffsetBy: scaleR * (transform offset + half) - half - transform offset.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 16:19'!extent: extentPoint	super extent: extentPoint.	self firstSubmorph bounds: self innerBounds.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 16:46'!scaleImageBy: pixels	| scalePerPixel steps transform factor |	transform _ self firstSubmorph.	(steps _ (pixels * self getZoomFactor * 0.2) rounded) = 0 ifTrue: [^self].	scalePerPixel _ 1.01.	factor _ scalePerPixel raisedTo: steps abs.	steps > 0 ifTrue: [		factor _ 1.0 / factor.	].	self changeScaleTo: (transform scale * factor min: 10.0 max: 0.1).! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/1/2000 15:28'!step	| innerPasteUp overlap |	innerPasteUp _ self firstSubmorph firstSubmorph.	overlap _ (innerPasteUp submorphs 		inject: 0@0 		into: [ :min :each | min min: each position]) rounded.	overlap = (0@0) ifFalse: [		innerPasteUp submorphs do: [ :each | each position: each position - overlap].		innerPasteUp layoutChanged.	].! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/3/2000 07:24'!cameraPoint	^(self firstSubmorph transform globalPointToLocal: self innerBounds center) rounded! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/2/2000 15:55'!cameraPoint: newPt	| transform |	transform _ self firstSubmorph.	self changeOffsetTo: newPt * transform scale - (transform innerBounds extent // 2) ! !ZoomAndScrollMorph removeSelector: #fullDrawOn:!ZoomAndScrollMorph removeSelector: #zoomerMouseDown:!ZoomAndScrollMorph removeSelector: #zoomerMouseMove:!ZoomAndScrollMorph removeSelector: #zoomerMouseUp:!PasteUpMorph subclass: #ZoomAndScrollMorph	instanceVariableNames: 'sourceRectangle usingBalloon panAndTiltFactor zoomFactor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!TransformMorph removeSelector: #canDrawAtHigherResolution!StoryboardBookMorph class removeSelector: #additionsToViewerCategories!StoryboardBookMorph removeSelector: #zoomerMouseDown:!StoryboardBookMorph removeSelector: #zoomerMouseMove:!StoryboardBookMorph removeSelector: #zoomerMouseUp:!