'From Squeak2.9alpha of 17 July 2000 [latest update: #2746] on 27 September 2000 at 10:47:21 pm'!"Change Set:		moreProjDate:			27 September 2000Author:			Bob Arning- start cleaning up different ways of enumerating Projects- cleanup some old refs in ProjectHistory"!!ChangeSet methodsFor: 'testing' stamp: 'RAA 9/27/2000 22:40'!projectsBelongedTo	"Answer a list of all the projects for which the receiver is the current change set"	^ Project allProjects select: [:proj | proj projectChangeSet == self]! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 22:47'!mouseMove: evt in: aMorph	| start tuple project url pvm |	start _ aMorph valueOfProperty: #mouseDownPoint ifAbsent: [^self].	(start dist: evt cursorPoint) abs < 5 ifTrue: [^self].	aMorph removeProperty: #mouseDownPoint.	evt hand hasSubmorphs ifTrue: [^self].	tuple _ aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^self].	project _ tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [		^evt hand attachMorph: (ProjectViewMorph on: project).	].	url _ tuple third.	url isEmptyOrNil ifTrue: [^self].	pvm _ ProjectViewMorph new.	pvm		project: (DiskProxy global: #Project selector: #namedUrl: args: {url});		lastProjectThumbnail: tuple second.	evt hand attachMorph: pvm.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 22:45'!mouseUp: evt in: aMorph	| tuple project url |	(aMorph boundsInWorld containsPoint: evt cursorPoint) ifFalse: [^self].	tuple _ aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^1 beep].	project _ tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [self closeMyFlapIfAny. ^project enter].	url _ tuple third.	url isEmptyOrNil ifTrue: [^1 beep].	self closeMyFlapIfAny.	Project thumbnailFromUrl: url."---	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!ImageSegment class methodsFor: 'testing' stamp: 'RAA 9/27/2000 18:50'!swapOutProjects  "ImageSegment swapOutProjects"  	"Swap out segments for all projects other than the current one."	| spaceLeft newSpaceLeft |	spaceLeft _ Smalltalk garbageCollect.	Project allProjects doWithIndex:		[:p :i | p couldBeSwappedOut ifTrue:			[Transcript cr; cr; nextPutAll: p name.			(ImageSegment new copyFromRoots: (Array with: p) sizeHint: 0)				extract; writeToFile: 'project' , i printString.			newSpaceLeft _ Smalltalk garbageCollect.			Transcript cr; print: newSpaceLeft - spaceLeft; endEntry.			spaceLeft _ newSpaceLeft]].! !!Project methodsFor: 'file in/out' stamp: 'RAA 9/27/2000 18:53'!ensureChangeSetNameUnique	| myName |	myName _ self name.	Project allProjects do: [:pp | 		pp == self ifFalse: [			pp name = myName ifTrue: [				^self projectChangeSet name: (ChangeSet uniqueNameLike: myName)			]		]	]! !!Project methodsFor: 'file in/out' stamp: 'RAA 9/27/2000 18:58'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.Display checkCurrentHandForObjectToPaste.Command initialize.world clearCommandHistory.world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: aFileName inDirectory: aDirectory.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'RAA 9/27/2000 18:55'!storeSomeSegment	"Try all projects to see if any is ready to go out.  Send at most three of them.	Previous one has to wait for a garbage collection before it can go out."	| cnt pList start proj gain |	cnt _ 0.  gain _ 0.	pList _ Project allProjects.	start _ pList size atRandom.	"start in a random place"	start to: pList size + start do: [:ii | 		proj _ pList atWrap: ii.		proj storeSegment ifTrue: ["Yes, did send its morphs to the disk"			gain _ gain + (proj projectParameters at: #segmentSize 						ifAbsent: [0]).	"a guess"			self beep.			(cnt _ cnt + 1) >= 2 ifTrue: [^ gain]]].	self beep.	^ gain! !!Project methodsFor: 'isolation layers' stamp: 'RAA 9/27/2000 18:53'!compileAllIsolated: newClass from: oldClass	"Whenever a recompile is needed in a class, look in other isolated projects for saved methods and recompile them also.	At the time this method is called, the recompilation has already been done for the project now in force."	Project allProjects do: [:proj | proj compileAll: newClass from: oldClass].! !!Project class methodsFor: 'utilities' stamp: 'RAA 9/27/2000 19:01'!allProjects	Smalltalk garbageCollect.	^ self allSubInstances select: [:p | p name notNil]! !!Project class methodsFor: 'utilities' stamp: 'RAA 9/27/2000 19:00'!ofWorld: aPasteUpMorph	"Find the project of a world."	"Usually it is the current project"	CurrentProject world == aPasteUpMorph ifTrue: [^ CurrentProject].	"Inefficient enumeration if it is not..."	^ self allProjects detect: [:pr |		pr world isInMemory 			ifTrue: [pr world == aPasteUpMorph]			ifFalse: [false]]		ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'RAA 9/27/2000 18:52'!storeAllInSegments	"Write out all Projects in this Image.	Project storeAllInSegments.		"	| all ff ll |all _ Project allProjects.Transcript show: 'Initial Space Left: ', (ff _ Smalltalk garbageCollect) printString; cr.all do: [:proj |	Transcript show: proj name; cr.	proj storeSegment  "storeSegmentNoFile"].Transcript show: 'After writing all: ', (ll _ Smalltalk garbageCollect) printString; cr.Transcript show: 'Space gained: ', (ll - ff) printString; cr."some will come back in"! !!Project class methodsFor: 'utilities' stamp: 'RAA 9/27/2000 19:00'!topProject	"Answer the top project.  There is only one"	^ self allProjects detect: [:p | p isTopProject]! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 20:49'!cleanUp	| proj |	mostRecent _ mostRecent reject: [ :each |		proj _ each fourth first.		proj isNil or: [proj world isNil]	].	self changed.! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 20:27'!forget: aProject	| newTuple |	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.	mostRecent _ mostRecent reject: [ :each |		each fourth first == aProject or: [			each fourth first isNil & (each first = newTuple first)		].	].	self changed.	^newTuple! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 20:29'!mostRecentCopy	self cleanUp.	^mostRecent copy! !