'From Squeak2.8alpha of 6 February 2000 [latest update: #1819] on 23 February 2000 at 1:08:01 am'!"Change Set:		PluggableFileList2Date:			23 February 2000Author:			Andrew C. GreenbergThis is a revised version of the PluggableFileLIst2, and incorporates PluggableFileLIst as originally posted to the listserv, with modifications and fixes.  For best results, this should be used together with PluggableButtonView changeset posted contemporaneously with this changeset.  The changesets may be loaded in any order.1) Implements a more graphically attractive 'standard file dialog' service similar to those found in Windows, MacOS and many Unix GUIs.  It is basically a highly pluggable modal FileList with buttons -- See the class comment for more detail.Sample doIts:	x _ PluggableFileList getFile	y _ PluggableFileList putFile	z _ PluggableFileList getFolder2) PluggableFileList is installed as the MVC operation for the 'file...' menu selection as well.  In time I hope to build a Morphic-side dialog, so to replace the present menu-based interface used there.3) This changeset introduces a ModalSystemWindowView for building Modal dialogs in MVC.4) The changeset also fixes a typo in ScreenController, in which an earlier change set had inadvertently elided the words 'dual change sorter' to 'chang'"!StandardSystemView subclass: #ModalSystemWindowView	instanceVariableNames: 'modalBorder '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!FileList subclass: #PluggableFileList	instanceVariableNames: 'accepted fileFilterBlock canAcceptBlock validateBlock newFiles prompt resultBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!PluggableFileList class	instanceVariableNames: ''!ModalSystemWindowView subclass: #PluggableFileListView	instanceVariableNames: 'acceptButtonView '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!ModalSystemWindowView commentStamp: '<historical>' prior: 0!I am a view for a Modal System Window.  I vary from StandardSystemView, of which I am a subclass in a few ways:	(1) I use ModalController as my default controller;	(2) When asked to update with the symbol #close, I direct the controller to close;	(3) I display a slightly different title bar with no control boxes.!!ModalSystemWindowView reorganize!('initialize-release' borderWidth: initialize)('modal dialog' doModalDialog)('controller access' defaultControllerClass)('label access' backgroundColor)('displaying' display displayBorder displayLabelBoxes)('model access' update:)!!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/18/2000 20:41'!borderWidth: anObject	modalBorder _ false.	^super borderWidth: anObject! !!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 00:50'!initialize 	"Refer to the comment in View|initialize."	super initialize.	self borderWidth: 5.	self noLabel.	modalBorder _ true.! !!ModalSystemWindowView methodsFor: 'modal dialog' stamp: 'acg 2/18/2000 23:47'!doModalDialog	| savedArea |	self resizeInitially.	self resizeTo: 		((self windowBox)			align: self windowBox center			with: Display boundingBox aboveCenter).	savedArea _ Form fromDisplay: self windowBox.	self display.	self controller startUp.	self release.	savedArea displayOn: Display at: self windowOrigin.! !!ModalSystemWindowView methodsFor: 'controller access' stamp: 'acg 2/9/2000 00:58'!defaultControllerClass	^ModalController! !!ModalSystemWindowView methodsFor: 'label access' stamp: 'acg 2/9/2000 08:35'!backgroundColor	^Color lightYellow! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/18/2000 20:24'!display	super display.	self displayLabelBackground: false.	self displayLabelText.! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/19/2000 00:59'!displayBorder	"Display the receiver's border (using the receiver's borderColor)."	modalBorder ifFalse: [^super displayBorder].	Display		border: self displayBox		widthRectangle: (1@1 corner: 2@2)		rule: Form over		fillColor: Color black.	Display		border: (self displayBox insetBy: (1@1 corner: 2@2))		widthRectangle: (4@4 corner: 3@3)		rule: Form over		fillColor: (Color r: 16rEA g: 16rEA b: 16rEA).! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/9/2000 07:21'!displayLabelBoxes	"Modal dialogs don't have closeBox or growBox."! !!ModalSystemWindowView methodsFor: 'model access' stamp: 'acg 2/9/2000 00:57'!update: aSymbol	aSymbol = #close		ifTrue: [^self controller close].	^super update: aSymbol! !!PluggableFileList commentStamp: '<historical>' prior: 0!I am a model for a modal dialog akin to "Standard File Services" on various modern GUI operating systems.  My protocol includes some methods to maintain upward compatibility with StandardFileMenu, which I hope to replace.Sample doIts:	"StandardFileDialog getFolder"-- ask user to select folder, answer corresponding FileDirectory	"StandardFileDialog getFile"	-- ask user to select file, answer corresponding FileStream	"StandardFileDialog putFile"	-- ask user to create new file, answer FileStream  In addition to the instance variables inhereted from FileList, of which I am a subclass, I am pluggable via the following instance variables:prompt			<String>	Display a prompt between the buttons.resultBlock		<BlockContext>	Passed a file directory and a file name, answer the result to be answered by the dialog.	canAcceptBlock	<BlockContext>		Answer whether the accept button should be "active"fileFilterBlock	<BlockContext>		Passed a file directory entry, answer whether the entry should be added to the list.  The list can be further filtered (but not expanded) by the user through the pattern.validateBlock	<BlockContent>	Passed a file directory entry, a file name and a collection of newly created files, answer whether the dialog selection is valid.  validateBlock is checked after the user has pressed accept, for example to ask if the user really meant to delete a file.newFiles		<OrderedCollection>	newFiles is an OrderedCollection of fileNames of files added by the user to the current directory since the user last entered same!!PluggableFileList reorganize!('initialize-release' defaultBackgroundColor initialize open openAsMorphLabel:inWorld: openLabel:)('accessing' beAccepted canAccept canAcceptBlock: fileFilterBlock: fileListIndex fileVolumeIndex prompt: resultBlock: validate validateBlock:)('accepting/cancelling' leftButtonPressed leftButtonState result rightButtonPressed rightButtonState)('file list menu' addNew:byEvaluating: fileSelectedMenu: itemsForFileEnding: itemsForNoFile listForPattern:)('file string' fileString fileString:)('StandardFileMenu' startUpWithCaption: startUpWithCaption:at:)!!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 21:44'!defaultBackgroundColor	^Color lightYellow! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 14:52'!initialize	prompt _ 'Select File'.	directory _ FileDirectory default.	newFiles _ OrderedCollection new.	fileFilterBlock _ PluggableFileList allFilesAndFoldersFileFilter.	canAcceptBlock _ PluggableFileList fileNameSelectedAcceptBlock.	resultBlock _ PluggableFileList pathNameResultBlock.	validateBlock _ PluggableFileList checkExistingFileValidateBlock.! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/9/2000 01:28'!open	^self openLabel: directory pathName! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/14/2000 22:46'!openAsMorphLabel: aString inWorld: aWorld	"Open a view of an instance of me."	"PluggableFileList new openAsMorphLabel: 'foo inWorld: World"	| windowMorph volListMorph templateMorph fileListMorph leftButtonMorph middleButtonMorph rightButtonMorph |		self directory: directory.	windowMorph _ (PluggableFileListMorph new)		model: self;		setLabel: aString;		borderWidth: 1;		yourself.	volListMorph _ PluggableListMorph on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListMorph autoDeselect: false.	windowMorph addMorph: volListMorph frame: (0@0 corner: 0.4@0.5625).	templateMorph _ PluggableTextMorph on: self		text: #pattern		accept: #pattern:.	templateMorph askBeforeDiscardingEdits: false.	windowMorph addMorph: templateMorph frame: (0@0.5625 corner: 0.4@0.75).	fileListMorph _ PluggableListMorph on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	windowMorph addMorph: fileListMorph frame: (0.4@0 corner: 1.0@0.75).	leftButtonMorph _ PluggableButtonMorph 		on: self		getState: #leftButtonState		action: #leftButtonPressed.	leftButtonMorph		label: 'Cancel';		onColor: Color red offColor: Color red;		feedbackColor: Color orange;		borderWidth: 3.	middleButtonMorph _ PluggableButtonMorph		on: self		getState: nil		action: nil.	middleButtonMorph		label: prompt;		onColor: Color lightYellow offColor: Color lightYellow;		feedbackColor: Color lightYellow;		borderWidth: 1.	rightButtonMorph _ PluggableButtonMorph		on: self		getState: #rightButtonState		action: #rightButtonPressed.	rightButtonMorph		label: 'Accept';		onColor: Color green offColor: Color lightYellow;		feedbackColor: Color black;		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]).	"self canAccept ifFalse: [rightButtonMorph controller: NoController new]."	windowMorph		addMorph: leftButtonMorph frame: (0@0.75 corner: 0.25@1.0);		addMorph: middleButtonMorph frame: (0.25@0.75 corner: 0.75@1.0);		addMorph: rightButtonMorph frame: (0.75@0.75 corner: 1.0@1.0).	self changed: #getSelectionSel.	aWorld addMorph: windowMorph centeredNear: Display center.	^windowMorph! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 01:10'!openLabel: aString	"Open a view of an instance of me."	"StandardFileDialog new open"	| topView volListView templateView fileListView fileStringView leftButtonView middleButtonView rightButtonView |		self directory: directory.	topView _ (PluggableFileListView new)		model: self.	volListView _ PluggableListView on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: self		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	"fileStringView _ PluggableTextView on: self		text: #fileString		accept: #fileString:.	fileStringView askBeforeDiscardingEdits: false.	fileStringView window: (0@0 extent: 200@15).	topView addSubView: fileStringView below: templateView."	fileStringView _ templateView.	leftButtonView _ PluggableButtonView 		on: self		getState: nil		action: #leftButtonPressed.	leftButtonView		label: 'Cancel';		backgroundColor: Color red;		borderWidth: 3;		window: (0@0 extent: 50@15).	middleButtonView _ PluggableButtonView		on: self		getState: nil		action: nil.	middleButtonView		label: prompt;		window: (0@0 extent: 100@15);		borderWidth: 1;		controller: NoController new.	rightButtonView _ PluggableButtonView		on: self		getState: nil		action: #rightButtonPressed.	rightButtonView		label: 'Accept';		backgroundColor: (self canAccept ifTrue: [Color green] ifFalse: [Color lightYellow]);		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]);		window: (0@0 extent: 50@15).	self canAccept ifFalse: [rightButtonView controller: NoController new].	topView acceptButtonView: rightButtonView.	topView		addSubView: leftButtonView below: fileStringView;		addSubView: middleButtonView toRightOf: leftButtonView;		addSubView: rightButtonView toRightOf: middleButtonView.	self changed: #getSelectionSel.	topView doModalDialog.		^self result! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:33'!beAccepted	^accepted _ true! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 09:10'!canAccept	^canAcceptBlock value: directory value: fileName! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:52'!canAcceptBlock: aBlock	^canAcceptBlock _ aBlock! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 07:33'!fileFilterBlock: aBlock	^fileFilterBlock _ aBlock! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/18/2000 21:21'!fileListIndex	self changed: #fileString.	^super fileListIndex! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/18/2000 21:21'!fileVolumeIndex	self changed: #fileString.	^super fileVolumeIndex! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:28'!prompt: aString	 prompt _ aString! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:31'!resultBlock: aBlock	^resultBlock _ aBlock! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:28'!validate	^validateBlock value: directory value: fileName value: newFiles! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/10/2000 08:02'!validateBlock: aBlock	^validateBlock _ aBlock! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 01:05'!leftButtonPressed	accepted _ false.	self changed: #close.! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/14/2000 22:40'!leftButtonState	^true! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 00:38'!result	accepted ifFalse: [^nil].	^resultBlock value: directory value: fileName! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/10/2000 07:58'!rightButtonPressed	(canAcceptBlock value: directory value: fileName) ifFalse: [^nil].	(validateBlock value: directory value: fileName value: newFiles) ifFalse: [^nil].	accepted _ true.	self changed: #close! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/14/2000 22:43'!rightButtonState	^self canAccept! !!PluggableFileList methodsFor: 'file list menu' stamp: 'acg 2/10/2000 07:47'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'New ',aString,' Name?' 					initialAnswer: aString,'Name')		isEmpty ifTrue: [^ self].	newName _ response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.	newFiles add: newName! !!PluggableFileList methodsFor: 'file list menu' stamp: 'acg 2/9/2000 07:57'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding: self fileNameSuffix asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third! !!PluggableFileList methodsFor: 'file list menu' stamp: 'acg 2/9/2000 07:49'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	^ Array with: labels with: lines with: selectors! !!PluggableFileList methodsFor: 'file list menu' stamp: 'acg 2/9/2000 07:50'!itemsForNoFile	^ #(		('sort by name' 'sort by size' 'sort by date'		'add new file' 'add new directory')		(3)		(sortByName sortBySize sortByDate		addNewFile addNewDirectory)		)! !!PluggableFileList methodsFor: 'file list menu' stamp: 'acg 2/10/2000 07:44'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles sortBlock |	entries _ directory entries select: fileFilterBlock.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	"create block to decide what order to display the entries"	sortBlock _ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x fileSize = y fileSize 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ].	newList _ (SortedCollection new: 30) sortBlock: sortBlock.	allFiles _ pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: entry]].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	newFiles _ OrderedCollection new.	^ newList asArray.! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/18/2000 21:23'!fileString	fileName ifNil: [^directory pathName].	^directory fullNameFor: fileName! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/19/2000 01:02'!fileString: aString	"| textName index ending |	textName _ aString asString.	(FileDirectory default fileExists: textName) ifTrue:		[self directory: (FileDirectory forFileName: textName).		 index _ list indexOf: (FileDirectory localNameFor: textName).		 index = 0 ifTrue: 			[ending _ ') ', (FileDirectory localNameFor: textName).		  	 index _ list findFirst: [:line | line endsWith: ending]].		 self fileListIndex: index].	(FileDirectory default directoryExists: textName) ifTrue:		[self directory: (FileDirectory on: textName)]."	self changed: #fileString.	self changed: #contents.	^true! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'acg 2/12/2000 15:30'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor, so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil		at: (World ifNil: [Sensor cursorPoint]				ifNotNil: [World primaryHand lastEvent cursorPoint])! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'acg 2/12/2000 15:35'!startUpWithCaption: aString at: location	self prompt: aString.	^self open! !!PluggableFileList class reorganize!('instance creation' getFilePathNameDialog getFilePathNameDialogWithExistenceCheck getFolderDialog new open)('standard dialog operations' getFile getFilePathName getFilePathNameWithExistenceCheck getFolder putFile)('resultBlocks' directoryResultBlock fileNameResultBlock pathNameResultBlock sfmResultBlock)('canAcceptBlocks' alwaysAcceptBlock fileNameSelectedAcceptBlock)('validateBlocks' alwaysValidateBlock checkExistingFileValidateBlock existingFileValidateBlock okToOpen:without: okToOverwrite:)('fileFilterBlocks' allFilesAndFoldersFileFilter allFoldersFileFilter)('StandardFileMenu' newFileMenu: oldFileMenu:)!!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFilePathNameDialog	^(self new)		validateBlock: PluggableFileList alwaysValidateBlock;		yourself! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFilePathNameDialogWithExistenceCheck	^(self new)		prompt: 'Select New File:';		validateBlock: PluggableFileList checkExistingFileValidateBlock;		yourself! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFolderDialog	^(self new)		prompt: 'Select a Folder';		fileFilterBlock: PluggableFileList allFoldersFileFilter;		canAcceptBlock: PluggableFileList alwaysAcceptBlock;		resultBlock: PluggableFileList directoryResultBlock;		validateBlock: PluggableFileList alwaysValidateBlock;		yourself! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/9/2000 00:35'!new	^super new initialize! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/9/2000 00:34'!open	^self new open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:24'!getFile	| result |	result _ self getFilePathName.	^result ifNotNil: [FileStream oldFileNamed: result]! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:31'!getFilePathName	^self getFilePathNameDialog open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!getFilePathNameWithExistenceCheck	^self getFilePathNameDialogWithExistenceCheck open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/9/2000 01:16'!getFolder	^self getFolderDialog open! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!putFile	| result |	result _ self getFilePathNameWithExistenceCheck.	^result ifNotNil: 		[FileDirectory deleteFilePath: result.		 FileStream newFileNamed: result]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:19'!directoryResultBlock	^[:theDirectory :theFileName | theDirectory]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:07'!fileNameResultBlock	^[:theDirectory :theFileName | theFileName]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:07'!pathNameResultBlock	^[:theDirectory :theFileName | 		theFileName 			ifNil: [theDirectory pathName]			ifNotNil: [theDirectory fullNameFor: theFileName]].! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/12/2000 15:08'!sfmResultBlock	^[:theDirectory :theFileName | 		StandardFileMenuResult directory: theDirectory name: theFileName]! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'acg 2/10/2000 08:18'!alwaysAcceptBlock	^[:theDirectory :theFileName | true]! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'acg 2/10/2000 08:10'!fileNameSelectedAcceptBlock	^[:theDirectory :theFileName | theFileName isNil not]! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 08:27'!alwaysValidateBlock	^[:theDirectory :theFileName :theNewFiles | true].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/12/2000 14:52'!checkExistingFileValidateBlock	^[:theDirectory :theFileName :theNewFiles | 		(theNewFiles includes: theFileName) or:			[(PluggableFileList okToOverwrite: theFileName)]].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/12/2000 14:52'!existingFileValidateBlock	^[:theDirectory :theFileName :theNewFiles | 		(theNewFiles includes: theFileName) or:			[(PluggableFileList okToOverwrite: theFileName)]].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 08:05'!okToOpen: aFileNameString without: aSuffixString	"Answer whether user confirms that it is ok to overwrite the file named in aString"	^ 1 = ((PopUpMenu		labels:'overwrite that fileselect another file')		startUpWithCaption: aFileNameString, 'already exists.')! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 07:55'!okToOverwrite: aString	"Answer whether user confirms that it is ok to overwrite the file named in aString"	^ 1 = ((PopUpMenu		labels:'overwrite that fileselect another file')		startUpWithCaption: aString, 'already exists.')! !!PluggableFileList class methodsFor: 'fileFilterBlocks' stamp: 'acg 2/10/2000 08:16'!allFilesAndFoldersFileFilter	^[:each | true]! !!PluggableFileList class methodsFor: 'fileFilterBlocks' stamp: 'acg 2/10/2000 08:17'!allFoldersFileFilter	^[:each | each isDirectory]! !!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'acg 2/12/2000 15:10'!newFileMenu: aDirectory	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"	^(self getFilePathNameDialogWithExistenceCheck)		resultBlock: self sfmResultBlock;		yourself! !!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'acg 2/12/2000 15:11'!oldFileMenu: aDirectory	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"	^(self getFilePathNameDialog)		resultBlock: self sfmResultBlock;		yourself! !!PluggableFileListView commentStamp: '<historical>' prior: 0!I provide aview for PluggableFileList!!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:57'!acceptButtonView: aView	^acceptButtonView _ aView! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/18/2000 20:52'!label: aString	super label: aString.	self noLabel! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:55'!update: aSymbol	(aSymbol = #volumeListIndex or: [aSymbol = #fileListIndex])		ifTrue: [self updateAcceptButton].	^super update: aSymbol! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 09:40'!updateAcceptButton	self model canAccept		ifTrue:			[acceptButtonView				backgroundColor: Color green;				borderWidth: 3;				controller: acceptButtonView defaultController]		ifFalse:			[acceptButtonView				backgroundColor: Color lightYellow;				borderWidth: 1;				controller: NoController new].	acceptButtonView display.! !!Rectangle methodsFor: 'accessing' stamp: 'acg 2/23/2000 00:52'!aboveCenter	"Answer the point slightly above the center of the receiver."	^self topLeft + self bottomRight // (2@3)! !!ScreenController methodsFor: 'nested menus' stamp: 'acg 2/12/2000 15:43'!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'package browser'			'method finder'			'workspace'			'file list'			'file...'			'transcript'			'morphic world'			'simple change sorter'			'dual change sorter'			'mvc project'			'morphic project'			'construction project'			)		lines: #(1 9 11)		selections: #(durableOpenMenuopenBrowser openPackageBrowser openSelectorBrowser openWorkspace openFileList openFile openTranscript openMorphicWorldopenSimpleChangeSorter openChangeManageropenProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 15:29'!newFileMenu: aDirectory	World ifNil: [^PluggableFileList newFileMenu: aDirectory].	^super new newFileFrom: aDirectory! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 15:29'!oldFileMenu: aDirectory	World ifNil: [^PluggableFileList oldFileMenu: aDirectory].	^super new oldFileFrom: aDirectory! !