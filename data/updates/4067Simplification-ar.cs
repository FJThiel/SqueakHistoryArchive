'From Squeak3.1alpha of 28 February 2001 [latest update: #4064] on 24 May 2001 at 1:54:13 pm'!"Change Set:		Simplification-arDate:			24 May 2001Author:			Andreas RaabProvides a very simple tool for simplifying (e.g., flattening) an input stroke."!Object subclass: #StrokePoint	instanceVariableNames: 'position prev next flags '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Tools-Simplification'!StrokePoint class	instanceVariableNames: ''!Object subclass: #StrokeSimplifier	instanceVariableNames: 'points firstPoint finalPoint lastPoint lastStrokePoint lastStrokeIndex distance samples time removeDuplicates simplifyStroke maxDistance maxSamples maxTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Tools-Simplification'!!StrokeSimplifier commentStamp: '<historical>' prior: 0!I represent a very simple algorithm for simplifying an input stroke. See class side for an example.!StrokeSimplifier class	instanceVariableNames: ''!!StrokePoint methodsFor: 'initialize' stamp: 'ar 5/19/2001 15:17'!on: aPoint	flags _ 0.	self position: aPoint.! !!StrokePoint methodsFor: 'initialize' stamp: 'ar 5/19/2001 15:28'!releaseCachedState! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:17'!backwardDirection	"Compute the backward direction to the previous point in the stroke."	| dir |	dir _ prev ifNil:[0@0] ifNotNil:[self position - prev position].	dir isZero ifFalse:[dir _ dir normalized].	^dir! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:18'!defineIntermediatePoint	"Define an intermediate point for an extreme change in direction"	| pt |	pt _ self class on: position.	pt width: self width.	pt prevPoint: self.	pt nextPoint: next.	next ifNotNil:[next prevPoint: pt].	self nextPoint: pt.	pt isFinal: self isFinal.! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:17'!forwardDirection	"Compute the forward direction to the next point in the stroke."	| dir |	dir _ next ifNil:[0@0] ifNotNil:[next position - self position].	dir isZero ifFalse:[dir _ dir normalized].	^dir! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:16'!nextPoint	"Return the next point in the stroke"	^next! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:16'!nextPoint: aPoint	"Set the next point in the stroke"	next _ aPoint! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:16'!position	"Return the position of the receiver"	^position! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:16'!position: aPoint	"Set the position of the receiver to aPoint"	position _ aPoint.! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:16'!prevPoint	"Return the previous point of the stroke"	^prev! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:16'!prevPoint: aPoint	"Set the previous point of the stroke"	prev _ aPoint! !!StrokePoint methodsFor: 'accessing' stamp: 'ar 5/19/2001 15:18'!removeIntermediatePoint	"Remove an intermediate point for an extreme change in direction"	next ifNil:[^self].	prev ifNil:[^self].	next position = self position ifTrue:[		next _ next nextPoint.		next ifNotNil:[next prevPoint: self].		^self removeIntermediatePoint]! !!StrokePoint methodsFor: 'flags' stamp: 'ar 5/19/2001 15:17'!isFinal	^flags anyMask: 1! !!StrokePoint methodsFor: 'flags' stamp: 'ar 5/19/2001 15:17'!isFinal: aBool	flags _ aBool ifTrue:[flags bitOr: 1] ifFalse:[flags bitClear: 1].	(aBool and:[prev notNil and:[prev isFinal not]]) ifTrue:[prev isFinal: true].! !!StrokePoint methodsFor: 'flags' stamp: 'ar 5/19/2001 15:17'!isProcessed	^flags anyMask: 2! !!StrokePoint methodsFor: 'flags' stamp: 'ar 5/19/2001 15:17'!isProcessed: aBool	flags _ aBool ifTrue:[flags bitOr: 2] ifFalse:[flags bitClear: 2].! !!StrokePoint methodsFor: 'intersecting' stamp: 'ar 5/19/2001 15:18'!intersectFrom: startPt with: startDir to: endPt with: endDir	"Compute the intersection of two lines, e.g., compute alpha and beta for		startPt + (alpha * startDir) = endPt + (beta * endDir).	Reformulating this yields		(alpha * startDir) - (beta * endDir) = endPt - startPt.	or		(alpha * startDir) + (-beta * endDir) = endPt - startPt.	or		(alpha * startDir x) + (-beta * endDir x) = endPt x - startPt x.		(alpha * startDir y) + (-beta * endDir y) = endPt y - startPt y.	which is trivial to solve using Cramer's rule. Note that since	we're really only interested in the intersection point we need only	one of alpha or beta since the resulting intersection point can be	computed based on either one."	| det deltaPt alpha |	det _ (startDir x * endDir y) - (startDir y * endDir x).	det = 0.0 ifTrue:[^nil]. "There's no solution for it"	deltaPt _ endPt - startPt.	alpha _ (deltaPt x * endDir y) - (deltaPt y * endDir x).	alpha _ alpha / det.	"And compute intersection"	^startPt + (alpha * startDir)! !!StrokePoint methodsFor: 'enumerating' stamp: 'ar 5/19/2001 15:19'!do: aBlock	aBlock value: self.	next ifNotNil:[next do: aBlock].! !!StrokePoint methodsFor: 'printing' stamp: 'ar 5/19/2001 15:19'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; print: position; nextPut:$).! !!StrokePoint class methodsFor: 'instance creation' stamp: 'ar 5/19/2001 15:25'!on: aPoint	^self new on: aPoint! !!StrokeSimplifier methodsFor: 'initialize' stamp: 'ar 5/19/2001 16:28'!initialize	removeDuplicates _ true.	simplifyStroke _ true.	maxDistance _ 10 squared.	maxSamples _ 10.	maxTime _ 1000.	self reset.! !!StrokeSimplifier methodsFor: 'initialize' stamp: 'ar 5/19/2001 15:21'!reset	points _ OrderedCollection new: 100.	lastPoint _ nil.	lastStrokePoint _ nil.! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:21'!add: aPoint	lastPoint ifNotNil:[		(aPoint = lastPoint position and:[removeDuplicates]) ifTrue:[^false].	].	self addPoint: aPoint.	^true! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:37'!closeStroke	"Close the current stroke"	lastPoint do:[:pt| lastPoint _ pt].	lastPoint nextPoint: firstPoint.	self simplifyLineFrom: firstPoint.	firstPoint _ firstPoint nextPoint.	self simplifyLineFrom: firstPoint.	firstPoint _ firstPoint nextPoint.	self simplifyLineFrom: firstPoint.	firstPoint prevPoint nextPoint: nil.	firstPoint prevPoint: nil.	! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:27'!currentStroke	"Return a copy of the current stroke.	As far as we have it, that is."	| pts |	pts _ WriteStream on: (Array new: 100).	firstPoint do:[:pt| pts nextPut: pt position].	^pts contents! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:27'!finalStroke	"Return the final stroke"	^self currentStroke! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:21'!finalizeStroke	"Finalize the current stroke, e.g., remove the last point(s) if necessary"	| prevPt |	prevPt _ lastPoint prevPoint.	(prevPt prevPoint == nil or:[prevPt position = lastPoint position]) 		ifFalse:[lastPoint _ prevPt].	lastPoint nextPoint: nil.	firstPoint do:[:pt| pt isFinal: true].! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:22'!firstPoint	^firstPoint! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:21'!next	"Returns the next 'final' point, e.g., one that will not be affected by simplification later"	| thePoint |	(finalPoint notNil and:[finalPoint isFinal]) ifFalse:[^nil].	thePoint _ finalPoint.	finalPoint _ finalPoint nextPoint.	^thePoint! !!StrokeSimplifier methodsFor: 'public' stamp: 'ar 5/19/2001 15:21'!pointsDo: aBlock	firstPoint ifNil:[^self].	firstPoint do: aBlock.! !!StrokeSimplifier methodsFor: 'simplification' stamp: 'ar 5/19/2001 15:22'!addFirstPoint	"No points in stroke yet. Add the very first point."	self addNextPoint.	finalPoint _ firstPoint _ lastPoint.	self addPoint: firstPoint position.! !!StrokeSimplifier methodsFor: 'simplification' stamp: 'ar 5/19/2001 15:22'!addLastPoint	self addNextPoint.! !!StrokeSimplifier methodsFor: 'simplification' stamp: 'ar 5/19/2001 15:23'!addNextPoint	lastStrokePoint ifNotNil:[		lastStrokePoint releaseCachedState.		lastStrokePoint nextPoint: lastPoint.		lastPoint prevPoint: lastStrokePoint.		self simplifyLineFrom: lastPoint.	].	lastStrokePoint _ lastPoint.	distance _ 0. "Distance since last stroke point"	samples _ 0.	 "Samples since last stroke point"	time _ 0. "Time since last stroke point"! !!StrokeSimplifier methodsFor: 'simplification' stamp: 'ar 5/19/2001 15:27'!addPoint: aPoint	| strokePoint |	strokePoint _ self asStrokePoint: aPoint.	strokePoint prevPoint: lastPoint.	lastPoint ifNotNil:[		lastPoint do:[:pt| lastPoint _ pt].		lastPoint nextPoint: strokePoint.		lastPoint releaseCachedState].	lastPoint _ strokePoint.	points add: strokePoint.	simplifyStroke ifTrue:[self simplifyIncrementally].! !!StrokeSimplifier methodsFor: 'simplification' stamp: 'ar 5/19/2001 15:23'!simplifyIncrementally	"Simplify the last point that was added"	| prevPt dir |	lastStrokePoint ifNil:[^self addFirstPoint].	prevPt _ (points at: points size-1).	dir _ lastPoint position - prevPt position.	distance _ distance + (dir dotProduct: dir). "e.g., distance^2"	samples _ samples + 1.	"time _ time + (points last key - (points at: points size-1) key)."	"If we have sampled too many points or went too far,	add the next point. This may eventually result in removing earlier points."	(samples >= maxSamples or:[distance >= maxDistance "or:[time > maxTime]"]) 		ifTrue:[^self addNextPoint].	"Note: We may want to add a time/speed feature in the future."! !!StrokeSimplifier methodsFor: 'simplification' stamp: 'ar 5/19/2001 15:24'!simplifyLineFrom: p5	"Remove a point if it represents the intermediate point of a line.	We only remove 'inner' points of a line, that is, for a sequence of points like	p1----p2----p3----p4---p5	we will remove only p3. This is so that any curve can be adequately represented, e.g., so that for a stroke running like:		p0		 |		p1----p2----p3----p4----p5							   |							   |							  p6	we will neither touch p2 (required for the curve p0,p1,p2) nor p5 yet (the shape of the curve relies on p6 which is not yet recorded."	| p4 p3 p2 p1 d1 d2 d3 d4 cosValue |	p4 _ p5 prevPoint ifNil:[^self].	"Note: p4 (actually p1 from above) is final after we know the next point."	p3 _ p4 prevPoint ifNil:[^p4 isFinal: true].	p2 _ p3 prevPoint ifNil:[^self].	p1 _ p2 prevPoint ifNil:[^self].	"First, compute the change in direction at p3 (this is the point we are *really* interested in)."	d2 _ p2 forwardDirection.	d3 _ p3 forwardDirection.	cosValue _ d2 dotProduct: d3.	"See if the change is below the threshold for linearity.	Note that the above computes the cosine of the directional change	at p2,p3,p4 so that a value of 1.0 means no change at all, and -1.0	means a reversal of 180 degrees."	cosValue < 0.99 ifTrue:[		"0.999 arcCos radiansToDegrees is approx. 2.56 degrees.		If the cosine is less than we consider this line to be curved."		^p2 isFinal: true]. "we're done here"	"Okay, so the line is straight. Now make sure that the previous and the	next segment are straight as well (so that we don't remove a point which	defines the start/end of a curved segment)"	d1 _ p1 forwardDirection.	cosValue _ d1 dotProduct: d2.	cosValue < 0.95 ifTrue:[		"0.99 arcCos radiansToDegrees is approx. 8 degrees"		^p2 isFinal: true].	"And the same for the last segment"	d4 _ p4 forwardDirection.	cosValue _ d3 dotProduct: d4.	cosValue < 0.95 ifTrue:[		"0.99 arcCos radiansToDegrees is approx. 8 degrees"		^p2 isFinal: true].	"Okay, so p3 defines an inner point of a pretty straight line.	Let's get rid of it."	p2 nextPoint: p4.	p4 prevPoint: p2.	p2 releaseCachedState.	p3 releaseCachedState.	p4 releaseCachedState.! !!StrokeSimplifier methodsFor: 'private' stamp: 'ar 5/19/2001 15:25'!asStrokePoint: aPoint	^StrokePoint on: aPoint! !!StrokeSimplifier class methodsFor: 'instance creation' stamp: 'ar 5/19/2001 15:26'!new	^super new initialize.! !!StrokeSimplifier class methodsFor: 'examples' stamp: 'ar 5/19/2001 15:30'!flattenExample		"StrokeSimplifier flattenExample"	"This example demonstrate how aggressive the stroke recorder simplifies series of points"	| pts fc lastPt nextPt |	[Sensor anyButtonPressed] whileFalse.	fc _ FormCanvas on: Display.	pts _ self new.	lastPt _ Sensor cursorPoint.	pts add: lastPt.	[Sensor anyButtonPressed] whileTrue:[		nextPt _ Sensor cursorPoint.		nextPt = lastPt ifFalse:[			fc line: lastPt to: nextPt width: 3 color: Color black.			pts add: nextPt.			lastPt _ nextPt.		].	].	pts closeStroke.	(PolygonMorph vertices: pts finalStroke color: Color transparent borderWidth: 3 borderColor: Color black) makeOpen; addHandles; openInWorld.! !