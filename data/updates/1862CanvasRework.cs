'From Squeak2.8alpha of 16 February 2000 [latest update: #1859] on 17 February 2000 at 4:59:02 pm'!"Change Set:		CanvasReworkDate:			17 February 2000Author:			Andreas RaabThis (rather large) change set modifies many of the internals of Canvases and cleans up drawing related parts of Morphic. The primary intent is to provide a stronger fence between Morphic and BitBlt (since BitBlt is subject to change very soon). Everyone using lots of drawing methods from Canvas - repeat after me:	'I will not use combination rules with a Canvas'	'I WILL use a Color where I mean a Color'Clients that require effects that are currently not part of the Canvas interface should setup their own BitBlt operations, fetching and restoring the portions of the destination form explicitly (see CornerRounder for an example). For getting the contents of the Canvas the methods #contentsOfArea: and #contentsOfArea:into: have been provided.For stating the intent of displaying an image more clearly, the following methods have been added:* drawImage:at:[sourceRect:]Plainly draw the image (e.g., what used to be represented as Form>>over).* paintImage:at:[sourceRect:]Draw an image that has a certain source key to be treated as transparent (e.g., what used to be represented as Form>>paint)* translucentImage:at:[sourceRect:]Draw an image that might contain transparency values. This is an explicit hint for the canvas to choose a representation which is best suited for the target device (e.g., in a FormCanvas this may result in different combination rules depending on the source and target depth).The public use of the following methods is highly disapproved:* image:at:  [replaced by #paintImage:at:]* imageWithOpaqueWhite:at:  [replaced by #drawImage:at:]* image:at:rule:  [Obsolete]* image:at:sourceRect:rule:  [Considered to be PRIVATE]The methods are still kept for compatibility but will definitely go away at some time.Additional notes: * You will get errors when attempting to pass a bit pattern as a color. This is intentional - Canvases are smart enough to figure out how to represent any given color best. * The change set has one minor known glitch - gradients look ugly in 8bit depth or less. The problem will be addressed later; once the BitBlt modifications are completed it will go away all by itself.""Close Transcripts (just to be sure...)"Smalltalk isMorphic ifTrue:[	(World submorphs 		select:[:m| (m isKindOf:SystemWindow) and:[m model == Transcript]]) 			do:[:win| win delete]].!Canvas subclass: #FormCanvas	instanceVariableNames: 'origin clipRect shadowDrawing form port shadowStipple shadowColor '	classVariableNames: 'AA '	poolDictionaries: ''	category: 'Morphic-Support'!BitBlt subclass: #GrafPort	instanceVariableNames: 'lastColor alpha fillPattern'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!BorderedMorph methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:41'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor |	borderWidth = 0 ifTrue: [  "no border"		"Note: This is the hook for border styles.			When converting to the new borders we'll just put 0 into the borderWidth"		super drawOn: aCanvas.		^ self].	borderColor == #raised ifTrue: [		"Use a hack for now"		aCanvas fillRectangle: self bounds fillStyle: self fillStyle.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: (borderWidth = 1 ifTrue: [color twiceLighter]										ifFalse: [color lighter])			bottomRightColor: (borderWidth = 1 ifTrue: [color twiceDarker]										ifFalse: [color darker])].	borderColor == #inset ifTrue: [		insetColor _ owner colorForInsets.		aCanvas fillRectangle: self bounds fillStyle: self fillStyle.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: (borderWidth = 1 ifTrue: [insetColor twiceDarker]										ifFalse: [insetColor darker])			bottomRightColor: (borderWidth = 1 ifTrue: [insetColor twiceLighter]										ifFalse: [insetColor lighter])].	"solid color border"	aCanvas fillRectangle: (self bounds insetBy: borderWidth) fillStyle: self fillStyle.	aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: borderWidth		borderColor: borderColor.! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/16/2000 21:32'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList |	myBnds _ self fullBounds.	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		cacheCanvas translateBy: myBnds origin negated			during:[:tempCanvas| super fullDrawOn: tempCanvas].		^self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: myBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			super fullDrawOn: c]].! !!Canvas reorganize!('initialization' flush reset)('copying' copy)('accessing' clipRect contentsOfArea: contentsOfArea:into: depth extent form origin shadowColor shadowColor:)('testing' isBalloonCanvas isShadowDrawing isVisible:)('drawing' fillColor: line:to:brushForm: line:to:color: line:to:width:color: paragraph:bounds:color: point:color: render: text:at:font:color: text:bounds:font:color:)('private' image:at:sourceRect:rule:)('drawing-general' draw: drawMorph: fullDraw: fullDrawMorph:)('drawing-support' cache:using:during: clipBy:during: preserveStateDuring: transformBy:clippingTo:during: transformBy:clippingTo:during:smoothing: translateBy:during: translateTo:clippingTo:during:)('drawing-rectangles' fillRectangle:color: fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameRectangle:color: frameRectangle:width:color:)('drawing-ovals' fillOval:color: fillOval:color:borderWidth:borderColor: fillOval:fillStyle: fillOval:fillStyle:borderWidth:borderColor: frameOval:color: frameOval:width:color:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor: drawPolygon:fillStyle: drawPolygon:fillStyle:borderWidth:borderColor:)('drawing-images' drawImage:at: drawImage:at:sourceRect: paintImage:at: paintImage:at:sourceRect: stencil:at:color: stencil:at:sourceRect:color: translucentImage:at: translucentImage:at:sourceRect:)('converting' asShadowDrawingCanvas asShadowDrawingCanvas:)('other' flushDisplay forceToScreen: translateBy:clippingTo:during:)('drawing-obsolete' image:at: image:at:rule: imageWithOpaqueWhite:at:)!!Canvas methodsFor: 'accessing' stamp: 'ar 2/12/2000 18:17'!contentsOfArea: aRectangle	"Return the contents of the given area"	^self contentsOfArea: aRectangle into: (Form extent: aRectangle extent depth: self depth)! !!Canvas methodsFor: 'accessing' stamp: 'ar 2/12/2000 18:17'!contentsOfArea: aRectangle into: aForm	"Return the contents of the given area"	^self subclassResponsibility! !!Canvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:46'!shadowColor	"Return the current override color or nil if no such color exists"	^nil! !!Canvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:46'!shadowColor: aColor	"Set a shadow color. If set this color overrides any client-supplied color."! !!Canvas methodsFor: 'private' stamp: 'ar 2/12/2000 18:12'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Note: The public use of this protocol is deprecated. It will become private. Nobody in the outside world must assume that a thing like a combination rule has any specific effect."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 2/17/2000 01:24'!fullDrawMorph: aMorph	(self isVisible: aMorph fullBounds) ifTrue:[self fullDraw: aMorph].! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 2/12/2000 18:05'!cache: aRectangle using: aCache during: aBlock	"Cache the execution of aBlock by the given cache.	Note: At some point we may want to actually *create* the cache here;		for now we're only using it."	(aCache notNil and:[(aCache isKindOf: Form) and:[aCache extent = aRectangle extent]]) 		ifTrue:[^self paintImage: aCache at: aRectangle origin].	aBlock value: self.! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/16/2000 23:45'!drawImage: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm"	self drawImage: aForm		at: aPoint		sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 01:47'!drawImage: aForm at: aPoint sourceRect: sourceRect	"Draw the given form."	self shadowColor ifNotNil:[		^self fillRectangle: ((aForm boundingBox intersect: sourceRect) translateBy: aPoint)				color: self shadowColor].	^self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form over! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/16/2000 23:48'!paintImage: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self paintImage: aForm		at: aPoint		sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 01:48'!paintImage: aForm at: aPoint sourceRect: sourceRect	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self shadowColor ifNotNil:[		^self stencil: aForm at: aPoint sourceRect: sourceRect color: self shadowColor].	^self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form paint! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 14:05'!translucentImage: aForm at: aPoint	"Draw a translucent image using the best available way of representing translucency."	self translucentImage: aForm		at: aPoint		sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 01:48'!translucentImage: aForm at: aPoint sourceRect: sourceRect	"Draw a translucent image using the best available way of representing translucency.	Note: This will be fixed in the future."	self shadowColor ifNotNil:[		^self stencil: aForm at: aPoint sourceRect: sourceRect color: self shadowColor].	(self depth < 32 or:[aForm depth < 32]) 		ifTrue:[^self paintImage: aForm at: aPoint sourceRect: sourceRect].	self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form blend! !!Canvas methodsFor: 'drawing-obsolete' stamp: 'ar 2/12/2000 18:10'!image: aForm at: aPoint	"Note: This protocol is deprecated. Use #paintImage: instead."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: Form paint.! !!Canvas methodsFor: 'drawing-obsolete' stamp: 'ar 2/12/2000 18:11'!image: aForm at: aPoint rule: combinationRule	"Note: This protocol is deprecated. Use one of the explicit image drawing messages (#paintImage, #drawImage) instead."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox		rule: combinationRule.! !!Canvas methodsFor: 'drawing-obsolete' stamp: 'ar 2/12/2000 18:11'!imageWithOpaqueWhite: aForm at: aPoint	"Note: This protocol is deprecated. Use #drawImage: instead"	self image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form over.! !!CornerRounder methodsFor: 'all' stamp: 'ar 2/12/2000 18:33'!saveBitsUnderCornersOf: aMorph on: aCanvas	| offset corner mask form |	underBits _ (1 to: 4) collect:		[:i | 		mask _ cornerMasks at: i.		corner _ aMorph bounds corners at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@mask height negated].		i = 3 ifTrue: [offset _ mask extent negated].		i = 4 ifTrue: [offset _ mask width negated@0].		form _ aCanvas contentsOfArea: (corner + offset extent: mask extent).		form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0)].! !!CornerRounder methodsFor: 'all' stamp: 'ar 2/17/2000 01:49'!tweakCornersOf: aMorph on: aCanvas borderWidth: w	| offset corner saveBits c fourColors c14 c23 insetColor mask nonShadowCanvas outBits |	nonShadowCanvas _ aCanvas copy shadowColor: nil.	w > 0 ifTrue:		[c _ aMorph borderColor.		fourColors _ Array new: 4 withAll: c.		c == #raised ifTrue:			[c14 _ aMorph color lighter. c23 _ aMorph color darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14].		(c == #inset and: [aMorph owner notNil]) ifTrue:			[insetColor _ aMorph owner colorForInsets.			c14 _ insetColor lighter. c23 _ insetColor darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	(1 to: 4) do:		[:i | 		corner _ aMorph bounds corners at: i.		saveBits _ underBits at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@saveBits height negated].		i = 3 ifTrue: [offset _ saveBits extent negated].		i = 4 ifTrue: [offset _ saveBits width negated@0].		"Mask out corner area (painting saveBits won't clear if transparent)."		mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).		outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).		mask displayOn: outBits at: 0@0 rule: Form and.		"Paint back corner bits."		saveBits displayOn: outBits at: 0@0 rule: Form paint.		nonShadowCanvas drawImage: outBits at: corner + offset.		w > 0 ifTrue:			["Paint over with border if any"			aCanvas stencil: (cornerOverlays at: i) at: corner + offset					color: (fourColors at: i)]].! !!CornerRounder methodsFor: 'all' stamp: 'ar 2/12/2000 18:31'!tweakCornersOf: aMorph on: aCanvas borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits c fourColors c14 c23 insetColor mask outBits |	w > 0 ifTrue:		[c _ aMorph borderColor.		fourColors _ Array new: 4 withAll: c.		c == #raised ifTrue:			[c14 _ aMorph color lighter. c23 _ aMorph color darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14].		(c == #inset and: [aMorph owner notNil]) ifTrue:			[insetColor _ aMorph owner colorForInsets.			c14 _ insetColor lighter. c23 _ insetColor darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	(1 to: 4) do: 		[:i | (cornerList includes: i) ifTrue:			[corner _ aMorph bounds corners at: i.			saveBits _ underBits at: i.			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:				["Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]]! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:05'!drawOn: aCanvas	aCanvas text: contents bounds: (bounds insetBy: 2)  font: self fontToUse color: color.	border ifNotNil: [aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: 1		borderColor: Color black].	aCanvas			paintImage: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))! !!DropShadowMorph methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:15'!drawOn: aCanvas	"Draw my submorphs as a shadow, then fullDrawOn will droaw them normally."	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	aCanvas translateBy: shadowOffset during:[:shadowCanvas|		shadowCanvas shadowColor: color.		self drawSubmorphsOn: shadowCanvas].! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:34'!drawOn: aCanvas 	"Draw the background of the player"	| box bgImage |	box _ self bounds.	bgImage _ self valueOfProperty: #transitionBackground ifAbsent:[nil].	bgImage 		ifNil:[aCanvas fillRectangle: box color: color]		ifNotNil:[aCanvas drawImage: bgImage at: box origin].! !!FlashThumbnailMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:05'!drawOn: aCanvas	(player == nil or:[frameNumber == nil]) ifTrue:[^super drawOn: aCanvas].false ifTrue:[super drawOn: aCanvas.			^aCanvas text: frameNumber printString bounds: self innerBounds font: nil color: Color red].	image ifNil:[		Cursor wait showWhile:[			image _ player imageFormOfSize: (self extent - (self borderWidth * 2))					 forFrame: frameNumber.			frameNumber printString displayOn: image]].	aCanvas frameRectangle: self bounds width: self borderWidth color: self borderColor.	aCanvas paintImage: image at: self topLeft + self borderWidth.! !!Form methodsFor: 'accessing' stamp: 'ar 2/16/2000 22:00'!offset	^offset ifNil:[0@0]! !!FormCanvas methodsFor: 'initialize-release' stamp: 'ar 2/17/2000 00:21'!reset	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	self shadowColor: nil.! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 13:58'!contentsOfArea: aRectangle into: aForm	self flush.	self form 		displayOn: aForm 		at:  (aRectangle origin + origin) negated		clippingBox: (0@0 extent: aRectangle extent).	^aForm! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 00:26'!shadowColor	^shadowColor! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 00:26'!shadowColor: aColor	shadowColor _ aColor! !!FormCanvas methodsFor: 'testing' stamp: 'ar 2/17/2000 00:24'!isShadowDrawing	^ self shadowColor notNil! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/16/2000 22:37'!fillColor: c	"Note: This always fills, even if the color is transparent."	self setClearColor: c.	port fillRect: form boundingBox.! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:12'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	self setPaintColor: Color black.	port sourceForm: brush; fillColor: nil;		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/16/2000 22:07'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	self setFillColor: c.	port width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:23'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ port displayScannerFor: para		foreground: (self shadowColor ifNil:[c]) background: Color transparent		ignoreColorChanges: self shadowColor notNil.	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:34'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	self setPaintColor: aColor.	port colorMap: (Color maskingMap: stencilForm depth).	port stencil: stencilForm		at: aPoint + origin		sourceRect: sourceRect.! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:19'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (self shadowColor ifNil:[c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 2/17/2000 00:16'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	sourceQuad _ (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!FormCanvas methodsFor: 'private' stamp: 'ar 2/16/2000 23:50'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	port colorMap: (aForm colormapIfNeededForDepth: form depth); fillColor: nil.	port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule.! !!FormCanvas methodsFor: 'private' stamp: 'ar 2/17/2000 14:16'!setClearColor: aColor	"Install a new clear color - e.g., a color is used for clearing the background"	aColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form over].	"Okay, so aColor really *is* a color"	port sourceForm: nil.	port combinationRule: Form over.	port fillPattern: aColor.! !!FormCanvas methodsFor: 'private' stamp: 'ar 2/17/2000 14:48'!setFillColor: aColor	"Install a new color used for filling."	| screen patternWord fillColor |	fillColor _ self shadowColor ifNil:[aColor].	fillColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse:[		port combinationRule: Form over.		^port fillPattern: fillColor].	"fillColor is some translucent color"	self depth > 8 ifTrue:[		"We can represent actual transparency"		port fillPattern: fillColor.		self depth = 16			ifTrue:[port alphaBits: fillColor privateAlpha; combinationRule: 30]			ifFalse:[port combinationRule: Form blend].		^self].	"Less than 16bit depth -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ fillColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!FormCanvas methodsFor: 'private' stamp: 'ar 2/17/2000 14:54'!setPaintColor: aColor	"Install a new color used for filling."	| paintColor screen patternWord |	paintColor _ self shadowColor ifNil:[aColor].	paintColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form paint].	"Okay, so paintColor really *is* a color"	port sourceForm: nil.	(paintColor isTranslucent) ifFalse:[		port fillPattern: paintColor.		^port combinationRule: Form paint].	self depth < 16 ifTrue:[		screen _ Color translucentMaskFor: paintColor alpha depth: self depth.		patternWord _ paintColor pixelWordForDepth: self depth.		port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).		^port combinationRule: Form paint].	port fillPattern: paintColor.	self depth = 16		ifTrue:[port alphaBits: paintColor privateAlpha; combinationRule: 31]		ifFalse:[port combinationRule: Form blend].! !!FormCanvas methodsFor: 'converting' stamp: 'ar 2/17/2000 00:17'!asShadowDrawingCanvas	"Note: This is sort of an optimization here since since the logic is all there"	^self copy shadowColor: (Color black alpha: 0.5)! !!FormCanvas methodsFor: 'converting' stamp: 'ar 2/17/2000 00:16'!asShadowDrawingCanvas: aColor	"Note: This is sort of an optimization here since since the logic is all there"	^self copy shadowColor: aColor! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/17/2000 00:22'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isBitmapFill and:[aFillStyle isKindOf: InfiniteForm]) ifTrue:[		self flag: #fixThis.		^self fillRectangle: aRectangle color: aFillStyle].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self asBalloonCanvas fillRectangle: aRectangle fillStyle: aFillStyle.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/17/2000 14:43'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	rect _ r translateBy: origin.	"draw the border of the rectangle"	borderColor isTransparent ifFalse:[		self setFillColor: borderColor.		(r area > 10000 or: [fillColor isTranslucent]) ifTrue: [			port frameRect: rect borderWidth: borderWidth.		] ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle					than to compute and fill the border rects"					port fillRect: rect]].	"fill the inside"	fillColor isTransparent ifFalse:		[self setFillColor: fillColor.		port fillRect: (rect insetBy: borderWidth)].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/16/2000 22:07'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		self setFillColor: bottomRightColor.		port 			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'ar 2/16/2000 22:42'!fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	"draw the border of the oval"	rect _ r translateBy: origin.	borderColor isTransparent ifFalse:[		self setFillColor: borderColor.		(r area > 10000 or: [fillColor isTranslucent]) 			ifTrue: [port frameOval: rect borderWidth: borderWidth]			ifFalse: [port fillOval: rect]]. "faster this way"	"fill the inside"	fillColor isTransparent ifFalse:		[self setFillColor: fillColor.		port fillOval: (rect insetBy: borderWidth)].! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'ar 2/17/2000 00:22'!fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Fill the given oval."	self shadowColor ifNotNil:		[^self fillOval: aRectangle color: self shadowColor borderWidth: bw borderColor: bc].	(aFillStyle isBitmapFill and:[aFillStyle isKindOf: InfiniteForm]) ifTrue:[		self flag: #fixThis.		^self fillOval: aRectangle color: aFillStyle borderWidth: bw borderColor: bc].	(aFillStyle isSolidFill) ifTrue:[		^self fillOval: aRectangle color: aFillStyle asColor borderWidth: bw borderColor: bc].	"Use a BalloonCanvas instead"	self asBalloonCanvas fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc! !!FormCanvas methodsFor: 'drawing-polygons' stamp: 'ar 2/17/2000 00:19'!drawPolygon: vertices fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Use a BalloonCanvas"	self asBalloonCanvas 		drawPolygon: vertices 		fillStyle: (self shadowColor ifNil:[aFillStyle])		borderWidth: bw 		borderColor: bc! !!FormCanvas methodsFor: 'object fileIn' stamp: 'ar 2/17/2000 15:05'!converttfocsfps0: varDict tfocfps0: smartRefStrm	"These variables are automatically stored into the new instance ('origin' 'clipRect' 'form' 'port' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('shadowColor' )  If a non-nil value is needed, please assign it."	"These are going away ('shadowDrawing' 'shadowStipple' ).  Possibly store their info in another variable?"! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:25'!drawBezierShape: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a boundary shape that is defined by a list of vertices.	Each three subsequent vertices define a quadratic bezier segment.	For lines, the control point should be set to either the start or the end	of the bezier curve."	| fillC borderC |	fillC _ self shadowColor ifNil:[c].	borderC _ self shadowColor ifNil:[borderColor].	self ensuredEngine		drawBezierShape: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawGeneralBezierShape: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general boundary shape (e.g., possibly containing holes)"	| fillC borderC |	fillC _ self shadowColor ifNil:[c].	borderC _ self shadowColor ifNil:[borderColor].	self ensuredEngine		drawGeneralBezierShape: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawGeneralPolygon: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general polygon (e.g., a polygon that can contain holes)"	| fillC borderC |	fillC _ self shadowColor ifNil:[c].	borderC _ self shadowColor ifNil:[borderColor].	self ensuredEngine		drawGeneralPolygon: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw the oval defined by the given rectangle"	| fillC borderC |	fillC _ self shadowColor ifNil:[c].	borderC _ self shadowColor ifNil:[borderColor].	self ensuredEngine		drawOval: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawRectangle: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw a rectangle"	| fillC borderC |	fillC _ self shadowColor ifNil:[c].	borderC _ self shadowColor ifNil:[borderColor].	self ensuredEngine		drawRectangle: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 2/12/2000 18:13'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	| warp dstRect srcQuad dstOffset center |	(self ifNoTransformWithIn: sourceRect) & false		ifTrue:[^super image: aForm at: aPoint sourceRect: sourceRect rule: rule].	dstRect _ (transform localBoundsToGlobal: (aForm boundingBox translateBy: aPoint)).	dstOffset _ 0@0. "dstRect origin."	"dstRect _ 0@0 corner: dstRect extent."	center _ 0@0."transform globalPointToLocal: dstRect origin."	srcQuad _ transform globalPointsToLocal: (dstRect innerCorners).	srcQuad _ srcQuad collect:[:pt| pt - aPoint].	warp _ (WarpBlt toForm: Display)			sourceForm: aForm;			cellSize: 2;  "installs a new colormap if cellSize > 1"			combinationRule: Form over.	warp copyQuad: srcQuad toRect: (dstRect translateBy: dstOffset).	self frameRectangle: (aForm boundingBox translateBy: aPoint) color: Color green.	"... TODO ... create a bitmap fill style from the form and use it for a simple rectangle."! !!BalloonCanvas methodsFor: 'drawing-polygons' stamp: 'ar 2/17/2000 00:25'!drawPolygon: vertices fillStyle: aFillStyle borderWidth: borderWidth borderColor: borderColor	"Draw a simple polygon defined by the list of vertices."	| fillC borderC |	fillC _ self shadowColor ifNil:[aFillStyle].	borderC _ self shadowColor ifNil:[borderColor].	self ensuredEngine		drawPolygon: (vertices copyWith: vertices first)		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 2/17/2000 00:15'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		subCanvas _ self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect.		aBlock value: subCanvas.		foundMorph _ subCanvas foundMorph.		^self	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal:					(self clipRect intersect: innerRect).	sourceQuad _ (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ ColorPatchCanvas extent: patchRect extent depth: self depth.		subCanvas stopMorph: stopMorph.		subCanvas foundMorph: foundMorph.		subCanvas doStop: doStop.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		i = 2 ifTrue:[foundMorph _ subCanvas foundMorph].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 2/17/2000 00:17'!test3	"FormCanvas test3"	| baseCanvas |	baseCanvas _ FormCanvas extent: 200@200.	baseCanvas fillColor: Color white.	baseCanvas translateBy: 10@10 during:[:canvas|		canvas shadowColor: (Color black alpha: 0.5).		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0.	].! !!GradientFillMorph methodsFor: 'drawing' stamp: 'ar 2/17/2000 02:01'!drawOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| style |	super drawOn: aCanvas.	(color isKindOf: Color) ifFalse: [^ self].  "An InfiniteForm, for example"	(color = Color transparent) ifTrue: [^ self].  "Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^ self].  "same color; no gradient"	style _ GradientFillStyle ramp: {0.0 -> color. 1.0 -> fillColor2}.	style origin: self position.	style direction: (gradientDirection == #vertical 		ifTrue:[0@self height] 		ifFalse:[self width@0]).	aCanvas fillRectangle: self innerBounds fillStyle: style.! !!GrafPort reorganize!('accessing' alphaBits: displayScannerFor:foreground:background:ignoreColorChanges: fillPattern:)('drawing support' fillOval: fillRect: frameOval:borderWidth: frameRect:borderWidth: frameRectBottom:height: frameRectRight:width: image:at:sourceRect:rule: stencil:at:sourceRect:)('copying' clippedBy: copyBits)('object fileIn' convertdshcddwhsscccccla0:dshcddwhsscccccaf0:)!!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:07'!alphaBits: a	alpha _ a! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:08'!displayScannerFor: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setDestForm: destForm sourceForm: destForm			fillColor: halftoneForm combinationRule: combinationRule			destOrigin: 0@0 sourceOrigin: 0@0			extent: 0@0 clipRect: self clipRect;		alphaBits: alpha! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:09'!fillPattern: anObject	fillPattern _ anObject.	self fillColor: anObject.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:32'!fillOval: rect	| centerX centerY nextY yBias xBias outer nextOuterX |	rect area <= 0 ifTrue: [^ self].	height _ 1.	yBias _ rect height odd ifTrue: [0] ifFalse: [-1].	xBias _ rect width odd ifTrue: [1] ifFalse: [0].	centerX _ rect center x.	centerY _ rect center y.	outer _ EllipseMidpointTracer new on: rect.	nextY _ rect height // 2.	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		width _ (nextOuterX bitShift: 1) + xBias.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		self copyBits.		destY _ centerY + nextY + yBias.		self copyBits.		nextY _ nextY - 1.	].	destY _ centerY.	height _ 1 + yBias.	width _ rect width.	destX _ rect left.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:38'!fillRect: rect	| fc |	fillPattern class == InfiniteForm ifTrue:[		fc _ halftoneForm.		self fillColor: nil.		fillPattern displayOnPort: ((self clippedBy: rect) colorMap: nil) at: rect origin.		halftoneForm _ fc.		^self].	destX _ rect left.	destY _ rect top.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:26'!frameOval: rect borderWidth: borderWidth	| centerX centerY nextY yBias xBias wp outer inner nextOuterX nextInnerX fillAlpha |	rect area <= 0 ifTrue: [^ self].	height _ 1.	wp _ borderWidth asPoint.	yBias _ rect height odd ifTrue: [0] ifFalse: [-1].	xBias _ rect width odd ifTrue: [1] ifFalse: [0].	centerX _ rect center x.	centerY _ rect center y.	outer _ EllipseMidpointTracer new on: rect.	inner _ EllipseMidpointTracer new on: (rect insetBy: wp).	nextY _ rect height // 2.	1 to: (wp y min: nextY) do:[:i|		nextOuterX _ outer stepInY.		width _ (nextOuterX bitShift: 1) + xBias.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		self copyBits.		destY _ centerY + nextY + yBias.		self copyBits.		nextY _ nextY - 1.	].	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		nextInnerX _ inner stepInY.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		width _ nextOuterX - nextInnerX.		self copyBits.		destX _ centerX + nextInnerX + xBias.		self copyBits.		destX _ centerX - nextOuterX.		destY _ centerY + nextY + yBias.		self copyBits.		destX _ centerX + nextInnerX + xBias.		self copyBits.		nextY _ nextY - 1.	].	destY _ centerY.	height _ 1 + yBias.	width _ wp x.	destX _ rect left.	self copyBits.	destX _ rect right - wp x.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 14:44'!frameRect: rect borderWidth: borderWidth	sourceX _ 0.	sourceY _ 0.	(rect areasOutside: (rect insetBy: borderWidth)) do:		[:edgeStrip | self destRect: edgeStrip; copyBits].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectBottom: rect height: h	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectRight: rect width: w	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm _ aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 00:31'!stencil: stencilForm at: aPoint sourceRect: aRect	"Paint using aColor wherever stencilForm has non-zero pixels"	self sourceForm: stencilForm;		destOrigin: aPoint;		sourceRect: aRect.	self copyBits! !!GrafPort methodsFor: 'copying' stamp: 'ar 2/17/2000 01:07'!clippedBy: aRectangle	^ self copy clipRect: (self clipRect intersect: aRectangle)! !!GrafPort methodsFor: 'copying' stamp: 'ar 2/17/2000 01:07'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31])		ifTrue: [alpha == nil					ifTrue: [self copyBitsTranslucent: 255]					ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !!GrafPort methodsFor: 'object fileIn' stamp: 'ar 2/17/2000 15:05'!convertdshcddwhsscccccla0: varDict dshcddwhsscccccaf0: smartRefStrm	"These variables are automatically stored into the new instance ('alpha' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('fillPattern' )  If a non-nil value is needed, please assign it."	"These are going away ('lastColor' ).  Possibly store their info in another variable?"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:05'!drawOn: aCanvas	"Draw the hand itself (i.e., the cursor)."	temporaryCursor == nil		ifTrue: [aCanvas paintImage: NormalCursor at: bounds topLeft]		ifFalse: [aCanvas paintImage: temporaryCursor at: bounds topLeft].	userInitials size > 0 ifTrue:		[aCanvas text: userInitials					at: (self cursorBounds topRight + (0@4))					font: nil color: color].! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/17/2000 14:51'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvasDepth: aCanvas depth.	(cacheCanvas == nil or: [aCanvas depth = 1]) ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles == true "bulletproofing against nil value, which can happen"			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	aCanvas paintImage: cacheCanvas form at: subBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/17/2000 14:49'!nonCachingFullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	| shadowForm |	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		shadowForm _ self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."		shadowCanvas paintImage: shadowForm at: shadowForm offset.  "draw shadows"	].	"draw morphs in front of shadows"	self drawSubmorphsOn: aCanvas.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas depth = 1			ifTrue: [aCanvas drawImage: savedPatch at: savedPatch offset]			ifFalse: [aCanvas paintImage: savedPatch at: savedPatch offset].		((userInitials size = 0) and:		 [(submorphs size = 0) and:		 [temporaryCursor == nil]]) ifTrue: [			"Make the transition to using hardware cursor. Clear savedPatch and			 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).			Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].  "show hardware cursor"			savedPatch _ nil]].! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/17/2000 14:37'!shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m bounds]).	canvas _ (FormCanvas extent: bnds extent depth: 1) asShadowDrawingCanvas.	canvas translateBy: bnds topLeft negated		during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].	^ canvas form offset: bnds topLeft! !!ImageMorph methodsFor: 'other' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	aCanvas paintImage: image at: bounds origin.! !!ImageMorphWithSpotlight methodsFor: 'all' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	super drawOn: aCanvas.	spotOn ifTrue:		[aCanvas paintImage: spotBuffer at: spotBuffer offset].! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:34'!drawToggleOn: aCanvas in: aRectangle	| aForm |	aCanvas 		fillRectangle: (bounds withRight: aRectangle right)		color: container color.	complexContents hasContents ifFalse: [^self].	aForm _ isExpanded 		ifTrue: [container expandedForm]		ifFalse: [container notExpandedForm].	^aCanvas 		paintImage: aForm 		at: aRectangle topLeft! !!InterpolatingImageMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	aCanvas paintImage: (self cachedImageForDepth: aCanvas depth) at: self topLeft! !!MagnifierMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	super drawOn: aCanvas.		"border and fill"	aCanvas isShadowDrawing ifFalse: [		"Optimize because #magnifiedForm is expensive"		aCanvas paintImage: self magnifiedForm at: self innerBounds origin]! !!MenuItemMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	| selectionColor |	selectionColor _ Display depth <= 2						ifTrue: [Color gray]						ifFalse: [owner color darker].	(isSelected & isEnabled) ifTrue: [		aCanvas fillRectangle: self bounds color: selectionColor].	super drawOn: aCanvas.	subMenu == nil ifFalse: [		aCanvas			paintImage: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))].! !!PasteUpMorph methodsFor: 'display' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	turtleTrailsForm ifNotNil: [aCanvas paintImage: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 2/12/2000 18:06'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ self damageRecorder invalidRectsFullBounds: ("0@0 extent:" self viewBox "extent").	self damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color.				turtleTrailsForm ifNotNil: [c paintImage: turtleTrailsForm at: 0@0]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				turtleTrailsForm ifNotNil: [c paintImage: turtleTrailsForm at: 0@0].				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!PolygonMorph methodsFor: 'private' stamp: 'ar 2/17/2000 00:16'!borderForm	"A form must be created for drawing the border whenever the borderColor is translucent."	| borderCanvas |	borderForm ifNotNil: [^ borderForm].	borderCanvas _ (FormCanvas extent: bounds extent depth: 1)		shadowColor: Color black.	borderCanvas translateBy: bounds topLeft negated		during:[:tempCanvas| self drawBorderOn: tempCanvas].	borderForm _ borderCanvas form.	self arrowForms do:		[:f |  "Eliminate overlap between line and arrowheads if transparent."		borderForm copy: f boundingBox from: f to: f offset - self position rule: Form erase].	^ borderForm! !!RemoteHandMorph methodsFor: 'other' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	"For remote cursors, always draw the hand itself (i.e., the cursor)."	super drawOn: aCanvas.	aCanvas paintImage: NormalCursor at: self position.! !!ScreeningMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:07'!fullDrawOn: aCanvas	| mergeForm |	submorphs size = 0 ifTrue: [^ super fullDrawOn: aCanvas].	(submorphs size = 1 or: [displayMode == #showScreenOnly]) ifTrue:		[^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showSourceOnly ifTrue:		[^ aCanvas fullDrawMorph: self sourceMorph].	displayMode == #showScreenOverSource ifTrue:		[aCanvas fullDrawMorph: self sourceMorph.		^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showScreened ifTrue:		[aCanvas fullDrawMorph: self screenMorph.		self flag: #fixCanvas. "There should be a more general way than this"		mergeForm _ self sourceMorph imageFormForRectangle: self screenMorph bounds.		(BitBlt toForm: mergeForm) copyForm: self screenForm to: 0@0 rule: Form and			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas paintImage: mergeForm at: self screenMorph position]! !!ShadowDrawingCanvas methodsFor: 'private' stamp: 'ar 2/12/2000 18:13'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the given form. For the 'paint' combination rule use stenciling otherwise simply fill the source rectangle."	rule = Form paint ifTrue:[		^myCanvas			stencil: aForm			at: aPoint			sourceRect: sourceRect			color: shadowColor	] ifFalse:[		^myCanvas			fillRectangle: (sourceRect translateBy: aPoint)			color: shadowColor	].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	"Put the painting on the display"	paintingForm ifNotNil: [		aCanvas paintImage: paintingForm at: bounds origin]. ! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 2/12/2000 18:35'!restoreRect: oldRect	"Restore the given rectangular area of the painting Form from the undo buffer."	formCanvas drawImage: undoBuffer		at: oldRect origin		sourceRect: (oldRect translateBy: self topLeft negated).	self invalidRect: oldRect.! !!SketchMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	aCanvas paintImage: self rotatedForm at: bounds origin.! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'ar 2/17/2000 01:14'!buildChartForm        | chartForm transText |        chartForm _ ColorChart deepCopy asFormOfDepth: Display depth.        true "Display depth >= 16" ifTrue:                [chartForm fill: ((TransparentBox left + 9)@0 extent: 1@9) fillColor: Color lightGray.                chartForm fill: ((TransparentBox right - 10)@0 extent: 1@9) fillColor: Color lightGray.                transText _ (Form extent: 63@9 depth: 1   "Where there's a will there's a way..."                                        fromArray: #( 0 0 4194306 1024 4194306 1024 15628058 2476592640                                                                        4887714 2485462016 1883804850 2486772764 4756618                                                                        2485462016 4748474 1939416064 0 0)                                        offset: 0@0).                transText displayOn: chartForm at: 62@0.                Display depth = 32 ifTrue:                        ["Set opaque bits for 32-bit display"                        chartForm fill: chartForm boundingBox rule: Form under                                        fillColor: (Color r: 0.0 g: 0.0 b: 0.0 alpha: 1.0)]].        chartForm borderWidth: 1.        self form: chartForm.        self updateSelectorDisplay.! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 2/17/2000 01:12'!pickColorAt: aPoint 	"RAA 27 Nov 99 - aPoint is global, so no need to add viewbox topleft"	| worldBox globalP c alpha localPt |	localPt _ aPoint - self topLeft.	(FeedbackBox containsPoint: localPt) ifTrue: [^ self].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"pick up color, either inside or outside this world"	worldBox _ self world viewBox.	globalP _ aPoint 		"+ worldBox topLeft".	"get point in screen coordinates"	(worldBox containsPoint: globalP)		ifTrue: [c _ self world colorAt: aPoint belowMorph: Morph new]		ifFalse: [c _ Display colorAt: globalP].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: localPt)		ifTrue: [alpha _ (aPoint x - bounds left - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"					self updateColor: (selectedColor alpha: alpha)						feedbackColor: (selectedColor alpha: alpha)]		ifFalse: [self updateColor: ((selectedColor isColor and: [selectedColor isTranslucentColor])					ifTrue: [c alpha: selectedColor alpha]					ifFalse: [c])				feedbackColor: c]! !!FatBitsPaint methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2000 18:40'!drawOn: aCanvas	| f |	f _ self rotatedForm.	backgroundColor ifNotNil: [aCanvas fillRectangle: bounds fillStyle: backgroundColor].	aCanvas translucentImage: f at: bounds origin.! !!TextContainer methodsFor: 'private' stamp: 'ar 2/17/2000 00:16'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (FormCanvas extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: tempCanvas]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back _ tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [m fullDrawOn: tempCanvas]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!ThreePhaseButtonMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	state == #off ifTrue: [		offImage ifNotNil: [aCanvas paintImage: offImage at: bounds origin]].	state == #pressed ifTrue: [		pressedImage ifNotNil: [aCanvas paintImage: pressedImage at: bounds origin]].	state == #on ifTrue: [		image ifNotNil: [aCanvas paintImage: image at: bounds origin]].! !!ThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee viewedMorphBox myBox scale c shrunkForm aWorld |	super drawOn: aCanvas.	((((actualViewee _ self actualViewee) ~~ nil and: [(aWorld _ actualViewee world) ~~ nil])			and: [aWorld ~~ actualViewee or: [lastFormShown == nil]]) and: [RecursionDepth + 1 < RecursionMax])		ifTrue:			[RecursionDepth _ RecursionDepth + 1.			viewedMorphBox _ actualViewee fullBounds.			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.			c translateBy: viewedMorphBox topLeft negated 				"recursion happens here"				during:[:tempCanvas| actualViewee fullDrawOn: tempCanvas].			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:  "This branch used if we've recurred, or if the thumbnail views a World that's already been rendered once, or if the referent is not in a world at the moment"			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas paintImage: shrunkForm at: self center - shrunkForm boundingBoxcenter]	"sw 12/20/1999 13:35 special-case code for SketchMorph commented out, since it seems to have done more harm than good: 			((actualViewee isKindOf: SketchMorph) and: [false])				ifTrue:					[diag _ actualViewee form extent  asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds]."! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:01'!drawDissolveOn: aCanvas	"startForm and endFrom are both fixed, but the dissolve ration changes."	startForm copyBits: endForm at: 0@0 translucent: stepNumber asFloat / (nSteps*2).	aCanvas drawImage: startForm at: self position.! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:01'!drawFrenchDoorOn: aCanvas	"startForm and endFrom are both fixed, but a border expands out from a vertical (or H) slit, revealing endForm.	It's like opening a pair of doors."	| box innerForm outerForm boxExtent h w |	h _ self height. w _ self width.	direction = #in ifTrue: [innerForm _ endForm.  outerForm _ startForm.							boxExtent _ self stepFrom: 0@h to: self extent].	direction = #out ifTrue: [innerForm _ startForm.  outerForm _ endForm.							boxExtent _ self stepFrom: self extent to: 0@h].	direction = #inH ifTrue: [innerForm _ endForm.  outerForm _ startForm.							boxExtent _ self stepFrom: w@0 to: self extent].	direction = #outH ifTrue: [innerForm _ startForm.  outerForm _ endForm.							boxExtent _ self stepFrom: self extent to: w@0].			aCanvas drawImage: outerForm at: self position.	box _ Rectangle center: self center extent: boxExtent.	aCanvas drawImage: innerForm at: box topLeft sourceRect: (box translateBy: self position negated).	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:01'!drawPageBackOn: aCanvas	"endForm grows in the given direction, overlaying endForm."	| offset growRect scale |	aCanvas drawImage: startForm at: self position.	offset _ self stepFrom: self extent * direction negated to: 0@0.	growRect _ (bounds translateBy: offset) intersect: bounds.	scale _ growRect extent asFloatPoint / bounds extent.	aCanvas drawImage: (endForm magnify: endForm boundingBox by: scale smoothing: 1)		at: growRect topLeft.	((growRect translateBy: direction) areasOutside: growRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawPageForwardOn: aCanvas	"startForm shrinks in the given direction, revealing endForm."	| offset shrinkRect scale |	aCanvas drawImage: endForm at: self position.	offset _ self stepFrom: 0@0 to: self extent * direction.	shrinkRect _ (bounds translateBy: offset) intersect: bounds.	scale _ shrinkRect extent asFloatPoint / bounds extent.	aCanvas drawImage: (startForm magnify: startForm boundingBox by: scale smoothing: 1)		at: shrinkRect topLeft.	((shrinkRect translateBy: direction negated) areasOutside: shrinkRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawSlideAwayOn: aCanvas	"startMorph slides away in the given direction, revealing up the endMorph."	| startLoc moveRect |	startLoc _ self stepFrom: self position to: self position + (self extent * direction).	moveRect _ startForm boundingBox translateBy: startLoc.	aCanvas drawImage: endForm at: self position.	aCanvas drawImage: startForm at: startLoc.	((moveRect translateBy: direction negated) areasOutside: moveRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawSlideBorderOn: aCanvas	"startForm and endFrom are both fixed, but a border slides in the given direction, revealing endForm.  (It's like opening a can of sardines ;-)."	| endRect box sourceRect boxLoc |	box _ endForm boundingBox.	boxLoc _ self stepFrom: box topLeft - (box extent * direction) to: box topLeft.	sourceRect _ box translateBy: boxLoc.	endRect _ sourceRect translateBy: self position.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas drawImage: startForm at: self position].	aCanvas drawImage: endForm at: self position + boxLoc sourceRect: sourceRect.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawSlideBothOn: aCanvas	"endMorph slides in the given direction, as startMorph slides out of its way."	| endLoc endRect startLoc |	startLoc _ self stepFrom: self position to: self position + (self extent * direction).	aCanvas drawImage: startForm at: startLoc.	endLoc _ self stepFrom: self position - (self extent * direction) to: self position.	aCanvas drawImage: endForm at: endLoc.	endRect _ endForm boundingBox translateBy: endLoc.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:03'!drawSlideOverOn: aCanvas	"endMorph slides in the given direction, covering up the startMorph."	| endLoc endRect |	endLoc _ self stepFrom: self position - (self extent * direction) to: self position.	endRect _ endForm boundingBox translateBy: endLoc.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas drawImage: startForm at: self position].	aCanvas drawImage: endForm at: endLoc.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:03'!drawZoomFrameOn: aCanvas	"startForm and endFrom are both fixed, but a square border expands out from the center (or back), revealing endForm.	It's like passing through a portal."	| box innerForm outerForm boxExtent |	direction = #in		ifTrue: [innerForm _ endForm.  outerForm _ startForm.				boxExtent _ self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm _ startForm.  outerForm _ endForm.				boxExtent _ self stepFrom: self extent to: 0@0].			aCanvas drawImage: outerForm at: self position.	box _ Rectangle center: self center extent: boxExtent.	aCanvas drawImage: innerForm at: box topLeft sourceRect: (box translateBy: self position negated).	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:03'!drawZoomOn: aCanvas	"Zoom in: endForm expands overlaying startForm.	Zoom out: startForm contracts revealing endForm."	| box innerForm outerForm boxExtent scale |	direction = #in		ifTrue: [innerForm _ endForm.  outerForm _ startForm.				boxExtent _ self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm _ startForm.  outerForm _ endForm.				boxExtent _ self stepFrom: self extent to: 0@0].	aCanvas drawImage: outerForm at: self position.	box _ Rectangle center: self center extent: boxExtent.	scale _ box extent asFloatPoint / bounds extent.	aCanvas drawImage: (innerForm magnify: innerForm boundingBox by: scale smoothing: 1)		at: box topLeft.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!URLMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." | thumbnail oldExt |color == Color transparent 	ifTrue: ["show thumbnail"		thumbnail _ self thumbnailOrNil.		thumbnail			ifNil: [aCanvas frameRectangle: bounds width: borderWidth 						color: borderColor.				aCanvas fillRectangle: (bounds insetBy: borderWidth) color: color]			ifNotNil: [oldExt _ bounds extent.				bounds _ bounds origin extent: thumbnail extent + (2@2).				aCanvas frameRectangle: bounds width: borderWidth color: borderColor.				aCanvas paintImage: thumbnail at: bounds origin + borderWidth.				oldExt = thumbnail extent ifFalse: [self layoutChanged]]]	ifFalse: ["show labeled button"		^ super drawOn: aCanvas]! !FormCanvas removeSelector: #translucentImage:at:sourceRect:!FormCanvas removeSelector: #setShadowDrawing!FormCanvas removeSelector: #fillRectangle:color:!FormCanvas removeSelector: #newClearColor:!FormCanvas removeSelector: #defeatShadowDrawing!FormCanvas removeSelector: #paintImage:at:sourceRect:!FormCanvas removeSelector: #nonShadowCopy!FormCanvas removeSelector: #clearColor:!FormCanvas removeSelector: #drawColor:!FormCanvas removeSelector: #primaryColor!FormCanvas removeSelector: #fillOval:color:!FormCanvas removeSelector: #drawRule:color:!FormCanvas removeSelector: #stipple!FormCanvas removeSelector: #copyForShadowDrawingOffset:!FormCanvas removeSelector: #frameRectangle:width:color:!FormCanvas removeSelector: #newFillColor:!FormCanvas removeSelector: #primaryColor:!FormCanvas removeSelector: #stipple:!FormCanvas removeSelector: #drawImage:at:sourceRect:!FormCanvas removeSelector: #stencil:at:color:!FormCanvas removeSelector: #frameOval:width:color:!BalloonCanvas removeSelector: #drawColor:!GradientFillMorph removeSelector: #drawPostscriptOn:!GradientFillMorph removeSelector: #colorArrayForDepth:!GradientFillMorph removeSelector: #releaseCachedState!GradientFillMorph removeSelector: #loadCachedState!GradientFillMorph removeSelector: #colorsArray!GradientFillMorph removeSelector: #stepSize!GrafPort removeSelector: #displayScannerFor:foreground:background:rule:halftone:ignoreColorChanges:!GrafPort removeSelector: #fillRect:offset:!GrafPort removeSelector: #fillOval:color:borderWidth:borderColor:borderRule:!GrafPort removeSelector: #fillColor:!GrafPort removeSelector: #alpha:!GrafPort removeSelector: #stencil:at:fillColor:rule:!GrafPort removeSelector: #stencil:at:sourceRect:fillColor:rule:!GrafPort removeSelector: #frameRect:borderWidth:borderColor:!GrafPort removeSelector: #stencil:at:!GrafPort removeSelector: #fillRect:color:offset:!"Postscript:After we've installed everything reshape the classes to its new form."Canvas subclass: #FormCanvas	instanceVariableNames: 'origin clipRect form port shadowColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'.BitBlt subclass: #GrafPort	instanceVariableNames: 'alpha fillPattern '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'.