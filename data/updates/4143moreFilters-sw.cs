'From Squeak3.1alpha of 28 February 2001 [latest update: #4140] on 6 June 2001 at 3:21:18 pm'!"Change Set:		moreFilters-swDate:			6 June 2001Author:			Scott WallaceImplements six further filters for the little-talked-about 'filter-message-set' feature, including an item that allows you to type in a filtering block on the fly.Provides balloon help for all the filtration items."!!ChangeList methodsFor: 'menu actions' stamp: 'sw 6/6/2001 12:54'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | aChange _ changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass _ aChange methodClass) notNil				and: [ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 6/6/2001 12:51'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangeSorter class methodsFor: 'services' stamp: 'sw 6/6/2001 12:52'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 14:40'!filterMessageList	"Allow the user to refine the list of messages."	| aMenu evt |	Smalltalk isMorphic ifFalse: [^ self inform: 'sorry, morphic only at this time.'].	messageList size <= 1 ifTrue: [^ self inform: 'this is not a propitious filtering situation'].	"would like to get the evt coming in but thwarted by the setInvokingView: circumlocution"	evt _ self currentWorld activeHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Filter by only showing...'.	aMenu addStayUpItem.	aMenu addList: #(		('messages that send...'					filterToSendersOf			'filter to show only messages that send a selector I specify')		('unsent messages'						filterToUnsentMessages		'filter to show only messages that have no senders')		-		('messages in current change set'		filterToCurrentChangeSet	'filter to show only messages that are in the current change set')		('messages not in current change set'	filterToNotCurrentChangeSet	'filter to show only messages that are not in the current change set')		-		('messages in any change set'			filterToAnyChangeSet		'filter to show only messages that occur in at least one change set')		('messages not in any change set'		filterToNotAnyChangeSet		'filter to show only messages that do not occur in any change set in the system')		-		('messages authored by me'				filterToCurrentAuthor		'filter to show only messages whose authoring stamp has my initials')		('messages not authored by me'			filterToNotCurrentAuthor	'filter to show only messages whose authoring stamp does not have my initials')		-		('messages logged in .changes file'		filterToMessagesInChangesFile	'filter to show only messages whose latest source code is logged in the .changes file')		('messages only in .sources file'			filterToMessagesInSourcesFile	'filter to show only messages whose latest source code is logged in the .sources file')		-		('messages with prior versions'			filterToMessagesWithPriorVersions	'filter to show only messages that have at least one prior version')		('messages without prior versions'		filterToMessagesWithoutPriorVersions	'filter to show only messages that have no prior versions')		-		('messages in hardened classes'			filterToMessagesWithHardenedClasses	'filter to show only messages of established classes (as opposed to Uniclasses such as Player23)')		-		('messages that...'						filterToMessagesThat			'let me type in a block taking a class and a selector, which will specify yea or nay concerning which elements should remain in the list')			).	aMenu popUpEvent: evt hand lastEvent in: evt hand world.! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 12:55'!filterToAnyChangeSet	"Filter down only to messages present in ANY change set"	self filterFrom:		[:aClass :aSelector |			ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector: aSelector]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:14'!filterToMessagesInChangesFile	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."	| cm |	self filterFrom:		[:aClass :aSelector |			aClass notNil and: [aSelector notNil and:				[(self class isPseudoSelector: aSelector) not and:					[(cm _ aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex ~~ 1]]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:15'!filterToMessagesInSourcesFile	"Filter down only to messages whose source code resides in the .sources file."	| cm |	self filterFrom: [:aClass :aSelector |		(aClass notNil and: [aSelector notNil]) and:			[(self class isPseudoSelector: aSelector) not and:				[(cm _ aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex == 1]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 14:10'!filterToMessagesThat	"Allow the user to type in a block which will be"	| reply |	reply _ FillInTheBlank		multiLineRequest: 'Type your block here'		centerAt: Sensor cursorPoint		initialAnswer: '[:aClass :aSelector |		]'		answerHeight: 200.	reply isEmptyOrNil ifTrue: [^ self].	self filterFrom: (Compiler evaluate: reply)! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:13'!filterToMessagesWithPriorVersions	"Filter down only to messages which have at least one prior version"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(self class isPseudoSelector: aSelector) not and:					[[(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 15:12'!filterToMessagesWithoutPriorVersions	"Filter down only to messages which have no prior version stored"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(self class isPseudoSelector: aSelector) not and:					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) <= 1]]]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/6/2001 13:07'!filterToNotAnyChangeSet	"Filter down only to messages present in NO change set"	self filterFrom:		[:aClass :aSelector |			(ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not]! !!MessageSet methodsFor: 'filtering' stamp: 'sw 6/5/2001 21:42'!filterToUnsentMessages	"Filter the receiver's list down to only those items which have no senders"	self filterFrom:		[:aClass :aSelector |			(Smalltalk allCallsOn: aSelector) size == 0]	! !