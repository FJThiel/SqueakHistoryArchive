'From Squeak 2.2 of Sept 23, 1998 on 23 October 1998 at 10:03:58 am'!"Change Set:		PaneBorderEditsDate:			23 October 1998Author:			Dan IngallsThis fileIn adds pane resizing to morphic windows.  The old code has been refactored and the new code shares rectangle functions with the MVC resizing logic.  Also fixed a couple of bugs in the logic for minimum pane size limits.This new code also eliminates sensitive morphs as the basis for spawning window resize handles.  Instead it uses enter and leave events from panes and the window as a whole.  This makes things simpler, and easier use as well.Also added a stopgap feature for editing window labels, simlar to that in MVC."!!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/22/1998 16:11'!adjustTo: newRect along: side 	"Return a copy adjusted to fit a neighbor that has changed size."	side = #left ifTrue: [^ self withRight: newRect left].	side = #right ifTrue: [^ self withLeft: newRect right].	side = #top ifTrue: [^ self withBottom: newRect top].	side = #bottom ifTrue: [^ self withTop: newRect bottom].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:00'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) < (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) < (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:11'!forPoint: aPoint closestSideDistLen: sideDistLenBlock	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side _ self sideNearestTo: aPoint.	side == #right ifTrue:		[^ sideDistLenBlock value: side value: (self right - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #left ifTrue:		[^ sideDistLenBlock value: side value: (self left - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #bottom ifTrue:		[^ sideDistLenBlock value: side value: (self bottom - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].	side == #top ifTrue:		[^ sideDistLenBlock value: side value: (self top - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09'!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft _ aPoint x - self left.	distToRight _ self right - aPoint x.	distToTop _ aPoint y - self top.	distToBottom _ self bottom - aPoint y.	closest _ distToLeft. side _ #left.	distToRight < closest ifTrue: [closest _ distToRight. side _ #right].	distToTop < closest ifTrue: [closest _ distToTop. side _ #top].	distToBottom < closest ifTrue: [closest _ distToBottom. side _ #bottom].	^ side" | r | r _ Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 10/23/1998 09:22'!mouseEnter: event	(owner isKindOf: SystemWindow) ifTrue:		[owner paneTransition: event].	(retractableScrollBar and: [(submorphs includes: scrollBar) not])		ifTrue: [self privateAddMorph: scrollBar atIndex: 1.				self resizeScrollBar.				scrollBar changed]! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 10/23/1998 09:24'!mouseLeave: event	retractableScrollBar ifTrue:		[self privateRemoveMorph: scrollBar.		scrollBar privateOwner: nil].	(owner isKindOf: SystemWindow) ifTrue:		[owner paneTransition: event]! !!SystemWindow reorganize!('initialization' initialize)('geometry' extent: justDroppedInto:event: labelRect panelRect position: setBoundsOfPaneMorphs setPaneRectsFromBounds)('label' label labelHeight relabel setLabel: setStripeColorsFrom: update:)('open/close' delete initialExtent openInMVC openInMVCExtent: openInWorld: openInWorldExtent: positionSubmorphs)('resize/collapse' collapseOrExpand collapsedFrame fullFrame isCollapsed paneWithLongestSide:near: reframePanesAdjoining:along:to: spawnPaneFrameHandle: spawnReframeHandle:)('top window' activate activeOnlyOnTop activeOnlyOnTop: isActive passivate)('panes' addMorph:frame: paneColor)('events' handlesMouseDown: mouseDown: mouseMove: mouseUp: paneTransition:)('stepping' step stepTime wantsSteps)('drawing' areasRemainingToFill:)!!SystemWindow methodsFor: 'initialization' stamp: 'di 10/22/1998 23:23'!initialize	| aFont |	super initialize.	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: aFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 16@16).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabel to: self.	self extent: 300@200! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/20/1998 16:45'!extent: newExtent	| inner labelRect paneColor |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/23/1998 09:39'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| panelRect |	panelRect _ self panelRect.	paneRects _ paneMorphs collect:		[:m | 		(m bounds translateBy: panelRect topLeft negated)			scaleBy: (1.0 asPoint / panelRect extent)]! !!SystemWindow methodsFor: 'label' stamp: 'di 10/22/1998 23:28'!setLabel: aString	labelString _ aString.	label ifNil: [^ self].	label contents: aString.	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: bounds topCenter + (0@borderWidth)! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/21/1998 16:12'!paneWithLongestSide: sideBlock near: aPoint 	| thePane theSide theLen box |	theLen _ 0.	paneMorphs do:		[:pane | box _ pane bounds.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[thePane _ pane.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ thePane! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 22:55'!reframePanesAdjoining: growingPane along: side to: aDisplayBox 	| delta newRect minDim theMin horiz |	growingPane ifNil: [^ self].  "As from click outside"	newRect _ aDisplayBox.	horiz _ #(left right) includes: side.	theMin _ horiz ifTrue: [40] ifFalse: [20].	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ (((paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side])		collect: [:pane | pane bounds adjustTo: newRect along: side]) copyWith: aDisplayBox)			inject: 999 into:				[:was :rect | was min: (horiz ifTrue: [rect width] ifFalse: [rect height])].	"If so, amend newRect as required"	minDim > theMin ifFalse:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (growingPane bounds perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	paneMorphs do:		[:pane | (pane bounds bordersOn: growingPane bounds along: side) ifTrue:			[pane bounds: (pane bounds adjustTo: newRect along: side)]].	"And adjust the growing pane itself"	growingPane bounds: newRect.	"Finally force a recomposition of the whole window"	self setPaneRectsFromBounds.	self extent: self extent! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 23:18'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds |	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			side = #top ifTrue: [newBounds _ growingPane bounds withTop: localPt y].			side = #bottom ifTrue: [newBounds _ growingPane bounds withBottom: localPt y].			side = #left ifTrue: [newBounds _ growingPane bounds withLeft: localPt x].			side = #right ifTrue: [newBounds _ growingPane bounds withRight: localPt x].			self reframePanesAdjoining: growingPane along: side to: newBounds]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/23/1998 09:59'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			ptName = #top ifTrue: [self bounds: (self bounds withTop: localPt y)].			ptName = #bottom ifTrue: [self bounds: (self bounds withBottom: localPt y)].			ptName = #left ifTrue: [self bounds: (self bounds withLeft: localPt x)].			ptName = #right ifTrue: [self bounds: (self bounds withRight: localPt x)].			ptName = #topLeft ifTrue: [self bounds: (self bounds bottomRight rect: localPt)].			ptName = #bottomRight ifTrue: [self bounds: (self bounds topLeft rect: localPt)].			ptName = #bottomLeft ifTrue: [self bounds: (self bounds topRight rect: localPt)].			ptName = #topRight ifTrue: [self bounds: (self bounds bottomLeft rect: localPt)]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'top window' stamp: 'di 10/20/1998 16:44'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph _ self topRendererOrSelf.	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self isCollapsed ifFalse:		[model modelWakeUp.		self positionSubmorphs]! !!SystemWindow methodsFor: 'top window' stamp: 'di 10/20/1998 16:46'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	self submorphsDo: [:m | m lock].! !!SystemWindow methodsFor: 'events' stamp: 'di 10/23/1998 09:22'!paneTransition: event	"Mouse has entered or left a pane"	^ self spawnReframeHandle: event! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect _ aDisplayBox.	theMin _ 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport _ nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen _ 0.	subViews do:		[:sub | box _ sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub _ sub.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ theSub! !Rectangle removeSelector: #forPoint:closestSideAndDist:!SystemWindow removeSelector: #updateIfOld!SystemWindow removeSelector: #addHandles!SystemWindow removeSelector: #addCustomMenuItems:hand:!SystemWindow removeSelector: #removeHandles!SystemWindow removeSelector: #enterHandle:morph:pointName:!SystemWindow removeSelector: #spawnHandle:!View removeSelector: #bordersOn:along:!StandardSystemView removeSelector: #newDisplayBoxFor:adjoining:along:!SystemWindow allInstancesDo: 	[:w |	(w submorphs select: [:m | m isMemberOf: Morph])		do: [:m | m delete].	w on: #mouseEnter send: #spawnReframeHandle: to: w.	w on: #mouseLeave send: #spawnReframeHandle: to: w.	(w instVarNamed: 'label') on: #mouseDown send: #relabel to: w]!