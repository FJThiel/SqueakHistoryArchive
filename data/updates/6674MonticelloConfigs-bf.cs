'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 30 June 2005 at 11:11:30 pm'!"Change Set:		MonticelloConfigurations-bf.30Date:			30 June 2005Author:			Doug WayInitial MonticelloConfigurations install, based on MonticelloConfigurations-bf.30.mcz from http://source.impara.de.  See http://tweak.impara.de/ABOUT/FAQ/MCConfigurationUpdates/ for details on usage."!Object subclass: #MCConfiguration	instanceVariableNames: 'name dependencies repositories log'	classVariableNames: 'DefaultLog'	poolDictionaries: ''	category: 'MonticelloConfigurations'!MCTool subclass: #MCConfigurationBrowser	instanceVariableNames: 'configuration dependencyIndex repositoryIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloConfigurations'!MCVersionReader subclass: #MCMcmReader	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloConfigurations'!MCWriter subclass: #MCMcmWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloConfigurations'!RWBinaryOrTextStream subclass: #MCPseudoFileStream	instanceVariableNames: 'localName'	classVariableNames: ''	poolDictionaries: ''	category: 'MonticelloConfigurations'!!MCPseudoFileStream commentStamp: '<historical>' prior: 0!A pseudo file stream which can be used for updates.!!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 22:09'!browse	(MCConfigurationBrowser new configuration: self) show! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 3/22/2005 10:51'!fileOutOn: aStream	self writerClass fileOut: self on: aStream! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19'!load	^self depsSatisfying: [:dep | dep isCurrent not]		versionDo: [:ver | ver load]		displayingProgress: 'loading packages'! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 4/22/2005 17:19'!merge	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | ver merge]		displayingProgress: 'merging packages'! !!MCConfiguration methodsFor: 'actions' stamp: 'bf 5/23/2005 15:40'!upgrade	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | 			(Preferences upgradeIsMerge and: [self mustMerge: ver])				ifFalse: [ver load]				ifTrue: [[ver merge]					on: MCMergeResolutionRequest do: [:request |						request merger conflicts isEmpty							ifTrue: [request resume: true]							ifFalse: [request pass]]]]		displayingProgress: 'upgrading packages'! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:19'!changes	^MCPatch operations: #()! !!MCConfiguration methodsFor: 'faking' stamp: 'bf 3/24/2005 01:17'!info	^MCVersionInfo new! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:32'!dependencies	^dependencies ifNil: [dependencies := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/21/2005 18:40'!dependencies: aCollection	dependencies := aCollection! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:22'!fileName	^ self name, '.', self writerClass extension! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 6/9/2005 15:58'!log	^log ifNil: [Transcript]! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 4/28/2005 11:55'!log: aStream	log := aStream.! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:23'!name	^name! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 18:23'!name: aString	name := aString! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:35'!repositories	^repositories ifNil: [repositories := OrderedCollection new]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:36'!repositories: aCollection	repositories := aCollection! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/23/2005 00:44'!summary	^String streamContents: [:stream |		self dependencies			do: [:ea | stream nextPutAll: ea versionInfo name; cr ]]! !!MCConfiguration methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:50'!writerClass	^ MCMcmWriter ! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/10/2005 15:48'!depsSatisfying: selectBlock versionDo: verBlock displayingProgress: progressString	| repoMap count |	repoMap _ Dictionary new.	self repositories do: [:repo |		MCRepositoryGroup default addRepository: repo.		repo allVersionNames			ifEmpty: [self logWarning: 'cannot read from ', repo description]			ifNotEmptyDo: [:all | all do: [:ver | repoMap at: ver put: repo]]].	count := 0.	self dependencies do: [:dep |		| ver repo |		ver := dep versionInfo name.		repo := repoMap at: ver ifAbsent: [			self logError: 'Version ', ver, ' not found in any repository'.			self logError: 'Aborting'.			^count].		(selectBlock value: dep) ifTrue: [			| new |			new := self versionNamed: ver for: dep from: repo.			new ifNil: [					self logError: 'Could not download version ', ver, ' from ', repo description.					self logError: 'Aborting'.					^count]				ifNotNil: [					self logUpdate: dep package with: new.					ProgressNotification signal: '' extra: 'Installing ', ver.					verBlock value: new.					count := count + 1.				]		].		dep package workingCopy repositoryGroup addRepository: repo.	] displayingProgress: progressString.	^count! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 11:26'!diffBaseFor: aDependency	| wc |	aDependency package hasWorkingCopy ifFalse: [^nil].	wc := aDependency package workingCopy.	wc ancestors ifEmpty: [^nil].	^wc ancestors first name! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:07'!logError: aString	self log		cr; nextPutAll: 'ERROR: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 15:59'!logUpdate: aPackage with: aVersion	self log		cr; nextPutAll: '========== ', aVersion info name, ' =========='; cr;		cr; nextPutAll: aVersion info message asString; cr;		flush.	aPackage hasWorkingCopy ifFalse: [^self].	aPackage workingCopy ancestors do: [:each |		(aVersion info hasAncestor: each)			ifTrue: [(aVersion info allAncestorsOnPathTo: each)				do: [:ver | self log cr; nextPutAll: '>>> ', ver name, ' <<<'; cr;							nextPutAll: ver message; cr; flush]]]! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:08'!logWarning: aString	self log		cr; nextPutAll: 'WARNING: ';		nextPutAll: aString; cr;		flush.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 5/23/2005 14:47'!mustMerge: aVersion	"answer true if we have to do a full merge and false if we can simply load instead"		| pkg wc current |	(pkg := aVersion package) hasWorkingCopy ifFalse: [^false "no wc -> load"].	(wc := pkg workingCopy) modified ifTrue: [^true "modified -> merge"].	wc ancestors isEmpty ifTrue: [^true "no ancestor info -> merge"].	current := wc ancestors first.	(aVersion info hasAncestor: current) ifTrue: [^false "direct descendant of wc -> load"].	"new branch -> merge"	^true! !!MCConfiguration methodsFor: 'private' stamp: 'bf 6/9/2005 16:17'!versionNamed: verName for: aDependency from: repo	| baseName fileName ver |	(repo filterFileNames: repo cachedFileNames forVersionNamed: verName) ifNotEmptyDo: [:cachedNames |		fileName := cachedNames anyOne.		ProgressNotification signal: '' extra: 'Using cached ', fileName.		ver := repo versionFromFileNamed: fileName].	ver ifNil: [		baseName := self diffBaseFor: aDependency.		(baseName notNil and: [baseName ~= verName]) ifTrue: [			fileName := (MCDiffyVersion nameForVer: verName base: baseName), '.mcd'.			ProgressNotification signal: '' extra: 'Downloading ', fileName.			ver := repo versionFromFileNamed: fileName]].	ver ifNil: [		fileName := verName, '.mcz'.		ProgressNotification signal: '' extra: 'Downloading ', fileName.		ver := repo versionFromFileNamed: fileName].	^ver! !!MCConfiguration methodsFor: 'initialize' stamp: 'ar 5/27/2005 17:28'!initialize	super initialize.	log := DefaultLog.! !!MCConfiguration methodsFor: 'testing' stamp: 'bf 3/22/2005 22:56'!isCacheable	^false! !!MCConfiguration methodsFor: 'updating' stamp: 'bf 5/23/2005 17:43'!updateFromImage	self dependencies: (self dependencies collect: [:dep |		dep package hasWorkingCopy			ifTrue: [				dep package workingCopy in: [:wc |					MCVersionDependency package: wc package info: wc ancestors first]]			ifFalse: [dep]]).! !!MCConfiguration methodsFor: 'updating' stamp: 'bf 5/30/2005 20:50'!updateFromRepositories	| oldInfos newNames sortedNames newDeps |	oldInfos := self dependencies collect: [:dep | dep versionInfo].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldInfos)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asSortedCollection:		[:a :b | a numericSuffix > b numericSuffix].	newDeps := OrderedCollection new.	self dependencies do: [:dep |		| newName |		newName := sortedNames			detect: [:each | (each copyUpToLast: $-) = dep package name]			ifNone: [nil].		newDeps add: (newName			ifNil: [dep]			ifNotNil: [				| repo ver  |				repo := newNames at: newName.				ver := self versionNamed: newName for: dep from: repo.				ver ifNil: [dep]					ifNotNil: [MCVersionDependency package: ver package info: ver info]			])	] displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27'!defaultLog	"Answer the default configuration log"	^DefaultLog! !!MCConfiguration class methodsFor: 'accessing' stamp: 'ar 5/27/2005 17:27'!defaultLog: aStream	"Set the default configuration log"	DefaultLog := aStream.! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:43'!dependencyFromArray: anArray	^MCVersionDependency		package: (MCPackage named: anArray first)		info: (			MCVersionInfo			name: anArray second			id: (UUID fromString: anArray third)			message: nil			date: nil			time: nil			author: nil			ancestors: nil)! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:44'!dependencyToArray: aDependency	^ {		aDependency package name . 		aDependency versionInfo name . 		aDependency versionInfo id asString }! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 6/9/2005 14:25'!repositoryFromArray: anArray	^ MCRepositoryGroup default repositories		detect: [:repo | repo description = anArray first]		ifNone: [			MCHttpRepository				location: anArray first				user: ''				password: '']! !!MCConfiguration class methodsFor: 'converting' stamp: 'bf 3/24/2005 01:51'!repositoryToArray: aRepository	^ {aRepository description}! !!MCConfiguration class methodsFor: 'instance creation' stamp: 'bf 3/24/2005 01:51'!fromArray: anArray	| configuration |	configuration := self new.	anArray pairsDo: [:key :value |		key = #repository			ifTrue: [configuration repositories add: (self repositoryFromArray: value)].		key = #dependency			ifTrue: [configuration dependencies add: (self dependencyFromArray: value)].	].	^configuration! !!MCConfiguration class methodsFor: 'class initialization' stamp: 'bf 4/20/2005 17:20'!initialize	"MCConfiguration initialize"	Preferences addPreference: #upgradeIsMerge		categories: #('updates') default: false 		balloonHelp: 'When upgrading packages, use merge instead of load'.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 22:08'!add	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:01'!down	self canMoveDown ifTrue: [		self list swap: self index with: self index + 1.		self index: self index + 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 6/22/2005 12:26'!installMenu	| menu |	menu _ MenuMorph new defaultTarget: self.	menu add: 'load packages' action: #load.	menu add: 'merge packages' action: #merge.	menu add: 'upgrade packages' action: #upgrade.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42'!load	self configuration load.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 16:44'!loadMenu	| menu |	menu _ MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:42'!merge	self configuration merge.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'ar 4/14/2005 21:41'!post	"Take the current configuration and post an update"	| name update managers names choice |	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	name := FillInTheBlank		request: 'Update name (.cs) will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	name isEmpty ifTrue:[^self].	self configuration name: name.	update := MCPseudoFileStream on: (String new: 100).	update localName: name, '.cs'.	update nextPutAll: '"Change Set:		', name.	update cr; nextPutAll: 'Date:			', Date today printString.	update cr; nextPutAll: 'Author:			Posted by Monticello'.	update cr; cr; nextPutAll: 'This is a configuration map created by Monticello."'.	update cr; cr; nextPutAll: '(MCConfiguration fromArray: #'.	self configuration fileOutOn: update.	update nextPutAll: ') upgrade.'.	update position: 0.	managers := Smalltalk at: #UpdateManager ifPresent:[:mgr| mgr allRegisteredManagers].	managers ifNil:[managers := #()].	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := UIManager default chooseFrom: names lines: {managers size}.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| mgr |			mgr := managers at: index.			^mgr publishUpdate: update.		].		choice := names at: index.	] ifFalse:[		names _ ServerDirectory groupNames asSortedArray.		choice _ (SelectionMenu labelList: names selections: names) startUp.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: update.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 21:05'!remove	self canRemove ifTrue: [		self list removeAt: self index.		self changedList.		self updateIndex.	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 23:38'!store	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	self pickName ifNotNilDo: [:name |		self configuration name: name.		self pickRepository ifNotNilDo: [:repo |			repo storeVersion: self configuration]].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 3/23/2005 20:53'!up	self canMoveUp ifTrue: [		self list swap: self index with: self index - 1.		self index: self index - 1.		self changedList.	].! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 16:44'!updateMenu	| menu |	menu _ MenuMorph new defaultTarget: self.	menu add: 'update from image' action: #updateFromImage.	menu add: 'update from repositories' action: #updateFromRepositories.	menu popUpInWorld.! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'bf 4/19/2005 17:43'!upgrade	self configuration upgrade.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 22:08'!addDependency	(self pickWorkingCopiesSatisfying: [:each | (self includesPackage: each package) not])		do: [:wc |			wc ancestors isEmpty				ifTrue: [self inform: 'You must save ', wc packageName, ' first!!Skipping this package']				ifFalse: [					self dependencies add: (MCVersionDependency						package: wc package						info: wc ancestors first)]].	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:36'!checkDependencies	^self checkModified and: [self checkMissing]! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:35'!checkMissing	| missing |	missing := (self dependencies collect: [:ea | ea versionInfo name]) asSet.	self repositories		do: [:repo |			repo allVersionNames				do: [:found | missing remove: found ifAbsent: []]]		displayingProgress: 'searching versions'.	^missing isEmpty or: [		self selectDependency: missing anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'No repository found for'; cr.			missing do: [:r | strm nextPutAll: r; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:37'!checkModified	| modified |	modified := self dependencies select: [:dep |		dep isFulfilled and: [dep package workingCopy modified]].		^modified isEmpty or: [		self selectDependency: modified anyOne.		self confirm: (String streamContents: [:strm |			strm nextPutAll: 'These packages are modified:'; cr.			modified do: [:dep | strm nextPutAll: dep package name; cr].			strm nextPutAll: 'Do you still want to store?'])]	! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 4/19/2005 17:28'!dependencyList	^self dependencies collect: [:dep | 		Text string: dep versionInfo name			attributes: (Array streamContents: [:attr |				dep isFulfilledByAncestors					ifFalse: [attr nextPut: TextEmphasis bold]					ifTrue: [dep isCurrent ifFalse: [attr nextPut: TextEmphasis italic]].			])]! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/23/2005 17:56'!selectedDependency	^ self dependencies at: self dependencyIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'bf 3/21/2005 16:30'!selectedPackage	^ self selectedDependency ifNotNilDo: [:dep | dep package]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:17'!addRepository	(self pickRepositorySatisfying: [:ea | (self repositories includes: ea) not])		ifNotNilDo: [:repo |			(repo isKindOf: MCHttpRepository)				ifFalse: [^self inform: 'Only HTTP repositories are supported'].			self repositories add: repo.			self changed: #repositoryList.		]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:45'!checkRepositories	| bad |	bad := self repositories reject: [:repo | repo isKindOf: MCHttpRepository].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Please remove these repositories:'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: '(only HTTP repositories are supported)']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/24/2005 00:47'!checkRepositoryTemplates	"unused for now - we only do HTTP"	| bad |	bad := self repositories select: [:repo | repo creationTemplate isNil].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Creation template missing for'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: 'Please fill in the details first!!']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 21:15'!repositoryList	^self repositories collect: [:ea | ea description]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'bf 3/23/2005 17:58'!selectedRepository	^ self repositories at: self repositoryIndex ifAbsent: []! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 6/22/2005 12:26'!buttonSpecs	^ #(('Add' add 'Add a dependency')		('Update' updateMenu 'Update dependencies')		('Install' installMenu 'Load/Merge/Upgrade into image')		('Up' up 'Move item up in list' canMoveUp)		('Down' down 'Move item down in list' canMoveDown)		('Remove' remove 'Remove item' canRemove)		('Store' store 'store configuration')		('Post' post 'Post this configuration to an update stream')		)! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 4/19/2005 16:51'!defaultExtent	^ 350@500! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/24/2005 00:20'!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency...' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/22/2005 22:01'!pickName	| name |	name := FillInTheBlank		request: 'Name (.', self configuration writerClass extension, ' will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	^ name isEmpty ifFalse: [name]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:11'!pickRepository	^self pickRepositorySatisfying: [:ea | true]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:09'!pickRepositorySatisfying: aBlock	| index list |	list := MCRepositoryGroup default repositories select: aBlock.	index _ (PopUpMenu labelArray: (list collect: [:ea | ea description]))		startUpWithCaption: 'Repository:'.	^ index = 0 ifFalse: [list at: index]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/22/2005 21:46'!pickWorkingCopiesSatisfying: aBlock	| copies item |	copies := (MCWorkingCopy allManagers select: aBlock)		asSortedCollection: [:a :b | a packageName <= b packageName].	item _ (PopUpMenu labelArray: #('match ...'),(copies collect: [:ea | ea packageName]) lines: #(1))				startUpWithCaption: 'Package:'.	item = 1 ifTrue: [		| pattern |		pattern := FillInTheBlank request: 'Packages matching:' initialAnswer: '*'.		^pattern isEmptyOrNil			ifTrue: [#()]			ifFalse: [				(pattern includes: $*) ifFalse: [pattern _ '*', pattern, '*'].				copies select: [:ea | pattern match: ea packageName]]	].	^ item = 0		ifTrue: [#()]		ifFalse: [{copies at: item - 1}]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 21:27'!repositoryMenu: aMenu	^self fillMenu: aMenu fromSpecs: #(		('add repository...' addRepository)	)! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'bf 3/23/2005 22:01'!widgetSpecs	^ #(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu: dependencyList dependencyIndex dependencyMenu:) (0 0 1 1) (0 30 0 -180))		((listMorph:selection:menu: repositoryList repositoryIndex repositoryMenu:) (0 1 1 1) (0 -180 0 -120))		((textMorph: description) (0 1 1 1) (0 -120 0 0))	 	)! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44'!canMoveDown	^self index between: 1 and: self maxIndex - 1 ! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:44'!canMoveUp	^self index > 1! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/23/2005 20:45'!canRemove	^self index > 0! !!MCConfigurationBrowser methodsFor: 'testing' stamp: 'bf 3/21/2005 17:15'!includesPackage: aPackage	^self dependencies anySatisfy: [:each | each package = aPackage]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:54'!changedButtons	self changed: #canMoveDown.	self changed: #canMoveUp.	self changed: #canRemove.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:55'!changedList	self dependencyIndex > 0 ifTrue: [^self changed: #dependencyList].	self repositoryIndex > 0 ifTrue: [^self changed: #repositoryList].	self error: 'nothing selected'! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:56'!dependencyIndex	^dependencyIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55'!dependencyIndex: anInteger	dependencyIndex := anInteger.	dependencyIndex > 0		ifTrue: [self repositoryIndex: 0].	self changed: #dependencyIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:43'!index	^self dependencyIndex max: self repositoryIndex! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00'!index: anInteger	self dependencyIndex > 0 ifTrue: [^self dependencyIndex: anInteger].	self repositoryIndex > 0 ifTrue: [^self repositoryIndex: anInteger].	anInteger > 0 ifTrue: [self error: 'cannot select']! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:51'!list	self dependencyIndex > 0 ifTrue: [^self dependencies].	self repositoryIndex > 0 ifTrue: [^self repositories].	^#()! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 20:52'!maxIndex	^ self list size! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 17:57'!repositoryIndex	^repositoryIndex ifNil: [0]! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 5/27/2005 19:55'!repositoryIndex: anInteger	repositoryIndex := anInteger.	repositoryIndex > 0		ifTrue: [self dependencyIndex: 0].	self changed: #repositoryIndex; changed: #description.	self changedButtons.! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:16'!selectDependency: aDependency	self dependencyIndex: (self dependencies indexOf: aDependency)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 23:15'!selectRepository: aRepository	self repositoryIndex: (self repositories indexOf: aRepository)! !!MCConfigurationBrowser methodsFor: 'selection' stamp: 'bf 3/23/2005 21:00'!updateIndex	self index > 0 ifTrue: [self index: (self index min: self maxIndex)]! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:03'!configuration	^configuration ifNil: [configuration := MCConfiguration new]! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 14:56'!configuration: aConfiguration	configuration := aConfiguration! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/21/2005 16:35'!dependencies	^self configuration dependencies! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 4/19/2005 16:02'!dependencies: aCollection	self configuration dependencies: aCollection.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 17:41'!repositories	^ self configuration repositories! !!MCConfigurationBrowser methodsFor: 'accessing' stamp: 'bf 3/23/2005 21:15'!repositories: aCollection	^self configuration repositories: aCollection! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'bf 4/14/2005 15:37'!description	self selectedDependency ifNotNilDo: [:dep | ^ ('Package: ', dep package name, String cr,		dep versionInfo summary) asText].	self selectedRepository ifNotNilDo: [:repo | ^repo creationTemplate		ifNotNil: [repo creationTemplate asText]		ifNil: [repo asCreationTemplate asText addAttribute: TextColor red]].	^ ''! !!MCConfigurationBrowser methodsFor: 'description' stamp: 'bf 3/23/2005 22:49'!description: aText	self selectedRepository ifNotNilDo: [:repo | 		| new | 		new := MCRepository readFrom: aText asString.		(new class = repo class 			and: [new description = repo description])				ifTrue: [					repo creationTemplate: aText asString.					self changed: #description]				ifFalse: [					self inform: 'This does not match the previous definition!!'				]	].! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44'!updateFromImage	self configuration updateFromImage.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser methodsFor: 'updating' stamp: 'bf 5/23/2005 17:44'!updateFromRepositories	self configuration updateFromRepositories.	self changed: #dependencyList; changed: #description! !!MCConfigurationBrowser class methodsFor: 'class initialization' stamp: 'bf 3/21/2005 19:46'!initialize	TheWorldMenu registerOpenCommand: { 'Monticello Configurations' . { self . #open }. 'Monticello Configuration Browser' }.! !!MCConfigurationBrowser class methodsFor: 'opening' stamp: 'bf 3/21/2005 19:50'!open	^self new show! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17'!configurationName	^fileName ifNotNil: [(fileName findTokens: '/\:') last copyUpToLast: $.]! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 01:17'!fileName: aString	fileName := aString! !!MCMcmReader methodsFor: 'accessing' stamp: 'bf 3/23/2005 00:05'!version	| configuration |	configuration := MCConfiguration fromArray: (MCScanner scan: stream).	configuration name: self configurationName.	^configuration! !!MCMcmReader class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:47'!extension	^ 'mcm'! !!MCMcmReader class methodsFor: 'instance creation' stamp: 'bf 3/23/2005 01:17'!on: aStream fileName: aFileName	| reader |	reader _ self on: aStream.	reader fileName: aFileName.	^reader! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/22/2005 18:00'!close	stream close! !!MCMcmWriter methodsFor: 'writing' stamp: 'bf 3/24/2005 01:50'!writeConfiguration: aConfiguration	stream nextPut: $(.	aConfiguration repositories do: [:ea | 		stream cr.		stream nextPutAll: 'repository '.		(MCConfiguration repositoryToArray: ea) printElementsOn: stream].	aConfiguration dependencies do: [:ea | 		stream cr.		stream nextPutAll: 'dependency '.		(MCConfiguration dependencyToArray: ea) printElementsOn: stream].	stream cr.	stream nextPut: $).	stream cr.! !!MCMcmWriter class methodsFor: 'writing' stamp: 'bf 3/22/2005 17:37'!fileOut: aConfiguration on: aStream	| inst |	inst _ self on: aStream.	inst writeConfiguration: aConfiguration.	inst close.	! !!MCMcmWriter class methodsFor: 'accessing' stamp: 'bf 3/22/2005 10:49'!readerClass	^ MCMcmReader! !!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54'!localName	^localName! !!MCPseudoFileStream methodsFor: 'accessing' stamp: 'ar 4/14/2005 19:54'!localName: aString	localName := aString! !MCConfigurationBrowser initialize!MCConfiguration initialize!