'From Squeak3.10beta of 22 July 2007 [latest update: #7158] on 26 October 2007 at 12:50:12 pm'!"Change Set:		stringAndCharFixes-mirDate:			26 October 2007Author:			Michael RuegerBackport of fixes from 3.9 and 3.10"!Collection subclass: #CharacterSetComplement	instanceVariableNames: 'absent'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!CharacterSetComplement commentStamp: 'nice 3/23/2007 02:27' prior: 0!CharacterSetComplement is a space efficient implementation of (CharacterSet complement) taking care of WideCharacter (code > 255)instance variables:	absent <CharacterSet> contains character that are not in the set (i.e. my complement)!!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:19'!= anObject	"Implementation note: we do not test if equal to a WideCharacterSet,	because it is unlikely that WideCharacterSet is as complete as self"		^self class == anObject class and: [		absent = anObject complement ]! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:16'!hash	^absent hash bitXOr: self class hash! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!add: aCharacter	"a character is present if not absent"		(absent includes: aCharacter) ifTrue: [absent remove: aCharacter].	^aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:11'!do: aBlock	"evaluate aBlock with each character in the set.	don't do it, there are too many..."	self shouldNotImplement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:07'!includes: aCharacter	^(absent includes: aCharacter) not! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!reject: aBlock	"Implementation note: rejecting present is selecting absent"		^(absent select: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!remove: aCharacter	"This means a character is absent from myself"		^absent add: aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!select: aBlock	"Implementation note: selecting present is rejecting absent"		^(absent reject: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:10'!size	"Is this 2**32-absent size ?"		^self shouldNotImplement! !!CharacterSetComplement methodsFor: 'private' stamp: 'nice 3/23/2007 02:21'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^absent byteArrayMap collect: [:i | 1 - i]! !!CharacterSetComplement methodsFor: 'converting' stamp: 'nice 3/23/2007 02:08'!complement	"return a character set containing precisely the characters the receiver does not"		^absent copy! !!CharacterSetComplement methodsFor: 'initialize-release' stamp: 'nice 3/23/2007 02:25'!complement: aCharacterSet	"initialize with the complement"		absent := aCharacterSet! !!CharacterSetComplement methodsFor: 'testing' stamp: 'nice 3/23/2007 02:12'!hasWideCharacters	"This is a guess that absent is not holding each and every possible wideCharacter..."		^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CharacterSetComplement class	instanceVariableNames: ''!!CharacterSetComplement class methodsFor: 'instance creation' stamp: 'nice 3/23/2007 02:25'!of: aCharacterSet	"answer the complement of aCharacterSet"		^ super new complement: aCharacterSet! !Collection subclass: #WideCharacterSet	instanceVariableNames: 'map'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!WideCharacterSet commentStamp: 'nice 5/9/2006 23:33' prior: 0!WideCharacterSet is used to store a Set of WideCharacter with fast access and inclusion test.Implementation should be efficient in memory if sets are sufficently sparse.Wide Characters are at most 32bits.We split them into 16 highBits and 16 lowBits.map is a dictionary key: 16 highBits value: map of 16 lowBits.Maps of lowBits  are stored as arrays of bits in a WordArray.If a bit is set to 1, this indicate that corresponding character is present.Only 2048 entries are necessary in each lowmap.And only lowmap corresponding to a present high value are stored.!!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!= anObject	^self species == anObject species and: [		self wideCharacterMap = anObject wideCharacterMap ]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/10/2006 00:26'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| aMap lowmap |	aMap := ByteArray new: 256.	lowmap := map at: 0 ifAbsent: [^aMap].	lowmap := lowmap copyFrom: 1 to: 8. "Keep first 8*32=256 bits..."	self bitmap: lowmap do: [:code | aMap at: code + 1 put: 1].	^aMap! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 22:27'!hash	^self map hash! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!species	^self hasWideCharacters		ifTrue: [WideCharacterSet]		ifFalse: [CharacterSet]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:14'!wideCharacterMap	^map! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: [WordArray new: 2048].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/10/2006 00:21'!do: aBlock 	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | aBlock						value: (Character value: ((high bitShift: 16) bitOr: low))]]! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:49'!includes: aCharacter 	| val high low |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	^(self		bitmap: (map				at: high				ifAbsent: [^ false])		at: low) isZero not! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := (map				at: high				ifAbsent: [^ aCharacter]) self clearBitmap: lowmap at: low.	lowmap max = 0		ifTrue: [map removeKey: high].	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:00'!size	| size |	size := 0.	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | size := size + 1]].	^ size! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!bitmap: aMap at: shortInteger	"access a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/10/2006 00:10'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits"		0 to: 31 do: [:shift |		| mask |		mask := 1 bitShift: shift.		1 to: aMap size do: [:i | 			((aMap at: i) bitAnd: mask) isZero ifFalse: [aBlock value: ((i - 1 bitShift: 5) bitOr: shift)]]]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!clearBitmap: aMap at: shortInteger	"clear a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:47'!setBitmap: aMap at: shortInteger	"set a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:25'!hasWideCharacters	"Answer true if i contain any wide character"		self do: [:e | e asciiValue >= 256 ifTrue: [^true]].	^false! !!WideCharacterSet methodsFor: 'initialize-release' stamp: 'nice 5/9/2006 22:31'!initialize	map := Dictionary new.! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self become: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 23:22'!wideCharacterMap	"used for comparing with WideCharacterSet"		| wide |	wide := WideCharacterSet new.	wide addAll: self.	^wide wideCharacterMap! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self become: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:09'!includes: aCharacter	aCharacter asciiValue >= 256		ifTrue: ["Guard against wide characters"			^false].	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!remove: aCharacter	aCharacter asciiValue >= 256		ifFalse: ["Guard against wide characters"			map at: aCharacter asciiValue + 1 put: 0].	^aCharacter! !!String class methodsFor: 'primitives' stamp: 'JMM 10/30/2006 13:07'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 _ string1 size.		len2 _ string2 size.		1 to: (len1 min: len2) do:[:i |			c1 _ (string1 at: i) asInteger.			c2 _ (string2 at: i) asInteger.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 _ string1 size.	len2 _ string2 size.	1 to: (len1 min: len2) do:[:i |		c1 _ (string1 at: i) asInteger.		c2 _ (string2 at: i) asInteger.		c1 < 256 ifTrue: [c1 _ order at: c1 + 1].		c2 < 256 ifTrue: [c2 _ order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !ByteSymbol removeSelector: #compare:with:collated:!ByteString removeSelector: #compare:with:collated:!!String methodsFor: 'comparing' stamp: 'JMM 10/30/2006 13:16'!compare: string1 with: string2 collated: order	(string1 isByteString and: [string2 isByteString]) ifTrue: [		^ ByteString compare: string1 with: string2 collated: order	].     "Primitive does not fail properly right now"      ^ String compare: string1 with: string2 collated: order"self assert: 'abc' = 'abc' asWideString.self assert: 'abc' asWideString = 'abc'.self assert: ((ByteArray with: 97 with: 0 with: 0 with: 0) asString ~= 'a000' asWideString).self assert: ('a000' asWideString ~= (ByteArray with: 97 with: 0 with: 0 with: 0) asString).self assert: ('abc' sameAs: 'aBc' asWideString).self assert: ('aBc' asWideString sameAs: 'abc').self assert: ((ByteArray with: 97 with: 0 with: 0 with: 0) asString sameAs: 'Abcd' asWideString) not.self assert: ('a000' asWideString sameAs: (ByteArray with: 97 with: 0 with: 0 with: 0) asString) not."! !!String methodsFor: 'comparing' stamp: 'JMM 10/30/2006 13:24'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 1! !!String methodsFor: 'comparing' stamp: 'JMM 10/30/2006 13:24'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."		^ (self compare: self with: aString collated: AsciiOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'JMM 10/30/2006 13:11'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."		aString isString ifFalse: [ ^ false ].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'JMM 10/30/2006 13:24'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 3! !!String methodsFor: 'comparing' stamp: 'JMM 10/30/2006 13:25'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) >= 2! !!ByteString methodsFor: 'comparing' stamp: 'JMM 10/30/2006 15:57'!findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!String class methodsFor: 'primitives' stamp: 'nice 5/9/2006 20:17'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString at: i) asciiValue.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!ByteString methodsFor: 'comparing' stamp: 'JMM 10/30/2006 15:58'!findSubstring: key in: body startingAt: start matchTable: matchTable	key isWideString ifTrue: [^super findSubstring: key in: body startingAt: start matchTable: matchTable].	^self findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable! !