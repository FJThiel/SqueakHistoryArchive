'From Squeak3.9alpha of ''27 October 2004'' [latest update: #6469] on 22 November 2004 at 2:38:55 pm'!"Change Set:		StringMorphEditorSelectionFix-nk (v3)Date:			22 November 2004Author:			Ned KonzEnsures that you can select just after the last character in a TextMorph that is set to autoFit with autoWrap off (that is, with no space to the right of the last character).v2 avoids selecting to the right of a CR at the end of a text line.v3 adds same fixes to MultiCharacterBlockScanner."!!CharacterBlockScanner methodsFor: 'scanning' stamp: 'nk 11/22/2004 14:32'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line := textLine.	rightMargin := line rightMargin.	lastIndex := line first.	self setStopConditions.		"also sets font"	characterIndex := index.  " == nil means scanning for point"	characterPoint := aPoint.	(characterPoint isNil or: [characterPoint y > line bottom])		ifTrue: [characterPoint := line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX := leftMargin := line leftMarginForAlignment: alignment.	destY := line top.	runLength := text runLengthFor: line first.	characterIndex		ifNotNil:	[lineStop := characterIndex  "scanning for index"]		ifNil:	[lineStop := line last  "scanning for point"].	runStopIndex := lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0.	done  := false.	[done] whileFalse:		[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth			ifNil: [font widthOf: (text at: lastIndex)]			ifNotNil: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex				ifNil: [					"Result for characterBlockAtPoint: "					(stopCondition ~~ #cr and: [ lastIndex == line last						and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ]])							ifTrue: [ "Correct for right half of last character in line"								^ (CharacterBlock new stringIndex: lastIndex + 1										text: text										topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)										extent:  0 @ lastCharacterExtent y)									textLine: line ].						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifNotNil: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'nk 11/22/2004 14:36'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line := textLine.	rightMargin := line rightMargin.	lastIndex := line first.	self setStopConditions.		"also sets font"	characterIndex := index.  " == nil means scanning for point"	characterPoint := aPoint.	(characterPoint isNil or: [characterPoint y > line bottom])		ifTrue: [characterPoint := line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX := leftMargin := line leftMarginForAlignment: alignment.	destY := line top.	runLength := text runLengthFor: line first.	characterIndex		ifNotNil:	[lineStop := characterIndex  "scanning for index"]		ifNil:	[lineStop := line last  "scanning for point"].	runStopIndex := lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0.	done  := false.	[done] whileFalse:		[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth			ifNil: [font widthOf: (text at: lastIndex)]			ifNotNil: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex				ifNil: [					"Result for characterBlockAtPoint: "					(stopCondition ~~ #cr and: [ lastIndex == line last						and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ]])							ifTrue: [ "Correct for right half of last character in line"								^ (CharacterBlock new stringIndex: lastIndex + 1										text: text										topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)										extent:  0 @ lastCharacterExtent y)									textLine: line ].						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifNotNil: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!StringMorphEditor methodsFor: 'event handling' stamp: 'nk 6/12/2004 22:07'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor newSel |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	self editor selectFrom: newSel first to: newSel last.! !