'From Squeak 2.4c of May 10, 1999 on 6 July 1999 at 9:18:36 pm'!ChangeList subclass: #ChangeListForProjects	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Changes'!Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail nextProject guards projectParameters isolatedHead inForce classArray methodDictArray orgArray '	classVariableNames: 'CurrentProject UsingIsolation '	poolDictionaries: ''	category: 'Interface-Projects'!!Behavior methodsFor: 'creating method dictionary' stamp: 'tk 7/6/1999 17:32'!compileAllFrom: oldClass	"Compile all the methods in the receiver's method dictionary.	This validates sourceCode and variable references and forces	all methods to use the current bytecode set"	self selectorsDo: [:sel | self recompile: sel from: oldClass].	Project current compileAllIsolated: self from: oldClass.! !!ChangeList methodsFor: 'initialization-release' stamp: 'tk 6/21/1999 20:39'!initialize	showsVersions _ false.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	super initialize! !!ChangeList methodsFor: 'accessing' stamp: 'tk 6/21/1999 20:43'!listSelections	listSelections ifNil: [		list ifNotNil: [			listSelections _ Array new: list size withAll: false]].	^ listSelections! !!ChangeListForProjects methodsFor: 'as yet unclassified' stamp: 'tk 6/24/1999 15:08'!contents	^ Preferences showDiffsInChangeList		ifFalse: [self undiffedContents]		ifTrue: [self currentDiffedFromContents]			"Current is writing over one in list.  Show how I would change it"! !!ChangeListForProjects methodsFor: 'as yet unclassified' stamp: 'tk 6/24/1999 15:14'!currentDiffedFromContents	| aChange aClass |	listIndex = 0 ifTrue: [^ ''].	aChange _ changeList at: listIndex.	^ ((aChange type == #method and: [(aClass _ aChange methodClass) notNil]) 		and: [aClass includesSelector: aChange methodSelector])			ifTrue: [TextDiffBuilder 					buildDisplayPatchFrom: aChange text					to: (aClass sourceCodeAt: aChange methodSelector)]			ifFalse: [(changeList at: listIndex) text]! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/24/1999 15:27'!headerFor: selector	^ '    ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, selector				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/21/1999 20:34'!readStamp	"Get the time stamp of this method off the file"	| item tokens anIndex |	stamp _ ''.	file ifNil: [^ stamp].	file position: position.	item _ file nextChunk.	tokens _ Scanner new scanTokens: item.	tokens size < 3 ifTrue: [^ stamp].	anIndex _ tokens indexOf: #stamp: ifAbsent: [^ stamp].	^ stamp _ tokens at: (anIndex + 1).! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/23/1999 08:20'!text	| text |	^ file ifNil: ['']		ifNotNil: [			file openReadOnly.			file position: position.			text _ file nextChunkText.			file close.			text]! !!ChangeRecord methodsFor: 'initialization' stamp: 'tk 6/24/1999 14:51'!class: clsName category: cat method: method sourceFiles: fileArray	"This should be enough to find all the information for a method, or method deletion"	file _ fileArray at: method fileIndex.	position _ method filePosition.	type _ #method.	class _ clsName copyUpTo: $ .	"the non-meta part of a class name"	category _ cat.	meta _ clsName endsWith: ' class'.	self readStamp.! !!ChangeSet commentStamp: 'tk 7/6/1999 21:17' prior: 0!My instances keep track of the changes made to a system, so the user can write the changes on a file as source code (a "fileOut").  The order in which changes are made is not remembered.------classChanges -  Dictionary {class name -> Set {eg, #change, #rename, etc}}.methodChanges -  Dictionary {class name -> IdentityDictionary {selector -> {eg, #change, #remove, etc}}.classRemoves -  Set {class name (original)}.methodRemoves -  Dictionary {(Array with: class name with: selector) -> (Array with: source pointer with: category)}.name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.  Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.  Of all classes in classChanges, and all of their superclasses.	Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).!!ChangeSet reorganize!('initialize-release' clear initialize isMoribund veryDeepCopyWith: wither)('accessing' classRemoves editPostscript hasPostscript methodChanges methodRemoves name name: postscriptHasDependents printOn: removePostscript structures superclasses)('testing' belongsToAProject correspondingProject isEmpty okayToRemove okayToRemoveInforming:)('converting' asSortedCollection)('method changes' addSelector:class: atSelector:class:put: browseMessagesWithPriorVersions changeSelector:class: changedMessageList changedMessageListAugmented forgetChange:forSelector:class: methodChangesAtClass: removeSelector:class: removeSelectorChanges:class: selectorList selectorsInClass: undoChange:for:class:)('class changes' addClass: changeClass:from: changedClassNames changedClasses classChangeAt: commentClass: flushClassRemoves hasClassChangesFor: noteClassForgotten: noteClassStructure: noteRemovalOf: renameClass:as: reorganizeClass: verifyClassRemoves)('moving changes' absorbChangesInChangeSetsNamed: absorbClass:from: absorbMethod:class:from: absorbStructureOfClass:from: assimilateAllChangesFoundIn: editPreamble expungeEmptyClassChangeEntries forgetAllChangesFoundIn: hasPreamble removeAllMemoryOfChangesTo: removeAllMemoryOfChangesToClassNamed: removeClassAndMetaClassChanges: removeClassChanges: removePreamble)('reverting methods')('fileIn/Out' assurePostscriptExists assurePreambleExists checkForConversionMethods checkForSlips fileOut fileOutChangesFor:on: fileOutOn: fileOutPSFor:on: fileOutPostscriptOn: fileOutPreambleOn: lookForSlips postscriptString postscriptString: preambleString preambleString: preambleTemplate summaryString summaryStringDelta:)('private' addCoherency: atClass:add: atClass:includes: atSelector:class: fileOutClassDefinition:on: fileOutClassModifications:on: inspectMethodChanges oldNameFor:)('object fileIn' test1 test2)!!ChangeSet methodsFor: 'testing' stamp: 'tk 6/23/1999 07:14'!belongsToAProject	Project allSubInstancesDo: [:proj |		proj projectChangeSet == self ifTrue: [^ true]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'tk 6/23/1999 07:14'!correspondingProject	"If the receiver is the current change set for any project, answer it, else answer nil"	Project allSubInstancesDo: [:proj |		proj projectChangeSet == self ifTrue: [^ proj]].	^ nil! !!ChangeSet methodsFor: 'method changes' stamp: 'tk 7/6/1999 12:54'!changeSelector: selector class: class 	"Include indication that a method has been edited. 	This method must be called before the new method in actually installed, so old methodDictionary state can be saved.  It is now -- keep it that way!!"		Utilities noteMethodSubmission: selector forClass: class name.		"Keep track of change in order for 'recent submissions' browser"	(self atSelector: selector class: class) = #add 		ifFalse: [self atSelector: selector class: class put: #change]			"Don't forget a method is new just because it's been changed"		ifTrue: [Project current isolateClass: class].			"top isolated project needs to record this change"			! !!ClassDescription methodsFor: 'initialize-release' stamp: 'tk 7/4/1999 17:47'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods "& self hasMethods"	"other isolated projects may have methods!!"		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [wasPresent ifTrue: [self updateInstancesFrom: oldClass]].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			weak: sub isWeak			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods			wasPresent: true]	"if false, no subclasses, does not get here"! !!ClassDescription methodsFor: 'organization' stamp: 'tk 6/21/1999 12:59'!organization: aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	organization _ aClassOrg! !!HandMorph methodsFor: 'world menu' stamp: 'tk 6/26/1999 19:01'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'changes...') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out changes' target: Utilities action: #fileOutChanges.	menu balloonTextForLastItem: 'Write the current change set out to a file whose name reflects the change set name and the current date & time.'.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu balloonTextForLastItem: 'Create a new change set and make it the current one.'.	menu add: 'browse changed methods' action: #browseChangedMessages.	menu balloonTextForLastItem: 'Open a message-list browser showing all methods in the current change set'.	menu add: 'check for slips' target: Smalltalk changes action: #lookForSlips.	menu balloonTextForLastItem: 'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu balloonTextForLastItem: 'Open a change sorter that allows you to view one change set at a time.'.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu balloonTextForLastItem: 'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'.	menu addLine.	menu add: 'browse recent submissions' action: #openRecentChanges.	menu balloonTextForLastItem: 'Open a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'.	menu add: 'recent change log' action: #openChangesLog.	menu balloonTextForLastItem: 'Open a change-list browser on the latter part of the changes log.'.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	menu balloonTextForLastItem: 'Save a file that, when reloaded, reconstitutes the current World.'.	menu addLine.	menu add: 'isolate methods of this project' action: #beIsolated.	menu balloonTextForLastItem: 'Make this project and its subprojects be isolated from the rest of the system.  Changes to methods here will be revoked when you leave this project.'.	menu add: 'assert in all projects' action: #assert.	menu balloonTextForLastItem: 'The changes made in this isolated project will be installed in all projects.'.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/26/1999 19:05'!assert.	"The changes made in this isolated project will be installed in all projects."	World project assert.! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/26/1999 18:58'!beIsolated	"label this project.  Further method changes made here will be revoked when you leave the project."	World project beIsolated.! !!Project commentStamp: 'tk 7/6/1999 21:06' prior: 0!A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet, as well as the parent project in which it was created.  When you change projects, whether by entering or exiting, all the global state is saved into the project being exited, and loaded from the one being entered.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.When you accept a method, the entire system feels the change, except projects that are "isolated".  In an "isolated" project, changes are revoked when you leave the project.  When you enter another project, that project's changes are installed.  (To make a project be isolated, choose "isolate changes of this project" from the "changes..." section of the screen menu.)  You can use an isolated project for making dangerous change to a system, and you can get out if it crashes.  An imported application can have the separate environment it wants.  Also, [later] you can freeze part of the system for a demo that you don't want to disturb.	An isolated project shares methods with all subprojects inside it, unless they are isolated themselves.   Each isolated project is the head of a tree of projects it shares all methods with.	You may 'assert' all changes ever made in the current project to take effect everywhere.  You are first informed if there are any direct method conflicts with other projects.  The conflicts are presented in a ChangeList Browser.	[Later: A project may be 'frozen'.  Asserts do not apply to it after that.  (Great for demos.)  You should be informed when an assert was blocked in a frozen project.]	Class definitions are global.  If you add an instance variable, it happens in all projects.  All versions of the methods are recompiled, in all projects.  If you remove an inst var that is in use in another isolated project, it will become an Undeclared global.  It is best not to remove an inst var when it is being used in another isolated project.   	Senders and Implementors do not see other versions of a method in other isolated projects.	When you ask for versions of a method, you will not get the history in other isolated projects.	Moving methods and classes between changeSets, and merging changeSets has no effect on which methods are in force.  But, when you look at a changeSet from a different isolated project, the methods will contain the 'wrong' code.  A changeSet is just a list of method names, and has no code of its own.	When finer grained assertion is needed, use the method (aProject assertClass: aClass from: thisProject warn: warnConflicts).	How it works: When a class first changes, store its MethodDictionary object.  Keep parallel arrays of associations to Classes and MethodDictionaries.  Traverse and install when you leave and enter an "ioslated project".  When you leave, store this project's own MethodDictionaries there.	To do an assert, we must discover which methods changed here, and which changed only in the project we are asserting into.  There is one copy of the 'virgin' method dictionaries in the system.  It is always being temporarily stored by the currently inForce isolated project.isolatedHead - true for the "top project", and the origin of each "isolated project".  false or nil for any subproject that shares all methods with its parent project.inForce -  true if my methods are installed now.  false if I am dormant.classArray - list of associations to classes methodDictArray - the method dictionaries of those classes before we started changing methods.  They hang onto the original compiledMethods.  (If this project is dormant, it contains the method dictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - true when more than one isolated project exists.  When false, only top project has (isolatedHead = true), and no project records any method dictionaries.  This is to save space when not using Isolated Projects.!!Project methodsFor: 'accessing' stamp: 'tk 6/25/1999 16:42'!classArray	"An array of associations from the Smalltalk dictionary"	^ classArray! !!Project methodsFor: 'accessing' stamp: 'tk 6/21/1999 11:40'!inForce	^ inForce! !!Project methodsFor: 'accessing' stamp: 'tk 7/6/1999 12:24'!inForce: boolean	"Dangerous.  Only used to take control from another top isolated project"	inForce _ boolean! !!Project methodsFor: 'accessing' stamp: 'tk 6/21/1999 11:41'!methodDictArray	^ methodDictArray! !!Project methodsFor: 'accessing' stamp: 'tk 6/21/1999 13:08'!orgArray	^ orgArray! !!Project methodsFor: 'menu messages' stamp: 'tk 6/24/1999 11:40'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case."	| showZoom recorderOrNil same |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	CurrentProject makeThumbnail.	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue:[displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	showZoom _ Preferences showProjectZoom		and: ["Only show zoom if there is room for the both displays plus a megabyte"			Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+1000000)].	showZoom ifTrue:[self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	(same _ CurrentProject topIsolated == self topIsolated) ifFalse: [		CurrentProject revoke].	CurrentProject _ self.	same ifFalse: [CurrentProject invoke].	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts.			self spawnNewProcessAndTerminateOld: true]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore.			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'object fileIn' stamp: 'tk 6/21/1999 13:15'!convertdwctppdaevtngp0: varDict dwctppdaevtngpiicmo0: smartRefStrm	"These variables are automatically stored into the new instance ('world' 'changeSet' 'transcript' 'parentProject' 'previousProject' 'displayDepth' 'activeProcess' 'exitFlag' 'viewSize' 'thumbnail' 'nextProject' 'guards' 'projectParameters' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('isolatedHead' 'inForce' 'classArray' 'methodDictArray' 'orgArray' )  If a non-nil value is needed, please assign it."! !!Project methodsFor: 'isolated changes' stamp: 'tk 6/24/1999 19:28'!assert	"Enforce these changes in every project in the system.  The effect is the same as if this changeSet were filed into the other project now.  (Cancel out my saved MethodDictionaries.  Change the other stored MethodDictionaries to use my versions of methods I changed.)"	| deltas conflictList |	isolatedHead == true ifFalse: [		parentProject == self			ifTrue: [self beIsolated]			ifFalse: [^ parentProject assert]].	inForce == true ifFalse: [^ self inform: 'This is not the current project'].	deltas _ self deltaMD.	"For each class, methods I changed or deleted"	conflictList _ ChangeListForProjects new initialize.	Project allSubInstancesDo: [:proj | 		self == proj ifFalse: [proj assertAll: deltas from: self orWriteOn: conflictList]].	(self informOfConflictsIn: conflictList) ifFalse: [^ self].	Project allSubInstancesDo: [:proj |  "actually install the changes" 		self == proj ifFalse: [proj assertAll: deltas from: self orWriteOn: nil]].	classArray _ methodDictArray _ orgArray _ Array new.		"our state is now the background" ! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/4/1999 17:38'!assertAll: deltaMD from: sourceProject orWriteOn: conflictList	"Apply these change to this isolated project.  If I don't mention a class, then I use the default, which will indeed be changed.  If he does not mention a class, I keep my changes to it.  If we both have it, for each selector he mentions, use his value!!	**Only do the assert if conflictList is nil**  When conflictList is a ChangeList, do not assert, and record my version of the conflicting methods."	| mine sourceIndex sourceOrg list rec seenHere divider sourceFilesCopy |	isolatedHead == true ifFalse: [^ self].	"only head projects"	inForce == true ifTrue: [^ self error: 'two projects in force at once'].	list _ conflictList.	seenHere _ false.	sourceFilesCopy _ SourceFiles collect: [:x | 		x isNil ifTrue: [nil] ifFalse: [x readOnlyCopy]].	divider _ ChangeRecord new file: nil position: 0 type: #doIt.	self renew.	classArray withIndexDo: [:assoc :ind |		deltaMD at: assoc ifPresent: [:deltas | "of this class"			mine _ methodDictArray at: ind.			sourceIndex _ sourceProject classArray indexOf: assoc.			sourceOrg _ sourceProject orgArray at: sourceIndex.			deltas associationsDo: [:entry |				list 					ifNil: [entry value == #delete 						ifTrue: [mine removeKey: entry key.							(orgArray at: ind) removeElement: entry key]						ifFalse: [mine at: entry key put: entry value.							(orgArray at: ind) classify: entry key 									under: (sourceOrg categoryOfElement: entry key)]]					ifNotNil: ["no assert, just catalog my version"						(mine includesKey: entry key) ifTrue: [							seenHere ifFalse: ["label to tell name of project"								list addItem: divider text: 'Project: ', self name.								seenHere _ true].							rec _ ChangeRecord new class: assoc key								category: ((orgArray at: ind) 										categoryOfElement: entry key)								method: (mine at: entry key)								sourceFiles: sourceFilesCopy.							list addItem: rec text: (rec headerFor: entry key)]]				]]].	^ list! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/6/1999 20:35'!assertClass: aClass from: sourceProject warn: warnConflicts	"Write into me, the methods in aClass that are from sourceProject.  sourceProject must be the current project!!  If warnConflicts is true, tell the user about conflicting methods."	| deltas justOne conflictList assoc |	self == sourceProject ifTrue: [^ self].	isolatedHead == true ifFalse: [^ self inform: 'I am not a top isolated project'].  			"only head projects.  find using topIsolated"	sourceProject topIsolated == sourceProject ifFalse: [		^ self inform: 'Source must be a top project'].	sourceProject inForce == true ifFalse: [		^ self inform: 'Source must be the current project'].	deltas _ sourceProject deltaMD.	"For each class, methods I changed or deleted"	justOne _ Dictionary new.	assoc _ Smalltalk associationAt: aClass name ifAbsent: ["a metaclass"				self renew.	"only metaclasses need this"				Association key: aClass name value: aClass].	justOne at: assoc put: (deltas at: assoc ifAbsent: [^ self]).	conflictList _ ChangeListForProjects new initialize.	"Different than a normal assert because the class will not become part of the virgin set of changes.  Must always add the class to the other project."	(classArray includes: assoc)		ifTrue: [self assertAll: justOne from: sourceProject orWriteOn: conflictList.			warnConflicts ifTrue: [				(self informOfConflictsIn: conflictList) ifFalse: [^ self]].			self assertAll: justOne from: sourceProject orWriteOn: nil]	"do it"		ifFalse: [			classArray _ classArray, (Array with: assoc).			methodDictArray _ methodDictArray, (Array with: aClass methodDict copy).						orgArray _ orgArray, (Array with: aClass organization copyTwoLevel)].! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/6/1999 12:26'!beIsolated	"Become the head of a tree of projects that all share methods, but do not share with projects outside the tree.  At the moment of isolation, keep the methods that are in force from my previous top isolated project."	| oldTop |	isolatedHead == true ifTrue: [^ self].	"already are"	parentProject == self ifTrue: ["are top, and initializing for first time"		isolatedHead _ true.		inForce _ true.		^ classArray _ methodDictArray _ orgArray _ Array new].		"If we are not top, and top never initialized, topIsolated (below) will do it"	Project current == self ifFalse: [			^ self inform: 'Must be in this project to isolate it'.].	oldTop _ parentProject topIsolated.	isolatedHead _ true.	classArray _ oldTop classArray copy.	methodDictArray _ oldTop methodDictArray collect: [:md | md copy].	orgArray _ oldTop orgArray copyTwoLevel.	UsingIsolation _ true.	inForce _ true.	oldTop inForce: false.	"I take over as a top project"! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/6/1999 18:17'!compileAll: newClass from: oldClass	"If I have a saved method dictionary for this class, get it recompiled.  Invoke this project, compileAll for the Class, and revoke.  When it is the current project's turn, just revoke in order to do the virgin configuration.  Look under both names for the one that is installed in Smalltalk."	| current assoc |	isolatedHead == true ifFalse: [^ self].	"only head projects"	assoc _ Smalltalk associationAt: newClass name ifAbsent: ["a metaclass"				self renew.				Association key: newClass name value: newClass].	(classArray indexOf: assoc) = 0 ifTrue: [		newClass name = oldClass name ifTrue: [^ self]. 		assoc _ Smalltalk associationAt: oldClass name ifAbsent: ["a metaclass"					self renew.					Association key: oldClass name value: oldClass].		(classArray indexOf: assoc) = 0 ifTrue: [^ self]].	(current _ Project current) topIsolated == self ifTrue: ["recompile the virgin MD"		current revoke.		"virgin configuration now installed"		assoc value selectorsDo: [:sel | assoc value recompile: sel from: assoc value].		^ current invoke].	current revoke.	self invoke.	assoc value selectorsDo: [:sel | assoc value recompile: sel from: assoc value].	self revoke.	current invoke.! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/6/1999 17:23'!compileAllIsolated: newClass from: oldClass	"Whenever a recompile is needed in a class, look in other isolated projects for saved method dictionaries.  They need all their methods of this class recompiled also.  This occurs when an inst var is deleted.	All saved method dictionaries are treated equally, even the 'virgin' one in the current project.	Could save time by copying in methods shared with the inForce world, but for now just recompile them all."	Project allSubInstancesDo: [:proj | proj compileAll: newClass from: oldClass].		"its saved method dictionary"! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/6/1999 20:34'!deltaMD	"Prepare a dictionary of fake MethodDictionaries.  For each class, include compiledMethods I changed, and #delete for the ones I deleted.  	Can do this because the original MethodDictionaries of the classes I changed are saved in methodDictArray.  They are carried around the system and saved in each isolated project that is entered."	| deltas diffMD outside myMD class |	self renew.	deltas _ Dictionary new.	classArray withIndexDo: [:assoc :ind |		class _ assoc value.		deltas at: assoc put: (diffMD _ MethodDictionary new).		outside _ methodDictArray at: ind.		(myMD _ class methodDict) associationsDo: [:entry |			(outside at: entry key ifAbsent: [nil]) == entry value ifFalse: [				diffMD at: entry key put: entry value]].	"we changed it"		outside keysDo: [:sel |			(myMD includesKey: sel) ifFalse: [				diffMD at: sel put: #delete]]].	"we deleted it"	^ deltas				! !!Project methodsFor: 'isolated changes' stamp: 'tk 6/24/1999 19:27'!informOfConflictsIn: conflictList	"Post conflicts to the user in a workspace, then ask if should go on."	| response |	conflictList list isEmpty ifFalse: ["we found some conflicts"		conflictList listSelections.	"init it"		ChangeListForProjects open: conflictList 			name: 'Methods that conflict with project ', self name			multiSelect: false.		response _ (PopUpMenu labels: 'assert my methods in every project\cancel' 					withCRs)				startUpWithCaption: 'Another project has methods that conflict with mine.\See the new window.\Resolve the conflicts by making changes in this project.' withCRs.		^ response = 1].	"go ahead an assert"	^ true! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/4/1999 17:28'!invoke	"Install all methods changed here into method dictionaries.  Make my versions be the ones that will be called."	| swap swap2 cls |	isolatedHead == true ifFalse: [		parentProject == self			ifTrue: [self beIsolated]			ifFalse: [^ parentProject invoke]].	inForce ifTrue: [^ self].		"we are already installed"	self renew.	classArray withIndexDo: [:assoc :ind |		cls _ assoc value.		swap _ cls methodDict.	"Save outside's version of classes I effect"		cls methodDictionary: (methodDictArray at: ind).		"install mine"		methodDictArray at: ind put: swap.		"save his"		swap2 _ cls organization.		cls organization: (orgArray at: ind).			orgArray at: ind put: swap2].		inForce _ true.! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/4/1999 17:31'!isolateClass: aClass	"If I am an isolated project, remember the pre-change state of this class's methods, so we can revert to it."	| assoc |	isolatedHead == true ifFalse: [		parentProject == self			ifTrue: [self beIsolated]			ifFalse: [^ parentProject isolateClass: aClass]].	UsingIsolation == true ifFalse: [^ self].	"save space by not recording"	inForce ifFalse: [self inform: 		'modifying an isolated project that is not the current one.'].		"See when this happens.  MethodDict gets out of synch"	assoc _ Smalltalk associationAt: aClass name ifAbsent: ["a metaclass"				self renew.				Association key: aClass name value: aClass].	(classArray includes: assoc) ifTrue: [^ self].	"already recorded"	classArray _ classArray, (Array with: assoc).	methodDictArray _ methodDictArray, (Array with: aClass methodDict copy).				orgArray _ orgArray, (Array with: aClass organization copyTwoLevel).! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/4/1999 16:42'!renew	"Look up metaclasses again, in case they got obsoleted.  Even minor changes, such as an update the redefines the non-meta class will create a new metaclass."	| nonMetaName |	classArray do: [:assoc |		(assoc key endsWith: ' class') ifTrue: [			nonMetaName _ (assoc key copyFrom: 1 to: assoc key size - 6) asSymbol.			Smalltalk at: nonMetaName ifPresent: [:cls |				assoc value: cls class]]]! !!Project methodsFor: 'isolated changes' stamp: 'tk 7/4/1999 17:37'!revoke	"Take back all methods changed here.  Install the original method dictionaries.  The orignal method versions will now be the ones used."	| temp temp2 cls |	isolatedHead == true ifFalse: [		parentProject == self			ifTrue: [self beIsolated]			ifFalse: [^ parentProject revoke]].	inForce ifFalse: [^ self].		"we are not in power"	self renew.	classArray withIndexDo: [:assoc :ind |		cls _ assoc value.		temp _ cls methodDict.	"Gather my version of classes I effect"		cls methodDictionary: (methodDictArray at: ind).		"install other guy's"		methodDictArray at: ind put: temp.		"save mine"		temp2 _ cls organization.		cls organization: (orgArray at: ind).			orgArray at: ind put: temp2].		inForce _ false.! !!Project methodsFor: 'isolated changes' stamp: 'tk 6/17/1999 11:15'!topIsolated	"Go up the parent chain and find an isolated project."	parentProject ifNil: [self inform: 'there is a project with no parent'. ^ self].	isolatedHead == true ifTrue: [^ self].	^ parentProject == self			ifTrue: [self beIsolated. self]			ifFalse: [parentProject topIsolated].! !!Project methodsFor: 'isolated changes' stamp: 'tk 6/17/1999 12:23'!writeMethods: clsName from: assoc on: file first: seen	"Write methods changed here for this class on the file.  I am not the current project.  If my first write, put out which project I am."	| method oldPos sourceFile preamble |	seen ifFalse: [file nextChunkPut: '"Conflicting methods in, ', self name, '"'].	method _ assoc value.	oldPos _ method filePosition.	sourceFile _ SourceFiles at: method fileIndex.	sourceFile position: oldPos.	"Copy the preamble""	preamble _ self name , ' methodsFor: ' ,			(self organization categoryOfElement: selector) asString printString."	file copyPreamble: preamble from: sourceFile.	"Copy the method chunk"	file copyMethodChunkFrom: sourceFile.	sourceFile skipSeparators.	"The following chunk may have ]style["	sourceFile peek == $] ifTrue: [		file cr; copyMethodChunkFrom: sourceFile].! !ChangeRecord removeSelector: #class:category:method:!Project removeSelector: #compileAllFrom:!Project removeSelector: #compileAllIsolated:!