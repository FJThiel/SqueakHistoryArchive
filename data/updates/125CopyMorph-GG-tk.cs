'From Squeak 2.0 of May 22, 1998 on 26 June 1998 at 9:40:59 pm'!Model subclass: #Player	instanceVariableNames: 'costume '	classVariableNames: 'BiggestSubclassNumber TimeOfError '	poolDictionaries: ''	category: 'Morphic-Scripting'!ReferenceStream subclass: #SmartRefStream	instanceVariableNames: 'structures steady reshaped renamed superclasses progressBar objCount classInstVars '	classVariableNames: 'ScannedObject '	poolDictionaries: ''	category: 'System-Object Storage'!!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Object methodsFor: 'copying' stamp: 'tk 6/23/1998 11:38'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	^ SmartRefStream new veryDeepCopy: self! !!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!DataStream commentStamp: 'tk 6/26/1998 21:40' prior: 0!This is the save-to-disk facility. A DataStream can store one or more objects in a persistent form.To handle objects with sharing and cycles, you must use aReferenceStream instead of a DataStream.  (Or SmartRefStream.)  ReferenceStream is typicallyfaster and produces smaller files because it doesn't repeatedly write the same Symbols.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.Each object to be stored has two opportunities to control what gets stored.  On the high level, objectToStoreOnDataStream allows you to substitute another object on the way out.  The low level hook is storeDataOn:. The read-in counterparts to these messages are comeFullyUpOnReload and (class) readDataFrom:size:. See these methods, and the class DiskProxy, for more information about externalizing and internalizing.NOTE: A DataStream should be treated as a write-stream for writing.  It is a read-stream for reading.  It is not a ReadWriteStream.!!Morph methodsFor: 'e-toy commands' stamp: 'tk 6/25/1998 16:10'!show	"Make sure this morph is on-stage."	| saved |	self world ifNil: [^ self].	"would like to set bounds, but we must be in a world"	(self fullBounds intersects: self world bounds) ifFalse: [		(saved _ self valueOfProperty: #relPosition) ifNil: [			"backward compatibility -- remove later"			saved _ self position - (1000000@100000) - owner position].		self position: saved + owner position.		self wrap].  "be sure I'm on-stage"! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/22/1998 18:02'!duplicateMorph	| newMorph |	newMorph _ argument veryDeepCopy.		false ifTrue: [newMorph _ argument usableDuplicateIn: self world].	"old"	self grabMorphFromMenu: newMorph.	newMorph costumee ifNotNil: [newMorph costumee startRunning].	" -- End of presently active code -- "	self flag: #noteToDan.  "The following code was formerly in duplicateMorph, and 		may need to be reincorporated somewhere:""	oldModel _ argument findA: MorphicModel.	oldModel ifNotNil:		[oldModel model duplicate: (new findA: MorphicModel) from: oldModel]."	self flag: #noteToTed.  "the following corrsponds to the hook you had in for getting script tiles straightened out:""	newMorph justDuplicatedFrom: argument.		We depend on nameInModel working, and hand having grabbed already (old tck note)"! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 6/26/1998 15:04'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesAndSizes.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!Player methodsFor: 'clone' stamp: 'tk 6/25/1998 17:06'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls civ ii |	newCls _ (self class officialClass instanceOfUniqueClassWithInstVarString: 			self class instanceVariablesString 		andClassInstVarString: self class class instanceVariablesString) class.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	civ _ self class class allInstVarNames.	ii _ civ indexOf: 'scripts'.	newCls instVarAt: ii put: self class scripts.	"later must duplicate this""	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]]."	ii _ civ indexOf: 'slotInfo'.	newCls instVarAt: ii put: self class slotInfo deepCopy.	ii _ civ indexOf: 'costumeDictionary'.	newCls instVarAt: ii put: self class costumeDictionary copy.	newCls copyAddedStateFrom: self class.  "The player-ref jump table?"	^ newCls! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii _ BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className _ (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii _ ii + 1].	BiggestSubclassNumber _ ii.	^ className	! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !!SmartRefStream commentStamp: 'tk 6/26/1998 21:41' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There should be a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!SmartRefStream reorganize!('read write' aComment appendClassDefns instVarInfo: mapClass: moreObjects next nextPut: nextPutObjOnly: noHeader readInstance readShortInst renamed restoreClassInstVars saveClassInstVars scanFrom: setStream: structures superclasses uniClasesDo: uniClassInstVarsRefs: verifyStructure versionSymbol: veryDeepClassVars: veryDeepCopy: veryDeepRectify:)('class changed shape' catalogValues:size: storeInstVarsIn:from: verifyClass:was:selector:newList:oldList: writeClassRenameMethod:was:fromInstVars: writeConversionMethod:class:was:fromInstVars:to:)('conversion' bookPageMorphbosfcepcbbfgcc0 clippingMorphbosfcep0 clippingMorphbosfcepc0 gradientFillbosfcepbbfgcc0 layoutMorphbosfcepbbochvimol0 layoutMorphbosfcepcbbochvimol0 mouseWillPlaytgpspm0)!!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ #marked.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object _ super next.	"all the action here"			self restoreClassInstVars.		"for UniClasses. version 4"			topCall _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 10:58'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream.	"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:00'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ #marked.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/25/1998 21:42'!veryDeepClassVars: refs	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo costumeDictionary) and player321 cross references.""Uniclasses use class vars to hold onto siblings who are referred to in code"| class val pp |pp _ Object class instSize + 1.refs do: [:each | "values = new ones"	"each is not a Metaclass and not a Class!!"	(class _ each class) isSystemDefined ifFalse: [		class classPool associationsDo: [:assoc |			(val _ refs at: assoc value ifAbsent: [nil]) ifNotNil: [				"If not in refs, then the right value is already in the field"				assoc value: val]].		pp to: class class instSize do: [:ii | 			(val _ refs at: (class instVarAt: ii) ifAbsent: [nil]) ifNotNil: [				"If not in refs, then the right value is already in the field"				class instVarAt: ii put: val]].		]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/26/1998 21:35'!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: assoc key comeFullyUpOnReload]]				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in shallowCopy"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		"ScannedObject _ refs."	"debug"	^ refs at: anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/24/1998 10:39'!veryDeepRectify: refs	"refs is a dictionary of (old object -> shallow copy of it).  For each field, map the value to a new object.  This is for copying, so if an object is not in refs, use its old value.	Rehash the Sets.  If any other class depends on the hashes of its inst vars, let is recompute also."	| hashers new class index sub val |	hashers _ OrderedCollection new.	refs associationsDo: [:assoc | 		assoc key == assoc value ifFalse: ["is a new object"			new _ assoc value.			class _ new class.			class isVariable				ifTrue: 					[index _ new basicSize.					[index > 0] whileTrue: 						[sub _ new basicAt: index.						(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [								"If not in refs, then the right value is already in the field"								new basicAt: index put: val].						index _ index - 1]].			index _ class instSize.			[index > 0] whileTrue: 				[sub _ new instVarAt: index.				(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [						"If not in refs, then the right value is already in the field"						new instVarAt: index put: val].				index _ index - 1].			(new respondsTo: #rehash) ifTrue: [hashers add: new].			]].	"Force new Sets and Dictionaries to rehash"	hashers do: [:each | each rehash].! !!StrikeFont methodsFor: 'accessing' stamp: 'tk 6/26/1998 16:45'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	^Array with: name		with: self height		with: emphasis	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:46'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| eval |	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	emphasis > 0 ifTrue: [self error: 'Synthietic fonts do not get written out. Proceed for plain font.'].	eval _ 'StrikeFont familyName: #', self name ,' size: ', self height printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval).! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:49'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name.	aStream space.	self height printOn: aStream.	aStream nextPut: $)! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 6/26/1998 14:42'!familyName: aName size: aSize	| aStyle |	(aStyle _ TextStyle named: aName asSymbol)		ifNil: [aStyle _ TextStyle default].	"substitute. OK not to copy"	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'examples' stamp: 'tk 6/26/1998 15:19'!update	"A temporary method to change the names of StrikeFonts.  New convention is that each StrikeFont is in a TextStyle that has only fonts of the same name (family).  The name of that TextStyle in TextConstants is the same name as the family name of this font.  Sizes are no longer in the name of the font."	"StrikeFont update"| sty |TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		"Transcript show: assoc key; space."		sty _ assoc value.		sty fontArray do: [:font | font name: assoc key]		]]].TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		sty _ assoc value.		sty fontArray do: [:font | 			(StrikeFont familyName: font name size: font height) == font ifFalse: [				self error: 'not same']]]]].! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!TextStyle methodsFor: 'accessing' stamp: 'tk 6/26/1998 15:03'!fontNamesAndSizes  "TextStyle default fontNames"	^ fontArray collect: [:x | x name, ' ', x height printString]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 6/26/1998 15:58'!collectionFromFileNamed: fileName	"Read the file.  It is an TextStyle whose StrikeFonts are to be added to the system.  (Written by fooling SmartRefStream, so it won't write a DiskProxy!!)  These fonts will be added to the master TextSytle for this font family.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		TextConstants at: #forceFontWriting put: true.		ff nextPut: (TextConstants at: #AFontName).			'do not mix font families in the TextStyle written out'.		TextConstants at: #forceFontWriting put: false.		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this newName style heights |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.	"Only works if file created by special code above"	newName _ this fontArray first name.	this fontArray do: [:aFont | aFont name = newName ifFalse: [		self error: 'All must be same family']].	style _ TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights _ style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !SmartRefStream removeSelector: #writing!"Rename lots of fonts and put their TextStyles into TextConstants."StrikeFont update.!