'From Squeak 2.5 of August 6, 1999 on 07 September 1999 at 10:49:34 pm'!"Change Set:		ListItemSelectByLetterDate:			26 September 1999Author:			Jason McVayE-mail:			jmcvay@bigfoot.comThis changeset allows you, when the focus is on a ListMorph, to hit any character key sans command keys and, if there is a list item that starts with that letter, it is highlighted.  Subsequent hits of the same letter selects the next item in the list that starts with that character.From now on you have to hit the command key in concert with a character in order to get at the special functions.  Personally, i think having to use the command key is more natural anyway...I made PluggableListMorph's instance variable always be represented by an OrderedCollection to make things work better for me."!!InputSensor methodsFor: 'modifier keys' stamp: 'JLM 9/26/1999 01:33'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command key"	^ ((self commandKeyPressed or: [self controlKeyPressed]) or: [self macOptionKeyPressed])! !!MorphicEvent methodsFor: 'keyboard' stamp: 'JLM 9/26/1999 06:04'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command 	key "	^ (self commandKeyPressed or: [self controlKeyPressed])		or: [self macOptionKeyPressed]! !!PluggableListMorph methodsFor: 'events' stamp: 'JLM 9/26/1999 07:02'!listHandlesBasicKeys	" if ya don't want the list to automatically handle non-modifier key (excluding shift key) input, return false "	^ true! !!PluggableListMorph methodsFor: 'selection' stamp: 'JLM 9/26/1999 06:56'!selectionIndex	selection == nil ifTrue: [^ 0" to avert a failure on nil"].	^ list find: selection! !!PluggableListMorph methodsFor: 'model access' stamp: 'JLM 9/26/1999 06:28'!getList	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst asOrderedCollection.! !!PluggableListMorph methodsFor: 'model access' stamp: 'JLM 9/26/1999 07:01'!keyStroke: event 	"Process potential command keys"	| args aChar aLowercaseChar oldSelection aSpecialKey nextSelection nextSelectionList nextSelectionText max howManyItemsShowing |	aChar _ event keyCharacter.	(event anyModifierKeyPressed or: [(self listHandlesBasicKeys) not])		ifTrue: 			[keystrokeActionSelector == nil ifTrue: [^ nil].			(args _ keystrokeActionSelector numArgs) = 1 ifTrue: [^ model perform: keystrokeActionSelector with: aChar].			args = 2 ifTrue: [^ model					perform: keystrokeActionSelector					with: aChar					with: self].			^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'].	oldSelection _ self selectionIndex.	nextSelection _ oldSelection.	aSpecialKey _ aChar asciiValue.	max _ self maximumSelection.	aSpecialKey < 32		ifTrue: 			[" one of a number of special keys"			aSpecialKey == 31				ifTrue: 					[" down arrow"					nextSelection _ oldSelection + 1.					nextSelection > max ifTrue: [nextSelection _ 1]].			aSpecialKey == 30				ifTrue: 					[" up arrow"					nextSelection _ oldSelection - 1.					nextSelection < 1 ifTrue: [nextSelection _ max]].			aSpecialKey == 1 ifTrue: [" home"				nextSelection _ 1].			aSpecialKey == 4 ifTrue: [" end"				nextSelection _ max].			howManyItemsShowing _ self numSelectionsInView.			aSpecialKey == 11 ifTrue: [" page up"				nextSelection _ 1 max: oldSelection - howManyItemsShowing].			aSpecialKey == 12 ifTrue: [" page down"				nextSelection _ oldSelection + howManyItemsShowing min: max].			^ self changeModelSelection: nextSelection].	aLowercaseChar _ aChar asLowercase.	nextSelectionList _ list copyFrom: oldSelection + 1 to: max.	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).	" make sure to get rid of blanks due to the hierarchal nature of some of 	           the collection entries"	nextSelectionText _ nextSelectionList detect: [:a | (a withBlanksTrimmed at: 1) asLowercase == aLowercaseChar]				ifNone: [nextSelectionText _ nil].	nextSelectionText ~~ nil		ifTrue: 			[nextSelection _ list findFirst: [:a | a == nextSelectionText].			^ self changeModelSelection: nextSelection]		ifFalse: [self flash]! !