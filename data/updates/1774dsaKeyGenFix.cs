'From Squeak 2.5 of August 6, 1999 on 11 January 2000 at 12:30:37 am'!"Change Set:		dsaKeyGenFixDate:			10 January 2000Author:			John MaloneyFixes a bug in remainder:mod: and adds a test method for it.Makes isProbablyPrime: work for small primes. Adds an optionto initialize the random number generator from the sound input."!!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jm 1/11/2000 00:25'!initRandom: randomInteger	"Initialize the the secure random number generator with the given value. The argument should be a positive integer of up to 512 bits chosen randomly to avoid someone being able to predict the sequence of random values generated."	"Note: The random generator must be initialized before generating a key set or signature. Signature verification does not require initialization of the random generator."	randSeed _ 16rEFCDAB8998BADCFE10325476C3D2E1F067452301.  "initial seed"	randKey _ randomInteger.	Transcript show: 'Random seed: ', randomInteger printString; cr.! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jm 1/11/2000 00:13'!randomBitsFromSoundInput: bitCount	"Answer a positive integer with the given number of random bits of 'noise' from a sound input source. Typically, one would use a microphone or line input as the sound source, although many sound cards have enough thermal noise that you get random low-order sample bits even with no microphone connected. Only the least signficant bit of the samples is used. Since not all sound cards support 16-bits of sample resolution, we use the lowest bit that changes."	"(1 to: 10) collect: [:i | DigitalSignatureAlgorithm new randomBitsFromSoundInput: 512]"	| recorder buf mid samples bitMask randomBits bit |	"collect some sound data"	recorder _ SoundRecorder new clearRecordedSound.	recorder resumeRecording.	(Delay forSeconds: 1) wait.	recorder stopRecording.	buf _ recorder condensedSamples.	"grab bitCount samples from the middle"	mid _ buf monoSampleCount // 2.	samples _ buf copyFrom: mid to: mid + bitCount - 1.	"find the least significant bit that varies"	bitMask _ 1.	[bitMask < 16r10000 and:	 [(samples collect: [:s | s bitAnd: bitMask]) asSet size < 2]]		whileTrue: [bitMask _ bitMask bitShift: 1].	bitMask = 16r10000 ifTrue: [^ self error: 'sound samples do not vary'].	"pack the random bits into a positive integer"	randomBits _ 0.	1 to: samples size do: [:i |		bit _ ((samples at: i) bitAnd: bitMask) = 0 ifTrue: [0] ifFalse: [1].		randomBits _ (randomBits bitShift: 1) + bit].	^ randomBits	! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 1/10/2000 20:38'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations _ 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes _ Integer primesUpTo: 2000.		SmallPrimes _ SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor _ SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne _ p - 1.	b _ self logOfLargestPowerOfTwoDividing: pMinusOne.	m _ pMinusOne // (2 raisedTo: b).	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r _ Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a _ (r next * 16rFFFFFF) truncated.		j _ 0.		z _ self raise: a to: m mod: p.		couldBePrime _ z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime _ true]				ifFalse: [					(j _ j + 1) < b						ifTrue: [z _ self remainder: (z * z) mod: p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 1/10/2000 19:38'!remainder: x mod: y	"Answer the remainder of dividing x by y, where x and y are both large positive integers of at least two digits."	| remainder divisor shift quotient  |	remainder _ x.	divisor _ y.	"Pre-scale operands so the divisor's top digit is >= 128. This makes it	 possible to estimate the next digit of the division with very high	 probability that the first guess is correct. Knuth says so!!"	shift _ 8 - (HighBitOfByte at: ((divisor digitAt: divisor digitLength) + 1)).	shift > 0 ifTrue: [		remainder _ remainder bitShift: shift.		divisor _ divisor bitShift: shift].	"copy remainder with a leading zero and allocate quotient"	remainder _ remainder		copyto: (LargePositiveInteger new: remainder digitLength + 1).	divisor digitLength < 5 ifTrue: [divisor _ self asLargePositiveInteger: divisor].	quotient _ LargePositiveInteger new: remainder digitLength - divisor digitLength.	"do the actual division"	self primDivideLoopPrimRem: remainder div: divisor quo: quotient.	"rescale or normalize the remainder"	shift > 0		ifTrue: [remainder _ remainder bitShift: shift negated]		ifFalse: [remainder _ self normalize: remainder].	^ remainder! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 1/11/2000 00:08'!generateKeySet	"Generate and answer a key set for code signing. The result is a pair (<private key><public key>). Each key is an array of four large integers. The signer must be sure to record this keys set and must keep the private key secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	"Note: Unguessable random numbers are needed for key generation. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before generating a key set. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	"DigitalSignatureAlgorithm generateKeySet"	| dsa |	dsa _ DigitalSignatureAlgorithm new.	(self confirm: 'Shall I seed the random generator from the current sound input?')		ifTrue: [dsa initRandom: (dsa randomBitsFromSoundInput: 512)]		ifFalse: [dsa initRandomFromUser].	^ dsa generateKeySet! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'jm 1/10/2000 19:41'!exerciseRemainder: iterationCount	"Exercise the remainder method on iterationCount pairs of random 60 bit integers."	"DigitalSignatureAlgorithm exerciseRemainder: 10000"	| dsa r c d tmp rem |	dsa _ DigitalSignatureAlgorithm new.	r _ Random new.	iterationCount timesRepeat: [		c _ ((r next * 16r3FFFFFFF highBit) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		d _ ((r next * 16r3FFFFFFF) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		c < d ifTrue: [tmp _ c. c _ d. d _ tmp].		rem _ dsa remainder: c mod: d.		rem = (c \\ d) ifFalse: [self error: 'bad remainder']].	self inform: 'remainder:mod: passed ', iterationCount printString, ' tests'.! !