'From Squeak3.6alpha of ''17 March 2003'' [latest update: #5278] on 2 July 2003 at 8:48:49 am'!"Change Set:		KCP85a-nkDate:			2 July 2003Author:			Ned KonzOriginal:Change Set:		KCP-0085-MoveToChangeSetDate:			22 May 2003Author:			Stephane DucasseThis changeset prepares to deprecate the SystemDictionary methods related to changeSet and fix senders.(Also merged some conflicts with more recent updates in SystemDictionary>>majorShrink and ProjectLoading class>>openName:stream:fromDirectory:withProjectView:. -dew)""ChangeSet current: Smalltalk changes!!ChangeSet methodsFor: 'testing' stamp: 'sd 5/23/2003 14:24'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == self class current ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 15:14'!checkForConversionMethods	"See if any conversion methods are needed"	| oldStruct newStruct tell choice list needsel smart restore renamed listAdd listDrop msgSet rec nn |	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"	structures ifNil: [^ self].	list _ OrderedCollection new.	renamed _ OrderedCollection new.	self changedClasses do: [:class |		need _ (self atClass: class includes: #new) not.		need ifTrue: ["Renamed classes."			(self atClass: class includes: #rename) ifTrue: [				rec _ changeRecords at: class name.				rec priorName ifNotNil: [					(structures includesKey: rec priorName) ifTrue: [						renamed add: class.  need _ false]]]].		need ifTrue: [need _ (self atClass: class includes: #change)].		need ifTrue: [oldStruct _ structures at: class name 									ifAbsent: [need _ false.  #()]].		need ifTrue: [			newStruct _ (Array with: class classVersion), (class allInstVarNames).			need _ (oldStruct ~= newStruct)].		need ifTrue: [sel _ #convertToCurrentVersion:refStream:.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				list add: class]].		].	list isEmpty & renamed isEmpty ifTrue: [^ self].	"Ask user if want to do this"	tell _ 'If there might be instances of ', (list asArray, renamed asArray) printString,		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'			withCRs,		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.	choice _ (PopUpMenu labels: 'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.') startUpWithCaption: tell. 	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"			list do: [:cls | structures removeKey: cls name ifAbsent: []].			renamed do: [:cls | 				nn _ (changeRecords at: cls name) priorName.				structures removeKey: nn ifAbsent: []]].	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"	listAdd _ self askAddedInstVars: list.	"Go through each inst var that was added"	listDrop _ self askRemovedInstVars: list.	"Go through each inst var that was removed"	list _ (listAdd, listDrop) asSet asArray.	smart _ SmartRefStream on: (RWBinaryOrTextStream on: '12345').	smart structures: structures.	smart superclasses: superclasses.	(restore _ self class current) == self ifFalse: [		self class  newChanges: self].	"if not current one"	msgSet _ smart conversionMethodsFor: list.		"each new method is added to self (a changeSet).  Then filed out with the rest."	self askRenames: renamed addTo: msgSet using: smart.	"renamed classes, add 2 methods"	restore == self ifFalse: [self class current newChanges: restore].	msgSet messageList isEmpty ifTrue: [^ self].	self inform: 'Remember to fileOut again after modifying these methods.'.	MessageSet open: msgSet name: 'Conversion methods for ', self name.! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'sd 5/23/2003 14:25'!defaultChangeSetToShow	"Answer the name of a change-set to show"	^ ChangeSet current! !!ClassBuilder methodsFor: 'class definition' stamp: 'sd 5/23/2003 14:51'!recompile: force from: oldClass to: newClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	oldClass == nil ifTrue:[		"newClass has an empty method dictionary		so we don't need to recompile"		ChangeSet current addClass: newClass.		^newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		"No recompilation necessary but we might have added		class vars or class pools so record the change"		ChangeSet current changeClass: newClass from: oldClass.		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		ChangeSet current changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		ChangeSet current changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.	].	^oldClass "now mutated to newClass"! !!ClassBuilder methodsFor: 'private' stamp: 'sd 5/23/2003 14:33'!recordClass: oldClass replacedBy: newClass	"Keep the changes up to date when we're moving instVars around"	(instVarMap includesKey: oldClass name) ifTrue:[		ChangeSet current changeClass: newClass from: oldClass.	].! !!ClassDescription methodsFor: 'accessing' stamp: 'sd 5/23/2003 14:34'!comment: aStringOrText	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText.	ChangeSet current commentClass: self.	Utilities noteMethodSubmission: #Comment forClass: self theNonMetaClass! !!ClassDescription methodsFor: 'accessing' stamp: 'sd 5/23/2003 14:34'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.	ChangeSet current commentClass: self theNonMetaClass.	Utilities noteMethodSubmission: #Comment forClass: self theNonMetaClass! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sd 5/23/2003 14:34'!removeSelector: selector 	| priorMethod | 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	(self methodDict includesKey: selector) ifFalse: [^ nil].	priorMethod _ self compiledMethodAt: selector.	ChangeSet current removeSelector: selector class: self		priorMethod: priorMethod		lastMethodInfo: {priorMethod sourcePointer.						(self whichCategoryIncludesSelector: selector)}.	super removeSelector: selector.	self organization removeElement: selector.	self acceptsLoggingOfCompilation ifTrue:		[self environment logChange: self name , ' removeSelector: #' , selector]! !!ClassDescription methodsFor: 'compiling' stamp: 'sd 5/23/2003 14:34'!compile: code notifying: requestor trailer: bytes 		ifFail: failBlock		elseSetSelectorAndNode: selAndNodeBlock	"Intercept this message in order to remember system changes.	 5/15/96 sw: modified so that if the class does not wish its methods logged in the changes file, then they also won't be accumulated in the current change set.	7/12/96 sw: use wantsChangeSetLogging to determine whether to put in change set"	| methodNode selector newMethod priorMethodOrNil |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	selector _ methodNode selector.	selAndNodeBlock value: selector value: methodNode.	requestor ifNotNil:		["Note this change for recent submissions list"		Utilities noteMethodSubmission: selector forClass: self].	methodNode encoder requestor: requestor.  "Why was this not preserved?"	newMethod _ methodNode generate: bytes.	priorMethodOrNil _ (self methodDict includesKey: selector)		ifTrue: [self compiledMethodAt: selector]		ifFalse: [nil].	ChangeSet current noteNewMethod: newMethod forClass: self		selector: selector priorMethod: priorMethodOrNil.	self addSelector: selector withMethod: newMethod.	^ newMethod! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:51'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue:		[ChangeSet current commentClass: self.		^ self organization classComment: aString stamp: aStamp].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil:		[file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	ChangeSet current commentClass: self.	organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:35'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	ChangeSet current reorganizeClass: self.	^self organization!]style[(10 156 22 80)f1b,f1,f1LReadWriteStream fileIn;,f1! !!Class methodsFor: 'class variables' stamp: 'sd 5/23/2003 14:29'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol |	aString first isLowercase		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		subclass scopeHas: symbol			ifTrue: [:temp | 					^ self error: aString 						, ' is already used as a variable name in class ' 						, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		ChangeSet current changeClass: self from: self.		classPool declare: symbol from: Undeclared]! !!Class methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:33'!removeFromChanges	"References to the receiver, a class, and its metaclass should no longer be included in the system ChangeSet.	7/18/96 sw: call removeClassAndMetaClassChanges:"	ChangeSet current removeClassAndMetaClassChanges: self! !!DualChangeSorter methodsFor: 'initialization' stamp: 'sd 5/23/2003 14:38'!morphicWindow		| window |	leftCngSorter _ ChangeSorter new myChangeSet: ChangeSet current.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	^ window! !!DualChangeSorter methodsFor: 'initialization' stamp: 'sd 5/23/2003 14:38'!open	| topView |	Smalltalk isMorphic | Sensor leftShiftDown ifTrue: [^ self openAsMorph].	leftCngSorter _ ChangeSorter new myChangeSet: ChangeSet current.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	topView _ (StandardSystemView new) model: self; borderWidth: 1.	topView label: leftCngSorter label.	topView minimumSize: 300 @ 200.	leftCngSorter openView: topView offsetBy: 0@0.	rightCngSorter openView: topView offsetBy: 360@0.	topView controller open.! !!DualChangeSorter methodsFor: 'other' stamp: 'sd 5/23/2003 14:38'!labelString	"The window label"	| leftName rightName changesName |	leftName _ leftCngSorter changeSetCategory categoryName.	rightName _ rightCngSorter changeSetCategory categoryName.	changesName _ 'Changes go to "', ChangeSet current name,  '"'.	^ ((leftName ~~ #All) or: [rightName ~~ #All])		ifTrue:			['(', leftName, ') - ', changesName, ' - (', rightName, ')']		ifFalse:			[changesName]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:40'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [ChangeSet current preambleString == nil])		ifTrue: [ChangeSet current preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [ChangeSet current postscriptString == nil])		ifTrue: [ChangeSet current postscriptString: chunk].							! !!Project methodsFor: 'menu messages' stamp: 'sd 5/23/2003 15:15'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	self installProjectPreferences.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		world triggerEvent: #aboutToEnterWorld.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: 'menu messages' stamp: 'sd 5/23/2003 15:16'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject _ self.	Display newDepthNoRestore: displayDepth.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	World pauseEventRecorder.	world isMorph		ifTrue:			["Entering a Morphic project"			World _ world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World _ nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess _ Processor activeProcess.! !!Project methodsFor: 'menu messages' stamp: 'sd 5/23/2003 14:40'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ ChangeSet current.	thumbnail ifNotNil: [thumbnail hibernate].	Smalltalk isMorphic		ifTrue:			[world _ World.			world sleep.			ActiveWorld _ ActiveHand _ ActiveEvent _ nil]		ifFalse:			[world _ ScheduledControllers.			ScheduledControllers unCacheWindows].	Sensor flushAllButDandDEvents. "Will be reinstalled by World>>install"	transcript _ Transcript.! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'sd 5/23/2003 15:16'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList proj trusted localDir projStream archive mgr projectsToBeDeleted baseChangeSet |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"		^self inform: 'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,'	].	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	preStream isZipArchive 		ifTrue:[	archive _ ZipArchive new readFrom: preStream.				projStream _ self projectStreamFromArchive: archive]		ifFalse:[projStream _ preStream].	trusted _ SecurityManager default positionToSecureContentsOf: projStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(preStream respondsTo: #close) ifTrue:[preStream close].		^self]].	localDir _ Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName ~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) 				nextPutAll: preStream contents;				close.		].	].	morphOrList _ projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet _ ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	[morphOrList _ morphOrList fileInObjectAndCode] ensure: [				ChangeSet  newChanges: baseChangeSet].	mgr _ ResourceManager new initializeFrom: ResourceCollector current.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName: aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots 			detect: [:mm | mm class == Project] 			ifNone: [^self inform: 'No project found in this file'].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		CurrentProjectRefactoring currentBeParentTo: proj.		projectsToBeDeleted _ OrderedCollection new.		existingView ifNil: [			Smalltalk isMorphic ifTrue: [				proj createViewIfAppropriate.			] ifFalse: [				ChangeSorter allChangeSets add: proj changeSet.				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSorter allChangeSets add: proj changeSet.		Project current projectParameters 			at: #deleteWhenEnteringNewProject 			ifPresent: [ :ignored | 				projectsToBeDeleted add: Project current.				Project current removeParameter: #deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters 				at: #projectsToBeDeleted 				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	(Project newMorphicOn: morphOrList) enter! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'sd 5/23/2003 15:16'!useTempChangeSet	"While reading the project in, use the temporary change set zzTemp"	| zz |	zz _ ChangeSorter changeSetNamed: 'zzTemp'.	zz ifNil: [zz _ ChangeSorter basicNewChangeSet: 'zzTemp'].	ChangeSet  newChanges: zz.! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sd 5/23/2003 14:41'!fileOutChanges	"Append to the receiver a description of all class changes."	Cursor write showWhile:		[self header; timeStamp.		ChangeSet current fileOutOn: self.		self trailer; close]! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/23/2003 15:17'!browseChangedMessages	ChangeSet  browseChangedMessages! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/23/2003 14:41'!lookForSlips	ChangeSet current lookForSlips! !!SmartRefStream methodsFor: 'import image segment' stamp: 'sd 5/23/2003 14:41'!mapClass: newClass origName: originalName	"See if instances changed shape.  If so, make a fake class for the old shape and return it.  Remember the original class name."	| newName oldInstVars fakeClass |	newClass isMeta ifTrue: [^ newClass].	newName _ newClass name.	(steady includes: newClass) & (newName == originalName) ifTrue: [^ newClass].		"instances in the segment have the right shape"	oldInstVars _ structures at: originalName ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	fakeClass _ Object subclass: ('Fake37', originalName) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	ChangeSet current removeClassChanges: fakeClass name.	"reduce clutter"	^ fakeClass! !!StringHolder methodsFor: 'message list menu' stamp: 'sd 5/23/2003 14:42'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotation! !!CodeHolder methodsFor: 'commands' stamp: 'sd 5/23/2003 14:35'!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self setClassAndSelectorIn: [:cl :sel |		cl ifNotNil:			[ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotation]]! !!Browser methodsFor: 'class functions' stamp: 'sd 5/23/2003 14:23'!addAllMethodsToCurrentChangeSet	"Add all the methods in the selected class or metaclass to the current change set.  You ought to know what you're doing before you invoke this!!"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[aClass selectors do:			[:sel |				ChangeSet current adoptSelector: sel forClass: aClass].		self changed: #annotation]! !!Browser methodsFor: 'message category functions' stamp: 'sd 5/23/2003 14:23'!alphabetizeMessageCategories	classListIndex = 0 ifTrue: [^ false].	self okToChange ifFalse: [^ false].	ChangeSet current reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer sortCategories.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'sd 5/23/2003 14:23'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	ChangeSet current reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer changeFromString: aString.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'sd 5/23/2003 14:23'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(oldIndex _ messageCategoryListIndex) = 0 ifTrue: [^ self].	oldName _ self selectedMessageCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	newName = oldName ifTrue: [^ self].	ChangeSet current reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self classListIndex: classListIndex.	self messageCategoryListIndex: oldIndex.	self changed: #messageCategoryList.! !!ChangeList methodsFor: 'menu actions' stamp: 'sd 5/23/2003 14:24'!selectConflicts	"Selects all method definitions for which there is ALSO an entry in changes"	| change class  |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change _ changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class _ change methodClass) notNil			and: [(ChangeSet current atSelector: change methodSelector						class: class) ~~ #none]])]].	self changed: #allSelections! !!ChangeSorter methodsFor: 'creation' stamp: 'sd 5/23/2003 14:25'!morphicWindow	"ChangeSorter new openAsMorph"	|  window |	myChangeSet ifNil: [self myChangeSet: ChangeSet current]. 	window _ (SystemWindow labelled: self labelString) model: self.	self openAsMorphIn: window rect: (0@0 extent: 1@1).	^ window! !!ChangeSorter methodsFor: 'creation' stamp: 'sd 5/23/2003 14:26'!open	"ChangeSorterPluggable new open"	| topView |	Smalltalk isMorphic | Sensor leftShiftDown ifTrue: [^ self openAsMorph].	topView _ StandardSystemView new.	topView model: self.	myChangeSet ifNil: [self myChangeSet: ChangeSet current]. 	topView label: self labelString.	topView borderWidth: 1; minimumSize: 360@360.	self openView: topView offsetBy: 0@0.	topView controller open.! !!ChangeSorter methodsFor: 'access' stamp: 'sd 5/23/2003 14:25'!labelString	"The label for my entire window.  The large button that displays my name is gotten via mainButtonName"	^ String streamContents:		[:aStream |			aStream nextPutAll: (ChangeSet current == myChangeSet				ifTrue: ['Changes go to "', myChangeSet name, '"']				ifFalse: ['ChangeSet: ', myChangeSet name]).		(self changeSetCategory categoryName ~~ #All)			ifTrue:				[aStream nextPutAll:  ' - ', self parenthesizedCategoryName]]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sd 5/23/2003 15:15'!newCurrent	"make my change set be the current one that changes go into"	ChangeSet  newChanges: myChangeSet.	self update.  "Because list of changes in a category may thus have changed"	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sd 5/23/2003 14:26'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg _ myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(self confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber _ myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangeSorter removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!ChangeSorter class methodsFor: 'adding' stamp: 'sd 5/23/2003 15:15'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet _ self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!ChangeSorter class methodsFor: 'adding' stamp: 'sd 5/23/2003 15:15'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet |	oldChanges _ ChangeSet current.	PreviousSet _ oldChanges name. 		"so a Bumper update can find it"	newName _ aName sansPeriodSuffix.	newSet _ self basicNewChangeSet: newName.	[newSet ifNotNil:		[ChangeSet  newChanges: newSet.		aStream fileInAnnouncing: 'Loading ', newName, '...'.		Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName].	aStream close] ensure: [			ChangeSet  newChanges: oldChanges].	^ newSet! !!ChangeSorter class methodsFor: 'services' stamp: 'sd 5/23/2003 14:27'!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  "	AllChangeSets size = 1 ifTrue: [^ AllChangeSets first].	AllChangeSets last == ChangeSet current		ifTrue: 	[^ AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[^ AllChangeSets last]! !!MessageSet methodsFor: 'filtering' stamp: 'sd 5/23/2003 14:38'!filterToCurrentChangeSet	"Filter the receiver's list down to only those items in the current change set"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(ChangeSet current atSelector: aSelector class: aClass) ~~ #none]]! !!MessageSet methodsFor: 'filtering' stamp: 'sd 5/23/2003 14:38'!filterToNotCurrentChangeSet	"Filter the receiver's list down to only those items not in the current change set"	self filterFrom:		[:aClass :aSelector |			(aClass notNil and: [aSelector notNil]) and:				[(ChangeSet current atSelector: aSelector class: aClass) == #none]]! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 5/23/2003 14:38'!selectorsChanged	"Return a list of methods in the current change set (or satisfying some 	other such criterion) that are in the protocol of this object"	| aList aClass targetedClass |	targetedClass _ self targetObject				ifNil: [targetClass]				ifNotNil: [self targetObject class].	aList _ OrderedCollection new.	ChangeSet current methodChanges		associationsDo: [:classChgAssoc | classChgAssoc value				associationsDo: [:methodChgAssoc | (methodChgAssoc value == #change							or: [methodChgAssoc value == #add])						ifTrue: [(aClass _ targetedClass whichClassIncludesSelector: methodChgAssoc key)								ifNotNil: [aClass name = classChgAssoc key										ifTrue: [aList add: methodChgAssoc key]]]]].	^ aList! !!SystemDictionary methodsFor: 'browsing' stamp: 'sd 5/23/2003 15:17'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	self deprecatedExplanation: 'Use ChangeSet current browseChangedMessages'.	ChangeSet  browseChangedMessages! !!SystemDictionary methodsFor: 'class names' stamp: 'sd 5/22/2003 23:08'!removeClassFromSystem: aClass logged: aBool	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	aBool ifTrue:[		aClass wantsChangeSetLogging ifTrue:			[ChangeSet current noteRemovalOf: aClass].		aClass acceptsLoggingOfCompilation ifTrue:			[Smalltalk logChange:  'Smalltalk removeClassNamed: #', aClass name].	].	SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'class names' stamp: 'sd 5/22/2003 23:08'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	| oldref i |	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	ChangeSet current renameClass: aClass as: newName.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sd 5/23/2003 14:52'!makeSqueaklandRelease	"Smalltalk makeSqueaklandRelease"	"NOTE: This method assumes that 	* ALL WINDOWS HAVE BEEN CLOSED (most importantly all project 	windows) * ALL GLOBAL FLAPS HAVE BEEN DESTROYED (not just disabled) 	This method may needs to be run twice - upon the first run you will 	probably receive an error message saying 'still have obsolete 	behaviors'. Close the notifier and try again. If there are still obsolete 	behaviors then go looking for them. 	Last update: ar 8/18/2001 01:14 for Squeak 3.1"	| ss |	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.')		ifFalse: [^ self].	"Delete all projects"	Project		allSubInstancesDo: [:p | p == Project current				ifFalse: [Project deletingProject: p]].	"Fix up for some historical problem"	self systemNavigation		allObjectsDo: [:o | o isMorph				ifTrue: [o removeProperty: #undoGrabCommand]].	"Hm ... how did this come in?!!"	Smalltalk keys		do: [:x | (x class == String					and: [(Smalltalk at: x) isBehavior])				ifTrue: [Smalltalk removeKey: x]].	"Remove stuff from References"	References keys		do: [:k | References removeKey: k].	"Reset command history"	CommandHistory resetAllHistory.	"Clean out Undeclared"	Undeclared removeUnreferencedKeys.	"Reset scripting system"	StandardScriptingSystem initialize.	"Reset preferences"	Preferences chooseInitialSettings; installBrightWindowColors.	"Do a nice fat GC"	Smalltalk garbageCollect.	"Dependents mean that we're holding onto stuff"	(Object classPool at: #DependentsFields) size > 1		ifTrue: [self error: 'Still have dependents'].	"Set a few default preferences"	#(#(#honorDesktopCmdKeys #false) #(#warnIfNoChangesFile #false) #(#warnIfNoSourcesFile #false) #(#showDirectionForSketches #true) #(#menuColorFromWorld #false) #(#unlimitedPaintArea #true) #(#useGlobalFlaps #false) #(#mvcProjectsAllowed #false) #(#projectViewsInWindows #false) #(#automaticKeyGeneration #true) #(#securityChecksEnabled #true) #(#showSecurityStatus #false) #(#startInUntrustedDirectory #true) #(#warnAboutInsecureContent #false) #(#promptForUpdateServer #false) #(#fastDragWindowForMorphic #false) )		do: [:spec | Preferences setPreference: spec first toValue: spec last == #true].	"Initialize Browser (e.g., reset recent classes etc)"	Browser initialize.	"Check for Undeclared"	Undeclared isEmpty		ifFalse: [self error: 'Please clean out Undeclared'].	"Remove graphics we don't want"	ScriptingSystem deletePrivateGraphics.	"Remove a few text styles"	#(#Helvetica #Palatino #Courier )		do: [:n | TextConstants				removeKey: n				ifAbsent: []].	"Dump all player uniclasses"	Smalltalk		at: #Player		ifPresent: [:player | player				allSubclassesDo: [:cls | cls isSystemDefined						ifFalse: [cls removeFromSystem]]].	"Dump all Wonderland uniclasses"	Smalltalk		at: #WonderlandActor		ifPresent: [:wnldActor | wnldActor				allSubclassesDo: [:cls | cls isSystemDefined						ifFalse: [cls removeFromSystem]]].	"Attempt to get rid of them"	Smalltalk garbageCollect.	"Now remove larger parts"	Smalltalk discardFFI; discard3D; discardSUnit; discardSpeech; discardVMConstruction; discardPWS; discardIRC.	"Dump change sets"	ChangeSorter		removeChangeSetsNamedSuchThat: [:cs | cs name ~= ChangeSet current name].	"Clear current change set"	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk garbageCollect.	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	"Remove refs to old ControlManager"	ScheduledControllers _ nil.	"Flush obsolete subclasses"	Behavior flushObsoleteSubclasses.	Smalltalk garbageCollect.	Smalltalk obsoleteBehaviors isEmpty		ifFalse: [self error: 'Still have obsolete behaviors'].	"Clear all server entries"	ServerDirectory serverNames		do: [:each | ServerDirectory removeServerNamed: each].	SystemVersion current resetHighestUpdate.	ss _ Set allSubInstances.	'Rehashing all sets'		displayProgressAt: Sensor cursorPoint		from: 1		to: ss size		during: [:bar | 1				to: ss size				do: [:i | 					bar value: i.					(ss at: i) rehash]].	Smalltalk obsoleteClasses isEmpty		ifFalse: [self halt].	self halt: 'Ready to condense changes or sources'.	SystemDictionary removeSelector: #makeSqueaklandRelease! !!SystemDictionary methodsFor: 'shrinking' stamp: 'sd 5/23/2003 15:16'!fileOutAndRemove: rootClasses withOtherClasses: otherClasses andOtherMessages: otherMessages	"classesAndMethodsPair is {set of class names. set of selectors}."	| changeSet cl priorChanges |	"First fileOut all classes and methods..."	changeSet _ ChangeSorter basicNewChangeSet:  rootClasses first, 'EtAl'.	rootClasses , otherClasses do:		[:n | changeSet addClass: (cl _ Smalltalk at: n).		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | changeSet atSelector: sel class: cls put: #add]]].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (otherMessages includes: sel) ifTrue:					[changeSet atSelector: sel class: cls put: #add]]]].	Preferences checkForSlips		ifTrue: [Preferences disable: #checkForSlips.				changeSet fileOut.				Preferences enable: #checkForSlips]		ifFalse: [changeSet fileOut].	"Now remove all classes and methods..."	priorChanges _ ChangeSet current.  "Save current changeSet"	ChangeSet  newChanges: changeSet.  "just a place to dump removals"	rootClasses do:		[:n | cl _ Smalltalk at: n.  "Root classes get left, but all methods removed."		{cl. cl class} do:			[:cls | cls zapOrganization.			cls selectors do: [:sel | cls removeSelectorSimply: sel]]].	(ChangeSet superclassOrder: (otherClasses collect: [:n | (Smalltalk at: n)])) reverseDo:		[:cls | cls removeFromSystem].	Smalltalk classNames do:		[:n | cl _ Smalltalk at: n.		{cl. cl class} do:			[:cls | cls selectors do:				[:sel | (otherMessages includes: sel) ifTrue:					[cls removeSelectorSimply: sel]]]].	ChangeSet  newChanges: priorChanges.  "Restore current changeSet"	ChangeSorter removeChangeSet: changeSet.	changeSet _ nil.  "Try to avoid registering this as a normal changeSet."	Smalltalk garbageCollect! !!SystemDictionary methodsFor: 'shrinking' stamp: 'sd 5/23/2003 14:43'!lastRemoval			"Smalltalk lastRemoval"	 | oldDicts newDicts |	"Some explicit removals - add unwanted methods keeping other methods."	#(abandonSources printSpaceAnalysis)		do: [:each | self class removeSelector: each].	"Get rid of all unsent methods."	[self removeAllUnSentMessages > 0] whileTrue.	"Shrink method dictionaries."	Smalltalk garbageCollect.	oldDicts _ MethodDictionary allInstances.	newDicts _ Array new: oldDicts size.	oldDicts withIndexDo: [:d :index | 		newDicts at: index put: d rehashWithoutBecome.	].	oldDicts elementsExchangeIdentityWith: newDicts.	oldDicts _ newDicts _ nil.	Smalltalk allClassesDo: [:c | c zapOrganization].	SystemOrganization _ nil.	ChangeSet current initialize! !!SystemDictionary methodsFor: 'shrinking' stamp: 'sd 5/23/2003 15:17'!majorShrink    	"Undertake a major shrinkage of the image.	This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  majorShrink produces a 999k image in Squeak 2.8	Smalltalk majorShrink; abandonSources; lastRemoval"	| oldDicts newDicts |	Smalltalk isMorphic ifTrue: [^ self error: 'You can only run majorShrink in MVC'].	Project current isTopProject ifFalse: [^ self error: 'You can only run majorShrink in the top project'].	(Smalltalk confirm: 'All sub-projects will be deleted from this image.You should already have made a backup copy,or you must save with a different name after shrinking.Shall we proceed to discard most of the content in this image?')		ifFalse: [^ self inform: 'No changes have been made.'].	"Remove all projects but the current one.  - saves 522k"	ProjectView allInstancesDo: [:pv | pv controller closeAndUnscheduleNoTerminate].	Project current setParent: Project current.	MorphWorldView allInstancesDo: [:pv | pv topView controller closeAndUnscheduleNoTerminate].	Smalltalk at: #Wonderland ifPresent:[:cls| cls removeActorPrototypesFromSystem].	Player freeUnreferencedSubclasses.	MorphicModel removeUninstantiatedModels.	Utilities classPool at: #ScrapsBook put: nil.	Utilities zapUpdateDownloader.	ProjectHistory currentHistory initialize.	Project rebuildAllProjects.	"Smalltalk discardVMConstruction."  "755k"	Smalltalk discardSoundSynthesis.  "544k"	Smalltalk discardOddsAndEnds.  "227k"	Smalltalk discardNetworking.  "234k"	"Smalltalk discard3D."  "407k"	Smalltalk discardFFI.  "33k"	Smalltalk discardMorphic.  "1372k"	Symbol rehash.  "40k"	"Above by itself saves about 4,238k"	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewImageImports.	"Now delete various other classes.."	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'System-Object Storage'.	Smalltalk removeClassNamed: #ProjectController.	Smalltalk removeClassNamed: #ProjectView.	"Smalltalk removeClassNamed: #Project."	Smalltalk removeClassNamed: #Environment.	Smalltalk removeClassNamed: #Component1.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	RemoteString removeSelector: #makeNewTextAttVersion.	Utilities class removeSelector: #absorbUpdatesFromServer.	Smalltalk removeClassNamed: #PenPointRecorder.	Smalltalk removeClassNamed: #Path.	Smalltalk removeClassNamed: #Base64MimeConverter.	"Smalltalk removeClassNamed: #EToySystem. Dont bother - its very small and used for timestamps etc"	Smalltalk removeClassNamed: #RWBinaryOrTextStream.	Smalltalk removeClassNamed: #AttributedTextStream.	Smalltalk removeClassNamed: #WordNet.	Smalltalk removeClassNamed: #SelectorBrowser.	TextStyle allSubInstancesDo:		[:ts | ts newFontArray: (ts fontArray copyFrom: 1 to: (2 min: ts fontArray size))].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	ChangeSet  noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: ChangeSet current).	SystemDictionary removeSelector: #majorShrink.	[Smalltalk removeAllUnSentMessages > 0]		whileTrue:		[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]].	SystemOrganization removeEmptyCategories.	Smalltalk allClassesDo: [:c | c zapOrganization].	Smalltalk garbageCollect.	'Rehashing method dictionaries . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: MethodDictionary instanceCount		during: [:bar |			oldDicts _ MethodDictionary allInstances.			newDicts _ Array new: oldDicts size.			oldDicts withIndexDo: [:d :index | 				bar value: index.				newDicts at: index put: d rehashWithoutBecome.			].			oldDicts elementsExchangeIdentityWith: newDicts.		].	oldDicts _ newDicts _ nil.	Project rebuildAllProjects.	ChangeSet current initialize.		"seems to take more than one try to gc all the weak refs in SymbolTable"	3 timesRepeat: [		Smalltalk garbageCollect.		Symbol compactSymbolTable.	].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'sd 5/23/2003 14:45'!removeNormalCruft 	"Remove various graphics, uniclasses, references.   Caution: see comment at bottom of method"	"Smalltalk removeNormalCruft"		ScriptingSystem stripGraphicsForExternalRelease.	ScriptingSystem spaceReclaimed.	References keys do: [:k | References removeKey: k].	Smalltalk classNames do:		[:cName | #( 'Player' 'CardPlayer' 'Component' 'WonderlandActor' 'MorphicModel' 'PlayWithMe') do:			[:superName | ((cName ~= superName and: [cName beginsWith: superName])				and: [(cName allButFirst: superName size) allSatisfy: [:ch | ch isDigit]])				ifTrue: [Smalltalk removeClassNamed: cName]]].	Smalltalk at: #Wonderland ifPresent:[:cls | cls removeActorPrototypesFromSystem].	ChangeSet current clear"Caution: if any worlds in the image happen to have uniclass players associated with them, running this method would likely compromise their functioning and could cause errors, especially if the uniclass player of the current world had any scripts set to ticking.  If that happens to you somehow, you will probably want to find a way to reset the offending world's player to be an UnscriptedCardPlayer, or perhaps nil"! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sd 5/23/2003 14:42'!currentChangeSetString	"Smalltalk currentChangeSetString"	^ 'Current Change Set: ', ChangeSet current name! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'nk 7/2/2003 08:48'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	ChangeSet newChanges: aChangeSet.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'nk 7/2/2003 08:48'!noChanges 	"Initialize the system ChangeSet."	ChangeSet noChanges.! !!SystemDictionary methodsFor: 'to be deprecated in the next changeset' stamp: 'sd 5/22/2003 22:45'!changes	"Answer the current system ChangeSet."	^ChangeSet current! !!Environment class methodsFor: 'system conversion' stamp: 'sd 5/23/2003 15:15'!reorganizeEverything	"Undertake a grand reorganization.	Environment reorganizeEverything.	"	| bigCat envt pool s |	"First check for clashes between environment names and existing globals..."	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			[(Smalltalk includesKey: bigCat) ifTrue:				[^ self error: bigCat , ' cannot be used to nameboth a package and a class or other global variable.No reorganization will be attempted.']]].	(self confirm:'Your image is about to be partitioned into environments.Many things may not work after this, so you should beworking in a throw-away copy of your working image.Are you really ready to procede?(choose ''no'' to stop here safely)')		ifFalse: [^ self inform: 'No changes were made'].	ChangeSet  newChanges: (ChangeSet basicNewNamed: 'Reorganization').	"Recreate the Smalltalk dictionary as the top-level Environment."	Smalltalk _ SmalltalkEnvironment newFrom: Smalltalk.	Smalltalk setName: #Smalltalk inOuterEnvt: nil.	"Don't hang onto old copy of Smalltalk ."	Smalltalk recreateSpecialObjectsArray.	Smalltalk allClassesDo:		[:c | c environment: nil. "Flush any old values"].	"Run through all categories making up new sub-environments"	SystemOrganization categories do:		[:cat | bigCat _ (cat asString copyUpTo: '-' first) asSymbol.		(Smalltalk kernelCategories includes: bigCat) ifFalse:			["Not a kernel category ..."			envt _ Smalltalk at: bigCat						ifAbsent: ["... make up a new environment if necessary ..."									Smalltalk makeSubEnvironmentNamed: bigCat].			"... and install the member classes in that category"			envt transferBindingsNamedIn: (SystemOrganization listAtCategoryNamed: cat)									from: Smalltalk].		].	"Move all shared pools that are only referred to in sub environments"	Smalltalk associationsDo:		[:assn | ((pool _ assn value) isMemberOf: Dictionary) ifTrue:			[s _ IdentitySet new.			Smalltalk allClassesAnywhereDo:				[:c | c sharedPools do:					[:p | p == pool ifTrue:						[s add: c environment]]].			(s size = 1 and: [(envt _ s someElement) ~~ Smalltalk]) ifTrue:				[envt declare: assn key from: Smalltalk]]].	Smalltalk rewriteIndirectRefs.	Smalltalk newChanges: (ChangeSet basicNewNamed: 'PostReorganization').	ChangeSorter initialize.	Preferences enable: #browserShowsPackagePane.! !!TheWorldMenu methodsFor: 'commands' stamp: 'sd 5/23/2003 14:49'!lookForSlips	ChangeSet current lookForSlips! !!TheWorldMenu methodsFor: 'construction' stamp: 'sd 5/23/2003 15:17'!changesMenu        "Build the changes menu for the world."        | menu |        menu _ self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { Utilities . #fileOutChanges}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSorter . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { ChangeSet  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.                { 'find recent submissions (R)' . { #myWorld . #openRecentSubmissionsBrowser:}.                                'Make an open recent-submissions browser be the front-window, expanding a collapsed one or creating a new one if necessary.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted, latest first.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions at the top of the browser.'}.			nil.                { 'recently logged changes...' . { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        self projectForMyWorld isIsolated ifTrue: [                self fillIn: menu from: {                         { 'propagate changes upward' . {self. #propagateChanges}.                                'The changes made in this isolated project will propagate to projects up to the next isolation layer.'}.                }.        ] ifFalse: [                self fillIn: menu from: {                         { 'isolate changes of this project' . {self. #beIsolated}.                                'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'}.                }.        ].        ^ menu! !!Utilities class methodsFor: 'fileout' stamp: 'sd 5/23/2003 14:49'!fileOutChanges	"File out the current change set to a file whose name is a function of the current date and time."	ChangeSet current fileOut.	Transcript cr; show: 'Changes filed out ', Date dateAndTimeNow printString! !!VersionsBrowser methodsFor: 'menu' stamp: 'sd 5/23/2003 14:50'!removeMethodFromChanges	"Remove my method from the current change set"	ChangeSet current removeSelectorChanges: selectorOfMethod class: classOfMethod.	self changed: #annotation! !