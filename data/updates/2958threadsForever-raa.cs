'From Squeak2.9alpha of 17 July 2000 [latest update: #3003] on 13 November 2000 at 8:47:13 am'!"Change Set:		threadsForeverDate:			12 November 2000Author:			Bob Arning- restore use of #restoreSuspendedEventHandler when grabbing from parts bin- changed menus in thread nav a bit, also they appear on mouseDown rather than mouse up- added rollovers to prev & next images- changed resizing of EToyHistoryMorph- stack new navigators up the right side of the screen"!!Morph methodsFor: 'debug and other' stamp: 'RAA 11/12/2000 13:44'!addMouseUpActionWith: codeToRun	((codeToRun isKindOf: MessageSend) not and: [codeToRun isEmptyOrNil]) ifTrue: [^self].	self setProperty: #mouseUpCodeToRun toValue: codeToRun.	self		on: #mouseUp 		send: #programmedMouseUp:for:		to: self.	self		on: #mouseDown		send: #programmedMouseDown:for:		to: self.	self		on: #mouseEnter		send: #programmedMouseEnter:for:		to: self.	self		on: #mouseLeave		send: #programmedMouseLeave:for:		to: self.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 11/12/2000 13:42'!programmedMouseUp: anEvent for: aMorph	| aCodeString |	self deleteAnyMouseActionIndicators.	aCodeString _ self valueOfProperty: #mouseUpCodeToRun ifAbsent: [^self].	(self fullBounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	[		(aCodeString isKindOf: MessageSend) ifTrue: [			aCodeString value		] ifFalse: [			Compiler				evaluate: aCodeString				for: self				notifying: nil				logged: false		].	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: self].		"in case a save/load progress display needs a home"! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 13:24'!initialize	super initialize.	self listDirection: #topToBottom.	color _ Color lightBrown.	self layoutInset: 4.	borderColor _ #raised "Color brown".	borderWidth _ 4.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self useRoundedCorners.	self rebuild.	! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/13/2000 07:46'!rebuild	| history r1 |	changeCounter _ ProjectHistory changeCounter.	history _ ProjectHistory currentHistory mostRecentCopy.	self removeAllMorphs.	self rubberBandCells: false. "enable growing"	r1 _ self addARow: {		self inAColumn: {			StringMorph new contents: 'Jump...'; lock.		}.	}.	r1 on: #mouseUp send: #jumpToProject to: self.	history do: [ :each |		(			self addARow: {				(self inAColumn: {					StretchyImageMorph new form: each second; minWidth: 35; minHeight: 35; lock				}) vResizing: #spaceFill.				self inAColumn: {					StringMorph new contents: each first; lock.					"StringMorph new contents: each third; lock."				}.			}		)			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			on: #mouseUp send: #mouseUp:in: to: self;			on: #mouseDown send: #mouseDown:in: to: self;			on: #mouseMove send: #mouseMove:in: to: self;			on: #mouseLeave send: #mouseLeave:in: to: self;			setProperty: #projectParametersTuple toValue: each;			setBalloonText: (each third isEmptyOrNil ifTrue: ['not saved'] ifFalse: [each third])	]."---	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/13/2000 08:44'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| nameOfThisProject |	threadName isEmpty ifTrue: [threadName _ 'I need a name'].	threadName _ FillInTheBlank 		request: 'Name this thread.' 		initialAnswer: threadName.	threadName isEmptyOrNil ifTrue: [^self].	listOfPages _ OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		(nameOfThisProject _ m valueOfProperty: #nameOfThisProject) ifNotNil: [			listOfPages add: {nameOfThisProject}.		].	].	self class know: listOfPages as: threadName.	self removeAllMorphs; addButtons.	self world ifNil: [		self openInWorld; positionAppropriately.	].! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 13:41'!addButtonsAlan	| marginPt i sz data images pageNumber proj f m b1 b2 dot arrowWidth arrowCenter vertices arrowHeight allProjects nameMorph |	allProjects _ Project allProjects.	self changeNoLayout.	self hResizing: #rigid. "... this is very unlikely..."	self vResizing: #rigid.	marginPt _ 4@4.	i _ self currentIndex.	sz _ 50@40.	arrowWidth _ 14.	arrowHeight _ 17.	data _ {		{i - 1. 'Previous:'. #previousPage. #rightCenter. arrowWidth negated}.		{i + 1. 'Next:'. #nextPage. #leftCenter. arrowWidth}	}.	images _ data collect: [ :tuple |		pageNumber _ tuple first.		((pageNumber between: 1 and: listOfPages size) and: 				[(proj _ Project named: (listOfPages at: pageNumber) first in: allProjects) notNil]) ifTrue: [			f _ proj thumbnail scaledToSize: sz.			arrowCenter _ f boundingBox perform: tuple fourth.			vertices _ {				arrowCenter - (0@arrowHeight).				arrowCenter + (0@arrowHeight).				arrowCenter + (tuple fifth @ 0).			}.			f getCanvas				drawPolygon: vertices 				color: Color orange 				borderWidth: 0 				borderColor: Color transparent.			m _ ImageMorph new image: f.			m setBalloonText: tuple second,' ',(listOfPages at: pageNumber) first.			m addMouseUpActionWith: (				MessageSend receiver: self selector: tuple third			).		] ifFalse: [			f _ (Form extent: sz depth: 16) fillColor: Color lightGray.			m _ ImageMorph new image: f.		].		m	].	b1 _ images first.	b2 _ images second.	dot _ EllipseMorph new extent: 16@16; color: Color orange lighter; borderWidth: 0.	self addMorph: (b1 position: self position + marginPt).	self addMorph: (b2 position: b1 topRight + (marginPt x @ 0)).	self extent: b2 bottomRight - self position + marginPt.	self addMorph: dot.	dot align: dot center with: b1 bounds rightCenter + ((marginPt x @ 0) // 2).	dot setBalloonText: threadName,'more commands'.	dot on: #mouseDown send: #moreCommands to: self.	self fullBounds.	self addMorph: (nameMorph _ SquishedNameMorph new).	nameMorph		target: self getSelector: #threadName setSelector: nil;		color: Color transparent;		width: self width;		height: 15;		align: nameMorph bottomLeft with: self bottomLeft.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/13/2000 08:04'!editThisThread	| sz morphsForPageSorter pvm sorter allProjects proj |	sz _ (100@80 / (listOfPages size / 35 max: 1)) rounded.	allProjects _ Project allProjects.	'Assembling thumbnail images...'		displayProgressAt: self cursorPoint		from: 0 to: listOfPages size		during: [:bar |			morphsForPageSorter _ listOfPages withIndexCollect: [ :each :index | 				bar value: index.				(proj _ Project named: each first in: allProjects) ifNil: [					nil				] ifNotNil: [					pvm _ ProjectViewMorph on: proj.					pvm _ pvm imageForm scaledToSize: sz.					pvm _ pvm asMorph.					pvm setProperty: #nameOfThisProject toValue: each first.					pvm setBalloonText: each first.					pvm				]			].		].	morphsForPageSorter _ morphsForPageSorter reject: [ :each | each isNil].	sorter _ BookPageSorterMorph new		book: self 		morphsToSort: morphsForPageSorter.	sorter pageHolder cursor: self currentIndex.	self currentWorld addMorphFront: sorter.	sorter align: sorter center with: self currentWorld center.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 13:17'!moreCommands	| allThreads aMenu others |	allThreads _ self class knownThreads.	aMenu _ MenuMorph new defaultTarget: self.	others _ (allThreads keys reject: [ :each | each = threadName]) asSortedCollection.	others do: [ :each |		aMenu add: 'switch to <',each,'>' selector: #switchToThread: argument: each.	].	aMenu add: 'switch to recent projects' action: #getRecentThread.	aMenu addLine.	aMenu add: 'thread of all projects' action: #threadOfAllProjects.	aMenu add: 'thread of no projects' action: #threadOfNoProjects.	aMenu add: 'edit this thread' action: #editThisThread.	aMenu addLine.	aMenu add: 'First project in thread' action: #firstPage.	aMenu add: 'Last project in thread' action: #lastPage.	aMenu add: 'jump within this thread' action: #jumpWithinThread.	aMenu addLine.	aMenu add: 'simply close this navigator' action: #delete.	aMenu popUpEvent: self world primaryHand lastEvent in: self world! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 16:07'!positionAppropriately	| others otherRects overlaps |	others _ self world submorphs select: [ :each | each ~~ self and: [each isKindOf: self class]].	otherRects _ others collect: [ :each | each bounds].	self align: self fullBounds bottomRight with: self world bottomRight.	[		overlaps _ false.		otherRects do: [ :r |			(r intersects: bounds) ifTrue: [overlaps _ true. self bottom: r top].		].		self top < self world top ifTrue: [			self bottom: self world bottom.			self right: self left - 1.		].		overlaps	] whileTrue.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 13:05'!threadOfAllProjects	| projects nameList nav |	projects _ Project allProjects select: [ :each | each world isMorph].	nameList _ projects collect: [ :each | {each name}].	nav _ self class basicNew.	nav		listOfPages: nameList;		threadName: '';		initialize.	nav editThisThread.! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 13:21'!threadOfNoProjects	| nameList nav |	nameList _ { {CurrentProjectRefactoring currentProjectName} }.	nav _ self class basicNew.	nav		listOfPages: nameList;		threadName: '';		initialize.	nav editThisThread.! !!InternalThreadNavigationMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/12/2000 15:56'!openThreadNamed: nameOfThread	| coll nav |	coll _ self knownThreads at: nameOfThread ifAbsent: [^self].	nav _ World 		submorphThat: [ :each | (each isKindOf: self) and: [each threadName = nameOfThread]]		ifNone: [			nav _ self basicNew.			nav				listOfPages: coll;				threadName: nameOfThread;				initialize;				openInWorld;				positionAppropriately.			^self		].	nav		listOfPages: coll;		threadName: nameOfThread;		removeAllMorphs;		addButtons.! !!PasteUpMorph methodsFor: 'event handling' stamp: 'RAA 11/12/2000 15:43'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: evt.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		self isPartsBin ifFalse:[^evt hand grabMorph: grabbedMorph].		grabbedMorph _ grabbedMorph partRepresented duplicate.		grabbedMorph restoreSuspendedEventHandler.		(grabbedMorph fullBounds containsPoint: evt position) 			ifFalse:[grabbedMorph position: evt position].		"Note: grabbedMorph is ownerless after duplicate so use #grabMorph:from: instead"		^evt hand grabMorph: grabbedMorph from: self].	(super handlesMouseDown: evt)		ifTrue:[^super mouseDown: evt].	evt hand halo: nil. "shake off halos"	evt hand releaseKeyboardFocus. "shake of keyboard foci"	evt shiftPressed ifTrue:[		^evt hand 			waitForClicksOrDrag: self 			event: evt 			selectors: { #findWindow:. nil. #dragThroughOnDesktop:}			threshold: 5].	self isWorldMorph ifTrue:[^self addAlarm: #invokeWorldMenu: with: evt after: 200].	"otherwise, explicitly ignore the event if we're not the world,	so that we could be picked up if need be"	self isWorldMorph ifFalse:[evt wasHandled: false].! !