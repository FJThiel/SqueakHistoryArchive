'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5657] on 20 February 2004 at 1:54:10 pm'!"Change Set:		ANSICompatibility-AFiDate:			24 November 2002Author:			Alain FischerI modified this changeset by removing the DateAndTime and Duration changes.  I also removed the changes to TestRunner as I don't think they belong here.Note that the description below will be incorrect in reference to these classes.  - Ken Causeyoriginal comment continues:This change set add ANSI compatibility to Squeak 3.2.Now TestRunner with ANSI tests loaded show (2777 run, 2753 passed, 24 failed, 0 errors).17 classes (8 new / 9 modified)New classes:ArithmeticError, DateAndTime, Duration, FloatingPointException, RuleDate, RuleIndexDate, RuleSelectionCodeDate, ScaledDecimalModified Classes:BlockContext (added method #argumentCount)Character (added method #codePoint)Character class (added method #codePoint:)Float (2 methods added, 3 methods #modified)Float class (added method #one)Fraction (1 method added, 1 method modified)Fraction class (added method #one)Integer (6 methods added, 1 method modified)Integer class (added method #one)Number (7 methods added, 2 methods modified)Number class (modified method #readRemainderOf:from:base:withSign:)PositionableStream (modified method #skip:)String (3 methods added)TestRunner (2 methods modified)ZeroDivide is now subclass of ArithmeticError"!Error subclass: #ArithmeticError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!ArithmeticError subclass: #FloatingPointException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!Date subclass: #RuleDate	instanceVariableNames: 'dayOfWeek selectionRule'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Magnitudes'!!RuleDate commentStamp: '<historical>' prior: 0!RuleDate instances represent dates determined by some rule (first Tuesday in March, etc.) but the exact day of the month varies from year to year.  Once created they must be updated for a selected year to represent the exact day of that year.Typical Use:	RuleDate instances are suitable for representing dates such as election day, or the start of daylight saving time in the USA.Implementation:Instance variables:	dayOfWeek		- a <Symbol> representing the day name of the					week (Sunday, etc) of the desired day.	selectionRule	- a <Symbol> representing the position (first, last)					of the desired day in the list of days occurring					on that day of the week in the desired month.!RuleDate subclass: #RuleIndexDate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Magnitudes'!!RuleIndexDate commentStamp: '<historical>' prior: 0!RuleIndexDate instances represent dates determined by some rule but the exact day of the month varies from year to year.  Once created they must be updated for a selected year to represent the exact day of that year.	It has a rule that selects exact day of the month based on the ordinal position (1, 2, etc.) of the desired day in the list of days occurring on that day of the week in the desired month.Typical Use:	RuleIndexDate instances are suitable for representing dates such as Thanksgiving Day (fourth Tuesday in November) in the USA.Implementation:Instance variables:	(selectionRule in super class)	- an <Integer> representing the			ordinal position (1, 2, etc.) of the desired day in the list			of days occurring on that day of the week in the desired			month.!RuleDate subclass: #RuleSelectionCodeDate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Magnitudes'!!RuleSelectionCodeDate commentStamp: '<historical>' prior: 0!RuleSelectionCodeDate instances represent dates determined by some rule but the exact day of the month varies from year to year.  Once created they must be updated for a selected year to represent the exact day of that year.	It has a rule that selects exact day of the month by evaluating the selection block with the list of days occurring on that day of the week in the desired month as an argument.Typical Use:	RuleSelectionCodeDate instances are suitable for representing dates such as the last day of daylight saving time (the Saturday before the last Sunday in October) in the USA.Implementation:Instance variables:	(selectionRule in super class)	- a <monadicValuable> containing			the selection block to be evaluated.  The argument is the list			of days occurring on that day of the week in the desired			month.  It must return the desired day of the month 			which may be any <Integer>.!Number subclass: #ScaledDecimal	instanceVariableNames: 'fraction scale'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!ScaledDecimal commentStamp: '<historical>' prior: 0!ScaledDecimal provides a numeric representation of fixed point decimal numbers able to accurately represent decimal fractions.  It supports unbounded precision, with no limit to the number of digits before and after the decimal point.	ScaledDecimal complies with the ANSI protocols:	Object	number	ScaledDecimal	????#todo. "finish protocol list."Implementation Notes:	I implemented ScaledDecimal with the decimal fraction stored in instance variables numerator and denominator, and the number of digits after the decimal point in fractionalDigit as a positive Integer.  I implemented operations by first coercing the aurguments to fractions, doing the operations, then coercing the result to the proper numeric representation when necessary and scale.  This is because I assume the Fraction class is more likely to implement them correctly.  Richard A. Harmon!ArithmeticError subclass: #ZeroDivide	instanceVariableNames: 'dividend '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!BlockContext methodsFor: 'accessing' stamp: 'RAH 4/25/2000 19:49'!argumentCount	"Answers the number of arguments needed to evaluate the receiver."	#Valuable.	^ self numArgs! !!Character methodsFor: 'accessing' stamp: 'RAH 4/25/2000 19:49'!codePoint	"Return the encoding value of the receiver."	#Fundmntl.	^ self asciiValue! !!Character class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!codePoint: integer 	"Return a character whose encoding value is integer."	#Fundmntl.	(0 > integer or: [255 < integer])		ifTrue: [self error: 'parameter out of range 0..255'].	^ CharacterTable at: integer + 1! !!Number methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	"Answer 1 divided by the receiver. Create an error notification if the 	receiver is 0."	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	self = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	^ 1 / self! !!Number methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49'!raisedToInteger: operand 	"Answer the receiver raised to the power operand, an Integer."	| count result |	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	operand isInteger ifFalse: [^ ArithmeticError signal: 'parameter is not an Integer'"<- Chg"].	operand = 0 ifTrue: [^ self class one].	operand = 1 ifTrue: [^ self].	operand < 0 ifTrue: [^ (self raisedToInteger: operand negated) reciprocal].	count := 1.	[(count := count + count) < operand] whileTrue.	result := self class one.	[count > 0]		whileTrue: 			[result := result * result.			(operand bitAnd: count)				= 0 ifFalse: [result := result * self].			count := count bitShift: -1].	^ result! !!Number methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!fractionPart	"Answer the fractional part of the receiver."	#Numeric.	"2000/03/04  Harmon R. Added ANSI <number> protocol"	^ self - self truncated! !!Number methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!integerPart	"Answer the integer part of the receiver."	#Numeric.	"2000/03/04  Harmon R. Added ANSI <number> protocol"	^ self truncated! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Do any required conversion and then the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFloatD	"Answer a d precision floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFloatE	"Answer a floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFloatQ	"Answer a floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scale 	"Answer a scaled decimal number, with a fractional precision of scale, 	approximating the receiver."	#Numeric.	"add 200/01/19 For number protocol."	^ ScaledDecimal newFromNumber: self scale: scale! !!Float methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	self = 0 ifTrue: ["<- Chg"		^ (ZeroDivide dividend: self) signal"<- Chg"].	"<- Chg"	^ 1.0 / self! !!Float methodsFor: 'mathematical functions' stamp: 'AFi 11/23/2002 21:06'!raisedTo: aNumber	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].	self < 0.0 ifTrue:		[ ArithmeticError signal: ' raised to a non-integer power' ].	0.0 = aNumber ifTrue: [^ 1.0].				"special case for exponent = 0.0"	(self= 0.0) | (aNumber = 1.0) ifTrue: [^ self].	"special case for self = 1.0"	^ (self ln * aNumber asFloat) exp			"otherwise use logarithms"! !!Float methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49'!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: ["v Chg"					^ FloatingPointException signal: 'undefined if less than zero.']].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert receiverScaledDecimal to a Float and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal asFloat perform: arithmeticOpSelector with: self! !!Float methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printPaddedWith: aCharacter to: aNumber 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least on aNumber 	integerPart characters and padded the right with aCharacter to be at 	least anInteger fractionPart characters."	| aStream digits fPadding fLen iPadding iLen curLen periodIndex |	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	aStream := WriteStream on: (String new: 10).	self printOn: aStream.	digits := aStream contents.	periodIndex := digits indexOf: $..	curLen := periodIndex - 1.	iLen := aNumber integerPart.	curLen < iLen		ifTrue: [iPadding := (String new: (iLen - curLen) asInteger) atAllPut: aCharacter;					 yourself]		ifFalse: [iPadding := ''].	curLen := digits size - periodIndex.	fLen := (aNumber fractionPart * (aNumber asFloat exponent * 10)) asInteger.	curLen < fLen		ifTrue: [fPadding := (String new: fLen - curLen) atAllPut: aCharacter;					 yourself]		ifFalse: [fPadding := ''].	^ iPadding , digits , fPadding! !!Fraction methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	"Refer to the comment in Number|reciprocal."	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	numerator = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	numerator = 1 ifTrue: [^ denominator].	numerator = -1 ifTrue: [^ denominator negated].	^ Fraction numerator: denominator denominator: numerator! !!Fraction methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert receiverScaledDecimal to a Fraction and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal asFraction perform: arithmeticOpSelector with: self! !!Integer methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!// aNumber 	| q |	#Numeric.	"Changed 200/01/19 For ANSI support."	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	self = 0 ifTrue: [^ 0].	q := self quo: aNumber.	"Refer to the comment in Number|//."	(q negative		ifTrue: [q * aNumber ~= self]		ifFalse: [q = 0 and: [self negative ~= aNumber negative]])		ifTrue: [^ q - 1"Truncate towards minus infinity."]		ifFalse: [^ q]! !!Integer methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert me to a ScaledDecimal and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal perform: arithmeticOpSelector with: (self asScaledDecimal: 0)! !!Integer methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scaleNotUsed 	"The number of significant digits of the answer is the same as the 	number of decimal digits in the receiver.  The scale of the answer is 0."	#Numeric.	"add 200/01/19 For <integer> protocol."	^ ScaledDecimal newFromNumber: self scale: 0! !!Integer methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printOn: outputStream base: baseInteger showRadix: flagBoolean 	"Write a sequence of characters that describes the receiver in radix 	baseInteger with optional radix specifier. 	The result is undefined if baseInteger less than 2 or greater than 36."	| tempString startPos |	#Numeric.	"2000/03/04  Harmon R. Added ANSI <integer> protocol"	tempString := self printStringRadix: baseInteger.	flagBoolean ifTrue: [^ outputStream nextPutAll: tempString].	startPos := (tempString indexOf: $r ifAbsent: [self error: 'radix indicator not found.'])				+ 1.	self negative ifTrue: [outputStream nextPut: $-].	outputStream nextPutAll: (tempString copyFrom: startPos to: tempString size)! !!Integer methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printPaddedWith: aCharacter to: anInteger 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least anInteger characters."	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	^ self		printPaddedWith: aCharacter		to: anInteger		base: 10! !!Integer methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printPaddedWith: aCharacter to: anInteger base: aRadix 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least anInteger characters."	| aStream padding digits |	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	aStream := WriteStream on: (String new: 10).	self		printOn: aStream		base: aRadix		showRadix: false.	digits := aStream contents.	padding := anInteger - digits size.	padding > 0 ifFalse: [^ digits].	^ ((String new: padding) atAllPut: aCharacter;	 yourself) , digits! !!Integer methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printStringRadix: baseInteger 	"Return a string containing a sequence of characters that represents the 	numeric value of the receiver in the radix specified by the argument.  	If the receiver is negative, a minus sign ('-') is prepended to the 	sequence of characters. 	The result is undefined if baseInteger less than 2 or greater than 36."	| tempString |	#Numeric.	"2000/03/04  Harmon R. Added ANSI <integer> protocol"	baseInteger = 10		ifTrue: 			[tempString := self printStringBase: baseInteger.			self negative				ifTrue: [^ '-10r' , (tempString copyFrom: 2 to: tempString size)]				ifFalse: [^ '10r' , tempString]].	^ self printStringBase: baseInteger! !!Number class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!readRemainderOf: integerPart from: aStream base: base withSign: sign 	"Read optional fractional part and exponent, and return the final result"	| value fraction fractionDigits fracpos peekChar scale |	#Numeric.	"Changed 200/01/19 For ANSI Numeric Literals support."	value := integerPart.	fractionDigits := 0.	(aStream peekFor: $.)		ifTrue: ["<integer>.<fraction>"			(aStream atEnd not and: [aStream peek digitValue between: 0 and: base - 1])				ifTrue: 					[fracpos := aStream position.					fraction := Integer readFrom: aStream base: base.					fraction := fraction asFloat / (base raisedTo: aStream position - fracpos).					fractionDigits := aStream position - fracpos.					value := value asFloat + fraction]				ifFalse: 					["oops - just <integer>."					aStream skip: -1.					"un-gobble the period"					^ value * sign"Number readFrom: '3r-22.2'"]].	peekChar := aStream peek.	"<number>(e|d|q)<exponent>>"	peekChar = $e | (peekChar = $d) | (peekChar = $q)		ifTrue: 			[aStream next.			value := value * (base raisedTo: (Integer readFrom: aStream))]		ifFalse: [peekChar = $s				ifTrue: 					["<number>s[<scale>]"					aStream next.					(aStream atEnd not and: ["<number>s<scale>"						aStream peek digitValue between: 0 and: 10])						ifTrue: [scale := Integer readFrom: aStream].					scale isNil						ifTrue: ["<number>s"							fractionDigits = 0								ifTrue: ["<integer>s"									scale := 0]								ifFalse: ["<integer>.<fraction>s"									scale := fractionDigits]].					value := ScaledDecimal newFromNumber: value scale: scale]].	(value isFloat		and: [value = 0.0 and: [sign = -1]])		ifTrue: [^ Float negativeZero]		ifFalse: [^ value * sign]! !!Float class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	#Numeric.	"add 200/01/19 For <number> protocol support."	^ 1.0! !!Fraction class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	#Numeric.	"add 200/01/19 For <number> protocol support."	^ self numerator: 1 denominator: 1! !!Integer class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	#Numeric.	"add 200/01/19 For <number> protocol support."	^ 1! !!PositionableStream methodsFor: 'positioning' stamp: 'RAH 6/29/2000 05:44'!skip: anInteger 	"Skips the next amount objects in the receiver's future sequence values."	"2000/06/23 Harmon, R. Changed for ANSI <gettableStream> protocol."	#Stream.	self position: (self position + (anInteger min: (self contents size - self position)))! !!RuleDate methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!applyRuleTo: daysNamedInMonthList 	"Private - Answer the day of the month selected from dayOfMonth list 	by applying the receiver's rule."	^ daysNamedInMonthList perform: selectionRule! !!RuleDate methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!basicUpdateForMonth: mm year: yyyy 	"Private - Answer the receiver after updating by applying the rule for 	the month, mm, of year, yyyy."	| dayByRule daysNamedInMonth firstDayNamed aDay aYear |	firstDayNamed := self				dayInMonth: mm				year: yyyy				ofFirstDayNamed: dayOfWeek.	aDay := (Date				newDay: firstDayNamed				month: mm				year: yyyy) day.	aYear := yyyy.	julianDayNumber := (Date newDay: aDay year: aYear) julianDayNumber.	daysNamedInMonth := (firstDayNamed to: self daysInMonth by: 7) asArray.	dayByRule := self applyRuleTo: daysNamedInMonth.	aDay := (Date				newDay: dayByRule				month: mm				year: yyyy) day.		julianDayNumber := (Date newDay: aDay year: aYear) julianDayNumber! !!RuleDate methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!dayInMonth: monthIn year: yearIn ofFirstDayNamed: dayNameIn 	"Private - Answer, the day in the month, monthIn, of year, yearIn, of 	the first day named, dayNameIn."	| frstDayNdx dayName firstDay |	dayName := dayNameIn asSymbol.	frstDayNdx := (Date firstWeekdayOfMonth: monthIn year: yearIn)				- 1.	frstDayNdx = 0 ifTrue: [frstDayNdx := frstDayNdx + 7].	firstDay := 1.	(Date nameOfDay: frstDayNdx)		= dayName		ifFalse: 			[firstDay := 1 + (Date dayOfWeek: dayName) - frstDayNdx.			firstDay < 1 ifTrue: [firstDay := firstDay + 7]].	^ firstDay! !!RuleDate methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!setDayOfWeek: dayName selectionRule: positionName 	"Private - Set dayOfWeek to dayName, and selectionRule to positionName. 	 	Parameters 	dayName		<Symbol>		captured 	positionName	<Symbol>		captured	"	dayOfWeek := dayName.	selectionRule := positionName! !!RuleDate methodsFor: 'updating' stamp: 'RAH 4/25/2000 19:49'!updateForYear: yyyy 	"Update the receiver by applying the rule for its month number of 	year, yyyy. 	 	Definition: <RuleDate> 	Parameters 	yyyy	<Integer>	captured	"	self basicUpdateForMonth: self monthIndex year: yyyy! !!RuleDate methodsFor: 'testing' stamp: 'RAH 4/25/2000 19:49'!isRuleDate	#DtAndTm.	"Added 2000/04/08 To use DNU mod."	^ true! !!RuleDate class methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!getValidMonthNumber: monthIn 	"Private - Answer the month number of monthIn if it is a month name 	String, else monthIn as the month number  if it is an Integer, else 	signal an error. 	 	Definition: <RuleDate factory> 	Parameters 	monthIn	<readableString> | <Integer>	captured 	Return Values 	<RuleDate>		new 	Errors 	Month is not an Integer 1 - 12. or a valid month name String	"	monthIn isInteger		ifTrue: 			[(monthIn between: 1 and: 12)				ifTrue: [^ monthIn].			^ Error signal: 'Month must be 1 - 12.'].	(monthIn isMemberOf: String)		ifTrue: [^ self indexOfMonth: monthIn].	^ Error signal: 'Month must be an Integer 1 - 12 or a month name String.'! !!RuleDate class methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!getValidSelectionRule: positionName 	"Private - Answer the selection position (first, last) in the list of day of 	the week,  Report an error if positionName is not one of (first, last)."	| positionSymbol |	(positionName isMemberOf: String)		ifFalse: [^ Error signal: 'Position name: "' , positionName , '" is not a String.'].	positionSymbol := positionName asLowercase asSymbol.	(#(first last ) includes: positionSymbol)		ifFalse: [^ Error signal: 'Position name: "' , positionName , '" is not valid.'].	^ positionSymbol! !!RuleDate class methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!newDayOfWeek: dayName selectionRule: positionName 	"Private - Answer an uncreated rule date with the dayOfWeek (Sunday, 	etc) set to dayName, and selectionRule (first, last) set to positionName. 	Note: Must be updated to create the date. 	 	Parameters 	dayName		<readableString>		captured 	positionName	<readableString>		captured 	Return Values 	<RuleDate>		new	"	| daySymbol newRuleDate positionSymbol |	(dayName isMemberOf: String)		ifFalse: [^ Error signal: 'Day name: "' , dayName , '" is not a String.'].	daySymbol := dayName asLowercase.	daySymbol at: 1 put: (daySymbol at: 1) asUppercase.	daySymbol := daySymbol asSymbol.	(WeekDayNames includes: daySymbol)		ifFalse: [^ Error signal: 'Day name: "' , dayName , '" is not valid.'].	positionSymbol := self getValidSelectionRule: positionName.	newRuleDate := super new.	newRuleDate setDayOfWeek: daySymbol selectionRule: positionSymbol.	^ newRuleDate! !!RuleDate class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!first: dayName inMonth: monthIn year: yearIn 	"Answer a date that is the first day of the week (Sunday, etc), dayName, 	in month, monthIn, of year, yearIn.  Example: 	 	RuleDate first: 'Monday' inMonth: 'April' year: 2000 	 	Note: The month may be an index or a month name. 	The year may be specified as the actual number of years since the 	beginning of the Roman calendar or the  number of years since 1900, 	or a two digit date from 1900.  1/1/01 will NOT mean 2001. 	Definition: <RuleDate factory> 	Parameters 	dayName	<readableString>				captured 	monthIn	<readableString> | <Integer>	captured 	yearIn		<Integer>					captured 	Return Values 	<RuleDate>		new 	Errors 	Day name is not a String and a valid day of the week 	Month is not an Integer 1 - 12. or a valid month name String	"	| mmInt newRuleDate |	mmInt := self getValidMonthNumber: monthIn.	newRuleDate := self newDayOfWeek: dayName selectionRule: 'first'.	newRuleDate basicUpdateForMonth: mmInt year: yearIn.	^ newRuleDate! !!RuleDate class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!last: dayName inMonth: monthIn year: yearIn 	"Answer a date that is the last day of the week (Sunday, etc), dayName, 	in month, monthIn, of year, yearIn.  Example: 	 	RuleDate last: 'Monday' inMonth: 'April' year: 2000 	 	Note: The month may be an index or a month name. 	The year may be specified as the actual number of years since the 	beginning of the Roman calendar or the  number of years since 1900, 	or a two digit date from 1900.  1/1/01 will NOT mean 2001. 	Definition: <RuleDate factory> 	Parameters 	dayName	<readableString>				captured 	monthIn	<readableString> | <Integer>	captured 	yearIn		<Integer>					captured 	Return Values 	<RuleDate>		new 	Errors 	Day name is not a String and a valid day of the week 	Month is not an Integer 1 - 12. or a valid month name String	"	| mmInt newRuleDate |	mmInt := self getValidMonthNumber: monthIn.	newRuleDate := self newDayOfWeek: dayName selectionRule: 'last'.	newRuleDate basicUpdateForMonth: mmInt year: yearIn.	^ newRuleDate! !!RuleIndexDate methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!applyRuleTo: daysNamedInMonthList 	"Private - Answer the day of the month selected from dayOfMonth list 	by applying the receiver's rule."	^ daysNamedInMonthList at: selectionRule! !!RuleIndexDate class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!indexed: dayName inMonth: monthIn year: yearIn at: dayListIndex 	"Answer a date that is at the dayListIndex position of the list of day of 	the week (Sunday, etc), dayName, in month, monthIn, of year, yearIn.  	Example:  	RuleIndexDate indexed: 'Sunday' inMonth: 'April' year: 2000 at: 2. 	 	Note: The month may be an index or a month name. 	The year may be specified as the actual number of years since the 	beginning of the Roman calendar or the  number of years since 1900, 	or a two digit date from 1900.  1/1/01 will NOT mean 2001. 	 	Definition: <RuleDate factory> 	Parameters 	dayName		<readableString>				captured 	monthIn		<readableString> | <Integer>	captured 	yearIn			<Integer>					captured 	dayListIndex		<Integer>					captured 	Return Values 	<RuleDate>		new 	Errors 	Day name is not a String and a valid day of the week 	Month is not an Integer 1 - 12. or a valid month name String	"	| mmInt newRuleDate |	mmInt := self getValidMonthNumber: monthIn.	newRuleDate := self newDayOfWeek: dayName selectionRule: dayListIndex.	newRuleDate basicUpdateForMonth: mmInt year: yearIn.	^ newRuleDate! !!RuleIndexDate class methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!getValidSelectionRule: dayListIndex 	"Private - Answer the dayListIndex position in the list of all days named 	(Sunday, etc) in a month,  Report an error if dayListIndex does not 	represent an <Integer>."	dayListIndex isInteger ifFalse: [^ self error: 'Not an Integer.'].	^ dayListIndex! !!RuleSelectionCodeDate methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!applyRuleTo: daysNamedInMonthList 	"Private - Answer the day of the month selected from dayOfMonth list 	by applying the receiver's rule."	^ selectionRule value: daysNamedInMonthList! !!RuleSelectionCodeDate class methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!getValidSelectionRule: selectionBlock 	"Private - Answer the selectionBlock to select the date given the 	dayName (Sunday, etc) dayOfMonth list,  Report an error if 	selectionBlock does not represent a <monadicValuable> block."	((selectionBlock isMemberOf: BlockContext)		and: [selectionBlock argumentCount = 1])		ifFalse: [^ self error: 'Not an <monadicValuable> block.'].	^ selectionBlock! !!RuleSelectionCodeDate class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!selected: dayName inMonth: monthIn year: yearIn byCode: selectionBlock 	"Answer a date selected by selectionBlock given the dayName (Sunday, 	etc) dayOfMonth list, in month, monthIn, of year, yearIn.  Example: 	 	Standard Time starts on Sunday, 	so the Daylight Time end is the previous day: 	RuleSelectionCodeDate 	selected: 'Sunday' 	inMonth: 'October' 	year: 2000 	byCode: [ :sundaysList | 	(sundaysList last) - 1 	]. 	 	Note: The selected date need not be in the dayOfMonth list, but may be 	relative to a named day. 	The month may be an index or a month name. 	The year may be specified as the actual number of years since the 	beginning of the Roman calendar or the  number of years since 1900, 	or a two digit date from 1900.  1/1/01 will NOT mean 2001. 	Definition: <RuleDate factory> 	Parameters 	dayName		<readableString>				captured 	monthIn		<readableString> | <Integer>	captured 	yearIn			<Integer>					captured 	selectionBlock	<monadicValuable>			captured 	Return Values 	<RuleDate>		new 	Errors 	Day name is not a String and a valid day of the week 	Month is not an Integer 1 - 12. or a valid month name String	"	| mmInt newRuleDate |	mmInt := self getValidMonthNumber: monthIn.	newRuleDate := self newDayOfWeek: dayName selectionRule: selectionBlock.	newRuleDate basicUpdateForMonth: mmInt year: yearIn.	^ newRuleDate! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToFraction: receiver andSend: arithmeticOpSelector 	"Convert me to a Fraction and do the arithmetic. 	receiver arithmeticOpSelector self."	^ receiver perform: arithmeticOpSelector with: fraction! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToInteger: receiver andSend: arithmeticOpSelector 	"Convert receiver to a ScaledDecimal and do the arithmetic. 	receiver arithmeticOpSelector self."	^ (receiver asScaledDecimal: 0)		perform: arithmeticOpSelector with: self! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFloat	"Reimplementation - Number 'converting' method."	^ fraction asFloat! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asFraction	"Implementation - Number 'converting' method."	^ fraction! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asScaledDecimal: scaleIn 	"Reimplementation - Number 'converting' method."	^ ScaledDecimal newFromNumber: fraction scale: scaleIn! !!ScaledDecimal methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!asSpecies: number 	"Convert number to a ScaledDecimal."	#Numeric.	"add 200/01/19 For ANSI <number>support."	^ ScaledDecimal newFromNumber: number scale: scale! !!ScaledDecimal methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printOn: aStream 	"Reimplementation - Object 'printing' method."	| aFraction tmpFractionPart |	self < 0 ifTrue: [aStream nextPut: $-].	aFraction := fraction abs.	aStream nextPutAll: aFraction truncated printString.	scale = 0 ifTrue: [^ aStream nextPutAll: 's0'].	aStream nextPut: $..	tmpFractionPart := aFraction fractionPart.	1 to: scale		do: 			[:dummy | 			tmpFractionPart := tmpFractionPart * 10.			aStream nextPut: (Character digitValue: tmpFractionPart truncated).			tmpFractionPart := tmpFractionPart fractionPart].	aStream nextPut: $s.	scale printOn: aStream! !!ScaledDecimal methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printString	"Reimplementation - Number 'printing' method."	| tempStream |	tempStream := WriteStream on: (String new: 10).	self printOn: tempStream.	^ tempStream contents! !!ScaledDecimal methodsFor: 'testing' stamp: 'RAH 4/25/2000 19:49'!isScaledDecimal	"Reimplementation - Number 'testing' method."	^ true! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!* operand 	"Implementation of Number 'arithmetic' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction * operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #*! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!+ operand 	"Implementation of Number 'arithmetic' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction + operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #+! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!- operand 	"Implementation of Number 'arithmetic' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction - operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #-! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'AFi 11/23/2002 19:12'!/ operand 	"Implementation of Number 'arithmetic' method."	#ScalDec.	"Protocol: ANSI <number>."	operand = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	(operand isKindOf: ScaledDecimal) ifTrue: [^ ScaledDecimal newFromNumber: fraction / operand asFraction scale: (scale max: operand scale)].	^ operand adaptToScaledDecimal: self andSend: #/! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!// operand 	"Answer the integer quotient after dividing the receiver by operand 	with truncation towards negative infinity."	^ fraction // operand! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!negated	"Reimplementation of Number 'arithmetic' method."	^ ScaledDecimal newFromNumber: fraction negated scale: scale! !!ScaledDecimal methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!reciprocal	"Reimplementation of Number 'arithmetic' method."	self = 0 ifTrue: [^ (ZeroDivide dividend: 1) signal].	^ ScaledDecimal newFromNumber: fraction reciprocal scale: scale! !!ScaledDecimal methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!fractionPart	"Answer the fractional part of the receiver."	^ ScaledDecimal newFromNumber: fraction fractionPart scale: scale! !!ScaledDecimal methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!integerPart	"Answer the fractional part of the receiver."	^ ScaledDecimal newFromNumber: fraction integerPart scale: scale! !!ScaledDecimal methodsFor: 'truncation and round off' stamp: 'RAH 4/25/2000 19:49'!truncated	"Reimplementation of Number 'truncation and round off' method."	^ fraction truncated! !!ScaledDecimal methodsFor: 'comparing' stamp: 'AFi 11/23/2002 19:12'!< operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction < operand asFraction].	^ operand adaptToScaledDecimal: self andSend: #<! !!ScaledDecimal methodsFor: 'comparing' stamp: 'AFi 11/23/2002 19:13'!= comparand 	"Implementation of Number 'comparing' method."	comparand isNumber ifFalse: [^ false].	(comparand isKindOf: ScaledDecimal) ifTrue: [^ fraction = comparand asFraction].	^ comparand adaptToScaledDecimal: self andSend: #=! !!ScaledDecimal methodsFor: 'comparing' stamp: 'RAH 4/25/2000 19:49'!hash	"Reimplementation of Object 'comparing' method."	^ fraction hash! !!ScaledDecimal methodsFor: 'comparing' stamp: 'RAH 4/25/2000 19:49'!isZero	"Answer whether the receiver is equal to its class' zero"	^ fraction numerator = 0! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!denominator	"Private - Answer an Integer, the denominator part of the receiver."	^ fraction denominator! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!numerator	"Private - Answer an Integer, the numerator part of the receiver."	^ fraction numerator! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!scale	"Private - Answer a integer which represents the total number of digits 	used to represent the fraction part of the receiver, including trailing 	zeroes. "	^ scale! !!ScaledDecimal methodsFor: 'private' stamp: 'RAH 4/25/2000 19:49'!setFraction: fractionIn scale: scaleIn 	"Private - Set the fraction to fractionIn and the total number of digits 	used to represent the fraction part of the receiver, including trailing 	zeroes, to the Integer scaleIn."	fraction := fractionIn.	scale := scaleIn! !!ScaledDecimal methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49'!squared	"Reimplementation - Number 'mathematical functions' method."	"not used ->"	^ ScaledDecimal newFromNumber: fraction squared scale: scale! !!ScaledDecimal class methodsFor: 'instance creation' stamp: 'RAH 4/25/2000 19:49'!newFromNumber: aNumber scale: scaleIn 	"Answer a new instance of me."	| temp |	temp := self basicNew.	temp setFraction: aNumber asFraction scale: scaleIn.	^ temp! !!ScaledDecimal class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!one	"Answer the receiver's representation of one."	^ self newFromNumber: 1 scale: 0! !!ScaledDecimal class methodsFor: 'constants' stamp: 'RAH 4/25/2000 19:49'!zero	"Answer the receiver's representation of zero."	^ self newFromNumber: 0 scale: 0! !!String methodsFor: 'accessing' stamp: 'RAH 4/25/2000 19:49'!indexOfSubCollection: sub 	#Collectn.	"Added 2000/04/08 For ANSI <sequenceReadableCollection> protocol."	^ self		indexOfSubCollection: sub		startingAt: 1		ifAbsent: [0]! !!String methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!subStrings	"Answer an array of the substrings that compose the receiver."	#Collectn.	"Added 2000/04/08 For ANSI <readableString> protocol."	^ self substrings! !!String methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!subStrings: separators 	"Answer an array containing the substrings in the receiver separated 	by the elements of separators."	| char result sourceStream subString |	#Collectn.	"Changed 2000/04/08 For ANSI <readableString> protocol."	(separators allSatisfy: [:element | element isKindOf: Character])		ifFalse: [^ self error: 'separators must be Characters.'].	sourceStream := ReadStream on: self.	result := OrderedCollection new.	subString := String new.	[sourceStream atEnd]		whileFalse: 			[char := sourceStream next.			(separators includes: char)				ifTrue: [subString notEmpty						ifTrue: 							[result add: subString copy.							subString := String new]]				ifFalse: [subString := subString , (String with: char)]].	subString notEmpty ifTrue: [result add: subString copy].	^ result asArray! !ArithmeticError subclass: #ZeroDivide	instanceVariableNames: 'dividend'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!