'From Squeak2.8alpha of 13 January 2000 [latest update: #2210] on 31 May 2000 at 1:13:43 pm'!"Change Set:		dsaPart1Date:			31 May 2000Author:			Bob ArningThis is the first of two changesets to DSA that will:- fix the incompatibility between the current code and the new LargeInteger plugin- provide some timing data useful in evaluating part two- provide for saving some signatures to disk to validate part twoAfter filing this in, you can do:- (DigitalSignatureAlgorithm runTiming) to get a short report to the Transcript showing times for various large integer arithmetic implementations- (DigitalSignatureAlgorithm timeDecode: 20) to get timing information on signature verification with the current DSA code- (DigitalSignatureAlgorithm writeExamplesToDisk) to save some messages with signatures and public keys to disk. This file can be used in validating the second changeset"!!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'RAA 5/31/2000 12:33'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations _ 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes _ Integer primesUpTo: 2000.		SmallPrimes _ SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor _ SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne _ p - 1.	b _ self logOfLargestPowerOfTwoDividing: pMinusOne.	m _ pMinusOne // (2 raisedTo: b).	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r _ Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a _ (r next * 16rFFFFFF) truncated.		j _ 0.		z _ (self raise: a to: m mod: p) normalize.	"<--since largeint = requires this"		couldBePrime _ z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime _ true]				ifFalse: [					(j _ j + 1) < b						ifTrue: [z _ self remainder: (z * z) mod: p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'RAA 5/31/2000 08:46'!sign: aStringOrStream privateKey: privateKey dsa: dsa	"Sign the given message (a stream or string) and answer a signature string."	"Note: Unguessable random numbers are needed for message signing. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before signing a message. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	| hasher h sig |	hasher _ SecureHashAlgorithm new.	(aStringOrStream class isBytes)		ifTrue: [h _ hasher hashMessage: aStringOrStream]		ifFalse: [h _ hasher hashStream: aStringOrStream].	sig _ dsa computeSignatureForMessageHash: h privateKey: privateKey.	^ dsa signatureToString: sig! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'RAA 5/31/2000 12:54'!testExamplesFromDisk	"verify messages from file on disk"	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm testExamplesFromDisk"	| msg  sig file publicKey |	file _ FileStream oldFileNamed: 'dsa.test.out'.	[		[file atEnd] whileFalse: [			sig _ file nextChunk.			msg _ file nextChunk.			publicKey _ Compiler evaluate: file nextChunk.			(self verify: sig isSignatureOf: msg publicKey: publicKey) ifTrue: [				Transcript show: 'SUCCESS: ',msg; cr.			] ifFalse: [				self error: 'ERROR!! Signature verification failed'			].		].	] ensure: [file close]! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'RAA 5/31/2000 08:46'!timeDecode: count	"Example of signing a message and verifying its signature."	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm timeDecode: 20"	| msg keys sig s dsa |	dsa _ DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	#(1 10 100 1000 10000 100000) do: [ :extraLen |		s _ String new: extraLen.		1 to: s size do: [ :i | s at: i put: (Character value: 200 atRandom)].		msg _ 'This is a test...',s.		keys _ self testKeySet.		sig _ self sign: msg privateKey: keys first dsa: dsa.		"self inform: 'Signature created'."		self timeDirect: [			count timesRepeat: [				(self verify: sig isSignatureOf: msg publicKey: keys last)					ifFalse: [self error: 'ERROR!! Signature verification failed'].			].		] as: 'verify msgLen = ',msg size printString count: count	].! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'RAA 5/31/2000 13:13'!writeExamplesToDisk	"Example of signing a message and verifying its signature. Used to create samples from one implementation that could later be tested with a different implementation"	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm writeExamplesToDisk"	| sig file keyList dsa msgList |	dsa _ DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	self inform: 'About to generate 5 key sets. Will take a while'.	keyList _ {self testKeySet},((1 to: 5) collect: [ :ignore | self generateKeySet]).	msgList _ {'This is a test...'. 'This is the second test period.'. 'And finally, a third message'}.	file _ FileStream newFileNamed: 'dsa.test.out'.	[		msgList do: [ :msg |			keyList do: [ :keys |				sig _ self sign: msg privateKey: keys first dsa: dsa.				(self verify: sig isSignatureOf: msg publicKey: keys last) ifTrue: [					file						nextChunkPut: sig;						nextChunkPut: msg;						nextChunkPut: keys last storeString.				] ifFalse: [					self error: 'ERROR!! Signature verification failed'				].			].		].	] ensure: [file close]! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:35'!runTiming"DigitalSignatureAlgorithm runTiming"	| results ops modeNames |	modeNames _ #('standard dsa' 'standard integer' 'digitDiv:neg:').	results _ OrderedCollection new.	1 to: 3 do: [ :mode |		results add: (DigitalSignatureAlgorithm timeMultiply: 100000 mode: mode),{mode}.		results add: (DigitalSignatureAlgorithm timeRemainder: 100000 mode: mode),{mode}.		results add: (DigitalSignatureAlgorithm timeToDivide: 100000 mode: mode),{mode}.	].	ops _ (results collect: [ :each | each second]) asSet asSortedCollection.	ops do: [ :eachOp |		results do: [ :eachResult |			eachResult second = eachOp ifTrue: [				Transcript show: eachResult first asStringWithCommas,'  ',					eachResult second ,' took ',					eachResult third asStringWithCommas,' ms using ',					(modeNames at: eachResult fourth); cr			].		].		Transcript cr.	].! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:21'!time: aBlock as: aString count: anInteger	^{anInteger. aString. (Time millisecondsToRun: aBlock)}! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:40'!timeDirect: aBlock as: aString count: anInteger	Transcript show: anInteger asStringWithCommas,'  ',		aString ,' took ',		(Time millisecondsToRun: aBlock) asStringWithCommas,' ms'; cr! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:18'!timeMultiply: iterationCount mode: mode	"Exercise the multiply primitive on iterationCount pairs of random 60 bit integers."	"DigitalSignatureAlgorithm timeMultiply: 100000 mode: 1"	| dsa r x y |	dsa _ DigitalSignatureAlgorithm new.	r _ Random new.		x _ ((r next * 16r3FFFFFFF highBit) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		y _ ((r next * 16r3FFFFFFF) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.	^self time: [		iterationCount timesRepeat: [			mode = 1 ifTrue: [dsa multiply: x by: y].			mode = 2 ifTrue: [x * y].		].	] as: 'multiply' count: iterationCount! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:19'!timeRemainder: iterationCount mode: mode	"Exercise the remainder method on iterationCount pairs of random 60 bit integers."	"DigitalSignatureAlgorithm timeRemainder: 100000 mode: 1"	| dsa r c d tmp |	dsa _ DigitalSignatureAlgorithm new.	r _ Random new.		c _ ((r next * 16r3FFFFFFF highBit) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		d _ ((r next * 16r3FFFFFFF) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		c < d ifTrue: [tmp _ c. c _ d. d _ tmp].	^self time: [		iterationCount timesRepeat: [			mode = 1 ifTrue: [dsa remainder: c mod: d].			mode = 2 ifTrue: [c \\ d].			mode = 3 ifTrue: [(c digitDiv: d neg: false) second].		].	] as: 'remainder' count: iterationCount! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:19'!timeToDivide: iterationCount mode: mode	"Exercise the divide primitive on iterationCount pairs of random 60 bit integers."	"DigitalSignatureAlgorithm timeToDivide: 100000 mode: 1"	| dsa r c d tmp |	dsa _ DigitalSignatureAlgorithm new.	r _ Random new.		c _ ((r next * 16r3FFFFFFF highBit) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		d _ ((r next * 16r3FFFFFFF) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		c < d ifTrue: [tmp _ c. c _ d. d _ tmp].	^self time: [		iterationCount timesRepeat: [			mode = 1 ifTrue: [dsa divide: c by: d].			mode = 2 ifTrue: [c // d. c \\ d].			mode = 3 ifTrue: [(c digitDiv: d neg: false) second].		].	] as: 'divide' count: iterationCount! !