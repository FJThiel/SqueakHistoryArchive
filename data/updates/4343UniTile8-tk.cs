'From Squeak3.1alpha of 28 February 2001 [latest update: #4342] on 17 September 2001 at 2:17:01 pm'!"Change Set:		UniTile8-tkDate:			17 September 2001Author:			Ted Kaehler	Working toward being able to program naturally in a protocol (lexicon) browser with Universal tiles.	Added menus to get a new universal tile for (new temp variable), inst var, constants, return, if-then test, self, comment, and assignment arrow.  	Other actions are available by selecting a tile in the script.  As before a tile expands to show controls for (send a new message to it), delete it, and up/down arrows for a number constant.	Make accept work. Make refresh work after an accept that creates a new method.	Make menus appear on mouseDown.	Add a method template in tiles when no method is selected.	Dropping a temp var name into a block both installs it as a temp, and starts a new statement.	Dropping an assignment arrow on a noun causes it to change to an assignment statement.  "!!SyntaxMorph commentStamp: 'tk 9/12/2001 15:23' prior: 0!A single class of morph that holds any piece of Smalltalk syntax, and allows it to be a tile.  Tiles can be dragged in or out of a method. In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.  If you use a Protocol Browser, and choose tiles, there will be two buttons that bring up menus with many tiles on them.Clicking multiple times selects enclosing phrases of code.  Dragging lets you take away a copy.  Any tile may be replaced by dropping on it.  Shift-click to edit the text of any tile.  Change variable and message names, but do not change the part-of-speech (objects to selector).Each SyntaxMorph holds a ParseNode.  After editing, the parseNode is only good as a part-of-speech indicator.  Only the Class of a parseNode is important.  It's state is not kept up to date with the tile edits (but maybe it should be).  (For MessageNodes, whether the receiver slot is nil is significant.)The correspondence between SyntaxMorphs and parseNodes in the real parse tree is not one-to-one.  Several extra levels of SyntaxMorph were added as aligners to make the horizontal and vertical layout right.  These sometimes have nil for the parseNode.When accept the method, we pass over the tree of SyntaxMorphs, gathering their printStrings and inserting punctuation.  See (SyntaxMorph>>printOn:indent:).  We send the result to the compiler.  (We do not use the parse tree we already have.)To turn on type checking: Preferences enable: #eToyFriendlyor for testing:     World project projectParameters at: #fullCheck put: true.Colors of tiles:  Each tile has a current color (inst car color) and a deselectedColor (a property).  The deselectedColor may be governed by the part of speech, or not.  (translateColor: is only used when a tile is created, to set deselectedColor.)  From deselectedColor (set by #setDeselectedColor), the color changes to:	lightBrown when selected (not the submorphs) in #select	translucent when held in the hand (allMorphs) in #lookTranslucent	green when a drop target (allMorphs) (change the owners back) #dropColor, 		#trackDropZones deselectedColor is moderated by the darkness setting, #scaleColorByUserPref:.  (as it is put into color in #color:)Code to produce an individual tile is: 	(SyntaxMorph new) attachTileForCode: '''abc''' nodeType: LiteralNode.see offerTilesMenuFor:in: for many other phrases that produce useful tiles.AssignmentNode:  If three submorphs, is a statement, and is a noun.  If one submorph, is just the left arrow.  When dropped on a variable, it creates a new assignment statement. !!Object methodsFor: 'testing' stamp: 'tk 9/6/2001 19:15'!openInstanceBrowserWithTiles	"Open up an instance browser on me with tiles as the code type, and with the search level as desired."	| aBrowser |	aBrowser _ InstanceBrowser new.	aBrowser useVocabulary: Vocabulary fullVocabulary.	aBrowser limitClass: self class.	aBrowser contentsSymbol: #tiles.		"preset it to make extra buttons (tile menus)"	aBrowser openOnObject: self inWorld: ActiveWorld showingSelector: nil.	aBrowser contentsSymbol: #source.	aBrowser toggleShowingTiles.	"(2@3) openInstanceBrowserWithTiles.WatchMorph new openInstanceBrowserWithTiles"! !!CodeHolder methodsFor: 'controls' stamp: 'tk 9/8/2001 22:40'!optionalButtonRow	"Answer a row of control buttons"	| aRow aButton aLabel |	aRow _ AlignmentMorph newRow.	aRow setNameTo: 'buttonPane'.	aRow beSticky.	aRow hResizing: #spaceFill.	aRow wrapCentering: #center; cellPositioning: #leftCenter.	aRow clipSubmorphs: true.	aRow cellInset: 3.	Preferences menuButtonInToolPane		ifTrue:			[aRow addMorphFront: self menuButton].	self optionalButtonPairs  do:		[:tuple |			aButton _ PluggableButtonMorph				on: self				getState: nil				action: tuple second.			aButton 				useRoundedCorners;				hResizing: #spaceFill;				vResizing: #spaceFill;				onColor: Color transparent offColor: Color transparent.			aLabel _ Preferences abbreviatedBrowserButtons 				ifTrue: [self abbreviatedWordingFor: tuple second]				ifFalse: [nil].			aButton label: (aLabel ifNil: [tuple first asString])				" font: (StrikeFont familyName: 'Atlanta' size: 9)".			tuple size > 2 ifTrue: [aButton setBalloonText: tuple third].			tuple size > 3 ifTrue: [aButton triggerOnMouseDown: tuple fourth].			aRow addMorphBack: aButton].	aRow addMorphBack: self codePaneProvenanceButton.	^ aRow! !!MessageSet methodsFor: 'private' stamp: 'tk 9/15/2001 08:27'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class_c.  oldSelector_os].	class ifNil: [^ false].	(oldSelector ~~ nil and: [oldSelector first isUppercase]) ifTrue: [		oldSelector = #Comment ifTrue: [			class comment: aString. 			self clearUserEditFlag.			^ false].		oldSelector = #Definition ifTrue: [			"self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self clearUserEditFlag. 			^ false].		oldSelector = #Hierarchy ifTrue: [			self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^ false].	self noteAcceptanceOfCodeFor: selector.	selector == oldSelector ifFalse:		[self reformulateListNoting: selector].	contents _ aString copy.	self changed: #annotation.	^ true! !!Lexicon methodsFor: 'initialization' stamp: 'tk 9/6/2001 17:58'!openOnClass: aTargetClass inWorld: aWorld showingSelector: aSelector	"Create and open a SystemWindow to house the receiver, showing the categories pane.  The target-object parameter is optional -- if nil, the browser will be associated with the class as a whole but not with any particular instance of it."	| window aListMorph catListFraction |	currentVocabulary ifNil: [currentVocabulary _ Vocabulary fullVocabulary].	limitClass ifNil: [limitClass _ ProtoObject].	targetClass _ aTargetClass.		window _ self windowWithLabel: self startingWindowTitle.	catListFraction _ 0.20.		window addMorph: self newCategoryPane frame: (0 @ 0 corner: 0.5 @ catListFraction).	aListMorph _ PluggableListMorph new.	aListMorph 	setProperty: #balloonTextSelectorForSubMorphs toValue: #balloonTextForLexiconString.	aListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph setNameTo: 'messageList'.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: (0.5 @ 0 corner: 1 @ catListFraction).		"side by side"	self 		addLowerPanesTo: window 		at: (0 @ catListFraction  corner: 1@1) 		with: nil.	window changeAllBorderColorsFrom: Color black to: (self defaultBackgroundColor mixed: 0.5 with: Color black).	window color: self defaultBackgroundColor.	window openInWorld: aWorld.	self reformulateCategoryList.	aSelector ifNotNil: [self selectSelectorItsNaturalCategory: aSelector] ifNil: [self categoryListIndex: 1].	#(navigateToPreviousMethod	 navigateToNextMethod removeFromSelectorsVisited) do:		[:sel |			(self buttonWithSelector: sel) ifNotNilDo:				[:aButton | aButton borderWidth: 0]].	self adjustWindowTitle! !!Lexicon methodsFor: 'basic operation' stamp: 'tk 9/14/2001 16:32'!messageListIndex: anIndex	"Set the message list index as indicated, and update the history list if appropriate"	| newSelector current |	current _ self selectedMessageName.	super messageListIndex: anIndex.	anIndex = 0 ifTrue: [		editSelection _ #newMessage.		self contentsChanged].	(newSelector _ self selectedMessageName) ifNotNil: 		[self updateSelectorsVisitedfrom: current to: newSelector]! !!Lexicon methodsFor: 'contents' stamp: 'tk 9/14/2001 16:37'!contents	"We have a class, allow new messages to be defined"	editSelection == #newMessage ifTrue: [^ targetClass sourceCodeTemplate].	^ super contents! !!Lexicon methodsFor: 'control buttons' stamp: 'tk 9/8/2001 22:43'!optionalButtonPairs	"Answer a tuple (formerly pairs) defining buttons, in the format:			button label			selector to send			help message"	| aa |	aa _ contentsSymbol == #tiles ifTrue: [{	{'tiles'.				#tilesMenu.					'tiles for assignment and constants'. 	true}.	{'vars'.				#varTilesMenu.	'tiles for instance variables and a new temporary'. 	true}		}] ifFalse: [#()].	"true in 4th place means act on mouseDown"	^ aa, #(	('view'				seeAlso							'view a method called by this method')	('find'			obtainNewSearchString			'find methods by name search')	('senders'			setSendersSearch				'find methods I implement that send a given message')	('<'					navigateToPreviousMethod 		'view the previous active method')	('>'					navigateToNextMethod 			'view the next active method')	('-'					removeFromSelectorsVisited		'remove this method from my active list'))"	('cat'				showMainCategory				'show this method''s home category')	('inheritance'		methodHierarchy				'browse method inheritancegreen: sends to supertan: has override(s)mauve: both of the above')"! !!Lexicon methodsFor: 'selection' stamp: 'tk 9/15/2001 08:17'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	self setClassAndSelectorIn: [:c :s | ^c]! !!Lexicon methodsFor: 'selection' stamp: 'tk 9/15/2001 08:14'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])"	self selection ifNil: [^ csBlock value: targetClass value: nil].	^ super setClassAndSelectorIn: csBlock! !!Lexicon methodsFor: 'tiles' stamp: 'tk 9/17/2001 13:42'!acceptTiles	| pp pq methodNode cls sel |	"In complete violation of all the rules of pluggable panes, search dependents for my tiles, and tell them to accept."	pp _ self dependents detect: [:pane | pane isKindOf: PluggableTileScriptorMorph] 			ifNone: [^ self beep].	pq _ pp findA: TransformMorph.	methodNode _ pq findA: SyntaxMorph.	cls _ methodNode parsedInClass.	sel _ cls compile: methodNode decompile classified: self selectedCategoryName			notifying: nil.	self noteAcceptanceOfCodeFor: sel.	self reformulateListNoting: sel.! !!Lexicon methodsFor: 'tiles' stamp: 'tk 9/14/2001 18:05'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow _ self containingWindow) ifNil: [self error: 'hamna dirisha'].	aSelector _ self selectedMessageName. 	aClass _ self selectedClassOrMetaClass ifNil: [targetClass].	aClass ifNotNil:		[aSelector 			ifNil: [source _ SyntaxMorph sourceCodeTemplate]			ifNotNil: [				aClass _ self selectedClassOrMetaClass classThatUnderstands: aSelector.				source _ aClass sourceCodeAt: aSelector].    		tree _ Compiler new 			parse: source 			in: aClass 			notifying: nil.		(syn _ tree asMorphicSyntaxUsing: SyntaxMorph)			parsedInClass: aClass.		tileScriptor _  syn inAPluggableScrollPane].	codePane _ aWindow findDeepSubmorphThat:   		[:m | (m isKindOf: PluggableTextMorph) and: 				[m getTextSelector == #contents]] ifAbsent: [nil].	codePane ifNotNil: [codePane hideScrollBar].	codePane ifNil: [codePane  _ aWindow findDeepSubmorphThat:   		[:m | m isKindOf: PluggableTileScriptorMorph] ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod _ aClass ifNotNil: [		aClass compiledMethodAt: aSelector ifAbsent: [nil]].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent.! !!Lexicon methodsFor: 'tiles' stamp: 'tk 9/7/2001 10:15'!tilesMenu	"Offer a menu of tiles for assignment and constants"	SyntaxMorph new offerTilesMenuFor: self targetObject in: self! !!Lexicon methodsFor: 'tiles' stamp: 'tk 9/7/2001 10:24'!varTilesMenu	"Offer a menu of tiles for instance variables and a new temporary"	SyntaxMorph new offerVarsMenuFor: self targetObject in: self! !!Morph methodsFor: 'debug and other' stamp: 'tk 9/6/2001 18:32'!buildDebugMenu: aHand	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu aPlayer |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect].	(self isKindOf: MorphicModel) ifTrue:		[aMenu add: 'inspect model' target: self model action: #inspect].	(aPlayer _ self player) ifNotNil:		[aMenu add: 'inspect player' target: aPlayer action: #inspect].     aMenu add: 'explore morph' target: self selector: #explore.	aMenu addLine.	aMenu add: 'viewer for Player' target: self player action: #beViewed.	aMenu balloonTextForLastItem: 'Opens a viewer on my Player -- this is the same thing you get if you click on the cyan "View" halo handle'.	aMenu add: 'viewer for Morph' target: self action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'Opens a Viewer on this Morph, rather than on its Player'.	aMenu addLine.	aPlayer ifNotNil:		[aPlayer class isUniClass ifTrue: [			aMenu add: 'browse player class' target: aPlayer action: #browseHierarchy]].	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aMenu addLine.	aPlayer ifNotNil:		[aMenu add: 'player protocol (tiles)' target: aPlayer action: #openInstanceBrowserWithTiles			"#browseProtocolForPlayer"].	aMenu add: 'morph protocol (text)' target: self selector: #haveFullProtocolBrowsed.	aMenu add: 'morph protocol (tiles)' target: self selector: #openInstanceBrowserWithTiles.	aMenu addLine.	self addViewingItemsTo: aMenu.	aMenu 		add: 'make own subclass' action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file'  action: #saveOnFile;		addLine;		add: 'call #tempCommand' action: #tempCommand;		add: 'define #tempCommand' action: #defineTempCommand;		addLine;		add: 'control-menu...' target: self selector: #invokeMetaMenu:;		add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!PluggableTileScriptorMorph methodsFor: 'updating' stamp: 'tk 9/14/2001 18:16'!update: aSymbol	"Update the receiver in the manner suggested by aSymbol"	aSymbol == #flash ifTrue: [^ self flash].	(aSymbol == #contents or: [aSymbol == #tiles])		ifTrue: [^ self containingWindow model installTilesForSelection]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/7/2001 16:13'!getCurrentValue	parseNode ifNil: [^nil].	parseNode class == Symbol ifTrue: [^nil].	"special"	^parseNode currentValueIn: self hostContext! !!SyntaxMorph methodsFor: 'node types' stamp: 'tk 9/13/2001 15:28'!isNoun	"Consider these to be nouns:  MessageNode with receiver, CascadeNode with receiver, AssignmentNode, TempVariableNode, LiteralNode, VariableNode, LiteralVariableNode."	(#(TempVariableNode LiteralNode VariableNode LiteralVariableNode) includes:		(parseNode class name)) ifTrue: [^ true].	(self nodeClassIs: MessageNode) ifTrue: [^ parseNode receiver notNil].	(self nodeClassIs: CascadeNode) ifTrue: [^ parseNode receiver notNil].	(self nodeClassIs: AssignmentNode) ifTrue: [^ submorphs size >= 3].	^ false! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/13/2001 15:28'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"Two cases: 1) a phrase being dropped into a block.  Add a new line.		2) aMorph is replacing self by dropping on it.	For the moment, you have to drop it the right place (the end of a tile if it is complex).  We do not look at enclosing morphs"	itNoun _ aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m isBlockNode])				ifTrue: [m stopStepping; removeDropZones]].	self isBlockNode & itNoun ifTrue:		[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				(self addBlockArg: aMorph)].		"If I am a BlockNode and it is a noun add it as a new line"		^ self addToBlock: aMorph event: evt].					self isBlockNode ifTrue: [		 (aMorph nodeClassIs: CommentNode) ifTrue: [^ self addToBlock: aMorph event: evt].		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[aMorph isAVariable ifFalse: [ ^ self]]]].	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			self isAVariable ifTrue: [^ self newAssignment]					ifFalse: [^ self]]].	"only assign to a variable"	aMorph deselect.	(old _ owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/13/2001 15:19'!structureMatchWith: aMorph	| meNoun itNoun |	"Return true if the node types would allow aMorph to replace me.  This tests the gross structure of the method only."	meNoun _ self isNoun.	itNoun _ aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ (self submorphs				detect: [:mm | ((mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode])]				ifNone: [nil]) isNil].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"		(aMorph nodeClassIs: CommentNode) ifTrue: [^ true]].	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	(self nodeClassIs: ReturnNode) & (aMorph parseNode class == MessageNode) 		ifTrue: [^ true].		"Command replace Return"	(self nodeClassIs: MessageNode) & (aMorph parseNode class == ReturnNode) ifTrue: [		(owner submorphs select: [:ss | ss isSyntaxMorph]) last == self			ifTrue: [^ true]].	"Return replace last command"	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			^ self isAVariable & self isDeclaration not]].	"only assign to a variable"	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: MessageNode) ifFalse: [		(self nodeClassIs: aMorph parseNode class) ifTrue: [^ true]].	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'drawing' stamp: 'tk 9/13/2001 15:13'!lookTranslucent	self setDeselectedColor.	super color: (self color alpha: 0.25).	submorphs do: [:mm | (mm respondsTo: #lookTranslucent) 		ifTrue: [mm lookTranslucent]		ifFalse: ["mm color: color"]].! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'tk 9/13/2001 15:24'!trackDropZones	| hand i localPt insertion insHt ii prevBot nxtHt d c1 c2 ht2 spacer1 spacer2 wid ht1 dc each |	hand _ self primaryHand.	("hand lastEvent redButtonPressed &" hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifFalse: [^ self].	insertion _ hand firstSubmorph renderedMorph.	insertion isSyntaxMorph ifFalse: [^ self].	insertion isNoun ifFalse: [(insertion nodeClassIs: CommentNode) ifFalse: [^ self]].	localPt _ self globalPointToLocal: hand position.	insHt _ insertion height.  "**just use standard line height here"	self removeDropZones.  "Maybe first check if in right place, then just tweak heights."	i _ (ii _ self indexOfMorphAbove: localPt) min: submorphs size-1.	prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].	nxtHt _ (submorphs isEmpty		ifTrue: [insertion]		ifFalse: [self submorphs at: i+1]) height.	d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]			ifFalse: [0 max: (localPt y - prevBot min: nxtHt)].	"Top and bottom spacer heights cause continuous motion..."	c1 _ Color transparent.  c2 _ Color transparent.	ht2 _ d*insHt//nxtHt.  ht1 _ insHt - ht2.	wid _ self width - (2*borderWidth) - (2*self layoutInset).	wid isPoint ifTrue: [wid _ wid x].	(spacer1 _ BorderedMorph newBounds: (0@0 extent: wid@ht1)				color: (ht1 > (insHt//2) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer1 color.	self privateAddMorph: spacer1 atIndex: (i+1 max: 1).	(spacer2 _ BorderedMorph newBounds: (0@0 extent: wid@ht2)				color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer2 color.	spacer1 setProperty: #dropZone toValue: true.	spacer2 setProperty: #dropZone toValue: true.	self privateAddMorph: spacer2 atIndex: (i+3 min: submorphs size+1).	self fullBounds.  "Force layout prior to testing for cursor containment"	"Maintain the drop target highlight -- highlight spacer if hand is in it."	{spacer1. spacer2} do:		[:spacer | (spacer containsPoint: localPt) ifTrue:			[spacer color: self dropColor.			"Ignore border color.  Maybe do it later.			self borderColor = self dropColor				ifTrue: [self borderColor: self stdBorderColor]"]].	"If no submorph (incl spacers) highlighted, then re-highlight the block."	"Ignore border color.  Maybe do it later.	((self wantsDroppedMorph: insertion event: hand lastEvent) and:		[(self submorphs anySatisfy: [:m | m containsPoint: localPt]) not])			ifTrue: [self borderColor: self dropColor].	"	"Dragging a tile within a Block, if beside a tile, color it a dropzone"	"Transcript show: localPt y printString; space; show: submorphs first top 		printString; space; show: submorphs last top printString; cr."	dc _ self dropColor.	1 to: ((ii+4 min: submorphs size) max: 1) do: [:ind | 		each _ submorphs at: ind.		each isSyntaxMorph ifTrue: [			localPt y >= each top 				ifTrue: ["in this one or beyond"					(localPt y < each bottom) 						ifTrue: [(each submorphs anySatisfy: [:m | 								m containsPoint: localPt])							ifTrue: [each setDeselectedColor]							ifFalse: [each color: dc]]						ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]				ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 15:50'!ownerPrecedence	| oo below sel pp |	"Return the selector precedence of my owner.  1 for unary (asInteger), 2 for binary arithmetic (+), and 3 for keyword selectors (from:to:).  Subtract 0.5 if self is an arg, not the receiver (the case of a + (b + c))"	oo _ owner. below _ self.	[oo isSyntaxMorph ifFalse: [^ 10].	"I do not need parens"	 oo parseNode == nil] whileTrue: [below _ oo.  oo _ oo owner].	(sel _ oo selector) ifNil: [^ 10].	(pp _ sel precedence) = 3 ifTrue: [^ 2.5]. 	"keyword messages need parens"	^ oo receiverNode == below ifTrue: [pp] ifFalse: [pp - 0.5]! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 15:58'!printAssignmentNodeOn: strm indent: level	"sometimes an assignment is in parens"	| parens above |	parens _ submorphs size >= 3.	parens ifTrue: [		above _ self ownerPrecedence.	"high if not in an expression"		parens _ above <= 3].	"assignment is a noun inside a message"	parens ifTrue: [strm nextPut: $( ].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			strm ensureASpace; skip: -1. 	"_ will have a leading space"			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm skip: -1; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 14:30'!printBlockNodeOn: strm indent: level	| lev inASyntaxButNotOutermost subNodeClass |	lev _ level.	inASyntaxButNotOutermost _ owner isSyntaxMorph and: [ owner isMethodNode not].	inASyntaxButNotOutermost ifTrue: [strm nextPut: $[.  lev _ lev+1].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: lev.			subNodeClass _ sub parseNode class.			(#(BlockArgsNode ReturnNode CommentNode) includes: subNodeClass name) ifFalse: [				strm skip: -1; nextPut: $.			].			subNodeClass == BlockArgsNode				ifTrue: [strm space]				ifFalse: [strm crtab: lev].		] 		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	inASyntaxButNotOutermost ifTrue: [strm nextPut: $] ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 15:50'!printMessageNodeOn: strm indent: level	| parens me above |	parens _ parseNode receiver notNil.	parens ifTrue: [me _ self selector precedence.		above _ self ownerPrecedence.	"high if not in an expression"		parens _ me > above].	parens ifTrue: [strm nextPut: $( ].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm skip: -1; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 13:52'!printOn: strm indent: level	| nodeClass |	(self hasProperty: #ignoreNodeWhenPrinting) ifFalse: [		nodeClass _ parseNode class.		nodeClass == VariableNode ifTrue: [^self printVariableNodeOn: strm indent: level].		nodeClass == LiteralVariableNode ifTrue: [^self printVariableNodeOn: strm indent: level].		nodeClass == MessageNode ifTrue: [^self printMessageNodeOn: strm indent: level].		nodeClass == BlockNode ifTrue: [^self printBlockNodeOn: strm indent: level].		nodeClass == BlockArgsNode ifTrue: [^self printBlockArgsNodeOn: strm indent: level].		nodeClass == MethodNode ifTrue: [^self printMethodNodeOn: strm indent: level].		nodeClass == MethodTempsNode ifTrue: [^self printMethodTempsNodeOn: strm indent: level].		nodeClass == CascadeNode ifTrue: [^self printCascadeNodeOn: strm indent: level].		nodeClass == AssignmentNode ifTrue: [^self printAssignmentNodeOn: strm indent: level].	].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 14:36'!submorphsDoIfSyntax: block1 ifString: block2 otherwise: block3	submorphs do: [ :sub |		sub isSyntaxMorph ifTrue: [			block1 value: sub		] ifFalse: [			(sub isKindOf: StringMorph) ifTrue: [				block2 value: sub			] ifFalse: [				(sub isKindOf: TextMorph) ifTrue: [					block2 value: sub				] ifFalse: [					block3 value: sub				].			].		].	].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/12/2001 16:07'!offerPopUp	"Put up a halo to allow user to change		Literals (Integer, true),		Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,),		Variable (Color),		not AssignmentNode (_ inc dec),	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge dismiss rr |	(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"	any _ false.	(upDown _ self upDownArrows) ifNotNil: [any _ true].	(retract _ self retractArrow) ifNotNil: [any _ true].	(extend _ self extendArrow) ifNotNil: [any _ true].	(dismiss _ self dismisser) ifNotNil: [any _ true].	"(assign _ self assignmentArrow) ifNotNil: [any _ true].			get from menu or any other assignment"	submorphs last class == ColorTileMorph ifFalse: [		(colorPatch _ self colorPatch) ifNotNil: [any _ true]].	any ifFalse: [^ self].	"Transcript cr; print: parseNode class; space; 		print: (self hasProperty: #myPopup); endEntry."	panel _ RectangleMorph new color: Color transparent; borderWidth: 0.	upDown ifNotNil: [		panel addMorphBack: upDown first.		upDown first align: upDown first topLeft with: panel topLeft + (0@0).		panel addMorphBack: upDown second.		upDown second align: upDown second topLeft with: upDown first bottomLeft + (0@1).		upDown size > 2 ifTrue: [			panel addMorphBack: upDown third.			upDown third align: upDown third topLeft with: upDown first topRight + (2@3).			]].	rr _ self right.	colorPatch ifNotNil: [		rr _ rr + colorPatch submorphs first width + 1.		self addMorphBack: colorPatch.	"always in tile"		"colorPatch align: colorPatch topLeft 					with: panel topLeft + (1@1)"].	retract ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: retract.		retract align: retract topLeft with: (edge+2) @ (panel top + 3)].	extend ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: extend.		extend align: extend topLeft with: (edge+2) @ (panel top + 3)].	dismiss ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: dismiss.		dismiss align: dismiss topLeft with: (edge+2) @ (panel top + 1)]."	assign ifNotNil: [		edge _ panel submorphs size = 0 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: assign.		assign align: assign topLeft with: (edge+2) @ (panel top + 2)]."	panel align: panel topLeft with: rr @ (self top -2).	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	self addMorphBack: panel.	"Any reason ever to have panel below?"	"(owner listDirection = #topToBottom and: [self listDirection = #leftToRight])		ifTrue: [self addMorphBack: panel]		ifFalse: [owner addMorph: panel after: self]."! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 9/12/2001 14:47'!attachTileForCode: expression nodeType: nodeClass	| nn master tile |	"create a new tile for a part of speech, and put it into the hand"	"a few special cases"	expression = 'self' ifTrue: [		^ (((self string: expression toTilesIn: Object) 				findA: ReturnNode) findA: nodeClass) attachToHand].	expression = '<me by name>' ifTrue: ["Tile for the variable in References"		nn _ nodeClass knownName ifNil: [#+].		(References at: nn asSymbol ifAbsent: [nil]) == nodeClass ifTrue: [			^ self attachTileForCode: nn nodeType: LiteralVariableNode].		"otherwise just give a tile for self"		^ self attachTileForCode: 'self' nodeType: VariableNode].	expression = '<assignment>' ifTrue: ["do something really special"		master _ self class new.		master addNoiseString: '  _  ' emphasis: 1.		tile _ master firstSubmorph.		^ (tile parseNode: AssignmentNode new) attachToHand].	"special marker"		"When this is dropped on a variable, enclose it in 			a new assignment statement"	"general case -- a tile for a whole line of code is returned"	^ ((self string: expression toTilesIn: Object) 				findA: nodeClass) attachToHand.! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 9/7/2001 11:21'!attachToHand	"Adjust my look and attach me to the hand"	self roundedCorners.	ActiveHand attachMorph: self.	Preferences tileTranslucentDrag		ifTrue: [self lookTranslucent.			self align: self center with: ActiveHand position "+ self cursorBaseOffset"]		ifFalse: [self align: self topLeft with: ActiveHand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 9/13/2001 13:44'!string: anExpression toTilesIn: playerClass	| code tree methodNode |	"Construct SyntaxMorph tiles for some code.  Returns the main BlockNode of a doIt."	"This is really cheating!!  Make a true parse tree later. -tk"	code _ String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab; nextPutAll: anExpression].	"decompile to tiles"	tree _ Compiler new 		parse: code 		in: playerClass		notifying: nil.	methodNode _ tree asMorphicSyntaxUsing: SyntaxMorph.	anExpression first == $" ifTrue: ["a comment" 		"(methodNode findA: CommentNode) firstSubmorph color: Color blue."		^ methodNode].	^ methodNode submorphs detect: [:mm | 		(mm respondsTo: #parseNode) 			ifTrue: [mm parseNode class == BlockNode] 			ifFalse: [false]].! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/15/2001 08:33'!accept	"Turn my current state into the text of a method.  Compile it in my class."	| cls sc sel |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile accept  "always accept at the root"].	(cls _ self parsedInClass) ifNil: [^ self].	sel _ cls compile: self decompile notifying: nil.	(sc _ self firstOwnerSuchThat: [:mm | mm class == ScriptEditorMorph]) 		ifNotNil: [sc hibernate; unhibernate].	"rebuild the tiles"	^ sel! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/13/2001 12:57'!offerTilesMenuFor: aReceiver in: aLexiconModel	"Offer a menu of tiles for assignment and constants"	| menu |	menu _ MenuMorph new addTitle: 'Hand me a tile for...'.	menu addLine.	menu add: '(accept method now)' target: aLexiconModel selector: #acceptTiles.	menu submorphs last color: Color red darker.	menu addLine.	menu add: 'me, by name' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'<me by name>'. aReceiver}.	menu add: 'self' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'self'. VariableNode}.	menu add: '_   (assignment)' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'<assignment>'. nil}.	menu add: '"a Comment"' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'"a comment"\' withCRs. CommentNode}.	menu submorphs last color: Color blue.	menu add: 'a Number' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'5'. LiteralNode}.	menu add: 'a Character' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'$z'. LiteralNode}.	menu add: '''abc''' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'''abc'''. LiteralNode}.	menu add: 'a Symbol constant' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'#next'. LiteralNode}.	menu add: 'true' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'true'. VariableNode}.	menu add: 'a Test' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'true ifTrue: [] ifFalse: []'. MessageNode}.	menu add: 'a Loop' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'1 to: 10 do: [:index | self]'. MessageNode}.	menu add: 'a Block' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'[self]'. BlockNode}.	menu add: 'a Class or Global' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'Character'. LiteralVariableNode}.	menu add: 'a Reply' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. ReturnNode}.	menu popUpAt: ActiveHand position forHand: ActiveHand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/17/2001 13:38'!offerVarsMenuFor: aReceiver in: aLexiconModel	"Offer a menu of tiles for assignment and constants"	| menu instVarList cls |	menu _ MenuMorph new addTitle: 'Hand me a tile for...'.	menu addLine.	menu add: '(accept method now)' target: aLexiconModel selector: #acceptTiles.	menu submorphs last color: Color red darker.	menu addLine.	menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. TempVariableNode}.	instVarList _ OrderedCollection new.	cls _ aReceiver class.	[instVarList addAllFirst: cls instVarNames.	 cls == aLexiconModel limitClass] whileFalse: [cls _ cls superclass].	instVarList do: [:nn |		menu add: nn target: self selector: #instVarTile: argument: nn].	menu popUpAt: ActiveHand position forHand: ActiveHand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/8/2001 22:16'!showMenu: evt	| menu |	menu _ MenuMorph new.	self rootTile isMethodNode ifTrue:		[menu add: 'accept method' target: self selector: #accept].	menu addLine.	menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. TempVariableNode}.	menu addLine.	self parsedInClass allInstVarNames do: [:nn |		menu add: nn,' tile' target: self selector: #instVarTile: argument: nn].	menu addLine.	menu add: 'show code' target: self selector: #showCode.	menu add: 'try out' target: self selector: #try.	menu popUpAt: evt hand position forHand: evt hand in: World.! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 9/14/2001 14:27'!selector	| sel cnt |	"Find the selector I represent, or have inside of me.  My parseNode is a SelectorNode or a MessageNode."	parseNode class == SelectorNode ifTrue: [		^ self decompile asString asSymbol].	parseNode class == KeyWordNode ifTrue: [		^ self decompile asString asSymbol].	"Beware of messageParts.  If MessagePartNode, only returns this part."	sel _ ''.  cnt _ 0.	submorphs do: [:mm | 		mm isSyntaxMorph ifTrue: [ cnt _ cnt + 1.			(mm nodeClassIs: SelectorNode) ifTrue: [^ mm selector].			(mm nodeClassIs: MessagePartNode) ifTrue: [				sel _ sel, mm selector].			(mm nodeClassIs: KeyWordNode) ifTrue: [				sel _ sel, mm decompile asString].			cnt = 2 & (sel size = 0) ifTrue: ["not the receiver.  Selector and arg"				(mm nodeClassIs: MessageNode) ifTrue: [					sel _ mm selector]]]].	sel ifNil: [^ nil].	sel size > 0 ifTrue: [^ sel asSymbol]. 	^ nil! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 9/14/2001 18:19'!sourceCodeTemplate	"Return the default tile method template"	^ 'anEmpty: input1 method: input2	"Edit the name above and the code below to make your own method"	3 + 4.	"Drag tiles in here.  Use the ''tiles'' and ''vars'' menus to get new tiles"	^ ''this is a statement'' sorted'  ! !SyntaxMorph removeSelector: #replyTile!SyntaxMorph removeSelector: #tempVarTile!!SyntaxMorph reorganize!('initialization' inAPluggableScrollPane inAScrollPane openInWindow returnNode:expression: sample:)('accessing' actualObject cleanUpString: color: editor externalName fillStyle: getCurrentValue immediatelyBelowTheMethodNode isLeafTile parseNode parseNode: parsedInClass parsedInClass: receiverNode rename: unSpaceAndUpShift:appending: userScriptSelector userScriptSelector:)('node types' findA: isAVariable isBlockNode isCascadePart isDeclaration isMethodNode isNoun isSyntaxMorph nodeClassIs: rootTile)('event handling' cursorBaseOffset handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: step stepTime wantsSteps)('dropping/grabbing' acceptDroppingMorph:event: cleanupAfterItDroppedOnMe justDroppedInto:event: morphToDropInPasteUp: structureMatchWith: wantsDroppedMorph:event:)('drawing' drawOn: lookTranslucent)('highlighting' borderColor: compoundBorderColor dropColor grabColor highlightForDrop: highlightForGrab: stdBorderColor unhighlight unhighlightBorder unhighlightOwner unhighlightOwnerBorder)('selection' currentSelectionDo: deselect isSelectable scaleColorByUserPref: select setDeselectedColor setSelection: wantsKeyboardFocusFor:)('insertion drop zones' removeDropZones trackDropZones)('layout' addBlockArg: addColumn:on: addMorphBack: addNoiseString: addNoiseString:emphasis: addRow:on: addSingleKeywordRow: addString:special: addTempVar: addTextRow: addToBlock:event: addToken:type:on: addTokenSpecialCase:type:on: addUnaryRow:style: foldMessage foldMessageOneArg isKnownVarName: removeReturnNode tempVarNodesDo: try unfoldMessage)('printing' getHeader: ownerPrecedence printAssignmentNodeOn:indent: printBlockArgsNodeOn:indent: printBlockNodeOn:indent: printCascadeNodeOn:indent: printMessageNodeOn:indent: printMethodNodeOn:indent: printMethodTempsNodeOn:indent: printOn: printOn:indent: printSimpleStringMorph:on: printStatementsOn:indent: printVariableNodeOn:indent: structure submorphsDoIfSyntax:ifString: submorphsDoIfSyntax:ifString:otherwise:)('pop ups' addArgs: assignmentArrow changeSound: colorChangedForSubmorph: colorPatch deleteLine deletePopup dismisser event:arrow:upDown: extend extendArrow newAssignment offerPopUp replaceSel:menuItem: retract retractArrow selectorMenu selectorMenuAsk: setSelector:in: tossOutArgs: upDown:event:arrow: upDownArithOp: upDownArrows upDownAssignment: upDownDone upDownMore:event:arrow:)('new tiles' attachTileForCode:nodeType: attachToHand instVarTile: string:toTilesIn:)('menus' accept acceptIfInScriptor acceptIgnoring: acceptSilently acceptUnlogged decompile getMenuBlock offerTilesMenuFor:in: offerVarsMenuFor:in: showCode showMenu:)('debugging' balloonText debugger debugger: hostContext update:)('tests' changed test testForNode:andDo: toDo)('type checking' allSpecs argTypeFor: currentVocabulary okToBeReplacedBy: receiverOrArgType receiverOrArgTypeAbove receiverTypeFor: resultType resultTypeFor: selector)('node to morph' addTemporaries: addTemporaryControls alanBinaryPostRcvr:key:args: alanKeywordMessage:isAConditional:key:args: alanKwdCollect:isAConditional:key:args: alanKwdIfDo:isAConditional:key:args: alanKwdRepeatForDoing:isAConditional:key:args: alanKwdSetter2:isAConditional:key:args: alanKwdSetter:isAConditional:key:args: alanUnaryGetter:key: alanUnaryPostRcvr:key:selector: alansMessageNode:receiver:selector:keywords:arguments: assignmentNode:variable:value: blockNode:arguments:statements: blockNodeCollect:arguments:statements: cascadeNode:receiver:messages: changeBasicStyle finalAppearanceTweaks isStandardGetterSelector: isStandardSetterKeyword: messageNode:receiver:selector:keywords:arguments: messageOneArg:receiver:selector:args: methodNodeInner:selectorOrFalse:precedence:arguments:temporaries:primitive:block: methodNodeOuter: vanillaMessageNode:receiver:selector:arguments:)('formatting options' alansTest1 controlContrast2: controlContrast: controlSpacing2: controlSpacing: lookClassic usingClassicTiles)('alans styles' aSimpleStringMorphWith: alansCurrentFontPreference alansTemplateStyleFor: anUpdatingStringMorphWith:special: constructSelfVariant:and: darkerColor fontToUseForSpecialWord: lighterColor noiseBeforeBlockArg noiseStringMorph: noiseWordBeforeVariableNode:string: setConditionalPartStyle setSpecialOuterTestFormat setSpecialTempDeclarationFormat1 setSpecialTempDeclarationFormat2 shouldBeBrokenIntoWords: specialColor:andBorder: splitAtCapsAndDownshifted: standardCellPositioning standardInset substituteKeywordFor: tokenVerticalSeparator translateFromWordySelfVariant: translateToWordyGetter: translateToWordySelfVariant: translateToWordySetter:)('vocabulary' limitClassToUseWith:vocabulary: vocabularyToUseWith:)!InstanceBrowser removeSelector: #tilesMenu!