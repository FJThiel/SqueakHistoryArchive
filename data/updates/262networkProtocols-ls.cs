'From Squeak 2.1 of June 30, 1998 on 15 September 1998 at 12:11:47 am'!"Change Set:		mailProtocols-lsDate:			14 September 1998Author:			Lex SpoonSeveral changes regarding networking protocols.	1. Most notably, removes and reimplements SMTPSocket in a general way.	2. Misc small changes to POPSocket	3. Socket.new initializes the network before creating the socket, and Socket.createIfFail: calls 'self new' instead of 'super new'.	4. SimpleClientSocket keeps an internal buffer.  Now getResponse and getMultilineResponse can always return an integral number of complete lines, and there is never any overflow that gets dumped on the floor.  However, one should probably not mix calls to the SimpleClientSocket methods (getResponse, sendCommand:, getMultiLineResponse) with calls to raw Socket sending and receiving commands (getData, sendData:, etc).	4. A couple of reduntant methods are removed from HTTPSocket.	5. makes 'Character nbsp' return a NUL character (ASCII 0) instead of value 160.  Value 160 is the Latin-1 non-breakable-space, but it looks funny in Squeak."SMTPSocket removeFromSystem.!Socket subclass: #SimpleClientSocket	instanceVariableNames: 'buffer bufferPos '	classVariableNames: 'CR CrLf LF '	poolDictionaries: ''	category: 'System-Network'!SimpleClientSocket subclass: #POPSocket	instanceVariableNames: 'serverName userName password progressObservers numMessages '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!SimpleClientSocket subclass: #SMTPSocket	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/14/1998 22:08'!nbsp	"non-breakable space.  It looks like a space, but it's not considered a separator"	#xxx. "the correct code for ISO 8859-1 is 160.  However, Squeak's character 160 doesn't look right.  If you value absolute correctness over looks, then change this back"	"Character value: 160"	^Character value: 0! !!SimpleClientSocket commentStamp: '<historical>' prior: 0!This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.The 'get' commands above make use of an internal buffer.  So intermixing these two commands and regular Socket recieve commands can cause problems.!!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:34'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		(chunk beginsWith: '.')			ifTrue: [ response nextPutAll: (chunk copyFrom: 2 to: chunk size) ]			ifFalse: [ response nextPutAll: chunk ].		done _ (chunk = ('.', String cr)) ].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 02:10'!getResponse	"Get a one-line response from the server.  The final LF is removed from the line, but the CR is left, so that the line is in Squeak's text format"	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:27'!getResponseShowing: showFlag	| line idx |	line _ WriteStream on: String new.	buffer ifNil: [		buffer _ String new.		bufferPos _ 0 ].	[		"look for a LF in the buffer"		idx _ buffer indexOf: Character lf startingAt: bufferPos+1 ifAbsent: [ 0 ].		idx > 0 ifTrue: [			"found it!! we have a line"			line nextPutAll: (buffer copyFrom: bufferPos+1 to: idx-1).			bufferPos _ idx.			^line contents ].				"didn't find it.  add the whole buffer to the line, and retrieve some more data"		line nextPutAll: (buffer copyFrom: bufferPos+1 to: buffer size).		bufferPos _ 0.		buffer _ String new.		self waitForDataQueryingUserEvery: 30.		buffer _ self getData.		true	] whileTrue.! !!POPSocket reorganize!('private-initialization' initialize)('initialization' addProgressObserver: password: serverName: userName:)('private' reportToObservers:)('low-level protocol' connectToPOP deleteAllMessages deleteMessage: disconnectFromPOP messagesDo: numMessages retrieveMessage:)!!POPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 19:57'!reportToObservers: aString	"send aString to all observers"	progressObservers do: [ :observer |		observer show: aString.		aString last = Character cr ifFalse: [ observer show: String cr ]].! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/14/1998 06:40'!connectToPOP	"connect to the POP server"	| address response |	Socket initializeNetwork.	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find the address for ', serverName	].	"connect the socket"	self connectTo: address port: 110.	(self waitForConnectionUntil: POPSocket standardDeadline) ifFalse: [		self close.		self reportToObservers: 'failed to connect to server'.		^false ].	"get a hello message"	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close.  ^false ].	"login"	self sendCommand: 'USER ', userName.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	self sendCommand: 'PASS ', password.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	^true! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:55'!deleteAllMessages	"delete all messages"	1 to: self numMessages do: [ :num |		self deleteMessage: num ]! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 20:00'!disconnectFromPOP	"send a QUIT message and disconnect"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:54'!messagesDo: aBlock	"perform aBlock on each message text"	| thisMessage |	1 to: self numMessages do: [ :num |		thisMessage _ self retrieveMessage: num.		aBlock value: thisMessage.	].	! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 02:02'!numMessages	"query the number of messages that are in the POP mailbox"	| response answerString |	numMessages ifNotNil: [ ^numMessages ].	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [ 		"ERROR"		^0 ].	[			answerString _ (response findTokens: Character separators) second.		numMessages _ answerString asNumber asInteger.		^numMessages	] ifError: [ :a :b |	].	"parse error"	^0! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/14/1998 10:15'!connectToSMTPServer: serverName	"connect to the given server on the SMTP port"	| addr |	addr _ NetNameResolver addressForName: serverName.	addr == nil ifTrue: [		self error: 'could not resolve host name' ].	Transcript show: 'connecting to ', serverName, '...'.	self connectTo: addr  port: 25.	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [		^false ].	self checkSMTPResponse.	self sendCommand: 'HELO aSqueakSystem'.	self checkSMTPResponse.	^true! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:38'!data: messageData	"send the data of a message"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkSMTPResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine |		cookedLine _ messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine _ '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:13'!getSMTPResponse	"wait for an SMTP response, and return the number of the response"	| line |	[ line _ self getResponse.	Transcript show: line.	(line at: 4) = $- ] whileTrue.	^(line copyFrom: 1 to: 3) asNumber! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:21'!mailFrom: fromAddress	self sendCommand: 'MAIL FROM: <', fromAddress, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:31'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	self sendCommand: 'QUIT'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:20'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 22:37'!checkSMTPResponse	"get an SMTP response, and check that it's in the 200's or 300's.  If it's not, close the socket and issue an error:"	(#(2 3) includes: self getSMTPResponse // 100) ifFalse: [		self close.		self error: 'server responded with an error' ].! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/14/1998 06:44'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ self new initialize.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 19:18'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	Socket initializeNetwork.	^ super new initialize! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 19:44'!example	"POPSocket example"	"download a user's messages into an OrderedCollection and inspect the OrderedCollection"	| ps messages |	ps _ POPSocket new.	ps serverName: (FillInTheBlank request: 'POP server').	ps userName: (FillInTheBlank request: 'POP username').	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [ :messageText |		messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !!SMTPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 22:32'!deliverMailTo: server from: fromAddress to: recipientList text: messageText	^self notYetImplemented! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:40'!example	"SMTPSocket example"	"send a message over SMTP"	self deliverMailFrom: 'lex@cc.gatech.edu' to: #(root src) text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'localhost'.! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:36'!example2	"SMTPSocket example2"	"send a message using the low-level protocol methods.  Normally one would just use the high-level class message"	| sock |	sock _ self new.	sock connectToSMTPServer: 'localhost'.	sock mailFrom: 'lex@cc.gatech.edu'.	sock recipient: 'lex@localhost'.	sock recipient: 'root'.	sock data:'From: testTo: "not listed"Subject: this is a testHi, this is a test message.'.	sock quit.	sock close.! !!SMTPSocket class methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:49'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"deliver mail to a list of users.  NOTE: the recipient list should be a collection of bare addresses--no '<>' or '()' stuff"	| sock |	Socket initializeNetwork.	sock _ self new.	(sock connectToSMTPServer: serverName)		ifFalse: [ ^false ].	sock mailFrom: fromAddress.	recipientList do: [ :recipient |		sock recipient: recipient ].	sock data: messageText.	sock quit.	sock closeAndDestroy.	^true! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements _ OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!String methodsFor: 'accessing' stamp: 'ls 9/10/1998 22:27'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start _ 1.	[ start <= self size ] whileTrue: [		end _ self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end _ end - 1.		aBlock value: (self copyFrom: start  to: end).		start _ end + 2. ].! !!String class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 22:29'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !SimpleClientSocket removeSelector: #endsWithSinglePeriodLine:!POPSocket removeSelector: #zzcloseAndDestroy:!HTTPSocket class removeSelector: #httpPost:accept:with:!HTTPSocket class removeSelector: #httpPost:with:!