'From Squeak3.1alpha of 28 February 2001 [latest update: #3868] on 20 March 2001 at 11:04:05 pm'!"Change Set:		vocabularyCorpus-swDate:			20 March 2001Author:			Scott WallaceExtends Vocabulary, and docks up both tiling systems to use it.  Viewers and Scriptors and Lexicons will now feed off of vocabularies rather than off of static tables."!ObjectWithDocumentation subclass: #MethodInterface	instanceVariableNames: 'selector argumentVariables resultSpecification receiverType elementWording attributeKeywords defaultStatus '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!!MethodInterface commentStamp: 'sw 3/20/2001 00:44' prior: 0!A MethodInterface describes the interface for a single method.  The most generic form is not bound to any particular class or object but rather describes an idealized interface.	selector					A symbol - the selector being described	argumentSpecifications	A list of specifications for the formal arguments of the method	resultSpecification 		A characterization of the return value of the method	userLevel					attributeKeywords		A list of symbols, comprising keywords that the user wishes to								associate with this method	defaultStatus			The status to apply to new instances of the class by default!ObjectWithDocumentation subclass: #ResultSpecification	instanceVariableNames: 'type companionSetterSelector refetchFrequency '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!ObjectWithDocumentation subclass: #Vocabulary	instanceVariableNames: 'vocabularyName categories methodInterfaces object limitClass '	classVariableNames: 'AllMethodInterfaces AllVocabularies '	poolDictionaries: ''	category: 'System-Protocols'!!Vocabulary commentStamp: 'sw 3/19/2001 05:29' prior: 0!VocabularyvocabularyName	a Symbol -- the formal name by which this vocabulary is known.categories			a list of MethodCategory objects: the categories that comprise the vocabularymethodInterfaces 	an IdentityDictionary; keys are method selectors, values are MethodInterfacesA Vocabulary can be either be *abstract*, i.e. associated with a *class*, or it can be *bound to an instance*.object				in the *bound* form, an actual object is associated with the vocabularylimitClass			in the *bound* form, an actual limit class is assocaited with the vocabularyAllMethodInterfaces	This class variable is available to hold on to all method interfaces						defined in the system, regardless of class.  Not deployed in 						the first version of this code to be circulated externally.AllVocabularies		A dictionary associating symbols with actual abstract vocabulary instances!!Object methodsFor: 'macpal' stamp: 'sw 3/20/2001 13:29'!isUniversalTiles	"Return true if I (my world) uses universal tiles.  This message can be called in places where the current World is not known, such as when writing out a project.  For more information about the project-writing subtlety addressed by this protocol, kindly contact Ted Kaehler."	^ Preferences universalTiles! !!Object methodsFor: 'macpal' stamp: 'sw 3/20/2001 13:24'!methodInterfacesForCategory: aCategory inViewer: aViewer	"Return a list of methodInterfaces info for use in a viewer on the receiver"	| categorySymbol |	categorySymbol _ aCategory asSymbol.	(categorySymbol == #'instance variables') ifTrue:		"user-defined instance variables"		[^ self methodInterfacesForInstanceVariablesCategoryIn: aViewer].	(categorySymbol == #scripts) ifTrue:						"user-defined scripts"		[^ self methodInterfacesForScriptsCategoryIn: aViewer].	^ (self usableMethodInterfacesIn: (aViewer currentVocabulary methodInterfacesInCategory: aCategory forInstance: self ofClass: self class))   "all others"! !!Object methodsFor: 'macpal' stamp: 'sw 3/20/2001 13:40'!slotInfo	"Answer a list of slot-information objects.  Initally only provides useful info for players"	^ Dictionary new! !!Object methodsFor: 'testing' stamp: 'sw 12/11/2000 15:43'!nameForViewer	"Answer a name to be shown in a Viewer that is viewing the receiver"	| aName |	(aName _ self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	^ [(self asString copyWithout: Character cr) truncateTo:  27] ifError:		[:msg :rcvr | ^ self class name printString]! !!Object methodsFor: 'viewer' stamp: 'sw 1/26/2001 21:41'!categoriesForViewer: aViewer	"Answer a list of categories to offer in the given viewer"	^ aViewer currentVocabulary categoryListForInstance: self ofClass: self class limitClass: ProtoObject! !!Object methodsFor: 'viewer' stamp: 'sw 1/26/2001 20:00'!offerViewerMenuFor: aViewer event: evt	"Offer the primary Viewer menu to the user.  Copied up from Player code, but most of the functions suggested here don't work for non-Player objects, many aren't even defined, some relate to exploratory sw work not yet reflected in the current corpus.  Think of this as a beginning!!"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu title: '**CAUTION -- UNDER CONSTRUCTION!!**', self nameForViewer.	(aViewer affordsUniclass and: [self belongsToUniClass not]) ifTrue:		[aMenu add: 'give me a Uniclass' action: #assureUniClass.		aMenu addLine].	aMenu add: 'choose protocol...' target: aViewer action: #chooseVocabulary.	aMenu add: 'rename me' target: aViewer selector: #chooseNewNameForReference.	self belongsToUniClass ifTrue:		[aMenu add: 'add a new instance variable' target: self selector: #addInstanceVariableIn: argument: aViewer.		aMenu add: 'add a new script' target: aViewer selector: #newPermanentScriptIn: argument: aViewer.		aMenu addLine.		aMenu add: 'make my class be first-class' target: self selector: #makeFirstClassClassIn: argument: aViewer.		aMenu add: 'move my changes up to my superclass' target: self action: #promoteChangesToSuperclass.		aMenu addLine].	aMenu add: 'toggle scratch pane' target: aViewer selector: #toggleScratchPane.	aMenu add: 'make a nascent script for me' target: aViewer selector: #makeNascentScript.	aMenu add: 'tear off a tile' target: self selector: #launchTileToRefer.	aMenu addLine.	aMenu add: 'inspect me' target: self selector: #inspect.	aMenu add: 'inspect my class' target: self class action: #inspect.	aMenu add: 'references to me' target: aViewer action: #browseReferencesToObject.	aMenu addLine.	aMenu add: 'browse full' action: #browseOwnClassFull.	aMenu add: 'browse hierarchy' action: #browseOwnClassHierarchy.	aMenu add: 'browse protocol' action: #haveFullProtocolBrowsed.	aMenu add: 'browse sub-protocol' action: #browseOwnClassSubProtocol.	aMenu addLine.	aMenu add: 'set user level...' target: aViewer action: #setUserLevel.	aMenu addLine.	aMenu add: 'inspect this Viewer' target: aViewer action: #inspect.	aMenu popUpEvent: evt in: aViewer currentWorld! !!Object methodsFor: 'viewer' stamp: 'sw 3/9/2001 21:26'!tilePhrasesForCategory: aCategory inViewer: aViewer	"Return a collection of phrases for the category"	| resultType |	^ (self methodInterfacesForCategory: aCategory inViewer: aViewer) collect:		[:aMethodInterface |			((resultType _ aMethodInterface resultType) notNil and: [resultType ~~ #unknown]) 				ifTrue:					[aViewer phraseForVariableFrom: aMethodInterface]				ifFalse:					[aViewer phraseForCommandFrom: aMethodInterface]]! !!Object methodsFor: 'viewer' stamp: 'sw 3/9/2001 13:48'!usableMethodInterfacesIn: aListOfMethodInterfaces	"Filter aList, returning a subset list of apt phrases"	^ aListOfMethodInterfaces! !!Behavior methodsFor: 'testing' stamp: 'sw 1/26/2001 20:06'!fullyImplementsVocabulary: aVocabulary	"Answer whether instances of the receiver respond to all the messages in aVocabulary"	(aVocabulary encompassesAPriori: self) ifTrue: [^ true].	aVocabulary allSelectorsInVocabulary do:		[:aSelector | (self canUnderstand: aSelector) ifFalse: [^ false]].	^ true! !!Behavior methodsFor: 'testing' stamp: 'sw 1/26/2001 20:05'!implementsVocabulary: aVocabulary	"Answer whether instances of the receiver respond to the messages in aVocabulary.  Formerly, one had required that every message of the protocol be implemented, a check now devolved to #fullyImplementsVocabulary, but with present thinking, we allow any object to be thought of as capable of partially implementing any protocol"	^ true! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'sw 12/1/2000 20:11'!allSelectorsUnderstood	"Answer a list of all selectors understood by instances of the receiver"	| aList |	aList _ OrderedCollection new.	self withAllSuperclasses do:		[:aClass | aList addAll: aClass selectors].	^ aList asSet asArray"SketchMorph allSelectorsUnderstood size"! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 3/19/2001 06:31'!"popeye" formalHeaderPartsFor: "olive oil" aSelector	"Return a collection giving the parts in the formal declaration for aSelector.  This parse is in support of schemes in which adjutant properties of a method can be declared via special comments secreted in the formal header" "	The result will have     	3 elements for a simple, argumentless selector.		5 elements for a single-argument selector		9 elements for a two-argument selector		13 elements for a three-argument, selector		etc...	The syntactic elements are:		1		comment preceding initial selector fragment		2		first selector fragment		3		comment following first selector fragment        ----------------------  (ends here for, e.g., #copy)		4		first formal argument		5		comment following first formal argument        ----------------------  (ends here for, e.g., #copyFrom:)		6		second keyword		7		comment following second keyword		8		second formal argument		9		comment follwing second formal argument         ----------------------  (ends here for, e.g., #copyFrom:to:)	Any nil element signifies an absent comment."	^ Scanner new scanMessageParts: (self methodHeaderFor: aSelector)"	Behavior class formalHeaderPartsFor: #formalHeaderPartsFor:"	! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sw 1/5/2001 06:53'!allMethodCategoriesIntegratedThrough: mostGenericClass	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"	| aColl |	aColl _ OrderedCollection new.	self withAllSuperclasses do:		[:aClass |			(aClass includesBehavior: mostGenericClass)				ifTrue:	[aColl addAll: aClass organization categories]].	aColl remove: 'no messages' asSymbol ifAbsent: [].	^ (aColl asSet asSortedCollection: [:a :b | a asLowercase < b asLowercase]) asArray"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sw 12/12/2000 12:26'!allMethodsInCategory: aName	"Answer a list of all the method categories of the receiver and all its superclasses"	| aColl |	aColl _ OrderedCollection new.	self withAllSuperclasses do:		[:aClass | aColl addAll:			(aName = ClassOrganizer allCategory				ifTrue:					[aClass organization allMethodSelectors]				ifFalse:					[aClass organization listAtCategoryNamed: aName])].	^ aColl asSet asSortedArray"TileMorph allMethodsInCategory: #initialization"! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sw 3/20/2001 13:26'!namedTileScriptSelectors	"Answer a list of all the selectors of named tile scripts.  Initially, only Player reimplements, but if we switch to a scheme in which every class can have uniclass subclasses, this would kick in elsewhere"	^ OrderedCollection new! !!Class methodsFor: 'class name' stamp: 'sw 12/1/2000 20:39'!externalName	"Answer a name by which the receiver can be known."	^ name! !!Class methodsFor: 'class name' stamp: 'sw 12/18/2000 15:50'!nameForViewer	"Answer the name to be shown in the header of a viewer looking at the receiver"	^ self name ifNil: ['Unnamed class']! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 3/9/2001 16:27'!wording: aWording selector: aSelector type: aType setter: aSetter	"Set the receiver's fields as indicated"	selector _ aSelector.	elementWording _ aWording.	aType ifNotNil:		[resultSpecification _ ResultSpecification new.		resultSpecification resultType: aType.		aSetter ifNotNil: [resultSpecification companionSetterSelector: aSetter]]! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/10/2001 00:38'!argumentVariables	"Answer the list of argumentVariables of the interface"	^ argumentVariables ifNil: [argumentVariables _ OrderedCollection new]! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/12/2001 13:43'!conjuredUpFor: aSelector class: aClass	"Initialize the receiver to have the given selector, obtaining whatever info one can from aClass.  This basically covers the situation where no formal definition has been made."	| parts |	self initializeFor: aSelector.	receiverType _ #unknown.	parts _ aClass formalHeaderPartsFor: aSelector.	argumentVariables _ (1 to: selector numArgs) collect:		[:anIndex | Variable new name: (parts at: (4 * anIndex)) type: #object].	parts last isEmptyOrNil ifFalse: [self documentation: parts last].! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/9/2001 17:00'!initialize	"Initialize the receiver"	super initialize.	attributeKeywords _ OrderedCollection new.	defaultStatus _ #normal.	argumentVariables _ OrderedCollection new! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 2/24/2001 00:34'!initializeFor: aSelector	"Initialize the receiver to have the given selector"	selector _ aSelector.	attributeKeywords _ OrderedCollection new.	defaultStatus _ #normal! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/10/2001 00:37'!initializeFromEToyCommandSpec: tuple category: aCategorySymbol	"tuple holds an old etoy command-item spec, of the form found in #additionsToViewerCategories methods.   Initialize the receiver to hold the same information"	selector _ tuple second.	self documentation: tuple third.	receiverType _ #player.	selector numArgs == 1 ifTrue:		[argumentVariables _ OrderedCollection with:			(Variable new name: (Player formalHeaderPartsFor: selector) fourth type: tuple fourth)].	aCategorySymbol ifNotNil: [self flagAttribute: aCategorySymbol]! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/9/2001 17:46'!initializeFromEToySlotSpec: tuple	"tuple holds an old etoy slot-item spec, of the form found in #additionsToViewerCategories methods.   Initialize the receiver to hold the same information"	| setter |	selector _ tuple seventh.	elementWording _ tuple second.	self documentation: tuple third.	receiverType _ #player.	resultSpecification _ ResultSpecification new.	resultSpecification resultType: tuple fourth.	((tuple fifth == #readWrite) and: [((tuple size >= 9) and: [(setter _ tuple at: 9) ~~ #unused])]) ifTrue:		[resultSpecification companionSetterSelector: setter].		"slot amount 'The amount of displacement' number readOnly player getAmount unused unused"	! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 3/7/2001 13:05'!receiverType: aType	"set the receiver type.  Whether the receiverType earns its keep here is not yet well understood.  At the moment, this is unsent"	receiverType _ aType! !!MethodInterface methodsFor: 'access' stamp: 'sw 3/8/2001 16:29'!companionSetterSelector	"If there is a companion setter selector, anwer it, else answer nil"	^ resultSpecification ifNotNil:		[resultSpecification companionSetterSelector]! !!MethodInterface methodsFor: 'access' stamp: 'sw 2/13/2001 13:47'!elementWording	"Answer the wording to be shown on friendly tiles representing the receiver; by default, it is just the same as the method selector itself, but anything special-cased via #wordingForOperator:, and all getters/setters of slots, are transformed into somethingfriendlier here"	^ elementWording ifNil:		[elementWording _ "grandfathered case is problematical here"		((selector beginsWith: 'get') and: [selector size > 3])			ifTrue:				[(selector copyFrom: 4 to: selector size) withFirstCharacterDownshifted]			ifFalse:				[((selector beginsWith: 'set') and: [selector size > 4])					ifTrue:						[(selector copyFrom: 4 to: selector size - 1) withFirstCharacterDownshifted]					ifFalse:						[ScriptingSystem wordingForOperator: selector]]]! !!MethodInterface methodsFor: 'access' stamp: 'sw 3/10/2001 00:33'!printOn: aStream	"print the receiver on a stream.  Overridden to provide details about wording, selector, result type, and companion setter."	super printOn: aStream.	aStream nextPutAll: ' - wording: ''', self elementWording asString, ''' selector: #', selector asString.	self argumentVariables size > 0 ifTrue:		[aStream nextPutAll: 'Arguments: '.		argumentVariables doWithIndex:			[:aVariable :anIndex | 				aStream nextPutAll: 'argument #', anIndex printString, ' name = ', aVariable variableName, ', type = ', aVariable variableType]].	resultSpecification ifNotNil:		[aStream nextPutAll: ' result type = ', resultSpecification resultType asString.		resultSpecification companionSetterSelector ifNotNil:			[aStream nextPutAll: ' setter = ', resultSpecification companionSetterSelector asString]]	! !!MethodInterface methodsFor: 'access' stamp: 'sw 2/24/2001 12:04'!receiverType	"Answer the receiver type"	^ receiverType ifNil: [receiverType _ #unknown]! !!MethodInterface methodsFor: 'access' stamp: 'sw 3/10/2001 00:38'!resultType	"Answer the result type"	^ resultSpecification		ifNotNil:			[resultSpecification type]		ifNil:			[#unknown]! !!MethodInterface methodsFor: 'access' stamp: 'sw 3/9/2001 17:02'!typeForArgumentNumber: anArgumentNumber	"Answer the data type for the given argument number"	| aVariable |	aVariable _ self argumentVariables at: anArgumentNumber.	^ aVariable variableType! !!Morph methodsFor: 'scripting' stamp: 'sw 12/14/2000 10:02'!selectorsForViewer	"Answer a list of symbols representing all the selectors available in all my viewer categories"	| aClass aList itsAdditions |	aClass _ self renderedMorph class.	aList _ OrderedCollection new.	[aClass == Morph superclass] whileFalse:		[(aClass class includesSelector: #additionsToViewerCategories) ifTrue:			[itsAdditions _ aClass additionsToViewerCategories.			itsAdditions do:				[:anAddition | anAddition second "the spec list" do:					[:aSpec |						 aSpec first == #command ifTrue: [aList add: aSpec second].						aSpec first == #slot ifTrue:							[aList add: (aSpec at: 7).							aList add: (aSpec at: 9)]]]].		aClass _ aClass superclass]. 	^ aList asSet copyWithoutAll: #(unused dummy)"SimpleSliderMorph basicNew selectorsForViewer"! !!Morph methodsFor: 'scripting' stamp: 'sw 3/19/2001 14:11'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	"Answer a readout tile representing the given part's value, given the putter, getter, and type information"	| aColor aTile displayer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:			[NumericReadoutTile new typeColor: aColor]		ifFalse:				[typeSymbol == #sound				ifTrue:					[SoundReadoutTile new typeColor: aColor]				ifFalse:					[typeSymbol == #buttonPhase						ifTrue:							[SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol]						ifFalse:							[StringReadoutTile new typeColor: aColor]]]. 	displayer _ UpdatingStringMorph new		getSelector: getSelector;		target: self player;		growable: true;		minimumWidth: 24;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	(typeSymbol == #number)		ifTrue:			 [((#(cursor  "etc...") includes: partName) and: [self isKindOf: GraphMorph])				ifTrue:					[displayer floatPrecision: 0.1]				ifFalse:					[(self player slotInfo includesKey: partName)  "i.e., a user-defined numeric slot"						ifTrue:							[displayer floatPrecision: (self player slotInfoAt: partName) floatPrecision]]].	typeSymbol == #string		ifTrue:			[displayer useStringFormat.			displayer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[displayer useStringFormat]				ifFalse:	[displayer useDefaultFormat]].	aTile addMorphBack: displayer.	((putSelector ~~ #unused) and: [#(number sound boolean buttonPhase) includes: typeSymbol])  ifTrue: [aTile addArrows].	getSelector numArgs == 0 ifTrue:		[aTile setLiteralInitially: (self scriptPerformer perform: getSelector)].	^ aTile! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 3/10/2001 00:39'!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	resultType _ opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((TileMorph new setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#object]))]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/9/2001 16:58'!methodInterfacesForCategory: aCategory inViewer: aViewer	"Return a list of methodInterfaces nfo for use in a viewer on the receiver.  These can be of two flavors - command and slot."	| categorySymbol |	categorySymbol _ aCategory asSymbol.	(categorySymbol == #'instance variables') ifTrue:		"user-defined instance variables"		[^ self methodInterfacesForInstanceVariablesCategoryIn: aViewer].	(categorySymbol == #scripts) ifTrue:						"user-defined scripts"		[^ self methodInterfacesForScriptsCategoryIn: aViewer].	^ (self usableMethodInterfacesIn: (aViewer currentVocabulary methodInterfacesInCategory: aCategory forInstance: self ofClass: self class))   "all others"! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/9/2001 16:30'!methodInterfacesForInstanceVariablesCategoryIn: aViewer	"Return a collection of methodInterfaces for the instance-variables category"	| aList anInterface itsSlotName |	aList _ OrderedCollection new.	self slotInfo associationsDo:		[:assoc |			anInterface _ MethodInterface new.			itsSlotName _ assoc key.			anInterface wording: itsSlotName selector: (Utilities getterSelectorFor: itsSlotName) type: assoc value type setter: (Utilities getterSelectorFor: itsSlotName).			aList add: anInterface].	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/10/2001 00:48'!methodInterfacesForScriptsCategoryIn: aViewer	"Answer a list of method interfaces for the category #scripts in a Viewer"	^ self class scripts values! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/10/2001 01:32'!tileForArgType: typeSymbol inViewer: aViewer	"Answer a tile to represent a value of the given type in the given viewer"	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ self tileForPlayer: aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #point ifTrue: [^ TileMorph new setLiteral: 0@0; typeColor: aColor].	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	typeSymbol == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol].	typeSymbol == #text ifTrue: [^ ("(TextMorph new contents: 'setup')" 'aborning' newTileMorphRepresentative) typeColor:  aColor].	self error: 'Unrecognized type'! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/9/2001 13:47'!usableMethodInterfacesIn: methodInterfaceList	"Filter the list given by methodInterfaceList, to remove items inappropriate to the receiver"	self hasCostumeThatIsAWorld ifTrue:		[^ methodInterfaceList select: [:anInterface |			#(beep doMenuItem color startScript: stopScript: pauseScript: liftAllPens lowerAllPens clearTurtleTrails initiatePainting cursor valueAtCursor mouseX mouseY roundUpStrays unhideHiddenObjects) includes: anInterface selector]].	self hasAnyBorderedCostumes ifTrue: [^ methodInterfaceList].	^ self hasOnlySketchCostumes		ifTrue:			[methodInterfaceList select: [:anInterface | (#(color borderColor borderWidth) includes: anInterface selector) not]]		ifFalse:			[methodInterfaceList select: [:anInterface | (#(borderColor borderWidth) includes: anInterface selector) not]]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 3/10/2001 01:31'!tileForPlayer: aPlayer	"Return a tile representing aPlayer"	^ TileMorph new		setObjectRef: nil "disused parm" actualObject: aPlayer;		typeColor: (ScriptingSystem colorForType: #player)! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 3/9/2001 14:09'!universalTilesForGetterOf: aMethodInterface	"Return universal tiles for a getter on the given method interface.  Record who self is."	| ms argTile argArray itsSelector itsWording |	itsSelector _ aMethodInterface selector.	argArray _ #().	(itsWording _ aMethodInterface elementWording) == #colorSees ifTrue:		[itsSelector _ #color:sees:.		argTile _ self tileForArgType: #color inViewer: nil.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy].	itsWording == #isOverColor ifTrue:		[itsSelector _ #seesColor:.		argTile _ self tileForArgType: #color inViewer: nil.		argArray _  Array with: argTile colorSwatch color].	itsWording == #touchesA ifTrue:		[itsSelector _ #touchesA:.		argTile _ self tileForArgType: #player inViewer: nil.		argArray _ Array with: argTile actualObject].	ms _ MessageSend receiver: self selector: itsSelector arguments: argArray.	^ ms asTilesIn: self class! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 3/19/2001 13:57'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList |	itsSelector _ aMethodInterface selector.	argList _ OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile _ self tileForArgType: (aType _ aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms _ MessageSend receiver: self selector: itsSelector arguments: argList asArray.	^ ms asTilesIn: self class! !!Player methodsFor: 'misc' stamp: 'sw 3/10/2001 01:13'!categoriesForViewer: aViewer	"Answer a list of category symbols to offer as alternatives in the viewer"	^  aViewer currentVocabulary categoryListForInstance: self ofClass: self class limitClass: ProtoObject! !!Player methodsFor: 'misc' stamp: 'sw 3/12/2001 13:46'!offerViewerMenuFor: aViewer event: evt	"Put up the Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld _ aViewer world.	aMenu _ MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes]].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	aMenu add: 'add a new script' target: aViewer action: #newPermanentScript.	aMenu addLine.	aMenu add: 'expunge empty scripts' target: self action: #expungeEmptyScripts.	aMenu add: 'browse etoy vocabulary' target: self action: #browseEToyVocabulary.	Preferences universalTiles ifTrue:		[aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary].	"aMenu add: 'searching protocol browser' target: self action: #openSearchingProtocolBrowser."	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect].	aMenu popUpEvent: evt in: aWorld! !!Player class methodsFor: 'other' stamp: 'sw 1/6/2001 06:27'!nameForViewer	"Answer the name by which the receiver is to be referred in a viewer"	^ self isUniClass		ifTrue:			[self someInstance getName]		ifFalse:			[super nameForViewer]! !!Player class methodsFor: 'housekeeping' stamp: 'sw 12/18/2000 15:45'!isUniClass	"UnscriptedPlayer reimplements to false"	^ self ~~ Player! !!ResultSpecification methodsFor: 'companion setter' stamp: 'sw 2/27/2001 09:15'!companionSetterSelector	"Answer the companion setter, nil if none"	^ companionSetterSelector! !!ResultSpecification methodsFor: 'result type' stamp: 'sw 2/27/2001 09:14'!resultType	"Answer the reciever's result type"	^ type! !!ResultSpecification methodsFor: 'result type' stamp: 'sw 2/24/2001 12:11'!resultType: aType	"Set the receiver's resultType as specified"	type _ aType! !!ResultSpecification methodsFor: 'result type' stamp: 'sw 2/24/2001 12:12'!type	"Answer the reciever's type"	^ type! !!Scanner methodsFor: 'public access' stamp: 'sw 1/28/2001 23:31'!scanMessageParts: sourceString	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"	| coll nonKeywords |	coll _ OrderedCollection new.	self scan: (ReadStream on: sourceString asString).	nonKeywords _ 0.	[tokenType = #doIt] whileFalse:		[(currentComment == nil or: [currentComment isEmpty])			ifTrue: [coll addLast: nil]			ifFalse: [coll addLast: currentComment removeFirst.				[currentComment isEmpty] whileFalse:					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].		(token numArgs < 1 or: [(token = #|) & (coll size > 1)])			ifTrue: [(nonKeywords _ nonKeywords + 1) > 1 ifTrue: [^ coll]]						"done with header"			ifFalse: [nonKeywords _ 0].		coll addLast: token.		self scanToken].	(currentComment == nil or: [currentComment isEmpty])		ifTrue: [coll addLast: nil]		ifFalse: [coll addLast: currentComment removeFirst.			[currentComment isEmpty] whileFalse: [				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].	^ coll! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 3/20/2001 15:46'!wantsDroppedMorph: aMorph event: evt	"Answer whether the receiver would be interested in accepting the morph"	^ (aMorph isTileLike and: [self isTextuallyCoded not]) and:		[(aMorph resultType == #command or: [aMorph resultType == #unknown])]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'sw 2/3/2001 01:40'!editor	"In parallel with the interface for text morphs, we respond to this, but in our case we are our own editor"	^ self! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/23/2001 23:40'!argTypeFor: aSelector	"Answer the type of the argument of this selector.  Return #unknown if not found."	| itsInterface |	aSelector numArgs = 0 		ifTrue: [self inform: aSelector, ' does not take an argument'. ^ #error "7"].	itsInterface _ self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface typeForArgumentNumber: 1! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 3/12/2001 12:41'!currentVocabulary	"Answer the current vocabulary associated with the receiver.  Potentially, each Scriptor, or each Project, or whatever, might have its own, but for the moment we simply share the global etoy vocabulary"	^ Vocabulary eToyVocabulary! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/27/2001 09:11'!receiverTypeFor: aSelector	"Answer the type of the receiver of this selector.  Return #unknown if not found."	| itsInterface |	aSelector ifNil: [^ #unknown].	itsInterface _ self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface receiverType! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/24/2001 12:13'!resultTypeFor: aSelector	"Answer the result type of selector.  Return #unknown if not found."	| itsInterface |	aSelector ifNil: [self inform: 'Please tell Ted how you caused this'.		^ #abs "a bogus type"].	itsInterface _ self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface resultType! !!TilePadMorph methodsFor: 'mouse' stamp: 'sw 3/20/2001 15:46'!canAccept: aMorph	"Answer whether this pad can accept the given morph"	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isKindOf: TileMorph]) 		ifTrue:			[^ (aMorph resultType == type) or:				[(aMorph resultType == #unknown) and: [type == #player]]].	^ false! !!Variable methodsFor: 'name' stamp: 'sw 3/12/2001 12:40'!name: aName type: aType	"Set the variable's name and type as indicated"	variableName _ aName.	variableType _ aType! !!Variable methodsFor: 'name' stamp: 'sw 3/10/2001 00:29'!printOn: aStream	"Print the receiver on the stream"	super printOn: aStream.	aStream nextPutAll: ' named ', (self variableName ifNil: ['<unnamed>'])! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 1/26/2001 20:08'!chooseVocabulary	"Put up a menu allowing the user to specify which protocol to use in this viewer"	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose a vocabulary'.	Vocabulary allVocabularies do:		[:aVocabulary |			(scriptedPlayer class implementsVocabulary: aVocabulary)				ifTrue:					[aMenu add: aVocabulary vocabularyName selector: #switchToVocabulary: argument: aVocabulary.					aMenu balloonTextForLastItem: aVocabulary documentation]].	aMenu popUpInWorld: self currentWorld! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 3/14/2001 09:51'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-typed command represented by aMethodInterface."	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal |	names _ scriptedPlayer class namedTileScriptSelectors.	resultType _ aMethodInterface resultType.	cmd _ aMethodInterface selector.	(universal _ scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase _ scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType _ aMethodInterface typeForArgumentNumber: 1.				aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ scriptedPlayer tileForArgType: argType inViewer: self.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector _ #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString _ (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentationOrNil.			aDocString ifNotNil:					[aPhrase submorphs second setBalloonText: aDocString]				ifNil:					[balloonTextSelector _ #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script'].	universal ifFalse:		[selfTile _ self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow _ ViewerRow newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		aPhrase beTransparent.		aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.		aRow addMorphBack: (stat _ (inst _ scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).		inst updateStatusMorph: stat].	aRow beSticky; disableDragNDrop.	^ aRow! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 3/20/2001 23:00'!phraseForVariableFrom: aMethodInterface	"Return a structure consisting of tiles and controls and a readout representing a 'variable' belonging to the player, complete with an appropriate readout when indicated.  Functions in both universalTiles mode and classic mode.  Slightly misnamed in that this path is used for any methodInterface that indicates an interesting resultType."	| anArrow slotName getterButton cover inner aRow doc setter tryer universal |	aRow _ ViewerRow newRow		color: self color;		beSticky;		elementSymbol: (slotName _ aMethodInterface elementWording);		wrapCentering: #center;		cellPositioning: #leftCenter.	(universal _ scriptedPlayer isUniversalTiles) ifFalse:		[aRow addMorphBack: (Morph new color: self color;		extent: 11 @ 22; yourself)].  "spacer"	aRow addMorphBack: (self infoButtonFor: slotName).	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	universal ifTrue:			[inner _ scriptedPlayer universalTilesForGetterOf: aMethodInterface.			cover _ Morph new color: Color transparent.			cover extent: inner fullBounds extent.			(getterButton _ cover copy) addMorph: cover; addMorphBack: inner.			cover on: #mouseDown send: #newMakeGetter:from:forMethodInterface:					to: self withValue: aMethodInterface.			aRow addMorphFront:  (tryer _ ScriptingSystem tryButtonFor: inner).			tryer color: tryer color lighter lighter]		ifFalse:			[aRow addMorphBack: self tileForSelf bePossessive.			aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"			getterButton _ self getterButtonFor: aMethodInterface elementWording type: aMethodInterface resultType].	aRow addMorphBack: getterButton.	(doc _ aMethodInterface documentationOrNil) ifNotNil:		[getterButton setBalloonText: doc].	universal ifFalse:		[(slotName == #isOverColor) ifTrue:			[self addIsOverColorDetailTo: aRow.			^ aRow].		(slotName == #touchesA) ifTrue:			[self addTouchesADetailTo: aRow.			^ aRow]].	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	(setter _ aMethodInterface companionSetterSelector) ifNotNil:		[aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		anArrow _ universal 			ifTrue: [self arrowSetterButton: #newMakeSetterFromInterface:evt:from:  						args: aMethodInterface]			ifFalse: [self arrowSetterButton: #makeSetter:from:forPart:						args: (Array with: slotName with: aMethodInterface resultType)].		aRow addMorphBack: anArrow].	(#(colorSees playerSeeingColor copy touchesA) includes: slotName) ifFalse: 		[(universal and: [slotName == #isOverColor]) ifFalse:			[aRow addMorphBack: (self readoutFor: slotName type: aMethodInterface resultType readOnly: setter isNil getSelector: aMethodInterface selector putSelector: setter)]].	anArrow ifNotNil: [anArrow step].	^ aRow! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 3/10/2001 02:16'!newGetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a getter on this property.  Record who self is."	| ms argTile argArray |	ms _ MessageSend receiver: aPlayer selector: aMethodInterface selector arguments: #().	aMethodInterface selector == #colorSees ifTrue: [		ms selector: #color:sees:.		argTile _ aPlayer tileForArgType: #color inViewer: nil.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy. 		ms arguments: argArray].	aMethodInterface selector == #isOverColor ifTrue: [		ms selector: #seesColor:.		argTile _ aPlayer tileForArgType: #color inViewer: nil.		ms arguments: (Array with: argTile colorSwatch color)].	aMethodInterface selector == #touchesA ifTrue: [		ms selector: #touchesA:.		argTile _ aPlayer tileForArgType: #player inViewer: nil.		ms arguments: (Array with: argTile actualObject)].	^ ms asTilesIn: aPlayer class! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 3/10/2001 02:18'!newMakeGetter: evt from: aMorph forMethodInterface: aMethodInterface	"Button in viewer performs this to make a new style tile and attach to hand."	| newTiles |	newTiles _ self newGetterTilesFor: scriptedPlayer methodInterface: aMethodInterface.	owner ifNotNil: [self primaryHand attachMorph: newTiles.			newTiles align: newTiles topLeft with: evt hand position + (7@14)]		ifNil: [^ newTiles]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 3/20/2001 22:58'!newMakeSetterFromInterface: aMethodInterface evt: evt from: aMorph 	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m _ self newSetterTilesFor: scriptedPlayer methodInterface: aMethodInterface.	owner		ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 3/9/2001 23:34'!newSetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a setter on this property.  Record who self is."	| ms  argValue |	argValue _ aPlayer perform: aMethodInterface selector.	ms _ MessageSend receiver: aPlayer selector: aMethodInterface companionSetterSelector arguments: (Array with: argValue).	^ ms asTilesIn: aPlayer class! !!CategoryViewer methodsFor: 'support' stamp: 'sw 1/26/2001 19:35'!currentVocabulary	"Answer the  vocabulary  currently installed in the viewer.  The outer StandardViewer object holds this information."	^ self outerViewer currentVocabulary! !!StandardViewer methodsFor: 'categories' stamp: 'sw 12/11/2000 14:34'!addCategoryViewerFor: aStartingCategory	"Add a category viewer for the given category"	| aViewer |	self addMorphBack: (aViewer _ CategoryViewer new).	aViewer initializeFor: scriptedPlayer categoryChoice: aStartingCategory.	self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer]! !!StandardViewer methodsFor: 'categories' stamp: 'sw 1/26/2001 19:36'!currentVocabulary	"Answer the vocabulary currently associated with the receiver"	^ self valueOfProperty: #currentVocabulary ifAbsent:		[(scriptedPlayer isKindOf: Player)			ifTrue:				[Vocabulary eToyVocabulary]			ifFalse:				[Vocabulary fullVocabulary]]! !!StandardViewer methodsFor: 'categories' stamp: 'sw 12/11/2000 10:51'!outerViewer	"Answer the StandardViewer or equivalent that contains this object"	^ self! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 3/7/2001 21:43'!switchToVocabulary: aVocabulary	"Make the receiver show categories and methods as dictated by aVocabulary.  If this constitutes a switch, then wipe out existing category viewers that will be showing the wrong thing."	((self valueOfProperty: #currentVocabulary ifAbsent: [nil]) == aVocabulary) ifFalse:		[self setProperty: #currentVocabulary toValue: aVocabulary.		(self submorphs select: [:m | m isKindOf: CategoryViewer]) do: [:m | m delete]]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 2/24/2001 01:02'!allMethodsInCategory: categoryName 	"Answer a list of methods in the category of the given name"	^ self allMethodsInCategory: categoryName forInstance: object ofClass: object class! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/12/2001 12:35'!atKey: aKey putMethodInterface: anInterface	"Place the given interface at the given key.  Also save it in the cumulative repository held in my class variable AllMethodInterfaces, for potential sharing."	methodInterfaces at: aKey put: anInterface.	self class storeInterface: anInterface forSelector: aKey! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/8/2001 11:47'!categoryList	"Answer the category list considering only code implemented in my limitClass and lower.  This variant is used when the limitClass and targetObjct are known"	| classToUse foundAMethod classThatImplements |	classToUse _ object class.	^ categories		select:			[:aCategory |				foundAMethod _ false.				aCategory elementsInOrder do:					[:aSpec |						classThatImplements _  classToUse classThatUnderstands: aSpec selector.						(classThatImplements notNil and: [classThatImplements includesBehavior: limitClass])							ifTrue:								[foundAMethod _ true]].				foundAMethod]		thenCollect:			[:aCategory | aCategory categoryName]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/20/2001 00:11'!categoryWithNameIn: categoryNames thatIncludesSelector: aSelector forInstance: targetInstance ofClass: targetClass	"Answer the name of a category, from among the provided categoryNames, which defines the selector for the given class.  Note reimplementor"	| itsName |	self categories do:		[:aCategory | ((categoryNames includes: (itsName _ aCategory categoryName)) and:  [aCategory includesKey: aSelector])			ifTrue:				[^ itsName]].	^ nil! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/20/2001 15:42'!includesDefinitionForSelector: aSelector	"Answer whether the given selector is known to the vocabulary.  This is independent of whether its definition lies within the range specified by my limitClass.  Answer whether the given selector is known to the vocabulary.  Unsent at the moment, may disappear."	^ methodInterfaces includesKey: aSelector! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/19/2001 23:56'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given class (and instance, if provided), only considering method implementations in mostGenericClass and lower"	| classToUse aClass |	(methodInterfaces includesKey: aSelector) ifFalse: [^ false].	classToUse _ self classToUseFromInstance: anInstance ofClass: aTargetClass.	^ (aClass _ classToUse whichClassIncludesSelector: aSelector)		ifNil:			[false]		ifNotNil:			[(aClass includesBehavior: mostGenericClass) and:				[(self someCategoryThatIncludes: aSelector) notNil]]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 2/23/2001 23:30'!methodInterfaceAt: aSelector ifAbsent: aBlock	"Answer the vocabulary's method interface for the given selector; if absent, return the result of evaluating aBlock"	^ methodInterfaces at: aSelector ifAbsent: [aBlock value]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/19/2001 12:08'!methodInterfacesInCategory: categoryName forInstance: anObject ofClass: aClass	"Answer a list of method interfaces of all methods in the given category.  Somewhat vexingly, this conjures up a method interface for every selector that needs one but lacks one."	^ (self allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass) collect:		[:aSelector | methodInterfaces at: aSelector ifAbsent:			[MethodInterface new conjuredUpFor: aSelector class: aClass]]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 3/19/2001 23:55'!someCategoryThatIncludes: aSelector	"Answer the name of a category that includes the selector, nil if none"	^ categories detect: [:c | c includesKey: aSelector] ifNone: [nil]! !!Vocabulary methodsFor: 'initialization' stamp: 'sw 2/21/2001 15:39'!initializeFor: anObject	"Initialize the receiver to bear a vocabulary suitable for anObject"	object _ anObject.	vocabularyName _ #unnamed.	categories _ OrderedCollection new.	methodInterfaces _ IdentityDictionary new.	self documentation: 'A vocabulary that has not yet been documented'.! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 3/12/2001 12:32'!addGetterAndSetterInterfacesFromOldSlotSpec: aCommandSpec	"Create, given an old etoy-style command spec, appropriate MethodInterfaces, and store those interfaces in my method-interface dictionary"	| aMethodInterface aSelector |	aMethodInterface _ MethodInterface new initializeFromEToySlotSpec: aCommandSpec.	self atKey: aCommandSpec seventh putMethodInterface: aMethodInterface.	(aCommandSpec size >= 9 and: [(#(unused missing) includes: aCommandSpec ninth) not])		ifTrue:			[aMethodInterface _ MethodInterface new initializeFor: (aSelector _ aCommandSpec ninth).			self atKey: aSelector putMethodInterface: aMethodInterface]"	1	#slot  -- indicates that is a slot specification rather than a method specification	2	slot name	3	help message	4	type	5	#readOnly or #readWrite (if #readWrite, items 8 and 9 should be present & meaningful)	6	<future use -- target for getter -- currently always set to #player>	7	getter selector	8	<future use -- target for setter -- currently always set to #player>	9	setter selector"! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 3/10/2001 00:11'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	|   classes aMethodCategory selector selectors categorySymbols |	super initialize.	self vocabularyName: #eToy.	self documentation: '"EToy" is a vocabulary that provides the equivalent of the 1997-2000 etoy prototype'.	categorySymbols _ Set new.	classes _ self morphClassesDeclaringViewerAdditions.	classes do:		[:aMorphClass | categorySymbols addAll: aMorphClass basicNew categoriesForViewer].	categorySymbols asOrderedCollection do:		[:aCategorySymbol |			aMethodCategory _ ElementCategory new categoryName: aCategorySymbol.			selectors _ Set new.			classes do:				[:aMorphClass |					 (aMorphClass additionsToViewerCategory: aCategorySymbol) do:						[:anElement |							anElement first == #command								ifTrue:									[selectors add: (selector _ anElement second).									(methodInterfaces includesKey: selector) ifFalse:										[methodInterfaces at: selector put: (MethodInterface new initializeFromEToyCommandSpec:  anElement category: aCategorySymbol)]]								ifFalse:  "#slot format"									[selectors add: (selector _ anElement seventh).  "the getter"									(methodInterfaces includesKey: selector) ifFalse:										[self addGetterAndSetterInterfacesFromOldSlotSpec: anElement]]]].			(selectors copyWithout: #unused) asSortedArray do:				[:aSelector |					aMethodCategory elementAt: aSelector put: (methodInterfaces at: aSelector)].				 			self addCategory: aMethodCategory].	#(scripts 'instance variables') do: [:sym | self addCategoryNamed: sym].	self setCategoryDocumentationStrings! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 3/9/2001 17:28'!morphClassesDeclaringViewerAdditions	"Answer a list of actual morph classes implementing #additionsToViewerCategories"	| markers survivors |	markers _ Smalltalk allImplementorsOf: #additionsToViewerCategories.	survivors _ OrderedCollection new.	markers do:		[:aMarker |			MessageSet parse: aMarker toClassAndSelector:				[:cl :sel |					(cl soleInstance isKindOf: Morph class) ifTrue:						[survivors add: cl soleInstance]]].	^ survivors"EToyVocabulary basicNew morphClassesDeclaringViewerAdditions"! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 3/20/2001 00:11'!categoryWithNameIn: categoryNames thatIncludesSelector: aSelector forInstance: targetInstance ofClass: targetClass	"Answer the name of a category, from among the provided categoryNames, which defines the selector for the given class.  Here, if the category designated by the implementing class is acceptable it is the one returned"	| aClass catName |	 (aClass _ targetClass classThatUnderstands: aSelector) 		ifNotNil:			[(categoryNames includes: (catName _ aClass whichCategoryIncludesSelector: aSelector))					ifTrue:						[(catName ~~ #'as yet unclassified')							ifTrue: [^ catName]]].	^ super categoryWithNameIn: categoryNames thatIncludesSelector: aSelector forInstance: targetInstance ofClass: aClass! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 3/20/2001 15:42'!includesDefinitionForSelector: aSelector	"Answer whether the given selector is known to the vocabulary.  Unsent at the moment, may disappear."	^ true! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 3/20/2001 22:21'!initializeStandardVocabularies	"Initialize a few standard vocabularies and place them in the AllVocabularies list."	AllVocabularies _ OrderedCollection new.	AllMethodInterfaces _ IdentityDictionary new.	self addVocabulary: EToyVocabulary new.	self addVocabulary: self newTestVocabulary.	self addVocabulary: self newPublicVocabulary.	self addVocabulary: FullVocabulary new.	"self addVocabulary: self newNumberVocabulary."	"Vocabulary initialize"! !!Vocabulary class methodsFor: 'method interfaces' stamp: 'sw 3/14/2001 09:53'!resetMethodInterfaceRepository	"Reset the class variable that holds a cumulative repository of all method interfaces.  No senders at present -- intended to be evaluated manually during development."	AllMethodInterfaces _ IdentityDictionary new"Vocabulary resetMethodInterfaceRepository"! !FullVocabulary removeSelector: #categoryWithNameIn:thatIncludesSelector:forClass:!Vocabulary removeSelector: #categoryDefiningSelector:forClass:!Vocabulary removeSelector: #categoryWithNameIn:thatIncludesSelector:forClass:!Vocabulary removeSelector: #nameOfCategoryContaining:!CategoryViewer removeSelector: #newMakeSetter:from:forMethodInterface:!CategoryViewer removeSelector: #phraseForSlot:!Player removeSelector: #commandPhraseFor:inViewer:!Player removeSelector: #tilePhrasesSpecsForCategory:!Player removeSelector: #tilePhrasesSpecsInstanceVariablesCategory!ObjectRepresentativeMorph removeSelector: #categoryElementsFor:!Morph removeSelector: #categoryElementsFor:!Object removeSelector: #commandPhraseFor:inViewer:!Object removeSelector: #tilePhrasesSpecsForCategory:!Smalltalk removeClassNamed: #ValueSpecification!"Postscript:"Vocabulary initialize.!