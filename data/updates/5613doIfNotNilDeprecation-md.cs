'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5595] on 12 December 2003 at 4:58:58 pm'!"Change Set:		doIfNotNilDeprecation-mdDate:			12 December 2003Author:			Marcus DenkerThis changeset deprecates Object>>doIfNotNil: and changesall senders to use ifNotNilDo: instead."!!Object methodsFor: 'accessing' stamp: 'md 12/12/2003 16:25'!doIfNotNil: aBlock	self deprecated: 'use ifNotNilDo:'.	^ self ifNotNilDo: aBlock! !!BorderedMorph methodsFor: 'menu' stamp: 'md 12/12/2003 16:21'!changeBorderWidth: evt	| handle origin aHand newWidth oldWidth |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	oldWidth _ borderWidth.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newWidth _ (newPoint - origin) r asInteger // 5.			self borderWidth: newWidth]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: 'border change' translated;					undoTarget: self selector: #borderWidth: argument: oldWidth;					redoTarget: self selector: #borderWidth: argument: newWidth)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase border width.Click when done.' hand: evt hand.	handle startStepping! !!HaloMorph methodsFor: 'private' stamp: 'md 12/12/2003 16:21'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse |	evt hand obtainHalo: self.	newExtent _ (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].	target renderedMorph setExtentFromHalo: (extentToUse _ newExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) ifNotNilDo:  		[:cmd | "Update the final extent"		cmd redoTarget: target selector: #setExtentFromHalo: argument: extentToUse]! !!HaloMorph methodsFor: 'private' stamp: 'md 12/12/2003 16:21'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |	evt hand obtainHalo: self.	degrees _ (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	self showingDirectionHandles ifFalse:		[self showDirectionHandles: true addHandles: false].	self addDirectionHandles.	target rotationDegrees: degrees.	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	(self valueOfProperty: #commandInProgress) ifNotNilDo:		[:cmd | "Update the final rotation"		cmd redoTarget: target selector: #rotationDegrees: argument: degrees].	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'md 12/12/2003 16:21'!endInteraction	"Clean up after a user interaction with the a halo control"	| m |	self isMagicHalo: false.	"no longer"	self magicAlpha: 1.0.	(target isInWorld not or: [owner isNil]) ifTrue: [^self].	[target isFlexMorph and: [target hasNoScaleOrRotation]] whileTrue: 			[m := target firstSubmorph.			target removeFlexShell.			target := m].	self isInWorld 		ifTrue: 			["make sure handles show in front, even if flex shell added"			self comeToFront.			self addHandles].	(self valueOfProperty: #commandInProgress) ifNotNilDo: 			[:cmd | 			self rememberCommand: cmd.			self removeProperty: #commandInProgress]! !!MIDIScore methodsFor: 'ambient track' stamp: 'md 12/12/2003 16:21'!eventMorphsDo: aBlock	"Evaluate aBlock for all morphs related to the ambient events."	ambientTrack == nil ifTrue: [^ self].	ambientTrack do: [:evt | evt morph ifNotNilDo: aBlock].! !!MoviePlayerMorph methodsFor: 'navigation' stamp: 'md 12/12/2003 16:21'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startRunning; step.  "will stop after first step"	soundTrackMorph ifNotNilDo: [:m | m image fillWhite].	self stepSoundTrack.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'md 12/12/2003 16:21'!accept 	"Inform the model of text to be accepted, and return true if OK."	| textToAccept ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection _ self selectionInterval copy.	saveScrollerOffset _ scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	textToAccept _ textMorph asText.	ok _ setTextSelector isNil or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNilDo:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model isKindOf: CodeHolder) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'md 12/12/2003 16:21'!cancel	self setText: self getText.	self setSelection: self getSelection.	getTextSelector == #annotation ifFalse:		[(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNilDo:			[:aPane | model changed: #annotation]]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'md 12/12/2003 16:21'!toggleAnnotationPaneSize	| handle origin aHand siblings newHeight lf prevBottom m ht |	self flag: #bob.		"CRUDE HACK to enable changing the size of the annotations pane"	owner ifNil: [^self].	siblings _ owner submorphs.	siblings size > 3 ifTrue: [^self].	siblings size < 2 ifTrue: [^self].	aHand _ self primaryHand.	origin _ aHand position.	handle _ HandleMorph new		forEachPointDo: [:newPoint |			handle removeAllMorphs.			newHeight _ (newPoint - origin) y asInteger min: owner height - 50 max: 16.			lf _ siblings last layoutFrame.			lf bottomOffset: newHeight.			prevBottom _ newHeight.			siblings size - 1 to: 1 by: -1 do: [ :index |				m _ siblings at: index.				lf _ m layoutFrame.				ht _ lf bottomOffset - lf topOffset.				lf topOffset: prevBottom.				lf bottomOffset = 0 ifFalse: [					lf bottomOffset: (prevBottom + ht).				].				prevBottom _ prevBottom + ht.			].			owner layoutChanged.		]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].		].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase pane.Click when done.' hand: aHand.	handle startStepping! !!PolygonMorph methodsFor: 'menu' stamp: 'md 12/12/2003 16:22'!customizeArrows: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			self arrowSpec: (newPoint - origin) / 5.0]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.' hand: evt hand.	handle startStepping! !!PolygonMorph methodsFor: 'private' stamp: 'md 12/12/2003 16:22'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms do: [:f | f offset: f offset + delta].	curveState _ nil.  "Force recomputation"	(self valueOfProperty: #referencePosition) ifNotNilDo:		[:oldPos | self setProperty: #referencePosition toValue: oldPos + delta]! !!Presenter methodsFor: 'viewer' stamp: 'md 12/12/2003 16:22'!updateViewer: aViewer forceToShow: aCategorySymbol	"Update the given viewer to make sure it is in step with various possible changes in the outside world, and when reshowing it be sure it shows the given category"	| aPlayer aPosition newViewer oldOwner wasSticky barHeight itsVocabulary aCategory categoryInfo |	aCategory _ aCategorySymbol ifNotNil: [aViewer currentVocabulary translatedWordingFor: aCategorySymbol].	categoryInfo _ aViewer categoryMorphs  asOrderedCollection collect:		[:aMorph | aMorph categoryRestorationInfo].	itsVocabulary _ aViewer currentVocabulary.	aCategory ifNotNil: [(categoryInfo includes: aCategorySymbol) ifFalse: [categoryInfo addFirst: aCategorySymbol]].	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	barHeight _ aViewer submorphs first listDirection == #topToBottom		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	Preferences viewersInFlaps ifTrue:		[newViewer setProperty: #noInteriorThumbnail toValue: true].	newViewer rawVocabulary: itsVocabulary.	newViewer limitClass: aViewer limitClass.	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton showCategories: categoryInfo.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world ifNotNilDo: [:aWorld | aWorld startSteppingSubmorphsOf: newViewer].	newViewer layoutChanged! !!TextMorph methodsFor: 'menu' stamp: 'md 12/12/2003 16:22'!changeMargins: evt	| handle origin aHand oldMargin newMargin |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	oldMargin _ margins.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newMargin _ (newPoint - origin max: 0@0) // 5.			self margins: newMargin]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: 'margin change' translated;					undoTarget: self selector: #margins: argument: oldMargin;					redoTarget: self selector: #margins: argument: newMargin)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor down and to the rightto increase margin inset.Click when done.' hand: evt hand.	handle startStepping! !