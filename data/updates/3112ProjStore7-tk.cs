'From Squeak2.9alpha of 16 June 2000 [latest update: #3169] on 12 December 2000 at 10:27:43 pm'!"Change Set:		ProjStore7-tkDate:			12 December 2000Author:			Ted KaehlerAnother round of trying to make References to Players write and read from exported projects.  This verion records the References to Players and reinstalls them.  Renames Players and references if there is a conflict at load time.	New tile scripts remove their tiles before being saved, and recreate them upon loading.  Viewer flaps are kept, but the viewer itself is removed.  It is recreated at load time.	Fixes bug in Character clone."!!SyntaxMorph commentStamp: 'tk 12/8/2000 23:01' prior: 0!A single class of morph that holds any piece of Smalltalk, and allows it to be a tile.  Tiles can be dragged in or out of a method. In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.Dragging a statement removes it from a block.  Dragging anything else drags off a copy.  (Can't drag out the original -- it leaves an illegal hole.)Each SyntaxMorph points at a ParseNode.  After editing, the parseNode is only good as a part-of-speech indicator.  Only the classes of the parseNodes are important.  It's state is not kept up to date with the tile edits (but maybe it should be).The correspondence with parseNodes in not one-to-one.  Several extra levels of SyntaxMorph were added as aligners to make the horizontal and vertical layout right.  These have nil for the parseNode.To accept, pass over the tree of SyntaxMorphs, gathering their printStrings and inserting punctuation.  See (SyntaxMorph>>printOn:indent:).  Accept that.  Pretty print to make it look better.!!Character methodsFor: 'copying' stamp: 'tk 12/9/2000 11:46'!clone	"Answer with the receiver, because Characters are unique."! !!ClassDescription methodsFor: 'instance variables' stamp: 'tk 12/12/2000 11:59'!renameSilentlyInstVar: old  to: new	| i oldName newName |	oldName _ old asString.	newName _ new asString.	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self replaceSilently: oldName to: newName.	"replace in text body of all methods"! !!ClassDescription methodsFor: 'instance variables' stamp: 'tk 12/12/2000 11:58'!replaceSilently: old to: new	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"	| oldCode newCode parser header body sels oldName newName |	oldName _ old asString.	newName _ new asString.	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 12/12/2000 12:11'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots. 	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject | 		importedObject class class == Metaclass ifTrue: [self declare: importedObject]].	arrayOfRoots do: [:importedObject | 		(importedObject isKindOf: Project) ifTrue: [			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences]].	arrayOfRoots do: [:importedObject | 		(importedObject respondsTo: #unhibernate) ifTrue: [			importedObject unhibernate].	"ScriptEditors and ViewerFlapTabs"		].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!Morph methodsFor: 'naming' stamp: 'tk 12/12/2000 12:58'!renameTo: aName	"Set Player name in costume.  Update Viewers.  Fix all tiles (old style).  fix References.  New tiles: recompile, and recreate open scripts.  If coming in from disk, and have name conflict, References will already have new name."	| aPresenter putInViewer aPasteUp renderer oldKey assoc classes oldName |	oldName _ self knownName.	(renderer _ self topRendererOrSelf) setNameTo: aName.	putInViewer _ false.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: renderer player.		putInViewer ifTrue: [			renderer player viewerFlapTab hibernate]].  "empty it temporarily"	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]].	putInViewer ifTrue: [aPresenter viewMorph: self].	"recreate my viewer"	"fix References dictionary.  See restoreReferences to know why oldKey is 		already aName, but oldName is the old name."	oldKey _ References keyAtIdentityValue: renderer player ifAbsent: [^ aName].	assoc _ References associationAt: oldKey.	oldKey = aName ifFalse: ["normal rename"		assoc key: aName.		References rehash].	"Force strings in tiles to be remade with new name.  New tiles only."	(aPasteUp valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ aName].	classes _ (Smalltalk allCallsOn: assoc) collect: [:classAndMethod | 		(classAndMethod findTokens: Character separators) first asSymbol].	(classes asSet) do: [:clsName |		(Smalltalk at: clsName) replaceSilently: oldName to: aName].		"replace in text body of all methods.  Can be wrong!!"	"Redo the tiles that are showing"	aPasteUp allTileScriptingElements do: [:mm | "just ScriptEditorMorphs"		(mm isKindOf: ScriptEditorMorph) ifTrue: [			((mm playerScripted class compiledMethodAt: mm scriptName) hasLiteral: assoc)				ifTrue: [mm hibernate; unhibernate]]].	^ aName! !!FlapTab methodsFor: 'initialization' stamp: 'tk 12/11/2000 16:29'!adaptToWorld	| wasShowing new |	(wasShowing _ self flapShowing) ifTrue:					[self hideFlap].	(self respondsTo: #unhibernate) ifTrue: [		(new _ self unhibernate) == self ifFalse: [			^ new adaptToWorld]].	self spanWorld.	self positionObject: self.	wasShowing ifTrue:		[self showFlap]! !!PasteUpMorph methodsFor: 'flaps' stamp: 'tk 12/11/2000 16:17'!releaseViewers	"In preparation for saving, make the flapTabs release their viewers."	(self valueOfProperty: #universalTiles ifAbsent: [false]) ifTrue: [		self flapTabs do: [:ft | 			(ft respondsTo: #hibernate) ifTrue: [ft hibernate]]].! !!Player methodsFor: 'misc' stamp: 'tk 12/11/2000 14:50'!viewerFlapTab	"If a viewer in a flap exists for me, return it."	costume world submorphsDo: [:mm | 		(mm isKindOf: ViewerFlapTab) ifTrue: [			mm scriptedPlayer == self ifTrue: [^ mm]]]. 	^ nil! !!Presenter methodsFor: 'viewer' stamp: 'tk 12/11/2000 16:27'!viewMorph: aMorph	| aPlayer aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown ifFalse:		[((aPalette _ aMorph standardPalette) ~~ nil and: [aPalette isInWorld])			ifTrue:	[^ aPalette viewMorph: aMorph]].	aPlayer _ (topItem _ aMorph topRendererOrSelf) assuredPlayer.	aViewer _ self nascentPartsViewer.	"19 sept 2000 - allow flaps in any paste up"	flapLoc _ associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: aPlayer barHeight: 0.		aViewer enforceTileColorPolicy.		aViewer fullBounds. "force layout"		associatedMorph addMorph: aViewer.		flapLoc hideViewerFlapsOtherThanFor: aPlayer.		aFlapTab _ flapLoc viewerFlapTabFor: topItem.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		flapLoc startSteppingSubmorphsOf: aViewer.		^ aFlapTab].			aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds. "force layout"	Preferences automaticViewerPlacement ifTrue:		[aPoint _ aMorph bounds right @ 			(aMorph center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		associatedMorph addMorph: aViewer.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^ aViewer! !!Presenter methodsFor: 'misc' stamp: 'tk 12/11/2000 14:51'!currentlyViewing: aPlayer	"Only detects viewers in tabs"	^ aPlayer viewerFlapTab ~~ nil! !!Project methodsFor: 'file in/out' stamp: 'tk 12/11/2000 16:17'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	"Display checkCurrentHandForObjectToPaste."Command initialize.world clearCommandHistory.world fullReleaseCachedState; releaseViewers. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).roots _ roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copySmartRootsExport: roots asArray.	"old way was (is _ ImageSegment new copyFromRootsForExport: roots asArray)"is state = #tooBig ifTrue: [^ false].str _ ''."considered legal to save a project that has never been entered"(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: aFileName inDirectory: aDirectory.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 12/12/2000 11:00'!restoreReferences	| key newKey |	"I just came in from an exported segment.  Take all my players that were in References, and reinstall them."	(world valueOfProperty: #References ifAbsent: [#()]) do: [:assoc | "just came in"		key _ assoc key.		(References includesKey: key) 			ifTrue: ["must rename" 				(References at: key) == assoc value ifTrue: [					self error: 'why object already present?'].				newKey _ assoc value uniqueNameForReference.				References removeKey: newKey.				assoc key: newKey.				References add: assoc.	"use the known association"				assoc value renameTo: newKey.	"Player name and recompile scripts"				]			ifFalse: [References add: assoc]].	world removeProperty: #References.! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 12/11/2000 13:52'!showSourceInScriptor	"Remove tile panes, if any, and show textual source instead"	| aCodePane wld |	self isTextuallyCoded ifFalse: [self becomeTextuallyCoded].		"Mostly to fix up grandfathered ScriptEditors"	self submorphs allButFirst do: [:m | m delete].	aCodePane _ MethodHolder isolatedCodePaneForClass: playerScripted class selector: scriptName.	showingMethodPane _ true.	self addMorphBack: aCodePane.	wld _ self world ifNil: [Display bestGuessOfCurrentWorld].	(wld valueOfProperty: #universalTiles ifAbsent: [false]) 		ifTrue: [self useNewTilesNow].	"grab aCodePane, get model, and remove it" 	self currentWorld startSteppingSubmorphsOf: self! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 12/8/2000 12:11'!retract	| rec oo |	"replace this message with its receiver.  I am the message node."	rec _ submorphs detect: [:mm | mm isSyntaxMorph] ifNone: [^ nil].	(rec nodeClassIs: MessagePartNode) ifTrue: [^ nil].	submorphs do: [:mm |		mm valueOfProperty: #myPopup ifPresentDo:			[:panel | panel delete. self removeProperty: #myPopup]].	(oo _ owner) isSyntaxMorph ifFalse: [oo _ oo owner].	oo replaceSubmorph: self by: rec.	rec acceptIfInScriptor.! !!ViewerFlapTab methodsFor: 'as yet unclassified' stamp: 'tk 12/12/2000 13:40'!hibernate	"drop my viewer to save space when writing to the disk."	referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].! !!ViewerFlapTab methodsFor: 'as yet unclassified' stamp: 'tk 12/12/2000 12:44'!unhibernate	"recreate my viewer"	referent ifNil: [^ self presenter viewMorph: scriptedPlayer costume].! !SyntaxMorph removeSelector: #offerPopUp2!