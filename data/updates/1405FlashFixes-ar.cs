'From Squeak 2.5 of August 6, 1999 on 1 September 1999 at 4:33:26 pm'!"Change Set:		FlashFixes-arDate:			1 September 1999Author:			Andreas RaabMisc fixes for the flash player."!!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 9/1/1999 15:25'!loadInitialFrame	"Force the transformations taking place in the first frame."	super loadInitialFrame.	self stepToFrame: 1.	(self isSpriteHolder and:[self visible]) ifTrue:[self activateSprites: true].! !!FlashCharacterMorph methodsFor: 'printing' stamp: 'ar 9/1/1999 15:19'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:'(renderTime = '; print: renderTime;		nextPutAll:'; depth = '; print: self depth;		"nextPutAll:' complexity = '; print: self complexity * bounds area // 1000 / 1000.0;"		"nextPutAll:' size = '; print: bounds area;"	 nextPutAll:')'.! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 9/1/1999 16:32'!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix: version >= 3].	self flag: #checkThis.	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	(flags anyMask: 64) ifTrue:["self halt:'Clip shape encountered'." ^true].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move 		ifTrue:[self recordMoveObject: id name: name depth: depth matrix: matrix colorMatrix: cxForm]		ifFalse:[self recordPlaceObject: id name: name depth: depth matrix: matrix colorMatrix: cxForm].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 9/1/1999 14:45'!processPlaceObject: data	| id depth matrix colorMatrix |	id _ data nextWord.	depth _ data nextWord.	matrix _ data nextMatrix.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	data atEnd ifFalse:[colorMatrix _ data nextColorMatrix].	self recordPlaceObject: id name: nil depth: depth matrix: matrix colorMatrix: colorMatrix.	^true! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 9/1/1999 14:40'!recordMoveObject: objectIndex name: aString depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 9/1/1999 14:42'!recordPlaceObject: objectIndex name: aString depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 9/1/1999 14:41'!recordMoveObject: objectIndex name: aString depth: depth matrix: matrix colorMatrix: colorMatrix	| index oldObj mat |	index _ nil.	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth])					ifTrue:[index _ morph id]]].	oldObj _ self recordRemoveObject: index depth: depth.	oldObj isNil ifTrue:[^self].	objectIndex isNil ifFalse:[index _ objectIndex].	matrix isNil 		ifTrue:[mat _ oldObj matrixAtFrame: frame]		ifFalse:[mat _ matrix].	self recordPlaceObject: index name: aString depth: depth matrix: mat colorMatrix: colorMatrix.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 9/1/1999 14:44'!recordPlaceObject: objectIndex name: aString depth: depth matrix: matrix colorMatrix: colorTransform	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorTransform: colorTransform atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.	aString ifNotNil:[active setNameTo: aString].! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 9/1/1999 15:27'!loopFrames	^true! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 9/1/1999 16:15'!stepForward	frameNumber < maxFrames		ifTrue:[^self frameNumber: frameNumber + 1].	self loopFrames		ifTrue:[self frameNumber: 1]		ifFalse:[self stopPlaying].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 9/1/1999 16:14'!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	frame > loadedFrames ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do: [:sound | sound ifNotNil:[self playFlashSound: sound]].	self executeActionsAt: frame.	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 9/1/1999 15:50'!actionTarget: target	"Set the context (e.g., the receiver) of the following actions."	| rcvr lastSlash nextSlash loc |	target = '' ifTrue:[^self].	target first = $/		ifTrue:[rcvr _ self flashPlayer ifNil:[self]. lastSlash _ 1.] "absoute path"		ifFalse:[rcvr _ self. lastSlash _ 0]. "relative path"	[lastSlash > target size] whileFalse:[		nextSlash _ target findString:'/' startingAt: lastSlash+1.		nextSlash = 0 ifTrue:[nextSlash _ target size + 1].		loc _ target copyFrom: lastSlash+1 to: nextSlash-1.		(loc size = 2 and:[loc = '..']) ifTrue:[			[rcvr _ rcvr owner.			rcvr isFlashSprite] whileFalse.		] ifFalse:[			rcvr _ rcvr submorphs detect:[:m| m knownName = loc] ifNone:[rcvr owner].			rcvr _ rcvr submorphs detect:[:m| m isFlashSprite].		].		lastSlash _ nextSlash].	^rcvr! !!FlashSpriteMorph methodsFor: 'actions' stamp: 'ar 9/1/1999 16:15'!executeActionsAt: frame	| rcvr actionList index msg result |	actionList _ actions at: frame ifAbsent:[^self].	index _ 1.	rcvr _ self.	[index <= actionList size] whileTrue:[		msg _ actionList at: index."Transcript cr; print: msg selector; space; print: msg arguments; endEntry."		msg selector == #actionTarget:			ifTrue:[	rcvr _ msg sentTo: self]			ifFalse:[	result _ msg sentTo: rcvr.					result ifNotNil:[index _ index + result]].		index _ index + 1].! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 9/1/1999 14:39'!initialize	super initialize.	color _ Color white.	self loopFrames: true.	localBounds _ bounds.	activationKeys _ #().	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	progressValue _ ValueHolder new.	progressValue contents: 0.0.	self defaultAALevel: 2.	self deferred: true.! !FlashFileReader removeSelector: #recordPlaceObject:depth:matrix:colorMatrix:!FlashFileReader removeSelector: #recordMoveObject:depth:matrix:colorMatrix:!FlashMorphReader removeSelector: #recordPlaceObject:depth:matrix:colorMatrix:!FlashMorphReader removeSelector: #recordMoveObject:depth:matrix:colorMatrix:!