'From Squeak2.8alpha of 13 January 2000 [latest update: #1950] on 29 March 2000 at 12:06:48 pm'!!Morph methodsFor: 'thumbnail' stamp: 'tk 3/28/2000 11:08'!updateThumbnailUrl	"If I have a cached thumbnail, then update it's urls."	| cachedThumbnail |	(cachedThumbnail _ self valueOfProperty: #cachedThumbnail) ifNotNil:		[(cachedThumbnail respondsTo: #computeThumbnail) 			ifTrue: [cachedThumbnail pageMorph: self url inBook: owner url]			ifFalse: [self removeProperty: #computeThumbnail]].			"Test and removal are because the thumbnail is being replaced 			by another Morph.  We don't know why.  Need to fix that at 			the source."! !!Morph methodsFor: 'thumbnail' stamp: 'tk 3/28/2000 21:55'!updateThumbnailUrlInBook: bookUrl	"If I have a cached thumbnail, then update it's urls."	| cachedThumbnail |	(cachedThumbnail _ self valueOfProperty: #cachedThumbnail) ifNotNil:		[(cachedThumbnail respondsTo: #computeThumbnail) 			ifTrue: [cachedThumbnail pageMorph: self url inBook: bookUrl]			ifFalse: [self removeProperty: #computeThumbnail]].			"Test and removal are because the thumbnail is being replaced 			by another Morph.  We don't know why.  Need to fix that at 			the source."! !!BookMorph methodsFor: 'navigation' stamp: 'tk 3/28/2000 21:56'!goToPageMorph: newPage transitionSpec: transitionSpec	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^ self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex _ pages identityIndexOf: newPage ifAbsent: [^ self "abort"].	readIn _ newPage isInMemory not.	oldPageIndex _ pages identityIndexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageIndex == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageIndex < pageIndex].	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			(pages at: pageIndex) position: currentPage position.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: (ascending or: [transitionSpec notNil]) not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self addMorphBack: (currentPage _ pages at: pageIndex).					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].					readIn ifTrue: [currentPage updateThumbnailUrlInBook: self url.						currentPage sqkPage computeThumbnail].	"just store it"					]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].	readIn ifTrue: [currentPage updateThumbnailUrl.		currentPage sqkPage computeThumbnail].	"just store it"! !!BookMorph methodsFor: 'navigation' stamp: 'tk 3/28/2000 13:40'!goToPageUrl: aUrl	| pp short |	pp _ pages detect: [:pg | pg url = aUrl] ifNone: [nil].	pp ifNil: [short _ (aUrl findTokens: '/') last.			pp _ pages detect: [:pg | pg url ifNil: [false]						ifNotNil: [(pg url findTokens: '/') last = short]] "it moved"					ifNone: [pages at: 1]].	self goToPageMorph: pp.! !!BookMorph methodsFor: 'menu' stamp: 'tk 3/28/2000 22:03'!reserveUrls	"Save a dummy version of the book first, assign all pages URLs, write dummy files to reserve the url, and write the index.  Good when I have pages with interpointing bookmarks."| stem |(stem _ self getStemUrl) size = 0 ifTrue: [^ self].pages doWithIndex: [:pg :ind | 	"does write the current page too"	pg url ifNil: [pg reserveUrl: stem,(ind printString),'.sp']]."self saveIndexOnURL."! !!BookMorph methodsFor: 'menu' stamp: 'tk 3/28/2000 21:42'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL. (page file names must be unique even if they live in different directories.)"	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls fName |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine)].	strm ifNil: [^ self saveIndexOnURL].	strm class == String ifTrue: [^ self saveIndexOnURL].	strm exists ifFalse: [^ self saveIndexOnURL].	"write whole thing if missing"	strm _ strm asStream.	strm class == String ifTrue: [^ self saveIndexOnURL].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	fName _ pageURL copyAfterLast: $/.	2 to: remote size do: [:ii | 		((remote at: ii) url findString: fName startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				pre _ pre copyAfterLast: $/.				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]].				after ifNil: [after _ remote size+1]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	remote at: index put: (aPage sqkPage copyForSaving).	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 3/28/2000 10:19'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list mine sf remoteFile urlList |	pages size = 0 ifTrue: [^ self].	dict _ Dictionary new.  dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	#(color borderWidth borderColor pageSize) do: [:sel |		dict at: sel put: (self perform: sel)].	self reserveUrlsIfNeeded.	"should already be done"	list _ pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: [:out :ind |		out isInMemory ifTrue: [  			(out valueOfProperty: #SqueakPage) ifNil: [				out saveOnURLbasic].			list at: ind put: (out sqkPage copyForSaving)]].	urlList _ list collect: [:ppg | ppg url].	self setProperty: #allTextUrls toValue: urlList.	dict at: #allTextUrls put: urlList.	list _ (Array with: dict), list.	mine _ self valueOfProperty: #url.	mine ifNil: [mine _ self getStemUrl, '.bo'.		self setProperty: #url toValue: mine].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: list.		"remoteFile close"].! !!BookMorph class methodsFor: 'as yet unclassified' stamp: 'tk 3/28/2000 13:30'!isInWorld: aWorld withUrl: aUrl	| urls bks short |	"If a book with this url is in the that (current) world, return it.  Say if it is out or in another world."	urls _ OrderedCollection new.	bks _ OrderedCollection new.	aWorld allMorphsDo: [:aBook | (aBook isKindOf: BookMorph) ifTrue: [			bks add: aBook.			 (urls add: (aBook valueOfProperty: #url)) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]]]]. 	"shortcut"			self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]					ifFalse: [						self inform: 'Book may be open in some other project'.						^ aBook]]]].	"if same book name, use it"	short _ (aUrl findTokens: '/') last.	urls withIndexDo: [:kk :ind | (kk findTokens: '/') last = short ifTrue: [			^ bks at: ind]].	^ #out! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'tk 3/28/2000 10:33'!objectForDataStream: refStrm	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph class == String) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page url ~~ nil) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page url == nil) ifTrue: [		self error: 'page should already have a url'.		"find page's book, and remember it"		"bookMorph _ "].		clone _ self clone.	(bookUrl _ bookMorph url)		ifNil: [bookUrl _ self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb _ RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ SqueakPage stemUrl: bookUrl.		ind _ bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	^ clone! !!PasteUpMorph methodsFor: 'project' stamp: 'tk 3/27/2000 20:38'!releaseSqueakPages	| uu |	"If this world has a book with SqueakPages, then clear the SqueakPageCache"	submorphs do: [:sub | (sub isKindOf: BookMorph) ifTrue: [		uu _ sub valueOfProperty: #url ifAbsent: [nil].		uu ifNotNil: [(SqueakPageCache pageCache includesKey: uu) ifTrue: [				SqueakPageCache initialize]]]].	"wipe the cache"! !!Project methodsFor: 'file in/out' stamp: 'tk 3/27/2000 20:39'!exportSegmentWithCatagories: catList classes: classList	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is response str ans revertSeg roots holder |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allInstances.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ (Array with: self) asOrderedCollection, classList, (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: self name, '.pr'.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 3/27/2000 20:40'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is response sizeHint |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].world releaseSqueakPages.sizeHint _ self projectParameters at: #segmentSize ifAbsent: [0].is _ ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		 sizeHint: sizeHint.is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' only ', is segment size printString, 		'bytes in Segment.'; cr].self projectParameters at: #segmentSize put: is segment size.is extract; writeToFile: self name.^ true! !!Project methodsFor: 'object fileIn' stamp: 'tk 3/29/2000 11:55'!convertdwctppdaevtngp0: varDict dwctppdaevtngpiicmovue0: smartRefStrm	"These variables are automatically stored into the new instance ('world' 'changeSet' 'transcript' 'parentProject' 'previousProject' 'displayDepth' 'activeProcess' 'exitFlag' 'viewSize' 'thumbnail' 'nextProject' 'guards' 'projectParameters' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('isolatedHead' 'inForce' 'classArray' 'methodDictArray' 'orgArray' 'version' 'urlList' 'environment' )  If a non-nil value is needed, please assign it."! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 3/28/2000 22:19'!tryToPutReference: anObject typeID: typeID	"PRIVATE -- If we support references for type typeID, and if	   anObject already appears in my output stream, then put a	   reference to the place where anObject already appears. If we	   support references for typeID but didn't already put anObject,	   then associate the current stream position with anObject in	   case one wants to nextPut: it again.	 Return true after putting a reference; false if the object still	   needs to be put.	 : Added support for weak refs. Split out outputReference:.	08:42 tk  references stores relative file positions."	| referencePosn nextPosn |	"Is it a reference type of object?"	(self isAReferenceType: typeID) ifFalse: [^ false].	"Have we heard of and maybe even written anObject before?"	referencePosn _ references at: anObject ifAbsent:			["Nope. Remember it and let the sender write it."			references at: anObject put: (byteStream position - basePos).	"relative"			^ false].	"If referencePosn is an Integer, it's the stream position of anObject."	referencePosn isInteger ifTrue:		[self outputReference: referencePosn.	"relative"		^ true].	referencePosn == #none ifTrue: ["for DiskProxy"			references at: anObject put: (byteStream position - basePos).	"relative"			^ false].	"Else referencePosn is a collection of positions of weak-references to anObject.	 Make them full references since we're about to really write anObject."	references at: anObject put: (nextPosn _ byteStream position) - basePos.	"store relative"	referencePosn do: [:weakRefPosn |			byteStream position: weakRefPosn + basePos.		"make absolute"			self outputReference: nextPosn - basePos].	"make relative"	byteStream position: nextPosn.		"absolute"	^ false! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 3/28/2000 21:38'!fileExists: fileName	"Does the file exist on this server directory?  fileName must be simple with no / or references to other directories."	type == #file ifTrue: [^ self fileNames includes: fileName].	type == #http ifTrue: [^ (self readOnlyFileNamed: fileName) class ~~ String].	"ftp"	^ (self getFileList contentsOfEntireFile findTokens: FTPSocket crLf) includes: fileName! !