'From Squeak 2.3 beta of Nov 25, 1998 on 13 January 1999 at 3:52:21 pm'!!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 1/3/1999 12:52'!newFrom: aCollection	| newCollection |	newCollection _ self new.	newCollection addAll: aCollection.	^newCollection! !!Collection methodsFor: 'converting' stamp: 'ls 1/3/1999 13:48'!asCharacterSet	"Answer a CharacterSet whose elements are the unique elements of the receiver.  The reciever should only contain characters"	^CharacterSet newFrom: self! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 11/24/1998 08:38'!refreshChannelList	"update the list of channels"	| sortBlock |	channelList _ connection channelList.	channelList ifNil: [ channelList _ #() ].	"sort the channels"	sortCriterion = #name ifTrue: [		sortBlock _ [ :a :b | a name asIRCLowercase < b name asIRCLowercase ] ]	ifFalse: [		sortBlock _ [ :a :b |		a numUsers = b numUsers			ifTrue: [ a name asIRCLowercase < b name asIRCLowercase ]			ifFalse: [ a numUsers > b numUsers ] ] ].	channelList _ channelList asSortedCollection: sortBlock.	channelList _ channelList asArray.		channelIndex _ 0.	self changed: #channelDescriptions.	self changed: #channelIndex.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 12/10/1998 20:45'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	chatText _ chatText, newLine.	chatText size > 2000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 1000) to: chatText size ].	self changed: #chatText.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 12/10/1998 23:16'!processPart: aMessage	"a user is leaving a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) removeMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 12/11/1998 00:15'!processQuit: aMessage	"a user has left IRC.  Remove them from all chanels"	|  user |	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	subscribedChannels do: [ :channel |		(channel memberNames includes: user) 			ifTrue: [ channel removeMember: user ] ].! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 12/11/1998 00:16'!initializeMessageHandlers	"initilize the table mapping IRC commands to processing methods"	"IRCConnection initializeMessageHandlers"	MessageHandlers _ Dictionary new.	#(		372		processMotd:		377		processMotd:		375		processMotdStart:		376		processMotdEnd:		ping	processPing:		join		processJoin:		part	processPart:		quit		processQuit:		privmsg		processPrivmsg:		notice		processPrivmsg:		321		processChannelListStart:		322		processChannelList:		323		processChannelListEnd:		331		processNoTopic:		332		processTopic:		topic	processTopic:		353		processNamReply:	) pairsDo: [ :command  :method |		MessageHandlers at: command asString put: method ].! !!String methodsFor: 'converting' stamp: 'ls 1/3/1999 13:36'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result _ WriteStream on: (Array new: 10).	end _ 0.	"find one substring each time through this loop"	[ 		"find the beginning of the next substring"		beginning _ self indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: [ nil ].		beginning ~~ nil ] 	whileTrue: [		"find the end"		end _ self indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ self size + 1 ].		end _ end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'internet' stamp: 'ls 10/27/1998 00:52'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf input c crlf inPos outPos outString lineEndPos newOutPos |	cr _ Character cr.	lf _ Character linefeed.	crlf _ CharacterSet new.	crlf add: cr; add: lf.	inPos _ 1.	outPos _ 1.	outString _ String new: self size.	[ lineEndPos _ self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos _ outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos _ newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos _ lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos _ lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos _ outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !IRCConnection removeSelector: #processPach:!