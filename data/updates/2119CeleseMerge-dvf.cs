'From Squeak2.8alpha of 12 February 2000 [latest update: #2053] on 13 May 2000 at 8:51:16 pm'!!Celeste methodsFor: 'table of contents pane' stamp: 'dvf 4/27/2000 18:58'!partsMenu	| menu currMessage part |	menu _ CustomMenu new.	currMessage _ self currentMessage.	currMessage body atomicParts do: [:e | menu add: 'save ' , e printString action: e].	part _ menu startUp.	part ifNotNil: [part save]! !!MIMEDocument methodsFor: 'as yet unclassified' stamp: 'dvf 4/27/2000 19:01'!atomicParts	self isMultipart ifFalse: [^ OrderedCollection with: self].	^ self parts inject: OrderedCollection new into: [:col :part | col , part atomicParts]! !!MIMEHeaderValue class methodsFor: 'as yet unclassified' stamp: 'dvf 5/13/2000 20:47'!fromString: aString 	| parts newValue parms separatorPos parmName parmValue |	parts _ ReadStream on: (aString findTokens: ';').	newValue _ self new mainValue: parts next asLowercase.	parms _ Dictionary new.	parts do: 		[:e | 		separatorPos _ e findAnySubStr: '=' startingAt: 1. 		separatorPos <= e size			ifTrue: 				[parmName _ (e copyFrom: 1 to: separatorPos - 1) withBlanksTrimmed.				parmValue _ (e copyFrom: separatorPos + 1 to: e size) withBlanksTrimmed withoutQuoting.				parms at: parmName put: parmValue]].	newValue parameters: parms.	^ newValue! !!MIMEPart methodsFor: 'as yet unclassified' stamp: 'dvf 4/27/2000 19:01'!atomicParts	self isMultipart ifFalse: [^OrderedCollection with: self].	^self parts inject: OrderedCollection new into: [:col :part | col, part atomicParts]! !!MIMEPart methodsFor: 'as yet unclassified' stamp: 'dvf 4/27/2000 18:40'!decoderClass	| encoding |	encoding _ self fields at: 'content-transfer-encoding' ifAbsent: [^ nil].	encoding _ encoding mainValue.	encoding asLowercase = 'base64' ifTrue: [^ Base64MimeConverter].	encoding asLowercase = 'quoted-printable' ifTrue: [^ QuotedPrintableMimeConverter].	^ nil! !!MIMEPart methodsFor: 'as yet unclassified' stamp: 'dvf 4/27/2000 18:35'!mainType	| type |	type _ self fields at: 'content-type' ifAbsent: [^'application'].	^ (type mainValue findTokens: '/') first! !!MIMEPart methodsFor: 'as yet unclassified' stamp: 'dvf 4/27/2000 18:18'!name	| type nameField disposition |	type _ self fields at: 'content-type' ifAbsent: [].	(type notNil and: [(nameField _ type parameters at: 'name' ifAbsent: []) notNil])		ifTrue: [^ nameField].	disposition _ self fields at: 'content-disposition' ifAbsent: [].	(disposition notNil and: [(nameField _ disposition parameters at: 'filename' ifAbsent: []) notNil])		ifTrue: [^ nameField].	^ nil! !!MIMEPart methodsFor: 'as yet unclassified' stamp: 'dvf 4/27/2000 18:14'!parse	| parseStream |	fields _ Dictionary new.	parseStream _ ReadStream on: self text.	self fieldsFrom: parseStream do: [:key :value | fields at: key put: (MIMEHeaderValue fromString: value)].	content _ parseStream upToEnd! !!MailDB methodsFor: 'printing' stamp: 'dvf 4/29/2000 15:27'!printOn: aStream 	aStream nextPutAll: 'a MailDB on '.	rootFilename ifNotNil: [aStream nextPutAll: '''' , rootFilename , '''']! !!MailMessage methodsFor: 'parsing' stamp: 'dvf 4/29/2000 03:07'!timeFrom: aString 	"Parse the date and time and answer the result as the number of seconds 	since the start of 1980."	| s t rawDelta delta |	s _ ReadStream on: aString.	t _ (self readDateFrom: s) asSeconds.	"date part"	[s atEnd or: [s peek isAlphaNumeric]]		whileFalse: [s next].	s atEnd ifFalse: ["read time part (interpreted as local, regardless of sender's timezone)"		t _ t + (Time readFrom: s) asSeconds].	s skipSeparators.	('+-' includes: s peek)		ifTrue: 			[s peekFor: $+. rawDelta _ Integer readFrom: s.			delta _ rawDelta // 100 * 60 + (rawDelta \\ 100).			t _ t - (delta * 60)].	^ t - (Date newDay: 1 year: 1980) asSeconds"time started with 1980..."! !