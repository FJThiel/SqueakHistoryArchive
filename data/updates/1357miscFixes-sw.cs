'From Squeak 2.4c of May 10, 1999 on 27 July 1999 at 3:42:40 pm'!"Change Set:		miscFixes-swDate:			27 July 1999Author:			Scott Wallace(1)  Fixes bug that if, for a class new to the receiver system, the class comment occurs in a fileout before any actual class code is encountered, a debugger could result because the class had no instantiated organization yet.(2)  Corrects the wording of the dialog asking the user whether to save the style (it used i.e. where it ought to use e.g.).(3)  Minor adjustment to the reporting of outcome of a code update attempt, to avoid such jarring statements as '1 files processed'.(4)  Removes three morphic methods that (as per a Bert Freudenberg observation) were not in use."!!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 7/23/1999 14:39'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ self organization classComment: aString].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).	Smalltalk changes commentClass: self.	! !!Text methodsFor: 'attributes' stamp: 'sw 7/26/1999 12:56'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old _ priorMethod getSourceFromFile].	(old == nil or: [old unembellished]) ifTrue: 		[tell _ 'This method contains style (e.g. bold) for the first time.Do you really want to save the style info?'.		answ _ (PopUpMenu labels: 'Save method with styleSave method simply') startUpWithCaption: tell. 		answ = 2 ifTrue:			[^ self asString]].	"^ self		keep my style"! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 7/27/1999 13:54'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesThrough: 828 saveLocally: false updateImage: true""Utilities readServerUpdatesThrough: 828 saveLocally: true updateImage: true"	| doc urls failed loaded str |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	Cursor wait showWhile: [(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: (Utilities serverUrls collect: [:url | url, 'updates/']) 				throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil:			[doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			doc class == String ifTrue: [failed _ this]].	"an error loading"		failed ifNil: [			doc reset; text.			doc size = 0 ifTrue: [failed _ this]].		failed ifNil: [			doc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage ifTrue:					[ChangeSorter newChangesFromStream: doc					named: (this findTokens: '/') last].			saveLocally ifTrue:				[self saveUpdate: doc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1]]].	str _ loaded printString ,' new update file(s) processed.'.	failed ifNotNil: [str _ str, '\Could not load ' withCRs, 		(urls size - loaded) printString ,' update file(s).',		'\Starting with "' withCRs, failed, '".'].	failed ifNil: [DocLibrary external ifNotNil: [			DocLibrary external updateMethodVersions]].	self inform: str.! !Morph removeSelector: #newThumbnailOfHeight:!Morph removeSelector: #thumbnailOfHeight:!HandMorph removeSelector: #makeAliasForArgument!