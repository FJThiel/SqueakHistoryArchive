'From Squeak2.9alpha of 12 June 2000 [latest update: #2733] on 27 September 2000 at 1:52:28 pm'!"Change Set:		ColorPickerTweaksDate:			27 September 2000Author:			Dan IngallsWhy have a preference for modal vs modeless (pop-up vs enduring) color pickers?This changeSet allows you to anchor any pop-up color picker analogously to anchoring a pop-up menu.  Just click or drag on the little drag-dot, and you have an enduring color picker.But wait.  There's more...Introduces balloon help for the different control areas (even during modal operation).A color selection that begins in the color area can only affect color;  one that begins in the translucency control can only affect translucency.Oh, and...Also includes a change that bundles a restore-cursor into the restore-display choice in the world menu.  Simpler than exiting the project."!SketchMorph subclass: #ColorPickerMorph	instanceVariableNames: 'selectedColor sourceHand deleteOnMouseUp updateContinuously target selector argument originalColor theSelectorDisplayMorph command isModal includesTransparency clickedTranslucency '	classVariableNames: 'ColorChart DragBox FeedbackBox RevertBox TransparentBox '	poolDictionaries: ''	category: 'Morphic-Widgets'!!Color methodsFor: 'printing' stamp: 'di 9/27/2000 13:34'!storeOn: aStream	aStream		nextPutAll: '(' , self class name;		nextPutAll: ' r: '; print: (self red roundTo: 0.001);		nextPutAll: ' g: '; print: (self green roundTo: 0.001);		nextPutAll: ' b: '; print: (self blue roundTo: 0.001);		nextPutAll: ')'.! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'di 9/27/2000 13:29'!initializeModal: beModal	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	isModal _ beModal.	self removeAllMorphs.	isModal ifFalse:		[theSelectorDisplayMorph _ AlignmentMorph newRow			color: Color white;			borderWidth: 1;			borderColor: Color red;			hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			addMorph: (StringMorph contents: 'theSelector').		self addMorph: theSelectorDisplayMorph.		self addMorph: (SimpleButtonMorph new borderWidth: 0;			label: 'x' font: nil; color: Color transparent;			actionSelector: #delete; target: self; useSquareCorners;			position: self topLeft - (0@3); extent: 10@12;			setCenteredBalloonText: 'dismiss color picker')].	self addMorph: ((Morph newBounds: (DragBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'put me somewhere').	self addMorph: ((Morph newBounds: (RevertBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'restore original color').	self addMorph: ((Morph newBounds: (FeedbackBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'shows selected color').	self addMorph: ((Morph newBounds: (TransparentBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'adjust translucency').	self buildChartForm.		selectedColor ifNil: [selectedColor _ Color white].	sourceHand _ nil.	deleteOnMouseUp _ false.	updateContinuously _ true.! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'di 9/27/2000 13:19'!mouseDown: evt	| localPt |	localPt _ evt cursorPoint - self topLeft.	self deleteAllBalloons.	clickedTranslucency _ TransparentBox containsPoint: localPt.	(DragBox containsPoint: localPt)		ifTrue: [^ evt hand grabMorph: self].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	self comeToFront.	sourceHand _ evt hand.	self startStepping.! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 9/27/2000 10:36'!anchorAndRunModeless: aHand	"If user clicks on the drag-dot of a modal picker,	anchor it, and change to modeless operation."	aHand showTemporaryCursor: nil.  "revert to normal cursor"	self initializeModal: false; originalColor: originalColor.  "reset as modeless"	aHand flushEvents.  "Drop any events gathered during modal loop"	aHand position: Sensor cursorPoint; grabMorph: self.  "Slip into drag operation"! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 9/27/2000 12:55'!deleteAllBalloons	self submorphsDo: [:m | m deleteBalloon].! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 9/27/2000 11:47'!modalBalloonHelpAtPoint: cursorPoint	self submorphsDo:		[:m | m wantsBalloon ifTrue:			[(m valueOfProperty: #balloon) == nil				ifTrue: [(m containsPoint: cursorPoint) ifTrue: [m showBalloon: m balloonText]]				ifFalse: [(m containsPoint: cursorPoint) ifFalse: [m deleteBalloon]]]]! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 9/27/2000 13:23'!pickColorAt: aGlobalPoint 	| alpha selfRelativePoint pickedColor |	selfRelativePoint _ (self globalPointToLocal: aGlobalPoint) - self topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue:		[clickedTranslucency ifFalse: [^ self].  "Can't wander into translucency control"		alpha _ (selfRelativePoint x - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"		self 			updateColor: (selectedColor alpha: alpha)			feedbackColor: (selectedColor alpha: alpha).		^ self].	"pick up color, either inside or outside this world"	clickedTranslucency ifTrue: [^ self].  "Can't wander out of translucency control"	pickedColor _ Display colorAt: aGlobalPoint.	self 		updateColor: (			(selectedColor isColor and: [selectedColor isTranslucentColor])						ifTrue: [pickedColor alpha: selectedColor alpha]						ifFalse: [pickedColor]		)		feedbackColor: pickedColor! !!ColorPickerMorph methodsFor: 'menu' stamp: 'di 9/27/2000 13:18'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt |	aHand _ aMorph ifNil: [self activeHand] ifNotNil: [aMorph activeHand].	aHand ifNil: [aHand _ self currentHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.	self owner ifNil: [^ self].	aHand showTemporaryCursor: (ScriptingSystem formAtKey: #Eyedropper) 			hotSpotOffset: 6 negated @ 4 negated.    "<<<< the form was changed a bit??"	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	(DragBox containsPoint: (localPt _ Sensor cursorPoint - self topLeft)) ifTrue:		["Click or drag the drag-dot means to anchor as a modeless picker"		^ self anchorAndRunModeless: aHand].	clickedTranslucency _ TransparentBox containsPoint: localPt.	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	aHand newMouseFocus: nil;		showTemporaryCursor: nil;		flushEvents.	self delete.		  ! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 9/25/2000 15:38'!indicateColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	self pickColorAt: (pt _ Sensor cursorPoint).	isModal ifTrue:		[self activeHand position: pt.		self world displayWorldSafely; runStepMethods].	^ selectedColor	! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 9/27/2000 11:48'!trackColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	selectedColor _ originalColor.	self trackColorAt: (pt _ Sensor cursorPoint).	isModal ifTrue:		[self activeHand position: pt.		self world displayWorldSafely; runStepMethods.		self modalBalloonHelpAtPoint: pt].	^ selectedColor	! !!DisplayScreen methodsFor: 'other' stamp: 'di 9/25/2000 16:03'!restoreMorphicDisplay	DisplayScreen startUp.	(self getOuterMorphicWorld ifNil: [^ self])		extent: self extent;		viewBox: self boundingBox;		handsDo: [:h | h endDisplaySuppression; showTemporaryCursor: nil];		restoreFlapsDisplay;		fullRepaintNeeded! !!HandMorph methodsFor: 'event handling' stamp: 'di 9/27/2000 10:59'!flushEvents	"Flush any events that may be pending"	Sensor flushEvents.	"And bring button state up to date."	lastEvent _ lastEvent copy setButtons: Sensor primMouseButtons.! !!TranslucentColor methodsFor: 'printing' stamp: 'di 9/27/2000 13:33'!storeOn: aStream	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		print: (self alpha roundTo: 0.001);		nextPutAll: ')'.! !ColorPickerMorph removeSelector: #modalBalloonHelp!SketchMorph subclass: #ColorPickerMorph	instanceVariableNames: 'selectedColor sourceHand deleteOnMouseUp updateContinuously target selector argument originalColor theSelectorDisplayMorph command isModal clickedTranslucency '	classVariableNames: 'ColorChart DragBox FeedbackBox RevertBox TransparentBox '	poolDictionaries: ''	category: 'Morphic-Widgets'!