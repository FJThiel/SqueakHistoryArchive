'From Squeak2.8alpha of 4 February 2000 [latest update: #1873] on 3 March 2000 at 1:11:32 pm'!"Change Set:		25EvtSystem-smaDate:			29 February 2000Author:			Stefan Matthias AustThis changeset adds a fast and lightweight event notification framework to Squeak which could eventually replace the existing changed/update mechanism.  This system is compatible to Dolphin Smalltalk (and VSE I think) and supports the following methods:EVENT REGISTRATIONThe following methods register a message send (consisting of a selector and a receiver object) which should be performed when anEventSymbol is triggered by the receiver.when: anEventSymbol send: aSelector to: anObjectwhen: anEventSymbol send: aSelector to: anObject with: aParameterwhen: anEventSymbol send: aSelector to: anObject withArguments: anArraywhen: anEventSymbol sendTo: anObjectEVENT UNREGISTRATIONThe first method will unregister all message sends towards the given object.  The latter method will remove all registered message sends for any receiving objects.removeEventsTriggeredFor: anObjectremoveAllEventsTriggeredEVENT NOTIFICATIONThese methods are typically called by the object which wants to fire an event.  The first methods simply evaluates all registered message sends.  The other methods additionally pass more arguments. It's the responsibility of the user to make sure that the right number of arguments is passed.trigger: anEventSymboltrigger: anEventSymbol with: aParametertrigger anEventSymbol withArguments: anArrayOTHER METHODSThe method evaluates a block without the receiver triggering any events.  This is useful for modifying objects using writing accessor methods which normally would trigger events but where the modification would otherwise lead to an endless recursion.noEventsDo: aBlock"!ProtoObject subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields EventsFields '	poolDictionaries: ''	category: 'Kernel-Objects'!Object subclass: #MessageSend	instanceVariableNames: 'receiver selector arguments '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 20:26'!release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self breakDependents.	self removeAllEventsTriggered! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:12'!myEvents	"Private. Answer a Dictionary with the receiver's events or nil if no	events have been registered. Subclasses may overwrite this method	for performance reasons."	^ EventsFields at: self ifAbsent: []! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:13'!myEvents: aDictionaryOrNil	"Private. Set (or remove) the receiver's dictionary of events.	Subclasses may overwrite this method for performance reasons."	aDictionaryOrNil		ifNil: [EventsFields removeKey: self ifAbsent: []]		ifNotNil: [EventsFields at: self put: aDictionaryOrNil]! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 20:22'!noEventsDo: aBlock	"Evaluate aBlock while ensuring that the receiver will not trigger	any events. Answer the result of evaluating aBlock."	| events |	events _ self myEvents.	^ [self myEvents: nil. aBlock value] ensure: [self myEvents: events]! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 20:26'!removeAllEventsTriggered	"Remove all events triggered by the receiver."	self myEvents: nil! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:14'!removeEventsTriggeredFor: anObject	"Remove all that events trigged by the receiver which would have	been send to anObject."	| events |	events _ self myEvents ifNil: [^ self].	events copy keysAndValuesDo:		[:evtSym :msgSendSet |		| newSet |		newSet _ msgSendSet reject: [:each | each receiver == anObject].		msgSendSet size = newSet size ifFalse:			[newSet isEmpty				ifTrue: [events removeKey: evtSym]				ifFalse: [events at: evtSym put: newSet]]].	self myEvents: (events isEmpty ifFalse: [events])! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:17'!trigger: anEventSymbol	"Evaluate all message sends registered for anEventSymbol."	((self myEvents ifNil: [^ self])		at: anEventSymbol ifAbsent: [^ self])			do: [:each | each value]! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:18'!trigger: anEventSymbol with: aParameter	"Evaluate all message sends registered for anEventSymbol	and pass aParamter to the registered actions."	self trigger: anEventSymbol withArguments: (Array with: aParameter)! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:18'!trigger: anEventSymbol withArguments: anArray	"Evaluate all message sends registered for anEventSymbol	and pass anArray to the registered actions."	((self myEvents ifNil: [^ self])		at: anEventSymbol ifAbsent: [^ self])			do: [:each | each valueWithArguments: anArray]! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 21:16'!when: anEventSymbol perform: aMessageSend	"Register aMessageSend as action for anEventSymbol."	| events |	(events _ self myEvents) ifNil:		[self myEvents: (events _ IdentityDictionary new)].	(events		at: anEventSymbol 		ifAbsentPut: [Set new]) add: aMessageSend! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 20:47'!when: anEventSymbol send: aSelector to: anObject	self		when: anEventSymbol		perform: (MessageSend receiver: anObject selector: aSelector)! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 20:49'!when: anEventSymbol send: aSelector to: anObject with: anArgument	self		when: anEventSymbol		perform: (MessageSend receiver: anObject selector: aSelector argument: anArgument)! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 20:48'!when: anEventSymbol send: aSelector to: anObject withArguments: anArray	self		when: anEventSymbol		perform: (MessageSend receiver: anObject selector: aSelector arguments: anArray)! !!Object methodsFor: 'events' stamp: 'sma 2/29/2000 20:32'!when: anEventSymbol sendTo: anObject	self when: anEventSymbol send: anEventSymbol to: anObject! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!arguments	^ arguments! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:40'!arguments: anArray	arguments _ anArray! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!receiver	^ receiver! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!receiver: anObject	receiver _ anObject! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!selector	^ selector! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!selector: aSymbol	selector _ aSymbol! !!MessageSend methodsFor: 'comparing' stamp: 'sma 2/29/2000 20:43'!= anObject	^ anObject species == self species 		and: [receiver == anObject receiver		and: [selector == anObject selector		and: [arguments = anObject arguments]]]! !!MessageSend methodsFor: 'comparing' stamp: 'sma 2/29/2000 20:43'!hash	^ receiver hash xor: selector hash! !!MessageSend methodsFor: 'evaluating' stamp: 'sma 2/29/2000 20:41'!value	^ receiver perform: selector withArguments: arguments! !!MessageSend methodsFor: 'evaluating' stamp: 'sma 2/29/2000 20:45'!valueWithArguments: anArray	^ receiver perform: selector withArguments: arguments , anArray! !!Object class methodsFor: 'private' stamp: 'sma 2/29/2000 20:12'!initializeEventsFields	EventsFields _ IdentityDictionary new	"Object initializeEventsFields"! !!MessageSend class methodsFor: 'instance creation' stamp: 'sma 2/29/2000 20:44'!receiver: anObject selector: aSymbol	^ self receiver: anObject selector: aSymbol arguments: #()! !!MessageSend class methodsFor: 'instance creation' stamp: 'sma 2/29/2000 20:44'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!MessageSend class methodsFor: 'instance creation' stamp: 'sma 2/29/2000 20:39'!receiver: anObject selector: aSymbol arguments: anArray	^ self new		receiver: anObject;		selector: aSymbol;		arguments: anArray! !Object initializeEventsFields!Object removeSelector: #events!Object removeSelector: #trigger:with:with:!