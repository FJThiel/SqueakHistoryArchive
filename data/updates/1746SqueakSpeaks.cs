'From Squeak2.7alpha of 25 November 1999 [latest update: #1671] on 22 December 1999 at 4:12:15 am'!"Change Set:		SqueakSpeaksDate:			22 December 1999Author:			Luciano NotarfrancescoThis Change Set includes a simple Text-To-Speech system for english with animated 2D faces.The speech synthesis part of the system consists of a Klatt synthesizer and a basic segmental synthesizer. For examples on the TTS browse the 'examples' and 'examples-others' method categories in the Speaker class. For singing voices, see the 'examples' method category in the DECTalkReader class. For more information on the current Klatt synthesizer, see the class comment in the KlattSynthesizer class.You will need the Klatt plugin in order to use this system; to translate the plugin to C do:	KlattSynthesizerPlugin translateDoInlining: true"!Smalltalk at: #KlattResonatorIndices put: Dictionary new!Object subclass: #Clause	instanceVariableNames: 'string phrases accent '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!Object subclass: #DECTalkReader	instanceVariableNames: 'stream phonemes durations events currentDuration currentPitch f0Contour '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Support'!DECTalkReader class	instanceVariableNames: ''!EllipseMorph subclass: #EyeMorph	instanceVariableNames: 'iris '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Gestures'!Morph subclass: #FaceMorph	instanceVariableNames: 'leftEye leftEyebrow rightEye rightEyebrow lips '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Gestures'!EllipseMorph subclass: #HeadMorph	instanceVariableNames: 'face queue '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Gestures'!FloatArray variableWordSubclass: #KlattFrame	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Klatt'!KlattFrame class	instanceVariableNames: ''!AlignmentMorph subclass: #KlattFrameMorph	instanceVariableNames: 'frame lastSnapshot glottal '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Klatt'!Object subclass: #KlattSegment	instanceVariableNames: 'name features rank duration parameters '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Klatt'!KlattSegment class	instanceVariableNames: ''!Object subclass: #KlattSegmentParameter	instanceVariableNames: 'selector steady fixed proportion internal external '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Klatt'!Object subclass: #KlattSegmentSet	instanceVariableNames: 'phonemes segments '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Klatt'!KlattSegmentSet class	instanceVariableNames: ''!Object subclass: #KlattSynthesizer	instanceVariableNames: 'resonators frame pitch t0 nper nopen nmod a1 a2 x1 x2 b1 c1 glast vlast nlast periodCount samplesCount seed cascade samplesPerFrame samplingRate '	classVariableNames: 'Epsilon '	poolDictionaries: 'KlattResonatorIndices '	category: 'Speech-Klatt'!KlattSynthesizer class	instanceVariableNames: ''!InterpreterPlugin subclass: #KlattSynthesizerPlugin	instanceVariableNames: 'resonators frame pitch t0 nper nopen nmod a1 a2 x1 x2 b1 c1 glast vlast nlast periodCount samplesCount seed cascade samplesPerFrame samplingRate '	classVariableNames: 'A1v A2f A2v A3f A3v A4f A4v A5f A6f Anv Aspiration Atv B1 B2 B2f B3 B3f B4 B4f B5 B5f B6 B6f Bnp Bnz Btp Btz Bypass Db1 Df1 Diplophonia Epsilon F0 F1 F2 F3 F4 F5 F6 Flutter Fnp Fnz Friction Ftp Ftz Gain Jitter PI Ra Rk Ro Shimmer Turbulence Voicing '	poolDictionaries: 'KlattResonatorIndices '	category: 'Speech-Klatt'!KlattSynthesizerPlugin class	instanceVariableNames: ''!Object subclass: #LiljencrantsFant	instanceVariableNames: 'ro ra rk a1 a2 x1 x2 b1 c1 n0 ne '	classVariableNames: 'Epsilon '	poolDictionaries: ''	category: 'Speech-Klatt'!LiljencrantsFant class	instanceVariableNames: ''!CurveMorph subclass: #LipsMorph	instanceVariableNames: 'newVertices newScale '	classVariableNames: 'PhoneticArticulations '	poolDictionaries: ''	category: 'Speech-Gestures'!LipsMorph class	instanceVariableNames: ''!Object subclass: #PHOReader	instanceVariableNames: 'stream phonemes events pitches time '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Support'!PHOReader class	instanceVariableNames: ''!Object subclass: #Phoneme	instanceVariableNames: 'name properties '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Phonetics'!Phoneme class	instanceVariableNames: ''!Object subclass: #PhonemeSet	instanceVariableNames: 'name description phonemes specials '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Phonetics'!PhonemeSet class	instanceVariableNames: 'arpabet '!Object subclass: #PhoneticRule	instanceVariableNames: 'left text right phonemes '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Phonetics'!PhoneticRule class	instanceVariableNames: ''!Object subclass: #PhoneticTranscriber	instanceVariableNames: 'phonemes rules lexicon '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Phonetics'!PhoneticTranscriber class	instanceVariableNames: ''!Object subclass: #Phrase	instanceVariableNames: 'string words accent '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!AbstractSound subclass: #QueueSound	instanceVariableNames: 'startTime sounds currentSound done '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Support'!Object subclass: #Speaker	instanceVariableNames: 'pitch range loudness speed transcriber voice visitors '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!Speaker class	instanceVariableNames: ''!Object subclass: #Syllable	instanceVariableNames: 'phonemes accent events '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!Object subclass: #UtteranceVisitor	instanceVariableNames: 'clause phrase word syllable '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!UtteranceVisitor subclass: #DurationsVisitor	instanceVariableNames: 'inherents lowers speed '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!DurationsVisitor class	instanceVariableNames: ''!UtteranceVisitor subclass: #F0RenderingVisitor	instanceVariableNames: 'pitch range contour '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!F0RenderingVisitor class	instanceVariableNames: ''!UtteranceVisitor subclass: #IntonationVisitor	instanceVariableNames: 'functionWords '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!IntonationVisitor class	instanceVariableNames: ''!Object subclass: #Voice	instanceVariableNames: 'name sound '	classVariableNames: 'Voices '	poolDictionaries: ''	category: 'Speech-Events'!Voice subclass: #CompositeVoice	instanceVariableNames: 'voices '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!Voice subclass: #GesturalVoice	instanceVariableNames: 'head '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Gestures'!Voice subclass: #KlattVoice	instanceVariableNames: 'segments lastEvent lastEventTime left current right synthesizer patternFrame breathiness tract '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Klatt'!Voice class	instanceVariableNames: ''!KlattVoice class	instanceVariableNames: ''!Object subclass: #VoiceEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!VoiceEvent subclass: #CompositeEvent	instanceVariableNames: 'timedEvents '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!CompositeEvent class	instanceVariableNames: ''!VoiceEvent subclass: #GesturalEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!GesturalEvent subclass: #GazeGesturalEvent	instanceVariableNames: 'point '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!GesturalEvent subclass: #MoodGesturalEvent	instanceVariableNames: 'state '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!VoiceEvent subclass: #PhoneticEvent	instanceVariableNames: 'phoneme pitchPoints duration loudness '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!GesturalEvent subclass: #TalkGesturalEvent	instanceVariableNames: 'phoneme '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Events'!Object subclass: #VoiceParameter	instanceVariableNames: 'origin points stack '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-Support'!VoiceParameter class	instanceVariableNames: ''!Object subclass: #Word	instanceVariableNames: 'string syllables '	classVariableNames: ''	poolDictionaries: ''	category: 'Speech-TTS'!!KlattSynthesizer class methodsFor: 'class initialization' stamp: 'len 9/25/1999 23:14'!initialize	"	KlattSynthesizer initialize	"	Epsilon _ 1.0e-04.	self initializePool! !!KlattSynthesizer class methodsFor: 'class initialization' stamp: 'len 12/19/1999 05:30'!initializePool	| dict |	(Smalltalk includesKey: #KlattResonatorIndices)		ifFalse: [Smalltalk declare: #KlattResonatorIndices from: Undeclared].	(Smalltalk at: #KlattResonatorIndices) isNil		ifTrue: [(Smalltalk associationAt: #KlattResonatorIndices) value: Dictionary new].	dict _ Smalltalk at: #KlattResonatorIndices.	#(Rnpp Rtpp R1vp R2vp R3vp R4vp R2fp R3fp R4fp R5fp R6fp R1c R2c R3c R4c R5c R6c R7c R8c Rnpc Rnz Rtpc Rtz Rout)		doWithIndex: [ :each :i | dict at: each asSymbol put: i]! !KlattSynthesizer initialize!!Clause commentStamp: '<historical>' prior: 0!My instances are clauses. They can carry a phrase accent (applicable to their last phrase) and a boundary tone: 'L- L%' (for declarative sentences in American English), 'H- H%' (for Yes-No questions), etc.!!Clause methodsFor: 'accessing' stamp: 'len 12/12/1999 22:46'!accent	^ accent! !!Clause methodsFor: 'accessing' stamp: 'len 12/12/1999 22:46'!accent: aString	accent _ aString! !!Clause methodsFor: 'accessing' stamp: 'len 12/13/1999 02:32'!accept: anObject	anObject clause: self! !!Clause methodsFor: 'accessing' stamp: 'len 12/8/1999 17:53'!events	| answer |	answer _ CompositeEvent new.	self phrases do: [ :each | answer addAll: each events].	^ answer! !!Clause methodsFor: 'accessing' stamp: 'len 12/8/1999 17:50'!lastSyllable	^ self phrases last lastSyllable! !!Clause methodsFor: 'accessing' stamp: 'len 12/8/1999 17:49'!phrases	^ phrases! !!Clause methodsFor: 'accessing' stamp: 'len 12/8/1999 17:50'!phrases: aCollection	phrases _ aCollection! !!Clause methodsFor: 'accessing' stamp: 'len 12/12/1999 22:22'!string	^ string! !!Clause methodsFor: 'accessing' stamp: 'len 12/12/1999 22:22'!string: aString	string _ aString! !!Clause methodsFor: 'enumarating' stamp: 'len 12/13/1999 01:19'!eventsDo: aBlock	self phrases do: [ :phrase | phrase eventsDo: aBlock]! !!Clause methodsFor: 'enumarating' stamp: 'len 12/14/1999 04:22'!syllablesDo: aBlock	self wordsDo: [ :each | each syllables do: aBlock]! !!Clause methodsFor: 'enumarating' stamp: 'len 12/13/1999 02:40'!wordsDo: aBlock	self phrases do: [ :each | each words do: aBlock]! !!Clause methodsFor: 'printing' stamp: 'len 12/8/1999 18:17'!printOn: aStream	self phrases do: [ :each | aStream print: each; nextPutAll: '- ']! !!DECTalkReader methodsFor: 'initialization' stamp: 'len 12/20/1999 03:28'!initialize	phonemes _ PhonemeSet dectalkToArpabet.	events _ CompositeEvent new.	currentDuration _ 80.	currentPitch _ 100.	f0Contour _ VoiceParameter new.	durations _ Dictionary new.	#(	('ae'	230.0	80.0)	('aa'	240.0	100.0)	('ax'	120.0	60.0)	('er'	180.0	80.0)	('ay'	250.0	150.0)	('aw'	240.0	100.0)	('b'		85.0		60.0)	('ch'	70.0		50.0)	('d'		75.0		50.0)	('dh'	50.0		30.0)	('eh'	150.0	70.0)	('ea'	270.0	130.0)	('ey'	180.0	100.0)	('f'		100.0	80.0)	('g'		80.0		60.0)	('hh'	80.0		20.0)	('ih'	135.0	40.0)	('ia'	230.0	100.0)	('iy'	155.0	55.0)	('jh'	70.0		50.0)	('k'		80.0		60.0)	('l'		80.0		40.0)	('m'		70.0		60.0)	('n'		60.0		50.0)	('ng'	95.0		60.0)"	('oh'	240.0	130.0)"	('oy'	280.0	150.0)	('ao'	240.0	130.0)	('ow'	220.0	80.0)	('p'		90.0		50.0)	('r'		80.0		30.0)	('s'		105.0	60.0)	('sh'	105.0	80.0)	('t'		75.0		50.0)	('th'	90.0		60.0)	('uh'	210.0	70.0)	('ua'	230.0	110.0)	('ah'	160.0	60.0)	('uw'	230.0	150.0)	('v'		60.0		40.0)	('w'		80.0		60.0)	('y'		80.0		40.0)	('z'		75.0		40.0)	('zh'	70.0		40.0)	('sil'	100.0	100.0)) do: [ :each |		durations at: (PhonemeSet arpabet at: each first) put: each second / 1000.0]! !!DECTalkReader methodsFor: 'accessing' stamp: 'len 12/20/1999 03:28'!defaultDurationFor: aPhoneme	^ durations at: aPhoneme ifAbsent: [0.080]! !!DECTalkReader methodsFor: 'accessing' stamp: 'len 12/20/1999 03:04'!events	^ events! !!DECTalkReader methodsFor: 'accessing' stamp: 'len 12/20/1999 03:04'!phonemes	^ phonemes! !!DECTalkReader methodsFor: 'accessing' stamp: 'len 12/20/1999 03:04'!stream: aStream	stream _ aStream! !!DECTalkReader methodsFor: 'reading' stamp: 'len 12/20/1999 03:37'!addPitches	| offset |	offset _ 0.0.	events do: [ :each |		each pitchPoints: (self pitchesBetween: offset and: offset + each duration).		offset _ offset + each duration].! !!DECTalkReader methodsFor: 'reading' stamp: 'len 12/20/1999 04:31'!nextPhoneme	| try try2 phon |	try _ stream next asString.	(',.;-' includes: try first) ifTrue: [^ phonemes at: 'sil'].	try2 _ try, stream peek asString.	(phon _ phonemes at: try2 ifAbsent: []) notNil ifTrue: [stream next. ^ phon].	^ phonemes at: try! !!DECTalkReader methodsFor: 'reading' stamp: 'len 12/20/1999 03:37'!pitchesBetween: t1 and: t2	| step |	step _ (t2 - t1 / 0.035) asInteger + 1. "step small enough"	^ (t1 to: t2 by: t2 - t1 / step) collect: [ :each | each - t1 @ (f0Contour at: each)]! !!DECTalkReader methodsFor: 'reading' stamp: 'len 12/21/1999 02:36'!read	| phoneme time |	time _ 0.	[[stream atEnd not and: [stream peek isSeparator]] whileTrue: [stream next].	stream atEnd]		whileFalse: [phoneme _ self nextPhoneme.					currentDuration _ self defaultDurationFor: phoneme.					stream peek = $< ifTrue: [self readPitchAndDuration].					f0Contour at: time + (currentDuration / 2.0 min: 0.1) put: currentPitch.					time _ time + currentDuration.					f0Contour at: time put: currentPitch.					events add: (PhoneticEvent new phoneme: phoneme; duration: currentDuration; loudness: 1.0)].	self addPitches! !!DECTalkReader methodsFor: 'reading' stamp: 'len 12/20/1999 04:36'!readPitchAndDuration	| tokens code |	stream next.	tokens _ (stream upTo: $>) findTokens: ','.	currentDuration _ tokens first asNumber / 1000.0.	tokens size > 1 ifFalse: [^ self].	code _ tokens last asNumber.	currentPitch _ code > 37 ifTrue: [code] ifFalse: [AbstractSound pitchForMIDIKey: 35 + code]! !!DECTalkReader class methodsFor: 'instance creation' stamp: 'len 12/20/1999 03:52'!eventsFromStream: aStream	^ self new stream: aStream; read; events! !!DECTalkReader class methodsFor: 'instance creation' stamp: 'len 12/20/1999 03:52'!eventsFromString: aString	^ self eventsFromStream: (ReadStream on: aString)! !!DECTalkReader class methodsFor: 'instance creation' stamp: 'len 12/20/1999 03:52'!new	^ super new initialize! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:14'!daisy	"	DECTalkReader daisy playOn: KlattVoice new delayed: 10000	"	^ self eventsFromString: '_<50,22>dey<400,22>ziy<400,19>dey<400,15>ziy<400,10>gih<200,12>vmiy<200,14>yurr<200,15>ae<400,12>nsax<200,15>rduw<400,10>.ay<400,17>mhxae<400,22>fkrey<400,19>ziy<400,15>ao<200,12>lfao<200,14>rdhax<200,15>lah<400,17>vao<200,19>vyu<400,17>.ih<200,19>twow<200,20>ntbiy<200,19>ax<200,17>stay<400,22>lih<200,19>shmae<200,17>rih<400,15>jh<50,15>.ay<200,17>kae<400,19>ntax<200,15>fow<400,12>rdax<200,15>kae<200,12>rih<400,10>jh<50,10>.bah<200,10>tyu<400,15>lluh<200,19>kswiy<400,17>tah<200,10>pao<400,15>ndhax<200,19>siy<400,17>t<50,17>.ao<200,17>vax<200,19>bay<200,22>six<200,19>kel<200,15>bih<400,17>ltfao<200,10>rtuw<800,15>.'! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:48'!flower	"	DECTalkReader flower playOn: KlattVoice new delayed: 15000	"	^ self eventsFromString: '_<25,22>ow<200,22>flaw<400,22>rax<200,20>vskao<400,18>ao<200,18>tlae<800,13>nd<200,13>weh<200,13>nwih<400,18>lwiy<200,22>siy<800,20>yu<200,20>rlay<400,18>kax<200,20>geh<1600,22>n<25,22>dhax<200,22>tfao<300,23>ao<100,22>tae<200,23>nday<400,25>d<200,25>fao<800,18>r<25,18>yu<200,13>rwiy<400,20>bih<200,20>t hxih<200,20>ih<200,18>lae<200,20>ndgleh<400,22>nae<200,23>ndstuh<400,22>dax<200,20>geh<600,18>nst hxih<800,13>m<200,13>praw<200,22>deh<300,23>eh<100,22>dwax<200,23>rdzaa<400,25>aa<200,25>rmih<800,18>ih<200,18>ae<200,22>ndseh<200,23>eh<200,22>nt hxih<200,20>mhxow<300,22>ow<100,20>ow<200,18>mwax<800,18>ax<200,18>rdtey<200,18>thih<400,16>nxkax<200,20>geh<800,18>eh<400,18>n<200,18>_<600,22>dhax<200,22>hxih<400,22>lzax<200,20>rbey<400,18>rr<200,18>naw<800,13>ae<200,13>ndao<400,18>tah<200,22>mliy<800,20>vzlay<200,20>thih<400,18>kax<200,20>ndstih<800,22>ih<800,22>l<25,22>ow<200,22>rlae<300,23>nddhax<100,22>tih<200,23>zlao<400,25>ao<200,25>stnaw<800,18>wih<200,13>chdhow<400,20>zsow<200,20>diy<200,20>ax<200,18>lih<200,20>hxeh<400,22>ldhax<200,23>tstuh<400,22>dax<200,20>geh<400,18>eh<200,18>nst hxih<800,13>m<200,13>praw<200,22>deh<300,23>eh<100,22>dwax<200,23>rdzaa<400,25>aa<200,25>rmih<800,18>ih<200,18>ae<200,22>ndseh<200,23>eh<200,22>nt hxih<200,20>mhxow<300,22>ow<100,20>ow<200,18>mwax<800,18>ax<200,18>rdtey<200,18>thih<400,16>nxkax<200,20>geh<1200,18>n<200,18>_<600,22>dhow<200,22>zdey<400,22>zax<200,20>rpae<400,18>ae<200,18>stnaw<800,13>ae<200,13>ndih<400,18>ndhax<200,22>pae<800,20>stdhey<200,20>mah<400,18>strix<200,20>mey<800,22>ey<800,22>n<25,22>bah<200,22>twiy<300,23>kae<100,22>nstih<200,23>lray<600,25>znaw<800,18>ae<200,13>ndbiy<400,20>dhax<200,20>ney<200,20>shax<200,18>nax<200,20>geh<400,22>ndhax<200,23>tstuh<400,22>dax<200,20>geh<600,18>nst hxih<800,13>m<200,13>praw<200,22>deh<300,23>eh<100,22>dwax<200,23>rdzaa<400,25>aa<200,25>rmih<800,18>ih<200,18>ae<200,22>ndseh<200,23>eh<200,22>nt hxih<200,20>mhxow<300,22>ow<100,20>ow<200,18>mwax<800,18>ax<200,18>rdtey<200,18>thih<400,16>nxkax<200,20>geh<1200,18>n<200,18>.'! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:43'!great	"	(DECTalkReader great pitchBy: 0.5) playOn: (KlattVoice new tract: 19; flutter: 0.5) delayed: 10000	"	^ self eventsFromString: '_<50,20>ax<200,20>_<1>ax<500,22>_<10>ow<300,20>yxeh<1000,17>say<200,15>mdhax<80,13>grey<1000,15>t_priy<200,17>iy<200,18>teh<200,17>eh<200,15>ndrr<1600,13>_<200,13>priy<200,13>teh<1000,22>ndih<200,22>nxdhae<100,22>day<1000,18>mduh<200,20>ix<200,22>nweh<1600,20>l<600,20>_<60,25>may<300,25>niy<1200,22>dix<200,22>zsah<1000,24>chay<200,22>priy<200,24>teh<1000,25>ndtuh<200,22>_<10>uw<200,25>mah<1000,20>ch<100,20>_<20,20>ay<300,20>mlow<300,20>neliy<800,17>bah<200,13>tnow<1000,15>wah<200,13>nkae<200,15>nteh<1800,13>l<400,13>_<50,20>ax<200,20>_<1>ax<500,22>_<1>ow<300,20>yxeh<1000,17>say<200,15>mdhax<80,13>grey<1000,15>t_priy<200,17>iy<200,18>teh<200,17>eh<200,15>ndrr<1800,13>_<10,13>ah<200,13>drih<1000,22>ftih<50,22>nax<200,22>wrr<1000,18>ldax<200,20>vmay<200,22>ax<200,22>_<1>ow<1400,20>n<600,20>_<60,25>ay<300,25>pley<1100,22>dhax<200,22>gey<1000,24>m<100,24>bah<200,22>tuh<200,24>may<1000,25>riy<200,22>ax<200,25>lshey<600,20>m<400,20>_<20,20>yu<200,20>vleh<200,20>ftmiy<800,17>tuw<200,13>driy<800,15>mao<200,13>lah<200,15>low<1600,13>n<400,13>.'! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:25'!hawaii	"	DECTalkReader hawaii playOn: (KlattVoice new tract: 14.4) delayed: 10000	"	^ self eventsFromString: '_<300> naa<600,23> ay<300,23>t ae<300,22>nd yuw<1200,23> ,<600>ae<600,24>ndbluw<900,25> hxah<300,24> waa<940,23> aa<240,22> aa<240,21> iy<1200,20>,<600> dhah<600,32> naa<600,33> ay<300,33>t ih<300,32>z hxeh<900,30>veh<300,22>n liy<1200,25>,<600> ae<300,30> ae<300,31>nd yu<900,32> aa<300,30>rxhxeh<440,28> veh<440,28>n tuw<440,25> miy<2400,23> ,<600> lah<900,23>vliy<300,22> yuw<1200,23> ,<600> ae<600,24>nd bluw<900,25> hxah<300,24>waa<940,23>-aa<240,22>-aa<240,21>-iy<1200,20>,<600> wih<600,32>dh ao<900,33>lx dhih<300,32>s lah<880,30> v<40,30>liy<300,22> neh<1200,25>s,<600> dheh<300,30> eh<300,31>rx shuh<900,32>d biy<300,27>lah<4140,28> v<60,28> ,<600> kah<900,25>m wih<300,32>dh miy<1800,30> ,<600>waa<400,28> ay<200,28>lx dhah<600,25> muw<300,28>n ih<300,25>z aa<300,28>ndhah<300,25> siy<2400,23> ,<600> dhah<600,24> naa<600,25> ay<300,25>tih<300,32>z yxah<1200,30>nx ,<600> ae<600,28>nd sow<600,25>aa<600,28>rx-wiy<4200,30> ,<600> driy<900,23>mz kah<300,22>m truw<1000,23>uw<200,23> ,<600> ih<600,24>nbluw<900,25> hxah<300,24> waa<940,23> aa<240,22> aa<240,21> iy<1200,20>,<600> ae<600,32>nd maa<600,33> iy<300>n kuh<300,32>d ao<900,30>lxkah<300,22>m truw<1200,25> ,<600> dhih<300,30> ih<300,31>s mae<900,32>jhih<330,27>k naa<600,28> ay<350,28>t ah<350,27>v naa<600,28> ay<350,28>ts,<40> wih<380,27>dh yuw<1000,28>-uw<600,455>-uw<1800,35>.'! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:52'!startrek	"	DECTalkReader startrek playOn: KlattVoice new delayed: 15000	"	^ self eventsFromString: '_<50,17>dhey<400,17>rsklih<100,17>nxao<100,17>nzao<100,17>ndhax<100,17>staa<100,20>rbao<100,20>rdbaw<200,17>staa<100,18>rbao<100,18>rdbaw<200,15>staa<100,17>rbao<100,17>rdbaw<200,13>.dhey<100,17>rsklih<100,17>nxao<100,17>nzao<100,17>ndhax<100,17>staa<100,20>rbao<100,20>rdbaw<200,17>staa<100,18>rbao<100,18>rdbaw<200,15>jhih<400,13>m<50,13>._<50,17>ih<400,17>tslay<100,17>fjhih<100,17>mbah<100,17>tnao<50,20>tax<50,20>zwiy<100,20>now<100,17>ih<200,17>tnao<50,18>tax<50,18>zwiy<100,18>now<100,15>ih<200,15>tnao<50,17>tax<50,17>zwiy<100,17>now<100,13>ih<200,13>t<50,13>.ih<100,17>tslay<100,17>fjhih<100,17>mbah<100,17>tnao<50,20>tax<50,20>zwiy<100,20>now<100,17>ih<200,17>tnao<50,18>tax<50,18>zwiy<100,18>now<100,15>ih<200,15>tkae<200,13>ptix<200,13>n<50,13>._<50,17>ih<400,17>tswah<100,17>rsdhae<100,17>ndhae<100,17>t_hxiy<100,20>zdeh<200,20>djhih<200,17>mdeh<200,18>djhih<200,15>mdeh<200,17>djhih<200,13>m<50,13>.ih<100,17>tswah<100,17>rsdhae<100,17>ndhae<100,17>t_hxiy<100,20>zdeh<200,20>djhih<200,17>mdeh<200,18>djhih<200,15>mdeh<400,13>d<50,13>._<50,17>wiy<400,17>kah<100,17>mih<100,17>npiy<200,17>sshuh<100,20>tuh<100,20>kih<200,17>lshuh<100,18>tuh<100,18>kih<200,15>lshuh<100,17>tuh<100,17>kih<200,13>l<50,13>.wiy<100,17>kah<100,17>mih<100,17>npiy<200,17>sshuh<100,20>tuh<100,20>kih<200,17>lshuh<100,18>tuh<100,18>kih<200,15>lmeh<400,13>n<50,13>._<50,17>yxih<400,17>kaa<100,17>naa<100,17>chey<100,17>njhdhax<50,17>lao<50,20>zax<100,20>fih<100,17>zih<100,17>kslao<50,18>zax<100,18>fih<100,15>zih<100,15>kslao<50,17>zax<100,17>fih<100,13>zih<100,13>ks<50,13>.yxih<400,17>kaa<100,17>naa<100,17>chey<100,17>njhdhax<50,17>lao<50,20>zax<100,20>fih<100,17>zih<100,17>kslao<50,18>zax<100,18>fih<100,15>zih<100,15>kskaa<200,13>ptix<200,13>n<50,13>.'! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:52'!startrek1	"	DECTalkReader startrek1 playOn: KlattVoice new delayed: 5000	"	^ self eventsFromString: '_<50,17>dhey<400,17>rsklih<100,17>nxao<100,17>nzao<100,17>ndhax<100,17>staa<100,20>rbao<100,20>rdbaw<200,17>staa<100,18>rbao<100,18>rdbaw<200,15>staa<100,17>rbao<100,17>rdbaw<200,13>.'! !!DECTalkReader class methodsFor: 'examples' stamp: 'len 12/20/1999 04:38'!vermont	"	(DECTalkReader vermont pitchBy: 0.5) playOn: (KlattVoice new tract: 18.5; turbulence: 59) delayed: 15000	"	^ self eventsFromString: 'peh<400,25> niy<400,23>z ih<400,20>n ah<400,18> striy<1200,20>m,<400> fao<400,25> lih<400,23>nx liy<500,20>vz ,<100> ah<200,16>v sih<200,18> kah<200,20> mao<1000,12>rx ,<200> muw<400,20>n lay<400,18>tih<400,16>n vrr<400,13> maa<1200,16>nt ,<400> ay<400,25> siy<400,23> fih<400,20>nx grr<400,18> wey<1200,20>vz ,<400> skiy<400,25> trae<300,23>lxz  ,<100> aa<600,20>n ah<200,16> maw<200,18>n tih<200,20>n saa<800,12>-ay<200,12>d ,<200> snow<400,20> lay<400,18>tih<400,16>n vrr<400,13> maa<1200,16>nt ,<400> teh<200,15> lah<200,15>grae<200,15>f key<400,15> bah<300,15>lxz ,<100> dhey<200,15> sih<200,15>nx daw<400,15>n dhah<200,15> hxay<200,15> wey<300,15> ,<100> ae<200,15>ndtrae<200,15> vuh<200,15>lx iy<200,15>ch beh<500,27>nd,<100> ih<200,25>n dhah<200,27> row<1200,24>d ,<400> piy<200,16> pah<200,16>lx hxuw<200,16>miy<200,16>t ,<200> ih<400,16>n-dhih<200,16>s-row<200,16>-mae<400,16>n-tih<160,16>k ,<40> seh<200,16> tih<300,16>nx ,<100> aa<200,16>rx sow<200,16>hxih<200,16>p nah<200,16> tay<400,28>zd ,<200> bay<200,26> dhah<200,28>lah<900,25>v liy<700,24> ,<200> iy<400,25>v nih<400,23>nx sah<400,20>mrr<400,18> briy<1200,20>z ,<400> wao<400,25>rx blih<400,23>nx ah<400,20>v,<200> ah<200,16> meh<200,18> dow<200,20> laa<800,12>rxk ,<400> muw<400,20>nlay<400,18>t ih<400,16>n vrr<400,13> maa<1300,16>nt ,<400>iy<40,12>-yuw<280,12> ae<350,13>n day<420,16> ,<60> ae<340,20>ndmuw<380,25>n lay<340,27>t ,<100> ih<500,24>n vrr<540,26> maa<2000,23>nt.'! !!EyeMorph methodsFor: 'initialization' stamp: 'len 9/6/1999 23:36'!initialize	super initialize.	self color: (Color r: 1.0 g: 0.968 b: 0.935).	self borderColor: Color black; borderWidth: 1.	self extent: 30 @ 37.	self addMorphFront: (iris _ EllipseMorph new extent: 6 @ 6; borderWidth: 0; color: Color black).	self lookAtFront! !!EyeMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 15:40'!iris	^ iris! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:25'!closeEyelid	self iris delete.	self position: self position + (0 @ (self extent y // 2)).	self extent: self extent x @ 2! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/22/1999 15:57'!dilate: amount	| irisCenter |	irisCenter _ self iris center.	self iris extent: self iris extent * amount.	self iris position: irisCenter - self iris center + self iris position! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/24/1999 00:48'!lookAt: aPoint	| theta scale |	(self containsPoint: aPoint) ifTrue: [self iris align: iris center with: aPoint. ^ self].	theta _ (aPoint - self center) theta.	scale _ (aPoint - self center) r / 100.0 min: 1.0.	self iris align: self iris center with: self center + (theta cos @ theta sin * self extent / 3.0 * scale) rounded! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/22/1999 22:03'!lookAtFront	self iris position: self center - self iris center + self iris position! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/22/1999 22:23'!lookAtMorph: aMorph	self lookAt: aMorph center! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/23/1999 22:49'!openEyelid	self extent: self extent x @ (self extent x * 37.0 / 30.0) rounded.	self position: self position - (0 @ (self extent y // 2)).	self addMorphFront: self iris! !!EyeMorph methodsFor: 'actions' stamp: 'len 8/24/1999 01:18'!openness: aNumber	| previousCenter |	previousCenter _ self center.	self extent: self extent x @ (self extent x * 37.0 / 30.0 * aNumber) rounded.	self align: self center with: previousCenter.	(self containsPoint: self iris center) ifFalse: [self lookAtFront]! !!FaceMorph methodsFor: 'initialization' stamp: 'len 8/22/1999 23:27'!initialize	super initialize.	color _ Color transparent.	self addMorph: (leftEye _ EyeMorph new).	self addMorph: (rightEye _ EyeMorph new).	self addMorph: (lips _ LipsMorph new).	leftEye position: self position.	rightEye position: leftEye extent x @ 0 + leftEye position.	lips position: (0 @ 20 + (leftEye bottomRight + rightEye bottomLeft - lips extent // 2)).	self bounds: self fullBounds! !!FaceMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 22:21'!leftEye	^ leftEye! !!FaceMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 19:47'!lips	^ lips! !!FaceMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 22:21'!rightEye	^ rightEye! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:23'!closeEyelids	leftEye closeEyelid.	rightEye closeEyelid! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/24/1999 01:18'!grin	self leftEye openness: (0.2 to: 1.0 by: 0.1) atRandom.	self rightEye openness: (0.2 to: 1.0 by: 0.1) atRandom.	self lips grin! !!FaceMorph methodsFor: 'actions' stamp: 'len 9/7/1999 02:29'!happy	self lips smile! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/22/1999 22:00'!hideTonge	self lips hideTonge! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/22/1999 22:21'!lookAt: aPoint	self leftEye lookAt: aPoint.	self rightEye lookAt: aPoint! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/23/1999 22:51'!lookAtFront	self leftEye lookAtFront.	self rightEye lookAtFront! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/24/1999 01:05'!lookAtHand	| hand |	self isInWorld ifFalse: [^ self].	hand _ (self world activeHand) ifNil: [self world primaryHand].	self lookAtMorph: hand! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/24/1999 01:05'!lookAtMorph: aMorph	self leftEye lookAtMorph: aMorph.	self rightEye lookAtMorph: aMorph! !!FaceMorph methodsFor: 'actions' stamp: 'len 9/7/1999 02:25'!neutral	self lips neutral! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:23'!openEyelids	leftEye openEyelid.	rightEye openEyelid! !!FaceMorph methodsFor: 'actions' stamp: 'len 8/22/1999 23:18'!say: aString	self lips showBalloon: aString! !!FaceMorph methodsFor: 'geometry' stamp: 'len 8/24/1999 01:27'!mustachePosition	^ self nosePosition + self lips center // 2! !!FaceMorph methodsFor: 'geometry' stamp: 'len 8/24/1999 01:26'!nosePosition	^ self center * 2 + self lips center // 3! !!FaceMorph methodsFor: 'drawing' stamp: 'len 8/22/1999 21:56'!drawNoseOn: aCanvas	| nosePosition |	nosePosition _ self center * 2 + self lips center // 3.	aCanvas fillOval: (nosePosition- (3@0) extent: 2 @ 2) color: Color black.	aCanvas fillOval: (nosePosition + (3@0) extent: 2 @ 2) color: Color black! !!FaceMorph methodsFor: 'drawing' stamp: 'len 8/22/1999 19:02'!drawOn: aCanvas	super drawOn: aCanvas.	self drawNoseOn: aCanvas! !!FaceMorph methodsFor: 'stepping and presenter' stamp: 'len 8/24/1999 01:22'!step	| amount |	super step.	10 atRandom = 1		ifTrue: [[self lips perform: #(smile horror surprise sad grin) atRandom.				 (Delay forMilliseconds: 2000 atRandom) wait.				 self lips perform: #(neutral neutral smile sad) atRandom] fork].	5 atRandom = 1		ifTrue: [[self closeEyelids.				 (Delay forMilliseconds: 180) wait.				 self openEyelids.				 2 atRandom = 1 ifTrue: [self lookAtFront]] fork.				^ self].	"20 atRandom = 1 ifTrue: [(self perform: #(leftEye rightEye) atRandom) closeEyelid]."	20 atRandom = 1 ifTrue: [amount _ (0.2 to: 1.0 by: 0.01) atRandom.							 self leftEye openness: amount. self rightEye openness: amount].	3 atRandom = 1 ifTrue: [self lookAtHand. ^ self].	3 atRandom = 1 ifTrue: [self lookAtFront. ^ self].	3 atRandom = 1 ifTrue: [self lookAtMorph: self world submorphs atRandom]! !!FaceMorph methodsFor: 'stepping and presenter' stamp: 'len 9/13/1999 00:18'!stepTime	^ 1000! !!HeadMorph methodsFor: 'initialization' stamp: 'len 9/26/1999 17:20'!initialize	super initialize.	self color: self randomSkinColor.	self face: FaceMorph new.	self extent: self face extent * (1.5 @ 1.7).	self face align: self face center with: self center + (0 @ self height // 10).	self addRandomFurnitures.	queue _ SharedQueue new! !!HeadMorph methodsFor: 'accessing-private' stamp: 'len 9/6/1999 00:43'!queue	^ queue! !!HeadMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 23:25'!face	^ face! !!HeadMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 23:25'!face: aFaceMorph	face notNil ifTrue: [face delete].	self addMorphFront: (face _ aFaceMorph)! !!HeadMorph methodsFor: 'accessing' stamp: 'len 9/7/1999 01:38'!playEvent: event at: time	self queue nextPut: time -> event! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 00:19'!addAfroHair	| hair |	hair _ CurveMorph		vertices: {115@4. 144@20. 166@79. 132@131. 116@93. 88@85. 54@94. 40@134. 2@79. 31@16. 79@1}		color: self randomHairColor		borderWidth: 1		borderColor: Color black.	hair extent: (hair extent * (self width / hair width * 1.9)) rounded.	hair align: hair center with: self center x @ self top.	self addMorphFront: hair! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 9/13/1999 00:51'!addBeret	| beret pompon |	beret _ CurveMorph		vertices: {66@1. 90@14. 106@22. 114@35. 98@43. 55@35. 20@46. 2@38. 8@23. 23@13. 39@7}		color: Color random		borderWidth: 1		borderColor: Color black.	beret extent: (beret extent * (self width / beret width * 4 / 3)) rounded.	beret align: beret center x @ beret bottom with: self center x @ self face top.	pompon _ EllipseMorph new color: beret color; borderWidth: 1; borderColor: Color black; extent: beret height // 2.	pompon align: pompon center with: beret center x @ beret top.	beret addMorphFront: pompon.	self addMorphFront: beret! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 02:26'!addEars	| leftEar rightEar |	leftEar _ EllipseMorph new color: self color; extent: self height // 10 @ (self height // 7).	rightEar _ leftEar copy.	leftEar align: leftEar center with: self left @ self center y.	rightEar align: rightEar center with: self right @ self center y.	self addMorphBack: leftEar; addMorphBack: rightEar! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/23/1999 12:57'!addGlasses	| glass glass2 diameter |	diameter _ self face leftEye height * 2 // 3.	glass _ EllipseMorph new extent: diameter @ diameter; color: (Color yellow alpha: 0.5).	glass2 _ glass copy.	glass align: glass center with: self face leftEye center.	glass2 align: glass2 center with: self face rightEye center.	self addMorph: glass; addMorph: glass2! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/23/1999 23:33'!addHighHat	| hat |	hat _ CurveMorph		vertices: {70@3. 98@11. 94@46. 112@50. 96@58. 53@50. 18@61. 2@58. 24@48. 30@6. 47@6}		color: Color random		borderWidth: 1		borderColor: Color black.	hat extent: (hat extent * (self width / hat width * 4 / 3)) rounded.	hat align: hat center x @ hat bottom with: self center x @ self face top.	self addMorphFront: hat! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 01:40'!addLargeMustache	| mustache |	mustache _ CurveMorph		vertices: {48@4. 75@3. 93@15. 48@9. 3@19. 17@5}		color: self randomHairColor		borderWidth: 1		borderColor: Color black.	mustache extent: (mustache extent * (self width / mustache width)) rounded.	mustache align: mustache center with: self face mustachePosition.	self addMorphFront: mustache! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 9/13/1999 00:52'!addRandomFurnitures	self color: self randomSkinColor.	self perform: #(yourself addBeret addHighHat addAfroHair addShortHair addSpikyHair) atRandom.	self perform: #(yourself yourself addShortMustache) atRandom! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 00:19'!addShortHair	| hair |	hair _ CurveMorph		vertices: {81@3. 101@22. 105@48. 93@65. 76@32. 54@32. 28@35. 11@64. 2@52. 10@15. 45@2}		color: self randomHairColor		borderWidth: 1		borderColor: Color black.	hair extent: (hair extent * (self width / hair width * 1.15)) rounded.	hair align: hair center x @ (hair top * 4 + hair bottom // 5) with: self center x @ self top.	self addMorphFront: hair! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 01:39'!addShortMustache	| mustache |	mustache _ CurveMorph		vertices: {29@1. 54@14. 30@11. 1@15}		color: self randomHairColor		borderWidth: 1		borderColor: Color black.	mustache extent: (mustache extent * (self width / mustache width * 0.5)) rounded.	mustache align: mustache center with: self face mustachePosition.	self addMorphFront: mustache! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 02:14'!addSpikyHair	| hair |	hair _ PolygonMorph		vertices: {83@3. 81@30. 91@27. 111@23. 97@32. 112@37. 99@45. 114@52. 95@53. 55@43. 10@50. 1@40. 14@40. 8@26. 24@37. 15@11. 29@29. 30@16. 36@30. 41@6. 49@31. 54@8. 61@32. 64@1. 70@27}		color: self randomHairColor		borderWidth: 1		borderColor: Color black.	hair extent: (hair extent * (self width / hair width * 1.15)) rounded.	hair align: hair center with: self center x @ self top.	self addMorphFront: hair! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/29/1999 02:53'!addWhiteHat	| stage1 stage2 |	stage1 _ CurveMorph		vertices: {18@1. 93@18. 91@45. 8@40}		color: (Color r: 1.0 g: 0.968 b: 0.935)		borderWidth: 1		borderColor: Color black.	stage1 extent: (stage1 extent * (self width / stage1 width * 1.20)) rounded.	stage2 _ CurveMorph		vertices: {27@7. 81@5. 111@34. 11@28}		color: stage1 color		borderWidth: 1		borderColor: Color black.	stage2 extent: (stage2 extent * (self width / stage2 width * 1.20)) rounded.	stage1 align: stage1 center with: self center x @ self top.	stage2 align: stage2 center with: stage1 center x @ stage1 top.	stage1 addMorphFront: stage2.	self addMorphFront: stage1! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/24/1999 01:51'!randomHairColor	| hairColors |	hairColors _ {Color r: 0.613 g: 0.161 b: 0.0. "red"		Color r: 0.323 g: 0.226 b: 0.0. "dark brown"		Color r: 0.774 g: 0.548 b: 0.0. "light brown"		Color r: 0.968 g: 0.871 b: 0.0. "yellow"		Color r: 0.581 g: 0.581 b: 0.581. "gray"		Color black}.	self submorphs do: [ :each | (hairColors includes: each color) ifTrue: [^ each color]].	^ hairColors atRandom! !!HeadMorph methodsFor: 'furnitures' stamp: 'len 8/29/1999 22:27'!randomSkinColor	^ {Color r: 0.258 g: 0.161 b: 0.0.		Color r: 0.452 g: 0.258 b: 0.0.		Color r: 0.516 g: 0.323 b: 0.0.		Color r: 1.0 g: 0.935 b: 0.645.		Color r: 1.0 g: 0.806 b: 0.548} atRandom! !!HeadMorph methodsFor: 'stepping and presenter' stamp: 'len 9/26/1999 17:25'!step	| now |	super step.	now _ Time millisecondClockValue.	[queue isEmpty not and: [now >= queue peek key]]		whileTrue: [queue next value actOn: self].	self face lips updateShape! !!HeadMorph methodsFor: 'stepping and presenter' stamp: 'len 9/6/1999 23:30'!stepTime	^ 0! !!KlattFrame commentStamp: '<historical>' prior: 0!My instances are frames of parameters which are inputs for KlattSynthesizers. See the class method category 'documentation' for more details.!!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a1v	^ self at: 47! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a1v: aNumber	self at: 47 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a2f	^ self at: 35! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a2f: aNumber	self at: 35 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a2v	^ self at: 48! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a2v: aNumber	self at: 48 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a3f	^ self at: 36! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a3f: aNumber	self at: 36 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a3v	^ self at: 49! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a3v: aNumber	self at: 49 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a4f	^ self at: 37! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a4f: aNumber	self at: 37 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a4v	^ self at: 50! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a4v: aNumber	self at: 50 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a5f	^ self at: 38! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a5f: aNumber	self at: 38 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a6f	^ self at: 39! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!a6f: aNumber	self at: 39 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!anv	^ self at: 46! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!anv: aNumber	self at: 46 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!aspiration	^ self at: 10! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!aspiration: aNumber	self at: 10 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!atv	^ self at: 51! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!atv: aNumber	self at: 51 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b1	^ self at: 14! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b1: aNumber	self at: 14 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b2	^ self at: 18! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b2: aNumber	self at: 18 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b2f	^ self at: 41! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b2f: aNumber	self at: 41 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b3	^ self at: 20! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b3: aNumber	self at: 20 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b3f	^ self at: 42! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b3f: aNumber	self at: 42 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b4	^ self at: 22! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b4: aNumber	self at: 22 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b4f	^ self at: 43! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b4f: aNumber	self at: 43 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b5	^ self at: 24! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b5: aNumber	self at: 24 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b5f	^ self at: 44! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b5f: aNumber	self at: 44 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b6	^ self at: 26! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!b6: aNumber	self at: 26 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b6f	^ self at: 45! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!b6f: aNumber	self at: 45 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!bnp	^ self at: 28! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!bnp: aNumber	self at: 28 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!bnz	^ self at: 30! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!bnz: aNumber	self at: 30 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!btp	^ self at: 32! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!btp: aNumber	self at: 32 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!btz	^ self at: 34! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!btz: aNumber	self at: 34 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!bypass	^ self at: 40! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!bypass: aNumber	self at: 40 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!db1	^ self at: 16! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!db1: aNumber	self at: 16 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!df1	^ self at: 15! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!df1: aNumber	self at: 15 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!diplophonia	^ self at: 5! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!diplophonia: aNumber	self at: 5 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f0	^ self at: 1! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f0: aNumber	self at: 1 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f1	^ self at: 13! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f1: aNumber	self at: 13 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f2	^ self at: 17! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f2: aNumber	self at: 17 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f3	^ self at: 19! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f3: aNumber	self at: 19 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f4	^ self at: 21! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f4: aNumber	self at: 21 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f5	^ self at: 23! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f5: aNumber	self at: 23 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f6	^ self at: 25! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!f6: aNumber	self at: 25 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!flutter	^ self at: 2! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!flutter: aNumber	self at: 2 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!fnp	^ self at: 27! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!fnp: aNumber	self at: 27 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!fnz	^ self at: 29! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!fnz: aNumber	self at: 29 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!friction	^ self at: 11! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!friction: aNumber	self at: 11 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!ftp	^ self at: 31! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!ftp: aNumber	self at: 31 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!ftz	^ self at: 33! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!ftz: aNumber	self at: 33 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!gain	^ self at: 52! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 23:00'!gain: aNumber	self at: 52 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!jitter	^ self at: 3! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!jitter: aNumber	self at: 3 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!ra	^ self at: 8! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!ra: aNumber	self at: 8 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!rk	^ self at: 9! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!rk: aNumber	self at: 9 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!ro	^ self at: 7! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!ro: aNumber	self at: 7 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!shimmer	^ self at: 4! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!shimmer: aNumber	self at: 4 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!turbulence	^ self at: 12! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!turbulence: aNumber	self at: 12 put: aNumber! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!voicing	^ self at: 6! !!KlattFrame methodsFor: 'accessing' stamp: 'len 12/5/1999 22:59'!voicing: aNumber	self at: 6 put: aNumber! !!KlattFrame methodsFor: 'editing' stamp: 'len 12/17/1999 03:35'!edit	^ KlattFrameMorph new		frame: self;		addTestButton;		openInWorld! !!KlattFrame methodsFor: 'playing' stamp: 'len 12/17/1999 03:33'!play	(KlattSynthesizer new cascade: 6; millisecondsPerFrame: 1000; soundFromFrames: {self}) play! !!KlattFrame methodsFor: 'printing' stamp: 'len 9/1/1999 23:36'!printOn: aStream	self class parameterNames do: [ :each |		aStream			nextPutAll: each;			nextPut: $=; 			print: (self perform: each);			space]! !!KlattFrame class methodsFor: 'instance creation' stamp: 'len 12/17/1999 03:34'!default	"	KlattFrame default edit	"	^ self new		f0: 133;		flutter: 0; jitter: 0; shimmer: 0; diplophonia: 0;		voicing: 62;		ro: 0.4; ra: 0.01; rk: 0.25;		aspiration: 0;		friction: 0;		turbulence: 0;		f1: 500;		b1: 60;		df1: 0;		db1: 0;		f2: 1500;		b2: 90;		f3: 2800;	b3: 150;		f4: 3250;	b4: 200;		f5: 3700;	b5: 200;		f6: 4990;	b6: 500;		fnp: 280;	bnp: 90;		fnz: 280;	bnz: 90;		ftp: 2150;	btp: 180;		ftz: 2150;	btz: 180;		a2f: 52.5;	b2f: 200;		a3f: 39.3;	b3f: 350;		a4f: 25.4;	b4f: 500;		a5f: 0;		b5f: 600;		a6f: 0;		b6f: 800;		bypass: 0;		anv: 0;		a1v: 60.3;		a2v: 52.5;		a3v: 39.3;		a4v: 25.4;		atv: 0;		gain: 62! !!KlattFrame class methodsFor: 'instance creation' stamp: 'len 9/3/1999 02:38'!fromArray: anArray	| answer |	answer _ self new.	anArray doWithIndex: [ :each :i | answer at: i put: each].	^ answer! !!KlattFrame class methodsFor: 'instance creation' stamp: 'hmm 5/7/1999 22:00'!fromString: aString	^ self fromArray: (aString substrings collect: [ :each | each asNumber])! !!KlattFrame class methodsFor: 'instance creation' stamp: 'len 11/22/1999 02:38'!new	^ super new: 52! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 12/20/1999 01:49'!defaultForParameter: aSymbol	^ self default perform: aSymbol asSymbol! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 11/29/1999 02:10'!descriptionForParameter: aSymbol	^ (self parameterData detect: [ :one | one first = aSymbol]) at: 4! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 11/29/1999 02:10'!maximumForParameter: aSymbol	^ (self parameterData detect: [ :one | one first = aSymbol]) at: 3! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 11/29/1999 02:10'!minimumForParameter: aSymbol	^ (self parameterData detect: [ :one | one first = aSymbol]) at: 2! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 12/5/1999 22:59'!parameterData	"This is a table describing the Klatt parameters. The columns are: parameter name, minimum value, maximum, parameter description, unit." 	^ #(	"Excitation source (voice, aspiration and friction):"		(f0 20 1000 'Fundamental frequency (hz)' hz)		(flutter 0 1 'Amount of flutter' value)		(jitter 0 1 'Amount of jitter' value)		(shimmer 0 1 'Amount of shimmer' value)		(diplophonia 0 1 'Amount of diplophonia' value)		(voicing 0 80 'Amplitude of voicing' hz)		(ro 0 1 'Relative duration of open phase of voicing waveform = Te/T0 (0 - 1)' value)		(ra 0 0.2 'Relative duration of return phase of voicing waveform = Ta/T0 (0 - 1)' value)		(rk 0 1 'Simmetry of the glottal pulse = (Te-Tp)/Tp (0 - 1)' value)		(aspiration 0 80 'Amplitude of aspiration' dB)		(friction 0 80 'Amplitude of friction' dB)		(turbulence 0 80 'Amplitude of turbulence (in open glottal phase)' dB)	"Formants frequencies and bandwidths:"			(f1 200 1300 'Frequency of 1st formant' hz)		(b1 40 1000 'Bandwidth of 1st formant' hz)		(df1 0 100 'Change in F1 during open portion of period' hz)		(db1 0 400 'Change in B1 during open portion of period' hz)		(f2 550 3000 'Frequency of 2nd formant' hz)		(b2 40 1000 'Bandwidth of 2nd formant' hz)		(f3 1200 4999 'Frequency of 3rd formant' hz)		(b3 40 1000 'Bandwidth of 3rd formant' hz)		(f4 1200 4999 'Frequency of 4th formant' hz)		(b4 40 1000 'Bandwidth of 4th formant' hz)		(f5 1200 4999 'Frequency of 5th formant' hz)		(b5 40 1000 'Bandwidth of 5th formant' hz)		(f6 1200 4999 'Frequency of 6th formant' hz)		(b6 40 1000 'Bandwidth of 6th formant' hz)		(fnp 248 528 'Frequency of nasal pole' hz)		(bnp 40 1000 'Bandwidth of nasal pole' hz)		(fnz 248 528 'Frequency of nasal zero' hz)		(bnz 40 1000 'Bandwidth of nasal zero' hz)		(ftp 300 3000 'Frequency of tracheal pole' hz)		(btp 40 1000 'Bandwidth of tracheal pole' hz)		(ftz 300 3000 'Frequency of tracheal zero' hz)		(btz 40 2000 'Bandwidth of tracheal zero' hz)	"Parallel Friction-Excited:"		(a2f 0 80 'Amplitude of friction-excited parallel 2nd formant' dB)		(a3f 0 80 'Amplitude of friction-excited parallel 3rd formant' dB)		(a4f 0 80 'Amplitude of friction-excited parallel 4th formant' dB)		(a5f 0 80 'Amplitude of friction-excited parallel 5th formant' dB)		(a6f 0 80 'Amplitude of friction-excited parallel 6th formant' dB)		(bypass 0 80 'Amplitude of friction-excited parallel bypass path' dB)		(b2f 40 1000 'Bandwidth of friction-excited parallel 2nd formant' hz)		(b3f 60 1000 'Bandwidth of friction-excited parallel 2nd formant' hz)		(b4f 100 1000 'Bandwidth of friction-excited parallel 2nd formant' hz)		(b5f 100 1500 'Bandwidth of friction-excited parallel 2nd formant' hz)		(b6f 100 4000 'Bandwidth of friction-excited parallel 2nd formant' hz)	"Parallel Voice-Excited:"		(anv 0 80 'Amplitude of voice-excited parallel nasal formant' dB)		(a1v 0 80 'Amplitude of voice-excited parallel 1st formant' dB)		(a2v 0 80 'Amplitude of voice-excited parallel 2nd formant' dB)		(a3v 0 80 'Amplitude of voice-excited parallel 3rd formant' dB)		(a4v 0 80 'Amplitude of voice-excited parallel 4th formant' dB)		(atv 0 80 'Amplitude of voice-excited parallel tracheal formant' dB)	"Overall gain:"		(gain 0 80 'Overall gain' dB))! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 9/27/1999 02:21'!parameterNames	^ self parameterData collect: [ :each | each first]! !!KlattFrame class methodsFor: 'documentation' stamp: 'len 11/29/1999 02:10'!unitForParameter: aSymbol	^ (self parameterData detect: [ :one | one first = aSymbol]) at: 5! !!KlattFrame class methodsFor: 'examples' stamp: 'len 12/8/1999 21:22'!example1	"	KlattFrame example1.	KlattFrame example2.	KlattFrame example3	"	| frame |	frame _ self default		voicing: 62;		anv: 0; a1v: 0; a2v: 0; a3v: 0; a4v: 0;		yourself.	(KlattSynthesizer new cascade: 6; millisecondsPerFrame: 1000; soundFromFrames: {frame}) play! !!KlattFrame class methodsFor: 'examples' stamp: 'len 11/8/1999 00:56'!example2	"	KlattFrame example2	"	| frame |	frame _ self default		voicing: 62;		anv: 0; a1v: 62; a2v: 62; a3v: 62; a4v: 62;		yourself.	(KlattSynthesizer new cascade: 6; millisecondsPerFrame: 1000; soundFromFrames: {frame}) play! !!KlattFrame class methodsFor: 'examples' stamp: 'len 12/8/1999 21:23'!example3	"	KlattFrame example3	"	| frame |	frame _ self default		voicing: 62;		anv: 0; a1v: 62; a2v: 62; a3v: 62; a4v: 62;		yourself.	(KlattSynthesizer new cascade: 0; millisecondsPerFrame: 1000; soundFromFrames: {frame}) play! !!KlattFrame class methodsFor: 'code generation' stamp: 'len 9/27/1999 02:21'!generateAccessors	"	KlattFrame generateAccessors	"	| crtab getter setter |	crtab _ String with: Character cr with: Character tab.	self parameterNames		doWithIndex: [ :selector :i |			getter _ selector, crtab, '^ self at: ', i printString.			setter _ selector, ': aNumber', crtab, 'self at: ', i printString,' put: aNumber'.			self compile: getter classified: 'accessing'.			self compile: setter classified: 'accessing']! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 12/2/1999 02:57'!addSliderForParameter: parameter target: target min: min max: max description: description	self addMorphFront: (self newSliderForParameter: parameter target: target min: min max: max description: description)! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 11/29/1999 02:13'!addSlidersForParameters: params	| left right container current slider |	params size < 10		ifTrue: [left _ right _ self]		ifFalse: [container _ AlignmentMorph new color: self color; orientation: #horizontal.				left _ container clone orientation: #vertical.				right _ left clone.				container addMorphBack: left; addMorphBack: right.				self addMorphBack: container].	params do: [ :each |		current _ current == left ifTrue: [right] ifFalse: [left].		slider _ self newSliderNamed: each min: (KlattFrame minimumForParameter: each) max: (KlattFrame maximumForParameter: each).		slider setBalloonText: (KlattFrame descriptionForParameter: each).		current addMorphBack: slider]! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 10/1/1999 01:25'!addTestButton	self addMorphBack: (SimpleButtonMorph new target: self; actWhen: #buttonDown; actionSelector:  #playTest; labelString: 'play')! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 9/27/1999 02:25'!frame: aKlattFrame	self frame: aKlattFrame edit: KlattFrame parameterNames! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 10/1/1999 01:27'!frame: aKlattFrame edit: params	frame _ aKlattFrame.	self addSlidersForParameters: params.	(params detect: [ :one | #(ro ra rk) includes: one] ifNone: []) notNil		ifTrue: [glottal _ GraphMorph new extent: 210 @ 100.				glottal setBalloonText: 'Glottal pulse'.				self addMorphBack: glottal]! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 9/27/1999 02:30'!initialize	super initialize.	self orientation: #vertical.	self color: (Color r: 0.452 g: 0.935 b: 0.548)! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 12/2/1999 03:39'!newSliderForParameter: parameter target: target min: min max: max description: description	| r slider m |	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	slider _ SimpleSliderMorph new		color: (Color r: 0.065 g: 0.548 b: 0.645);		extent: 120@2;		target: target;		actionSelector: (parameter, ':') asSymbol;		minVal: min;		maxVal: max;		adjustToValue: (target perform: parameter asSymbol).	r addMorphBack: slider.	m _ StringMorph new contents: parameter, ': '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: target; getSelector: parameter asSymbol; putSelector: (parameter, ':') asSymbol;		width: 30; growable: false; floatPrecision: (max - min / 100.0 min: 1.0); step.	r addMorphBack: m.	r setBalloonText: description.	^ r! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'len 12/2/1999 02:59'!newSliderNamed: name min: min max: max	^ self newSliderForParameter: name target: frame min: min max: max description: ''! !!KlattFrameMorph methodsFor: 'menu' stamp: 'len 10/1/1999 01:31'!playTest	| synth |	synth _ KlattSynthesizer new.	synth millisecondsPerFrame: 1000; cascade: 8.	(SampledSound samples: (synth samplesFromFrames: {frame}) samplingRate: synth samplingRate) play! !!KlattFrameMorph methodsFor: 'stepping and presenter' stamp: 'len 9/27/1999 02:58'!step	| lf |	lastSnapshot = frame ifTrue: [^ self].	lastSnapshot _ frame clone.	lf _ LiljencrantsFant new		t0: 1 / frame f0 ro: frame ro rk: frame rk ra: frame ra samplingRate: 44000.	glottal data: lf init samples! !!KlattFrameMorph methodsFor: 'stepping and presenter' stamp: 'len 9/27/1999 02:51'!stepTime	^ 500! !!KlattSegment methodsFor: 'initialization' stamp: 'len 10/9/1999 02:14'!initialize	self parameters: Dictionary new! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 23:58'!addParameter: aKlattSegmentParameter	^ self parameters at: aKlattSegmentParameter selector put: aKlattSegmentParameter! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 01:51'!duration	^ duration! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 01:51'!duration: aNumber	duration _ aNumber! !!KlattSegment methodsFor: 'accessing' stamp: 'len 11/22/1999 01:07'!features	^ features! !!KlattSegment methodsFor: 'accessing' stamp: 'len 11/22/1999 01:07'!features: aCollection	features _ aCollection! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 02:56'!name	^ name! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 02:56'!name: aString	name _ aString! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 01:50'!parameters	^ parameters! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 02:13'!parameters: aDictionary	parameters _ aDictionary! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 01:49'!rank	^ rank! !!KlattSegment methodsFor: 'accessing' stamp: 'len 10/9/1999 01:49'!rank: aNumber	rank _ aNumber! !!KlattSegment methodsFor: 'processing' stamp: 'len 12/2/1999 01:55'!cosine: a with: b time: time duration: dur	time <= 0 ifTrue: [^ a].	time >= dur ifTrue: [^ b].	^ ((time / dur * Float pi) cos - 1 / -2.0) * (b - a) + a! !!KlattSegment methodsFor: 'processing' stamp: 'len 12/6/1999 03:26'!interpolate: slope1 with: slope2 mid: mid time: time speed: speed	| steady p1 p2 |	steady _ self duration * speed - (slope1 x + slope2 x).	steady < 0 "steady state cannot be reached"		ifTrue: [p1 _ self linear: slope1 y with: mid time: time duration: slope1 x.				p2 _ self linear: slope2 y with: mid time: self duration * speed - time duration: slope2 x.				^ p2 - p1 * time / (self duration * speed) + p1].	time < slope1 x		ifTrue: [^ self linear: slope1 y with: mid time: time duration: slope1 x].	^ time - slope1 x <= steady "steady state reached"		ifTrue: [mid]		ifFalse: [self linear: mid with: slope2 y time: time - slope1 x - steady duration: slope2 x]! !!KlattSegment methodsFor: 'processing' stamp: 'len 12/6/1999 03:31'!left: left right: right speed: speed pattern: patternFrame	| frames leftSlope rightSlope value |	frames _ (1 to: self duration * speed) collect: [ :each | patternFrame clone].	self parameters do: [ :each |		leftSlope _ self slopeWith: left selector: each selector speed: speed.		rightSlope _ self slopeWith: right selector: each selector speed: speed.		0 to: self duration * speed - 1 do: [ :time |			value _ self interpolate: leftSlope with: rightSlope mid: each steady time: time speed: speed.			(frames at: (time + 1) asInteger) perform: each selector with: value]].	^ frames! !!KlattSegment methodsFor: 'processing' stamp: 'len 12/6/1999 03:51'!linear: a with: b time: time duration: dur	time <= 0 ifTrue: [^ a].	time >= dur ifTrue: [^ b].	^ b - a * time / dur + a! !!KlattSegment methodsFor: 'processing' stamp: 'len 12/6/1999 03:16'!slopeWith: aKlattSegment selector: selector speed: speed	| me other |	me _ self parameters at: selector.	other _ aKlattSegment parameters at: selector.	^ (self dominates: aKlattSegment)		ifTrue: [me slopeWithDominated: other speed: speed]		ifFalse: [me slopeWithDominant: other speed: speed]! !!KlattSegment methodsFor: 'testing' stamp: 'len 10/12/1999 01:12'!dominates: aKlattSegment	"Answer true if the receiver dominates the argument,	i.e. if the receiver has greater rank than the argument."	^ self rank > aKlattSegment rank! !!KlattSegment methodsFor: 'printing' stamp: 'len 12/5/1999 23:38'!compileOn: aClass	| stream |	stream _ WriteStream on: ''.	self methodPrintOn: stream.	aClass compile: stream contents classified: 'default segments'! !!KlattSegment methodsFor: 'printing' stamp: 'len 12/5/1999 23:38'!methodPrintOn: aStream	| param |	aStream print: self name; cr;		tab; nextPutAll: '^ self segmentFromArray: '; cr;		tab; tab; nextPutAll: '"name	rank	duration	features"'; cr;		tab; tab; nextPutAll: '#('; print: self name; tab; tab; print: self rank; tab; tab; print: self duration; tab; tab; tab; print: (self features ifNil: [#()]); cr;		tab; tab; nextPutAll: '"selector		steady	fixed	prop	extern	intern"'.	KlattFrame parameterNames do: [ :each |		(param _ self parameters at: (each, ':') asSymbol ifAbsent: [])			ifNotNil: [aStream cr; tab; tab.					param methodPrintOn: aStream]].	aStream nextPut: $)! !!KlattSegment methodsFor: 'printing' stamp: 'len 11/25/1999 01:38'!methodString	| stream |	stream _ WriteStream on: ''.	self methodPrintOn: stream.	^ stream contents! !!KlattSegment methodsFor: 'printing' stamp: 'len 12/6/1999 03:59'!printOn: aStream	aStream nextPutAll: self name! !!KlattSegment methodsFor: 'message dispatching' stamp: 'len 12/8/1999 21:40'!doesNotUnderstand: aMessage	| sel |	(parameters includesKey: (sel _ (aMessage selector copyWith: $:) asSymbol))		ifTrue: [^ parameters at: sel].	^ super doesNotUnderstand: aMessage! !!KlattSegment class methodsFor: 'instance creation' stamp: 'len 10/9/1999 03:05'!new	^ super new initialize! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:09'!external	^ external! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:09'!external: aNumber	external _ aNumber! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 12/5/1999 23:22'!fixed	^ fixed! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 12/5/1999 16:10'!fixed: aNumber	fixed _ aNumber! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:09'!internal	^ internal! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:09'!internal: aNumber	internal _ aNumber! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:08'!proportion	^ proportion! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:09'!proportion: aNumber	proportion _ aNumber! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 23:52'!selector	^ selector! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 23:52'!selector: aSymbol	selector _ aSymbol asSymbol! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:08'!steady	^ steady! !!KlattSegmentParameter methodsFor: 'accessing' stamp: 'len 10/9/1999 02:08'!steady: aNumber	steady _ aNumber! !!KlattSegmentParameter methodsFor: 'printing' stamp: 'len 12/5/1999 23:35'!methodPrintOn: aStream	aStream nextPut: $(; print: self selector; tab.	self selector size < 4 ifTrue: [aStream tab].	self selector size < 8 ifTrue: [aStream tab].	aStream print: self steady; tab; tab; print: self fixed; tab; tab; print: self proportion; tab; tab; print: self external; tab; tab; print: self internal; nextPut: $)! !!KlattSegmentParameter methodsFor: 'printing' stamp: 'len 10/10/1999 00:22'!printOn: aStream	aStream nextPutAll: self selector; space; print: self steady! !!KlattSegmentParameter methodsFor: 'processing' stamp: 'len 12/6/1999 03:15'!slopeWith: parameter dominant: dominant speed: speed	| dominated time value |	dominated _ self == dominant ifTrue: [parameter] ifFalse: [self].	time _ dominant == self ifTrue: [dominant internal] ifFalse: [dominant external].	time _ time * speed.	value _ time ~= 0		ifTrue: [dominant proportion * dominated steady * 0.01 + dominant fixed]		ifFalse: [dominated steady].	^ time @ value! !!KlattSegmentParameter methodsFor: 'processing' stamp: 'len 12/6/1999 03:15'!slopeWithDominant: parameter speed: speed	^ self slopeWith: parameter dominant: parameter speed: speed! !!KlattSegmentParameter methodsFor: 'processing' stamp: 'len 12/6/1999 03:16'!slopeWithDominated: parameter speed: speed	^ self slopeWith: parameter dominant: self speed: speed! !!KlattSegmentSet commentStamp: '<historical>' prior: 0!My instances are sets of KlattSegments, and they map phonemes to actual KlattSegments. The default segments are adapted from rsynth 2.0, a public domain TTS.!!KlattSegmentSet methodsFor: 'initialization' stamp: 'len 12/20/1999 04:27'!initializeArpabet	phonemes _ PhonemeSet arpabet.	segments _ Dictionary new.	#(('p'	(p py pz))	('t'		(t ty tz))	('k'		(k ky kz))	('b'		(b by bz))	('d'		(d dy dz))	('g'		(g gy gz))	('m'		(m))	('n'		(n))	('ng'	(ng))	('f'		(f))	('th'	(th))	('s'		(s))	('sh'	(sh))	('hh'	(h))	('v'		(v qq v))	('dh'	(dh qq di))	('z'		(z qq zz))	('zh'	(zh qq zh))	('ch'	(ch ci))	('jh'	(j jy qq jy))	('l'		(l))	('r'		(r))	('w'		(w))	('q'		(qq)) "stop-ness - not quite glottal stop"	('y'		(y))	('ih'	(i))	('eh'	(e))	('ae'	(aa))	('ah'	(u))"	('oh'	(o))	????????????????????????"	('uh'	(oo))	('ax'	(a))	('iy'	(ee))	('er'	(er))	('aa'	(ar))	('ao'	(aw))	('uw'	(uu))	('ey'	(ai i))	('ay'	(ie i))	('oy'	(oi i))	('aw'	(ou ov))	('ow'	(oa ov))	('ia'	(ia ib))	('ea'	(air ib))	('ua'	(oor ib))	('sil'	(q))	('ll'		(ll))	('wh'	(w))	('ix'		(a))	('el'		(l))	('rx'	(rx))) do: [ :each |		segments at: (phonemes at: each first)		put: (each last collect: [ :selector | self perform: selector])]! !!KlattSegmentSet methodsFor: 'accessing-private' stamp: 'len 10/12/1999 00:49'!phonemes: aPhonemeSet	phonemes _ aPhonemeSet! !!KlattSegmentSet methodsFor: 'accessing-private' stamp: 'len 10/12/1999 00:48'!segments: aDictionary	segments _ aDictionary! !!KlattSegmentSet methodsFor: 'accessing' stamp: 'len 10/12/1999 00:48'!at: aPhoneme	^ self segments at: aPhoneme! !!KlattSegmentSet methodsFor: 'accessing' stamp: 'len 10/12/1999 00:53'!at: aPhoneme ifAbsent: aBlock	^ self segments at: aPhoneme ifAbsent: aBlock! !!KlattSegmentSet methodsFor: 'accessing' stamp: 'len 10/12/1999 00:48'!phonemes	^ phonemes! !!KlattSegmentSet methodsFor: 'accessing' stamp: 'len 10/12/1999 00:48'!segments	^ segments! !!KlattSegmentSet methodsFor: 'accessing' stamp: 'len 12/6/1999 03:58'!silence	self phonemes do: [ :each | each isSilence ifTrue: [^ self at: each]].	self error: 'silence segment not found'! !!KlattSegmentSet methodsFor: 'enumerating' stamp: 'len 11/28/1999 04:18'!do: aBlock	self segments do: [ :each | each do: aBlock]! !!KlattSegmentSet methodsFor: 'segments creation' stamp: 'len 12/5/1999 23:09'!parameterFromArray: anArray	| answer |	answer _ KlattSegmentParameter new.	#(selector: steady: fixed: proportion: external: internal:)		doWithIndex: [ :each :index | answer perform: each with: (anArray at: index)].	^ answer! !!KlattSegmentSet methodsFor: 'segments creation' stamp: 'len 11/29/1999 01:40'!segmentFromArray: anArray	| answer |	answer _ KlattSegment new.	#(name: rank: duration: features:)		doWithIndex: [ :each :index | answer perform: each with: (anArray at: index)].	5 to: anArray size do: [ :each | answer addParameter: (self parameterFromArray: (anArray at: each))].	^ answer! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!a	^ self segmentFromArray: 		"name	rank	duration	features"		#(a		2		4			(cnt mdl unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		230.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			1480		710.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		64.75		31.5		50		4		4)		(a3f:		47.25		24.5		50		4		4)		(a4f:		40.25		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		64.75		31.5		50		4		4)		(a3v:		47.25		24.5		50		4		4)		(a4v:		40.25		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!aa	^ self segmentFromArray: 		"name	rank	duration	features"		#(aa		2		5			(fnt low unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			790		410.0		50		4		4)		(b1:			130		65.0		50		4		4)		(f2:			1780		950.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		61.25		31.5		50		4		4)		(a3f:		52.5		24.5		50		4		4)		(a4f:		45.5		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		61.25		31.5		50		4		4)		(a3v:		52.5		24.5		50		4		4)		(a4v:		45.5		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ai	^ self segmentFromArray: 		"name	rank	duration	features"		#(ai		2		6			(fnt lmd unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			640		290.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			1600		830.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		59.5		28.0		50		5		5)		(a3f:		49		24.5		50		5		5)		(a4f:		43.75		21.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		59.5		28.0		50		5		5)		(a3v:		49		24.5		50		5		5)		(a4v:		43.75		21.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!air	^ self segmentFromArray: 		"name	rank	duration	features"		#(air		2		6			(fnt lmd unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			640		350.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			2020		1070.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		56		28.0		50		5		5)		(a3f:		52.5		24.5		50		5		5)		(a4f:		45.5		21.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		56		28.0		50		5		5)		(a3v:		52.5		24.5		50		5		5)		(a4v:		45.5		21.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ar	^ self segmentFromArray: 		"name	rank	duration	features"		#(ar		2		15			(bck low unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			790		410.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			880		470.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		63		31.5		50		4		4)		(a3f:		43.75		21.0		50		4		4)		(a4f:		36.75		17.5		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		63		31.5		50		4		4)		(a3v:		43.75		21.0		50		4		4)		(a4v:		36.75		17.5		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!aw	^ self segmentFromArray: 		"name	rank	duration	features"		#(aw		2		10			(bck lmd rnd vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		230.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			820		470.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		59.5		28.0		50		4		4)		(a3f:		36.75		17.5		50		4		4)		(a4f:		31.5		14.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		59.5		28.0		50		4		4)		(a3v:		36.75		17.5		50		4		4)		(a4v:		31.5		14.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!b	^ self segmentFromArray: 		"name	rank	duration	features"		#(b		26		12			(blb stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			760		350.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2500		0.0		100		0		2)		(b3:			150		0.0		100		0		2)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		0.0		100		0		2)		(anv:		-16		0.0		100		0		0)		(a1v:		38.5		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!by	^ self segmentFromArray: 		"name	rank	duration	features"		#(by		29		1			(blb stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			760		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2500		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		63		0.0		100		0		0)		(a3f:		57.25		0.0		100		0		0)		(a4f:		52.5		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		38.5		0.0		100		0		0)		(a2v:		63		0.0		100		0		0)		(a3v:		57.25		0.0		100		0		0)		(a4v:		52.5		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!bz	^ self segmentFromArray: 		"name	rank	duration	features"		#(bz		26		0			(blb stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		2		0)		(b1:			60		30.0		50		2		0)		(f2:			760		350.0		50		2		0)		(b2:			90		45.0		50		2		0)		(f3:			2500		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ch	^ self segmentFromArray: 		"name	rank	duration	features"		#(ch		23		4			(alv stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			1780		950.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2680		2680.0		0		2		2)		(b3:			150		150.0		0		2		2)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		150.0		0		2		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ci	^ self segmentFromArray: 		"name	rank	duration	features"		#(ci		18		8			(frc pla vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			400		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			2020		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		45.5		0.0		100		0		0)		(a3f:		56		0.0		100		0		0)		(a4f:		45.5		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		45.5		0.0		100		0		0)		(a3v:		56		0.0		100		0		0)		(a4v:		45.5		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!d	^ self segmentFromArray: 		"name	rank	duration	features"		#(d		26		8			(alv stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			1780		950.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2680		2680.0		0		2		2)		(b3:			150		150.0		0		2		2)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		150.0		0		2		2)		(anv:		-16		0.0		100		0		0)		(a1v:		45.5		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/8/1999 22:08'!dh	^ self segmentFromArray: 		"name	rank	duration	features"		#(dh		20		4			(dnt frc vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	36		18.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1600		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		45.5		0.0		100		0		0)		(a3f:		40.25		0.0		100		0		0)		(a4f:		42		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:	54		27.0		50		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		45.5		0.0		100		0		0)		(a3v:		40.25		0.0		100		0		0)		(a4v:		42		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!di	^ self segmentFromArray: 		"name	rank	duration	features"		#(di		20		4			(dnt frc vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1600		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		45.5		0.0		100		0		0)		(a3f:		40.25		0.0		100		0		0)		(a4f:		42		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		45.5		0.0		100		0		0)		(a3v:		40.25		0.0		100		0		0)		(a4v:		42		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!dy	^ self segmentFromArray: 		"name	rank	duration	features"		#(dy		29		1			(alv stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			1780		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2680		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		52.5		0.0		100		0		0)		(a3f:		49		0.0		100		0		0)		(a4f:		59.5		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		52.5		0.0		100		0		0)		(a2v:		52.5		0.0		100		0		0)		(a3v:		49		0.0		100		0		0)		(a4v:		59.5		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!dz	^ self segmentFromArray: 		"name	rank	duration	features"		#(dz		26		1			(alv stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		2		0)		(b1:			60		30.0		50		2		0)		(f2:			1780		950.0		50		2		0)		(b2:			90		45.0		50		2		0)		(f3:			2680		2680.0		0		2		0)		(b3:			150		150.0		0		2		0)		(fnz:		270		135.0		50		0		0)		(a2f:		42		0.0		100		0		0)		(a3f:		38.5		0.0		100		0		0)		(a4f:		49		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		0)		(b3f:		150		150.0		0		2		0)		(anv:		-16		0.0		100		0		0)		(a1v:		52.5		0.0		100		0		0)		(a2v:		42		0.0		100		0		0)		(a3v:		38.5		0.0		100		0		0)		(a4v:		49		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!e	^ self segmentFromArray: 		"name	rank	duration	features"		#(e		2		4			(fnt lmd unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			640		350.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			2020		1070.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		56		28.0		50		4		4)		(a3f:		52.5		24.5		50		4		4)		(a4f:		45.5		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		56		28.0		50		4		4)		(a3v:		52.5		24.5		50		4		4)		(a4v:		45.5		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ee	^ self segmentFromArray: 		"name	rank	duration	features"		#(ee		2		7			(fnt hgh unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			250		110.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			2320		1190.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			3200		1580.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		47.25		24.5		50		4		4)		(a3f:		50.75		24.5		50		4		4)		(a4f:		45.5		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		47.25		24.5		50		4		4)		(a3v:		50.75		24.5		50		4		4)		(a4v:		45.5		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/22/1999 03:07'!end	^ self segmentFromArray: 		"name	rank	duration	features"		#(end		31		5			(0 )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			1480		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2500		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		3		3)		(a2f:		-16		-10.5		100		3		0)		(a3f:		-16		-10.5		100		3		0)		(a4f:		-16		-10.5		100		3		0)		(a5f:		-16		0.0		100		3		0)		(a6f:		-16		0.0		100		3		0)		(bypass:		-16		0.0		100		3		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		-10.5		100		3		0)		(a1v:		-16		-10.5		100		3		0)		(a2v:		-16		-10.5		100		3		0)		(a3v:		-16		-10.5		100		3		0)		(a4v:		-16		-10.5		100		3		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!er	^ self segmentFromArray: 		"name	rank	duration	features"		#(er		2		16			(cnt lmd unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			580		290.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			1420		710.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		59.5		28.0		50		4		4)		(a3f:		47.25		24.5		50		4		4)		(a4f:		40.25		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		59.5		28.0		50		4		4)		(a3v:		47.25		24.5		50		4		4)		(a4v:		40.25		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/8/1999 22:08'!f	^ self segmentFromArray: 		"name	rank	duration	features"		#(f		18		12			(frc lbd vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	32		16.0		50		0		0)		(friction:	54		30.0		50		0		0)		(f1:			400		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1420		350.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		980.0		50		3		2)		(b3:			150		75.0		50		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		14		0.0		100		0		0)		(a3f:		14		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:	54		27.0		50		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		75.0		50		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		14		0.0		100		0		0)		(a3v:		14		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!g	^ self segmentFromArray: 		"name	rank	duration	features"		#(g		26		12			(stp vcd vel )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		3		3)		(b1:			60		30.0		50		3		3)		(f2:			1480		1550.0		50		3		3)		(b2:			90		45.0		50		3		3)		(f3:			2620		1580.0		50		3		3)		(b3:			150		75.0		50		3		3)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		3)		(b3f:		150		75.0		50		3		3)		(anv:		-16		0.0		100		0		0)		(a1v:		49		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!gy	^ self segmentFromArray: 		"name	rank	duration	features"		#(gy		29		1			(stp vcd vel )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			1480		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2620		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		59.5		0.0		100		0		0)		(a3f:		54.25		0.0		100		0		0)		(a4f:		38.5		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		49		0.0		100		0		0)		(a2v:		59.5		0.0		100		0		0)		(a3v:		54.25		0.0		100		0		0)		(a4v:		38.5		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!gz	^ self segmentFromArray: 		"name	rank	duration	features"		#(gz		26		2			(stp vcd vel )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1480		1550.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2620		1580.0		50		3		2)		(b3:			150		75.0		50		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		49		0.0		100		0		0)		(a3f:		43.75		0.0		100		0		0)		(a4f:		28		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		75.0		50		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		49		0.0		100		0		0)		(a2v:		49		0.0		100		0		0)		(a3v:		43.75		0.0		100		0		0)		(a4v:		28		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!h	^ self segmentFromArray: 		"name	rank	duration	features"		#(h		9		10			(apr glt )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			490		0.0		100		0		7)		(b1:			60		0.0		100		0		7)		(f2:			1480		0.0		100		0		7)		(b2:			90		0.0		100		0		7)		(f3:			2500		0.0		100		0		7)		(b3:			150		0.0		100		0		7)		(fnz:		270		135.0		50		0		0)		(a2f:		50.75		-14.0		100		0		7)		(a3f:		40.25		-7.0		100		0		7)		(a4f:		36.75		-3.5		100		0		7)		(a5f:		-16		0.0		100		0		7)		(a6f:		-16		0.0		100		0		7)		(bypass:		-16		0.0		100		0		7)		(b2f:		90		0.0		100		0		7)		(b3f:		150		0.0		100		0		7)		(anv:		-16		0.0		100		0		7)		(a1v:		49		-14.0		100		0		7)		(a2v:		50.75		-14.0		100		0		7)		(a3v:		40.25		-7.0		100		0		7)		(a4v:		36.75		-3.5		100		0		7))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!i	^ self segmentFromArray: 		"name	rank	duration	features"		#(i		2		6			(fnt smh unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			400		170.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			2080		1070.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2560		1340.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		50.75		24.5		50		4		4)		(a3f:		49		24.5		50		4		4)		(a4f:		43.75		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		50.75		24.5		50		4		4)		(a3v:		49		24.5		50		4		4)		(a4v:		43.75		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ia	^ self segmentFromArray: 		"name	rank	duration	features"		#(ia		2		6			(fnt smh unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			310		170.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			2200		1070.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2920		1460.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		49		24.5		50		5		5)		(a3f:		50.75		24.5		50		5		5)		(a4f:		45.5		21.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		49		24.5		50		5		5)		(a3v:		50.75		24.5		50		5		5)		(a4v:		45.5		21.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ib	^ self segmentFromArray: 		"name	rank	duration	features"		#(ib		2		6			(fnt low unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		230.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			1480		710.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		64.75		31.5		50		4		4)		(a3f:		47.25		24.5		50		4		4)		(a4f:		40.25		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		64.75		31.5		50		4		4)		(a3v:		47.25		24.5		50		4		4)		(a4v:		40.25		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ie	^ self segmentFromArray: 		"name	rank	duration	features"		#(ie		2		6			(cnt low unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			790		410.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			880		470.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		63		31.5		50		5		5)		(a3f:		43.75		21.0		50		5		5)		(a4f:		36.75		17.5		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		63		31.5		50		5		5)		(a3v:		43.75		21.0		50		5		5)		(a4v:		36.75		17.5		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!j	^ self segmentFromArray: 		"name	rank	duration	features"		#(j		26		4			(alv stp vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			1780		950.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2680		2680.0		0		2		2)		(b3:			150		150.0		0		2		2)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		150.0		0		2		2)		(anv:		-16		0.0		100		0		0)		(a1v:		45.5		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!jy	^ self segmentFromArray: 		"name	rank	duration	features"		#(jy		20		3			(frc pla vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			2020		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		40.25		0.0		100		0		0)		(a3f:		50.75		0.0		100		0		0)		(a4f:		40.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		40.25		0.0		100		0		0)		(a3v:		50.75		0.0		100		0		0)		(a4v:		40.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!k	^ self segmentFromArray: 		"name	rank	duration	features"		#(k		23		8			(stp vel vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		3		3)		(b1:			60		30.0		50		3		3)		(f2:			1480		1550.0		50		3		3)		(b2:			90		45.0		50		3		3)		(f3:			2620		1580.0		50		3		3)		(b3:			150		75.0		50		3		3)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		3)		(b3f:		150		75.0		50		3		3)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ky	^ self segmentFromArray: 		"name	rank	duration	features"		#(ky		29		1			(stp vel vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			1480		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2620		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		64.75		0.0		100		0		0)		(a3f:		64.75		0.0		100		0		0)		(a4f:		43.75		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		64.75		0.0		100		0		0)		(a3v:		64.75		0.0		100		0		0)		(a4v:		43.75		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!kz	^ self segmentFromArray: 		"name	rank	duration	features"		#(kz		23		4			(stp vel vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		3		3)		(b1:			60		30.0		50		3		3)		(f2:			1480		1550.0		50		3		3)		(b2:			90		45.0		50		3		3)		(f3:			2620		1580.0		50		3		3)		(b3:			150		75.0		50		3		3)		(fnz:		270		135.0		50		0		0)		(a2f:		54.25		0.0		100		0		0)		(a3f:		54.25		0.0		100		0		0)		(a4f:		33.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		3)		(b3f:		150		75.0		50		3		3)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		54.25		0.0		100		0		0)		(a3v:		54.25		0.0		100		0		0)		(a4v:		33.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!l	^ self segmentFromArray: 		"name	rank	duration	features"		#(l		11		8			(alv lat vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			460		230.0		50		6		0)		(b1:			60		30.0		50		6		0)		(f2:			1480		710.0		50		6		0)		(b2:			90		45.0		50		6		0)		(f3:			2500		1220.0		50		6		0)		(b3:			150		75.0		50		6		0)		(fnz:		270		135.0		50		0		0)		(a2f:		40.25		0.0		100		0		0)		(a3f:		40.25		0.0		100		0		0)		(a4f:		35		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		6		0)		(b3f:		150		75.0		50		6		0)		(anv:		-16		0.0		100		0		0)		(a1v:		50.75		0.0		100		0		0)		(a2v:		40.25		0.0		100		0		0)		(a3v:		40.25		0.0		100		0		0)		(a4v:		35		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ll	^ self segmentFromArray: 		"name	rank	duration	features"		#(ll		11		8			(alv lat vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			460		230.0		50		6		0)		(b1:			60		30.0		50		6		0)		(f2:			940		470.0		50		6		0)		(b2:			90		45.0		50		6		0)		(f3:			2500		1220.0		50		6		0)		(b3:			150		75.0		50		6		0)		(fnz:		270		135.0		50		0		0)		(a2f:		40.25		0.0		100		0		0)		(a3f:		40.25		0.0		100		0		0)		(a4f:		35		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		6		0)		(b3f:		150		75.0		50		6		0)		(anv:		-16		0.0		100		0		0)		(a1v:		50.75		0.0		100		0		0)		(a2v:		40.25		0.0		100		0		0)		(a3v:		40.25		0.0		100		0		0)		(a4v:		35		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!m	^ self segmentFromArray: 		"name	rank	duration	features"		#(m		15		8			(blb nas )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		2		0)		(aspiration:	0		0.0		50		2		0)		(friction:	0		0.0		50		2		0)		(f1:			480		480.0		0		3		0)		(b1:			40		20.0		50		3		0)		(f2:			1000		350.0		50		3		0)		(b2:			175		87.0		50		3		0)		(f3:			2200		0.0		100		5		0)		(b3:			120		0.0		100		5		0)		(fnz:		360		360.0		0		3		0)		(a2f:		44		-10.0		100		3		0)		(a3f:		47		-10.0		100		3		0)		(a4f:		-16		-10.0		100		3		0)		(a5f:		-16		0.0		100		3		0)		(a6f:		-16		0.0		100		3		0)		(bypass:		-16		0.0		100		3		0)		(b2f:		175		87.0		50		3		0)		(b3f:		120		0.0		100		5		0)		(anv:		56		28.0		50		3		0)		(a1v:		40		-10.0		100		3		0)		(a2v:		44		-10.0		100		3		0)		(a3v:		47		-10.0		100		3		0)		(a4v:		-16		-10.0		100		3		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!n	^ self segmentFromArray: 		"name	rank	duration	features"		#(n		15		8			(alv nas )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		2		0)		(aspiration:	0		0.0		50		2		0)		(friction:	0		0.0		50		2		0)		(f1:			480		480.0		0		3		0)		(b1:			40		20.0		50		3		0)		(f2:			1780		950.0		50		3		3)		(b2:			300		150.0		50		3		3)		(f3:			2620		2680.0		0		3		0)		(b3:			260		130.0		50		3		0)		(fnz:		450		450.0		0		3		0)		(a2f:		49		-10.0		100		3		0)		(a3f:		49		-10.0		100		3		0)		(a4f:		34		-10.0		100		3		0)		(a5f:		-16		0.0		100		3		0)		(a6f:		-16		0.0		100		3		0)		(bypass:		-16		0.0		100		3		0)		(b2f:		300		150.0		50		3		3)		(b3f:		260		130.0		50		3		0)		(anv:		56		28.0		50		3		0)		(a1v:		49		-10.0		100		3		0)		(a2v:		49		-10.0		100		3		0)		(a3v:		49		-10.0		100		3		0)		(a4v:		34		-10.0		100		3		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ng	^ self segmentFromArray: 		"name	rank	duration	features"		#(ng		15		8			(nas vel )		"selector		steady	fixed	prop	extern	intern"		(voicing:	52		26.0		50		2		0)		(aspiration:	0		0.0		50		2		0)		(friction:	0		0.0		50		2		0)		(f1:			480		480.0		0		3		0)		(b1:			160		80.0		0		5		0)		(f2:			820		1550.0		50		5		3)		(b2:			150		75.0		50		5		3)		(f3:			2800		1580.0		50		3		3)		(b3:			100		50.0		50		3		0)		(fnz:		360		360.0		0		3		0)		(a2f:		44		0.0		100		3		0)		(a3f:		49		0.0		100		3		0)		(a4f:		14		0.0		100		3		0)		(a5f:		-16		0.0		100		3		0)		(a6f:		-16		0.0		100		3		0)		(bypass:		-16		0.0		100		3		0)		(b2f:		150		75.0		50		5		3)		(b3f:		100		50.0		50		3		0)		(anv:		56		28.0		50		3		3)		(a1v:		34		0.0		100		3		0)		(a2v:		44		0.0		100		3		0)		(a3v:		49		0.0		100		3		0)		(a4v:		14		0.0		100		3		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!o	^ self segmentFromArray: 		"name	rank	duration	features"		#(o		2		6			(bck low rnd vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			610		290.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			880		470.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		61.25		31.5		50		4		4)		(a3f:		36.75		17.5		50		4		4)		(a4f:		29.75		14.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		61.25		31.5		50		4		4)		(a3v:		36.75		17.5		50		4		4)		(a4v:		29.75		14.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!oa	^ self segmentFromArray: 		"name	rank	duration	features"		#(oa		2		6			(cnt mdl unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		230.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			1480		710.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		64.75		31.5		50		5		5)		(a3f:		47.25		24.5		50		5		5)		(a4f:		40.25		21.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		64.75		31.5		50		5		5)		(a3v:		47.25		24.5		50		5		5)		(a4v:		40.25		21.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!oi	^ self segmentFromArray: 		"name	rank	duration	features"		#(oi		2		6			(bck rnd umd vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		230.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			820		350.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		59.5		28.0		50		5		5)		(a3f:		36.75		17.5		50		5		5)		(a4f:		31.5		14.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		59.5		28.0		50		5		5)		(a3v:		36.75		17.5		50		5		5)		(a4v:		31.5		14.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!oo	^ self segmentFromArray: 		"name	rank	duration	features"		#(oo		2		4			(bck rnd smh vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			370		170.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			1000		470.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		56		28.0		50		4		4)		(a3f:		42		21.0		50		4		4)		(a4f:		36.75		17.5		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		56		28.0		50		4		4)		(a3v:		42		21.0		50		4		4)		(a4v:		36.75		17.5		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!oor	^ self segmentFromArray: 		"name	rank	duration	features"		#(oor		2		6			(bck rnd smh vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			370		170.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			1000		470.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		56		28.0		50		5		5)		(a3f:		42		21.0		50		5		5)		(a4f:		36.75		14.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		56		28.0		50		5		5)		(a3v:		42		21.0		50		5		5)		(a4v:		36.75		14.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!or	^ self segmentFromArray: 		"name	rank	duration	features"		#(or		2		6			(bck lmd rnd vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		230.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			820		470.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		59.5		28.0		50		5		5)		(a3f:		36.75		17.5		50		5		5)		(a4f:		31.5		14.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		59.5		28.0		50		5		5)		(a3v:		36.75		17.5		50		5		5)		(a4v:		31.5		14.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ou	^ self segmentFromArray: 		"name	rank	duration	features"		#(ou		2		6			(cnt low unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			790		410.0		50		5		5)		(b1:			60		30.0		50		5		5)		(f2:			1300		590.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			2500		1220.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		61.25		31.5		50		5		5)		(a3f:		49		24.5		50		5		5)		(a4f:		42		21.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		64.75		31.5		50		5		5)		(a2v:		61.25		31.5		50		5		5)		(a3v:		49		24.5		50		5		5)		(a4v:		42		21.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ov	^ self segmentFromArray: 		"name	rank	duration	features"		#(ov		2		6			(bck rnd smh vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			370		170.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			1000		470.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		56		28.0		50		4		4)		(a3f:		42		21.0		50		4		4)		(a4f:		36.75		17.5		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		56		28.0		50		4		4)		(a3v:		42		21.0		50		4		4)		(a4v:		36.75		17.5		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!p	^ self segmentFromArray: 		"name	rank	duration	features"		#(p		23		8			(blb stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			760		350.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2500		0.0		100		0		2)		(b3:			150		0.0		100		0		2)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		0.0		100		0		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!py	^ self segmentFromArray: 		"name	rank	duration	features"		#(py		29		1			(blb stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			760		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2500		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		63		0.0		100		0		0)		(a3f:		57.75		0.0		100		0		0)		(a4f:		52.5		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		38.5		0.0		100		0		0)		(a2v:		63		0.0		100		0		0)		(a3v:		57.75		0.0		100		0		0)		(a4v:		52.5		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!pz	^ self segmentFromArray: 		"name	rank	duration	features"		#(pz		23		2			(blb stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			760		350.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2500		0.0		100		2		2)		(b3:			150		0.0		100		2		2)		(fnz:		270		135.0		50		0		0)		(a2f:		52.5		0.0		100		0		0)		(a3f:		47.25		0.0		100		0		0)		(a4f:		42		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		0.0		100		2		2)		(anv:		-16		0.0		100		0		0)		(a1v:		38.5		0.0		100		0		0)		(a2v:		52.5		0.0		100		0		0)		(a3v:		47.25		0.0		100		0		0)		(a4v:		42		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!q	^ self segmentFromArray: 		"name	rank	duration	features"		#(q		29		6			(0 )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		0.0		100		3		3)		(b1:			60		0.0		100		3		3)		(f2:			1480		0.0		100		3		3)		(b2:			90		0.0		100		3		3)		(f3:			2500		0.0		100		3		3)		(b3:			150		0.0		100		3		3)		(fnz:		270		135.0		50		3		3)		(a2f:		-16		-10.5		100		3		0)		(a3f:		-16		-10.5		100		3		0)		(a4f:		-16		-10.5		100		3		0)		(a5f:		-16		0.0		100		3		0)		(a6f:		-16		0.0		100		3		0)		(bypass:		-16		0.0		100		3		0)		(b2f:		90		0.0		100		3		3)		(b3f:		150		0.0		100		3		3)		(anv:		-16		-10.5		100		3		0)		(a1v:		-16		-10.5		100		3		0)		(a2v:		-16		-10.5		100		3		0)		(a3v:		-16		-10.5		100		3		0)		(a4v:		-16		-10.5		100		3		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!qq	^ self segmentFromArray: 		"name	rank	duration	features"		#(qq		30		0			(frc vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			280		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			1420		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2560		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		54.25		0.0		100		0		0)		(a3f:		50.75		0.0		100		0		0)		(a4f:		47.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		54.25		0.0		100		0		0)		(a3v:		50.75		0.0		100		0		0)		(a4v:		47.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!r	^ self segmentFromArray: 		"name	rank	duration	features"		#(r		10		11			(alv apr )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		0.0		100		0		5)		(b1:			60		0.0		100		0		5)		(f2:			1180		590.0		50		5		5)		(b2:			90		45.0		50		5		5)		(f3:			1600		740.0		50		5		5)		(b3:			150		75.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		49		24.5		50		5		5)		(a3f:		49		24.5		50		5		5)		(a4f:		-16		7.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		150		75.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		56		28.0		50		5		5)		(a2v:		49		24.5		50		5		5)		(a3v:		49		24.5		50		5		5)		(a4v:		-16		7.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!rx	^ self segmentFromArray: 		"name	rank	duration	features"		#(rx		10		10			(rzd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	50		25.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			490		0.0		100		0		5)		(b1:			60		30.0		50		0		5)		(f2:			1180		0.0		100		0		5)		(b2:			90		45.0		50		5		5)		(f3:			1600		1600.0		0		5		5)		(b3:			70		35.0		50		5		5)		(fnz:		270		135.0		50		0		0)		(a2f:		49		24.5		50		5		5)		(a3f:		49		24.5		50		5		5)		(a4f:		-16		7.0		50		5		5)		(a5f:		-16		-8.0		50		5		5)		(a6f:		-16		-8.0		50		5		5)		(bypass:		-16		-8.0		50		5		5)		(b2f:		90		45.0		50		5		5)		(b3f:		70		35.0		50		5		5)		(anv:		-16		0.0		100		5		5)		(a1v:		56		28.0		50		5		5)		(a2v:		49		24.5		50		5		5)		(a3v:		49		24.5		50		5		5)		(a4v:		-16		7.0		50		5		5))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!s	^ self segmentFromArray: 		"name	rank	duration	features"		#(s		18		12			(alv frc vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	32		16.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			400		170.0		50		3		2)		(b1:			200		100.0		50		3		2)		(f2:			1720		950.0		50		3		2)		(b2:			96		48.0		50		3		2)		(f3:			2620		0.0		100		3		2)		(b3:			220		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		42		0.0		100		0		0)		(a3f:		42		0.0		100		0		0)		(a4f:		54.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		96		48.0		50		3		2)		(b3f:		220		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		42		0.0		100		0		0)		(a3v:		42		0.0		100		0		0)		(a4v:		54.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!sh	^ self segmentFromArray: 		"name	rank	duration	features"		#(sh		18		12			(frc pla vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			400		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			2200		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		45.5		0.0		100		0		0)		(a3f:		56		0.0		100		0		0)		(a4f:		45.5		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		45.5		0.0		100		0		0)		(a3v:		56		0.0		100		0		0)		(a4v:		45.5		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!t	^ self segmentFromArray: 		"name	rank	duration	features"		#(t		23		6			(alv stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		2		2)		(b1:			60		30.0		50		2		2)		(f2:			1780		950.0		50		2		2)		(b2:			90		45.0		50		2		2)		(f3:			2680		2680.0		0		0		2)		(b3:			150		150.0		0		0		2)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		-16		0.0		100		0		0)		(a4f:		-16		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		2)		(b3f:		150		150.0		0		0		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		-16		0.0		100		0		0)		(a4v:		-16		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!th	^ self segmentFromArray: 		"name	rank	duration	features"		#(th		18		15			(dnt frc vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			400		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1780		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2680		2680.0		0		3		2)		(b3:			150		150.0		0		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		40.25		0.0		100		0		0)		(a3f:		42		0.0		100		0		0)		(a4f:		36.75		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		150.0		0		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		40.25		0.0		100		0		0)		(a3v:		42		0.0		100		0		0)		(a4v:		36.75		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!ty	^ self segmentFromArray: 		"name	rank	duration	features"		#(ty		29		1			(alv stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		0.0		100		0		0)		(b1:			60		0.0		100		0		0)		(f2:			1780		0.0		100		0		0)		(b2:			90		0.0		100		0		0)		(f3:			2680		0.0		100		0		0)		(b3:			150		0.0		100		0		0)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		52.5		0.0		100		0		0)		(a4f:		64.75		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		0.0		100		0		0)		(b3f:		150		0.0		100		0		0)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		52.5		0.0		100		0		0)		(a4v:		64.75		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!tz	^ self segmentFromArray: 		"name	rank	duration	features"		#(tz		23		2			(alv stp vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		2		1)		(b1:			60		30.0		50		2		1)		(f2:			1780		950.0		50		2		1)		(b2:			90		45.0		50		2		1)		(f3:			2680		2680.0		0		2		0)		(b3:			150		150.0		0		2		0)		(fnz:		270		135.0		50		0		0)		(a2f:		-16		0.0		100		0		0)		(a3f:		42		0.0		100		0		0)		(a4f:		54.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		2		1)		(b3f:		150		150.0		0		2		0)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		-16		0.0		100		0		0)		(a3v:		42		0.0		100		0		0)		(a4v:		54.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!u	^ self segmentFromArray: 		"name	rank	duration	features"		#(u		2		6			(bck lmd unr vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			700		350.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			1360		710.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2500		1220.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		57.75		28.0		50		4		4)		(a3f:		45.5		21.0		50		4		4)		(a4f:		38.5		17.5		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		57.75		28.0		50		4		4)		(a3v:		45.5		21.0		50		4		4)		(a4v:		38.5		17.5		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!uu	^ self segmentFromArray: 		"name	rank	duration	features"		#(uu		2		9			(bck hgh rnd vwl )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			250		110.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			880		470.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2200		1100.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		52.5		24.5		50		4		4)		(a3f:		31.5		14.0		50		4		4)		(a4f:		24.5		10.5		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		52.5		24.5		50		4		4)		(a3v:		31.5		14.0		50		4		4)		(a4v:		24.5		10.5		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!v	^ self segmentFromArray: 		"name	rank	duration	features"		#(v		20		4			(frc lbd vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1420		350.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		980.0		50		3		2)		(b3:			150		75.0		50		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		54.25		0.0		100		0		0)		(a3f:		50.75		0.0		100		0		0)		(a4f:		47.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		75.0		50		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		54.25		0.0		100		0		0)		(a3v:		50.75		0.0		100		0		0)		(a4v:		47.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!w	^ self segmentFromArray: 		"name	rank	duration	features"		#(w		10		8			(apr lbv vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			190		50.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			760		350.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2020		980.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		42		21.0		50		4		4)		(a3f:		35		17.5		50		4		4)		(a4f:		-16		7.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		57.75		28.0		50		4		4)		(a2v:		42		21.0		50		4		4)		(a3v:		35		17.5		50		4		4)		(a4v:		-16		7.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!x	^ self segmentFromArray: 		"name	rank	duration	features"		#(x		18		12			(frc vel vls )		"selector		steady	fixed	prop	extern	intern"		(voicing:	0		0.0		50		0		0)		(aspiration:	60		30.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			190		110.0		50		3		3)		(b1:			60		30.0		50		3		3)		(f2:			1480		1550.0		50		3		3)		(b2:			90		45.0		50		3		3)		(f3:			2620		1580.0		50		3		3)		(b3:			150		75.0		50		3		3)		(fnz:		270		135.0		50		0		0)		(a2f:		54.25		0.0		100		0		0)		(a3f:		54.25		0.0		100		0		0)		(a4f:		33.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		3)		(b3f:		150		75.0		50		3		3)		(anv:		-16		0.0		100		0		0)		(a1v:		-16		0.0		100		0		0)		(a2v:		54.25		0.0		100		0		0)		(a3v:		54.25		0.0		100		0		0)		(a4v:		33.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!y	^ self segmentFromArray: 		"name	rank	duration	features"		#(y		10		7			(apr pal vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			250		110.0		50		4		4)		(b1:			60		30.0		50		4		4)		(f2:			2500		1190.0		50		4		4)		(b2:			90		45.0		50		4		4)		(f3:			2980		1460.0		50		4		4)		(b3:			150		75.0		50		4		4)		(fnz:		270		135.0		50		0		0)		(a2f:		47.25		24.5		50		4		4)		(a3f:		52.5		24.5		50		4		4)		(a4f:		45.5		21.0		50		4		4)		(a5f:		-16		-8.0		50		4		4)		(a6f:		-16		-8.0		50		4		4)		(bypass:		-16		-8.0		50		4		4)		(b2f:		90		45.0		50		4		4)		(b3f:		150		75.0		50		4		4)		(anv:		-16		0.0		100		4		4)		(a1v:		64.75		31.5		50		4		4)		(a2v:		47.25		24.5		50		4		4)		(a3v:		52.5		24.5		50		4		4)		(a4v:		45.5		21.0		50		4		4))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!z	^ self segmentFromArray: 		"name	rank	duration	features"		#(z		20		4			(alv frc vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	40		20.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	60		30.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1720		950.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		38.5		0.0		100		0		0)		(a3f:		38.5		0.0		100		0		0)		(a4f:		50.75		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		38.5		0.0		100		0		0)		(a3v:		38.5		0.0		100		0		0)		(a4v:		50.75		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!zh	^ self segmentFromArray: 		"name	rank	duration	features"		#(zh		20		4			(frc pla vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			2020		1190.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		40.25		0.0		100		0		0)		(a3f:		50.75		0.0		100		0		0)		(a4f:		40.25		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		40.25		0.0		100		0		0)		(a3v:		50.75		0.0		100		0		0)		(a4v:		40.25		0.0		100		0		0))! !!KlattSegmentSet methodsFor: 'default segments' stamp: 'len 12/6/1999 02:25'!zz	^ self segmentFromArray: 		"name	rank	duration	features"		#(zz		20		4			(alv frc vcd )		"selector		steady	fixed	prop	extern	intern"		(voicing:	62		31.0		50		0		0)		(aspiration:	0		0.0		50		0		0)		(friction:	0		0.0		50		0		0)		(f1:			280		170.0		50		3		2)		(b1:			60		30.0		50		3		2)		(f2:			1720		950.0		50		3		2)		(b2:			90		45.0		50		3		2)		(f3:			2560		0.0		100		3		2)		(b3:			150		0.0		100		3		2)		(fnz:		270		135.0		50		0		0)		(a2f:		38.5		0.0		100		0		0)		(a3f:		38.5		0.0		100		0		0)		(a4f:		50.75		0.0		100		0		0)		(a5f:		-16		0.0		100		0		0)		(a6f:		-16		0.0		100		0		0)		(bypass:		-16		0.0		100		0		0)		(b2f:		90		45.0		50		3		2)		(b3f:		150		0.0		100		3		2)		(anv:		-16		0.0		100		0		0)		(a1v:		43.75		0.0		100		0		0)		(a2v:		38.5		0.0		100		0		0)		(a3v:		38.5		0.0		100		0		0)		(a4v:		50.75		0.0		100		0		0))! !!KlattSegmentSet class methodsFor: 'instance creation' stamp: 'len 10/12/1999 00:47'!arpabet	^ self new initializeArpabet! !!KlattSynthesizer commentStamp: '<historical>' prior: 0!My instances are Klatt-style cascade/parallel formant synthesizers, first described by Dennis Klatt in [1]. An updated version of the model was described in [2]. This version implements the LF (Liljencrants-Fant) glottal pulse model from [3], and the jitter and shimmer parameters suggested in [4]. For a description of the Klatt parameters, see KlattFrame.References:	[1] Klatt,D.H. "Software for a cascade/parallel formant synthesizer", in the Journal of the Acoustical Society of America, pages 971-995, volume 67, number 3, March 1980.	[2] Klatt,D.H. and Klatt, L.C. "Analysis, synthesis and perception of voice quality variations among female and male talkers". In the Journal of the Acoustical Society of America, pages 820-857, volume 87, number 2. February 1990.	[3] Fant, G., Liljencrants, J., & Lin, Q. "A four-parameter model of glottal flow", Speech Transmission Laboratory Qurterly Progress Report 4/85, KTH.	[4] Alwan, A., Bangayan, P., Kreiman, J., and Long, C. "Time and Frequency Synthesis Parameters of Severely Pathological Voice Qualities."!!KlattSynthesizer methodsFor: 'initialization' stamp: 'len 9/2/1999 01:44'!defaultMillisecondsPerFrame	"Default is 10 milliseconds per frame."	^ 10! !!KlattSynthesizer methodsFor: 'initialization' stamp: 'len 11/8/1999 01:25'!initialize	"Initialize the Klatt synthesizer."	"Seed for noise generation:"	seed _ 17.	"Sampling rate and millseconds per frame:"	self samplingRate: 22025.	self millisecondsPerFrame: self defaultMillisecondsPerFrame.	"Number of formants in the cascade branch: (0 to 8)"	self cascade: 0! !!KlattSynthesizer methodsFor: 'initialization' stamp: 'len 12/19/1999 05:36'!initializeResonators	resonators _ FloatArray new: 24 * 5		"24 resonators, 5 floats each"! !!KlattSynthesizer methodsFor: 'initialization' stamp: 'len 12/19/1999 04:51'!initializeState	self initializeResonators.	pitch _ 110.0.	t0 _ (samplingRate / pitch) asInteger.	nper _ 0.	nopen _ 0.	nmod _ 0.	periodCount _ 0.	samplesCount _ 0.	vlast _ 0.0.	glast _ 0.0.	nlast _ 0.0.	self ro: 0.25 ra: 0.01 rk: 0.25! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:53'!antiResonator: index frequency: freq bandwidth: bw	"Set up an anti-resonator"	| arg r a b c |	arg _ 0.0 - Float pi / samplingRate * bw.	r _ arg exp.	c _ 0.0 - (r * r).	arg _ Float pi * 2.0 / samplingRate * freq.	b _ r * arg cos * 2.0.	a _ 1.0 - b - c.	a _ 1.0 / a.	b _ 0.0 - b * a.	c _ 0.0 - c * a.	self resonatorA: index put: a.	self resonatorB: index put: b.	self resonatorC: index put: c! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:54'!antiResonator: index value: aFloat	| answer p1 |	answer _ (self resonatorA: index) * aFloat			+ ((self resonatorB: index) * (p1 _ self resonatorP1: index))			+ ((self resonatorC: index) * (self resonatorP2: index)).	self resonatorP2: index put: p1.	self resonatorP1: index put: aFloat.	^ answer! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:55'!resonator: index frequency: freq bandwidth: bw	"Convert formant frequencies and bandwidth into	resonator difference equation coefficients."	| arg r a b c |	arg _ 0.0 - Float pi / samplingRate * bw.	r _ arg exp.	c _ 0.0 - (r * r).	arg _ Float pi * 2.0 / samplingRate * freq.	b _ r * arg cos * 2.0.	a _ 1.0 - b - c.	self resonatorA: index put: a.	self resonatorB: index put: b.	self resonatorC: index put: c! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 10/29/1999 01:32'!resonator: index frequency: freq bandwidth: bw gain: gain	"Convert formant frequencies and bandwidth into	resonator difference equation coefficients."	self resonator: index frequency: freq bandwidth: bw.	self resonatorA: index put: (self resonatorA: index) * gain! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:55'!resonator: index value: aFloat	| answer p1 |	answer _ (self resonatorA: index) * aFloat			+ ((self resonatorB: index) * (p1 _ self resonatorP1: index))			+ ((self resonatorC: index) * (self resonatorP2: index)).	self resonatorP2: index put: p1.	self resonatorP1: index put: answer.	^ answer! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:58'!resonatorA: index	^resonators at: index * 5 - 4! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:58'!resonatorA: index put: aFloat	resonators at: index*5-4 put: aFloat! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:58'!resonatorB: index	^resonators at: index*5-3! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorB: index put: aFloat	resonators at: index*5-3 put: aFloat! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorC: index	^resonators at: index*5-2! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorC: index put: aFloat	resonators at: index*5-2 put: aFloat! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorP1: index	^resonators at: index*5-1! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorP1: index put: aFloat	resonators at: index*5-1 put: aFloat! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorP2: index	^resonators at: index*5! !!KlattSynthesizer methodsFor: 'accessing-resonators' stamp: 'len 8/29/1999 23:59'!resonatorP2: index put: aFloat	resonators at: index*5 put: aFloat! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 9/18/1999 00:50'!cascade	"Answer the number of formants in the cascade branch."	^ cascade! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 9/18/1999 00:51'!cascade: anInteger	"Set the number of formants in the cascade branch."	cascade _ anInteger! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 10/8/1999 02:09'!millisecondsPerFrame	^ 1000.0 / self samplingRate * self samplesPerFrame! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 9/3/1999 02:48'!millisecondsPerFrame: aNumber	self samplesPerFrame: (aNumber * self samplingRate / 1000) asInteger! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 8/24/1999 02:45'!samplesPerFrame	^ samplesPerFrame! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 9/2/1999 01:42'!samplesPerFrame: anInteger	samplesPerFrame _ anInteger! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 8/24/1999 02:45'!samplingRate	^ samplingRate! !!KlattSynthesizer methodsFor: 'accessing' stamp: 'len 10/3/1999 20:23'!samplingRate: anInteger	samplingRate _ anInteger.	self initializeState! !!KlattSynthesizer methodsFor: 'processing-LF' stamp: 'len 9/16/1999 00:28'!qu: u phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid	| expuphi |	expuphi _ (u * phi) exp.	^ expuphi * ((rphid * (u*u + 1.0) + u) * sinphi - cosphi) + 1.0! !!KlattSynthesizer methodsFor: 'processing-LF' stamp: 'len 9/19/1999 02:38'!ro: roNumber ra: raNumber rk: rkNumber	| r d phi cosphi sinphi rphid u theta rho gamma gammapwr te ro ra rk |	te _ (t0 * roNumber) asInteger.	ro _ te asFloat / t0 asFloat.	rk _ rkNumber.	ra _ raNumber.	ra <= 0.0		ifTrue: [d _ 1.0]		ifFalse: [r _ 1.0 - ro / ra.				d _ 1.0 - (r / (r exp - 1.0))].	phi _ Float pi * (rk + 1.0).	cosphi _ phi cos.	sinphi _ phi sin.	rphid _ ra / ro * phi * d.	u _ self zeroQphi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.	theta _ phi / te.	rho _ (u * theta) exp.	a1 _ 2.0 * theta cos * rho.	a2 _ 0.0 - (rho * rho).	x2 _ 0.0.	x1 _ rho * theta sin.	gamma _ (-1.0 / (ra * t0)) exp.	gammapwr _ gamma raisedTo: t0 - te.	b1 _ gamma.	c1 _ (1.0 - gamma) * gammapwr / (1.0 - gammapwr)! !!KlattSynthesizer methodsFor: 'processing-LF' stamp: 'len 9/16/1999 00:28'!zeroQphi: phi cosphi: cosphi sinphi: sinphi rphid: rphid	| qzero ua ub qa qb uc qc |	qzero _ self qu: 0 phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.	qzero > 0		ifTrue: [ua _ 0. ub _ 1.				qa _ qzero. qb _ self qu: ub phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.				[qb > 0]					whileTrue: [ua _ ub. qa _ qb.								ub _ ub * 2. qb _ self qu: ub phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid]]		ifFalse: [ua _ -1. ub _ 0.				qa _ self qu: ua phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid. qb _ qzero.				[qa < 0]					whileTrue: [ub _ ua. qb _ qa.								ua _ ua * 2. qa _ self qu: ua phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid]].	[ub - ua > Epsilon]		whileTrue: [uc _ ub + ua / 2. qc _ self qu: uc phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.					qc > 0 ifTrue: [ua _ uc. qa _ qc] ifFalse: [ub _ uc. qb _ qc]].	^ ub + ua / 2! !!KlattSynthesizer methodsFor: 'processing' stamp: 'len 12/1/1999 02:42'!samplesFromFrames: aCollection	| buffer index |	buffer _ SoundBuffer newMonoSampleCount: aCollection size * samplesPerFrame.	index _ 1.	aCollection do: [ :each |		self synthesizeFrame: each into: buffer startingAt: index.		index _ samplesPerFrame + index].	^ buffer! !!KlattSynthesizer methodsFor: 'processing' stamp: 'len 9/4/1999 00:20'!soundFromFrames: aCollection	^ SampledSound samples: (self samplesFromFrames: aCollection) samplingRate: samplingRate! !!KlattSynthesizer methodsFor: 'processing' stamp: 'len 12/21/1999 01:46'!synthesizeFrame: aKlattFrame into: aSoundBuffer startingAt: index	<primitive: 'primitiveSynthesizeFrameIntoStartingAt' module: 'Klatt'>	KlattSynthesizerPlugin doPrimitive: 'primitiveSynthesizeFrameIntoStartingAt'! !!KlattSynthesizer methodsFor: 'testing' stamp: 'len 9/27/1999 01:06'!isAllParallel	"Answer true if the receiver is not using the cascade branch."	^ self cascade = 0! !!KlattSynthesizer class methodsFor: 'instance creation' stamp: 'len 4/8/98 03:33'!new	^ super new initialize! !!KlattSynthesizerPlugin commentStamp: '<historical>' prior: 0!This is a pluggable primitive implementation of the KlattSynthesizer.!!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:14'!antiResonator: index frequency: freq bandwidth: bw	"Set up an anti-resonator"	| arg r a b c |	self returnTypeC: 'void'.	self var: 'freq' declareC: 'float freq'.	self var: 'bw' declareC: 'float bw'.	self var: 'arg' declareC: 'double arg'.	self var: 'a' declareC: 'float a'.	self var: 'b' declareC: 'float b'.	self var: 'c' declareC: 'float c'.	self var: 'r' declareC: 'float r'.	arg _ 0.0 - PI / samplingRate * bw.	r _ arg exp.	c _ 0.0 - (r * r).	arg _ PI * 2.0 / samplingRate * freq.	b _ r * arg cos * 2.0.	a _ 1.0 - b - c.	a _ 1.0 / a.	b _ 0.0 - b * a.	c _ 0.0 - c * a.	self resonatorA: index put: a.	self resonatorB: index put: b.	self resonatorC: index put: c! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:14'!antiResonator: index value: aFloat	| answer p1 |	self inline: true.	self returnTypeC: 'float'.	self var: 'aFloat' declareC: 'double aFloat'.	self var: 'answer' declareC: 'double answer'.	self var: 'p1' declareC: 'double p1'.	answer _ (self resonatorA: index) * aFloat			+ ((self resonatorB: index) * (p1 _ self resonatorP1: index))			+ ((self resonatorC: index) * (self resonatorP2: index)).	self resonatorP2: index put: p1.	self resonatorP1: index put: aFloat.	^ answer! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:15'!resonator: index frequency: freq bandwidth: bw	"Convert formant frequencies and bandwidth into	resonator difference equation coefficients."	| arg r a b c |	self returnTypeC: 'void'.	self var: 'freq' declareC: 'float freq'.	self var: 'bw' declareC: 'float bw'.	self var: 'arg' declareC: 'double arg'.	self var: 'a' declareC: 'float a'.	self var: 'b' declareC: 'float b'.	self var: 'c' declareC: 'float c'.	self var: 'r' declareC: 'float r'.	arg _ 0.0 - PI / samplingRate * bw.	r _ arg exp.	c _ 0.0 - (r * r).	arg _ PI * 2.0 / samplingRate * freq.	b _ r * arg cos * 2.0.	a _ 1.0 - b - c.	self resonatorA: index put: a.	self resonatorB: index put: b.	self resonatorC: index put: c! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 10/29/1999 01:32'!resonator: index frequency: freq bandwidth: bw gain: gain	"Convert formant frequencies and bandwidth into	resonator difference equation coefficients."	self returnTypeC: 'void'.	self var: 'freq' declareC: 'float freq'.	self var: 'bw' declareC: 'float bw'.	self var: 'gain' declareC: 'float gain'.	self resonator: index frequency: freq bandwidth: bw.	self resonatorA: index put: (self resonatorA: index) * gain! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:15'!resonator: index value: aFloat	| answer p1 |	self inline: true.	self returnTypeC: 'float'.	self var: 'aFloat' declareC: 'float aFloat'.	self var: 'answer' declareC: 'float answer'.	self var: 'p1' declareC: 'float p1'.	answer _ (self resonatorA: index) * aFloat			+ ((self resonatorB: index) * (p1 _ self resonatorP1: index))			+ ((self resonatorC: index) * (self resonatorP2: index)).	"(p1 between: -100000 and: 100000) ifFalse: [self halt].	(answer between: -100000 and: 100000) ifFalse: [self halt]."	self resonatorP2: index put: p1.	self resonatorP1: index put: answer.	^ answer! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorA: index	self inline: true.	self returnTypeC: 'float'.	^resonators at: index*5-5! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorA: index put: aFloat	self inline: true.	self returnTypeC: 'void'.	self var: 'aFloat' declareC: 'float aFloat'.	resonators at: index*5-5 put: aFloat! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorB: index	self inline: true.	self returnTypeC: 'float'.	^resonators at: index*5-4! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorB: index put: aFloat	self inline: true.	self returnTypeC: 'void'.	self var: 'aFloat' declareC: 'float aFloat'.	resonators at: index*5-4 put: aFloat! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorC: index	self inline: true.	self returnTypeC: 'float'.	^resonators at: index*5-3! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorC: index put: aFloat	self inline: true.	self returnTypeC: 'void'.	self var: 'aFloat' declareC: 'float aFloat'.	resonators at: index*5-3 put: aFloat! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorP1: index	self inline: true.	self returnTypeC: 'float'.	^resonators at: index*5-2! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorP1: index put: aFloat	self inline: true.	self returnTypeC: 'void'.	self var: 'aFloat' declareC: 'float aFloat'.	resonators at: index*5-2 put: aFloat! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorP2: index	self inline: true.	self returnTypeC: 'float'.	^resonators at: index*5-1! !!KlattSynthesizerPlugin methodsFor: 'resonators' stamp: 'len 9/6/1999 00:16'!resonatorP2: index put: aFloat	self inline: true.	self returnTypeC: 'void'.	self var: 'aFloat' declareC: 'float aFloat'.	resonators at: index*5-1 put: aFloat! !!KlattSynthesizerPlugin methodsFor: 'processing-LF' stamp: 'len 12/19/1999 04:55'!glottalSource	| x0 |	self inline: true.	self returnTypeC: 'float'.	self var: 'x0' declareC: 'float x0'.	t0 = 0 ifTrue: [^ 0].	nper < nopen		ifTrue: [x0 _ a1 * x1 + (a2 * x2).				x2 _ x1.				x1 _ x0]		ifFalse: [x0 _ b1 * x1 - c1.				x1 _ x0].	"Reset period when 'nper' reaches t0."	nper >= t0 ifTrue: [nper _ 0. self pitchSynchronousReset].	nper _ nper + 1.	^ x0! !!KlattSynthesizerPlugin methodsFor: 'processing-LF' stamp: 'len 10/29/1999 02:24'!normalizeGlottalPulse	| s1 s2 s0 |	self inline: true.	self returnTypeC: 'void'.	self var: 's0' declareC: 'float s0'.	self var: 's1' declareC: 'float s1'.	self var: 's2' declareC: 'float s2'.	s0 _ 0.0.	s1 _ x1.	s2 _ x2.	1 to: nopen do: [ :ingore |		s0 _ a1 * s1 + (a2 * s2).		s2 _ s1.		s1 _ s0].	s0 = 0.0 ifFalse: [x1 _ x1 / s0 * 10000.0]! !!KlattSynthesizerPlugin methodsFor: 'processing-LF' stamp: 'len 9/19/1999 02:29'!qu: u phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid	| expuphi |	self returnTypeC: 'float'.	self var: 'u' declareC: 'float u'.	self var: 'phi' declareC: 'float phi'.	self var: 'cosphi' declareC: 'float cosphi'.	self var: 'sinphi' declareC: 'float sinphi'.	self var: 'rphid' declareC: 'float rphid'.	self var: 'expuphi' declareC: 'float expuphi'.	expuphi _ (u * phi) exp.	^ expuphi * ((rphid * (u*u + 1.0) + u) * sinphi - cosphi) + 1.0! !!KlattSynthesizerPlugin methodsFor: 'processing-LF' stamp: 'len 11/8/1999 00:42'!ro: roNumber ra: raNumber rk: rkNumber	| r d phi cosphi sinphi rphid u theta rho gamma gammapwr te ro ra rk |	self returnTypeC: 'void'.	self var: 'roNumber' declareC: 'float roNumber'.	self var: 'raNumber' declareC: 'float raNumber'.	self var: 'rkNumber' declareC: 'float rkNumber'.	self var: 'r' declareC: 'float r'.	self var: 'd' declareC: 'float d'.	self var: 'phi' declareC: 'float phi'.	self var: 'cosphi' declareC: 'float cosphi'.	self var: 'sinphi' declareC: 'float sinphi'.	self var: 'rphid' declareC: 'float rphid'.	self var: 'u' declareC: 'float u'.	self var: 'theta' declareC: 'float theta'.	self var: 'rho' declareC: 'float rho'.	self var: 'gamma' declareC: 'float gamma'.	self var: 'gammapwr' declareC: 'float gammapwr'.	self var: 'ro' declareC: 'float ro'.	self var: 'ra' declareC: 'float ra'.	self var: 'rk' declareC: 'float rk'.	te _ (t0 * roNumber) asInteger.	ro _ te asFloat / t0 asFloat.	rk _ rkNumber.	ra _ raNumber.	ra <= 0.0		ifTrue: [d _ 1.0]		ifFalse: [r _ 1.0 - ro / ra.				d _ 1.0 - (r / (r exp - 1.0))].	phi _ PI * (rk + 1.0).	cosphi _ phi cos.	sinphi _ phi sin.	rphid _ ra / ro * phi * d.	u _ self zeroQphi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.	theta _ phi / te.	rho _ (u * theta) exp.	a1 _ 2.0 * theta cos * rho.	a2 _ 0.0 - (rho * rho).	x2 _ 0.0.	x1 _ rho * theta sin.	gamma _ (-1.0 / (ra * t0)) exp.	gammapwr _ gamma raisedTo: t0 - te.	b1 _ gamma.	c1 _ (1.0 - gamma) * gammapwr / (1.0 - gammapwr).	self normalizeGlottalPulse! !!KlattSynthesizerPlugin methodsFor: 'processing-LF' stamp: 'len 9/20/1999 01:46'!zeroQphi: phi cosphi: cosphi sinphi: sinphi rphid: rphid	| qzero ua ub qa qb uc qc |	self returnTypeC: 'float'.	self var: 'qzero' declareC: 'float qzero'.	self var: 'ua' declareC: 'float ua'.	self var: 'ub' declareC: 'float ub'.	self var: 'qa' declareC: 'float qa'.	self var: 'qb' declareC: 'float qb'.	self var: 'uc' declareC: 'float uc'.	self var: 'qc' declareC: 'float qc'.	self var: 'phi' declareC: 'float phi'.	self var: 'cosphi' declareC: 'float cosphi'.	self var: 'sinphi' declareC: 'float sinphi'.	self var: 'rphid' declareC: 'float rphid'.	qzero _ self qu: 0 phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.	qzero > 0		ifTrue: [ua _ 0. ub _ 1.				qa _ qzero. qb _ self qu: ub phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.				[qb > 0]					whileTrue: [ua _ ub. qa _ qb.								ub _ ub * 2. qb _ self qu: ub phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid]]		ifFalse: [ua _ -1. ub _ 0.				qa _ self qu: ua phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid. qb _ qzero.				[qa < 0]					whileTrue: [ub _ ua. qb _ qa.								ua _ ua * 2. qa _ self qu: ua phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid]].	[ub - ua > Epsilon]		whileTrue: [uc _ ub + ua / 2.0. qc _ self qu: uc phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.					qc > 0 ifTrue: [ua _ uc. qa _ qc] ifFalse: [ub _ uc. qb _ qc]].	^ ub + ua / 2.0! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 12/17/1999 03:16'!addAmplitudeDiplophonia	"Add diplophonia (bicyclic voice). Change voicing amplitude."	self returnTypeC: 'void'.	periodCount \\ 2 = 0		ifFalse: [x1 _ x1 * (1.0 - (frame at: Diplophonia)).				"x1 must be <= 0"				x1 > 0 ifTrue: [x1 _ 0]]! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 12/17/1999 03:51'!addFlutter	"Add F0 flutter, as specified in:		'Analysis, synthesis and perception of voice quality variations among		female and male talkers' D.H. Klatt and L.C. Klatt JASA 87(2) February 1990.	Flutter is added by applying a quasi-random element constructed from three	slowly varying sine waves."	| timeCount asin bsin csin deltaF0 |	self returnTypeC: 'void'.	self var: 'timeCount' declareC: 'float timeCount'.	self var: 'asin' declareC: 'float asin'.	self var: 'bsin' declareC: 'float bsin'.	self var: 'csin' declareC: 'float csin'.	self var: 'deltaF0' declareC: 'double deltaF0'.	timeCount _ (self cCoerce: samplesCount to: 'float') / (self cCoerce: samplingRate to: 'float').	asin _ (2.0 * PI * 12.7 * timeCount) sin.	bsin _ (2.0 * PI * 7.1 * timeCount) sin.	csin _ (2.0 * PI * 4.7 * timeCount) sin.	deltaF0 _ (frame at: Flutter) * 2.0 * (frame at: F0) / 100.0 * (asin + bsin + csin).	pitch _ pitch + deltaF0! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 12/17/1999 03:11'!addFrequencyDiplophonia	"Add diplophonia (bicyclic voice). Change F0."	self returnTypeC: 'void'.	periodCount \\ 2 = 0		ifTrue: [pitch _ pitch + ((frame at: Diplophonia) * (frame at: F0) * (1.0 - (frame at: Ro)))]		ifFalse: [pitch _ pitch - ((frame at: Diplophonia) * (frame at: F0) * (1.0 - (frame at: Ro)))]! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 11/22/1999 02:44'!addJitter	"Add jitter (random F0 perturbation)."	self returnTypeC: 'void'.	pitch _ pitch + (self nextRandom - 32767 * (frame at: Jitter) / 32768.0 * (frame at: F0))! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 11/22/1999 02:45'!addShimmer	"Add shimmer (random voicing amplitude perturbation)."	self returnTypeC: 'void'.	x1 _ x1 + (self nextRandom - 32767 * (frame at: Shimmer) / 32768.0 * x1).	"x1 must be <= 0"	x1 > 0 ifTrue: [x1 _ 0]! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 12/21/1999 02:24'!pitchSynchronousReset	self returnTypeC: 'void'.	(frame at: F0) > 0		ifTrue: [self voicedPitchSynchronousReset.				periodCount _ periodCount + 1 \\ 65535]		ifFalse: [t0 _ 1.				nmod _ t0]! !!KlattSynthesizerPlugin methodsFor: 'processing-voice' stamp: 'len 12/19/1999 04:52'!voicedPitchSynchronousReset	self returnTypeC: 'void'.	"Set the pitch."	pitch _ frame at: F0.	"Add flutter and jitter (F0 perturbations)."	self addFlutter.	self addJitter.	self addFrequencyDiplophonia.	pitch < 0 ifTrue: [pitch _ 0].	"Recompute t0 (it is the number of samples in one pitch period)."	t0 _ (samplingRate / pitch) asInteger.	"Duration of period before amplitude modulation."	nmod _ t0.	(frame at: Voicing) > 0 ifTrue: [nmod _ nmod // 2].	"Set open phase of glottal period."	nopen _ (t0 * (frame at: Ro)) asInteger.	"Set the LF glottal pulse model parameters."	self ro: (frame at: Ro) ra: (frame at: Ra) rk: (frame at: Rk).	"Add shimmer and diplophonia amplitude pertirbations.	(This must be done AFTER the actual computation of the LF parameters.)"	self addShimmer.	self addAmplitudeDiplophonia! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 11/9/1999 23:37'!cascadeBranch: source	"Cascade vocal tract, excited by laryngeal sources.	Nasal antiresonator, nasal resonator, tracheal antirresonator,	tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1."	| out |	self inline: true.	self returnTypeC: 'float'.	self var: 'source' declareC: 'float source'.	self var: 'out' declareC: 'float out'.	cascade > 0 ifFalse: [^ 0.0].	out _ self antiResonator: Rnz value: source.	out _ self resonator: Rnpc value: out.	out _ self antiResonator: Rtz value: out.	out _ self resonator: Rtpc value: out.	"Do not use unless sample rate >= 16000"	cascade >= 8 ifTrue: [out _ self resonator: R8c value: out].	"Do not use unless sample rate >= 16000"	cascade >= 7 ifTrue: [out _ self resonator: R7c value: out].	"Do not use unless long vocal tract or sample rate increased"	cascade >= 6 ifTrue: [out _ self resonator: R6c value: out].	cascade >= 5 ifTrue: [out _ self resonator: R5c value: out].	cascade >= 4 ifTrue: [out _ self resonator: R4c value: out].	cascade >= 3 ifTrue: [out _ self resonator: R3c value: out].	cascade >= 2 ifTrue: [out _ self resonator: R2c value: out].	cascade >= 1 ifTrue: [out _ self resonator: R1c value: out].	^ out! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 10/29/1999 02:31'!linearFromdB: aNumber	self inline: true.	self returnTypeC: 'float'.	self var: 'aNumber' declareC: 'double aNumber'.	^ (2.0 raisedTo: (aNumber-87.0/6.0)) * 32.767! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 11/9/1999 22:40'!nextRandom	"Answer a random number between 0 and 65535."	self inline: true.	seed _ (seed * 1309) + 13849 bitAnd: 65535.	^ seed! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 12/22/1999 02:38'!parallelFrictionBranch: source	"Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,	outputs added with alternating sign. Sound source for other	parallel resonators is friction plus first difference of	voicing waveform."	self inline: true.	self returnTypeC: 'float'.	self var: 'source' declareC: 'float source'.	^ (self resonator: R2fp value: source) - (self resonator: R3fp value: source) + (self resonator: R4fp value: source) - (self resonator: R5fp value: source) + (self resonator: R6fp value: source)! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 12/22/1999 02:37'!parallelVoicedBranch: source	"Voice-excited parallel vocal tract F1, F2, F3, F4, FNP and FTP."	self inline: true.	self returnTypeC: 'float'.	self var: 'source' declareC: 'float source'.	^ (self resonator: R1vp value: source) + (self resonator: R2vp value: source) + (self resonator: R3vp value: source) + (self resonator: R4vp value: source) + (self resonator: Rnpp value: source) + (self resonator: Rtpp value: source)! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 12/21/1999 02:25'!setCurrentFrame: aKlattFrame	| ampFNV ampFTV ampF1V ampF2V ampF3V ampF4V ampF2F ampF3F ampF4F ampF5F ampF6F |	self returnTypeC: 'void'.	self var: 'aKlattFrame' declareC: 'float *aKlattFrame'.	self var: 'ampFNV' declareC: 'float ampFNV'.	self var: 'ampFTV' declareC: 'float ampFTV'.	self var: 'ampF1V' declareC: 'float ampF1V'.	self var: 'ampF2V' declareC: 'float ampF2V'.	self var: 'ampF3V' declareC: 'float ampF3V'.	self var: 'ampF4V' declareC: 'float ampF4V'.	self var: 'ampF2F' declareC: 'float ampF2F'.	self var: 'ampF3F' declareC: 'float ampF3F'.	self var: 'ampF4F' declareC: 'float ampF4F'.	self var: 'ampF5F' declareC: 'float ampF5F'.	self var: 'ampF6F' declareC: 'float ampF6F'.	frame _ aKlattFrame.	"Fudge factors..."	ampFNV _ (self linearFromdB: (frame at: Anv)) * 0.6.	"-4.44 dB"	ampFTV _ (self linearFromdB: (frame at: Atv)) * 0.6.		"-4.44 dB"	ampF1V _ (self linearFromdB: (frame at: A1v)) * 0.4.		"-7.96 dB"	ampF2V _ (self linearFromdB: (frame at: A2v)) * 0.15.	"-16.5 dB"	ampF3V _ (self linearFromdB: (frame at: A3v)) * 0.06.	"-24.4 dB"	ampF4V _ (self linearFromdB: (frame at: A4v)) * 0.04.	"-28.0 dB"	ampF2F _ (self linearFromdB: (frame at: A2f)) * 0.15.		"-16.5 dB"	ampF3F _ (self linearFromdB: (frame at: A3f)) * 0.06.	"-24.4 dB"	ampF4F _ (self linearFromdB: (frame at: A4f)) * 0.04.	"-28.0 dB"	ampF5F _ (self linearFromdB: (frame at: A5f)) * 0.022.	"-33.2 dB"	ampF6F _ (self linearFromdB: (frame at: A6f)) * 0.03.	"-30.5 dB"	"Set coefficients of variable cascade resonators"	cascade >= 8		ifTrue: [samplingRate >= 16000	"Inside Nyquist rate?"					ifTrue: [self resonator: R8c frequency: 7500 bandwidth: 600]					ifFalse: [cascade _ 6]].	cascade >= 7		ifTrue: [samplingRate >= 16000	"Inside Nyquist rate?"					ifTrue: [self resonator: R7c frequency: 6500 bandwidth: 500]					ifFalse: [cascade _ 6]].	cascade >= 6 ifTrue: [self resonator: R6c frequency: (frame at: F6) bandwidth: (frame at: B6)].	cascade >= 5 ifTrue: [self resonator: R5c frequency: (frame at: F5) bandwidth: (frame at: B5)].	self resonator: R4c frequency: (frame at: F4) bandwidth: (frame at: B4).	self resonator: R3c frequency: (frame at: F3) bandwidth: (frame at: B3).	self resonator: R2c frequency: (frame at: F2) bandwidth: (frame at: B2).	self resonator: R1c frequency: (frame at: F1) bandwidth: (frame at: B1).	"Set coefficients of nasal and tracheal resonators and antiresonators"	self resonator: Rnpc frequency: (frame at: Fnp) bandwidth: (frame at: Bnp).	self resonator: Rtpc frequency: (frame at: Ftp) bandwidth: (frame at: Btp).	self antiResonator: Rnz frequency: (frame at: Fnz) bandwidth: (frame at: Bnz).	self antiResonator: Rtz frequency: (frame at: Ftz) bandwidth: (frame at: Btz).	"Set coefficients of parallel resonators, and amplitude of outputs"	self resonator: Rnpp frequency: (frame at: Fnp) bandwidth: (frame at: Bnp) gain: ampFNV.	self resonator: Rtpp frequency: (frame at: Ftp) bandwidth: (frame at: Btp) gain: ampFTV.	self resonator: R1vp frequency: (frame at: F1) bandwidth: (frame at: B1) gain: ampF1V.	self resonator: R2vp frequency: (frame at: F2) bandwidth: (frame at: B2) gain: ampF2V.	self resonator: R3vp frequency: (frame at: F3) bandwidth: (frame at: B3) gain: ampF3V.	self resonator: R4vp frequency: (frame at: F4) bandwidth: (frame at: B4) gain: ampF4V.	self resonator: R2fp frequency: (frame at: F2) bandwidth: (frame at: B2f) gain: ampF2F.	self resonator: R3fp frequency: (frame at: F3) bandwidth: (frame at: B3f) gain: ampF3F.	self resonator: R4fp frequency: (frame at: F4) bandwidth: (frame at: B4f) gain: ampF4F.	self resonator: R5fp frequency: (frame at: F5) bandwidth: (frame at: B5f) gain: ampF5F.	self resonator: R6fp frequency: (frame at: F6) bandwidth: (frame at: B6f) gain: ampF6F! !!KlattSynthesizerPlugin methodsFor: 'processing' stamp: 'len 12/22/1999 02:42'!synthesizeFrame: aKlattFrame into: buffer startingAt: startIndex	| noise voice frictionNoise aspirationNoise glotout	parGlotout source temp out	index top	voicing parVoicing turbulence friction aspiration bypass	gain ampGain |	self returnTypeC: 'void'.	self var: 'aKlattFrame' declareC: 'float *aKlattFrame'.	self var: 'buffer' declareC: 'short *buffer'.	self var: 'noise' declareC: 'float noise'.	self var: 'voice' declareC: 'float voice'.	self var: 'frictionNoise' declareC: 'float frictionNoise'.	self var: 'aspirationNoise' declareC: 'float aspirationNoise'.	self var: 'voicing' declareC: 'float voicing'.	self var: 'parVoicing' declareC: 'float parVoicing'.	self var: 'turbulence' declareC: 'float turbulence'.	self var: 'friction' declareC: 'float friction'.	self var: 'aspiration' declareC: 'float aspiration'.	self var: 'bypass' declareC: 'float bypass'.	self var: 'glotout' declareC: 'float glotout'.	self var: 'parGlotout' declareC: 'float parGlotout'.	self var: 'source' declareC: 'float source'.	self var: 'gain' declareC: 'float gain'.	self var: 'ampGain' declareC: 'float ampGain'.	self var: 'out' declareC: 'float out'.	self setCurrentFrame: aKlattFrame.	pitch > 0		ifTrue: [voicing _ self linearFromdB: (frame at: Voicing) - 7.				parVoicing _ self linearFromdB: (frame at: Voicing).				turbulence _ (self linearFromdB: (frame at: Turbulence)) * 0.1]		ifFalse: [voicing _ parVoicing _ turbulence _ 0.0].	friction _ (self linearFromdB: (frame at: Friction)) * 0.25.	aspiration _ (self linearFromdB: (frame at: Aspiration)) * 0.05.	bypass _ (self linearFromdB: (frame at: Bypass)) * 0.05.		"-26.0 dB"	"Flod overall gain into output resonator (low-pass filter)"	gain _ (frame at: Gain) - 3.	gain <= 0 ifTrue: [gain _ 57].	ampGain _ self linearFromdB: gain.	self resonator: Rout frequency: 0 bandwidth: samplingRate gain: ampGain.	noise _ nlast.	index _ startIndex.	top _ samplesPerFrame + startIndex - 1.	[index <= top] whileTrue: [		"Get low-passed random number for aspiration and friction noise"		noise _ (self nextRandom - 32768) asFloat / 4.0. "radom number between -8196.0 and 8196.0"		"Tilt down noise spectrum by soft low-pass filter having		 a pole near the origin in the z-plane."		noise _ noise + (0.75 * nlast).		nlast _ noise.		"Amplitude modulate noise (reduce noise amplitude during second		 half of glottal period) if voicing  simultaneously present."		nper > nmod ifTrue: [noise _ noise * 0.5].		"Compute frictation noise"		frictionNoise _ friction * noise.		"Compute voicing waveform."		voice _ self glottalSource.		vlast _ voice.		"Add turbulence during glottal open phase.		 Use random rather than noise because noise is low-passed."		nper < nopen ifTrue: [voice _ voice + (turbulence * (self nextRandom - 32768) asFloat / 4.0)].		"Set amplitude of voicing."		glotout _ voicing * voice.		parGlotout _ parVoicing * voice.		"Compute aspiration amplitude and add to voicing source."		aspirationNoise _ aspiration * noise.		glotout _ glotout + aspirationNoise.		parGlotout _ parGlotout + aspirationNoise.		"Cascade vocal tract, excited by laryngeal sources.		 Nasal antiresonator, nasal resonator, trachearl antirresonator,		 tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1."		out _ self cascadeBranch: glotout.		"Voice-excited parallel vocal tract F1, F2, F3, F4, FNP and FTP."		source _ parGlotout.	"Source is voicing plus aspiration."		out _ out + (self parallelVoicedBranch: source).		"Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,		 outputs added with alternating sign. Sound source for other		 parallel resonators is friction plus first difference of		 voicing waveform."		source _ frictionNoise + parGlotout - glast.		glast _ parGlotout.		out _ (self parallelFrictionBranch: source) - out.		"Apply bypas and output low-pass filter"		out _ bypass * source - out.		out _ self resonator: Rout value: out.		temp _ (out * ampGain) asInteger.		temp < -32768 ifTrue: [temp _ -32768].		temp > 32767 ifTrue: [temp _ 32767].		buffer at: index - 1 put: temp.		index _ index + 1.		samplesCount _ samplesCount + 1]! !!KlattSynthesizerPlugin methodsFor: 'primitives' stamp: 'len 9/26/1999 02:30'!primitiveSynthesizeFrameIntoStartingAt	| aKlattFrame buffer startIndex rcvr bufferOop |	self export: true.	self var: 'aKlattFrame' declareC: 'float *aKlattFrame'.	self var: 'buffer' declareC: 'short *buffer'.	aKlattFrame _ self checkedFloatPtrOf: (interpreterProxy stackValue: 2).	buffer _ self checkedShortPtrOf: (bufferOop _ interpreterProxy stackValue: 1).	startIndex _ interpreterProxy stackIntegerValue: 0.	interpreterProxy failed ifTrue: [^nil].	rcvr _ interpreterProxy stackObjectValue: 3.	(self loadFrom: rcvr) ifFalse:[^nil].	interpreterProxy success: (interpreterProxy stSizeOf: bufferOop) * 2 >= samplesPerFrame.	interpreterProxy failed ifTrue: [^nil].	self synthesizeFrame: aKlattFrame into: buffer startingAt: startIndex.	(self saveTo: rcvr) ifFalse: [^nil].	interpreterProxy pop: 3! !!KlattSynthesizerPlugin methodsFor: 'private' stamp: 'hmm 5/10/1999 06:49'!checkedFloatPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'float *'.	interpreterProxy success: (interpreterProxy isWords: oop).	interpreterProxy failed ifTrue:[^0].	^self cCoerce: (interpreterProxy firstIndexableField: oop) to:'float *'! !!KlattSynthesizerPlugin methodsFor: 'private' stamp: 'hmm 5/10/1999 06:50'!checkedShortPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'short *'.	interpreterProxy success: (interpreterProxy isWords: oop).	interpreterProxy failed ifTrue:[^0].	^self cCoerce: (interpreterProxy firstIndexableField: oop) to:'short *'! !!KlattSynthesizerPlugin methodsFor: 'private' stamp: 'len 12/17/1999 03:27'!loadFrom: klattOop	| oop |	interpreterProxy success: (interpreterProxy slotSizeOf: klattOop) = 22.	interpreterProxy failed ifTrue:[^ false].	oop _ interpreterProxy fetchPointer: 0 ofObject: klattOop.	resonators _ self checkedFloatPtrOf: oop.	pitch _ interpreterProxy fetchFloat: 2 ofObject: klattOop.	t0 _ interpreterProxy fetchInteger: 3 ofObject: klattOop.	nper _ interpreterProxy fetchInteger: 4 ofObject: klattOop.	nopen _ interpreterProxy fetchInteger: 5 ofObject: klattOop.	nmod _ interpreterProxy fetchInteger: 6 ofObject: klattOop.	a1 _ interpreterProxy fetchFloat: 7 ofObject: klattOop.	a2 _ interpreterProxy fetchFloat: 8 ofObject: klattOop.	x1 _ interpreterProxy fetchFloat: 9 ofObject: klattOop.	x2 _ interpreterProxy fetchFloat: 10 ofObject: klattOop.	b1 _ interpreterProxy fetchFloat: 11 ofObject: klattOop.	c1 _ interpreterProxy fetchFloat: 12 ofObject: klattOop.	glast _ interpreterProxy fetchFloat: 13 ofObject: klattOop.	vlast _ interpreterProxy fetchFloat: 14 ofObject: klattOop.	nlast _ interpreterProxy fetchFloat: 15 ofObject: klattOop.	periodCount _ interpreterProxy fetchInteger: 16 ofObject: klattOop.	samplesCount _ interpreterProxy fetchInteger: 17 ofObject: klattOop.	seed _ interpreterProxy fetchInteger: 18 ofObject: klattOop.	cascade _ interpreterProxy fetchInteger: 19 ofObject: klattOop.	samplesPerFrame _ interpreterProxy fetchInteger: 20 ofObject: klattOop.	samplingRate _ interpreterProxy fetchInteger: 21 ofObject: klattOop.	^ interpreterProxy failed == false! !!KlattSynthesizerPlugin methodsFor: 'private' stamp: 'len 12/19/1999 05:25'!saveTo: origKlattOop	| pitchOop a1Oop a2Oop x1Oop x2Oop b1Oop c1Oop glastOop vlastOop nlastOop klattOop |	interpreterProxy pushRemappableOop: origKlattOop.	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: pitch).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: a1).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: a2).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: x1).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: x2).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: b1).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: c1).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: glast).	interpreterProxy pushRemappableOop: (interpreterProxy floatObjectOf: vlast).	nlastOop _ interpreterProxy floatObjectOf: nlast.	vlastOop _ interpreterProxy popRemappableOop.	glastOop _ interpreterProxy popRemappableOop.	c1Oop _ interpreterProxy popRemappableOop.	b1Oop _ interpreterProxy popRemappableOop.	x2Oop _ interpreterProxy popRemappableOop.	x1Oop _ interpreterProxy popRemappableOop.	a2Oop _ interpreterProxy popRemappableOop.	a1Oop _ interpreterProxy popRemappableOop.	pitchOop _ interpreterProxy popRemappableOop.	klattOop _ interpreterProxy popRemappableOop.	interpreterProxy failed ifTrue:[^ false].	interpreterProxy storePointer: 2 ofObject: klattOop withValue: pitchOop.	interpreterProxy storeInteger: 3 ofObject: klattOop withValue: t0.	interpreterProxy storeInteger: 4 ofObject: klattOop withValue: nper.	interpreterProxy storeInteger: 5 ofObject: klattOop withValue: nopen.	interpreterProxy storeInteger: 6 ofObject: klattOop withValue: nmod.	interpreterProxy storePointer: 7 ofObject: klattOop withValue: a1Oop.	interpreterProxy storePointer: 8 ofObject: klattOop withValue: a2Oop.	interpreterProxy storePointer: 9 ofObject: klattOop withValue: x1Oop.	interpreterProxy storePointer: 10 ofObject: klattOop withValue: x2Oop.	interpreterProxy storePointer: 11 ofObject: klattOop withValue: b1Oop.	interpreterProxy storePointer: 12 ofObject: klattOop withValue: c1Oop.	interpreterProxy storePointer: 13 ofObject: klattOop withValue: glastOop.	interpreterProxy storePointer: 14 ofObject: klattOop withValue: vlastOop.	interpreterProxy storePointer: 15 ofObject: klattOop withValue: nlastOop.	interpreterProxy storeInteger: 16 ofObject: klattOop withValue: periodCount.	interpreterProxy storeInteger: 17 ofObject: klattOop withValue: samplesCount.	interpreterProxy storeInteger: 18 ofObject: klattOop withValue: seed.	^ interpreterProxy failed == false! !!KlattSynthesizerPlugin class methodsFor: 'class initialization' stamp: 'len 9/25/1999 23:12'!initialize	"	KlattSynthesizerPlugin initialize	"	KlattFrame parameterNames		doWithIndex: [ :each :i | self classPool at: each capitalized asSymbol put: i-1].	PI _ Float pi	.	Epsilon _ 1.0e-04! !!KlattSynthesizerPlugin class methodsFor: 'translation' stamp: 'len 12/6/1999 04:46'!declareCVarsIn: cg	cg var: 'resonators' declareC: 'float *resonators'.	cg var: 'frame' declareC: 'float *frame'.	cg var: 'pitch' declareC: 'float pitch'.	cg var: 'a1' declareC: 'float a1'.	cg var: 'a2' declareC: 'float a2'.	cg var: 'x1' declareC: 'float x1'.	cg var: 'x2' declareC: 'float x2'.	cg var: 'b1' declareC: 'float b1'.	cg var: 'c1' declareC: 'float c1'.	cg var: 'glast' declareC: 'float glast'.	cg var: 'vlast' declareC: 'float vlast'.	cg var: 'nlast' declareC: 'float nlast'! !!KlattSynthesizerPlugin class methodsFor: 'translation' stamp: 'len 9/25/1999 23:14'!moduleName	"	KlattSynthesizerPlugin translateDoInlining: true	"	^ 'Klatt'! !!LiljencrantsFant commentStamp: '<historical>' prior: 0!This is the LF glottal-pulse model. Actually this is here only for pedagogical purposes. The LF model is again implemented in KlattSynthesizer (and as primitive in the KlattSynthesizerPluggin). For more details on the LF model see:	Fant, G., Liljencrants, J., & Lin, Q. "A four-parameter model of glottal flow", Speech Transmission Laboratory Qurterly Progress Report 4/85, KTH.!!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 01:15'!n0: anInteger	n0 _ anInteger! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 01:15'!ne: anInteger	ne _ anInteger! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 00:02'!ra	^ ra! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 00:02'!ra: aNumber	ra _ aNumber! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 00:02'!rk	^ rk! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 00:02'!rk: aNumber	rk _ aNumber! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 00:36'!ro	^ ro! !!LiljencrantsFant methodsFor: 'accessing' stamp: 'len 9/15/1999 00:37'!ro: aNumber	ro _ aNumber! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:14'!computeSamplesInto: aFloatArray	| s0 s1 s2 |	aFloatArray at: 1 put: x1.	s2 _ x1.	aFloatArray at: 2 put: x2.	s1 _ x2.	3 to: ne - 1 do: [ :each |		s0 _ a1 * s1 + (a2 * s2).		aFloatArray at: each put: s0.		s2 _ s1.		s1 _ s0].	ne to: n0 do: [ :each | aFloatArray at: each put: b1 * (aFloatArray at: each - 1) - c1]! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:23'!d	| r |	ra <= 0.0 ifTrue: [^ 1.0].	r _ 1.0 - ro / ra.	^ 1.0 - (r / (r exp - 1.0))! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/26/1999 22:12'!example1	"	Utilities plot: LiljencrantsFant new example1	"	self t0: 1 / 133 * 4 ro: 0.25 rk: 0.25 ra: 0.01 samplingRate: 22025.	self init.	^ self samples! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 10/29/1999 01:55'!init	| d phi cosphi sinphi rphid u theta rho gamma gammapwr |	d _ self d.	phi _ Float pi * (rk + 1.0).	cosphi _ phi cos.	sinphi _ phi sin.	rphid _ ra / ro * phi * d.	u _ self zeroQphi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.	theta _ phi / ne.	rho _ (u * theta) exp.	a1 _ 2.0 * theta cos * rho.	a2 _ 0.0 - (rho * rho).	x1 _ 0.0.	x2 _ rho * theta sin.	gamma _ (-1.0 / (ra * n0)) exp.	gammapwr _ gamma raisedTo: n0 - ne.	b1 _ gamma.	c1 _ (1.0 - gamma) * gammapwr / (1.0 - gammapwr)! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:10'!qu: u phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid	| expuphi |	expuphi _ (u * phi) exp.	^ expuphi * ((rphid * (u*u + 1.0) + u) * sinphi - cosphi) + 1.0! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:16'!samples	| answer |	answer _ FloatArray new: n0.	self computeSamplesInto: answer.	^ answer! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:30'!t0: t0 ro: roNumber rk: rkNumber ra: raNumber samplingRate: samplingRate	| doubleN0 |	doubleN0 _ samplingRate * t0.	n0 _ doubleN0 asInteger.	ne _ (doubleN0 * roNumber) asInteger.	ro _ ne asFloat / n0 asFloat.	rk _ rkNumber.	ra _ raNumber! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:29'!t0: t0 tp: tp te: te ta: ta samplingRate: samplingRate	self t0: t0 ro: te / t0 rk: te - tp / tp ra: ta / t0 samplingRate: samplingRate! !!LiljencrantsFant methodsFor: 'processing' stamp: 'len 9/15/1999 01:07'!zeroQphi: phi cosphi: cosphi sinphi: sinphi rphid: rphid	| qzero ua ub qa qb uc qc |	qzero _ self qu: 0 phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.	qzero > 0		ifTrue: [ua _ 0. ub _ 1.				qa _ qzero. qb _ self qu: ub phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.				[qb > 0]					whileTrue: [ua _ ub. qa _ qb.								ub _ ub * 2. qb _ self qu: ub phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid]]		ifFalse: [ua _ -1. ub _ 0.				qa _ self qu: ua phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid. qb _ qzero.				[qa < 0]					whileTrue: [ub _ ua. qb _ qa.								ua _ ua * 2. qa _ self qu: ua phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid]].	[ub - ua > Epsilon]		whileTrue: [uc _ ub + ua / 2. qc _ self qu: uc phi: phi cosphi: cosphi sinphi: sinphi rphid: rphid.					qc > 0 ifTrue: [ua _ uc. qa _ qc] ifFalse: [ub _ uc. qb _ qc]].	^ ub + ua / 2! !!LiljencrantsFant class methodsFor: 'initialize-release' stamp: 'len 9/15/1999 00:58'!initialize	"	LiljencrantsFant initialize	"	Epsilon _ 1.0e-04! !!LipsMorph methodsFor: 'initialization' stamp: 'len 9/7/1999 01:44'!initialize	super initialize. 	vertices _ {11@3. 35@1. 60@5. 67@17. 34@24. 3@17}.	color _ Color black. "red darker."	borderColor _ Color black.	borderWidth _ 1.	closed _ true.	self neutral; updateShape! !!LipsMorph methodsFor: 'accessing' stamp: 'len 8/22/1999 17:54'!verticesString	| stream first |	stream _ WriteStream with: ''.	stream nextPut: ${.	first _ true.	vertices do: [ :each |		first ifFalse: [stream nextPutAll: '. '].		stream print: (each - self position) rounded.		first _ false].	stream nextPut: $}.	^ stream contents! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 23:17'!articulate: aPhoneme	self newVerticesCentered: (PhoneticArticulations at: aPhoneme ifAbsent: [^ self]) scaled: 0.5! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/24/1999 01:13'!grin	self newVerticesCentered: {17@5. 30@7. 33@12. 16@14. 2@10. 5@2}! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/24/1999 00:11'!hideTongue	self submorphs do: [ :each | each delete]! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:14'!horror	self newVerticesCentered: {21@3. 37@5. 36@19. 19@19. 3@19. 5@4}! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:15'!neutral	self newVerticesCentered: {13@1. 22@4. 12@6. 1@4}! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 22:34'!newVerticesCentered: anArray	self newVerticesCentered: anArray scaled: 0.5! !!LipsMorph methodsFor: 'actions' stamp: 'len 9/6/1999 01:35'!newVerticesCentered: anArray scaled: aNumber	newVertices _ anArray.	newScale _ aNumber! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 17:32'!openness: amount	self newVerticesCentered: {40@-3. 74@8. 59@ (21 * amount). 38@ (20 * amount). 22@ (21 * amount). 3@8}! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:11'!sad	self newVerticesCentered: {26@4. 50@10. 41@4. 27@2. 14@3. 1@10}! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/24/1999 00:10'!showTongue	| tongue |	self hideTongue.	tongue _ CurveMorph vertices: {10@2. 21@5. 16@23. 10@27. 5@23. 2@4} color: Color red borderWidth: 0 borderColor: Color black.	tongue position: self center - (10 @ 0).	self addMorphFront: tongue! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 19:12'!smile	self newVerticesCentered: {26@11. 43@7. 51@2. 44@12. 26@19. 8@14. 2@4. 12@9}! !!LipsMorph methodsFor: 'actions' stamp: 'len 8/22/1999 22:34'!surprise	self newVerticesCentered:  {22@3. 38@7. 37@21. 20@26. 4@21. 6@6}! !!LipsMorph methodsFor: 'actions' stamp: 'len 9/7/1999 02:44'!updateShape	| center median |	newVertices isNil ifTrue: [^ self].	median _ 0 @ 0.	newVertices do: [ :each | median _ median + each].	median _ median / newVertices size.	center _ self center.	vertices _ newVertices collect: [ :each | (each - median) * newScale + median].	self computeBounds.	self position: self position - self center + center.	newVertices _ nil! !!LipsMorph class methodsFor: 'class initialization' stamp: 'len 8/22/1999 18:28'!initialize	"	LipsMorph initialize	"	| o u a e i m n p t s |	a _ {22@2. 39@4. 45@16. 23@23. 2@15. 9@4}.	e _ {23@2. 41@3. 45@15. 21@19. 2@14. 6@3}.	i _ {21@2. 40@4. 45@14. 23@16. 2@13. 8@4}.	o _ {18@1. 31@5. 31@20. 16@24. 3@19. 5@5}.	u _ {14@1. 23@6. 22@16. 11@20. 2@14. 3@4}.	m _ {17@2. 31@2. 27@4. 15@3. 2@4. 6@2}.	n _ {20@3. 33@2. 39@8. 19@9. 2@8. 7@2}.	p _ {7@1. 16@3. 12@5. 6@6. 1@4}.	t _ {14@2. 29@3. 21@7. 12@8. 1@3}.	s _ {19@2. 32@4. 35@10. 18@13. 2@10. 9@3}.	PhoneticArticulations _ Dictionary new.	"Default"	PhonemeSet arpabet do: [ :each | PhoneticArticulations at: each put: p].	"Vowels"	PhonemeSet arpabet do: [ :each |		each name first = $a ifTrue: [PhoneticArticulations at: each put: a].		each name first = $e ifTrue: [PhoneticArticulations at: each put: e].		each name first = $i ifTrue: [PhoneticArticulations at: each put: i].		each name first = $o ifTrue: [PhoneticArticulations at: each put: o].		each name first = $u ifTrue: [PhoneticArticulations at: each put: u].		each name first = $w ifTrue: [PhoneticArticulations at: each put: u]].	"Particulars"	PhoneticArticulations		at: (PhonemeSet arpabet at: 'm') put: m;		at: (PhonemeSet arpabet at: 'n') put: n;		at: (PhonemeSet arpabet at: 't') put: t;		at: (PhonemeSet arpabet at: 's') put: s;		at: (PhonemeSet arpabet at: 'sh') put: s;		at: (PhonemeSet arpabet at: 'sh') put: s;		at: (PhonemeSet arpabet at: 'zh') put: s;		at: (PhonemeSet arpabet at: 'th') put: s;		at: (PhonemeSet arpabet at: 'jh') put: s;		at: (PhonemeSet arpabet at: 'dh') put: s;		at: (PhonemeSet arpabet at: 'd') put: s;		at: (PhonemeSet arpabet at: 'z') put: s! !!PHOReader commentStamp: '<historical>' prior: 0!My instances read PHO files with lines of the form 'phoneme duration time0 pitch0 time1 pitch1 ...'. Time is in milliseconds, and pitch is in hertz. Files on this format are used as inputs for the MBROLA synthesizer, and there are lots of them available on the web. Here's an example:_  120 0 105m  60 33 105E  70 42 102r  50 20 108I  50 20 125 100 142k  100r  50 80 137I  50 80 121s  70m  50@  90 33 111 88 108s  90!!PHOReader methodsFor: 'initialization' stamp: 'len 6/15/1999 00:36'!initialize	events _ OrderedCollection new.	pitches _ OrderedCollection new.	time _ 0.0.	phonemes _ PhonemeSet sampaToArpabet! !!PHOReader methodsFor: 'accessing' stamp: 'len 9/27/1999 23:01'!addPitches	| offset |	offset _ 0.0.	events do: [ :each |		each pitchPoints: (self pitchesBetween: offset and: offset + each duration).		offset _ offset + each duration].! !!PHOReader methodsFor: 'accessing' stamp: 'len 8/29/1999 02:16'!events	^ CompositeEvent new addAll: events; yourself! !!PHOReader methodsFor: 'accessing' stamp: 'len 11/28/1999 04:00'!nextEvent	| line phonemeName phoneme duration answer ptime pitch |	line _ ReadStream on: stream nextLine.	phonemeName _ line upTo: Character space.	phoneme _ phonemes at: phonemeName.	[line peek isSeparator] whileTrue: [line next].	duration _ (line upTo: Character space) asNumber / 1000.0.	answer _ PhoneticEvent new phoneme: phoneme; duration: duration; loudness: 1.0.	[line atEnd]		whileFalse: [ptime _ (line upTo: Character space) asNumber * duration / 100.0.					pitch _ (line upTo: Character space) asNumber asFloat.					pitches add: time + ptime @ pitch].	time _ time + duration.	^ answer! !!PHOReader methodsFor: 'accessing' stamp: 'len 6/15/1999 00:38'!pitchAt: t	"Answer the pitch of the receiver at a given time. (Do linear interpolation.)"	| xVal count x1 x2 y1 y2 |	xVal _ pitches first x.	count _ 1.	[xVal < t]		whileTrue: [count _ count + 1.					count > pitches size ifTrue: [^ pitches last y].					xVal _ (pitches at: count) x].	xVal = t ifTrue: [^ (pitches at: count) y].	count = 1 ifTrue: [^ pitches first y].	x1 _ (pitches at: count - 1) x.	x2 _ (pitches at: count) x.	y1 _ (pitches at: count - 1) y.	y2 _ (pitches at: count) y.	^ (t - x1) / (x2 - x1) * (y2 - y1) + y1! !!PHOReader methodsFor: 'accessing' stamp: 'len 6/20/1999 23:57'!pitchesBetween: t1 and: t2	| step |	step _ (t2 - t1 / 0.035) asInteger + 1. "step small enough"	^ (t1 to: t2 by: t2 - t1 / step) collect: [ :each | each - t1 @ (self pitchAt: each)]! !!PHOReader methodsFor: 'accessing' stamp: 'len 6/17/1999 01:45'!plotPitch	Utilities plot: ((0 to: time by: 0.050) collect: [ :each | self pitchAt: each])! !!PHOReader methodsFor: 'accessing' stamp: 'len 6/15/1999 00:40'!read	stream reset.	[stream atEnd] whileFalse: [events add: self nextEvent].	self addPitches! !!PHOReader methodsFor: 'accessing' stamp: 'len 6/15/1999 00:29'!stream: aStream	stream _ aStream! !!PHOReader class methodsFor: 'instance creation' stamp: 'len 6/15/1999 00:48'!eventsFromStream: aStream	^ self new stream: aStream; read; events! !!PHOReader class methodsFor: 'instance creation' stamp: 'len 6/15/1999 00:49'!eventsFromString: aString	^ self eventsFromStream: (ReadStream on: aString)! !!PHOReader class methodsFor: 'instance creation' stamp: 'len 6/15/1999 00:31'!new	^ super new initialize! !!PHOReader class methodsFor: 'instance creation' stamp: 'len 6/17/1999 01:47'!plotPitchFromStream: aStream	^ self new stream: aStream; read; plotPitch! !!PHOReader class methodsFor: 'instance creation' stamp: 'len 6/17/1999 01:47'!plotPitchFromString: aString	^ self plotPitchFromStream: (ReadStream on: aString)! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/13/1999 01:29'!aliceExample	| events |	events _ self eventsFromString: self aliceExampleString.	events do: [ :each | each pitchBy: 0.63489].	^ events! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/28/1999 03:05'!aliceExampleFemale	| events |	events _ self eventsFromString: self aliceExampleString.	events do: [ :each | each pitchBy: 1.3].	^ events! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/14/1999 01:09'!aliceExampleMale	| events |	events _ self eventsFromString: self aliceExampleString.	events do: [ :each | each pitchBy: 0.63489].	^ events! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/29/1999 04:36'!aliceShortExample	| events |	events _ self eventsFromString: self aliceShortExampleString.	events do: [ :each | each pitchBy: 1.3].	^ events! !!PHOReader class methodsFor: 'examples' stamp: 'len 12/9/1999 02:09'!aliceShortExampleMale	| events |	events _ self eventsFromString: self aliceShortExampleString.	events do: [ :each | each pitchBy: 0.4].	^ events! !!PHOReader class methodsFor: 'examples' stamp: 'len 7/27/1999 01:47'!mbrolaExample	^ self eventsFromString:'_ 50E 40 0 102m 50b 50r 30@U 80 5 119 35 126 70 140l 50@ 50 50 173w 100 75 133V 30 85 114z 60 75 101d 60@ 40v 40 85 105E 60 75 121l 50 70 121@ 60 60 150p 50d 70b 70 0 90AI 130 85 101T 70j 50 0 180E 120 0 185 95 131r 40i 90 85 135d 80 60 134@ 50 0 119 50 114t 70w 70 10 117 65 127 85 115A 180 0 102 55 91 95 85_ 100_ 100I 80 18 111t 80s 50@ 30s 70p 80i 80 25 171 85 200tS 110s 70I 30 35 112n 40T 80@ 40 85 108s 80AI 130 80 115z 70 90 125r= 120 75 111b 80EI 80 95 133z 70d 50A 40n 30D 60@ 30 65 121k 90A 30n 30 100 140k 80{ 70 5 170t 70@ 40 50 186n 40 75 163EI 100 90 173S 130@ 40n 30 65 153V 40v 70 0 148d 60AI 130 5 112 80 109f 110@U 160 87 88n 70z 210 88 82_ 80_ 100I 40 0 140t 50t 100EI 60 50 221k 70s 80@ 30 0 190l 50I 30 65 180s 110t 70V 50 20 171v 50f 90@U 140 25 157n 30i 60 66 160m 50 60 130z 80@ 40 62 78z 80I 70 78 134n 50 70 163p 120U 90 15 119 75 98t 90_ 140_ 100t 60 0 111u 50 80 119g 70E 50 90 145D 50r= 50 40 139 90 163w 90I 30 15 114D 50_ 40p 50r 30 0 102@ 30 65 110s 120A 50 90 148d 80I 50 50 178k 80I 50 66 167n 60f 50r= 50 90 125m 50EI 140 95 96S 140@ 80 35 168n 100 95 142_ 190{ 90 0 133n 30d 30p 80r 40@ 40 0 97 65 103d 70j 20u 60 65 150s 90I 30 50 210z 50s 140p 70i 130 0 138 95 98tS 160{ 70 0 127t 50D 50@ 30 15 93s 140{ 30 35 127m 50p 70l 50I 30 35 184N 70f 70r 60i 90 30 125k 40w 30@ 30 15 185n 30s 100i 50 20 148 70 142V 30 5 148v 40D 80@ 40 25 106d 80AI 150 95 115f 90@U 130 95 114n 70d 80EI 80 80 1374 50@ 30b 100EI 120 95 78s 210_ 80'! !!PHOReader class methodsFor: 'examples' stamp: 'len 7/27/1999 01:48'!pushExample	^ self eventsFromString:'_  60 0 137p  50 100 137u  110 90 137S  100 10 121D  90@  70 57 114 100 102s  70t  50A 100 57 121 64 121r 40t  50b  110V  140 21 117 57 100 92 100_ 3n  130 25 102 50 105t  60u  70 28 129 71 111b  70i  70 50 102g  20 10 100 80 102i  130 25 117 66 114n  260 3 111 23 105 42 97 61 93 73 93_  140 92 93 100 100'! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/16/1999 01:47'!pushExampleFemale	| events |	events _ self pushExample.	events do: [ :each | each pitchBy: 1.93489].	^ events! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/26/1999 23:47'!pushShortExample	^ self eventsFromString:'i  70 50 102g  20 10 100 80 102i  130 25 117 66 114n  260 3 111 23 105 42 97 61 93 73 93'."'_ 3n  130 25 102 50 105t  60u  70 28 129 71 111b  70i  70 50 102g  20 10 100 80 102i  130 25 117 66 114n  260 3 111 23 105 42 97 61 93 73 93_  140 92 93 100 100'"! !!PHOReader class methodsFor: 'examples' stamp: 'len 7/27/1999 01:48'!xmasExample	^ self eventsFromString:'_  120 0 105m  60 33 105E  70 42 102r  50 20 108I  50 20 125 100 142k  100r  50 80 137I  50 80 121s  70m  50@  90 33 111 88 108s  90{  70n  100 50 105 100 97d  50 80 93h  50 20 93{  50 20 102 60 114p  50i  50 100 125n  60 83 121u 100j  130 7 121 23 121 100 108r=  250 41 102 83 97_  210 95 86 100 100'! !!PHOReader class methodsFor: 'examples' stamp: 'len 9/29/1999 02:56'!xmasKidExample	| events |	events _ self xmasExample.	events do: [ :each | each pitchBy: 1.6].	^ events! !!PHOReader class methodsFor: 'examples-private' stamp: 'len 7/27/1999 01:45'!aliceExampleString	^ '_ 48 0 222{ 80 40 222 90 235l 72 44 250 66 250I 80s 88w 40 80 235@ 40 80 210z 64 12 210 50 181 75 181b 72 33 173 88 181I 56 71 181g 56 28 153 100 166I 64 62 160n 40 60 160I 88 27 166N 40 100 166t 80 20 160U 40 40 181 80 166g 48 100 166E 104 38 153 76 137t 56v 48E 72 11 166 66 153r 88 18 160 63 166i 112.8 14 166 49 173 77 173t 104.8 98 137AI 178.4 21 148 70 148 92 137r= 108 25 137 62 133 98 129d 49@ 59.2 6 137 73 133v 46s 89I 40 40 173t 40 40 166I 64 62 166N 72 22 160 77 153b 40 40 142 100 153AI 136 29 142h 80 30 142 100 148r= 64 62 153 100 153s 125I 64 37 210 100 190s 72 11 190t 72r= 104 30 160 69 142O 72n 40 40 142D 40 40 153@ 40 40 160b 40 40 153 100 160{ 216 18 166 51 166 70 153 88 137 100 133n 40k 56_ 144 94 129 100 100_ 100 0 137{ 40n 88 9 137 36 137 72 142t 40 40 137 60 133@ 48 16 148 100 148h 40 100 142{ 48 83 148v 48 16 142I 56 14 148 85 137N 56 71 137n 64 37 137 100 142O 96 41 137 83 153 100 153T 64I 56 42 166N 64 12 160 75 153t 80 30 142@ 56 28 166 100 148d 56 71 137u 160 15 160 45 160 70 153 95 142w 136 23 137 58 137 88 148A 112 21 153 57 160 92 173n 64 50 166 62 153s 56O 48 50 153r 40 40 142 100 133t 130w 56 57 166AI 168 9 173 33 166 57 153 80 148 100 148s 88_ 300S 92i 48 50 235h 40 40 235 100 250@ 40 60 210 100 210d 40p 40i 150k 56d 56I 72 44 222 100 210n 40 80 210t 56@ 48 83 181D 40 39 173 99 173@ 39.2 100 160b 104 30 153 100 153U 112 35 153 85 153 100 153k 72h 56r= 48 50 200s 136 5 181I 64 25 166 87 142s 56 14 137t 56r= 56 28 173 100 173w 56 71 166@ 56 42 181z 48 16 181 50 173r 120 73 181i 104 7 190 69 190 100 181d 40I 112 7 166 50 137 85 129N 80 30 114 50 111_ 56 83 111 100 100_ 140 0 153b 40 60 153 100 153U 64 75 1484 40 80 148 100 142I 40t 40 40 148h 40 40 142{ 48 33 137d 136 5 133 11 129 88 148n 48 66 148@U 144 16 160 44 173 72 190 100 210p 80I 96 75 190 100 181k 56tS 96r= 104 30 190 69 181z 72 11 181 33 173O 40 60 173r 64 37 160 100 153k 72 11 153O 152 63 190 89 200n 40 60 181v 40 60 166r= 40 60 160s 104 15 142EI 120 20 190 53 190 86 210S 104 7 210@ 56 28 181 100 160n 64 62 153 100 137z 40I 56 14 148 85 133n 40 100 133I 96 41 129 83 125t 80_ 64 85 125 100 100_ 140 0 222{ 56 14 222 28 220 42 235 85 235 100 220n 96 33 222 75 235 100 235w 48 33 222 66 250O 904 48 50 222 66 252I 48 33 250z 64 12 235 62 210D 56@ 56 71 190j 104 23 166 61 166 100 181u 112 35 190 42 210 71 210 100 210s 150@ 56 42 200v 40 20 160 60 148@ 64 25 153 87 142b 136 23 133 47 137U 96 8 160 50 173 91 181 100 181k 56_ 56T 56O 119.2 20 166 53 142 80 1374 40 20 133{ 136 5 137 35 129 64 125l 48 16 125 100 133I 80 50 153 100 181s 120_ 40_ 40w 88 9 166 54 142I 40 40 142D 40 40 137aU 62.4 38 137 63 133t 80p 55I 72 16 210 38 210k 40tS 75.2 99 173r= 136 29 160 64 160 76 166z 48O 44 90 185r 60 6 198 46 200 72 190k 40O 81.6 12 148 61 133n 40 20 133v 48 33 133r= 56 28 181 100 181s 120 6 173EI 136 11 222 41 210 94 210S 120@ 128 12 190 43 148 75 137n 64 12 129 50 125_ 80 88 125 100 100'! !!PHOReader class methodsFor: 'examples-private' stamp: 'len 7/27/1999 01:46'!aliceShortExampleString	^ '_ 48 0 222{ 80 40 222 90 235l 72 44 250 66 250I 80s 88w 40 80 235@ 40 80 210z 64 12 210 50 181 75 181b 72 33 173 88 181I 56 71 181g 56 28 153 100 166I 64 62 160n 40 60 160I 88 27 166N 40 100 166t 80 20 160U 40 40 181 80 166g 48 100 166E 104 38 153 76 137t 56v 48E 72 11 166 66 153r 88 18 160 63 166i 112.8 14 166 49 173 77 173t 104.8 98 137AI 178.4 21 148 70 148 92 137r= 108 25 137 62 133 98 129d 49@ 59.2 6 137 73 133v 46s 89I 40 40 173t 40 40 166I 64 62 166N 72 22 160 77 153b 40 40 142 100 153AI 136 29 142h 80 30 142 100 148@ 60 50 150r= 64 62 153 100 153s 125I 64 37 210 100 190s 72 11 190t 72r= 104 30 160 69 142O 72n 40 40 142D 40 40 153@ 40 40 160b 40 40 153 100 160{ 216 18 166 51 166 70 153 88 137 100 133n 40k 56_ 144 94 129 100 100'! !!Phoneme commentStamp: '<historical>' prior: 0!My instances are phonemes. See also PhonemeSet class.!!Phoneme methodsFor: 'accessing' stamp: 'len 6/9/1999 01:33'!example	^ self at: #example ifAbsent: []! !!Phoneme methodsFor: 'accessing' stamp: 'len 6/9/1999 01:34'!example: aString	self at: #example put: aString! !!Phoneme methodsFor: 'accessing' stamp: 'len 4/9/98 23:13'!name	^ name! !!Phoneme methodsFor: 'accessing' stamp: 'len 6/9/1999 01:33'!name: aString	name _ aString! !!Phoneme methodsFor: 'accessing' stamp: 'len 6/9/1999 01:35'!stress	"Answer the stress level of the receiver."	^ self at: #stress ifAbsent: [0]! !!Phoneme methodsFor: 'accessing' stamp: 'len 6/9/1999 01:38'!stress: aNumber	"Set the stress level of the receiver."	self at: #stress put: aNumber! !!Phoneme methodsFor: 'comparing' stamp: 'len 6/1/1999 02:13'!= aPhoneme	^ self species == aPhoneme species and: [self name = aPhoneme name]! !!Phoneme methodsFor: 'comparing' stamp: 'len 5/29/1999 04:01'!hash	^ self name hash! !!Phoneme methodsFor: 'copying' stamp: 'len 6/9/1999 02:10'!copy	^ super copy properties: properties copy! !!Phoneme methodsFor: 'testing' stamp: 'len 6/9/1999 01:27'!hasFeature: aSymbol	^ self hasProperty: aSymbol! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isAffricate	"Answer true if the receiver is an affricate phoneme."	^ self hasFeature: #affricate! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isBackVowel	"Answer true if the receiver is a back vowel phoneme."	^ self isVowel and: [self hasFeature: #back]! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isConsonant	"Answer true if the receiver is a consonant phoneme."	^ self hasFeature: #consonant! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isContinuant	"Answer true if the receiver is a continuant phoneme."	^ self hasFeature: #continuant! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isDiphthong	"Answer true if the receiver is a diphthong phoneme."	^ self hasFeature: #diphthong! !!Phoneme methodsFor: 'testing' stamp: 'len 8/10/1999 00:26'!isFricative	"Answer true if the receiver is a fricative phoneme."	^ self hasFeature: #fricative! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isFrontVowel	"Answer true if the receiver is a front vowel phoneme."	^ self isVowel and: [self hasFeature: #front]! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:02'!isGlide	"Answer true if the receiver is a glide phoneme."	^ self hasFeature: #glide! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isLiquid	"Answer true if the receiver is a liquid phoneme."	^ self hasFeature: #liquid! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isMidVowel	"Answer true if the receiver is a mid vowel phoneme."	^ self isVowel and: [self hasFeature: #mid]! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isNasal	"Answer true if the receiver is an nasal phoneme."	^ self hasFeature: #nasal! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 01:29'!isNonContinuant	"Answer true if the receiver is a noncontinuant phoneme."	^ self isContinuant not! !!Phoneme methodsFor: 'testing' stamp: 'len 8/16/1999 01:39'!isObstruent	"Answer true if the receiver is an obstruent phoneme."	^ self isStop or: [self isFricative or: [self isAffricate]]! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isSemivowel	"Answer true if the receiver is a semivowel phoneme."	^ self hasFeature: #semivowel! !!Phoneme methodsFor: 'testing' stamp: 'len 6/8/1999 01:21'!isSilence	"Answer true if the receiver is the silence phoneme."	^ self hasFeature: #silence! !!Phoneme methodsFor: 'testing' stamp: 'len 8/16/1999 01:39'!isSonorant	"Answer true if the receiver is a sonorant phoneme."	^ self isObstruent not! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isStop	"Answer true if the receiver is a stop phoneme."	^ self hasFeature: #stop! !!Phoneme methodsFor: 'testing' stamp: 'len 8/16/1999 00:46'!isSyllabic	"Answer true if the receiver is a syllabic consonant (or a vowel)."	^ self isVowel or: [self isDiphthong]! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isUnvoiced	"Answer true if the receiver is an uvoiced phoneme."	^ self hasFeature: #unvoiced! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isVoiced	"Answer true if the receiver is a voiced phoneme."	^ self hasFeature: #voiced! !!Phoneme methodsFor: 'testing' stamp: 'len 6/21/1999 19:55'!isVoicedConsonant	"Answer true if the receiver is a voiced consonant."	^ self isVoiced and: [self isConsonant]! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isVowel	"Answer true if the receiver is a vowel phoneme."	^ self hasFeature: #vowel! !!Phoneme methodsFor: 'testing' stamp: 'len 6/2/1999 02:03'!isWhisper	"Answer true if the receiver is an whisper phoneme."	^ self hasFeature: #whisper! !!Phoneme methodsFor: 'properties' stamp: 'len 6/9/1999 01:28'!addProperty: anObject	self at: anObject put: #nothing! !!Phoneme methodsFor: 'properties' stamp: 'len 6/9/1999 01:26'!at: anObject	^ properties at: anObject! !!Phoneme methodsFor: 'properties' stamp: 'len 6/9/1999 01:45'!at: anObject ifAbsent: aBlock	properties isNil ifFalse: [^ properties at: anObject ifAbsent: aBlock].	^ aBlock value! !!Phoneme methodsFor: 'properties' stamp: 'len 6/9/1999 01:27'!at: anObject put: anotherObject	properties isNil ifTrue: [properties _ IdentityDictionary new].	^ properties at: anObject put: anotherObject! !!Phoneme methodsFor: 'properties' stamp: 'len 6/10/1999 01:46'!hasProperty: anObject	^ properties notNil and: [properties includesKey: anObject]! !!Phoneme methodsFor: 'properties' stamp: 'len 6/9/1999 01:30'!properties	^ properties! !!Phoneme methodsFor: 'properties' stamp: 'len 6/9/1999 01:34'!properties: anIdentityDictionary	properties _ anIdentityDictionary! !!Phoneme methodsFor: 'transforming' stamp: 'len 6/9/1999 01:35'!stressed: aNumber	^ self copy stress: aNumber! !!Phoneme methodsFor: 'printing' stamp: 'len 8/17/1999 01:19'!printOn: aStream	name isNil ifTrue: [^ super printOn: aStream].	aStream nextPutAll: name.	self stress > 0 ifTrue: [aStream print: self stress]! !!Phoneme class methodsFor: 'instance creation' stamp: 'len 5/30/1999 01:17'!name: aString	^ self new name: aString! !!Phoneme class methodsFor: 'instance creation' stamp: 'len 5/29/1999 04:34'!name: aString example: anotherString	^ self new name: aString; example: anotherString! !!Phoneme class methodsFor: 'instance creation' stamp: 'len 6/9/1999 01:32'!name: aString example: anotherString features: anArray	| answer |	answer _ self new name: aString; example: anotherString.	anArray do: [ :each | answer addProperty: each].	^ answer! !!PhonemeSet commentStamp: '<historical>' prior: 0!My instances are phoneme sets, i.e. phonetic alphabets.There are several "standard" phoneme sets used among phoneticians. We choosed ARPABET to be the default phoneme set in this system, but other examples are implemented, such as DARPA (radio), MRPA and SAMPA. As well, mappings from those phoneme sets to ARPABET are provided.!!PhonemeSet methodsFor: 'initialization' stamp: 'len 6/2/1999 02:46'!initialize	phonemes _ Dictionary new.	specials _ Dictionary new! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 5/31/1999 01:00'!add: aPhoneme	^ phonemes at: aPhoneme name put: aPhoneme! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 5/31/1999 03:45'!at: aString	^ phonemes at: aString! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 5/31/1999 03:45'!at: aString ifAbsent: aBlock	^ phonemes at: aString ifAbsent: aBlock! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/22/1998 00:53'!description	^ description! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/22/1998 00:53'!description: aString	description _ aString! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/22/1998 00:53'!name	^ name! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/22/1998 00:53'!name: aString	name _ aString! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/8/1999 00:55'!names	"Answer the names of all the phonemes."	^ phonemes keys! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/5/1999 01:43'!pause	^ self silence! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 5/31/1999 01:00'!phonemes	^ phonemes values! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/5/1999 01:43'!silence	^ self specials at: #silence! !!PhonemeSet methodsFor: 'accessing' stamp: 'len 6/2/1999 02:46'!specials	^ specials! !!PhonemeSet methodsFor: 'copying' stamp: 'len 5/31/1999 01:35'!copy	^ self class new addAll: self phonemes; yourself! !!PhonemeSet methodsFor: 'enumerating' stamp: 'len 8/22/1999 18:27'!do: aBlock	phonemes do: aBlock! !!PhonemeSet methodsFor: 'transcribing' stamp: 'len 5/31/1999 03:26'!transcriptionOf: aString	^ (aString findTokens: '/ ')		collect: [ :each |			each last isDigit				ifTrue: [(self at: (each copyFrom: 1 to: each size - 1))							stressed: each last asString asNumber]				ifFalse: [self at: each]]! !!PhonemeSet methodsFor: 'printing' stamp: 'len 5/28/1999 02:55'!printOn: aStream	name isNil ifTrue: [^ super printOn: aStream].	aStream nextPutAll: name, ' phoneme set'! !!PhonemeSet class methodsFor: 'instance creation' stamp: 'len 6/22/1998 00:55'!new	^ super new initialize! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/10/1999 04:12'!arpabet	"Answer the ARPAbet phoneme set."	^ arpabet! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/10/1999 04:12'!darpa	"Answer the DARPA phoneme set."	^ self radio! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 12/20/1999 04:34'!dectalkToArpabet	"Answer a dictionary with DECTalk phoneme names	as keys and ARPAbet phonemes as values."	| answer |	answer _ Dictionary new.	self arpabet do: [ :each | answer at: each name put: each].	#(		('nx'	'ng')		('yx'	'jh')		('lx'		'l')		('rr'	'r')		('u'		'uw')		('hx'	'hh')		('h'		'hh')		('_'		'sil')) do: [ :each | answer at: each first put: (self arpabet at: each last)].	^ answer! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 5/31/1999 00:25'!default	^ self arpabet! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 9/29/1999 02:27'!mactalkToArpabet	"Answer a dictionary with MacTalk phoneme names	as keys and ARPAbet phonemes as values."	| answer |	answer _ Dictionary new.	#(			('IY'	'iy')		('IH'	'ih')		('EY'	'ey')		('EH'	'eh')		('AE'	'ae')		('AA'	'aa')		('AO'	'ao')		('OW'	'ow')		('UH'	'uh')		('UW'	'uw')"		(''	'er')"		('AX'	'ax')		('AH'	'ah')		('AY'	'ay')		('AW'	'aw')		('OY'	'oy')"		(''	'ix')"		('p'		'p')		('b'		'b')		('t'		't')		('d'		'd')		('k'		'k')		('g'		'g')		('f'		'f')		('v'		'v')		('T'		'th')		('D'		'dh')		('s'		's')		('z'		'z')		('S'		'sh')		('Z'		'zh')		('h'		'hh')		('m'		'm')		('n'		'n')		('N'		'ng')		('l'		'l')		('w'		'w')		('y'		'y')		('r'		'r')		('C'		'ch')		('J'		'jh')		('UX'	'ax')		('_'		'sil')		('~'		'sil')) do: [ :each | answer at: each first put: (self arpabet at: each last)].	^ answer! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/10/1999 04:11'!mrpa	"Answer the MRPA phoneme set."	self notYetImplemented! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/21/1999 20:46'!mrpaToArpabet	"Answer a dictionary with MRPA phoneme names	as keys and ARPAbet Phonemes as values."	self notYetImplemented! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/8/1999 01:55'!radio	"Answer the radio phoneme set, named after the BU RADIO FM corpus."	self notYetImplemented! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/10/1999 04:11'!sampa	"Answer the sampa phoneme set."	| answer mapping |	mapping _ self sampaToArpabet.	answer _ self new.	mapping keysDo: [ :each | answer add: ((self arpabet at: (mapping at: each)) copy name: each)].	^ answer! !!PhonemeSet class methodsFor: 'examples' stamp: 'len 6/12/1999 04:00'!sampaToArpabet	"Answer a dictionary with SAMPA phoneme names	as keys and ARPAbet phonemes as values."	| answer |	answer _ Dictionary new.	#(	('p'		'p')		('b'		'b')		('t'		't')		('d'		'd')		('k'		'k')		('m'		'm')		('n'		'n')		('l'		'l')		('r'		'r')		('f'		'f')		('v'		'v')		('s'		's')		('z'		'z')		('h'		'hh')		('w'		'w')		('g'		'g')		('tS'		'ch')		('dZ'	'jh')		('N'		'ng')		('T'		'th')		('D'		'dh')		('S'		'sh')		('Z'		'zh')		('j'		'y')		('i:'		'iy')		('i'		'iy')		('A:'	'aa')		('A'		'aa')		('O:'	'ao')		('O'		'ao')		('u:'	'uw')		('u'		'uw')		('3:'		'er')		('r='	'er')		('I'		'ih')		('e'		'eh')		('E'		'eh')		('{'		'ae')		('V'		'ah')		"	('Q'		'oh')"		('U'		'uh')		('@'		'ax')		('eI'		'ey')		('aI'	'ay')		('OI'	'oy')		('@U'	'ow')		('aU'	'aw')		('I@'	'ia')		('e@'	'ea')		('U@'	'ua')		('AI'	'ay')		('EI'		'ey')		('4'		't')		('_'		'sil')) do: [ :each | answer at: each first put: (self arpabet at: each last)].	^ answer! !!PhonemeSet class methodsFor: 'class initialization' stamp: 'len 12/20/1999 04:30'!initialize	"	PhonemeSet initialize	"	arpabet _ self new name: 'ARPAbet'; description: 'This is the ARPAbet phonetic alphabet.'.	#("Name"	"Example"	"Features"		('iy'	'heed'		#(continuant vowel front))		('ih'	'hid'		#(continuant vowel front))		('ey'	'hayed'		#(continuant vowel front))		('eh'	'head'		#(continuant vowel front))		('ae'	'had'		#(continuant vowel front))		('aa'	'hod'		#(continuant vowel back))		('ao'	'hawed'		#(continuant vowel back))		('ow'	'hoed'		#(continuant vowel back))		('uh'	'hood'		#(continuant vowel back))		('uw'	'who''d'		#(continuant vowel back))		('er'	'heard'		#(continuant vowel mid))		('ax'	'ago'		#(continuant vowel mid))		('ah'	'mud'		#(continuant vowel mid))		('ay'	'hide'		#(diphthong))		('aw'	'how''d'		#(diphthong))		('oy'	'boy'		#(diphthong))		('ix'		'roses'		#())		('p'		'pea'		#(consonant stop unvoiced))		('b'		'bat'		#(consonant stop voiced))		('t'		'tea'		#(consonant stop unvoiced))		('d'		'deep'		#(consonant stop voiced))		('k'		'kick'		#(consonant stop unvoiced))		('g'		'go'			#(consonant stop voiced))		('f'		'five'		#(continuant consonant fricative unvoiced))		('v'		'vice'		#(continuant consonant fricative voiced))		('th'	'thing'		#(continuant consonant fricative unvoiced))		('dh'	'then'		#(continuant consonant fricative voiced))		('s'		'so'			#(continuant consonant fricative unvoiced))		('z'		'zebra'		#(continuant consonant fricative voiced))		('sh'	'show'		#(continuant consonant fricative unvoiced))		('zh'	'measure'	#(continuant consonant fricative voiced))		('hh'	'help'		#(continuant consonant whisper))		('m'		'mom'		#(continuant consonant nasal))		('n'		'noon'		#(continuant consonant nasal))		('ng'	'sing'		#(continuant consonant nasal))		"old name: nx"		('l'		'love'		#(semivowel liquid))		('el'		'cattle')		('em'	'some')		('en'	'son')		('dx'	'batter')		('q'		'[glottal stop]')		('w'		'want'		#(continuant semivowel glide))		('y'		'yard'		#(continuant semivowel glide))		('r'		'race'		#(continuant semivowel liquid))		('ch'	'church'	#(continuant consonant affricate))		('jh'	'just'		#(continuant consonant affricate))		('wh'	'when'		#(semivowel liquid))	"not found in the original:"		('sil'	'[silence]'	#(silence))		('ll'		'')	"dark l"		('ai'	''			#(vowel))	"what is this?"		('ia'	''			#(vowel))		('ea'	''			#(vowel))		('ua'	''			#(vowel))		('aor'	'')		('rx'	''			#())	) do: [ :each |		arpabet add: (each size > 2						ifTrue: [Phoneme name: each first example: each second features: each last]						ifFalse: [Phoneme name: each first example: each last])].	arpabet specials at: #silence put: (arpabet at: 'sil')! !!PhoneticRule commentStamp: '<historical>' prior: 0!My instances are letter-to-sound rules for perform automatic text-to-phonemes transcription. (See the PhoneticTranscriber class comment too.)Rules are made up of four parts: (1) left context pattern, (2) the text to match, (3) the right context pattern, and (4) the phonemes to substitute for the matched text.The transcription procedure begins separating each block of letters (apostrophes included) and adding a space on each side. For each unmatched letter in the word, look through the rules where the text to match starts with the letter in the word. If the text to match if found and the right and left contexts patterns also match, output the phonemes for that rule and skip to the next unmatched letter.Context patterns special characters:	#	One or more vowels	:	Zero or more consonants	^	One consonant	.	One of B, D, V, G, J, L, M, N, R, W, or Z (voiced consonants)	%	One of ER, E, ES, ED, ING, ELY (a suffix)	[ONLY FOR RIGHT CONTEXT]	+	One of E, I or Y (a "front" vowel)Furthermore, the space character means any separator (space, comma, colon, etc), and any other character means that character it self.The english example is derived from: "Automatic Translation of English Text to Phonetics by Means of Letter-To-Sound Rules", NRL Report 7948, January 21st, 1976, Naval Research Laboratory, Washington, D.C. Published by the National Technical Information Service as document "AD/A021 929".!!PhoneticRule methodsFor: 'accessing' stamp: 'len 5/29/1999 03:59'!left	^ left! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 4/9/98 23:46'!left: aString	left _ aString! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 4/10/98 05:01'!phonemes	^ phonemes! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 4/9/98 23:47'!phonemes: aCollection	phonemes _ aCollection! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 5/29/1999 03:59'!right	^ right! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 4/9/98 23:46'!right: aString	right _ aString! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 4/10/98 05:00'!text	^ text! !!PhoneticRule methodsFor: 'accessing' stamp: 'len 4/9/98 23:46'!text: aString	text _ aString! !!PhoneticRule methodsFor: 'testing' stamp: 'len 6/8/1999 00:14'!matches: aString at: anInteger	^ (self textMatches: aString at: anInteger)		and: [(self leftMatches: aString at: anInteger)			and: [self rightMatches: aString at: anInteger]]! !!PhoneticRule methodsFor: 'private' stamp: 'len 11/3/1998 06:04'!leftMatches: aString at: anInteger	| leftindex textindex pattern |	left isEmpty ifTrue: [^ true].	leftindex _ left size.	textindex _ anInteger - 1.	[leftindex >= 1 and: [textindex >= 1]] whileTrue: [		pattern _ left at: leftindex.		"first check for simple text or apostrophe:"		(pattern isAlphaNumeric or: [pattern = $'])			ifTrue: [(aString at: textindex) asLowercase ~= pattern asLowercase						ifTrue: [^ false].					textindex _ textindex - 1].		"space:"		pattern = Character space			ifTrue: [((aString at: textindex) isSeparator						or: ['.,;:' includes: (aString at: textindex)]) ifFalse: [^ false].					textindex _ textindex - 1].		"one or more vowels:"		pattern = $#			ifTrue: [(aString at: textindex) isVowel ifFalse: [^ false].					textindex _ textindex - 1.					[textindex >= 1 and: [(aString at: textindex) isVowel]]						whileTrue: [textindex _ textindex - 1]].		"zero or more consonants:"		pattern = $:			ifTrue: [[textindex >= 1						and: ['bcdfghjklmnpqrstvwxyz'								includes: (aString at: textindex) asLowercase]]							whileTrue: [textindex _ textindex - 1]].		"one consonant:"		pattern = $^			ifTrue: [('bcdfghjklmnpqrstvwxyz' includes: (aString at: textindex))						ifFalse: [^ false].					textindex _ textindex - 1].		"b, d, v, g, j, l, m, n, r, w, z (voiced consonants):"		pattern = $.			ifTrue: [('bdvgjlmnrwz' includes: (aString at: textindex) asLowercase)						ifFalse: [^ false].					textindex _ textindex - 1].		"e, i or y (front vowels)"		pattern = $+			ifTrue: [('eiy' includes: (aString at: textindex) asLowercase)						ifFalse: [^ false].					textindex _ textindex - 1].		leftindex _ leftindex - 1].	^ true! !!PhoneticRule methodsFor: 'private' stamp: 'len 11/3/1998 06:04'!rightMatches: aString at: anInteger	| rightindex textindex pattern |	right isEmpty ifTrue: [^ true].	rightindex _ 1.	textindex _ anInteger + text size.	[rightindex <= right size and: [textindex <= aString size]] whileTrue: [		pattern _ right at: rightindex.		"first check for simple text or apostrophe:"		(pattern isAlphaNumeric or: [pattern = $'])			ifTrue: [(aString at: textindex) asLowercase ~= pattern asLowercase						ifTrue: [^ false].					textindex _ textindex + 1].		"space:"		pattern = Character space			ifTrue: [((aString at: textindex) isSeparator						or: ['.,;:' includes: (aString at: textindex)]) ifFalse: [^ false].					textindex _ textindex + 1].		"one or more vowels:"		pattern = $#			ifTrue: [(aString at: textindex) isVowel ifFalse: [^ false].					textindex _ textindex + 1.					[textindex <= aString size and: [(aString at: textindex) isVowel]]						whileTrue: [textindex _ textindex + 1]].		"zero or more consonants:"		pattern = $:			ifTrue: [[textindex <= aString size						and: ['bcdfghjklmnpqrstvwxyz'								includes: (aString at: textindex) asLowercase]]							whileTrue: [textindex _ textindex + 1]].		"one consonant:"		pattern = $^			ifTrue: [('bcdfghjklmnpqrstvwxyz' includes: (aString at: textindex))						ifFalse: [^ false].					textindex _ textindex + 1].		"b, d, v, g, j, l, m, n, r, w, z (voiced consonants):"		pattern = $.			ifTrue: [('bdvgjlmnrwz' includes: (aString at: textindex) asLowercase)						ifFalse: [^ false].					textindex _ textindex + 1].		"e, i or y (front vowels):"		pattern = $+			ifTrue: [('eiy' includes: (aString at: textindex) asLowercase)						ifFalse: [^ false].					textindex _ textindex + 1].		"er, e, es, ed, ing, ely (a suffix):"		pattern = $%			ifTrue: [(aString at: textindex) asLowercase = $e						ifTrue: [textindex _ textindex + 1.								(textindex < aString size and: [(aString at: textindex) asLowercase = $l])									ifTrue: [textindex _ textindex + 1.											(textindex < aString size and: [(aString at: textindex) asLowercase = $y])												ifTrue: [textindex _ textindex + 1]												ifFalse: [textindex _ textindex - 1]]									ifFalse: [('rsd' includes: (aString at: textindex) asLowercase)												ifTrue: [textindex _ textindex + 1]]]						ifFalse: [(textindex + 2 <= aString size									and: [(aString at: textindex) asLowercase = $i										and: [(aString at: textindex + 1) asLowercase = $n											and: [(aString at: textindex + 2) asLowercase = $g]]])									ifTrue: [textindex _ textindex + 3]									ifFalse: [^ false]]].		rightindex _ rightindex + 1].	^ true! !!PhoneticRule methodsFor: 'private' stamp: 'len 4/10/98 23:19'!textMatches: aString at: anInteger	text size > (aString size - anInteger + 1) ifTrue: [^ false].	1 to: text size do: [ :each |		(text at: each) asLowercase = (aString at: anInteger + each - 1) asLowercase ifFalse: [^ false]].	^ true! !!PhoneticRule methodsFor: 'comparing' stamp: 'len 5/29/1999 03:58'!= anObject	^ anObject left = self left		and: [anObject right = self right			and: [anObject text = self text				and: [anObject phonemes = self phonemes]]]! !!PhoneticRule methodsFor: 'comparing' stamp: 'len 5/29/1999 03:58'!hash	^ self text hash! !!PhoneticRule methodsFor: 'printing' stamp: 'len 5/31/1999 00:32'!printOn: aStream	aStream		nextPut: $[; print: left; nextPut: $,; print: text; nextPut: $,; print: right; nextPut: $];		nextPutAll: ' -> '.	phonemes isEmpty ifTrue: [aStream nextPutAll: '{}'] ifFalse: [aStream nextPut: $/].	phonemes do: [ :each | aStream nextPutAll: each name; nextPut: $/]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:14'!english	"Answer the english phonetic rules."	| answer |	answer _ OrderedCollection new.	#(englishPunctuationRules		englishARules englishBRules englishCRules englishDRules englishERules		englishFRules englishGRules englishHRules englishIRules englishJRules		englishKRules englishLRules englishMRules englishNRules englishORules		englishPRules englishQRules englishRRules englishSRules englishTRules		englishURules englishVRules englishWRules englishXRules englishYRules		englishZRules) do: [ :each | answer addAll: (self perform: each)].	^ answer asArray! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/30/1999 23:54'!englishARules	^ #((''		'a'		' '		'ax')		(' '		'are'	' '		'aa/r')		(' '		'ar'		'o'		'ax/r')		(''		'ar'		'#'		'eh/r')		('^'		'as'		'#'		'ey/s')		(''		'a'		'wa'	'ax')		(''		'aw'	''		'ao')		(' :'		'any'	''		'eh/n/iy')		(''		'a'		'^+#'	'ey')		('#:'	'ally'	''		'ax/l/iy')		(' '		'al'		'#'		'ax/l')		(''		'again'	''		'ax/g/eh/n')		('#:'	'ag'		'e'		'ih/jh')		(''		'a'		'^+:#'	'ae')		(' :'		'a'		'^+ '	'ey')		(' '		'arr'	''		'ax/r')		(''		'arr'	''		'ae/r')		(' :'		'ar'		' '		'aa/r')		(''		'ar'		' '		'er')		(''		'ar'		''		'aa/r')		(''		'air'	''		'eh/r')		(''		'ai'		''		'ey')		(''		'ay'		''		'ey')		(''		'au'		''		'ao')		('#:'	'al'		' '		'ax/l')		('#:'	'als'	' '		'ax/l/z')		(''		'alk'	''		'ao/k')		(''		'al'		'^'		'ao/l')		(' :'		'able'	''		'ey/b/ax/l')		(''		'able'	''		'ax/b/ax/l')		(''		'ang'	'+'		'ey/n/jh')		('^'		'a'		'^#'		'ey')		(''		'a'		''		'ae')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/30/1999 23:58'!englishBRules	^ #((' '		'be'		'^#'		'b/ih')		(''		'being'	''		'b/iy/ih/ng')		(' '		'both'	''		'b/ow/th')		(' '		'bus'	'#'		'b/ih/z')		(''		'buil'	''		'b/ih/l')		(''		'b'		''		'b')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/30/1999 23:59'!englishCRules	^ #((' '		'ch'		'^'		'k')		('^e'	'ch'		''		'k')		(''		'ch'		''		'ch')		(' s'		'ci'		'#'		's/ay')		(''		'ci'		'a'		'sh')		(''		'ci'		'o'		'sh')		(''		'ci'		'en'		'sh')		(''		'c'		'+'		's')		(''		'ck'		''		'k')		(''		'com'	'%'		'k/ah/m')		(''		'c'		''		'k')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 12/2/1999 02:41'!englishDRules	^ #(('#:'	'ded'	' '		'd/ih/d')		('.e'		'd'		' '		'd')		('#:^e'	'd'		' '		't')		(' '		'de'		'^#'		'd/ih')		(' '		'do'		' '		'd/uw')		(' '		'does'	''		'd/ah/z')		(' '		'doing'	''		'd/uw/ih/ng')		(' '		'dow'	''		'd/aw')		(''		'du'		'a'		'jh/uw')		(''		'd'		''		'd')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 12/9/1999 02:27'!englishERules	^ #(('#:'	'e'		' '		'')		(''':^'	'e'		' '		'')		(' :'		'e'		' '		'iy')		('#'		'ed'		' '		'd')		('#:'	'e'		'd'		'')		(''		'ev'		'er'		'eh/v')		(''		'e'		'^%'		'iy')		(''		'eri'	'#'		'iy/r/iy')		(''		'eri'	''		'eh/r/ih')		('#:'	'er'		'#'		'er')		(''		'er'		'#'		'eh/r')		(''		'er'		''		'er')		(' '		'even'	''		'iy/v/eh/n')		('#:'	'e'		'w'		'')		('t'		'ew'	''		'uw')		('s'		'ew'	''		'uw')		('r'		'ew'	''		'uw')		('d'		'ew'	''		'uw')		('l'		'ew'	''		'uw')		('z'		'ew'	''		'uw')		('n'		'ew'	''		'uw')		('j'		'ew'	''		'uw')		('th'	'ew'	''		'uw')		('ch'	'ew'	''		'uw')		('sh'	'ew'	''		'uw')		(''		'ew'	''		'y/uw')		(''		'e'		'o'		'iy')		('#:s'	'es'		' '		'ih/z')		('#:c'	'es'		' '		'ih/z')		('#:g'	'es'		' '		'ih/z')		('#:z'	'es'		' '		'ih/z')		('#:x'	'es'		' '		'ih/z')		('#:j'	'es'		' '		'ih/z')		('#:ch'	'es'		' '		'ih/z')		('#:sh'	'es'		' '		'ih/z')		('#:'	'e'		's'		'')		('#:'	'ely'	' '		'l/iy')		('#:'	'ement'	''		'm/eh/n/t')		(''		'eful'	''		'f/uh/l')		(''		'ee'		''		'iy')		(''		'earn'	''		'er/n')		(' '		'ear'	'^'		'er')		(''		'ead'	''		'eh/d')		('#:'	'ea'		' '		'iy/ax')		(''		'ea'		'su'		'eh')		(''		'ea'		''		'iy')		(''		'eigh'	''		'ey')		(''		'ei'		''		'iy')		(' '		'eye'	''		'ay')		(''		'ey'		''		'iy')		(''		'eu'		''		'y/uw')		(''		'e'		''		'eh')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:01'!englishFRules	^ #((''		'ful'	''		'f/uh/l')		(''		'f'		''		'f')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:02'!englishGRules	^ #((''		'giv'	''		'g/iy/v')		(' '		'g'		'i^'		'g')		(''		'ge'		't'		'g/eh')		('su'	'gges'	''		'g/jh/eh/s')		(''		'gg'		''		'g')		(' b#'	'g'		''		'g')		(''		'g'		'+'		'jh')		(''		'great'	''		'g/r/ey/t')		('#'		'gh'		''		'')		(''		'g'		''		'g')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 7/20/1999 00:42'!englishHRules	^ #((' '		'hav'	''		'hh/ae/v')		(' '		'here'	''		'hh/iy/r')		(' '		'hour'	''		'aw/er')		(''		'how'	''		'hh/aw')		(''		'h'		'#'		'hh')		(''		'h'		''		'')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:03'!englishIRules	^ #((' '		'in'		''		'ih/n')		(' '		'i'		' '		'ay')		(''		'in'		'd'		'ay/n')		(''		'ier'	''		'iy/er')		('#:r'	'ied'	''		'iy/d')		(''		'ied'	' '		'ay/d')		(''		'ien'	''		'iy/eh/n')		(''		'ie'		't'		'ay/eh')		(' :'		'i'		'%'		'ay')		(''		'i'		'%'		'iy')		(''		'ie'		''		'iy')		(''		'i'		'^+:#'	'ih')		(''		'ir'		'#'		'ay/r')		(''		'iz'		'%'		'ay/z')		(''		'is'		'%'		'ay/z')		(''		'i'		'd%'		'ay')		('+^'	'i'		'^+'		'ih')		(''		'i'		't%'		'ay')		('#:^'	'i'		'^+'		'ih')		(''		'i'		'^+'		'ay')		(''		'ir'		''		'er')		(''		'igh'	''		'ay')		(''		'ild'		''		'ay/l/d')		(''		'ign'	' '		'ay/n')		(''		'ign'	'^'		'ay/n')		(''		'ign'	'%'		'ay/n')		(''		'ique'	''		'iy/k')		(''		'i'		''		'ih')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:03'!englishJRules	^ #((''		'j'		''		'jh')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:04'!englishKRules	^ #((''		'k'		'n'		'')		(''		'k'		''		'k')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:04'!englishLRules	^ #((''		'lo'		'c#'		'l/ow')		('l'		'l'		''		'')		('#:^'	'l'		'%'		'ax/l')		(''		'lead'	''		'l/iy/d')		(''		'l'		''		'l')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:04'!englishMRules	^ #((''		'mov'	''		'm/uw/v')		(''		'm'		''		'm')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:05'!englishNRules	^ #(('e'		'ng'		'+'		'n/jh')		(''		'ng'		'r'		'ng/g')		(''		'ng'		'#'		'ng/g')		(''		'ngl'	'%'		'ng/g/ax/l')		(''		'ng'		''		'ng')		(''		'nk'		''		'ng/k')		(' '		'now'	' '		'n/aw')		(''		'n'		''		'n')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:06'!englishORules	^ #((''		'of'		' '		'ax/v')		(''		'orough'	''	'er/ow')		('#:'	'or'		' '		'er')		('#:'	'ors'	' '		'er/z')		(''		'or'		''		'ao/r')		(' '		'one'	''		'w/ah/n')		(''		'ow'	''		'ow')		(' '		'over'	''		'ow/v/er')		(''		'ov'		''		'ah/v')		(''		'o'		'^%'		'ow')		(''		'o'		'^en'	'ow')		(''		'o'		'^i#'	'ow')		(''		'ol'		'd'		'ow/l')		(''		'ought'	''		'ao/t')		(''		'ough'	''		'ah/f')		(' '		'ou'		''		'aw')		('h'		'ou'		's#'		'aw')		(''		'ous'	''		'ax/s')		(''		'our'	''		'ao/r')		(''		'ould'	''		'uh/d')		('^'		'ou'		'^l'		'ah')		(''		'oup'	''		'uw/p')		(''		'ou'		''		'aw')		(''		'oy'		''		'oy')		(''		'oing'	''		'ow/ih/ng')		(''		'oi'		''		'oy')		(''		'oor'	''		'ao/r')		(''		'ook'	''		'uh/k')		(''		'ood'	''		'uh/d')		(''		'oo'		''		'uw')		(''		'o'		'e'		'ow')		(''		'o'		' '		'ow')		(''		'oa'		''		'ow')		(' '		'only'	''		'ow/n/l/iy')		(' '		'once'	''		'w/ah/n/s')		(''		'on''t'	''		'ow/n/t')		('c'		'o'		'n'		'aa')		(''		'o'		'ng'		'ao')		(' :^'	'o'		'n'		'ah')		('i'		'on'		''		'ax/n')		('#:'	'on'		' '		'ax/n')		('#^'	'on'		''		'ax/n')		(''		'o'		'st '		'ow')		(''		'of'		'^'		'ao/f')		(''		'other'	''		'ah/dh/er')		(''		'oss'	' '		'ao/s')		('#:^'	'om'	''		'ah/m')		(''		'o'		''		'aa')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:06'!englishPRules	^ #((''		'ph'		''		'f')		(''		'peop'	''		'p/iy/p')		(''		'pow'	''		'p/aw')		(''		'put'	' '		'p/uh/t')		(''		'p'		''		'p')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:07'!englishPunctuationRules	^ #(('.'		'''s'		''		'z')		('#:.e'	'''s'		''		'z')		('#'		'''s'		''		'z')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:07'!englishQRules	^ #((''		'quar'	''		'k/w/ao/r')		(''		'qu'		''		'k/w')		(''		'q'		''		'k')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:07'!englishRRules	^ #((''		're'		'^#'		'r/iy')		(''		'r'		''		'r')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:07'!englishSRules	^ #((''		'sh'		''		'sh')		('#'		'sion'	''		'zh/ax/n')		(''		'some'	''		's/ah/m')		('#'		'sur'	'#'		'zh/er')		(''		'sur'	'#'		'sh/er')		('#'		'su'		'#'		'zh/uw')		('#'		'ssu'	'#'		'sh/uw')		('#'		'sed'	' '		'z/d')		('#'		's'		'#'		'z')		(''		'said'	''		's/eh/d')		('^'		'sion'	''		'sh/ax/n')		(''		's'		's'		'')		('.'		's'		' '		'z')		('#:.e'	's'		' '		'z')		('#:^##'	's'		' '		'z')		('#:^#'	's'		' '		's')		('u'		's'		' '		's')		(' :#'	's'		' '		'z')		(' '		'sch'	''		's/k')		(''		's'		'c+'		'')		('#'		'sm'		''		'z/m')		('#'		'sn'		''''		'z/ax/n')		(''		's'		''		's')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:08'!englishTRules	^ #((' '		'the'	' '		'dh/ax')		(''		'to'		' '		't/uw')		(''		'that'	' '		'dh/ae/t')		(' '		'this'	' '		'dh/ih/s')		(' '		'they'	''		'dh/ey')		(' '		'there'	''		'dh/eh/r')		(''		'ther'	''		'dh/er')		(''		'their'	''		'dh/eh/r')		(' '		'than'	' '		'dh/ae/n')		(' '		'them'	' '		'dh/eh/m')		(''		'these'	' '		'dh/iy/z')		(' '		'then'	''		'dh/eh/n')		(''		'through'	''	'th/r/uw')		(''		'those'	''		'dh/ow/z')		(''		'though'	' '	'dh/ow')		(' '		'thus'	''		'dh/ah/s')		(''		'th'		''		'th')		('#:'	'ted'	' '		't/ih/d')		('s'		'ti'		'#n'	'ch')		(''		'ti'		'o'		'sh')		(''		'ti'		'a'		'sh')		(''		'tien'	''		'sh/ax/n')		(''		'tur'	'#'		'ch/er')		(''		'tu'		'a'		'ch/uw')		(''		'two'	''		't/uw')		(''		't'		''		't')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:09'!englishURules	^ #((' '		'un'	'i'		'y/uw/n')		(' '		'un'	''		'ah/n')		(' '		'upon'	''		'ax/p/ao/n')		('t'		'ur'		'#'		'uh/r')		('s'		'ur'		'#'		'uh/r')		('r'		'ur'		'#'		'uh/r')		('d'		'ur'		'#'		'uh/r')		('l'		'ur'		'#'		'uh/r')		('z'		'ur'		'#'		'uh/r')		('n'		'ur'		'#'		'uh/r')		('j'		'ur'		'#'		'uh/r')		('th'	'ur'		'#'		'uh/r')		('ch'	'ur'		'#'		'uh/r')		('sh'	'ur'		'#'		'uh/r')		(''		'ur'		'#'		'y/uh/r')		(''		'ur'		''		'er')		(''		'u'		'^'		'ah')		(''		'u'		'^^'		'ah')		(''		'uy'	''		'ay')		(' g'	'u'		'#'		'')		('g'		'u'		'%'		'')		('g'		'u'		'#'		'w')		('#n'	'u'		''		'y/uw')		('t'		'u'		''		'uw')		('s'		'u'		''		'uw')		('r'		'u'		''		'uw')		('d'		'u'		''		'uw')		('l'		'u'		''		'uw')		('z'		'u'		''		'uw')		('n'		'u'		''		'uw')		('j'		'u'		''		'uw')		('th'	'u'		''		'uw')		('ch'	'u'		''		'uw')		('sh'	'u'		''		'uw')		(''		'u'		''		'y/uw')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:09'!englishVRules	^ #((''		'view'	''		'v/y/uw')		(''		'v'		''		'v')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 7/20/1999 00:43'!englishWRules	^ #((' '		'were'	''		'w/er')		(''		'wa'	's'		'w/aa')		(''		'wa'	't'		'w/aa')		(''		'where'	''		'wh/eh/r')		(''		'what'	''		'wh/aa/t')		(''		'whol'	''		'hh/ow/l')		(''		'who'	''		'hh/uw')		(''		'wh'	''		'wh')		(''		'war'	''		'w/ao/r')		(''		'wor'	'^'		'w/er')		(''		'wr'	''		'r')		(''		'w'		''		'w')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:10'!englishXRules	^ #((''		'x'		''		'k/s')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:10'!englishYRules	^ #((''		'young'	''		'y/ah/ng')		(' '		'you'	''		'y/uw')		(' '		'yes'	''		'y/eh/s')		(' '		'y'		''		'y')		('#:^'	'y'		' '		'iy')		('#:^'	'y'		'i'		'iy')		(' :'		'y'		''		'ay')		(' :'		'y'		'#'		'ay')		(' :'		'y'		'^+:#'	'ih')		(' :'		'y'		'^#'		'ay')		(''		'y'		''		'ih')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples-english' stamp: 'len 5/31/1999 00:10'!englishZRules 	^ #((''		'z'		''		'z')	) collect: [ :each | self fromArray: each]! !!PhoneticRule class methodsFor: 'examples' stamp: 'len 12/8/1999 17:14'!spanish	"Answer the spanish phonetic rules."	| phonemes |	phonemes _ PhonemeSet spanish.	^ #(		(''		'a'		''		'a')		(''		'b'		''		'b')		(''		'ch'		''		'ch')		(''		'c'		'i'		'z')		(''		'c'		'e'		'z')		(''		'c'		''		'k')		(''		'd'		''		'd')		(''		'e'		''		'e')		(''		'f'		''		'f')		(''		'g'		'e'		'j')		(''		'g'		'i'		'j')		(''		'gu'		'e'		'g')		(''		'gu'		'i'		'g')		(''		'g'		''		'g')		(''		'h'		''		'')		(''		'i'		''		'i')		(''		'j'		''		'j')		(''		'k'		''		'k')		(''		'll'		''		'y')		(''		'l'		''		'l')		(''		'm'		''		'm')		(''		'n'		''		'n')		(''		'o'		''		'o')		(''		'p'		''		'p')		(''		'qu'		''		'k')		(''		'rr'		''		'rx')		(' '		'r'		''		'rx')		(''		'r'		''		'r')		(''		's'		''		's')		(''		't'		''		't')		(''		'u'		''		'u')		(''		'v'		''		'v')		(''		'w'		''		'w')		(''		'x'		''		'k/s')		(''		'y'		' '		'i')		(''		'y'		''		'y')		(''		'z'		''		'z')	) collect: [ :each | self fromArray: each phonemes: phonemes]! !!PhoneticRule class methodsFor: 'instance creation' stamp: 'len 5/31/1999 00:16'!fromArray: anArray	^ self fromArray: anArray phonemes: PhonemeSet arpabet! !!PhoneticRule class methodsFor: 'instance creation' stamp: 'len 5/31/1999 00:19'!fromArray: anArray phonemes: aPhonemeSet	^ self new		left: (anArray at: 1);		text: (anArray at: 2);		right: (anArray at: 3);		phonemes: (aPhonemeSet transcriptionOf: (anArray at: 4)) asArray! !!PhoneticTranscriber commentStamp: '<historical>' prior: 0!My instances perform automatic words-to-phonemes transcription. (See the PhoneticRule class comment too.)Each transcriber must have a collection of PhoneticRules, and optionally a lexicon. When a transcriber is asked for the transcription of a word, it searches for the word in the lexicon first, and if the word is not found then the rules are used.Rules are made up of four parts: (1) left context pattern, (2) the text to match, (3) the right context pattern, and (4) the phonemes to substitute for the matched text.The transcription procedure begins when a text is provided to a transcriber. For each unmatched letter in the word, look through the rules where the text to match starts with the letter in the word. If one matching rule is found, then the rule is applied, writing the corresponding phonemes in the output and moving forward to the next unmatched position. If no rule is found for a position in the text, then the unmatched position is logged. At the end of the transcription, the phonemes extracted are provided in a collection and so are the unmatched positions.!!PhoneticTranscriber methodsFor: 'accessing-private' stamp: 'len 11/29/1999 02:31'!lexicon: aDictionary	lexicon _ aDictionary! !!PhoneticTranscriber methodsFor: 'accessing-private' stamp: 'len 6/5/1999 01:56'!phonemes: aPhonemeSet	phonemes _ aPhonemeSet! !!PhoneticTranscriber methodsFor: 'accessing-private' stamp: 'len 4/10/98 05:10'!rules: aCollection	rules _ aCollection! !!PhoneticTranscriber methodsFor: 'accessing' stamp: 'len 11/29/1999 02:31'!lexicon	^ lexicon! !!PhoneticTranscriber methodsFor: 'accessing' stamp: 'len 6/5/1999 01:56'!phonemes	^ phonemes! !!PhoneticTranscriber methodsFor: 'accessing' stamp: 'len 6/5/1999 01:56'!rules	^ rules! !!PhoneticTranscriber methodsFor: 'computing' stamp: 'len 12/14/1999 03:39'!transcriptionOf: aString	"Answer the phonetic transcription of the word in aString."	| rule string index transcription stressed |	(transcription _ self tryLexicon: aString) isNil ifFalse: [^ transcription].	transcription _ OrderedCollection new.	string _ ' ', aString,' '.	index _ 2.	[index < string size] whileTrue: [		rule _ self rules			detect: [ :one | one matches: string at: index]			ifNone: [].		rule isNil			ifTrue: ["unmatched character" index _ index+1]			ifFalse: [index _ index + rule text size.					transcription addAll: rule phonemes]].	stressed _ false.	^ transcription collect: [ :each |		(stressed not and: [each isVowel or: [each isDiphthong]])			ifTrue: [stressed _ true. each stressed: 1] ifFalse: [each]]! !!PhoneticTranscriber methodsFor: 'computing-private' stamp: 'len 11/29/1999 02:31'!tryLexicon: aWord	| string |	self lexicon isNil ifTrue: [^ nil].	string _ self lexicon at: aWord asUppercase ifAbsent: [^ nil].	^ self phonemes transcriptionOf: string asLowercase! !!PhoneticTranscriber class methodsFor: 'examples' stamp: 'len 4/13/98 16:21'!default	^ self english! !!PhoneticTranscriber class methodsFor: 'examples' stamp: 'len 12/14/1999 03:29'!english	"Answer an english phonetic transcriber."	^ self new rules: PhoneticRule english; phonemes: PhonemeSet arpabet; lexicon: self englishLexicon! !!PhoneticTranscriber class methodsFor: 'examples' stamp: 'len 12/14/1999 04:05'!englishLexicon	^ Dictionary new		add: 'HOW' -> 'HH AW1';		add: 'YOU' -> 'Y UW1';		add: 'ARE' -> 'AA1 R';		add: 'DOING' -> 'D UW1 IH0 NG';		add: 'THIS' -> 'DH IH1 S';		add: 'IS' -> 'IH1 Z';		add: 'MY' -> 'M AY1';		add: 'VOICE' -> 'V OY1 S';		add: 'FAST' -> 'F AE1 S T';		add: 'SLOW' -> 'S L OW1';		add: 'I' -> 'AY1';		add: 'AM' -> 'AE1 M';		add: 'A' -> 'AH0';		add: 'AN' ->  'AE1 N';		add: 'LOW' -> 'L OW1';		add: 'SPEAKER' -> 'S P IY1 K ER0';		add: 'ANSWER' -> 'AE1 N S ER0';		add: 'RECEIVER' -> 'R AH0 S IY1 V ER0';		add: 'OBJECT' -> 'AA1 B JH EH0 K T';		add: 'OBJECTS' -> 'AA1 B JH EH0 K T S';		add: 'READ' -> 'R IY1 D';		add: 'WRITE' -> 'R AY1 T';		add: 'SQUEAK' -> 'S K W IY1 K';		add: 'SMALLTALK' -> ' S M AO1 L T AO2 K';		add: 'CLASS' -> 'K L AE1 S';		add: 'WOMAN' -> 'W UH1 M AH0 N';		add: 'BICYCLIC' ->  'B AY1 S IH0 K L IH0 K';		add: 'LISTEN' -> 'L IH1 S AH0 N';		yourself! !!PhoneticTranscriber class methodsFor: 'examples' stamp: 'len 12/14/1999 03:29'!spanish	"Answer a spanish phonetic transcriber."	^ self new rules: PhoneticRule spanish; phonemes: PhonemeSet arpabet! !!Phrase commentStamp: '<historical>' prior: 0!My instances are phrases. They can carry a phrase accent ('H-' or 'L-') and a boundary tone ('H%', 'L%', '%H').!!Phrase methodsFor: 'accessing' stamp: 'len 12/12/1999 22:32'!accent	^ accent! !!Phrase methodsFor: 'accessing' stamp: 'len 12/12/1999 22:32'!accent: aString	accent _ aString! !!Phrase methodsFor: 'accessing' stamp: 'len 12/8/1999 17:48'!accept: anObject	anObject phrase: self! !!Phrase methodsFor: 'accessing' stamp: 'len 12/8/1999 17:53'!events	| answer |	answer _ CompositeEvent new.	self words do: [ :each | answer addAll: each events].	^ answer! !!Phrase methodsFor: 'accessing' stamp: 'len 12/8/1999 18:51'!lastSyllable	^ self words last lastSyllable! !!Phrase methodsFor: 'accessing' stamp: 'len 12/12/1999 22:22'!string	^ string! !!Phrase methodsFor: 'accessing' stamp: 'len 12/12/1999 22:22'!string: aString	string _ aString! !!Phrase methodsFor: 'accessing' stamp: 'len 12/8/1999 17:47'!words	^ words! !!Phrase methodsFor: 'accessing' stamp: 'len 12/8/1999 17:48'!words: aCollection	words _ aCollection! !!Phrase methodsFor: 'enumarating' stamp: 'len 12/13/1999 01:19'!eventsDo: aBlock	self words do: [ :word | word eventsDo: aBlock]! !!Phrase methodsFor: 'enumarating' stamp: 'len 12/13/1999 02:37'!syllablesDo: aBlock	self words do: [ :each | each syllables do: aBlock]! !!Phrase methodsFor: 'printing' stamp: 'len 12/8/1999 18:17'!printOn: aStream	self words do: [ :each | aStream print: each; space]! !!QueueSound methodsFor: 'initialization' stamp: 'len 9/26/1999 17:19'!initialize	super initialize.	sounds _ SharedQueue new.	done _ false.	startTime _ Time millisecondClockValue! !!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 21:52'!add: aSound	self sounds nextPut: aSound.	^ aSound! !!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 22:06'!currentSound	currentSound isNil ifTrue: [currentSound _ self nextSound].	^ currentSound! !!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 22:07'!currentSound: aSound	currentSound _ aSound! !!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 22:07'!done: aBoolean	done _ aBoolean! !!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 21:46'!sounds	^ sounds! !!QueueSound methodsFor: 'accessing' stamp: 'len 9/26/1999 17:19'!startTime	^ startTime! !!QueueSound methodsFor: 'accessing' stamp: 'len 9/26/1999 17:19'!startTime: anInteger	startTime _ anInteger! !!QueueSound methodsFor: 'sound generation' stamp: 'len 8/29/1999 22:07'!doControl	super doControl.	self currentSound notNil ifTrue: [self currentSound doControl]! !!QueueSound methodsFor: 'sound generation' stamp: 'len 9/26/1999 17:29'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	| finalIndex i remaining count rate |	self currentSound isNil ifTrue: [^ self].  "already done"	self startTime > Time millisecondClockValue ifTrue: [^ self].	rate _ self samplingRate.	finalIndex _ (startIndex + n) - 1.	i _ startIndex.	[i <= finalIndex] whileTrue: [		[self currentSound isNil ifTrue: [^ self].		(remaining _ self currentSound samplesRemaining) <= 0]			whileTrue: [self currentSound: self nextSound].		count _ (finalIndex - i) + 1.		remaining < count ifTrue: [count _ remaining].		self currentSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i _ i + count]! !!QueueSound methodsFor: 'sound generation' stamp: 'len 11/30/1999 04:13'!nextSound	| answer |	sounds isEmpty ifTrue: [^ nil].	answer _ sounds next.	answer reset.	^ answer! !!QueueSound methodsFor: 'sound generation' stamp: 'len 9/13/1999 00:26'!reset	super reset.	self currentSound notNil		ifTrue: [self currentSound reset]		ifFalse: [self currentSound: self nextSound]! !!QueueSound methodsFor: 'sound generation' stamp: 'len 8/29/1999 22:13'!samplesRemaining	(done and: [self sounds isEmpty])		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !!Speaker methodsFor: 'initialization' stamp: 'len 12/14/1999 03:19'!initialize	self pitch: 100.0; range: 0.3; loudness: 1.0; speed: 0.6; "normalizer: TextNormalizer new;" transcriber: PhoneticTranscriber default; voice: KlattVoice new; visitors: {IntonationVisitor default. DurationsVisitor default. F0RenderingVisitor default}! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:33'!loudness	^ loudness! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:33'!loudness: aNumber	loudness _ aNumber! !!Speaker methodsFor: 'accessing' stamp: 'len 12/13/1999 03:02'!phonemes	"Answer the phoneme set of the receiver."	^ self transcriber phonemes! !!Speaker methodsFor: 'accessing' stamp: 'len 12/12/1999 23:18'!pitch	"Answer the average pitch."	^ pitch! !!Speaker methodsFor: 'accessing' stamp: 'len 12/12/1999 23:18'!pitch: aNumber	"Set the average pitch."	pitch _ aNumber! !!Speaker methodsFor: 'accessing' stamp: 'len 12/12/1999 23:18'!range	"Answer the pitch range (variation)."	^ range! !!Speaker methodsFor: 'accessing' stamp: 'len 12/13/1999 01:14'!range: aNumber	"Set the pitch range (variation)."	range _ aNumber! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:33'!speed	^ speed! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:33'!speed: aNumber	speed _ aNumber! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:31'!transcriber	^ transcriber! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:31'!transcriber: aPhoneticTranscriber	transcriber _ aPhoneticTranscriber! !!Speaker methodsFor: 'accessing' stamp: 'len 12/12/1999 23:02'!visitors	^ visitors! !!Speaker methodsFor: 'accessing' stamp: 'len 12/12/1999 23:02'!visitors: aCollection	visitors _ aCollection! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:32'!voice	^ voice! !!Speaker methodsFor: 'accessing' stamp: 'len 12/8/1999 16:32'!voice: aVoice	voice _ aVoice! !!Speaker methodsFor: 'parsing' stamp: 'len 12/14/1999 02:13'!clauseFromString: aString	^ Clause new		string: aString;		phrases: ((aString findTokens: '!!?.,;()') collect: [ :each | self phraseFromString: each])! !!Speaker methodsFor: 'parsing' stamp: 'len 12/22/1999 03:46'!eventsFromString: aString	| clause |	clause _ self clauseFromString: aString.	clause phrases do: [ :each | each lastSyllable events add: (PhoneticEvent new phoneme: self phonemes silence; duration: 0.1)].	clause lastSyllable events last duration: 0.5.	visitors do: [ :each | each speaker: self. clause accept: each].	clause eventsDo: [ :each | each loudness: self loudness].	^ clause events! !!Speaker methodsFor: 'parsing' stamp: 'len 12/13/1999 03:19'!phraseFromString: aString	^ Phrase new		string: aString;		words: ((aString findTokens: ' !!?.,;()') collect: [ :each | self wordFromString: each])! !!Speaker methodsFor: 'parsing' stamp: 'len 12/8/1999 17:08'!syllabizationOf: phonemes	| syllable stream last answer |	answer _ OrderedCollection new.	syllable _ Syllable new phonemes: (OrderedCollection new: 4).	stream _ ReadStream on: phonemes.	[stream atEnd]		whileFalse: [syllable phonemes add: (last _ stream next).					(stream atEnd not and: [last isConsonant not and: [stream peek isConsonant]])						ifTrue: [answer add: syllable. syllable _ Syllable new phonemes: (OrderedCollection new: 4)]].	syllable phonemes isEmpty ifFalse: [answer add: syllable].	^ answer! !!Speaker methodsFor: 'parsing' stamp: 'len 12/8/1999 18:24'!wordFromString: aString	^ Word new		string: aString;		syllables: (self syllabizationOf: (self transcriber transcriptionOf: aString))! !!Speaker methodsFor: 'playing' stamp: 'len 12/22/1999 03:41'!say: aString	| events stream string |	events _ CompositeEvent new.	stream _ ReadStream on: (aString findTokens: '?' keep: '?').	[stream atEnd]		whileFalse: [string _ stream next.					stream atEnd ifFalse: [string _ string, stream next].					events addAll: (self eventsFromString: string)].	events playOn: self voice delayed: events duration * 1000.	self voice flush! !!Speaker methodsFor: 'editing' stamp: 'len 12/14/1999 05:16'!edit	| answer buttons |	answer _ (self findAVoice: KlattVoice) editor.	buttons _ AlignmentMorph new orientation: #horizontal; color: answer color.	buttons		addMorphFront: (SimpleButtonMorph new target: self; actWhen: #buttonDown; actionSelector:  #newHead; labelString: 'new head');		addMorphFront: (SimpleButtonMorph new target: self; actWhen: #buttonDown; actionSelector:  #saySomething; labelString: 'test').	answer		addSliderForParameter: #speed target: self min: 0.1 max: 2.0 description: 'Speed';		addSliderForParameter: #loudness target: self min: 0.0 max: 1.0 description: 'Loudness';		addSliderForParameter: #range target: self min: 0.0 max: 1.0 description: 'Pitch Range';		addSliderForParameter: #pitch target: self min: 20.0 max: 800.0 description: 'Pitch';		addMorphFront: buttons;		openInWorld! !!Speaker methodsFor: 'editing' stamp: 'len 12/2/1999 03:19'!findAVoice: aClass	(self voice isKindOf: aClass) ifTrue: [^ self voice].	(self voice isKindOf: CompositeVoice)		ifTrue: [self voice do: [ :each | (each isKindOf: aClass) ifTrue: [^ each]]].	^ nil! !!Speaker methodsFor: 'editing' stamp: 'len 12/2/1999 03:27'!makeGestural	(self findAVoice: GesturalVoice) isNil ifFalse: [^ self].	self voice: self voice + GesturalVoice new! !!Speaker methodsFor: 'editing' stamp: 'len 12/2/1999 03:27'!newHead	self makeGestural.	(self findAVoice: GesturalVoice) newHead! !!Speaker methodsFor: 'editing' stamp: 'len 12/14/1999 05:24'!saySomething	self say: #('This is my voice.' 'I am speaking.' 'Do you like my voice?' 'Listen to my voice.' 'Hello.' 'Hay. What are you doing?' 'How are you?' 'Is this my voice?' 'Are you there?' 'Help, please.' 'Howdy.' 'Ha ha he he hi.') atRandom! !!Speaker class methodsFor: 'instance creation' stamp: 'len 12/12/1999 23:06'!new	^ super new initialize! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:17'!bicyclic	"	Speaker bicyclic say: 'This is my voice. I am a woman with bicyclic voice.'	"	^ self new		pitch: 200.0;		voice: (KlattVoice new diplophonia: 0.4; tract: 14.4)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:56'!bigMan	"	Speaker bigMan say: 'I am the child? No. I am the big man speaking.'	"	^ self new		pitch: 90.0;		range: 0.5;		voice: (KlattVoice new tract: 20)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:19'!breathy	"	Speaker breathy say: 'This is my breathy voice.'	"	^ self new		pitch: 100.0;		voice: (KlattVoice new ro: 0.6; turbulence: 70)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 04:07'!child	"	Speaker child say: 'Hello. I am a child speaking.'	"	^ self new		pitch: 320.0;		voice: (KlattVoice new tract: 12)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:21'!creaky	"	Speaker creaky say: 'This is my creaky voice with hight jitter and shimmer.'	"	^ self new		pitch: 90.0;		speed: 0.5;		voice: (KlattVoice new jitter: 0.5; shimmer: 0.5)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:22'!default	"	Speaker default say: 'This is the default voice.'	"	^ self new! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 04:13'!exorsist	"	Speaker exorsist say: 'This is an scary voice. Boo.'	"	^ self new		pitch: 40.0;		speed: 0.5;		voice: (KlattVoice new tract: 10; diplophonia: 0.4; jitter: 0.3; shimmer: 0.5; turbulence: 50)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 04:13'!fly	"	Speaker fly say: 'Haaaaaalp.'	"	^ self new		pitch: 650.0;		loudness: 0.5;		speed: 0.8;		voice: (KlattVoice new flutter: 1.0; tract: 1)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 04:01'!kid	"	Speaker kid say: 'Do you like my voice? I am the kid speaking.'	"	^ self new		pitch: 170.0;		range: 0.4;		voice: (KlattVoice new tract: 16)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 04:02'!man	"	Speaker man say: 'Listen to my voice. I am a man speaking.'	"	^ self new pitch: 90.0! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:26'!notPressed	"	Speaker notPressed say: 'This is a non pressed voice.'	"	^ self new		pitch: 100.0;		voice: (KlattVoice new ro: 0.9)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:26'!pressed	"	Speaker pressed say: 'This is a pressed voice.'	"	^ self new		pitch: 100.0;		voice: (KlattVoice new ro: 0.1)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 03:27'!whispery	"	Speaker whispery say: 'This is my whispery voice.'	"	^ self new		voice: (KlattVoice new breathiness: 1.0)! !!Speaker class methodsFor: 'examples' stamp: 'len 12/14/1999 04:10'!woman	"	Speaker woman say: 'Do you listen? I am a woman speaking.'	"	^ self new		pitch: 230.0;		range: 0.5;		speed: 0.7;		voice: (KlattVoice new flutter: 0.5; ro: 0.3; ra: 0.003; tract: 14.4)! !!Speaker class methodsFor: 'examples-others' stamp: 'len 12/2/1999 03:46'!manWithEditor	"	Speaker manWithEditor say: 'With this editor you can change my voice.'	"	^ self man edit! !!Speaker class methodsFor: 'examples-others' stamp: 'len 12/14/1999 05:10'!manWithHead	"	Speaker manWithHead say: 'This is my voice. Can you see my lips?'	"	^ self man newHead! !!Syllable commentStamp: '<historical>' prior: 0!My instances are syllables. They can carry a pitch accent: 'H*', 'L*', etc.!!Syllable methodsFor: 'accessing' stamp: 'len 12/11/1999 13:03'!accent	^ accent! !!Syllable methodsFor: 'accessing' stamp: 'len 12/11/1999 13:04'!accent: aString	accent _ aString! !!Syllable methodsFor: 'accessing' stamp: 'len 12/8/1999 17:47'!accept: anObject	anObject syllable: self! !!Syllable methodsFor: 'accessing' stamp: 'len 12/13/1999 02:39'!events	^ events ifNil: [events _ CompositeEvent new addAll: (self phonemes collect: [ :each | PhoneticEvent new phoneme: each; duration: 0.080]); yourself]! !!Syllable methodsFor: 'accessing' stamp: 'len 12/8/1999 02:55'!phonemes	^ phonemes! !!Syllable methodsFor: 'accessing' stamp: 'len 12/8/1999 02:55'!phonemes: aCollection	phonemes _ aCollection! !!Syllable methodsFor: 'accessing' stamp: 'len 12/8/1999 02:54'!stress	self phonemes do: [ :each | each stress > 0 ifTrue: [^ each stress]].	^ 0! !!Syllable methodsFor: 'enumarating' stamp: 'len 12/13/1999 01:20'!eventsDo: aBlock	self events do: aBlock! !!Syllable methodsFor: 'testing' stamp: 'len 12/8/1999 19:03'!hasPrimaryStress	^ self stress = 1! !!Syllable methodsFor: 'testing' stamp: 'len 12/8/1999 19:03'!hasSecondaryStress	^ self stress = 2! !!Syllable methodsFor: 'testing' stamp: 'len 12/11/1999 13:11'!isAccented	^ self accent notNil! !!Syllable methodsFor: 'printing' stamp: 'len 12/8/1999 02:57'!printOn: aStream	| first |	aStream nextPut: $[.	first _ true.	self phonemes do: [ :each |		first ifFalse: [aStream space].		aStream print: each.		first _ false].	aStream nextPut: $]! !!UtteranceVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 18:53'!clause: aClause	clause _ aClause.	clause phrases do: [ :each | each accept: self].	phrase _ word _ syllable _ nil! !!UtteranceVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 18:53'!phrase: aPhrase	phrase _ aPhrase.	phrase words do: [ :each | each accept: self].	word _ syllable _ nil! !!UtteranceVisitor methodsFor: 'visiting' stamp: 'len 12/10/1999 02:46'!speaker: aSpeaker	^ self! !!UtteranceVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 16:36'!syllable: aSyllable	syllable _ aSyllable! !!UtteranceVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 18:53'!word: aWord	word _ aWord.	word syllables do: [ :each | each accept: self].	syllable _ nil! !!DurationsVisitor commentStamp: '<historical>' prior: 0!This is an implementation of the Klatt rule system as described in chapter 9 of "From text to speech: The MITalk system", Allen, Hunnicutt and Klatt.!!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:38'!defaultDurationFor: aPhoneme	"Some hardcoded durations for phonemes."	aPhoneme isVoiced ifTrue: [^ 0.0565].	aPhoneme isUnvoiced ifTrue: [^ 0.0751].	aPhoneme isConsonant ifTrue: [^ 0.06508].	aPhoneme isDiphthong ifTrue: [^ 0.1362].	^ 0.0741! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:39'!inherentDurationAt: aPhoneme	^ self inherents at: aPhoneme ifAbsent: [Transcript show: ' default duration for ', aPhoneme name. self defaultDurationFor: aPhoneme]! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:39'!inherents	^ inherents! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:39'!inherents: aDictionary	inherents _ aDictionary! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:39'!lowerDurationAt: aPhoneme	^ self lowers at: aPhoneme ifAbsent: [self inherentDurationAt: aPhoneme]! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:39'!lowers	^ lowers! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 16:39'!lowers: aDictionary	lowers _ aDictionary! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 18:28'!speed	^ speed! !!DurationsVisitor methodsFor: 'accessing' stamp: 'len 12/8/1999 18:28'!speed: aNumber	speed _ aNumber! !!DurationsVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 04:22'!clause: aClause	| min |	super clause: aClause.	self rule2.	clause wordsDo: [ :eachWord |		eachWord events do: [ :each |			min _ self lowerDurationAt: each phoneme.			eachWord isAccented ifFalse: [min _ min / 2.0].			each duration: each duration + min / 1.4 / self speed]].	clause syllablesDo: [ :each | each events recomputeTimes]! !!DurationsVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 17:04'!phrase: aPhrase	super phrase: aPhrase.	self rule3; rule3b! !!DurationsVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 18:27'!speaker: aSpeaker	self speed: aSpeaker speed! !!DurationsVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 17:05'!syllable: aSyllable	super syllable: aSyllable.	syllable events do: [ :each | each duration: (self inherentDurationAt: each phoneme) - (self lowerDurationAt: each phoneme)].	self rule4; rule5; rule9a; rule9b; rule10! !!DurationsVisitor methodsFor: 'visiting' stamp: 'len 12/8/1999 17:06'!word: aWord	super word: aWord.	self rule6; rule7; rule8! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:55'!rule10	"Rule 10: Shortening in clusters."	| current next previous stream |	phrase lastSyllable == syllable ifTrue: [^ self].	stream _ ReadStream on: syllable events.	current _ nil.	next _ stream next.	[stream atEnd]		whileFalse: [previous _ current.					current _ next.					next _ stream next.					current phoneme isVowel						ifTrue: [next phoneme isVowel									ifTrue: [current stretch: 1.2]									ifFalse: [(previous notNil and: [previous phoneme isVowel])												ifTrue: [current stretch: 0.7]]]						ifFalse: [next phoneme isConsonant									ifTrue: [(previous notNil and: [previous phoneme isConsonant])												ifTrue: [current stretch: 0.5]												ifFalse: [current stretch: 0.7]]									ifFalse: [(previous notNil and: [previous phoneme isConsonant])												ifTrue: [current stretch: 0.5]]]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:53'!rule2	"Rule 2: Clause Final Lengthening."	clause lastSyllable events stretch: 1.4! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/13/1999 02:36'!rule3	"Rule 3: Non-phrase-final shortening.	Syllabic segments are shortened by 60 if not in a phrase-final syllable."	phrase syllablesDo: [ :each |		phrase lastSyllable == each			ifFalse: [each events do: [ :event | event phoneme isSyllabic ifTrue: [event stretch: 0.6]]]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:53'!rule3b	"A phrase-final postvocalic liquid or nasal is lengthened by 140"	phrase lastSyllable events do: [ :each | (each phoneme isNasal or: [each phoneme isLiquid]) ifTrue: [each stretch: 1.4]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:56'!rule4	"Rule 4: Non-word-final shortening.	Syllabic segments are shortened by 85 if not in a word-final syllable."	word lastSyllable == syllable ifTrue: [^ self].	syllable events do: [ :each | each phoneme isSyllabic ifTrue: [each stretch: 0.85]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:56'!rule5	"Rule 5: Polysyllabic Shortening.	Syllabic segments in a polysyllabic word are shortened by 80."	word isPolysyllabic ifFalse: [^ self].	syllable events do: [ :each | each phoneme isSyllabic ifTrue: [each stretch: 0.8]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:59'!rule6	"Rule 6: Non-initial-consonant shortening."	| nonInitial |	nonInitial _ false.	word events do: [ :each |		(nonInitial and: [each phoneme isConsonant]) ifTrue: [each stretch: 0.85].		nonInitial _ true]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:59'!rule7	"Rule 7: Unstressed shortening."	word syllables		do: [ :each |			each stress > 0				ifFalse: [each events do: [ :event | event phoneme isSyllabic ifTrue: [event stretch: 0.5]].						each events first phoneme isSyllabic ifTrue: [each events first stretch: 0.7 / 0.5].						(each events last phoneme isSyllabic and: [each events size > 1]) ifTrue: [each events last stretch: 0.7 / 0.5]]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/13/1999 02:33'!rule8	"Rule 8: Lengthening for emphasis."	word isAccented		ifTrue: [word events do: [ :each | each phoneme isVowel ifTrue: [each stretch: 1.4]]]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:57'!rule9a	"Rule 9a: Postvocalic context of vowels."	| events current next nextnext |	phrase lastSyllable == syllable ifTrue: [^ self].	events _ syllable events.	1 to: events size do: [ :i |		current _ events at: i.		next _ i + 1 <= events size ifTrue: [(events at: i + 1) phoneme].		nextnext _ i + 2 <= events size ifTrue: [(events at: i + 2) phoneme].		current stretch: (self rule9a: current phoneme next: next nextnext: nextnext)]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 17:00'!rule9a: current next: next nextnext: nextnext	"Rule 9a: Postvocalic context of vowels."	current isVowel		ifTrue: [next isNil ifTrue: [^ 1.2].				nextnext isNil ifTrue: [^ self subRule9a: next].				(next isSonorant and: [nextnext isObstruent]) ifTrue: [^ self subRule9a: nextnext]]		ifFalse: [current isSonorant					ifTrue: [next isNil ifTrue: [^ 1.2].							next isObstruent ifTrue: [^ self subRule9a: next]]].	^ 1.0! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 16:58'!rule9b	"Rule 9b: Postvocalic context of vowels."	| events current next nextnext |	phrase lastSyllable == syllable ifFalse: [^ self].	events _ syllable events.	1 to: events size do: [ :i |		current _ events at: i.		next _ i + 1 <= events size ifTrue: [(events at: i + 1) phoneme].		nextnext _ i + 2 <= events size ifTrue: [(events at: i + 2) phoneme].		current stretch: 0.3 * (self rule9a: current phoneme next: next nextnext: nextnext) + 0.7]! !!DurationsVisitor methodsFor: 'rules' stamp: 'len 12/8/1999 17:01'!subRule9a: aPhoneme	"Sub-rule 9a, independent of segment position."	aPhoneme isVoiced ifFalse: [^ aPhoneme isStop ifTrue: [0.7] ifFalse: [1.0]].	aPhoneme isFricative ifTrue: [^ 1.6].	aPhoneme isStop ifTrue: [^ 1.2].	aPhoneme isNasal ifTrue: [^ 0.85].	^ 1.0! !!DurationsVisitor class methodsFor: 'instance creation' stamp: 'len 12/8/1999 16:40'!inherents: aDictionary lowers: anotherDictionary	^ self new inherents: aDictionary; lowers: anotherDictionary! !!DurationsVisitor class methodsFor: 'examples' stamp: 'len 12/8/1999 16:40'!default	| phonemes inherents lowers |	phonemes _ PhonemeSet arpabet.	inherents _ Dictionary new.	lowers _ Dictionary new.	#(	('ae'	230.0	80.0)	('aa'	240.0	100.0)	('ax'	120.0	60.0)	('er'	180.0	80.0)	('ay'	250.0	150.0)	('aw'	240.0	100.0)	('b'		85.0		60.0)	('ch'	70.0		50.0)	('d'		75.0		50.0)	('dh'	50.0		30.0)	('eh'	150.0	70.0)	('ea'	270.0	130.0)	('ey'	180.0	100.0)	('f'		100.0	80.0)	('g'		80.0		60.0)	('hh'	80.0		20.0)	('ih'	135.0	40.0)	('ia'	230.0	100.0)	('iy'	155.0	55.0)	('jh'	70.0		50.0)	('k'		80.0		60.0)	('l'		80.0		40.0)	('m'		70.0		60.0)	('n'		60.0		50.0)	('ng'	95.0		60.0)"	('oh'	240.0	130.0)"	('oy'	280.0	150.0)	('ao'	240.0	130.0)	('ow'	220.0	80.0)	('p'		90.0		50.0)	('r'		80.0		30.0)	('s'		105.0	60.0)	('sh'	105.0	80.0)	('t'		75.0		50.0)	('th'	90.0		60.0)	('uh'	210.0	70.0)	('ua'	230.0	110.0)	('ah'	160.0	60.0)	('uw'	230.0	150.0)	('v'		60.0		40.0)	('w'		80.0		60.0)	('y'		80.0		40.0)	('z'		75.0		40.0)	('zh'	70.0		40.0)	('sil'	100.0	100.0)) do: [ :each |		inherents at: (phonemes at: each first) put: each second / 1000.0.		lowers at: (phonemes at: each first) put: each last / 1000.0].	^ self inherents: inherents lowers: lowers! !!F0RenderingVisitor methodsFor: 'accessing' stamp: 'len 12/13/1999 03:47'!highPitch	^ pitch + (pitch * range)! !!F0RenderingVisitor methodsFor: 'accessing' stamp: 'len 12/13/1999 03:47'!lowPitch	^ pitch - (pitch * range)! !!F0RenderingVisitor methodsFor: 'accessing' stamp: 'len 12/13/1999 01:21'!timeForEvent: aVoiceEvent	| time |	time _ 0.	clause eventsDo: [ :each | aVoiceEvent == each ifTrue: [^ time] ifFalse: [time _ time + each duration]]! !!F0RenderingVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 03:32'!clause: aClause	contour _ VoiceParameter new at: 0 put: pitch; yourself.	super clause: aClause.	self renderPhraseAccentOrBoundaryTone: clause accent.	self assignF0ToEvents! !!F0RenderingVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 02:31'!phrase: aPhrase	super phrase: aPhrase.	self renderPhraseAccentOrBoundaryTone: phrase accent! !!F0RenderingVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 02:41'!renderPhraseAccentOrBoundaryTone: aStringOrNil	aStringOrNil isNil ifTrue: [^ self].	(aStringOrNil findTokens: ' ') do: [ :each |		each = 'H-' ifTrue: [self renderHighPhraseAccent].		each = 'L-' ifTrue: [self renderLowPhraseAccent].		each = 'H%' ifTrue: [self renderHighBoundary].		each = 'L%' ifTrue: [self renderLowBoundary].		each = '%H' ifTrue: [self renderHighInitial].		each = '%r' ifTrue: [self notYetImplemented]]! !!F0RenderingVisitor methodsFor: 'visiting' stamp: 'len 12/13/1999 02:42'!speaker: aSpeaker	pitch _ aSpeaker pitch.	range _ aSpeaker range! !!F0RenderingVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 02:41'!syllable: aSyllable	super syllable: aSyllable.	aSyllable isAccented ifFalse: [^ self].	aSyllable accent = 'H*' ifTrue: [^ self renderPeakAccent].	aSyllable accent = 'L*' ifTrue: [^ self renderLowAccent].	aSyllable accent = 'L*+H' ifTrue: [^ self renderScoopedAccent].	aSyllable accent = 'L+H*' ifTrue: [^ self renderRisingPeakAccent]! !!F0RenderingVisitor methodsFor: 'rendering-pitch accents' stamp: 'len 12/14/1999 05:47'!renderLowAccent	"Render a L* accent."	| start stop peakPosition |	start _ self syllableStartTime.	stop _ self syllableStopTime.	peakPosition _ (syllable events detect: [ :one | one phoneme isSyllabic] ifNone: [syllable events first]) duration / 2.0.	self time: start		startingF0: (contour at: start)		amplitude: (contour at: start) - self lowPitch		duration: stop - start		peakPosition: peakPosition		tilt: 0.0! !!F0RenderingVisitor methodsFor: 'rendering-pitch accents' stamp: 'len 12/14/1999 05:47'!renderPeakAccent	"Render a H* accent."	| start stop peakPosition |	start _ self syllableStartTime.	stop _ self syllableStopTime.	peakPosition _ (syllable events detect: [ :one | one phoneme isSyllabic] ifNone: [syllable events first]) duration / 2.0.	self time: start		startingF0: (contour at: start)		amplitude: self highPitch - (contour at: start)		duration: stop - start		peakPosition: peakPosition		tilt: 0.0! !!F0RenderingVisitor methodsFor: 'rendering-pitch accents' stamp: 'len 12/14/1999 01:44'!renderRisingPeakAccent	"Render a L+H* accent."	self notYetImplemented! !!F0RenderingVisitor methodsFor: 'rendering-pitch accents' stamp: 'len 12/14/1999 01:45'!renderScoopedAccent	"Render a L*+H accent."	self notYetImplemented! !!F0RenderingVisitor methodsFor: 'rendering-pitch accents' stamp: 'len 12/14/1999 01:43'!syllableStartTime	^ self timeForEvent: syllable events first! !!F0RenderingVisitor methodsFor: 'rendering-pitch accents' stamp: 'len 12/14/1999 01:43'!syllableStopTime	^ self syllableStartTime + syllable events duration! !!F0RenderingVisitor methodsFor: 'rendering-phrase accents' stamp: 'len 12/14/1999 03:45'!phraseAccentStartTime	| syl |	syl _ nil.	(phrase ifNil: [clause phrases last]) syllablesDo: [ :each | (syl isNil or: [syl isAccented]) ifTrue: [syl _ each]].	^ self timeForEvent: syl events last! !!F0RenderingVisitor methodsFor: 'rendering-phrase accents' stamp: 'len 12/14/1999 01:17'!phraseAccentStopTime	| lastEvent |	lastEvent _ (phrase ifNil: [clause phrases last]) lastSyllable events last.	^ (self timeForEvent: lastEvent) + lastEvent duration! !!F0RenderingVisitor methodsFor: 'rendering-phrase accents' stamp: 'len 12/14/1999 01:23'!renderHighPhraseAccent	"Render a H- accent."	| start stop |	start _ self phraseAccentStartTime.	stop _ self phraseAccentStopTime.	self time: start		startingF0: (contour at: start)		amplitude: self highPitch - (contour at: start)		duration: stop - start		peakPosition: stop - start		tilt: 1.0! !!F0RenderingVisitor methodsFor: 'rendering-phrase accents' stamp: 'len 12/14/1999 03:48'!renderLowPhraseAccent	"Render a L- accent."	| start stop |	start _ self phraseAccentStartTime.	stop _ self phraseAccentStopTime.	self time: start		startingF0: (contour at: start)		amplitude: (contour at: start) - self lowPitch		duration: stop - start		peakPosition: stop - start		tilt: -0.5! !!F0RenderingVisitor methodsFor: 'rendering-boundary tones' stamp: 'len 12/14/1999 02:27'!boundaryStartTime	^ self timeForEvent: (phrase ifNil: [clause phrases last]) words last events first! !!F0RenderingVisitor methodsFor: 'rendering-boundary tones' stamp: 'len 12/14/1999 02:27'!boundaryStopTime	| lastEvent |	lastEvent _ (phrase ifNil: [clause phrases last]) lastSyllable events last.	^ (self timeForEvent: lastEvent) + lastEvent duration! !!F0RenderingVisitor methodsFor: 'rendering-boundary tones' stamp: 'len 12/14/1999 01:38'!initialStopTime	| lastEvent |	lastEvent _ 	clause phrases first words first lastSyllable events last.	^ (self timeForEvent: lastEvent) + lastEvent duration! !!F0RenderingVisitor methodsFor: 'rendering-boundary tones' stamp: 'len 12/14/1999 01:34'!renderHighBoundary	"Render a H% boundary tone."	| start stop |	start _ self boundaryStartTime.	stop _ self boundaryStopTime.	self time: start		startingF0: (contour at: start)		amplitude: self highPitch - (contour at: start)		duration: stop - start		peakPosition: stop - start		tilt: 1.0! !!F0RenderingVisitor methodsFor: 'rendering-boundary tones' stamp: 'len 12/14/1999 03:07'!renderHighInitial	"Render a %H tone."	| start stop |	start _ 0.	stop _ self initialStopTime.	self time: start		startingF0: (contour at: start)		amplitude: self highPitch - (contour at: start) * 2		duration: stop - start		peakPosition: start		tilt: 0.0! !!F0RenderingVisitor methodsFor: 'rendering-boundary tones' stamp: 'len 12/14/1999 03:44'!renderLowBoundary	"Render a L% boundary tone."	| start stop |	start _ self boundaryStartTime.	stop _ self boundaryStopTime.	self time: start		startingF0: (contour at: start)		amplitude: (contour at: start) - self lowPitch		duration: stop - start		peakPosition: stop - start		tilt: -1.0! !!F0RenderingVisitor methodsFor: 'private' stamp: 'len 12/14/1999 00:48'!assignF0ToEvents	| time |	time _ 0.	clause events do: [ :each |		each pitchPoints: (self pitchesBetween: time and: time + each duration).		time _ time + each duration]! !!F0RenderingVisitor methodsFor: 'private' stamp: 'len 12/13/1999 02:55'!pitchesBetween: t1 and: t2	| step |	step _ (t2 - t1 / 0.035) asInteger + 1. "step small enough"	^ (t1 to: t2 by: t2 - t1 / step) collect: [ :each | each - t1 @ (contour at: each)]! !!F0RenderingVisitor methodsFor: 'private' stamp: 'len 12/14/1999 03:47'!time: time startingF0: startingF0 amplitude: amplitude duration: duration peakPosition: peakPosition tilt: tilt	| vowelStart riseAmplitude fallAmplitude |	vowelStart _ self timeOfFirstVowelAfter: time.	riseAmplitude _ tilt + 1.0 * amplitude / 2.0.	fallAmplitude _ amplitude - riseAmplitude.	contour		x: time y: startingF0;		x: vowelStart + peakPosition y: ((startingF0 + riseAmplitude max: self lowPitch) min: self highPitch);		x: time + duration y: ((startingF0 + riseAmplitude - fallAmplitude max: self lowPitch) min: self highPitch);		commit! !!F0RenderingVisitor methodsFor: 'private' stamp: 'len 12/14/1999 01:47'!timeOfFirstVowelAfter: time	| currentTime |	currentTime _ 0.	clause events do: [ :each |		(currentTime >= time and: [each phoneme isSyllabic]) ifTrue: [^ currentTime].		currentTime _ currentTime + each duration].	^ time "if not found, answer the time itself"! !!F0RenderingVisitor class methodsFor: 'examples' stamp: 'len 12/13/1999 02:25'!default	^ self new! !!IntonationVisitor methodsFor: 'accessing' stamp: 'len 12/10/1999 02:45'!functionWords	^ functionWords! !!IntonationVisitor methodsFor: 'accessing' stamp: 'len 12/10/1999 02:45'!functionWords: aCollection	functionWords _ aCollection! !!IntonationVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 02:52'!clause: aClause	super clause: aClause.	self isYesNoQuestionClause ifTrue: [^ clause accent: 'L- H%'].	self isWHQuestionClause ifTrue: [^ clause accent: '%H H- L%'].	clause accent: 'L- L%' "it's a declarative phrase"! !!IntonationVisitor methodsFor: 'visiting' stamp: 'len 12/12/1999 22:44'!isQuestionClause	^ clause string includes: $?! !!IntonationVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 00:07'!isWHQuestionClause	| firstWordString |	self isQuestionClause ifFalse: [^ false].	firstWordString _ clause phrases first words first string asLowercase.	^ (firstWordString beginsWith: 'wh') or: [firstWordString = 'how']! !!IntonationVisitor methodsFor: 'visiting' stamp: 'len 12/12/1999 22:45'!isYesNoQuestionClause	^ self isQuestionClause and: [self isWHQuestionClause not]! !!IntonationVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 03:16'!phrase: aPhrase	super phrase: aPhrase."	phrase == clause phrases last ifFalse: [phrase accent: 'L- H%']"! !!IntonationVisitor methodsFor: 'visiting' stamp: 'len 12/14/1999 03:12'!word: aWord	| accent |	super word: aWord.	((self functionWords includes: word string asLowercase) and: [phrase words first ~~ word]) ifTrue: [^ self].	self isYesNoQuestionClause ifTrue: [accent _ 'L*'] ifFalse: [accent _ 'H*'].	(word syllables detect: [ :one | one stress > 0] ifNone: [word syllables first]) accent: accent! !!IntonationVisitor class methodsFor: 'examples' stamp: 'len 12/13/1999 02:25'!default	^ self english! !!IntonationVisitor class methodsFor: 'examples' stamp: 'len 12/10/1999 02:41'!english	^ self new functionWords: self englishFunctionWords! !!IntonationVisitor class methodsFor: 'examples' stamp: 'len 12/10/1999 02:41'!englishFunctionWords	^ #('a' 'about' 'above' 'across' 'after' 'ago' 'all' 'along' 'although' 'am' 'among'		'an' 'and' 'any' 'apart' 'are' 'aren''t' 'around' 'as' 'aside' 'at' 'away'		'back' 'be' 'because' 'been' 'before' 'behind' 'below' 'between' 'both'		'but' 'by' 'can' 'can''t' 'could' 'couldn''t' 'down' 'each' 'either' 'every'		'few' 'for' 'forever' 'forward' 'fro' 'from' 'has' 'hasn''t' 'have' 'haven''t'		'he' 'her' 'here' 'him' 'his' 'home' 'how' 'however' 'i' 'if' 'immediately'		'in' 'inside' 'is' 'it' 'its' 'least' 'less' 'like' 'little' 'many' 'more' 'most' 'much'		'my' 'neither' 'no' 'none' 'nor' 'not' 'now' 'of' 'off' 'on' 'once' 'only' 'or'		'our' 'out' 'outside' 'over' 'part' 'plenty' 'right' 'round' 'several' 'she'		'should' 'shouldn''t' 'since' 'so' 'some' 'than' 'that' 'the' 'their' 'theirs'		'then' 'there' 'these' 'they' 'this' 'those' 'though' 'through' 'till' 'to' 'together'		'unless' 'until' 'up' 'upon' 'was' 'wasn''t' 'we' 'were' 'weren''t' 'what'		'whatever' 'when' 'where' 'whereas' 'whether' 'which' 'while' 'who' 'whom'		'whose' 'why' 'will' 'with' 'without' 'would' 'wouldn''t' 'yet' 'you' 'your' 'yours'	) asSet! !!Voice commentStamp: '<historical>' prior: 0!I am an abstract class for speaking voices that know how to play VoiceEvents.!!Voice methodsFor: 'initialization' stamp: 'len 9/26/1999 17:20'!initialize	name _ 'anonymous'! !!Voice methodsFor: 'accessing' stamp: 'len 6/21/1998 20:07'!name	^ name! !!Voice methodsFor: 'accessing' stamp: 'len 6/21/1998 20:07'!name: aString	name _ aString! !!Voice methodsFor: 'accessing' stamp: 'len 9/15/1999 23:54'!sound	^ sound! !!Voice methodsFor: 'converting' stamp: 'len 9/7/1999 01:26'!+ aVoice	"Answer the composition of the receiver with the argument."	^ CompositeVoice new add: self; add: aVoice; yourself! !!Voice methodsFor: 'playing' stamp: 'len 12/22/1999 03:51'!flush	"Play all the events in the queue."	sound notNil ifTrue: [sound done: true; play. sound _ nil]! !!Voice methodsFor: 'playing' stamp: 'len 12/22/1999 03:29'!playBuffer: buffer at: time	| tail |	tail _ SampledSound samples: buffer samplingRate: self samplingRate.	sound isNil		ifTrue: [sound _ QueueSound new startTime: time - SoundPlayer bufferMSecs.				sound add: tail; play]		ifFalse: [sound add: tail]! !!Voice methodsFor: 'playing' stamp: 'len 8/28/1999 23:04'!playGesturalEvent: event at: time	^ self! !!Voice methodsFor: 'playing' stamp: 'len 8/28/1999 23:05'!playPhoneticEvent: event at: time	^ self! !!Voice methodsFor: 'playing' stamp: 'len 9/14/1999 00:19'!playSilenceMSecs: msecs	Transcript cr; show: 'silence ', msecs printString, 'msecs'.	sound isNil ifTrue: [^ self].	sound add: (RestSound dur: msecs / 1000.0)! !!Voice methodsFor: 'playing' stamp: 'len 12/22/1999 03:51'!reset	"Reset the state of the receiver."	sound notNil ifTrue: [sound done: true. sound _ nil]! !!Voice methodsFor: 'printing' stamp: 'len 8/28/1999 03:04'!printOn: aStream	aStream nextPutAll: self class name; nextPutAll: ' ('; nextPutAll: self name; nextPut: $)! !!CompositeVoice methodsFor: 'initialization' stamp: 'len 8/28/1999 04:00'!initialize	super initialize.	self voices: OrderedCollection new! !!CompositeVoice methodsFor: 'accessing' stamp: 'len 9/13/1999 00:00'!add: aVoice	^ self voices add: aVoice! !!CompositeVoice methodsFor: 'accessing' stamp: 'len 8/28/1999 04:01'!voices	^ voices! !!CompositeVoice methodsFor: 'accessing' stamp: 'len 8/28/1999 04:00'!voices: aCollection	voices _ aCollection! !!CompositeVoice methodsFor: 'enumerating' stamp: 'len 8/29/1999 02:21'!do: aBlock	self voices do: aBlock! !!CompositeVoice methodsFor: 'playing' stamp: 'len 12/22/1999 03:51'!flush	"Play all the events in the queue."	super flush.	self do: [ :each | each flush]! !!CompositeVoice methodsFor: 'playing' stamp: 'len 9/26/1999 17:21'!playGesturalEvent: event at: time	self do: [ :each | each playGesturalEvent: event at: time]! !!CompositeVoice methodsFor: 'playing' stamp: 'len 9/26/1999 17:21'!playPhoneticEvent: event at: time	self do: [ :each | each playPhoneticEvent: event at: time]! !!CompositeVoice methodsFor: 'playing' stamp: 'len 9/26/1999 17:22'!reset	"Reset the state of the receiver."	super reset.	self do: [ :each | each reset]! !!GesturalVoice commentStamp: '<historical>' prior: 0!My instances are speaking voices with a head that acts in response to gestural events.!!GesturalVoice methodsFor: 'accessing' stamp: 'len 8/28/1999 23:07'!face	^ self head face! !!GesturalVoice methodsFor: 'accessing' stamp: 'len 8/28/1999 23:06'!head	^ head! !!GesturalVoice methodsFor: 'accessing' stamp: 'len 9/28/1999 02:16'!head: aHeadMorph	head notNil ifTrue: [aHeadMorph position: head position. head delete].	head _ aHeadMorph! !!GesturalVoice methodsFor: 'accessing' stamp: 'len 8/28/1999 23:06'!lips	^ self face lips! !!GesturalVoice methodsFor: 'accessing' stamp: 'len 9/28/1999 02:16'!newHead	| m |	m _ HeadMorph new.	self head: m.	m openInWorld.	^ m! !!GesturalVoice methodsFor: 'playing' stamp: 'len 9/7/1999 01:41'!playGesturalEvent: event at: time	self head playEvent: event at: time! !!GesturalVoice methodsFor: 'playing' stamp: 'len 9/6/1999 00:46'!playPhoneticEvent: event at: time	(TalkGesturalEvent new phoneme: event phoneme) playOn: self at: time! !!KlattVoice commentStamp: '<historical>' prior: 0!My instances are voices that play PhoneticEvents using a KlattSynthesizer and KlattSegments. There are many controls to change voice personalities, such as vocal tract length, breathiness, jitter, shimmer and glottal pulse shape.!!KlattVoice methodsFor: 'initialization' stamp: 'len 12/6/1999 03:43'!defaultPatternFrame	^ KlattFrame default clone		f0: 133;		flutter: 0; jitter: 0; shimmer: 0; diplophonia: 0;		voicing: 60;		aspiration: 0;		friction: 0;		bypass: 0;		turbulence: 0;		ro: 0.5; rk: 0.25; ra: 0.01;		f1: 500;		b1: 60;		f2: 1500;		b2: 90;		f3: 2800;	b3: 150;		f4: 3250;	b4: 200;		f5: 3700;	b5: 200;		f6: 4990;	b6: 500;		fnz: 270;	bnz: 100;		fnp: 270;	bnp: 100;		b2f: 200;		b3f: 350;		b4f: 500;		b5f: 600;		b6f: 800;		anv: 0;		gain: 61! !!KlattVoice methodsFor: 'initialization' stamp: 'len 12/6/1999 00:00'!initialize	super initialize.	synthesizer _ KlattSynthesizer new cascade: 0.	self segments: KlattSegmentSet arpabet.	self patternFrame: self defaultPatternFrame.	self breathiness: 0.0.	self tract: 17.3. "Set a male vocal tract."	self reset! !!KlattVoice methodsFor: 'accessing-private' stamp: 'len 9/27/1999 01:40'!patternFrame	^ patternFrame! !!KlattVoice methodsFor: 'accessing-private' stamp: 'len 12/2/1999 03:08'!patternFrame: aKlattFrame	patternFrame isNil ifTrue: [patternFrame _ aKlattFrame. ^ self].	patternFrame replaceFrom: 1 to: patternFrame size with: aKlattFrame! !!KlattVoice methodsFor: 'accessing' stamp: 'len 12/6/1999 03:43'!phonemes	^ self segments phonemes! !!KlattVoice methodsFor: 'accessing' stamp: 'len 9/6/1999 01:21'!samplingRate	^ self synthesizer samplingRate! !!KlattVoice methodsFor: 'accessing' stamp: 'len 10/12/1999 00:41'!segments	^ segments! !!KlattVoice methodsFor: 'accessing' stamp: 'len 10/12/1999 00:51'!segments: aKlattSegmentSet	segments _ aKlattSegmentSet! !!KlattVoice methodsFor: 'accessing' stamp: 'len 9/6/1999 01:21'!synthesizer	^ synthesizer! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/30/1999 03:26'!breathiness	^ breathiness! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/30/1999 03:26'!breathiness: aNumber	breathiness _ aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:16'!diplophonia	^ self patternFrame diplophonia! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:16'!diplophonia: aNumber	self patternFrame diplophonia: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:18'!flutter	^ self patternFrame flutter! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:16'!flutter: aNumber	self patternFrame flutter: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:15'!jitter	^ self patternFrame jitter! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:15'!jitter: aNumber	self patternFrame jitter: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:18'!ra	^ self patternFrame ra! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:16'!ra: aNumber	self patternFrame ra: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:18'!rk	^ self patternFrame rk! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:17'!rk: aNumber	self patternFrame rk: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:18'!ro	^ self patternFrame ro! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:16'!ro: aNumber	self patternFrame ro: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:16'!shimmer	^ self patternFrame shimmer! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:15'!shimmer: aNumber	self patternFrame shimmer: aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 12/1/1999 03:37'!tract	^ tract! !!KlattVoice methodsFor: 'personality' stamp: 'len 12/1/1999 03:37'!tract: aNumber	tract _ aNumber! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:18'!turbulence	^ self patternFrame turbulence! !!KlattVoice methodsFor: 'personality' stamp: 'len 11/29/1999 02:18'!turbulence: aNumber	self patternFrame turbulence: aNumber! !!KlattVoice methodsFor: 'editing' stamp: 'len 12/2/1999 02:52'!edit	self editor openInWorld! !!KlattVoice methodsFor: 'editing' stamp: 'len 12/6/1999 02:27'!editor	^ KlattFrameMorph new		frame: self patternFrame edit: #(flutter jitter shimmer diplophonia ro rk ra turbulence gain);		addSliderForParameter: #breathiness target: self min: 0.0 max: 1.0 description: 'Amount of breathiness';		addSliderForParameter: #tract target: self min: 10.0 max: 20.0 description: 'Vocal tract length (average male=17.3, average female=14.4)'! !!KlattVoice methodsFor: 'playing' stamp: 'len 12/22/1999 03:52'!flush	"Play all the events in the queue, and then reset."	| lastEventSegments |	lastEvent isNil		ifFalse: [lastEventSegments _ self segments at: lastEvent phoneme ifAbsent: [self segments silence].				self playEvent: lastEvent segments: lastEventSegments boundary: self segments end at: lastEventTime].	super flush.	self reset! !!KlattVoice methodsFor: 'playing' stamp: 'len 12/22/1999 03:19'!playPhoneticEvent: event at: time	| lastEventSegments boundarySegment |	"Play an event."	lastEvent isNil		ifFalse: [lastEventSegments _ self segments at: lastEvent phoneme ifAbsent: [self segments silence].				boundarySegment _ (self segments at: event phoneme ifAbsent: [self segments silence]) first.				self playEvent: lastEvent segments: lastEventSegments boundary: boundarySegment at: lastEventTime].	lastEvent _ event.	lastEventTime _ time! !!KlattVoice methodsFor: 'playing' stamp: 'len 12/22/1999 03:19'!reset	"Reset the state of the receiver."	super reset.	lastEvent _ lastEventTime _ nil.	current _ right _ left _ self segments end! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 12/6/1999 03:21'!currentFramesCount: n	| answer |	answer _ current left: left right: right speed: n / current duration asFloat pattern: self patternFrame.	answer size > 0 ifTrue: [self patternFrame: answer last].	^ answer! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 9/30/1999 22:34'!dBFromLinear: aNumber	^ aNumber log / 2 log * 6.0 + 87.0! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 12/8/1999 20:56'!durationsForEvent: event segments: segs	| scale |	scale _ event duration / ((segs inject: 0 into: [ :result :each | result + each duration]) * 10 / 1000.0).	^ segs collect: [ :each | (each duration * scale) rounded]! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 12/6/1999 03:48'!formantScale	self flag: #fixThis. "NOTE: this approximation is good only for vocal-tract lengths near 14.4 and 17.3 (and between them)... but it is certainly wrong for lengths such as 10 or 20."	^ (17.3 - self tract) / (17.3 - 14.4) * 0.175 + 1.0! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 9/30/1999 22:34'!linearFromdB: aNumber	^ (2 raisedTo: (aNumber-87/6.0))! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 12/19/1999 04:26'!playEvent: event frames: frames at: time	| frame breathyAspiration formantScale |	breathyAspiration _ self dBFromLinear: (self linearFromdB: 68) * self breathiness.	formantScale _ self formantScale.	1 to: frames size do: [ :each |		frame _ frames at: each.		frame gain: (self dBFromLinear: (self linearFromdB: frame gain) * event loudness).		frame f0: (event pitchAt: each - 1 * event duration / frames size).		frame voicing: (self dBFromLinear: (self linearFromdB: frame voicing) * (1.0 - self breathiness)).		frame aspiration: (frame aspiration max: breathyAspiration).		frame			f1: frame f1 * formantScale;			f2: frame f2 * formantScale;			f3: frame f3 * formantScale;			f4: frame f4 * formantScale;			f5: frame f5 * formantScale;			f6: frame f6 * formantScale].	"Transcript cr; show: (event duration * 1000 / frames size) printString."	synthesizer millisecondsPerFrame: event duration * 1000 / frames size.	self playBuffer: (synthesizer samplesFromFrames: frames) at: time! !!KlattVoice methodsFor: 'playing-private' stamp: 'len 12/22/1999 03:44'!playEvent: event segments: segs boundary: boundarySegment at: time	| frames stream dur durations |	frames _ OrderedCollection new.	stream _ ReadStream on: segs.	durations _ ReadStream on: (self durationsForEvent: event segments: segs).	[stream atEnd]		whileFalse: [current _ stream next.					dur _ durations next.					dur > 0						ifTrue: [right _ stream atEnd ifTrue: [boundarySegment] ifFalse: [stream peek].								frames addAll: (self currentFramesCount: dur)].					left _ current].	frames isEmpty ifTrue: [^ self].	self playEvent: event frames: frames at: time! !!Voice class methodsFor: 'instance creation' stamp: 'len 9/13/1999 00:58'!default	self voices isEmpty ifTrue: [^ KlattVoice new].	^ self voices detect: [ :one | one name = 'Kurt']		ifNone: [self voices detect: [ :one | one samplingRate >= 16000]					ifNone: [self voices anyOne]]! !!Voice class methodsFor: 'instance creation' stamp: 'len 6/21/1998 19:52'!new	^ super new initialize! !!Voice class methodsFor: 'class initialization' stamp: 'len 6/7/1999 01:33'!initialize	"	Voice initialize	"	Voices _ Set new! !!Voice class methodsFor: 'accessing' stamp: 'len 6/7/1999 01:33'!addVoice: aVoice	^ self voices add: aVoice! !!Voice class methodsFor: 'accessing' stamp: 'len 6/21/1999 00:51'!doesNotUnderstand: aMessage	self voices do: [ :each | each name asLowercase = aMessage selector asString ifTrue: [^ each]].	^ super doesNotUnderstand: aMessage! !!Voice class methodsFor: 'accessing' stamp: 'len 9/14/1999 00:16'!named: aString	^ self voices detect: [ :one | one name = aString]! !!Voice class methodsFor: 'accessing' stamp: 'len 6/7/1999 01:33'!voices	^ Voices! !!KlattVoice class methodsFor: 'instance creation' stamp: 'len 4/12/98 19:51'!new	^ super new initialize! !!VoiceEvent commentStamp: '<historical>' prior: 0!I am an abstract class for all events to be played on speaking Voices, such as PhoneticEvents or GesturalEvents.!!VoiceEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 03:06'!duration	"Answer the duration (in seconds) of the receiver."	^ 0! !!VoiceEvent methodsFor: 'accessing' stamp: 'len 8/29/1999 02:18'!voice	"Answer the default voice for the receiver."	^ Voice default! !!VoiceEvent methodsFor: 'playing' stamp: 'len 8/28/1999 23:11'!play	^ self playOn: self voice! !!VoiceEvent methodsFor: 'playing' stamp: 'len 8/28/1999 23:11'!playAt: time	^ self playOn: self voice at: time! !!VoiceEvent methodsFor: 'playing' stamp: 'len 8/28/1999 23:11'!playOn: aVoice	self playOn: aVoice at: Time millisecondClockValue! !!VoiceEvent methodsFor: 'playing' stamp: 'len 8/28/1999 03:54'!playOn: aVoice at: time	self subclassResponsibility! !!VoiceEvent methodsFor: 'playing' stamp: 'len 9/13/1999 00:46'!playOn: aVoice delayed: delay	self playOn: aVoice at: Time millisecondClockValue + delay! !!VoiceEvent methodsFor: 'testing' stamp: 'len 8/29/1999 21:17'!isGestural	^ false! !!VoiceEvent methodsFor: 'testing' stamp: 'len 8/29/1999 21:17'!isPhonetic	^ false! !!VoiceEvent methodsFor: 'transforming' stamp: 'len 8/29/1999 03:13'!compress: aNumber	self stretch: 1.0 / aNumber! !!VoiceEvent methodsFor: 'transforming' stamp: 'len 8/29/1999 03:13'!stretch: aNumber	^ self! !!CompositeEvent methodsFor: 'initialization' stamp: 'len 8/28/1999 23:15'!initialize: anInteger	timedEvents _ SortedCollection new: anInteger! !!CompositeEvent methodsFor: 'accessing-private' stamp: 'len 8/28/1999 22:54'!timedEvents	^ timedEvents! !!CompositeEvent methodsFor: 'accessing-private' stamp: 'len 8/28/1999 22:54'!timedEvents: aCollection	timedEvents _ aCollection! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 22:57'!add: aVoiceEvent	^ self add: aVoiceEvent at: self lastTime! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 22:57'!add: aVoiceEvent at: time	^ self timedEvents add: time -> aVoiceEvent! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 22:56'!add: aVoiceEvent delayed: time	^ self add: aVoiceEvent at: self lastTime + time! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/29/1999 02:16'!addAll: aCollection	aCollection do: [ :each | self add: each].	^ aCollection! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/29/1999 03:08'!at: anInteger	^ (self timedEvents at: anInteger) value! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 23:18'!duration	"Answer the duration (in seconds) of the receiver."	^ self lastTime / 1000.0! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/29/1999 03:09'!first	^ self at: 1! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/29/1999 03:09'!last	^ self at: self size! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 23:17'!lastTime	| last |	self isEmpty ifTrue: [^ 0].	last _ self timedEvents last.	^ last key + (last value duration * 1000) rounded! !!CompositeEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 23:16'!size	^ self timedEvents size! !!CompositeEvent methodsFor: 'converting' stamp: 'len 9/29/1999 02:52'!asArray		^ (1 to: self size) collect: [ :each | self at: each]! !!CompositeEvent methodsFor: 'converting' stamp: 'len 9/27/1999 22:48'!asPHOString	| stream |	stream _ WriteStream on: String new.	self do: [ :each | stream nextPutAll: each asPHOString; nextPut: Character cr].	^ stream contents! !!CompositeEvent methodsFor: 'copying' stamp: 'len 8/28/1999 23:16'!copy	| answer |	answer _ self class new: self size.	self timedEvents do: [ :each | answer add: each value copy at: each key].	^ answer! !!CompositeEvent methodsFor: 'enumerating' stamp: 'len 12/14/1999 05:49'!detect: aBlock	self detect: aBlock ifNone: [self error: 'event not found']! !!CompositeEvent methodsFor: 'enumerating' stamp: 'len 12/14/1999 05:49'!detect: aBlock ifNone: exceptionBlock	self do: [ :each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!CompositeEvent methodsFor: 'enumerating' stamp: 'len 8/28/1999 23:09'!do: aBlock	self timedEvents do: [ :each | aBlock value: each value]! !!CompositeEvent methodsFor: 'playing' stamp: 'len 12/22/1999 03:32'!playOn: aVoice at: time	self timedEvents do: [ :each | each value playOn: aVoice at: each key + time].	aVoice flush! !!CompositeEvent methodsFor: 'testing' stamp: 'len 8/28/1999 22:56'!isEmpty	^ self timedEvents isEmpty! !!CompositeEvent methodsFor: 'transforming' stamp: 'len 8/29/1999 03:12'!compress: aNumber	self stretch: aNumber reciprocal! !!CompositeEvent methodsFor: 'transforming' stamp: 'len 8/29/1999 03:11'!delay: time	self timedEvents do: [ :each | each key: each key + time]! !!CompositeEvent methodsFor: 'transforming' stamp: 'len 9/29/1999 05:16'!pitchBy: aNumber	self do: [ :each | each pitchBy: aNumber]! !!CompositeEvent methodsFor: 'transforming' stamp: 'len 8/29/1999 03:13'!stretch: aNumber	self do: [ :each | each stretch: aNumber].	self timedEvents do: [ :each | each key: (each key * aNumber) rounded]! !!CompositeEvent methodsFor: 'editing' stamp: 'len 9/28/1999 01:08'!inspect	"Open a OrderedCollectionInspector on the receiver.  Use basicInspect to get a normal (less useful) type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!CompositeEvent methodsFor: 'editing' stamp: 'len 9/28/1999 01:08'!inspectWithLabel: aLabel	"Open a OrderedCollectionInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true withLabel: aLabel! !!CompositeEvent methodsFor: 'private' stamp: 'len 12/13/1999 02:47'!recomputeTimes	| oldTimedEvents |	oldTimedEvents _ timedEvents.	timedEvents _ SortedCollection new: oldTimedEvents size.	oldTimedEvents do: [ :each | self add: each value]! !!CompositeEvent class methodsFor: 'instance creation' stamp: 'len 8/28/1999 23:14'!new	^ self new: 10! !!CompositeEvent class methodsFor: 'instance creation' stamp: 'len 8/28/1999 23:15'!new: anInteger	^ self basicNew initialize: anInteger! !!GesturalEvent methodsFor: 'accessing' stamp: 'len 8/29/1999 02:18'!voice	"Answer the default voice for the reciever."	^ Voice voices detect: [ :one | one class == GesturalVoice] ifNone: [super voice]! !!GesturalEvent methodsFor: 'playing' stamp: 'len 9/6/1999 00:40'!actOn: aHeadMorph	self subclassResponsibility! !!GesturalEvent methodsFor: 'playing' stamp: 'len 8/28/1999 03:53'!playOn: aVoice at: time	aVoice playGesturalEvent: self at: time! !!GesturalEvent methodsFor: 'testing' stamp: 'len 8/29/1999 21:18'!isGestural	^ true! !!GazeGesturalEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 03:17'!point	^ point! !!GazeGesturalEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 03:17'!point: aPoint	point _ aPoint! !!GazeGesturalEvent methodsFor: 'playing' stamp: 'len 9/6/1999 00:42'!actOn: aHeadMorph	aHeadMorph face lookAt: self point! !!GazeGesturalEvent methodsFor: 'printing' stamp: 'len 9/6/1999 00:42'!printOn: aStream	aStream nextPutAll: 'look at '; print: self point! !!MoodGesturalEvent methodsFor: 'accessing' stamp: 'len 9/7/1999 02:22'!state	^ state! !!MoodGesturalEvent methodsFor: 'accessing' stamp: 'len 9/12/1999 05:03'!state: aSymbol	state _ aSymbol asSymbol! !!MoodGesturalEvent methodsFor: 'playing' stamp: 'len 9/7/1999 02:23'!actOn: aHeadMorph	aHeadMorph face perform: self state! !!MoodGesturalEvent methodsFor: 'printing' stamp: 'len 9/7/1999 02:26'!printOn: aStream	aStream nextPutAll: 'set ', self state, ' mood'! !!PhoneticEvent commentStamp: '<historical>' prior: 0!My instances are events for a Voice.!!PhoneticEvent methodsFor: 'accessing-private' stamp: 'len 9/27/1999 23:06'!pitchPoints	^ pitchPoints! !!PhoneticEvent methodsFor: 'accessing-private' stamp: 'len 9/27/1999 23:06'!pitchPoints: p	pitchPoints _ p isNumber		ifTrue: [((0.0 to: duration by: 0.035) collect: [ :time | time @ p])]		ifFalse: [p first isPoint ifTrue: [p] ifFalse: [(p collect: [ :each | each first @ each last])]]! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 9/27/1999 23:06'!averagePitch	| sum previous |	self pitchPoints size = 1 ifTrue: [^ self pitchPoints first y].	sum _ 0.0.	self pitchPoints do: [ :each |		previous isNil ifFalse: [sum _ (each y + previous y) / 2.0 * (each x - previous x) + sum].		previous _ each].	sum _ previous y * (self duration - previous x) + sum.	^ sum / self duration! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 8/28/1999 23:18'!duration	"Answer the duration (in seconds) of the receiver."	^ duration! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 11/30/1999 04:26'!duration: aNumber	"Set the duration of the receiver (in seconds)."	((pitchPoints isNil or: [duration isNil]) or: [duration = 0])		ifFalse: [pitchPoints _ pitchPoints collect: [ :each | each x / duration * aNumber @ each y]].	duration _ aNumber! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 5/28/1999 01:36'!loudness	^ loudness! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 5/28/1999 01:37'!loudness: aNumber	loudness _ aNumber! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 5/28/1999 01:36'!phoneme	^ phoneme! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 5/28/1999 01:35'!phoneme: aPhoneme	phoneme _ aPhoneme! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 9/27/1999 23:03'!pitch: aNumber	self pitchPoints: aNumber! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 9/27/1999 23:04'!pitchAt: time	"Answer the pitch of the receiver at a given time. (Do linear interpolation.)"	| xVal count x1 x2 y1 y2 |	pitchPoints isNil ifTrue: [^ nil].	xVal _ pitchPoints first x.	count _ 1.	[xVal < time]		whileTrue: [count _ count + 1.					count > pitchPoints size ifTrue: [^ pitchPoints last y].					xVal _ (pitchPoints at: count) x].	xVal = time ifTrue: [^ (pitchPoints at: count) y].	count = 1 ifTrue: [^ pitchPoints first y].	x1 _ (pitchPoints at: count - 1) x.	x2 _ (pitchPoints at: count) x.	y1 _ (pitchPoints at: count - 1) y.	y2 _ (pitchPoints at: count) y.	^ (time - x1) / (x2 - x1) * (y2 - y1) + y1! !!PhoneticEvent methodsFor: 'accessing' stamp: 'len 9/27/1999 23:07'!pitchAt: time put: aNumber	"Set the pitch of the receiver at a given time."	pitchPoints isNil ifTrue: [pitchPoints _ Array with: time @ aNumber. ^ self].	pitchPoints _ pitchPoints copyWith: time @ aNumber! !!PhoneticEvent methodsFor: 'playing' stamp: 'len 8/28/1999 03:54'!playOn: aVoice at: time	aVoice playPhoneticEvent: self at: time! !!PhoneticEvent methodsFor: 'converting' stamp: 'len 9/27/1999 23:05'!asPHOString	| stream |	stream _ WriteStream on: String new.	stream		nextPutAll: self phoneme name; space;		print: (self duration * 1000) rounded.	self pitchPoints do: [ :each | stream space; print: (each x * 1000) rounded; space; print: each y rounded].	^ stream contents! !!PhoneticEvent methodsFor: 'copying' stamp: 'len 9/27/1999 23:01'!copy	^ super copy pitchPoints: self pitchPoints copy! !!PhoneticEvent methodsFor: 'testing' stamp: 'len 9/27/1999 23:04'!hasPitch	"Answer true if there is a pitch contour specified for the receiver."	^ pitchPoints notNil! !!PhoneticEvent methodsFor: 'testing' stamp: 'len 8/29/1999 21:17'!isPhonetic	^ true! !!PhoneticEvent methodsFor: 'transforming' stamp: 'len 9/27/1999 23:05'!pitchApply: aBlock	"Apply aBlock to the pitch points in the receiver."	self hasPitch ifFalse: [^ self].	pitchPoints _ pitchPoints collect: aBlock! !!PhoneticEvent methodsFor: 'transforming' stamp: 'len 9/27/1999 23:06'!pitchBy: aNumber	"Multiply the receiver's pitch contour by aNumber."	self hasPitch ifFalse: [^ self].	pitchPoints _ pitchPoints collect: [ :each | each x @ (each y * aNumber)]! !!PhoneticEvent methodsFor: 'transforming' stamp: 'len 6/5/1999 03:26'!stretch: aNumber	self duration: self duration * aNumber! !!PhoneticEvent methodsFor: 'transforming' stamp: 'len 9/27/1999 23:05'!transposeBy: aNumber	"Add the given step to the receiver's pitch."	pitchPoints _ pitchPoints collect: [ :each | each x @ (each y + aNumber)]! !!PhoneticEvent methodsFor: 'printing' stamp: 'len 9/27/1999 23:06'!printOn: aStream	| first |	aStream nextPutAll: '#('; print: phoneme; space; print: loudness; space; print: duration.	self pitchPoints isNil ifTrue: [aStream nextPut: $). ^ self].	aStream nextPutAll: ' #('.	first _ true.	self pitchPoints do: [ :each |		first ifFalse: [aStream space].		aStream print: each x; space; print: each y.		first _ false].	aStream nextPutAll: '))'! !!TalkGesturalEvent methodsFor: 'accessing' stamp: 'len 9/6/1999 00:41'!phoneme	^ phoneme! !!TalkGesturalEvent methodsFor: 'accessing' stamp: 'len 9/6/1999 00:41'!phoneme: aPhoneme	phoneme _ aPhoneme! !!TalkGesturalEvent methodsFor: 'playing' stamp: 'len 9/6/1999 00:44'!actOn: aHeadMorph	aHeadMorph face lips articulate: self phoneme! !!TalkGesturalEvent methodsFor: 'printing' stamp: 'len 9/7/1999 02:27'!printOn: aStream	aStream nextPutAll: 'articulate '; print: self phoneme! !!VoiceParameter methodsFor: 'initialization' stamp: 'len 12/13/1999 02:42'!initialize	points _ SortedCollection new.	stack _ SortedCollection new.	origin _ 0! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 12/14/1999 00:49'!at: time	"Answer the value of the receiver at a given time. (Do linear interpolation.)"	^ self cosineAt: time + self origin! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 11/24/1999 01:59'!at: time put: value	self points add: time + self origin -> value.	^ value! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 12/4/1999 17:30'!commit	self cleanBetween: stack first key and: stack last key.	self points addAll: stack.	stack _ SortedCollection new! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 12/4/1999 17:22'!duration	^ self points last key - self points first key! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 11/24/1999 01:59'!origin	^ origin! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 11/24/1999 01:59'!origin: aNumber	origin _ aNumber! !!VoiceParameter methodsFor: 'accessing' stamp: 'len 12/4/1999 17:20'!x: x y: y	stack add: x + self origin -> y! !!VoiceParameter methodsFor: 'private' stamp: 'len 11/23/1999 01:08'!cleanBetween: start and: end	self points: (self points reject: [ :each | each key between: start and: end])! !!VoiceParameter methodsFor: 'private' stamp: 'len 11/23/1999 00:42'!cosineAt: time	"Answer the value of the receiver at a given time. (Do cosine interpolation.)"	| xVal count x1 x2 y1 y2 |	points isNil ifTrue: [^ nil].	xVal _ points first key.	count _ 1.	[xVal < time]		whileTrue: [count _ count + 1.					count > points size ifTrue: [^ points last value].					xVal _ (points at: count) key].	xVal = time ifTrue: [^ (points at: count) value].	count = 1 ifTrue: [^ points first value].	x1 _ (points at: count - 1) key.	x2 _ (points at: count) key.	y1 _ (points at: count - 1) value.	y2 _ (points at: count) value.	^ ((time - x1 / (x2 - x1) * Float pi) cos - 1 / -2.0) * (y2 - y1) + y1! !!VoiceParameter methodsFor: 'private' stamp: 'len 12/4/1999 15:54'!linearAt: time	"Answer the value of the receiver at a given time. (Do linear interpolation.)"	| xVal count x1 x2 y1 y2 |	points isNil ifTrue: [^ nil].	xVal _ points first key.	count _ 1.	[xVal < time]		whileTrue: [count _ count + 1.					count > points size ifTrue: [^ points last value].					xVal _ (points at: count) key].	xVal = time ifTrue: [^ (points at: count) value].	count = 1 ifTrue: [^ points first value].	x1 _ (points at: count - 1) key.	x2 _ (points at: count) key.	y1 _ (points at: count - 1) value.	y2 _ (points at: count) value.	^ (time - x1) / (x2 - x1) * (y2 - y1) + y1! !!VoiceParameter methodsFor: 'private' stamp: 'len 12/4/1999 17:29'!points	^ points! !!VoiceParameter methodsFor: 'private' stamp: 'len 11/23/1999 00:41'!points: aCollection	points _ aCollection! !!VoiceParameter class methodsFor: 'instance creation' stamp: 'len 12/13/1999 02:15'!fromArray: anArray	| answer |	answer _ self new.	1 to: anArray size by: 2 do: [ :each | answer at: (anArray at: each) put: (anArray at: each + 1)].	^ answer! !!VoiceParameter class methodsFor: 'instance creation' stamp: 'len 12/4/1999 17:29'!new	^ super new initialize! !!Word methodsFor: 'accessing' stamp: 'len 12/8/1999 17:47'!accept: anObject	anObject word: self! !!Word methodsFor: 'accessing' stamp: 'len 12/8/1999 17:53'!events	| answer |	answer _ CompositeEvent new.	self syllables do: [ :each | answer addAll: each events].	^ answer! !!Word methodsFor: 'accessing' stamp: 'len 12/13/1999 02:33'!lastSyllable	^ self syllables last! !!Word methodsFor: 'accessing' stamp: 'len 12/8/1999 17:49'!string	^ string! !!Word methodsFor: 'accessing' stamp: 'len 12/8/1999 17:49'!string: aString	string _ aString! !!Word methodsFor: 'accessing' stamp: 'len 12/8/1999 17:48'!syllables	^ syllables! !!Word methodsFor: 'accessing' stamp: 'len 12/8/1999 17:48'!syllables: aCollection	syllables _ aCollection! !!Word methodsFor: 'enumerating' stamp: 'len 12/13/1999 01:20'!eventsDo: aBlock	self syllables do: [ :syllable | syllable eventsDo: aBlock]! !!Word methodsFor: 'testing' stamp: 'len 12/11/1999 13:11'!isAccented	^ (self syllables detect: [ :one | one isAccented] ifNone: []) notNil! !!Word methodsFor: 'testing' stamp: 'len 12/8/1999 18:47'!isPolysyllabic	^ self syllables size > 1! !!Word methodsFor: 'printing' stamp: 'len 12/13/1999 03:18'!printOn: aStream	aStream nextPutAll: (self isAccented ifTrue: [self string asUppercase] ifFalse: [self string])! !KlattSynthesizer initialize!KlattSynthesizerPlugin initialize!LiljencrantsFant initialize!PhonemeSet initialize!LipsMorph initialize!Voice initialize!