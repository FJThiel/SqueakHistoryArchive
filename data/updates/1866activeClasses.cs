'From Squeak2.8alpha of 12 January 2000 [latest update: #1862] on 17 February 2000 at 10:59:29 pm'!"Change Set:		activeClassesDate:			17 February 2000Author:			Dan IngallsNumerous small changes to restore operation of ImageSegment>>discoverActiveClasses."!!Behavior methodsFor: 'copying' stamp: 'di 2/17/2000 22:37'!copy	"Answer a copy of the receiver without a list of subclasses."	| myCopy |	myCopy _ self shallowCopy.	^myCopy methodDictionary: self methodDict copy! !!Behavior methodsFor: 'copying' stamp: 'di 2/17/2000 22:37'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ self methodDict copy! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 2/17/2000 22:41'!addSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary."	| oldMethod |	oldMethod _ self lookupSelector: selector.	self methodDict at: selector put: compiledMethod.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod == nil ifFalse: [oldMethod flushCache].	selector flushCache! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 2/17/2000 22:37'!compress	"Compact the method dictionary of the receiver."	self methodDict rehash! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:37'!compiledMethodAt: selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^ self methodDict at: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!compiledMethodAt: selector ifAbsent: aBlock	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"	^ self methodDict at: selector ifAbsent: [aBlock value]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!methodsDo: aBlock	"Evaluate aBlock for all the compiled methods in my method dictionary."	^ self methodDict valuesDo: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:38'!selectors	"Answer a Set of all the message selectors specified in the receiver's 	method dictionary."	^ self methodDict keys  	"Point selectors."! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:38'!selectorsDo: selectorBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysDo: selectorBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:40'!sourceCodeAt: selector	^ (self methodDict at: selector) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:40'!sourceCodeAt: selector ifAbsent: aBlock	^ (self methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:40'!hasMethods	"Answer whether the receiver has any methods in its method dictionary."	^ self methodDict size > 0! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:39'!whichClassIncludesSelector: aSymbol 	"Answer the class on the receiver's superclass chain where the argument, 	aSymbol (a message selector), will be found. Answer nil if none found."	(self methodDict includesKey: aSymbol) ifTrue: [^ self].	superclass == nil ifTrue: [^ nil].	^ superclass whichClassIncludesSelector: aSymbol	"Rectangle whichClassIncludesSelector: #inspect."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:40'!whichSelectorsAccess: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].	^ self methodDict keys select: 		[:sel | 		((self methodDict at: sel)			readsField: instVarIndex)			or: [(self methodDict at: sel) writesField: instVarIndex]]	"Point whichSelectorsAccess: 'x'."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:41'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who method |	who _ Set new.	self methodDict associationsDo:		[:assn |		method _ assn value.		((method hasLiteral: literal) or:				[specialFlag and: [method scanFor: specialByte]])			ifTrue:			[((literal isMemberOf: Association) not				or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])				ifTrue: [who add: assn key]]].	^who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:39'!whichSelectorsStoreInto: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].	^ self methodDict keys select: 		[:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!Behavior methodsFor: 'private' stamp: 'di 2/17/2000 22:38'!removeSelectorSimply: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !!ClassDescription commentStamp: 'di 2/17/2000 22:31' prior: 0!I add a number of facilities to basic Behaviors:	Named instance variables	Category organization for methods	The notion of a name of this class (implemented as subclass responsibility)	The maintenance of a ChangeSet, and logging changes on a file	Most of the mechanism for fileOut.	I am an abstract class, in particular, my facilities are intended for inheritance by two subclasses, Class and Metaclass.The slots 'organization' and 'methodDict' should ONLY be accessed by message in order for things to work during ImageSegment>>discoverActiveClasses (q.v.).!!ClassDescription methodsFor: 'copying' stamp: 'di 2/17/2000 22:35'!copy: sel from: class classified: cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	| code category |	"Useful when modifying an existing class"	code _ class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category _ class organization categoryOfElement: sel]				ifFalse: [category _ cat].			(self methodDict includesKey: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self error: self name 										, ' ' 										, sel 										, ' will be redefined if you proceed.']].			self compile: code classified: category]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 2/17/2000 22:17'!induceMDFault	"Stache a copy of the methodDict in the organization slot (hack!!),	and set the methodDict to nil.  This will induce an MD fault on any message send.	See: ClassDescription>>recoverFromMDFault	and ImageSegment>>discoverActiveClasses."	organization _ Array with: methodDict with: organization.	methodDict _ nil.	self flushCache! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 2/17/2000 22:34'!removeSelector: aSymbol 	"Remove the message whose selector is aSymbol from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	(self methodDict includesKey: aSymbol) ifFalse: [^nil].	self wantsChangeSetLogging ifTrue:		[Smalltalk changes removeSelector: aSymbol class: self].	super removeSelector: aSymbol.	self organization removeElement: aSymbol.	self acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange: self name , ' removeSelector: #' , aSymbol]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 2/17/2000 22:34'!removeSelectorUnlogged: aSymbol 	"Remove the message whose selector is aSymbol from the method dictionary of the receiver, if it is there. Answer nil otherwise.  Do not log the action either to the current change set or to the changes log"	(self methodDict includesKey: aSymbol) ifFalse: [^ nil].	super removeSelector: aSymbol.	self organization removeElement: aSymbol! !!ClassDescription methodsFor: 'organization' stamp: 'di 2/17/2000 22:36'!organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	organization ifNil:		[organization _ ClassOrganizer defaultList: 						self methodDict keys asSortedCollection asArray].	(organization isMemberOf: Array) ifTrue:		[self recoverFromMDFault].	^ organization! !!ClassDescription methodsFor: 'compiling' stamp: 'di 2/17/2000 22:34'!compile: text classified: category withStamp: changeStamp notifying: requestor 	| selector priorMethod method methodNode newText |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ self methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[newText _ ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [text askIfAddStyle: priorMethod req: requestor]			ifFalse: [text].		 method putSource: newText				fromParseNode: methodNode				class: self category: category withStamp: changeStamp 				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'compiling' stamp: 'di 2/17/2000 22:35'!compile: code notifying: requestor trailer: bytes		ifFail: failBlock		elseSetSelectorAndNode: selAndNodeBlock	"Intercept this message in order to remember system changes.	 5/15/96 sw: modified so that if the class does not wish its methods logged in the changes file, then they also won't be accumulated in the current change set.	7/12/96 sw: use wantsChangeSetLogging to determine whether to put in change set"	| methodNode selector method |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	selector _ methodNode selector.	selAndNodeBlock value: selector value: methodNode.	self wantsChangeSetLogging ifTrue:		[(self methodDict includesKey: selector)			ifTrue: [Smalltalk changes changeSelector: selector class: self]			ifFalse: [Smalltalk changes addSelector: selector class: self]].	methodNode encoder requestor: requestor.  "Why was this not preserved?"	method _ methodNode generate: bytes.	self addSelector: selector withMethod: method.	^ method! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:42'!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	self organization moveChangedCommentToFile: newFile numbered: 2.	changes _ self methodDict keys select: [:sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:36'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile position: oldPos.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.	"The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr.! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 2/17/2000 22:36'!classesThatImplementAllOf: selectorSet	"Return an array of any classes that implement all the messages in selectorSet."	| found remaining |	found _ OrderedCollection new.	selectorSet do:		[:sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].	found isEmpty		ifTrue: [^ self subclasses inject: Array new						into: [:subsThatDo :sub |							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]		ifFalse: [remaining _ selectorSet copyWithoutAll: found.				remaining isEmpty ifTrue: [^ Array with: self].				^ self subclasses inject: Array new						into: [:subsThatDo :sub |							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !!Class methodsFor: 'copying' stamp: 'di 2/17/2000 22:43'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Dictionary methodsFor: 'printing' stamp: 'di 2/17/2000 22:55'!printOn: aStream	aStream nextPutAll: self class name, ' ('.	self keys asSortedCollection do:		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key); space].	aStream nextPut: $)! !!ImageSegment class methodsFor: 'testing' stamp: 'di 2/17/2000 21:58'!activeClasses   "ImageSegment activeClasses"	"Restore all remaining MD faults and return the active classes"	| unused active |	unused _ OrderedCollection new.	active _ OrderedCollection new.	Smalltalk allClasses do:		[:c | (c instVarNamed: 'methodDict') 			ifNil: [unused addLast: c]			ifNotNil: [active addLast: c]].	unused do: [:c | c recoverFromMDFault].	^ active! !!ImageSegment class methodsFor: 'testing' stamp: 'di 2/17/2000 22:08'!activeClassesByCategory   "ImageSegment activeClassesByCategory"	"Return a dictionary of active classes by system category.	Useful for finding kernel categories to minimize swapping."	| active dict cat list |	active _ self activeClasses.	dict _ Dictionary new.	active do:		[:c | cat _ c category.		list _ dict at: cat ifAbsent: [Array new].		dict at: cat put: (list copyWith: c)].	^ dict"	ImageSegment discoverActiveClasses  <-- do it		-- do something typical --	ImageSegment activeClassesByCategory  <-- inspect it"! !!ImageSegment class methodsFor: 'testing' stamp: 'di 2/17/2000 22:00'!discoverActiveClasses   "ImageSegment discoverActiveClasses" 	"Run this method, do a few things, save and resume the image.	This will leave unused classes with MDFaults.	You MUST follow this soon by activeClasses, or by swapOutInactiveClasses."	| ok |	Smalltalk allClasses do:		[:c | ok _ true.		#(Array Object Class Message MethodDictionary) do:			[:n | ((Smalltalk at: n) == c or:				[(Smalltalk at: n) inheritsFrom: c]) ifTrue: [ok _ false]].		ok ifTrue: [c induceMDFault]]."	ImageSegment discoverActiveClasses.		-- do something typical --	PopUpMenu notify: ImageSegment activeClasses size printString , ' classes were active out of ' ,			Smalltalk allClasses size printString."! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!fileOutInitializerOn: aStream	(self methodDict includesKey: #initialize) ifTrue: 		[aStream cr.		aStream nextChunkPut: thisClass name , ' initialize'].! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool	super fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	(aBool and:[moveSource not and: [self methodDict includesKey: #initialize]]) ifTrue: 		[aFileStream cr.		aFileStream cr.		aFileStream nextChunkPut: thisClass name , ' initialize'.		aFileStream cr]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!nonTrivial 	"Answer whether the receiver has any methods or instance variables."	^ self instVarNames size > 0 or: [self methodDict size > 0]! !ImageSegment class removeSelector: #restoreMDFaults!