'From Squeak 2.5 of August 6, 1999 on 31 August 1999 at 1:17:41 pm'!"Change Set:		Bug FixesDate:			4 August 1999Author:			NumerousDan Ingalls:Documents the fact that Fraction class>>numerator:denominator does not reduce its result.Changes the implementation of Fraction>>= to tolerate improper fractions.Doug Way:Adjusts the location of pop-up menus when the mouse is near the right side of the screen, so that the pop-up menu appears just to the left of the mouse.  This prevents the mouse from appearing on top of the menu and accidentally selecting an item.  (For both Morphic and MVC.)John Duncan:Fixes Browser>>spawnHierarchy to compensate for the 'all' category.Bob Arning:Fixes attempts to browse class var refs in classes descended from nil.OHSHIMA Yoshiki:Adds two primitives (warpBits and primitiveDirectoryLookup) to the InterpreterSimulator.  It means nothing for most Squeakers, but it makes the InterpreterSimlator a bit more functional:-)Javier Diaz:Fixes problems when Celeste tries to display a message with contentType = 'text/html'.  Also, if the message has contentType = 'text/html' but not 'mime-version'.Peter Smet:Collection>>with:collect: now requires same sized collection, consistent with with:do:"!!Browser methodsFor: 'class functions' stamp: 'di 8/31/1999 10:51'!spawnHierarchy	"Create and schedule a new class hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex |	classListIndex = 0 ifTrue: [^ self].	newBrowser _ HierarchyBrowser new initHierarchyForClass: self selectedClass 			meta: self metaClassIndicated.	(aSymbol _ self selectedMessageName) ifNotNil: [		aBehavior _ self selectedClassOrMetaClass.		messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.		newBrowser messageCategoryListIndex: messageCatIndex + 1.		newBrowser messageListIndex:			((aBehavior organization listAtCategoryNumber: messageCatIndex)						indexOf: aSymbol)].	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)		label: self selectedClassName , ' hierarchy'! !!Celeste methodsFor: 'message text pane' stamp: 'jdr 8/18/1999 16:32'!formatedMessageText	"Answer a string that is my formatted mail message."	| message header body bodyText |	currentMsgID isNil ifTrue: [^ ''].	message _ mailDB getMessage: currentMsgID.	header _ message cleanedHeader.	body _ message body.	body contentType = 'text/html'		ifTrue: [			bodyText _ (HtmlParser parse: (ReadStream on: bodycontent)) formattedText. ]		ifFalse: [			bodyText _ body content ].	^header asText, String cr, bodyText! !!ClassDescription methodsFor: 'instance variables' stamp: 'RAA 8/9/1999 19:32'!browseClassVarRefs 	"1/17/96 sw: moved here from Browser so that it could be used from a variety of places."	| lines labelStream vars allVars index owningClasses |	lines _ OrderedCollection new.	allVars _ OrderedCollection new.	owningClasses _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class |		vars _ class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^1 beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index _ (PopUpMenu labels: labelStream contents lines: lines) startUp.	index = 0 ifTrue: [^ self].	Smalltalk browseAllCallsOn:		((owningClasses at: index) classPool associationAt: (allVars at: index))! !!ContextPart methodsFor: 'debugger access' stamp: 'di 8/31/1999 09:42'!shortStack	"Answer a String showing the top ten contexts on my sender chain."	^ String streamContents:		[:strm |		(self stackOfSize: 10)			do: [:item | strm print: item; cr]]! !!Fraction methodsFor: 'comparing' stamp: 'di 8/31/1999 10:33'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [numerator = 0 ifTrue: [^ aNumber numerator = 0].				^ (numerator * aNumber denominator) =					(aNumber numerator * denominator)				"Note: used to just compare num and denom,					but this fails for improper fractions"].	^ aNumber adaptToFraction: self andSend: #=! !!Fraction class methodsFor: 'instance creation' stamp: 'di 8/31/1999 10:16'!numerator: numInteger denominator: denInteger 	"Answer an instance of me (numInteger/denInteger).	NOTE: This primitive initialization method will not reduce improper fractions,	so normal usage should be coded as, eg,		(Fraction numerator: a denominator: b) reduced	or, more simply, as		a / b."	^self new setNumerator: numInteger denominator: denInteger! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'yo 6/3/1999 16:10'!warpBits	^ myBitBlt warpBits! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'yo 6/3/1999 12:03'!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	| modDateOop createDateOop nameString results |	self var: 'entryName' declareC: 'char *entryName'.	"allocate storage for results, remapping newly allocated	 oops in case GC happens during allocation"	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassArray) indexableSize: 5).	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassString) indexableSize: entryNameSize)..	self pushRemappableOop: (self positive32BitIntegerFor: createDate).	self pushRemappableOop: (self positive32BitIntegerFor: modifiedDate).	modDateOop   _ self popRemappableOop.	createDateOop _ self popRemappableOop.	nameString    _ self popRemappableOop.	results         _ self popRemappableOop.	1 to: entryNameSize do: [ :i |		self storeByte: i-1 ofObject: nameString withValue: (entryName at: i) asciiValue.	].	self storePointer: 0 ofObject: results withValue: nameString.	self storePointer: 1 ofObject: results withValue: createDateOop.	self storePointer: 2 ofObject: results withValue: modDateOop.	dirFlag		ifTrue: [ self storePointer: 3 ofObject: results withValue: trueObj ]		ifFalse: [ self storePointer: 3 ofObject: results withValue: falseObj ].	self storePointer: 4 ofObject: results		withValue: (self integerObjectOf: fileSize).	^ results! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'yo 6/3/1999 12:07'!primitiveDirectoryLookup	| index pathName array result |	index _ self stackIntegerValue: 0.	pathName _ (self shortPrint: (self stackValue: 1)).	pathName _ pathName copyFrom: 2 to: pathName size - 1.		successFlag ifFalse: [		^self primitiveFail.	].	array _ FileDirectory default primLookupEntryIn: pathName index: index.	array == nil ifTrue: [		self pop: 3.		self push: nilObj.		^array.	].	array == #badDirectoryPath ifTrue: [		^self primitiveFail.	].	result _ self makeDirEntryName: (array at: 1) size: (array at: 1) size				createDate: (array at: 2) modDate: (array at: 3)				isDir: (array at: 4)  fileSize: (array at: 5).	self pop: 3.	self push: result.! !!MailMessage methodsFor: 'initialize-release' stamp: 'jdr 8/18/1999 16:33'!from: aString	"Parse the given string to initialize myself. The given string willbecome	my text."	| parseStream isMime contentType bodyText contentTransferEncoding |	time _ 0.	from _ to _ cc _ subject _ ''.	text _ self removeTrailingSeparators: aString.	parseStream _ ReadStream on: text.	isMime _ false.	contentType _ 'text/plain'.	contentTransferEncoding _ nil.	self fieldsFrom: parseStream do:		[:fName :fValue |		fName = 'date' ifTrue: [time _ self timeFrom: fValue].		fName = 'from' ifTrue: [from _ fValue].		fName = 'to'			ifTrue: [to isEmpty					ifTrue: [to _ fValue]					ifFalse: [to _ to , ', ' , fValue]].		fName = 'cc'			ifTrue: [cc isEmpty					ifTrue: [cc _ fValue]					ifFalse: [cc _ cc , ', ' , fValue]].		fName = 'subject' ifTrue: [subject _ fValue].		fName = 'mime-version' ifTrue: [isMime _ true].		fName = 'content-type' ifTrue: [contentType _ fValuecopyUpTo: $;].		fName = 'content-transfer-encoding' ifTrue:[contentTransferEncoding _ fValue asLowercase]].	bodyText _ parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue:			[bodyText _ Base64MimeConverter mimeDecodeToChars:(ReadStream on: bodyText).			bodyText _ bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [ bodyText _bodyText decodeQuotedPrintable ].	body _ MIMEDocument contentType: contentType content: bodyText! !!MenuMorph methodsFor: 'control' stamp: 'di 8/31/1999 10:42'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]				ifNone: [self items isEmpty						ifTrue: [^ self]						ifFalse: [self items first]].	"Note: items may not be laid out yet (I found them all to be at 0@0), 	so have to add up heights of items above the selected item."	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	self bounds right > hand worldBounds right		ifTrue: [self position: self position - (self bounds width - 4 @ 0)].	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: selectedItem.	self changed! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'JDD 8/8/199913:05'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines _ allLabels size.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'displaying' stamp: 'dew 8/4/1999 01:49'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ (DisplayText				text: captionOrNil asText				textStyle: TextStyle default copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta _ 0 - frame width @ delta y].	frame _ frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm _ captionText form.		captionBox _ captionForm boundingBox expandBy: 4.		captionBox _ captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave _ Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result _ self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 8/31/1999 09:01'!logError: errMsg inContext: aContext to: aFilename	"Log the error message and a stack trace to the given file."	| ff ctx |	FileDirectory default deleteFileNamed: aFilename ifAbsent: [].	(ff _ FileStream fileNamed: aFilename) ifNil: [^ self "avoid recursive errors"].  	Date today printOn: ff.  ff space.	Time now printOn: ff.  ff cr.	"Note: The following is an open-coded version of ContextPart>>stackOfSize:	since this method may be called during a low space condition and we might	run out of space for allocating the full stack."	ctx _ aContext.	[ctx == nil] whileFalse:[		ff print: ctx; cr.		ctx _ ctx sender].	ff close.! !