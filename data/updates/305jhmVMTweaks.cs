'From Squeak 2.2beta of Sept 11, 1998 on 23 September 1998 at 12:38:36 am'!"Change Set:		jhmVMTweaksDate:			23 September 1998Author:			John MaloneyVirtual machine changes for release 2.2. Includes:  async file I/O  several new misc. primitives  a new sound generation primitive for LoopedSampledSound  fix for PluckedSound primitive  fix for interrupt starvation problem  fix to make spy more accurate on failing primitives  ability to set cursor mask  fix for G3 recording bug  changes from Bob Arning to simplify compilation under MPW on the Mac  config/platformSpecific changes from Tim Rowledge to support the DEC Itsy"!!Cursor methodsFor: 'displaying' stamp: 'jm 9/22/1998 23:33'!beCursorWithMask: maskForm	"Primitive. Tell the interpreter to use the receiver as the current cursor image with the given mask Form. Both the receiver and the mask should have extent 16@16 and a depth of one. The mask and cursor bits are combined as follow:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel""Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'jm 9/22/1998 16:48'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	arrayFmt < 4 ifTrue: [ "pointer type objects"		start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl).			srcIndex _ srcIndex + 1. ] ]	ifFalse: [		arrayFmt < 8  ifTrue: [ "long-word type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1 ] ]		ifFalse: [  "byte-type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1. ] ].	].	self pop: 4.  "leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 9/23/1998 00:14'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 9/22/1998 16:58'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 9/22/1998 23:09'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 9/22/1998 16:52'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 9/22/1998 16:41'!cCodeForMiscPrimitives	"Return the contents of the miscellaneous primitives file, which is generated via automatic translation to C."	^ CCodeGenerator new codeStringForPrimitives: #(		(Bitmap compress:toByteArray:)		(Bitmap decompress:fromByteArray:at:)		(Bitmap encodeBytesOf:in:at:)		(Bitmap encodeInt:in:at:)		(String compare:with:collated:)		(String translate:from:to:table:)			(String findFirstInString:inSet:startingAt:)		(String indexOfAscii:inString:startingAt:)		(SampledSound convert8bitSignedFrom:to16Bit:))! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 9/22/1998 17:00'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:CW Test Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:24'!macAsyncFilePrimsFile	^ '/*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>#include "sq.h"/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpenSync(&pb);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/23/1998 00:06'!macMinimal	^ '/* sqMacMinimal.c	This file includes the minimal support code to build a Macintosh virtual machine.	Many primitives are "stubbed-out", meaning that if they are invoked from the	image they will return a "primitive failed" error. Among the stubbed out primitives	are those that support sound input and output, serial and MIDI ports, networking,	joystick, and file directory operations. The basic file read/write operations are	NOT stubbed out, although they could be as long as the image loading mechanism	still works. In this case, you''ll need to modify the method "openSourceFiles"	in the image to skip opening the changes and sources files at startup time.	The purpose of this file is to provide an implementation roadmap when bootstrapping	Squeak on a new platform. Once all the non-stubbed-out functions in this file have	been implemented, you will have a working, usable Squeak virtual machine!!*** Implementation Notes ***  I/O Functions	The following are essential for display and user interaction:		ioScreenSize()		ioShowDisplay()		ioGetButtonState()		ioGetKeystroke()		ioMousePoint()		ioPeekKeystroke()	The following can be made no-ops:		ioProcessEvents() 	-- poll for input events on some platforms		ioSetCursor()		-- install a 16x16 black and white hardware cursor		ioSetCursorWithMask() -- install a masked cursor		ioBeep()			-- make a short beep through the speaker		ioExit()			-- exit the VM: quit the application, reboot, power down, or							-- some other behavior appropriate to this platform							-- (if this is a noop you won''t be able to quit from Squeak)		ioRelinquishProcessorForMicroseconds()							-- called when Squeak is idle to return time to the OS  File Naming	The virtual machine keeps track of the full path name of the Squeak image	file and the path to the directory containing the virtual machine. In this	minimal implementation, the VM path is the empty string and the image name is	hardwired to "squeak.image". It is assumed that the image file, the changes	file, the Squeak application, and the system sources file are all in the	the same directory, and that that directory is the default working directory	for file operations. The "shortImageName" is used to display the image file	name (but not its full path) in the title bar of the Macintosh window.  Time Functions		ioMSecs(), ioMicroMSecs()							-- both return a millisecond clock value, but historically							-- ioMicroMSecs() used a higher resolution timer; the							-- ideal implementation is an inexpensive clock with 1							-- millisecond accuracy, but both functions can use a							-- clock with much coarser accuracy (e.g., 50-100 mSecs)							-- if necessary		ioSeconds()			-- return the number of seconds since Jan 1, 1901	   						-- may return 0, but then the current date and time	   						-- will be wrong*** Linking ***	To build a Macintosh VM using this file, link together:		interp.c		-- automatically generated interpreter file		sqFilePrims.c	-- file primitives (can be stubbed out)		sqMacMinimal.c	-- this file		sqMiscPrims.c	-- automatically generated primitives (optional)	plus the appropriate support libraries. To build a PowerPC	virtual machine using CodeWarrior 8, these are:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		MathLib		MWCRuntime.Lib*/#include <MacHeaders.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include "sq.h"#define STUBBED_OUT { success(false); }/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	success(false);  /* stubbed out */}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* Process Macintosh events, checking for the interrupt key. Return	   true if the interrupt key was pressed. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top) - 20;		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 20, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support ***/int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	return 0;}int clipboardSize(void) {	return 0;}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	return 0;}/*** Directory ***/int dir_Delimitor(void) {	return '':'';}/*** System Attributes ***/char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return "";	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 680xx";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Directory Stubs ***/int dir_Create(char *pathString, int pathStringLength)						STUBBED_OUTint dir_Lookup(char *pathString, int pathStringLength, int index,  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile)										STUBBED_OUTdir_SetMacFileTypeAndCreator(char *filename, int filenameSize,  char *fType, char *fCreator)												{/* noop */}/*** Joystick Stubs ***/int joystickRead(int stickIndex)											STUBBED_OUT/*** MIDI Stubs ***/int sqMIDIClosePort(int portNum)											STUBBED_OUTint sqMIDIGetClock(void)													STUBBED_OUTint sqMIDIGetPortCount(void)												STUBBED_OUTint sqMIDIGetPortDirectionality(int portNum)								STUBBED_OUTint sqMIDIGetPortName(int portNum, int namePtr, int length)					STUBBED_OUTint sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate)	STUBBED_OUTint sqMIDIParameter(int whichParameter, int modify, int newValue)			STUBBED_OUTint sqMIDIPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time)	STUBBED_OUT/*** Networking Stubs ***/int sqNetworkInit(int resolverSemaIndex)									STUBBED_OUTvoid sqNetworkShutdown(void)												STUBBED_OUTvoid sqResolverAbort(void)													STUBBED_OUTvoid sqResolverAddrLookupResult(char *nameForAddress, int nameSize)			STUBBED_OUTint sqResolverAddrLookupResultSize(void)									STUBBED_OUTint sqResolverError(void)													STUBBED_OUTint sqResolverLocalAddress(void)											STUBBED_OUTint sqResolverNameLookupResult(void)										STUBBED_OUTvoid sqResolverStartAddrLookup(int address)									STUBBED_OUTvoid sqResolverStartNameLookup(char *hostName, int nameSize)				STUBBED_OUTint sqResolverStatus(void)													STUBBED_OUTvoid sqSocketAbortConnection(SocketPtr s)									STUBBED_OUTvoid sqSocketCloseConnection(SocketPtr s)									STUBBED_OUTint sqSocketConnectionStatus(SocketPtr s)									STUBBED_OUTvoid sqSocketConnectToPort(SocketPtr s, int addr, int port)					STUBBED_OUTvoid sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex)							STUBBED_OUTvoid sqSocketDestroy(SocketPtr s)											STUBBED_OUTint sqSocketError(SocketPtr s)												STUBBED_OUTvoid sqSocketListenOnPort(SocketPtr s, int port)							STUBBED_OUTint sqSocketLocalAddress(SocketPtr s)										STUBBED_OUTint sqSocketLocalPort(SocketPtr s)											STUBBED_OUTint sqSocketReceiveDataAvailable(SocketPtr s)								STUBBED_OUTint sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize)			STUBBED_OUTint sqSocketRemoteAddress(SocketPtr s)										STUBBED_OUTint sqSocketRemotePort(SocketPtr s)											STUBBED_OUTint sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize)				STUBBED_OUTint sqSocketSendDone(SocketPtr s)											STUBBED_OUT/*** Profiling Stubs ***/int clearProfile(void)														STUBBED_OUTint dumpProfile(void)														STUBBED_OUTint startProfiling(void)													STUBBED_OUTint stopProfiling(void)														STUBBED_OUT/*** Serial Port Functions Stubs ***/int serialPortClose(int portNum)											STUBBED_OUTint serialPortOpen(  int portNum, int baudRate, int stopBitsType,  int parityType, int dataBits, int inFlowCtrl, int outFlowCtrl,  int xOnChar, int xOffChar)												STUBBED_OUTint serialPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint serialPortWriteFrom(int portNum, int count, int bufferPtr)				STUBBED_OUT/*** Sound Output Stubs ***/int snd_AvailableSpace(void)												STUBBED_OUTint snd_PlaySamplesFromAtLength(  int frameCount, int arrayIndex, int startIndex)							STUBBED_OUTint snd_InsertSamplesFromLeadTime(  int frameCount, int srcBufPtr, int samplesOfLeadTime)						STUBBED_OUTint snd_PlaySilence(void)													STUBBED_OUTint snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_Stop(void)															STUBBED_OUT/*** Sound Input Stubs ***/int snd_SetRecordLevel(int level)											STUBBED_OUTint snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_StopRecording(void)													STUBBED_OUTdouble snd_GetRecordingSampleRate(void)										STUBBED_OUTint snd_RecordSamplesIntoAtLength(  int buf, int startSliceIndex, int bufferSizeInBytes)						STUBBED_OUT/*** Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void)			STUBBED_OUTint primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)	STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUTint primReverbSoundapplyReverbTostartingAtcount(void)						STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUT/*** Old Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtpan(void)						STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primWaveTableSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUT/*** Experimental Asynchronous File I/O ***/int asyncFileClose(AsyncFile *f)											STUBBED_OUTint asyncFileOpen(  AsyncFile *f, int fileNamePtr, int fileNameSize,  int writeFlag, int semaIndex)												STUBBED_OUTint asyncFileRecordSize()													STUBBED_OUTint asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize)		STUBBED_OUTint asyncFileReadStart(AsyncFile *f, int fPosition, int count)				STUBBED_OUTint asyncFileWriteResult(AsyncFile *f)										STUBBED_OUTint asyncFileWriteStart(  AsyncFile *f, int fPosition, int bufferPtr, int bufferSize)				STUBBED_OUT/*** Main ***/void main(void) {	sqImageFile f;	int reservedMemory, availableMemory;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	InitMacintosh();	SetUpMenus();	SetUpWindow();	SetUpPixmap();	sqFileInit();	imageName[0] = shortImageName[0] = vmPath[0] = 0;	strcpy(imageName, "squeak.image");	strcpy(shortImageName, "squeak.image");	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following to open the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("In this minimal VM, the image file must be named ''squeak.image''\n");		printf("and must be in the same directory as the Squeak application.\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:31'!macSoundFile	^ '#include <Sound.h>#include <SoundInput.h>#include "sq.h"/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 4)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, NULL, NULL, true, 0};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 23:28'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 750000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:34'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define USE_CLOCK_MSECS# define LITTLE_ENDIAN_BITBLT# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* for Unix variants, this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_FILIO# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  undef  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define JUMP_ALIGN_STRICT#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif# if defined(arm)				/* SA110/Linux, maybe Itsy */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   if defined(ITSY)#     define LITTLE_ENDIAN_BITBLT#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 23:26'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:35'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*//* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"#ifdef macintosh/* macintosh memory allocation */#include <Memory.h>#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) NewPtr(desiredHeapSize)/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWritetypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num) #endif /* ACORN */#ifdef LITTLE_ENDIAN_BITBLT#define ifLittleEndianDoelseDo(a, b) a#else#define ifLittleEndianDoelseDo(a, b) b#endif'! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/20/1998 14:00'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 24.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !