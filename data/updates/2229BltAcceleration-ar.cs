'From Squeak2.8alpha of 16 February 2000 [latest update: #2226] on 28 May 2000 at 5:14:22 pm'!"Change Set:		BltAcceleration-arDate:			28 May 2000Author:			Andreas RaabTry to make the most common blts in Morphic to be accelerated. Mostly happens when dragging some large morph around."!!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/28/2000 17:12'!fullDrawOn: aCanvas	self updateCacheCanvas: aCanvas.	aCanvas cache: self fullBounds			using: cacheCanvas form			during:[:cachingCanvas| super fullDrawOn: cachingCanvas].! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/28/2000 17:12'!imageForm	self updateCacheCanvas: Display getCanvas.	^ cacheCanvas form offset: self fullBounds topLeft! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/28/2000 17:12'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| myBnds rectList |	myBnds _ self fullBounds.	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: myBnds extent) getCanvas.		cacheCanvas translateBy: myBnds origin negated			during:[:tempCanvas| super fullDrawOn: tempCanvas].		^self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: myBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			super fullDrawOn: c]].! !!FXGrafPort methodsFor: 'drawing support' stamp: 'ar 5/28/2000 15:58'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	(sourceMap isNil and:[destMap isNil and:[colorMap isNil and:[fillPattern isNil]]]) ifTrue:[		"Let's try it the fast way if possible"		(destForm isBltAccelerated: rule for: aForm) ifTrue:[			^destForm 				copyBits: sourceRect truncated				from: aForm 				at: aPoint asIntegerPoint				clippingBox: self clipRect truncated				rule: rule 				fillColor: fillPattern 				map: colorMap]].	sourceForm _ aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!FXGrafPort methodsFor: 'accessing' stamp: 'ar 5/28/2000 15:51'!contentsOfArea: aRectangle into: aForm	destForm 		displayOn: aForm 		at:  aRectangle origin		clippingBox: (0@0 extent: aRectangle extent).	^aForm! !!Form methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 16:00'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver and can be used for accelerated blts"	^Form extent: extentPoint depth: self depth! !!Form methodsFor: 'private' stamp: 'ar 5/28/2000 15:49'!setExtent: extent depth: bitsPerPixel bits: bitmap	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	(bits isNil or:[self bitsSize = bitmap size]) ifFalse:[^self error:'Bad dimensions'].	bits _ bitmap! !!ExternalScreen methodsFor: 'form support' stamp: 'ar 5/28/2000 16:55'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver and can be used for accelerated blts"	| formHandle displayForm |	formHandle _ self primAllocateForm: self depth width: extentPoint x height: extentPoint y.	formHandle = nil ifTrue:[^super allocateForm: extentPoint].	displayForm _ (ExternalForm extent: extentPoint depth: self depth bits: nil) 		setExternalHandle: formHandle on: self.	allocatedForms at: displayForm put: displayForm executor.	^displayForm! !!ExternalScreen methodsFor: 'form support' stamp: 'ar 5/28/2000 15:56'!destroyForm: anExternalForm	"Destroy the given external form"	self primDestroyForm: anExternalForm getExternalHandle.	anExternalForm setExternalHandle: nil on: nil.	allocatedForms removeKey: anExternalForm ifAbsent:[].! !!ExternalScreen methodsFor: 'blitting support' stamp: 'ar 5/28/2000 16:16'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: hf map: map	"Attempt to accelerate blts to the receiver"	| r |	((self isBltAccelerated: rule for: sourceForm) and:[map == nil and:[hf == nil]]) ifTrue:[		"Try an accelerated blt"		r _ (destOrigin extent: sourceRect extent) intersect: (clipRect intersect: clippingBox).		r area <= 0 ifTrue:[^self].		(self primBltFast: bits from: sourceForm getExternalHandle			at: r origin from: sourceRect origin			extent: r extent) ifNotNil:[^self].	].	^super copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: hf map: map! !!ExternalScreen methodsFor: 'blitting support' stamp: 'ar 5/28/2000 16:16'!displayOn: destForm at: destOrigin clippingBox: clipRect rule: rule fillColor: hf	"Attempt to accelerate blts to aDisplayMedium"	| sourceRect |	((self isBltAccelerated: rule for: destForm) and:[hf = nil]) ifTrue:[		"Try an accelerated blt"		sourceRect _ (clipRect translateBy: destOrigin negated) intersect: clippingBox.		(self primBltFast: bits to: destForm getExternalHandle			at: 0@0 from: sourceRect origin			extent: sourceRect extent) ifNotNil:[^self]].	destForm copyBits: self boundingBox		from: self		at: destOrigin + self offset		clippingBox: clipRect		rule: rule		fillColor: hf		map: (self colormapIfNeededFor: destForm).! !!ExternalScreen methodsFor: 'blitting support' stamp: 'ar 5/28/2000 15:52'!isBltAccelerated: ruleInteger for: aForm	"Return true if the receiver can perform accelerated blt operations by itself.	It is assumed that blts of forms allocated on the receiverusing Form>>over 	may be accelerated.	Although some hardware may allow source-key blts (that is, Form>>paint or similar)	this is usually questionable and the additional effort for allocating and	maintaining the OS form doesn't quite seem worth the effort."	^aForm displayScreen == self and:[ruleInteger = Form over]! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 5/28/2000 17:11'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver"	^form allocateForm: extentPoint! !!FormCanvas methodsFor: 'other' stamp: 'ar 5/28/2000 17:07'!printOn: aStream	super printOn: aStream.	aStream nextPutAll:' on: '; print: form.! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 17:09'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas == nil or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])		ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: [aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 16:01'!savePatchFrom: aCanvas	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect _ myBnds _ self fullBounds.	savedPatch ifNotNil: [		damageRect _ myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch == nil or: [savedPatch extent ~= myBnds extent])		ifTrue: [  "allocate new patch form if needed"			savedPatch _ aCanvas form allocateForm: myBnds extent].	aCanvas		contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^ damageRect! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 17:12'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| subBnds rectList |	"Always check for real translucency -- can't be cached in a form"	self allMorphsDo: [:m |		m hasTranslucentColor ifTrue: [			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: subBnds extent) getCanvas.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !HandMorph removeSelector: #updateCacheCanvasDepth:!ExternalScreen removeSelector: #allocateOrRecycleForm:!ExternalScreen removeSelector: #formHandleOf:!CachingMorph removeSelector: #updateCacheCanvasDepth:!