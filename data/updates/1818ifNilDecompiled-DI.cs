'From Squeak2.8alpha of 12 January 2000 [latest update: #1811] on 6 February 2000 at 9:26:07 am'!"Change Set:		ifNilDecompiled-DIDate:			29 January 2000Author:			Dan IngallsThis change set extends the decompiler to properly decompile all code generated by ifNil constructs."!InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit lastJumpPc lastReturnPc limit hasValue blockStackBase '	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag '	poolDictionaries: ''	category: 'System-Compiler'!!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 1/28/2000 13:43'!codeMessage: receiver selector: selector arguments: arguments	| symbol |	symbol _ selector key.	(node _ BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node _ self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: (symbol isInfix								ifTrue: [2]								ifFalse: [symbol isKeyword												ifTrue: [3]												ifFalse: [1]])! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 1/28/2000 21:23'!decodeIfNilWithReceiver: receiver selector: selector arguments: arguments	selector == #ifTrue:ifFalse:		ifFalse: [^ nil].	(receiver isMessage: #==				receiver: nil				arguments: [:argNode | argNode == NodeNil])		ifFalse: [^ nil].	^ (MessageNode new			receiver: receiver			selector: (SelectorNode new key: #ifTrue:ifFalse: code: #macro)			arguments: arguments			precedence: 3)		noteSpecialSelector: #ifNil:ifNotNil:! !!InstructionStream methodsFor: 'testing' stamp: 'di 1/29/2000 14:42'!willJumpIfTrue 	"Answer whether the next bytecode is a jump-if-true." 	| byte |	byte _ self method at: pc.	^ byte between: 168 and: 171! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 2/5/2000 09:34'!doPop	stack isEmpty ifTrue:		["Ignore pop in first leg of ifNil for value"		^ self].	stack last == CaseFlag		ifTrue: [stack removeLast]		ifFalse: [statements addLast: stack removeLast].! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 2/6/2000 08:46'!jump: dist if: condition	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump		elseJump condHasValue b isIfNil saveStack |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc _ lastPc.	elseStart _ pc + dist.	end _ limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign _ condition.	savePc _ pc.	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist].	pc _ savePc.	ifExpr _ stack removeLast.	(stack size > 0 and: [stack last == IfNilFlag])		ifTrue: [stack removeLast.  isIfNil _ true]		ifFalse: [isIfNil _ false].	saveStack _ stack.	stack _ OrderedCollection new.	thenBlock _ self blockTo: elseStart.	condHasValue _ hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			thenJump will jump to the beginning of the while expr.  In the case of			while's with a block in the condition, the while expr			should include more than just the last expression: find all the			statements needed by re-decompiling."			stack _ saveStack.			pc _ thenJump.			b _ self statementsTo: elsePc.			"discard unwanted statements from block"			b size - 1 timesRepeat: [statements removeLast].			statements addLast: (constructor					codeMessage: (constructor codeBlock: b returns: false)					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)					arguments: (Array with: thenBlock)).			pc _ elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock _ self blockTo: thenJump.			elseJump _ exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc				ifTrue: [pc _ lastPc].			isIfNil			ifTrue: [cond _ constructor						codeMessage: ifExpr ifNilReceiver						selector: (sign							ifTrue: [constructor codeSelector: #ifNotNil: code: #macro]							ifFalse: [constructor codeSelector: #ifNil: code: #macro])						arguments: (Array with: thenBlock)]			ifFalse: [cond _ constructor						codeMessage: ifExpr						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)						arguments:							(sign								ifTrue: [Array with: elseBlock with: thenBlock]								ifFalse: [Array with: thenBlock with: elseBlock])].			stack _ saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 1/29/2000 08:38'!send: selector super: superFlag numArgs: numArgs	| args rcvr selNode msgNode messages |	args _ Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	rcvr _ stack removeLast.	superFlag ifTrue: [rcvr _ constructor codeSuper].	(selector == #blockCopy: and: [self checkForBlock: rcvr])		ifFalse:			[selNode _ constructor codeAnySelector: selector.			rcvr == CascadeFlag				ifTrue:					["May actually be a cascade or an ifNil: for value."					self willJumpIfFalse						ifTrue: "= generated by a case macro"							[selector == #= ifTrue:								[" = signals a case statement..."								statements addLast: args first.								stack addLast: rcvr. "restore CascadeFlag"								^ self].							selector == #== ifTrue:								[" == signals an ifNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							self error: 'bad case: ', selector]						ifFalse:							[(self willJumpIfTrue and: [selector == #==]) ifTrue:								[" == signals an ifNotNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							msgNode _ constructor codeCascadedMessage: selNode											arguments: args].					stack last == CascadeFlag						ifFalse:							["Last message of a cascade"							statements addLast: msgNode.							messages _ self popTo: stack removeLast.  "Depth saved by first dup"							msgNode _ constructor								codeCascade: stack removeLast								messages: messages]]				ifFalse:					[msgNode _ constructor								codeMessage: rcvr								selector: selNode								arguments: args].			stack addLast: msgNode]! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 08:49'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames _ Decompiler allInstVarNames.	code _ (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , (code copyFrom: 4 to: code size) , '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!Decompiler class methodsFor: 'class initialization' stamp: 'di 1/28/2000 22:21'!initialize	CascadeFlag _ 'cascade'.  "A unique object"	CaseFlag _ 'case'. "Ditto"	ArgumentFlag _ 'argument'.  "Ditto"	IfNilFlag _ 'ifNil'.  "Ditto"	"Decompiler initialize"! !!MessageNode methodsFor: 'initialize-release' stamp: 'di 1/28/2000 21:19'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selNode key.	selector _ selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'initialize-release' stamp: 'di 1/28/2000 21:19'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder 	"Compile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selName.	(self transform: encoder)		ifTrue: 			[selector isNil				ifTrue: [selector _ SelectorNode new 							key: (MacroSelectors at: special)							code: #macro]]		ifFalse: 			[selector _ encoder encodeSelector: selName.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!MessageNode methodsFor: 'printing' stamp: 'di 1/28/2000 23:51'!printIfNilNotNil: aStream indent: level	receiver ifNotNil:		[receiver ifNilReceiver printOn: aStream indent: level precedence: precedence].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^ self printKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 1/28/2000 23:47'!printOn: aStream indent: level	| printer |	special > 0 ifTrue: [printer _ MacroPrinters at: special].	(printer == #printCaseOn:indent:) ifTrue: 		[^self printCaseOn: aStream indent: level].	(printer == #printIfNilNotNil:indent:) ifTrue: 		[^self printIfNilNotNil: aStream indent: level].	receiver == nil 		ifFalse: [receiver printOn: aStream indent: level precedence: precedence].	(special > 0)		ifTrue: 			[self perform: printer with: aStream with: level]		ifFalse: 			[self 				printKeywords: selector key				arguments: arguments				on: aStream				indent: level]! !Decompiler initialize!