'From Squeak2.6 of 11 October 1999 [latest update: #1661] on 30 November 1999 at 10:31:59 pm'!!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 11/29/1999 12:39'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet |	aRootArray ifNil: [self errorWrongState].	aRootArray do: [:rr | 		(rr isKindOf: PasteUpMorph) ifTrue: [			rr removeProperty: #revertTo]].	"will be reverting to this file"	rootSet _ IdentitySet new: 150.	rootSet addAll: aRootArray.	arrayOfRoots _ rootSet asArray.	rootSet _ nil.	"be clean"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	endMarker _ 'End' clone.	"for enumeration of objects"	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 11/30/1999 22:29'!copyFromRootsForExport: rootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	Smalltalk garbageCollect.	"get contexts with Players"	[self copyFromRoots: arrayOfRoots sizeHint: 0.	(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"do over to include methods pointed at by blocks"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 11/17/1999 15:01'!copyFromRootsLocalFileFor: rootArray sizeHint: segSize	"If the roots include a World, add its Player classes to the roots."	| newRoots |	arrayOfRoots _ rootArray.	[(newRoots _ self rootsIncludingPlayers) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	Smalltalk forgetDoIts.  	Smalltalk garbageCollect.	"zap context that holds allExtantPlayers array"	self copyFromRoots: arrayOfRoots sizeHint: segSize.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 11/30/1999 22:30'!extract	"This operation replaces (using become:) all the original roots of a segment with segmentRootStubs.  Thus the original objects will be reclaimed, and the root stubs will remain to bring the segment back in if it is needed."	Cursor write showWhile: [		state = #inactive ifTrue: [self copyFromRoots: arrayOfRoots sizeHint: 0].		state = #activeCopy ifFalse: [self errorWrongState].		arrayOfRoots elementsForwardIdentityTo:			(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).		state _ #active].! !!ImageSegment methodsFor: 'testing' stamp: 'tk 11/30/1999 22:29'!deepCopyTest: aRootArray	"ImageSegment new deepCopyTest: Morph withAllSubclasses asArray"	"Project allInstances do:		[:p | p == Project current ifFalse:			[Transcript cr; cr; nextPutAll: p name.			ImageSegment new deepCopyTest: (Array with: p)]]."	| t1 t2 copy |	t1 _ Time millisecondsToRun: [self copyFromRoots: aRootArray sizeHint: 0].	t2 _ Time millisecondsToRun: [copy _ self segmentCopy].	Transcript cr; print: segment size * 4; nextPutAll: ' bytes stored with ';		print: outPointers size; show: ' outpointers in '; print: t1; show: 'ms.'.	Transcript cr; nextPutAll: 'Reconstructed in '; print: t2; show: 'ms.'.	^ copy"Smalltalk allClasses do:	[:m | ImageSegment new deepCopyTest: (Array with: m with: m class)]"! !!ImageSegment methodsFor: 'testing' stamp: 'tk 11/30/1999 22:30'!findRogueRootsImSeg: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) Break all owner pointers in submorphs and all scripts.2) Create the segment and look at outPointers.3) Remove those we expect.4) Remember to quit without saving -- the owner pointers are smashed."| newRoots suspects bag1 bag2 |arrayOfRoots _ rootArray.[(newRoots _ self rootsIncludingPlayers) == nil] whileFalse: [	arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"self findRogueRootsPrep.	"and free that context!!"Smalltalk forgetDoIts.Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots sizeHint: 0.suspects _ outPointers select: [:oo | oo isMorph].suspects size > 0 ifTrue: [suspects inspect].bag1 _ Bag new.  bag2 _ Bag new.outPointers do: [:key | 	(key isKindOf: Class) 		ifTrue: [bag2 add: key class name]		ifFalse: [(#(Symbol Point Rectangle True False String Float Color Form ColorForm StrikeFont Metaclass UndefinedObject TranslucentColor) includes: key class name)			ifTrue: [bag2 add: key class name]			ifFalse: [bag1 add: key class name]]]."(bag sortedCounts) is the SortedCollection"(StringHolder new contents: bag1 sortedCounts printString, '', bag2 sortedCounts printString) 	openLabel: 'Objects pointed at by the outside'.self halt: 'Examine local variables pointIn and inSeg'."Use this in inspectors:	outPointers select: [:oo | oo class == <a Class>].		"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 11/19/1999 20:21'!declare: classThatIsARoot	| existing |	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	(Smalltalk includesKey: classThatIsARoot name) ifFalse: [		"Class entry in Smalltalk not referred to in Segment, install anyway."		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing _ Smalltalk at: classThatIsARoot name.	existing xxxClass == ImageSegmentRootStub ifTrue: [		"We are that segment!!  Must ask it carefully!!"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing == false | (existing == nil) ifTrue: [		"association is in outPointers, just installed"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	"Conflict with existing global or copy of the class"	(existing isKindOf: Class) ifTrue: [		classThatIsARoot isSystemDefined not ifTrue: [			"UniClass.  give it a new name"			classThatIsARoot setName: Player chooseUniqueClassName.			^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].		"Take the incoming one"		self inform: 'Using newly arrived version of ', classThatIsARoot name.		^ (Smalltalk at: classThatIsARoot name) becomeForward: classThatIsARoot].	self error: 'Name already in use by a non-class: ', classThatIsARoot name.! !!ImageSegment methodsFor: 'instance remapping' stamp: 'tk 11/29/1999 12:39'!allInstancesOf: aClass do: aBlock	| withSymbols oldInstances segSize |	"Bring me in, locate instances of aClass and submit them to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	(outPointers includes: aClass) ifFalse: [^ self].		"If has instances, they point out at the class"	Cursor read showWhile: [		state = #onFile ifTrue: [self readFromFile.			endMarker _ 'End' clone]].	"for enumeration of objects"	segSize _ segment size.	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == aClass ifTrue: [		oldInstances add: obj]].	oldInstances do: [:inst | aBlock value: inst].	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'instance remapping' stamp: 'tk 11/29/1999 12:40'!segUpdateInstancesOf: oldClass toBe: newClass isMeta: isMeta	| withSymbols oldInstances segSize |	"Bring me in, locate instances of oldClass and get them converted.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	(outPointers includes: oldClass) ifFalse: [^ self].		"If has instances, they point out at the class"	Cursor read showWhile: [		state = #onFile ifTrue: [self readFromFile.			endMarker _ 'End' clone]].	"for enumeration of objects"	segSize _ segment size.	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == oldClass ifTrue: [		oldInstances add: obj]].	newClass updateInstances: oldInstances asArray from: oldClass isMeta: isMeta.	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment class methodsFor: 'testing' stamp: 'tk 11/30/1999 22:27'!swapOutInactiveClasses  "ImageSegment swapOutInactiveClasses"  	"Make up segments by grouping unused classes by system category.	Read about, and execute discoverActiveClasses, and THEN execute this one."	| unused groups i roots |	ImageSegment recoverFromMDFault.	ImageSegmentRootStub recoverFromMDFault.	unused _ Smalltalk allClasses select: [:c | (c instVarNamed: 'methodDict') == nil].	unused do: [:c | c recoverFromMDFault].	groups _ Dictionary new.	SystemOrganization categories do:		[:cat |		i _ (cat findLast: [:c | c = $-]) - 1.		i <= 0 ifTrue: [i _ cat size].		groups at: (cat copyFrom: 1 to: i)			put: (groups at: (cat copyFrom: 1 to: i) ifAbsent: [Array new]) ,			((SystemOrganization superclassOrder: cat) select: [:c | 				unused includes: c]) asArray].	groups keys do:		[:cat | roots _ groups at: cat.		Transcript cr; cr; show: cat; cr; print: roots; endEntry.		roots _ roots , (roots collect: [:c | c class]).		(cat beginsWith: 'Sys' "something here breaks") ifFalse:			[(ImageSegment new copyFromRoots: roots sizeHint: 0) extract; 				writeToFile: cat].		Transcript cr; print: Smalltalk garbageCollect; endEntry]! !!ImageSegment class methodsFor: 'testing' stamp: 'tk 11/30/1999 22:27'!swapOutProjects  "ImageSegment swapOutProjects"  	"Swap out segments for all projects other than the current one."	| spaceLeft newSpaceLeft |	spaceLeft _ Smalltalk garbageCollect.	Project allSubInstances doWithIndex:		[:p :i | p == Project current ifFalse:			[Transcript cr; cr; nextPutAll: p name.			(ImageSegment new copyFromRoots: (Array with: p) sizeHint: 0)				extract; writeToFile: 'project' , i printString.			newSpaceLeft _ Smalltalk garbageCollect.			Transcript cr; print: newSpaceLeft - spaceLeft; endEntry.			spaceLeft _ newSpaceLeft]].! !!ImageSegment class methodsFor: 'testing' stamp: 'tk 11/30/1999 22:27'!testClassFaultOn: someClass  "ImageSegment testClassFaultOn: FileList"  	"Swap out a class with an existing instance.  Then send a message to the inst.	This will cause the VM to choke down deep and resend #cannotInterpret:.	This in turn will send a message to the stubbed class which will choke	and resend: #doesNotUnderstand:.  Then, if we're lucky, things will start working."	(ImageSegment new copyFromRoots: (Array with: someClass with: someClass class) 		sizeHint: 0) extract; writeToFile: 'test'.! !!Project methodsFor: 'file in/out' stamp: 'tk 11/17/1999 15:40'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is response sizeHint |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].self possiblyRevert ifTrue: [^ true].	"zapped segment and went back to old stubs"sizeHint _ self projectParameters at: #segmentSize ifAbsent: [0].is _ ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		 sizeHint: sizeHint.is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' not enough objects for a Segment.'; cr.	^ false].self projectParameters at: #segmentSize put: is segment size.is extract; writeToFile: self name.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 11/30/1999 22:23'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"| is str |world == World ifTrue: [^ self].		" inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false.""Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.	""project world deleteAllFlapArtifacts.""self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].is _ ImageSegment new copyFromRootsLocalFileFor: 		(Array with: world presenter with: world)	"world, and all Players"	sizeHint: 0.is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' did not get enough objects'; cr.  ^ self beep].false ifTrue: [	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				Smalltalk					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract."is instVarAt: 2 put: is segment clone."		"different memory"! !ImageSegment removeSelector: #copyFromRootsLocalFileFor:!ImageSegment removeSelector: #copyFromRoots:!