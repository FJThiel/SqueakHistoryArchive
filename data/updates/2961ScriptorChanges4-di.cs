'From Squeak2.9alpha of 12 June 2000 [latest update: #3011] on 14 November 2000 at 8:43:40 am'!"Change Set:		ScriptorChanges4Date:			11 November 2000Author:			Dan IngallsIntroduces a notion of successive clicks to expand a selectionMakes 'tearing off' a copy require a 5-pixel drag.Many state variables removed.Tile coloring defaults to none -- the other choice is temporarily broken."!AlignmentMorph subclass: #SyntaxMorph	instanceVariableNames: 'parseNode explanation parsedInClass getMenuBlock minBorderWidth markerMorph debugger '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Tile Scriptors'!!Debugger methodsFor: 'code pane' stamp: 'di 11/14/2000 08:43'!createSyntaxMorph	| methodNode rootMorph |	methodNode _ self selectedClass compilerClass new			parse: contents			in: self selectedClass			notifying: nil.	(rootMorph _ methodNode asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: self selectedClass;		debugger: self.	self addDependent: rootMorph.	^rootMorph! !!ParseNode methodsFor: 'tiles' stamp: 'di 11/13/2000 18:35'!addCommentToMorph: aMorph	| row stream |	(comment isNil or: [comment isEmpty]) ifTrue: [^ self].	stream _ SyntaxMorphStream on: (Text new: 400).	self printCommentOn: stream indent: 1.	row _ aMorph addTextRow: stream contents asString.	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!BlockNode methodsFor: 'tiles' stamp: 'di 11/13/2000 20:32'!asMorphicSyntaxIn: parent	| row column |	(column _ parent addColumn: #block on: self) layoutInset: 2@-1.	self addCommentToMorph: column.	arguments size > 0 ifTrue:		[row _ column addRow: #blockarg1 on: (BlockArgsNode new).		arguments do: [:arg | (arg asMorphicSyntaxIn: row) color: #blockarg2]].	statements do: [ :each | 		(each asMorphicSyntaxIn: column) borderWidth: 1.		each addCommentToMorph: column].	^ column! !!BraceNode methodsFor: 'tiles' stamp: 'di 11/13/2000 21:17'!asMorphicSyntaxIn: parent	| row |	row _ (parent addRow: #brace on: self) layoutInset: 1.	row addMorphBack: (StringMorph new contents: 		(String streamContents: [:aStream | self printOn: aStream indent: 0])).	^row! !!CascadeNode methodsFor: 'tiles' stamp: 'di 11/13/2000 18:25'!asMorphicSyntaxIn: parent	| cascadeMorph row |	row _ parent addRow: #cascade on: self.	receiver asMorphicSyntaxIn: row.	cascadeMorph _ row addColumn: #cascade2 on: self.	messages do: [ :m | m asMorphicSyntaxIn: cascadeMorph].	^row! !!MessageNode methodsFor: 'tiles' stamp: 'di 11/13/2000 20:18'!morphFromKeywords: key arguments: args on: parent indent: ignored 	| keywords column row receiverMorph firstArgMorph receiverWidth messageWidth |	receiver ifNotNil: ["i.e. not a cascade"			receiverMorph _ receiver asMorphicSyntaxIn: parent].	keywords _ key keywords.	args size = 0 ifTrue:			[row _ (parent addTextRow: key) layoutInset: 1.			^ row parseNode: selector].	receiverWidth _ receiver				ifNil: [0]				ifNotNil: [receiverMorph fullBounds width].	(receiverWidth <= 80 and: [args size = 1])		ifTrue: [row _ (parent addTextRow: keywords first) layoutInset: 1.			row parseNode: selector.			firstArgMorph _ args first asMorphicSyntaxIn: parent.			receiver ifNil: [^ self].			(firstArgMorph fullBounds height > 100					or: [firstArgMorph fullBounds width > 250])				ifTrue: [parent foldMessageOneArg].			^ self].	column _ parent addColumn: #keyword1 on: self.	messageWidth _ 0.	keywords		with: (args copyFrom: 1 to: keywords size)		do: [:kwd :arg | 			(row _ column addRow: #keyword2 on: self) borderWidth: 1;				parseNode: (self as: MessagePartNode);				 borderColor: row stdBorderColor.			row addToken: kwd				type: #keyword2				on: KeyWordNode new.			arg asMorphicSyntaxIn: row.			messageWidth _ messageWidth + row fullBounds width].	receiverMorph ifNotNil:		[receiverWidth + messageWidth < 350 ifTrue: [^ parent unfoldMessage].			((receiverWidth > 200						or: [receiverWidth > 80								and: [column fullBounds height > 20]])					or: [receiverMorph fullBounds width > 30							and: [column fullBounds height > 100									or: [column fullBounds width > 250]]])				ifTrue: [^ parent foldMessage]]! !!MethodNode methodsFor: 'tiles' stamp: 'di 11/13/2000 18:34'!asMorphicSyntaxIn: morph	| header tempMorph selNode |	selNode _ selectorOrFalse class == SelectorNode 		ifTrue: [selectorOrFalse] 		ifFalse: [SelectorNode new key: selectorOrFalse code: nil].	header _ morph addRow: Color white on: selNode.	precedence = 1		ifTrue: [header addToken: self selector type: #keyword1 on: self]		ifFalse: [self selector keywords with: arguments do:					[:kwd :arg | 					header addToken: kwd type: #keyword2 on: self.					(arg asMorphicSyntaxIn: header) color: #blockarg2]].	self addCommentToMorph: morph.	temporaries size > 0 ifTrue: [		tempMorph _ morph addRow: #tempVariable on: (MethodTempsNode new).		tempMorph color: tempMorph color darker.		temporaries do: [:temp | temp asMorphicSyntaxIn: tempMorph ]				separatedBy: [tempMorph addMorphBack: (tempMorph transparentSpacerOfSize: 4@4)]].	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue:		["Dont decompile <prim> for, eg, ^ self "		morph addTextRow: (String streamContents: [ :strm | self printPrimitiveOn: strm])].	block asMorphicSyntaxIn: morph.	^ morph! !!SyntaxMorph methodsFor: 'accessing' stamp: 'di 11/13/2000 20:06'!parsedInClass	^ self root parseNode encoder classEncoding! !!SyntaxMorph methodsFor: 'accessing' stamp: 'di 11/13/2000 20:09'!parsedInClass: x	self parsedInClass == x ifTrue: [self error: 'inconsistent value']! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/13/2000 10:03'!handlesMouseDown: evt	evt yellowButtonPressed ifTrue: [^ true].	parseNode == nil ifTrue: [^ false].	owner isSyntaxMorph ifTrue:		[((owner nodeClassIs: MethodNode) and: [(self nodeClassIs: BlockNode) not])			ifTrue: [^ false]].	"Can only take block out of a MethodNode"	^ true! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/13/2000 18:42'!mouseDown: evt 	owner isSyntaxMorph ifTrue:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == outerMorph or: [self hasOwner: outerMorph]])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"bare, out in the world"	(self nodeClassIs: MethodNode) ifTrue:		[^ self]. "whole method not draggable"	evt hand attachMorph: self.	^ self align: self topLeft with: evt hand position + self cursorBaseOffset.! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/13/2000 12:45'!mouseEnterDragging: evt	"Highlight this level as a potential drop target""Transcript cr; print: self; show: ' enterDragging'."	self unhighlightOwner.	self highlightForDrop: evt.	(self nodeClassIs: BlockNode) ifTrue: [self startStepping]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/13/2000 12:50'!mouseMove: evt	| dup selection |	owner isSyntaxMorph ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		(evt cursorPoint dist: mouseDownLoc) > 4 ifTrue:			["If drag 5 pixels, then tear off a copy of outer selection."			selection _ outerMorph ifNil: [self].			evt hand attachMorph: (dup _ selection duplicate).			dup align: dup topLeft with: evt hand position + self cursorBaseOffset.			self setSelection: nil.			self allOwnersDo:				[:m | (m isSyntaxMorph and: [m nodeClassIs: BlockNode])					ifTrue: [m startStepping]]]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/13/2000 16:39'!mouseUp: evt	owner isSyntaxMorph ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		outerMorph ifNil: [^ self setSelection: {self. nil. self} "first click"].		^ self setSelection: {self. nil. (outerMorph firstOwnerSuchThat:										[:m | m isSyntaxMorph and: [m isSelectable]])									ifNil: [self]}].! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 11/13/2000 00:53'!acceptDroppingMorph: aMorph event: evt	| itNoun |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	self allOwnersDo:		[:m | (m isSyntaxMorph and: [m nodeClassIs: BlockNode])			ifTrue: [m stopStepping; hideCaret]].	(self nodeClassIs: BlockNode) & itNoun		ifTrue:			[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse:					["if already declared, start new line of code with it"					self addToBlock: aMorph event: evt]]			ifFalse:			[^ self addToBlock: aMorph event: evt]].	"If I am a BlockNode and it is a noun add it as a new line"	(self nodeClassIs: BlockNode) ifTrue: [		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[((aMorph nodeClassIs: TempVariableNode)				or: [aMorph nodeClassIs: VariableNode])  ifFalse: [ ^ self]]]].	owner replaceSubmorph: self by: aMorph.	"do the normal replacement"	aMorph owner layoutChanged.! !!SyntaxMorph methodsFor: 'drawing' stamp: 'di 11/13/2000 20:38'!drawOn: aCanvas	super drawOn: aCanvas.	(self nodeClassIs: BlockNode) ifTrue:		[aCanvas fillRectangle: (self topLeft + (1@0) extent: 2@(self height-1)) color: Color blue.		aCanvas fillRectangle: (self topLeft + (1@0) extent: 4@1) color: Color blue.		aCanvas fillRectangle: (self bottomLeft + (1@-1) extent: 4@1) color: Color blue]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'di 11/13/2000 21:12'!stdBorderColor 	"several choices of how to do the border"	self class noTileColor		ifTrue: [^ "color" Color transparent]		ifFalse: [^ "color darker" Color transparent]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'di 11/13/2000 10:13'!unhighlight	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		self == outerMorph			ifTrue: [self borderColor: #raised]			ifFalse: [self borderColor: self stdBorderColor]]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/13/2000 18:54'!currentSelectionDo: blockForSelection	| root |	(root _ self root) ifNil: [^ blockForSelection value: nil value: nil value: nil].	root valueOfProperty: #selectionSpec ifPresentDo:		[:selectionSpec | ^ blockForSelection							value: selectionSpec first							value: selectionSpec second							value: selectionSpec third].	^ blockForSelection value: nil value: nil value: nil! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/13/2000 13:17'!deselect	self allMorphsDo:		[:m | m isSyntaxMorph ifTrue: [m color: Color transparent; borderColor: Color transparent]]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/13/2000 17:49'!isSelectable	"Spacer morphs enclose other morphs with the same parseNode"	(self nodeClassIs: CascadeNode) ifTrue: [^ false].	(self nodeClassIs: SelectorNode) ifTrue: [^ false].	(self nodeClassIs: KeyWordNode) ifTrue: [^ false].	(self nodeClassIs: MethodNode) ifTrue: [^ false].	^ true! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/13/2000 18:53'!root	^ self orOwnerSuchThat: [:m | m isSyntaxMorph and: [m nodeClassIs: MethodNode]]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/13/2000 13:18'!select	self deselect.	((self nodeClassIs: SelectorNode) or: [self nodeClassIs: MessagePartNode])		ifTrue: [self color: Color lightBrown]		ifFalse: [self color: Color lightBrown].	self borderColor: #raised! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/13/2000 18:55'!setSelection: newSpec	"A selectionSpec is {Inner morph.  Where clicked.  Outer morph}.	First mouseDown starts a selection (with outerMorph == nil).	Dragging more than 4 pixels means to grab a copy of the current outer selection.		The current selection is the outerMorph, or the inner if it is nil.	Each mouseUp extends the selection to the next outer morph that is selectable.		Except if this is the first click."	| root |	(root _ self root) valueOfProperty: #selectionSpec ifPresentDo:		[:oldSpec | (newSpec == nil or: [newSpec third == nil			or: [oldSpec third notNil and: [(oldSpec third hasOwner: newSpec third) not]]]) ifTrue:			["Clear any prior selection."			(oldSpec third ifNil: [self]) deselect]].	newSpec ifNil: [^ root removeProperty: #selectionSpec].	"Select outer morph of the new selection"	newSpec third == nil		ifTrue: [self select  "first click down"]		ifFalse: [newSpec third select  "subsequent clicks"].	root setProperty: #selectionSpec toValue: newSpec! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/13/2000 20:23'!getMenuBlock	^ nil! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/13/2000 18:44'!showMenu: evt	| exp oldColor oldWidth menu val |	oldColor _ self borderColor.	oldWidth _ self borderWidth.	self borderWidth: 1.	self borderColor: Color red.	World displayWorldSafely.	exp _ exp withNoLineLongerThan: 35.	(val _ self getCurrentValue) ifNotNil: [		exp _ exp,'Value: ',((val withNoLineLongerThan: 35) truncateWithElipsisTo: 300).	].	menu _ "MenuMorph" SyntaxMenuMorph new.	menu title: exp.	menu add: 'OK' target: self selector: #yourself.	menu addLine.	(self getMenuItemsIn: self hostContext) do: [ :each |		each ifNil: [menu addLine] ifNotNil: [			menu 				add: each first				target: each second 				selector: #valueWithPossibleArgs:				argument: {self parsedInClass}		].	].	(self nodeClassIs: MethodNode) ifTrue:		[menu add: 'accept method' target: self selector: #accept.		menu add: 'show code' target: self selector: #showCode].	menu whenDone: [		self borderColor: oldColor.		self borderWidth: oldWidth].	menu 		popUpAt: evt hand position x @ (self pointInWorld: self bounds bottomLeft) y		forHand: evt hand in: World.! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/13/2000 18:35'!addTempVar: aMorph 	| tempHolder ii tt var nn tempMorph |	"know we are a block inside a MethodNode" 	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.						(tt isSyntaxMorph and: [tt parseNode class == MethodTempsNode])					 		ifTrue: [tt] ifFalse: [nil]]				ifTrue: [nil].	nn _ (aMorph allMorphs detect: [:rr | rr class == StringMorph]) contents.	"name"	tempHolder ifNil: [		tempMorph _ owner addRow: #tempVariable on: MethodTempsNode new.		owner addMorph: tempMorph inFrontOf: self.		tempMorph color: tempMorph color darker.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempMorph.		^ true].	tempHolder ifNotNil: [		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		^ true]! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 20:29'!debugger	^ self root valueOfProperty: #debugger! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 20:29'!debugger: x	self root setProperty: #debugger toValue: x! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 20:07'!openInWindow	| window widget sel |	sel _ ''.	self firstSubmorph allMorphs do: [:rr | 			rr class == StringMorph ifTrue: [sel _ sel, rr contents]].	window _ (SystemWindow labelled: 'Tiles for ', self parsedInClass printString, '>>',sel).	widget _ self inAScrollPane.	window		addMorph: widget		frame: (0@0 extent: 1.0@1.0).	window openInWorldExtent: (		self extent + (20@40) min: (Display boundingBox extent * 0.8) rounded	)! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 07:43'!structure	"Print my structure from inner to outer."	^ String streamContents: [:s |		self withAllOwnersDo:			[:m | m isSyntaxMorph ifTrue:				[s cr; print: m parseNode class.				((m nodeClassIs: MessageNode) or: [m nodeClassIs: TileMessageNode]) ifTrue:					[s space; nextPutAll: m parseNode selector key]]]]! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 21:19'!toDo"Biggies...[ ]	Integrate with EToy scriptors	releaseCachedState can discard all morphic structure.[ ]	Options:	Show / hide syntax markers (like [], (), ., :, ;, etc)	No color / color-in-focus / full color	Tiles / textiles / text[ ]	ParsedTextMorph -- looks like text but has all same substructure[ ]	Introduce notion of an UnParsedNode -- maybe a flag in ParseNode	Text -> UnParsed -> Parsed -> CodeGen[ ]	Need DnD evaluator, or some sort of '!!' button on any entity (halo?)	Also inspector / browser[ ]	All the type help we can getDetails ...[ ]	Open up the parse of BraceNodes[ ]	Verify that all pastes are OK[ ]	Show range on blocks even when selected.[ ]	Colors not yet right for colored version.[ ]	Start work on show / hide of syntax markers -- (), [], etc.[ ]	Start work on textiles (grabable entites in 'normal' text)[ ]	Need autoscroll during drag for drop[ ]	Use, eg, shift-drag to move, del to delete[ ]	What about invalid drops -- stick on cursor?System...[ ]	Only keep history 7 deep; option to clear on quit	clear command above spaceLeft[ ]	Compute each page of prefs viewer on demand instead of as now.[ ]	Offer a search command that will gather up all preferences that match a given string (name or help string)Preferences enable: #noTileColor.Preferences disable: #noTileColor.Smalltalk browseAllSelect: [:cm | cm size > 600]SyntaxMorph testAll"! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 20:30'!update: aSymbol	| bingo saveOwner newMorph db |	(db _ self debugger) ifNil: [^super update: aSymbol].	aSymbol == #contents ifTrue: [		saveOwner _ owner.		db removeDependent: self.		markerMorph ifNotNil: [markerMorph delete. markerMorph _ nil].		newMorph _ db createSyntaxMorph.		self delete.		saveOwner addMorph: newMorph.		saveOwner owner setScrollDeltas.		newMorph update: #contentsSelection.	].	aSymbol == #contentsSelection ifTrue: [		markerMorph ifNil: [			markerMorph _ RectangleMorph new.			markerMorph				color: Color transparent;				borderWidth: 2;				borderColor: Color red;				lock.			owner addMorphFront: markerMorph.		].		bingo _ parseNode rawSourceRanges keyAtValue: db pcRange ifAbsent: [nil].		self testForNode: bingo andDo: [ :foundMorph | 			markerMorph				position: foundMorph position;				extent: foundMorph extent.			owner owner scrollIntoView: foundMorph bounds extra: 0.5.			^self		].	].	super update: aSymbol! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 21:12'!noTileColor	^ true! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 08:45'!testAllMethodsOver: methodSize  "MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 900]"	"Add up the total layout area for syntax morphs representing all methods	over the given size.  This is a stress-test for SyntaxMorph layout.	A small value for the total area is also a figure of merit in the presentation	of Squeak source code in general.""Results:	#(69 600 180820874 103700)  11/4	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoffFolded wide receivers, don't center keywords any more.	#(68 600 160033784 127727)  11/9	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoffFolded more messages, dropped extra vertical spacing in blocks.	#(68 600 109141704 137308)  11/10	79% build morphs, 6% get source, 8% layout, 7% parseFolded more messages, dropped extra horizontal spacing.	#(68 600 106912968 132171)  11/10	80% build morphs, ??% get source, 11% layout, 7% parseUnfolded keyword messages that will fit on one line.	#(68 600 96497372 132153)  11/10	81% build morphs, ??% get source, 8% layout, 8% parseAfter alignment rewrite...	#(74 600 101082316 244799)  11/12	76% build morphs, 4% get source, 15% layout, 5% parse"	| tree source biggies morph stats time area |	biggies _ Smalltalk allSelect: [:cm | cm size > methodSize].	stats _ OrderedCollection new.'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'	displayProgressAt: Sensor cursorPoint	from: 1 to: biggies size	during:		[:bar |		biggies withIndexDo:			[:methodRef :i | bar value: i.			Utilities setClassAndSelectorFrom: methodRef in: 				[:aClass :aSelector |				source _ (aClass compiledMethodAt: aSelector) getSourceFromFile.				time _ Time millisecondsToRun:					[tree _ Compiler new 						parse: source 						in: aClass 						notifying: nil.					morph _ tree asMorphicSyntaxUsing: SyntaxMorph.					area _ morph fullBounds area]].			stats add: {methodRef. area. time}]		].	^ {{biggies size.  methodSize. stats detectSum: [:a | a second]. stats detectSum: [:a | a third]}.		(stats asSortedCollection: [:x :y | x third >= y third]) asArray}! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 20:11'!testClass: aClass andMethod: aSelector	| tree source |	source _ (aClass compiledMethodAt: aSelector) getSourceFromFile.	tree _ Compiler new 		parse: source 		in: aClass 		notifying: nil.	(tree asMorphicSyntaxUsing: SyntaxMorph)		openInWindow.! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/13/2000 20:47'!translateColor: aColorOrSymbol	aColorOrSymbol == #comment  ifTrue: [^ Color blue lighter].	aColorOrSymbol == #block  ifTrue: [^ Color transparent].	aColorOrSymbol == #text  ifTrue: [^ Color transparent].	aColorOrSymbol isColor  ifTrue: [^ aColorOrSymbol].	self noTileColor ifTrue: [^ Color paleOrange].	"override"	aColorOrSymbol == #assignment  ifTrue: [^ Color paleGreen].	aColorOrSymbol == #keyword1  ifTrue: [^ Color paleBuff].	aColorOrSymbol == #keyword2  ifTrue: [^ Color paleBuff lighter].	aColorOrSymbol == #cascade  ifTrue: [^ Color paleYellow darker].	aColorOrSymbol == #cascade2  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #literal  ifTrue: [^ Color paleMagenta].	aColorOrSymbol == #message  ifTrue: [^ Color paleYellow].	aColorOrSymbol == #method  ifTrue: [^ Color white].	aColorOrSymbol == #error  ifTrue: [^ Color red].	aColorOrSymbol == #return  ifTrue: [^ Color lightGray].	aColorOrSymbol == #variable  ifTrue: [^ Color paleTan].	aColorOrSymbol == #brace  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #tempVariable  ifTrue: [^ Color paleYellow mixed: 0.75 with: Color paleGreen		"Color yellow lighter lighter"].	aColorOrSymbol == #blockarg2  ifTrue: [			^ Color paleYellow mixed: 0.75 with: Color paleGreen].	"arg itself"	aColorOrSymbol == #blockarg1  ifTrue: [^ Color paleRed].	"container"		"yellow mixed: 0.5 with: Color white"	^aColorOrSymbol! !SyntaxMorph removeSelector: #addTextRow:getMenuBlock:!SyntaxMorph removeSelector: #addTextRow:getMenuBlock:explanation:!SyntaxMorph removeSelector: #borderWidth:!SyntaxMorph removeSelector: #enclosingBlock!SyntaxMorph removeSelector: #enclosingBlocksDo:!SyntaxMorph removeSelector: #enclosingSyntaxSuchThat:do:!SyntaxMorph removeSelector: #explanation:!SyntaxMorph removeSelector: #getExplanation!SyntaxMorph removeSelector: #getMenuBlock:!SyntaxMorph removeSelector: #minBorderWidth:!SyntaxMorph removeSelector: #noTileColor!AlignmentMorph subclass: #SyntaxMorph	instanceVariableNames: 'parseNode markerMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Tile Scriptors'!MessageNode removeSelector: #buildMenuForClass:andSelector:!Smalltalk removeClassNamed: #DebugSyntaxMorph!