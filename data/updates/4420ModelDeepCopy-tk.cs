'From Squeak3.1alpha of 28 February 2001 [latest update: #4361] on 4 October 2001 at 1:57:19 pm'!"Change Set:		ModelDeepCopy-tkDate:			4 October 2001Author:			Ted KaehlerMake DeepCopier>>mapUniClasses stop depending on the number of inst vars in Model and its superclasses.  This is when a copy of a subclass of Player is made.  Remove an error message in DeepCopier checkBasicClasses. Thanks to Jim Benson for discovering this problem."!!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 10/4/2001 13:54'!checkBasicClasses	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 objCls morphCls playerCls |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	(objCls _ self objInMemory: #Object) ifNotNil: [		objCls instSize = 0 ifFalse: [self error: 			'Many implementers of veryDeepCopyWith: are out of date']].	(morphCls _ self objInMemory: #Morph) ifNotNil: [		morphCls superclass == Object ifFalse: [self error: 'Morph', str].		(morphCls instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 				'fullBounds' 'color' 'extension') 			ifFalse: [self error: 'Morph', str]].	"added ones are OK"	str2 _ 'Player|copyUniClassWith: and DeepCopier|mapUniClasses are out of date'.	(playerCls _ self objInMemory: #Player) ifNotNil: [		playerCls class instVarNames = #('scripts' 'slotInfo')			ifFalse: [self error: str2]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 10/4/2001 13:45'!checkVariables	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| meth |	self checkBasicClasses.	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(Smalltalk allClassesImplementing: #veryDeepInner:) do: [:aClass | 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(Smalltalk allClassesImplementing: #veryDeepCopyWith:) do: [:aClass | 		meth _ aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 10/4/2001 13:48'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."| pp oldPlayer newKey newAssoc oldSelList newSelList |"Uniclasses use class vars to hold onto siblings who are referred to in code"pp _ Player class superclass instSize.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+1"	"(pp+2) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+3 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	]."Make new entries in References and point to them."References keys "copy" do: [:playerName |	oldPlayer _ References at: playerName.	(references includesKey: oldPlayer) ifTrue: [		newKey _ (references at: oldPlayer) "new player" uniqueNameForReference.		"now installed in References"		(references at: oldPlayer) renameTo: newKey]].uniClasses "values" do: [:newClass |	oldSelList _ OrderedCollection new.   newSelList _ OrderedCollection new.	newClass selectorsDo: [:sel | 		(newClass compiledMethodAt: sel)	 literals do: [:assoc |			assoc isVariableBinding ifTrue: [				(References associationAt: assoc key ifAbsent: [nil]) == assoc ifTrue: [					newKey _ (references at: assoc value ifAbsent: [assoc value]) 									externalName asSymbol.					(assoc key ~= newKey) & (References includesKey: newKey) ifTrue: [						newAssoc _ References associationAt: newKey.						newClass methodDictionary at: sel put: 							(newClass compiledMethodAt: sel) clone.	"were sharing it"						(newClass compiledMethodAt: sel)							literalAt: ((newClass compiledMethodAt: sel) literals indexOf: assoc)							put: newAssoc.						(oldSelList includes: assoc key) ifFalse: [							oldSelList add: assoc key.  newSelList add: newKey]]]]]].	oldSelList with: newSelList do: [:old :new |			newClass replaceSilently: old to: new]].	"This is text replacement and can be wrong"! !!UnscriptedPlayer methodsFor: 'as yet unclassified' stamp: 'tk 10/4/2001 13:43'!copyUniClassWith: deepCopier		self error: 'oops, copyUniClass sent to an UnscriptedPlayer'! !UnscriptedPlayer removeSelector: #copyUniClass!