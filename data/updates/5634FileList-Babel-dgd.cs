'From Squeak3.5 of ''11 April 2003'' [latest update: #5180] on 27 December 2003 at 12:30:42 pm'!"Change Set:		FileList-Babel-dgdDate:			27 December 2003Author:			Diego Gomez Deck <DiegoGomezDeck@ConsultAr.com>More translatable strings"!!FileList methodsFor: 'file menu action' stamp: 'dgd 12/27/2003 12:18'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response := FillInTheBlank						request: ('New {1} Name?' translated format: {aString translated})						initialAnswer: ('{1}Name' translated format: {aString translated}))		isEmpty ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index := list indexOf: newName.	index = 0 ifTrue: [ending := ') ',newName.		index := list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file menu action' stamp: 'dgd 12/27/2003 12:20'!renameFile	"Rename the currently selected file"	| newName response |	listIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'NewFileName?' translated 					initialAnswer: fileName)		isEmpty ifTrue: [^ self].	newName _ response asFileName.	newName = fileName ifTrue: [^ self].	directory rename: fileName toBe: newName.	self updateFileList.	listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].	listIndex > 0 ifTrue: [fileName _ newName].	self changed: #fileListIndex.! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22'!defaultContents	contents _ list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState _ #FileList.	^ contents! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:24'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected' translated.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' translated format:{type translated}).	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:13'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	brevityFlag ifTrue: [		directory isRemoteDirectory ifTrue: [^ self readServerBrief]].	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read' translated].	(brevityFlag not or: [(fileSize := f size) <= 100000]) ifTrue:		[contents := f contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := f next: 5000.	f close.	contents := 'File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. fileSize. first5000}.	brevityState := #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:11'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read' translated].	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData := s contents.	^ contents := ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. size. hexData}]		ifFalse: [hexData]).! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:09'!readServerBrief	| lString sizeStr fsize ff first5000 parts |	"If file on server is known to be long, just read the beginning.  Cheat badly by reading the fileList string."	listIndex = 0 ifTrue: [^ self].	"Get size from file list entry"	lString := list at: listIndex.	parts := lString findTokens: '()'.	sortMode = #name ifTrue: [sizeStr := (parts second findTokens: ' ') third].	sortMode = #date ifTrue: [sizeStr := (parts first findTokens: ' ') third].	sortMode = #size ifTrue: [sizeStr := (parts first findTokens: ' ') first].	fsize := (sizeStr copyWithout: $,) asNumber.	fsize <= 50000 ifTrue:		[ff := directory oldFileOrNoneNamed: self fullName.		ff ifNil: [^ 'For some reason, this file cannot be read' translated].		contents := ff contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := directory getOnly: 3500 from: fileName.	contents := 'File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 3500 characters...------------------------------------------{3}------------------------------------------... end of the first 3500 characters.' translated format: {fileName. sizeStr. first5000}.	brevityState := #briefFile.   "don't change till actually read"	^ contents.! !