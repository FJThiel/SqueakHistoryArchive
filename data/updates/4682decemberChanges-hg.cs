'From Squeak3.2alpha of 1 November 2001 [latest update: #4599] on 9 January 2002 at 5:08:42 pm'!Object subclass: #ModuleInstaller	instanceVariableNames: 'startModuleRef operation createdModules downloadedModules loadedModules activatedModules progressIndicator progressValue withRecovery '	classVariableNames: ''	poolDictionaries: ''	category: 'Language-Modules-Repositories'!!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/2/2001 01:06'!recompile: force from: oldClass to: aClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	| newClass |	newClass _ aClass.	oldClass == nil ifTrue:[		"newClass has an empty method dictionary		so we don't need to recompile"		Smalltalk changes addClass: newClass.		newClass superclass addSubclass: newClass.		^newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		"No recompilation necessary but we might have added		class vars or class pools so record the change"		Smalltalk changes changeClass: newClass from: oldClass.		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		self showProgressFor: oldClass.		newClass _ self reshapeClass: oldClass to: newClass super: newClass superclass.		Smalltalk changes changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.		"And do the magic become"		self update: oldClass to: newClass.	].	^newClass! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/2/2001 01:05'!recordClass: oldClass replacedBy: newClass	"Keep the changes up to date when we're moving instVars around"	(instVarMap includesKey: oldClass name) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.	].! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 11/5/2001 00:53'!comment: aStringOrText	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText.	Smalltalk changes commentClass: self.	Utilities noteMethodSubmission: #Comment forClass: self theNonMetaClass! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 11/5/2001 00:55'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.	Smalltalk changes commentClass: self theNonMetaClass.	Utilities noteMethodSubmission: #Comment forClass: self theNonMetaClass! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/23/2000 23:08'!removeSelector: selector 	| priorMethod | 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	(self methodDict includesKey: selector) ifFalse: [^ nil].	priorMethod _ self compiledMethodAt: selector.	Smalltalk changes removeSelector: selector class: self		priorMethod: priorMethod		lastMethodInfo: {priorMethod sourcePointer.						(self whichCategoryIncludesSelector: selector)}.	super removeSelector: selector.	self organization removeElement: selector.	self acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange: self name , ' removeSelector: #' , selector]! !!ClassDescription methodsFor: 'compiling' stamp: 'hg 1/2/2002 15:32'!changes	^Smalltalk changes! !!ClassDescription methodsFor: 'compiling' stamp: 'di 3/7/2001 17:08'!compile: code notifying: requestor trailer: bytes 		ifFail: failBlock		elseSetSelectorAndNode: selAndNodeBlock	"Intercept this message in order to remember system changes.	 5/15/96 sw: modified so that if the class does not wish its methods logged in the changes file, then they also won't be accumulated in the current change set.	7/12/96 sw: use wantsChangeSetLogging to determine whether to put in change set"	| methodNode selector newMethod priorMethodOrNil |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	selector _ methodNode selector.	selAndNodeBlock value: selector value: methodNode.	requestor ifNotNil:		["Note this change for recent submissions list"		Utilities noteMethodSubmission: selector forClass: self].	methodNode encoder requestor: requestor.  "Why was this not preserved?"	newMethod _ methodNode generate: bytes.	priorMethodOrNil _ (self methodDict includesKey: selector)		ifTrue: [self compiledMethodAt: selector]		ifFalse: [nil].	Smalltalk changes noteNewMethod: newMethod forClass: self		selector: selector priorMethod: priorMethodOrNil.	self addSelector: selector withMethod: newMethod.	^ newMethod! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 14:34'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ self organization classComment: aString].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	Smalltalk changes commentClass: self.	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'hg 12/16/2001 18:17'!definitionST80	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [			path _ 	Preferences strongModules 						ifTrue: [(self module qualifiedPrefixForName: superclass name andValue: superclass), ' ']						ifFalse: [''].				aStream nextPutAll: path, superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	Preferences modularClassDefinitions 		ifFalse: [			aStream cr; tab; nextPutAll: 'poolDictionaries: ';					store: self sharedPoolsString.			aStream cr; tab; nextPutAll: 'category: ';					store: self module simulatedCategory asString].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'hg 12/16/2001 18:17'!definitionST80: isST80	"Answer a String that defines the receiver."	| aStream path |	isST80 ifTrue: [^ self definitionST80].	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [			path _ 	Preferences strongModules 						ifTrue: [(self module qualifiedPrefixForName: superclass name andValue: superclass), ' ']						ifFalse: [''].				aStream nextPutAll: path , superclass name].	aStream nextPutKeyword: self kindOfSubclass			withArg: self name.	aStream cr; tab; nextPutKeyword: 'instanceVariableNames: '			withArg: self instanceVariablesString.	aStream cr; tab; nextPutKeyword: 'classVariableNames: 'withArg: self classVariablesString.	Preferences modularClassDefinitions 		ifFalse: [			aStream cr; tab; nextPutAll: 'poolDictionaries: ';					store: self sharedPoolsString.			aStream cr; tab; nextPutAll: 'category: ';					store: self module simulatedCategory asString].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'hg 12/16/2001 18:16'!modularDefinition: includeModule	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [			path _ 	Preferences strongModules 						ifTrue: [(self module qualifiedPrefixForName: superclass name andValue: superclass), ' ']						ifFalse: [''].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'module: '.	includeModule ifTrue: [aStream store: self module].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 15:26'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	Smalltalk changes reorganizeClass: self.	^self organization!]style[(10 156 22 80)f1b,f1,f1LReadWriteStream fileIn;,f1! !!Class methodsFor: 'testing' stamp: 'hg 12/16/2001 22:45'!isObsolete	"Return true if the receiver is obsolete."	^(self module localAssocFor: name ifAbsent:[^true])		value ~~ self! !!Class methodsFor: 'class variables' stamp: 'di 3/27/2000 21:54'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol |	aString first isLowercase		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		subclass scopeHas: symbol			ifTrue: [:temp | 					^ self error: aString 						, ' is already used as a variable name in class ' 						, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		Smalltalk changes changeClass: self from: self.		classPool declare: symbol from: Undeclared]! !!Class methodsFor: 'fileIn/Out'!removeFromChanges	"References to the receiver, a class, and its metaclass should no longer be included in the system ChangeSet.	7/18/96 sw: call removeClassAndMetaClassChanges:"	Smalltalk changes removeClassAndMetaClassChanges: self! !!AlicePoolDefiner class methodsFor: 'pool definition' stamp: 'hg 12/9/2001 23:22'!initPool	"Create the pool dictionary if necessary"	| poolName |	"dummy to show up in search for users of this name"	AliceConstants.	poolName _ #AliceConstants.	(Module root definitionFor: poolName ifAbsent: [nil]) ifNotNilDo: [:poolModule |		[(Module root definitionFor: #WonderlandConstants ifAbsent: [nil]) 			definedNames keysAndValuesDo: [:key :value |			 	poolModule defineName: key as: value export: true].		self initPool: (Smalltalk at: poolName)]			on: Warning do: [:ex | ex resume: true]].! !!Compiler methodsFor: 'public access' stamp: 'hg 1/2/2002 14:43'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value providedReceiver scopedReceiver |	providedReceiver _ aContext ifNotNil: [aContext receiver] ifNil: [receiver].	"the only straightforward way to get the compiler to use a certain module for name lookup is by giving the module via the class, here an ad hoc one"	scopedReceiver _ providedReceiver ifNil: [		(Object copy setName: #DummyReceiverClass; module: Module default) new].	class _ scopedReceiver class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].	context == nil		ifTrue: [class addSelector: #DoIt withMethod: method.				value _ scopedReceiver DoIt.				InMidstOfFileinNotification signal ifFalse: [					class removeSelectorSimply: #DoIt.				].				^value]		ifFalse: [class addSelector: #DoItIn: withMethod: method.				value _ scopedReceiver DoItIn: context.				InMidstOfFileinNotification signal ifFalse: [					class removeSelectorSimply: #DoItIn:.				].				^value]! !!Encoder methodsFor: 'private' stamp: 'hg 1/2/2002 14:49'!isDummyClassEncoding		^ class name == #DummyReceiverClass! !!Module methodsFor: 'module name and path' stamp: 'hg 12/9/2001 23:22'!name	| name |	name _ parentModule ifNotNil: [			(parentModule refForNeighborModule: self) ifNotNilDo: [:refToMe |				refToMe name]].	^name ifNil: ['bad parent, #' , self hash printString]		! !!Module methodsFor: 'module name and path' stamp: 'hg 12/9/2001 23:23'!pathTo: module	^(self refForNeighborModule: module) ifNotNilDo: [:refToModule |		self path copyWith: refToModule name]! !!Module methodsFor: 'accessing defined names' stamp: 'hg 11/26/2001 22:35'!doesNotUnderstand: aMessage	"emulate uppercase accessor messages for exports"	self exportedAssocFor: aMessage selector 		ifPresent: [:ass :mod | ^ass value].	self submodulesDo: [:mod |		mod name == aMessage selector ifTrue: [^mod]].	^super doesNotUnderstand: aMessage	! !!Module methodsFor: 'accessing defined names' stamp: 'hg 12/9/2001 23:23'!qualifiedPrefixForName: aName andValue: aValue	"return a string with the messages that need to precede aName in a fully qualified reference to aName from this module. Need aValue to handle multiple definitions" 	| ref first definingModule |	first _ true.	"Check if defined locally."	(self localAssocFor: aName ifAbsent: [nil])		ifNotNilDo: [:assoc | assoc value == aValue ifTrue: [^''] ifFalse: [first _ false]].	ref _ self neighborModuleRefs detect: [:aRef | 			aRef module exportedAssocFor: aName ifPresent: [:assoc :mod | 				assoc value = aValue ifTrue: [definingModule _ mod] ifFalse: [first _ false]].			definingModule notNil] 		ifNone: [			"If weak modules and first found name is correct, then just return blank."			Preferences strongModules ifFalse: [				Module root associationFor: aName ifPresent: [:assoc :mod | 						assoc value = aValue ifTrue: [^'']]].			self error: 'Out of scope reference'].	ref importNames & first ifTrue: [^'']. "no prefix needed for first imported occurrence"	^ref hasAlias 		ifTrue: [ref alias asString]		ifFalse: [ref module pathAsMessages]! !!Module methodsFor: 'changing defined names' stamp: 'hg 1/9/2002 17:06'!redefineName: aString as: value export: exportIt	"Be careful about the identity of the associations used, so as to preserve literal bindings of capitalized variable references. "	| reusedAssoc key putInSmalltalk |	aString first isUppercase ifFalse: [		self notify: 'Global names should be Capitalized, but "', aString asText allBold, '" is not. This could cause various problems. Cancel to avoid creating this global name.'].	key _ aString asSymbol.	self adoptIfUndeclared: key.	reusedAssoc _ self localAssocFor: key ifAbsent: [		ReadOnlyVariableBinding key: key value: value].	"with weak modules, retain compatibility by also putting globals in Smalltalk. "	putInSmalltalk _ Preferences strongModules not and: [Module smalltalk notNil			and: [(value isKindOf: Module) not]].	putInSmalltalk ifTrue: [		Module smalltalk definesName: key ifTrue: [:a | reusedAssoc _ a]].	[reusedAssoc value: value] on: AttemptToWriteReadOnlyGlobal do: [:ex | ex resume: true].	putInSmalltalk ifTrue: [		Module smalltalk addAssoc: reusedAssoc export: false].	self addAssoc: reusedAssoc export: exportIt.! !!Module methodsFor: 'module definition protocol' stamp: 'hg 12/9/2001 20:51'!deltaModuleOn: baseModule alias: aString version: versionOrNil importNames: shouldImport	"use this message to declare that this module has a delta module"	| ref symOrNil |	symOrNil _ aString ifNotNil: [aString asSymbol].	ref _ DeltaModuleReference new 			in: self name: symOrNil version: versionOrNil 			baseModule: baseModule import: shouldImport.	self addNeighborModule: ref export: self shouldExportDeltaModules.	^ref! !!Module methodsFor: 'module definition protocol' stamp: 'hg 12/9/2001 20:56'!externalModule: moduleOrPath alias: aString version: versionOrNil importNames: shouldImport	"use this message to declare that this module depends on an external module."	| ref symOrNil |	symOrNil _ aString ifNotNil: [aString asSymbol].	ref _ ModuleReference new 			name: symOrNil version: versionOrNil 			module: moduleOrPath import: shouldImport.	self addNeighborModule: ref export: self shouldExportExternalModules.	^ref! !!Module methodsFor: 'module definition protocol' stamp: 'hg 12/9/2001 20:57'!parameterModuleWithDefault: moduleOrPathOrNil version: versionOrNil alias: moduleName importNames: shouldImport	"use this message to declare a module parameter. Set its module value to the default."	| ref |	ref _ ModuleParameter new name: moduleName module: moduleOrPathOrNil import: shouldImport defaultModule: moduleOrPathOrNil version: versionOrNil.	self addNeighborModule: ref export: self shouldExportExternalModules.	^ref! !!Module methodsFor: 'module definition protocol' stamp: 'hg 12/9/2001 23:50'!submodule: mod name: submoduleName version: versionOrNil importNames: shouldImport	"use this message to declare a submodule of this module. Note that this just creates an unresolved (Sub)ModuleReference, not any module unless given as an argument"	| ref submodule |	submodule _ mod 		ifNotNil: [mod version: mod verbatimVersion parentModule: self]			"use path instead of module during loading"		ifNil: [self path copyWith: submoduleName].	ref _ self neighborModuleRefs detect: [:r | r name = submoduleName]		ifNone: [			SubmoduleReference new				name: submoduleName version: versionOrNil 				module: submodule import: shouldImport].	self addNeighborModule: ref export: self shouldExportSubmodules.	^ref! !!Module methodsFor: 'module composition' stamp: 'hg 12/17/2001 17:20'!deepSubAndDeltaModules	| deepSubAndDeltaModules |	deepSubAndDeltaModules _ OrderedCollection new.	self deepSubmodulesDo: [:m |		deepSubAndDeltaModules add: m; addAll: m deltaModules].	^deepSubAndDeltaModules! !!Module methodsFor: 'changing module composition' stamp: 'hg 12/9/2001 22:10'!addNeighborModule: moduleReference export: shouldExport	(self hasNeighborModule: moduleReference module) ifTrue: [		self error: 'Neighbor module ', 				moduleReference module pathAsMessages, ' already exists.'].	moduleReference isModuleResolved & moduleReference importNames ifTrue: [		self checkImportForCircularity: moduleReference module].	moduleReference isModuleResolved & moduleReference hasAlias ifTrue: [		self defineName: moduleReference name as: moduleReference module export: shouldExport].	self addNeighborModuleRef: moduleReference.! !!Module methodsFor: 'changing module composition' stamp: 'hg 1/9/2002 16:57'!cleanOutModule	"Removing a module from the image ought to be as easy as removing from parent, but it ain't for compatibility reasons. Do other necessary things here."	| classes |	"classes have special removal needs"	classes _ OrderedCollection new.	self allClassesDo: [:cl | classes add: cl].	(ChangeSet superclassOrder: classes) reversed do: [:cl | 		cl removeFromSystem].		"under weak modules you must clear the names (from Smalltalk)"	Preferences strongModules ifFalse: [		self definedNames keys do: [:name | self removeName: name]].! !!Module methodsFor: 'changing module composition' stamp: 'hg 12/9/2001 23:22'!deltaModuleForBase: baseModule forceCreate: create asActive: markedAsActive	"return the DeltaModule associated with this module that has the given base module. If not found, create one if asked to, otherwise return nil."	| ref |	(self deltaModuleFor: baseModule) ifNotNilDo: [:mod | ^mod].	^create ifTrue: [		ref _ self deltaModuleOn: baseModule alias: nil version: nil importNames: false.		ref module markAsActive: markedAsActive.		ref module]! !!Module methodsFor: 'code analysis' stamp: 'hg 12/16/2001 18:52'!badBindingsWithScheme: bindingScheme	"check that all used globals (global literals in CompiledMethods) will be bound to the exact same association object if recompiled (this is stronger than just the same name or value). Return the bad ones as MethodReferences."	| badRefs ok sup isBad |	badRefs _ OrderedCollection new.	self allClassesDo: [:c |		{c. c class } do: [:cl |			cl methodDict valuesDo: [:cm |				isBad _ (cm literals detect: [:lit | 					lit isVariableBinding and: [lit key notNil] and: [						(c definesName: lit key lookInSuper: true ifTrue: [:a |]) not]]					ifNone: [nil]) notNil.				isBad ifTrue: [					badRefs add: (						MethodReference new							setStandardClass: cl 							methodSymbol: cm selector)]]]].	self allClassesDo: [:c |		sup _ c superclass.		isBad _ ((self definesName: sup name usingScheme: bindingScheme ifTrue: [:ass |			ok _ ass value == sup]) and: [ok]) not.		isBad ifTrue: [			badRefs add: (				MethodReference new					setStandardClass: c 					methodSymbol: #'<classCreation>')]].	^badRefs! !!Module methodsFor: 'code analysis' stamp: 'hg 12/16/2001 19:38'!deepUnresolvedRefs  	^self deepUnresolvedRefsWithScheme: self weakOrStrongBindingScheme ! !!Module methodsFor: 'code analysis' stamp: 'hg 12/16/2001 22:06'!deepUnresolvedRefsWithScheme: bindingScheme	| list n total localList |	total _ 0.	self deepSubmodulesDo: [:mod | total _ total + 1].	list _ OrderedCollection new.	self resetOutOfScopeCache.	'Locating methods with unresolved global references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: total		during:		[:bar | n _ 0.		self deepSubmodulesBottomUpDo: [:mod | 			bar value: (n_ n+1).			localList _ mod localUnresolvedRefsWithScheme: bindingScheme.			list addAll: localList.			"mod setUnresolvedCount: localList size."]].	self zeroOutOfScopeCache.	^list asSortedCollection! !!Module methodsFor: 'code analysis' stamp: 'hg 12/16/2001 19:38'!localUnresolvedRefs  	"all unresolved global references from code in this Module"	"(Module @ #(Squeak Language Modules)) localUnresolvedRefs"	^self localUnresolvedRefsWithScheme: self weakOrStrongBindingScheme ! !!Module methodsFor: 'code analysis' stamp: 'hg 1/2/2002 20:43'!localUnresolvedRefsWithScheme: bindingScheme	"check that all used globals (global literals in CompiledMethods) will be bound to the exact same association object if recompiled (this is stronger than just the same name or value). Return the bad ones as MethodReferences."	| badRefs ok sup isBad |	badRefs _ OrderedCollection new.	self resetOutOfScopeCache.	self allClassesDo: [:c |		{c. c class } do: [:cl |			cl methodDict valuesDo: [:cm |				isBad _ cm literals anySatisfy: [:lit | 					lit isVariableBinding and: [lit key notNil] and: [						((c definesName: lit key lookInSuper: true ifTrue: [:a |]) or: [							(self definesName: lit key usingScheme: bindingScheme 								withCache: OutOfScopeCache 								ifTrue: [:ass | ok _ ass == lit]) and: [ok]]) not]].				isBad ifTrue: [					badRefs add: (						MethodReference new							setStandardClass: cl 							methodSymbol: cm selector)]]]].	self allClassesDo: [:c |		sup _ c superclass.		isBad _ 			((self definesName: sup name usingScheme: bindingScheme				withCache: OutOfScopeCache				ifTrue: [:ass | ok _ ass value == sup]) and: [ok]) not.		(isBad and: [(c isObsolete | sup isNil) not]) ifTrue: [			badRefs add: (				MethodReference new					setStandardClass: c 					methodSymbol: #'<classCreation>')]].	^badRefs! !!Module methodsFor: 'system conversion' stamp: 'hg 12/16/2001 20:12'!declareExternalRefsForSelector: selector inClass: aClass	"for all unresolved globals in the method of the given selector and class, declare the global's defining module as one of my external modules"	| varName definingModule cm lits isDefined |	cm _ aClass compiledMethodAt: selector.	lits _ cm literals.	lits do: [:lit | 		lit isVariableBinding ifTrue: [			varName _ lit key.			isDefined _ 				self definesName: varName 					usingScheme: self weakOrStrongBindingScheme 					withCache: OutOfScopeCache ifTrue: [:a | ].			(isDefined or: [lit value == aClass]) ifFalse: [				definingModule _ Module root moduleDefining: varName.				definingModule ifNotNil: [					"ensure that defining module exports it"					"definingModule exportName: varName."					self ensureExternalModule: definingModule]]]]! !!Module methodsFor: 'system conversion' stamp: 'hg 12/16/2001 21:27'!deepDeclareExternalRefs   	"Root deepDeclareExternalRefs"	| n |	'Declaring all external references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: self deepSubmodules size		during:		[:bar | n _ 0.			self deepSubmodulesDo: [:mod |				mod localDeclareExternalRefsWithScheme: 					self weakOrStrongBindingScheme.				bar value: (n_ n+1)]].	self zeroOutOfScopeCache.! !!Module methodsFor: 'system conversion' stamp: 'hg 12/16/2001 21:20'!localDeclareExternalRefsWithScheme: bindingScheme	"For all classes in this module, identify all references to unresolved globals.	For each of these, call another method to declare the global's defining module."	| refsList |	refsList _ self localUnresolvedRefsWithScheme: bindingScheme.	self resetOutOfScopeCache.	refsList do: [:ref | 		ref methodSymbol == #'<classCreation>' 			ifFalse: [				self					declareExternalRefsForSelector: ref methodSymbol 					inClass: ref actualClass]			ifTrue: [				self ensureExternalModule: 					(Module root moduleDefining: ref actualClass superclass name)]].	self zeroOutOfScopeCache.	^refsList size! !!Module methodsFor: 'system conversion' stamp: 'hg 12/16/2001 19:12'!rewriteSourceForSelector: selector inClass: aClass	"Rewrite the source code for the method in question so that all out-of-scope references are converted to explicit references to the defining module (which is added as an import of this module). This is done by parsing the source with a lenient parser able to find variables in any module.  Then the parse tree is consulted for the source code ranges of each reference that needs to be rewritten and the pattern to which it should be rewritten.  Note that assignments, which will take the form	envt setValueOf: #GlobalName to: ...may generate spurious message due to agglutination of keywords with the value expression."	| code methodNode edits varName definingModule ok definingModules refString |	code _ aClass sourceCodeAt: selector.	methodNode _ Compiler new parse: code in: aClass notifying: nil.	edits _ OrderedCollection new.	methodNode encoder globalSourceRanges do:		[:tuple |   "{ varName. srcRange. store }"		(aClass scopeHas: (varName _ tuple first asSymbol) ifTrue: [:ignored]) ifFalse:			["This is a remote global.  Add it as reference to be edited."			edits addLast: { varName. tuple at: 2. tuple at: 3 }]].	"Sort the edits by source position."	edits _ edits asSortedCollection: [:a :b | a second first < b second first].	edits reverseDo: [:edit | 		varName _ edit first.		"if name isn't defined in this module"		ok _ (self definesName: varName usingScheme: #strong withCache: OutOfScopeCache ifTrue: [:a| ]).		ok ifFalse: [			"look in all modules in the system"			definingModules _ Module root modulesDefining: varName.			definingModules size = 1				ifTrue: [					definingModule _ definingModules first,					"ensure that defining module exports it"					definingModule exportName: varName.					self ensureExternalModule: definingModule. 					"Replace access out of scope with a full-path remote reference"					refString  _ 						self qualifiedPrefixForName: varName 							andValue: (definingModules first definitionFor: varName ifAbsent: []).					code _ code copyReplaceFrom: edit second first								to: edit second last								with: refString, varName]				ifFalse: [					definingModules size > 1 ifTrue: [						Transcript cr; show: varName, ' in ', aClass name, '>>', selector, ' is multiply defined. Reference left intact.']]]].	aClass compile: code classified: (aClass organization categoryOfElement: selector)! !!Module methodsFor: 'name lookup schemes' stamp: 'hg 12/16/2001 19:37'!defaultBindingScheme	^Preferences lenientScopeForGlobals 		ifTrue: [#lenient]		ifFalse: [self weakOrStrongBindingScheme]! !!Module methodsFor: 'name lookup schemes' stamp: 'hg 12/16/2001 16:39'!definesName: varName usingScheme: bindingScheme ifTrue: assocBlock	^ (bindingScheme == #strong			ifTrue: [self strongDefinesName: varName ifTrue: assocBlock]			ifFalse: [self weakDefinesName: varName ifTrue: assocBlock])		or: [bindingScheme == #lenient			and: [self lenientDefinesName: varName ifTrue: assocBlock]]! !!Module methodsFor: 'name lookup schemes' stamp: 'hg 12/16/2001 19:57'!definesName: varName usingScheme: bindingScheme withCache: cache ifTrue: assocBlock	"for efficiency, cache scope lookups" 	| assoc |	assoc _ cache at: varName ifAbsentCache: [:cacheAssoc |		self definesName: varName usingScheme: bindingScheme ifTrue: 			[:foundAssoc | cacheAssoc value: foundAssoc]].	assoc ifNotNil: [assocBlock value: assoc].	^assoc notNil! !!Module methodsFor: 'name lookup schemes' stamp: 'hg 12/16/2001 19:38'!weakOrStrongBindingScheme	"the default binding scheme, ignoring #lenient"	^Preferences strongModules		ifTrue: [#strong]		ifFalse: [#weak]! !!Module class methodsFor: 'virtual hierarchy' stamp: 'hg 12/16/2001 14:37'!fromPath: modulePath forceCreate: create	"return the module with the given path"	"don't be case sensitive but preserve given case when creating names"	| subref |	^modulePath inject: self root into: [:mod :localName |		subref _ mod neighborModuleRefs  			detect: [:ref | 				ref isSubmodule and: [					ref name asLowercase = localName asLowercase]] 			ifNone: [				create ifTrue: [					"creation phase 1: create unresolved reference (i.e. not the module)"					mod submodule: nil name: localName 						version: nil importNames: false]].		(create and: [subref isModuleResolved not]) ifTrue: [			"creation phase 2: resolve the module reference"			subref resolvedModule: Module new].		(subref isNil or: [subref isModuleResolved not]) ifTrue: [^nil].		subref module]! !!Module class methodsFor: 'system conversion' stamp: 'hg 12/9/2001 20:48'!generateSubmodules: moduleList for: mod	"a utility method, see Module>>topLevelModuleList"	| modName submods submod |	moduleList do: [:item |		item class == Array			ifFalse: [modName _ item. submods _ #()]			ifTrue: [modName _ item first. submods _ item second].		submod _ mod localAssocFor: modName ifAbsent: [			(mod submodule: Module new name: modName version: nil importNames: false)				module].		self generateSubmodules: submods for: submod].! !!Module class methodsFor: 'annotations' stamp: 'hg 12/9/2001 23:23'!annotationFor: object at: key	^(Annotations at: object ifAbsent: [nil])		ifNotNilDo: [:dictForObject | dictForObject at: key]! !!ModuleInstaller methodsFor: 'initialize-reset' stamp: 'hg 12/18/2001 12:05'!do: operationSymbol forModuleRef: moduleReference withRecovery: performRecovery	startModuleRef _ moduleReference.	operation _ operationSymbol.	withRecovery _ performRecovery.	self perform: operation! !!ModuleInstaller methodsFor: 'graph computation' stamp: 'hg 12/18/2001 09:36'!allModulesNeededBy: module exceptForNeedsOf: excludedModules	"Answer all modules needed by the given module, applied recursively, not considering the needs of excludedModules. This means all modules that are (indirectly) reachable from the given module. This is a basic breadth-first graph traversal algorithm."		| all remaining current newRemaining neighbors excludedSet |	all _ Set with: module.	excludedSet _ excludedModules asSet.	remaining _ all asOrderedCollection.	[remaining isEmpty] whileFalse: [		current _ remaining removeFirst.		neighbors _ self directlyNeededModulesFor: current.		newRemaining _ (neighbors difference: excludedSet) difference: all.		all addAll: neighbors.		remaining addAll: newRemaining].	^all copyWithout: module! !!ModuleInstaller methodsFor: 'graph computation' stamp: 'hg 12/26/2001 23:59'!compositeLoadingOrderFor: modules	| dependencies |	dependencies _ self loadingDependenciesFor: modules.	^modules topologicallySortedUsing: [:module1 :module2 |		((dependencies at: module1) includes: module2) not]! !!ModuleInstaller methodsFor: 'graph computation' stamp: 'hg 12/18/2001 09:40'!loadingDependenciesFor: modules	| dependencies |	dependencies _ 		modules collect: [:mod | 			mod -> 				((self allModulesNeededBy: mod exceptForNeedsOf: modules)					copyWithoutAll: mod deepSubmodules)].	^Dictionary newFrom: dependencies! !!ModuleInstaller methodsFor: 'graph computation' stamp: 'hg 12/26/2001 23:54'!loadingOrderFor: modules	| dependencies |	dependencies _ self loadingDependenciesFor: modules.	^modules topologicallySortedUsing: [:module1 :module2 |		((dependencies at: module1) includesAnyOf: 			module2 repository compositeModules) not]! !!ModuleInstaller methodsFor: 'defining modules' stamp: 'hg 1/2/2002 13:54'!ensureAllReachableModulesResolved: firstModuleRef	"Ensure that all recursively reachable modules are defined. This is a basic breadth-first graph traversal algorithm. Note that moduleRefs at first are unresolved, i.e. have paths instead of modules in their module slot."		| remaining refToResolve modulesDefined neighborRefsToScan startPath |	remaining _ OrderedCollection new.	"ensure that ALL modules along given path are properly resolved"	startPath _ firstModuleRef module.	1 to: startPath size - 1 do: [:level |		remaining add: (ModuleReference onPath: (startPath first: level))].	remaining add: firstModuleRef.	[remaining isEmpty] whileFalse: [		refToResolve _ remaining removeFirst.		modulesDefined _ self ensureModuleResolved: refToResolve.		neighborRefsToScan _ self refsToScanFrom: modulesDefined.		remaining addAll: neighborRefsToScan]! !!ModuleInstaller methodsFor: 'defining modules' stamp: 'hg 12/26/2001 23:10'!ensureModuleResolved: moduleRef	"ensure that the Module object for the moduleRef is in the image and correctly defined. First ask the moduleRef to find a matching module for its path and version. If none, I first need to ensure that the module definition file is in the cache, then create the Module object from the definition.	Return all modules that were defined--note that a composite repository may define more than one module at once.	If module is created here, then assume it has a standalone repository since it must be loaded as itself, if it were part of another repository then it would have to be loaded together with it."	| module modulesDefined definingRepository |	(moduleRef isModuleResolved or: [moduleRef findModuleFromPathAndVersion notNil]) 		ifTrue: [^#()].	module _ moduleRef createModuleFromPathAndVersion.	module repository defineFromDirectoryStructure.	definingRepository _ module repository standaloneRepository.	self note: 'Loading definition for module at ', 				definingRepository module pathAndVersion printString,'.'.	modulesDefined _ definingRepository defineModuleFromFile.	"mark that modules were created"	createdModules addAll: modulesDefined.	moduleRef isModuleResolved ifFalse: [self error: 'Loading module definition failed.'].	^modulesDefined				! !!ModuleInstaller methodsFor: 'defining modules' stamp: 'hg 12/26/2001 22:53'!refsToScanFrom: modules 	^(modules inject: #() into: [:total :module | total, module neighborModuleRefs]) asIdentitySet.! !!ModuleInstaller methodsFor: '(un)loading' stamp: 'hg 12/17/2001 17:31'!ensureAllModulesLoaded	"load the contents for all modules that need to be loaded"	| totalSize modulesToLoad |	modulesToLoad _ self modulesToLoad.	totalSize _ modulesToLoad inject: 0 into: [:subTotal :module |		subTotal + module repository sizeOfContentsFiles].	self 		phase: 'Loading necessary modules into image.'		progressTotal: totalSize.	(self loadingOrderFor: modulesToLoad) do: [:module |		self loadContentsForModule: module]! !!ModuleInstaller methodsFor: '(un)loading' stamp: 'hg 1/9/2002 16:57'!unloadModule: module	"Remove module from the image. This ought to be as easy as removing from parent, but it ain't for compatibility reasons"	module deepSubmodulesBottomUpDo: [:mod | 		mod cleanOutModule.		mod parentModule removeNeighborModule: mod.		mod version: nil parentModule: nil]! !!ModuleInstaller methodsFor: '(de)activating' stamp: 'hg 12/18/2001 09:47'!ensureAllModulesActive	"Ensure that all necessary modules are active. Note that this is not symmetric with ensureDeactivate, external, non-submodules may be activated."	| modulesToActivate |	modulesToActivate _ self allModulesNeededBy: self startModule exceptForNeedsOf: #().	modulesToActivate _ modulesToActivate reject: [:module | module isActive].	self		phase: 'Preparing to activate all needed modules.'		progressTotal: modulesToActivate size.	self switchModules: modulesToActivate beActive: true.	activatedModules _ modulesToActivate.	self note: 'All the needed modules active.'.! !!ModuleInstaller methodsFor: 'utilities' stamp: 'hg 12/18/2001 12:08'!gracefullyExecute: aBlock	"wrap the execution of the block in progress notification and error handling routines"	self showProgressDuring: [		[[aBlock value. self done] 			on: Warning do: [:ex | ex resume: true]		 ] on: Error do: [:ex |			withRecovery 				ifTrue: [					[ex signal] ensure: [						self revertGracefullyToStableState.						self done]]				ifFalse: [ex signal]]]! !!ModuleInstaller class methodsFor: 'instance creation' stamp: 'hg 12/18/2001 12:10'!do: selector forModuleRef: moduleReference	^self new do: selector forModuleRef: moduleReference withRecovery: true! !!ModuleInstaller class methodsFor: 'instance creation' stamp: 'hg 12/18/2001 12:10'!do: selector forModuleRef: moduleReference withRecovery: withRecovery	^self new do: selector forModuleRef: moduleReference withRecovery: withRecovery! !!ModuleInstaller class methodsFor: 'debugging' stamp: 'hg 12/18/2001 12:12'!testFullyInstallFromPath: pathAndVersion	^self do: #fullyInstallModule forModuleRef: 			(ModuleReference onPath: pathAndVersion)		withRecovery: false! !!ModuleRefactorer methodsFor: 'public' stamp: 'hg 1/2/2002 15:47'!runRefactorings	"Trigger the whole set of refactorings in this class."	Preferences strongModules ifTrue: [		Smalltalk newChanges: 			(ChangeSet basicNewNamed: self class name, ' Reorganization')].	self ensurePrerequisiteVersions.	self 		putAwayUnknownModules;		moveModules; 		reorderModules.	self moveGlobalsToModules.	self installModuleDeclarations.	self refactorClasses.	self convertPools.	self removeModules.	self installRepositories.		self incrementVersions.		Preferences strongModules 		ifTrue: [			Module root rewriteIndirectRefs.			Smalltalk newChanges: (ChangeSorter existingOrNewChangeSetNamed: 'PostReorganization').			ChangeSorter initialize]! !!ModuleRefactorer methodsFor: 'moving modules' stamp: 'hg 12/9/2001 20:48'!moveModule: mod toPath: path	| ref afterParentPath afterParent |	(Module fromPath: path forceCreate: false) ifNotNil: [		self error: 'Module at target path already exists'].	ref _ mod parentModule removeNeighborModule: mod.	afterParentPath _ path allButLast.	afterParent _ Module fromPath: afterParentPath forceCreate: true.	^(afterParent 		submodule: mod name: path last 		version: ref specifiedVersion importNames: ref importNames)			module! !!ModuleRefactorer methodsFor: 'moving modules' stamp: 'hg 12/9/2001 23:23'!moveModules		| moveList |	moveList _ self newPlacesForModules.	moveList pairsDo: [:before :after |		(Module fromPath: before forceCreate: false) ifNotNilDo: [:mod |			self moveModule: mod toPath: after]].		! !!ModuleReference methodsFor: 'resolving' stamp: 'hg 12/16/2001 23:26'!createModuleFromPathAndVersion 	Module fromPath: self specifiedPath forceCreate: true.	self isModuleResolved ifFalse: [		self findModuleFromPathAndVersion].	^self module! !!ModuleReference methodsFor: 'resolving' stamp: 'hg 12/14/2001 23:43'!findModuleFromPathAndVersion 	"this is just preliminary"	^Module @ self specifiedPath ifNotNilDo: [:mod |		((mod isKindOf: Module) and: [				self acceptAnyVersion or: [self versionIdenticalTo: mod version]]) 			ifTrue: [self resolvedModule: mod]]! !!ModuleReference methodsFor: 'resolving' stamp: 'hg 12/14/2001 23:26'!resolvedModule: mod	"resolve my reference to point to the given module"	mod verbatimVersion ifNil: [		mod version: self specifiedVersion parentModule: Module @ self specifiedPath allButLast].	module _ mod! !!ModuleReference methodsFor: 'printing' stamp: 'hg 12/14/2001 23:37'!explorerContents	^self isModuleResolved 		ifTrue: [module moduleExplorerContents]		ifFalse: [module explorerContents]! !!Parser methodsFor: 'error correction' stamp: 'hg 1/2/2002 15:08'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection temp binding globalToo |	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^ encoder undeclared: proposedVariable].	temp _ proposedVariable first isLowercase.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: proposedVariable) notNil])		ifTrue: [^ encoder global: binding name: proposedVariable].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleVariablesFor: proposedVariable.	aStream _ WriteStream on: (String new: 200).	globalToo _ 0.	aStream nextPutAll: 'declare ' ,		(temp ifTrue: ['temp']			ifFalse: [encoder isDummyClassEncoding					ifTrue: ['Global in Module...']					ifFalse: [globalToo _ 1.  'Class Variable']]); cr.	globalToo = 1 ifTrue: [aStream nextPutAll: 'declare Global in Module...'; cr].	alternatives do:		[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (globalToo + 1) with: (globalToo + alternatives size + 1)))		startUpWithCaption:(('Unknown variable: ', proposedVariable, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedVariable size).	(choice = 0) | (choice > (globalToo + alternatives size + 1))		ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice =1 ifTrue:			[temp ifTrue: [^ self declareTempAndPaste: proposedVariable]				ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: [^ self declareGlobal: proposedVariable]					ifFalse: [^ self declareClassVar: proposedVariable]]].	(choice = 2) & (globalToo = 1) ifTrue: [^ self declareGlobal: proposedVariable].	"Spelling correction"	self substituteWord: (alternatives at: choice-1-globalToo)			wordInterval: spot			offset: 0.	^ encoder encodeVariable: (alternatives at: choice-1-globalToo)! !!Parser methodsFor: 'error correction' stamp: 'hg 1/2/2002 15:10'!declareGlobal: name	| sym path module pathString |	sym _ name asSymbol.	pathString _ FillInTheBlank request: 'Path to the module where ', name, ' will be defined:'					initialAnswer: encoder classEncoding module path literalPrintString.	path _ Compiler evaluate: pathString.	module _ Module @ path.	module ifNil: [^self error: 'Module at ', path literalPrintString, ' not found.'].	module defineName: sym as: nil export: true.	^ encoder encodeVariable: sym! !!Repository methodsFor: 'accessing' stamp: 'hg 12/9/2001 23:23'!parentRepository	^self module parentModule ifNotNilDo: [:parentMod |		parentMod repository]! !!Repository methodsFor: 'accessing' stamp: 'hg 12/15/2001 10:44'!subrepositories	"need to handle repository cache here"	^self module submodules collect: [:mod |		self isCache 			ifFalse: [mod repository] 			ifTrue: [mod repository cache]]! !!Repository methodsFor: 'fileIn/Out' stamp: 'hg 12/17/2001 17:47'!compositeContentsOn: aStream	"take various measures to ensure that necessary preconditions are met."	| n compositeModulesInOrder |	self standaloneCheck.	self ensurePreconditionsForUpload.	compositeModulesInOrder _ 		ModuleInstaller new compositeLoadingOrderFor: self compositeModules.		'Uploading module ', self module pathAsMessages, ' into repository...'		displayProgressAt: Sensor cursorPoint 		from: 0 to: self compositeModules size		during:		[:bar | n _ 0.		aStream 			timeStamp; cr; cr.			compositeModulesInOrder do: [:mod |				aStream cr; cr; nextChunkPut: '#nextCompositeModule'; cr;					nextChunkPut: (self prefixForModule: mod); cr; cr.				mod repository contentsOn: aStream.				bar value: (n_ n+1).				aStream flush]]! !!Repository methodsFor: 'fileIn/Out' stamp: 'hg 12/26/2001 20:28'!fileInChunks: aStream into: topModule chunkBlock: aBlock	"load a file holding code to be evaluated with module as receiver"	| isCategory string |	'Filing in module ', topModule pathAsMessages, '...'		displayProgressAt: Sensor cursorPoint		from: 0 to: aStream size		during:		[:bar |		[[aStream atEnd] whileFalse: [			bar value: aStream position.			aStream skipSeparators.			[ 				isCategory _ aStream peekFor: $!!.				string _ aStream nextChunk.				aBlock value: string value: aStream value: isCategory			]	on: Warning				do: [ :ex | ex resume: true].			aStream skipStyleChunk]		] ensure: [aStream close]].! !!Repository methodsFor: 'testing' stamp: 'hg 11/17/2001 18:51'!fileExists: name	^self directory includesKey: name! !!Repository methodsFor: 'testing' stamp: 'hg 12/15/2001 10:43'!isCache	"this is not foolproof but should suffice"	^self module repository ~~ self! !!Repository methodsFor: 'installer support' stamp: 'hg 11/17/2001 18:53'!checkCompleteModuleContentsOK	"in future, this could be image segment OR source files"	^self isImplicit or: [		self checkRepositoryExists and: [			self checkContentsFilesExist and: [self checkContentsFilesOK]]]! !!Repository methodsFor: 'installer support' stamp: 'hg 11/17/2001 18:53'!checkContentsFilesExist	^self namesOfContentsFiles allSatisfy: [:name | self fileExists: name]! !!Repository methodsFor: 'installer support' stamp: 'hg 12/16/2001 13:13'!checkDefinitionFileOK	| name |	name _ self moduleFileNameForExtension: self moduleDefinitionExtension.	^self directory exists and: [self directory includesKey: name] and: [		true "determine verification strategy later"]! !!Repository methodsFor: 'installer support' stamp: 'hg 12/16/2001 22:46'!detectImproperlyDeclaredModules: modulesToCheck	| unresolved n incomplete |	'Detecting incomplete module dependencies...'		displayProgressAt: Sensor cursorPoint		from: 0 to: modulesToCheck size		during:		[:bar | n _ 0.			incomplete _ modulesToCheck select: [:mod |				unresolved _ 					mod localUnresolvedRefsWithScheme: 						mod weakOrStrongBindingScheme.				bar value: (n_ n+1).				unresolved isEmpty not]].	^incomplete! !!Repository methodsFor: 'installer support' stamp: 'hg 11/17/2001 18:55'!ensureContentsFilesExist	"determine strategy later"	^self checkContentsFilesExist ifFalse: [		self error: 'The module contents files do not exist for module ', 			module path printString]! !!Repository methodsFor: 'installer support' stamp: 'hg 11/17/2001 18:54'!ensureContentsFilesOK	"determine strategy later"	^(self checkContentsFilesExist and: [self checkContentsFilesOK]) "..." ifFalse: [		self error: 'The module contents files are not OK for module ', 			module path printString]! !!Repository methodsFor: 'installer support' stamp: 'hg 12/16/2001 22:35'!ensureModuleDependenciesDeclared: modules	| badModules stillBadModules |	badModules _ self detectImproperlyDeclaredModules: modules.	badModules isEmpty ifTrue: [^self].	self notify: 'At least one module does not completely declare its module dependencies. Without these a module may not load properly. Proceed to have all necessary dependecies declared automatically, or cancel to do it manually.'.	badModules do: [:mod | 		mod localDeclareExternalRefsWithScheme: 			mod weakOrStrongBindingScheme].	stillBadModules _ self detectImproperlyDeclaredModules: modules.	stillBadModules isEmpty ifTrue: [^self].	self notify: 'The automatic declaration of module dependencies did not completely succeed. Proceed to go ahead anyway, otherwise cancel.'.! !!Repository methodsFor: 'installer support' stamp: 'hg 12/16/2001 22:34'!ensurePreconditionsForUpload	self ensureDirectory.! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 12/15/2001 11:18'!deepDeleteDirectory	self directory exists ifFalse: [^self].	self subrepositories do: [:sub |		sub deepDeleteDirectory].	self directory fileNames do:[:fn |		self directory deleteFileNamed: fn ifAbsent:[]].	self parentRepository ifNotNilDo: [:parent |		parent directory deleteDirectory: self directory localName].! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 11/26/2001 22:42'!defineModule: mod		| fileName result |	fileName _ mod repository moduleFileNameForExtension: self moduleDefinitionExtension.	self fileInChunks: (self oldStreamNamed: fileName) 		into: mod 		chunkBlock: [:string :stream :isCategory |			result _ Compiler evaluate: string for: mod logged: false.			(result isKindOf: Array) ifTrue: [				self metaPrerequisites: result]].! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 12/15/2001 10:25'!deleteDirectoryAndFiles	self directory fileNames do:[:fn |		self directory deleteFileNamed: fn ifAbsent:[]].	self parentRepository ifNotNilDo: [:parent |		parent directory deleteDirectory: self directory localName].! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 12/16/2001 22:36'!ensureDeepUpload	"take various measures to ensure that necessary preconditions are met."	self isStandalone ifTrue: [		self ensurePreconditionsForUpload.		self ensureModuleDependenciesDeclared: self compositeModules.		self storeModuleComposite].	self subrepositories do: [:rep | rep ensureDeepUpload] ! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 1/2/2002 16:08'!loadCompositeModuleContentsInto: topModule	| targetModule value |	"self notify: 'Warning: You are about to load the contents of module ', topModule pathAsMessages asText allBold, ' from the repository. Any unsaved contents in this module will be lost.'."		Smalltalk newChanges: (ChangeSorter existingOrNewChangeSetNamed: 'Module Loading').	ChangeSorter initialize.	self namesOfContentsFiles do: [:name |		targetModule _ topModule.		"make name lookup be done in the scope of the target module"		Module scopeModuleInstance: targetModule.		self fileInChunks: (self oldStreamNamed: name) into: topModule chunkBlock: 			[:string :stream :isClassCategory |				value _ Compiler evaluate: string for: targetModule logged: false.								"Class category chunk followed by method definition"				isClassCategory ifTrue: [value scanFrom: stream].				"tag indicating that new (composite) module should receive definitions, 				 followed by expression defining the new receiver"				value = #nextCompositeModule ifTrue: [					targetModule allClassesDo: [ :cl | 						cl removeSelectorSimply: #DoIt; 						removeSelectorSimply: #DoItIn:].					Module scopeModuleInstance: topModule.					targetModule _ 						Compiler evaluate: stream nextChunk 							for: topModule logged: false.					Module scopeModuleInstance: targetModule]].		Module scopeModuleInstance: nil.		targetModule allClassesDo: [ :cl | 			cl removeSelectorSimply: #DoIt; 			removeSelectorSimply: #DoItIn:].		topModule class 			removeSelectorSimply: #DoIt; 			removeSelectorSimply: #DoItIn:.	].	Smalltalk newChanges: (ChangeSorter existingOrNewChangeSetNamed: 'PostLoading').	ChangeSorter initialize.	"answer the modules that were loaded"	^self compositeModules ! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 11/26/2001 20:45'!loadModuleContents	"load the files that define the contents of this module"	^self isStandalone 		ifFalse: [self standaloneRepository loadModuleContents]		ifTrue: [self loadCompositeModuleContentsInto: self module]! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 12/26/2001 20:30'!storeModule: mod	"store the files that define the given module"	| defStream contentsStream |	[defStream _ 		self streamNamed: 			(mod repository moduleFileNameForExtension: self moduleDefinitionExtension).	mod repository definitionOn: defStream.	] ensure: [defStream close].	[contentsStream _ 		self streamNamed: 			(mod repository moduleFileNameForExtension: self moduleContentsExtension).	mod repository contentsOn: contentsStream.	] ensure: [contentsStream close].! !!Repository methodsFor: 'up- and downloading' stamp: 'hg 12/26/2001 20:30'!storeModuleComposite	"store the files that define this (composite) module"	| defStream contentsStream |	[defStream _ 		self streamNamed: 			(self moduleFileNameForExtension: self moduleDefinitionExtension).	self compositeDefinitionsOn: defStream.	] ensure: [defStream close].	[contentsStream _ 		self streamNamed: 			(self moduleFileNameForExtension: self moduleContentsExtension).	self compositeContentsOn: contentsStream.	] ensure: [contentsStream close].! !!Repository methodsFor: 'system conversion' stamp: 'hg 1/2/2002 16:18'!importChangesFrom: aStream into: mod	| deltaModule deltaClass resultWithinModule resultPath result parseTree |	Smalltalk newChanges: (ChangeSorter existingOrNewChangeSetNamed: 'Import Changes into ', mod pathAsMessages).	ChangeSorter initialize.		self fileInChunks: aStream into: mod chunkBlock: [:string :stream :isClassCategory |		isClassCategory 			ifTrue: [	"a class category chunk followed by a method"				result _ Compiler evaluate: string for: mod logged: false.				(result isKindOf: ClassCategoryReader) ifTrue: [					resultPath _ result targetClass module path.					resultWithinModule _ mod path = 							(resultPath first: (mod path size min: resultPath size)).					resultWithinModule ifFalse: [						deltaModule _ 							mod deltaModuleForBase: result targetClass module 								forceCreate: true asActive: false.						deltaClass _ deltaModule deltaClassFor: result targetClass forceCreate: true.						result setClass: deltaClass]].				"Class category chunk followed by method definition"				result scanFrom: stream]			ifFalse: [	"could be many things sent to a class"				result _ Compiler evaluate: string for: mod logged: false.				parseTree _ 					Compiler new 						compileNoPattern: string in: mod class 						context: nil notifying: nil ifFail: [].				]].	Smalltalk newChanges: (ChangeSorter existingOrNewChangeSetNamed: 'PostImport').	ChangeSorter initialize.! !!Repository methodsFor: 'repository variants' stamp: 'hg 12/17/2001 17:22'!compositeModules	"Return those modules that should be stored in this repository."	^self isStandalone 		ifFalse: [self standaloneRepository compositeModules]		ifTrue: [			self module deepSubAndDeltaModules select: [:mod | 				mod repository standaloneRepository = self module repository]]! !!FileRepository methodsFor: 'accessing' stamp: 'hg 12/9/2001 23:22'!parentRepository	^super parentRepository ifNotNilDo: [:parent | parent cache]! !!RemoteRepository methodsFor: 'fileIn/Out' stamp: 'hg 11/17/2001 18:43'!oldStreamNamed: onlyTheFileName	"return a stream for reading from the repository I represent"	^self cache oldStreamNamed: onlyTheFileName! !!RemoteRepository methodsFor: 'up- and downloading' stamp: 'hg 11/26/2001 20:45'!loadCompositeModuleContentsInto: mod	^self cache loadCompositeModuleContentsInto: mod! !!RemoteRepository methodsFor: 'installer support' stamp: 'hg 11/17/2001 18:59'!ensureContentsFilesExist	self namesOfContentsFilesToDownload do: [:name |		self cacheFileNamed: name].! !!RemoteRepository methodsFor: 'installer support' stamp: 'hg 11/17/2001 18:51'!namesOfContentsFilesToDownload	^self namesOfContentsFiles reject: [:name |		self cache fileExists: name]! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 11/7/2000 11:24'!mapClass: newClass origName: originalName	"See if instances changed shape.  If so, make a fake class for the old shape and return it.  Remember the original class name."	| newName oldInstVars fakeClass |	newClass isMeta ifTrue: [^ newClass].	newName _ newClass name.	(steady includes: newClass) & (newName == originalName) ifTrue: [^ newClass].		"instances in the segment have the right shape"	oldInstVars _ structures at: originalName ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	fakeClass _ Object subclass: ('Fake37', originalName) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	Smalltalk changes removeClassChanges: fakeClass name.	"reduce clutter"	^ fakeClass! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/25/2001 17:04'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotation! !!CodeHolder methodsFor: 'commands' stamp: 'sw 12/28/2000 18:09'!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self setClassAndSelectorIn: [:cl :sel |		cl ifNotNil:			[Smalltalk changes adoptSelector: sel forClass: cl.			self changed: #annotation]]! !!Browser methodsFor: 'system category functions' stamp: 'hg 12/15/2001 10:21'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |	self okToChange ifFalse: [^ self classNotFound].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self classNotFound].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ self potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self classNotFound].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Module root definitionFor: (classNames at: index) asSymbol ifAbsent: [nil]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!SubmoduleReference methodsFor: 'printing' stamp: 'hg 10/10/2001 20:32'!storeOn: aStream	"write a message string that will create myself if sent to a module"	| moduleObjectCreator |	"Keep flag: messages with used selectors here so that this code will be updated if the selectors are changed."	self flag: #submodule:name:version:importNames: .	moduleObjectCreator _ self module repository isStandalone 		ifTrue: ['nil']		ifFalse: ['(', self module class printString, ' new)']. 	aStream 		nextPutAll: 'submodule: ', moduleObjectCreator "path literalPrintString"; 		nextPutAll: ' name: '; print: self name;		nextPutAll: ' version: '; print: specifiedVersion;		nextPutAll: ' importNames: '; print: self importNames.! !!SystemDictionary methodsFor: 'class names' stamp: 'ar 3/1/2001 22:27'!removeClassFromSystem: aClass logged: aBool	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	aBool ifTrue:[		aClass wantsChangeSetLogging ifTrue:			[SystemChanges noteRemovalOf: aClass].		aClass acceptsLoggingOfCompilation ifTrue:			[Smalltalk logChange:  'Smalltalk removeClassNamed: #', aClass name].	].	SystemOrganization removeElement: aClass name.	self removeFromStartUpList: aClass.	self removeFromShutDownList: aClass.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache! !!SystemDictionary methodsFor: 'class names' stamp: 'di 2/3/1999 22:33'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	| oldref i |	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	SystemChanges renameClass: aClass as: newName.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache! !!TransitionalSmalltalkModule class methodsFor: 'class initialization' stamp: 'hg 12/9/2001 20:48'!setup	"install instance of me as Smalltalk submodule of Root"	^(Module root 		submodule: Module new 		name: #OldstyleSmalltalk 		version: nil 		importNames: false)			module.! !Utilities class removeSelector: #inspectGlobals!RemoteRepository removeSelector: #ensureCompleteModuleContentsInCache!RemoteRepository removeSelector: #loadModuleContentsInto:!FileRepository removeSelector: #ensureDeepUpload!Repository removeSelector: #loadModuleContentsInto:!ModuleReference class removeSelector: #fromPath:!ModuleInstaller removeSelector: #willLoadModule:!Module removeSelector: #changes:!Module removeSelector: #createChanges!Module removeSelector: #declareExternalRefs!Module removeSelector: #newChanges:!Module removeSelector: #scopedLookup:inClass:cachedIn:!DeltaClass class removeSelector: #checkModuleInClasses!