'From Squeak 2.1 of June 30, 1998 on 5 August 1998 at 2:31:35 pm'!ReferenceStream subclass: #DeepCopyStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!!DeepCopyStream commentStamp: 'tk 8/5/1998 14:31' prior: 0!A special kind of ReferenceStream for in-memory copying.  veryDeepCopy uses me.  I always have a DummyStream in byteStream.  Mainly I block the tracing of Colors by testing in WriteInstance.  This keeps Colors out of the references dictionary and saves time.  !!DeepCopyStream methodsFor: 'as yet unclassified' stamp: 'tk 8/5/1998 14:29'!writeInstance: anObject    "PRIVATE -- Write the contents of an arbitrary instance."	anObject class == Color ifTrue: [^ self].	"do not trace or write.  Old color object will be used."	anObject class == TransparentColor ifTrue: [^ self].			"do not trace or write.  Old color object will be used."    ^ anObject storeDataOn: self! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/5/1998 14:31'!veryDeepCopy: anObject	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream and storeDataOn:"	| dummy refs class new uniClasses uc old |	dummy _ DeepCopyStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"  		"Note that dummy is a ReferenceStream.  instVarInfo: will not be called."	dummy nextPut: anObject.	"Do the traverse of the tree"	uniClasses _ Dictionary new.	"UniClass -> new UniClass"	renamed _ Dictionary new.	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | 		class _ each class.		class == Metaclass ifTrue: ["object is a metaclass" self error: 'can''t copy a class'].		class isMeta 			ifTrue: ["a class" self error: 'can''t copy a class']			ifFalse: ["an instance" class isSystemDefined 				ifFalse: [uc _ uniClasses at: class ifAbsent: [nil].					uc ifNil: [uniClasses at: class put: (uc _ each copyUniClass)]]]].	uniClasses do: [:uniCls | 		dummy nextPut: uniCls scripts].	"more objects to veryDeepCopy"	refs associationsDo: [:assoc | 		(uniClasses includesKey: assoc key class)			ifFalse: [(#(Form Color StrikeFont) includes: assoc key class name)				ifFalse: [assoc key class == DiskProxy					ifFalse: [assoc value: assoc key clone]					ifTrue: [assoc value: nil "assoc key comeFullyUpOnReload"]]						"a DiskProxy will never be looked up -- its not in any field.						Old value of field is used."				ifTrue: [assoc value: assoc key]]		"Don't copy Forms, Colors"			ifTrue: [old _ assoc key.				assoc value: (new _ (uc _ uniClasses at: assoc key class) new).				1 to: uc instSize do: [:ii | new instVarAt: ii put: (old instVarAt: ii)]]].		"Watch out for classes that do extra things in copy but not in shallowCopy"	self veryDeepRectify: refs.	"rehashes Sets and Dictionaries"	self veryDeepClassVars: refs.		ScannedObject _ refs.	"debug"	^ refs at: anObject! !