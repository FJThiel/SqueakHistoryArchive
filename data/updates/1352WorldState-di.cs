'From Squeak 2.4c of May 10, 1999 on 20 July 1999 at 7:55:44 am'!"Change Set:		WorldStateDate:			19 July 1999Author:			Dan IngallsRefactors MorphicProject into the old simple Project, and a new class WorldState.This makes worlds within worlds work better, since only one project is involved."!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime '	classVariableNames: 'DisableDeferredUpdates MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Support'!!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/19/1999 16:48'!canvas: x	project canvas: x.! !!PasteUpMorph methodsFor: 'project' stamp: 'di 7/19/1999 14:37'!beWorldForProject: aProject	self privateOwner: nil.	project _ WorldState new initForWorld.	self addHand: HandMorph new.	self setProperty: #automaticPhraseExpansion toValue: true.	self startSteppingSubmorphsOf: self! !!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'di 7/19/1999 15:48'!newWorldForProject: projectOrNil 	"Return a new pasteUpMorph configured as a world (ie project notNil).	projectOrNil is no longer used."	^ self new initForProject: WorldState new! !!Project methodsFor: 'initialization' stamp: 'di 7/19/1999 14:46'!initMorphic	"Written so that Morphic can still be removed."	Smalltalk verifyMorphicAvailability ifFalse: [^ nil].	world _ PasteUpMorph newWorldForProject: self.	changeSet _ ChangeSet new initialize.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ CurrentProject! !!Project methodsFor: 'initialization' stamp: 'di 7/19/1999 15:00'!installPasteUpAsWorld: pasteUpMorph	"(ProjectViewMorph newMorphicProjectOn: aPasteUpMorph) openInWorld."	world _ pasteUpMorph beWorldForProject: self! !!Project methodsFor: 'accessing' stamp: 'di 7/19/1999 15:06'!name	changeSet == nil ifTrue: [^ 'no name'].	^ changeSet name! !!Project class methodsFor: 'instance creation' stamp: 'di 7/19/1999 14:55'!newMorphic	"ProjectView open: Project newMorphic"	^ self basicNew initMorphic! !!Project class methodsFor: 'instance creation' stamp: 'di 7/19/1999 14:56'!newMorphicConstruction	"ProjectView open: Project newMorphicConstruction"	| aProject |	aProject _ self newMorphic.	aProject world configureForConstruction.	^ aProject! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'di 7/19/1999 14:52'!newMorphicConstruction	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphicConstruction.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'di 7/19/1999 14:57'!newMorphicProject	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphic.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'di 7/19/1999 14:55'!newMorphicProjectOn: aPasteUpOrNil	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphic.	aPasteUpOrNil ifNotNil: [proj installPasteUpAsWorld: aPasteUpOrNil].	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ScreenController methodsFor: 'menu messages' stamp: 'di 7/19/1999 15:01'!openConstructionProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView openAndEnter: Project newMorphicConstruction! !!ScreenController methodsFor: 'menu messages' stamp: 'di 7/19/1999 14:56'!openMorphicProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView open: Project newMorphic.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 7/19/1999 15:44'!hasMorphic	"Answer whether the Morphic classes are available in the system (they may have been stripped, such as by a call to Smalltalk removeMorphic"	^ ((Smalltalk at: #Morph ifAbsent: [nil]) isKindOf: Class)! !!WorldState methodsFor: 'initialization' stamp: 'di 6/14/1999 16:42'!initForWorld	hands _ Array new.	damageRecorder_ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/10/1999 22:47'!displayWorldSafely	"Update this world's display and keep track of errors during draw methods."	| oldHandler errCtx errMorph |	oldHandler _ Processor activeProcess errorHandler.	[self displayWorld] ifError:[:err :rcvr|		"Handle a drawing error"		errCtx _ thisContext.		[errCtx _ errCtx sender.		"Search the sender chain to find the morph causing the problem"		[errCtx notNil and:[(errCtx receiver isKindOf: Morph) not]] 			whileTrue:[errCtx _ errCtx sender].		"If we're at the root of the context chain then we have a fatal drawing problem"		errCtx == nil ifTrue:[^self handleFatalDrawingError: err].		errMorph _ errCtx receiver.		"If the morph causing the problem has already the #drawError flag set,		then search for the next morph above in the caller chain."		errMorph hasProperty: #errorOnDraw] whileTrue.		errMorph setProperty: #errorOnDraw toValue: true.		"Install the old error handler, so we can re-raise the error"		Processor activeProcess errorHandler: oldHandler.		rcvr error: err.	].! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/10/1999 22:28'!doOneCycle	self interCyclePause: MinCycleLapse.	self doOneCycleNow.! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/10/1999 22:43'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."	"process user input events, but only for remote hands"	self handsDo: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			self activeHand: h.			h processEvents.			self activeHand: nil]].	self runStepMethods.	self displayWorldSafely.! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/10/1999 22:33'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	self handsDo: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorldSafely.! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/10/1999 22:30'!doOneSubCycle	"Like doOneCycle, but preserves activeHand."	| currentHand |	currentHand _ activeHand.	self doOneCycle.	activeHand _ currentHand! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/7/1999 17:47'!lastCycleTime	^ lastCycleTime! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/7/1999 17:52'!lastCycleTime: x	lastCycleTime _ x! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:47'!lastStepTime	^ lastStepTime! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:52'!lastStepTime: x	lastStepTime _ x! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:47'!stepList	^ stepList! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:52'!stepList: x	stepList _ x! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/10/1999 22:40'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p _ [[true] whileTrue: [		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait]] newProcess.	p resume.	^ p! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:44'!canvas	^ canvas! !!WorldState methodsFor: 'canvas' stamp: 'di 7/19/1999 16:45'!canvas: x	canvas _ x.	damageRecorder == nil		ifTrue: [damageRecorder _ DamageRecorder new]		ifFalse: [damageRecorder doFullRepaint]! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:45'!damageRecorder	^ damageRecorder! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:44'!viewBox	^ viewBox! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:58'!viewBox: x	viewBox _ x! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:42'!activeHand	^ activeHand! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:50'!activeHand: x	activeHand _ x! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:40'!hands	^ hands! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:51'!hands: x	hands _ x! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 23:06'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now m oldWakeupTime |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	stepList do: [:entry |		m _ entry at: 1.		oldWakeupTime _ entry at: 2.		entry at: 2 put: now + ((oldWakeupTime - earliestTime) min: m stepTime)].	lastStepTime _ now.! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 23:06'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 22:14'!isStepping: aMorph	"Return true if the given morph is in the step list."	stepList do: [:entry | entry first == aMorph ifTrue: [^ true]].  "already stepping"	^ false! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 23:14'!runStepMethodsIn: aWorld	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == aWorld			ifTrue: [				wakeupTime <= now					ifTrue: [						morphToStep step.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse: [				deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]].	] ifError:[:err :rcvr|		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"	].	deletions ifNotNil: [		deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now.! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 22:10'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	self adjustWakeupTimesIfNecessary.	stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 22:15'!stopStepping: aMorph	"Remove the given morph from the step list."	stepList copy do: [:entry |		entry first == aMorph ifTrue: [stepList remove: entry ifAbsent: []]].! !!WorldState class methodsFor: 'class initialization' stamp: 'di 6/10/1999 22:26'!initialize	"WorldState initialize"	MinCycleLapse _ 20.		"allows 50 frames per second..."	DisableDeferredUpdates _ false.! !PasteUpMorph removeSelector: #damageRecorder:!Project removeSelector: #wedToWorldIfMorphic!WorldState removeSelector: #installPasteUpAsWorld:!WorldState removeSelector: #damageRecorder:!WorldState removeSelector: #initFromParent:!WorldState initialize!WorldState class removeSelector: #newMorphic!WorldState class removeSelector: #newMorphicConstruction!Smalltalk removeClassNamed: #WorldMorph!"Postscript:Replace projects pointed to by PasteUpMorphs with WorldStates." | a |PasteUpMorph allInstancesDo:	[:pum | pum project ifNotNil:		[pum instVarNamed: 'project' put: (pum project as: WorldState)]].a _ MorphicProject allInstances.a elementsExchangeIdentityWith: (a collect: [:mp | mp as: Project]).Smalltalk addToStartUpList: PasteUpMorph.Smalltalk removeClassNamed: #MorphicProject.!