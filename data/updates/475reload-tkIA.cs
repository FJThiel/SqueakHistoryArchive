'From Squeak 2.3 beta of Nov 25, 1998 on 10 December 1998 at 1:46:18 pm'!!BookMorph class methodsFor: 'all' stamp: 'tk 12/7/1998 17:55'!grabURL: aURLString	"Create a BookMorph for this url and put it in the hand."	| bk |	bk _ self new fromURL: aURLString.	"If this book is already in, we will steal the pages out of it!!!!!!!!"	bk goToPage: 1.	"install it"	World primaryHand attachMorph: bk.! !!Morph methodsFor: 'accessing' stamp: 'tk 12/4/1998 13:06'!sqkPage	^ self valueOfProperty: #SqueakPage! !!Morph methodsFor: 'accessing' stamp: 'tk 12/4/1998 13:08'!url	"If I have been assigned a url, return it.  For PasteUpMorphs mostly."	| sq |	(sq _ self sqkPage) ifNotNil: [^ sq url].	^ nil		! !!BookMorph methodsFor: 'initialization' stamp: 'tk 12/7/1998 18:12'!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm remote |	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	self initialize.	pages _ OrderedCollection new.	2 to: remote size do: [:ii | pages add: (remote at: ii)].	currentPage fullReleaseCachedState; delete.	"the blank one"	currentPage _ remote at: 2.	self setProperty: #modTime toValue: ((remote at: 1) at: #modTime).	^ self! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/4/1998 14:17'!pageNumberOf: aMorph	"Modified so that if the page IS in memory, other pages don't have to be brought in."	| ii |	ii _ 0.	1 to: pages size do: [:jj | 		aMorph == (pages at: jj) ifTrue: [ii _ jj]]."	1 to: pages size do: [:jj |		(pp _ pages at: jj) isInMemory = aMorph isInMemory ifTrue: [			pp == aMorph ifTrue: [ii _ jj]]]."		"If MorphObjectOut would resolve to an existing page, might 		 give the wrong answer, but users of this method should tolerate this."	^ ii! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/8/1998 21:57'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu add: 'send other pages to server' action: #savePagesOnURL.	aMenu add: 'reload from server' action: #reload.	aMenu add: 'keep in one file' action: #keepTogether.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/8/1998 21:26'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq |	(url _ self valueOfProperty: #url) ifNil: ["for .bo index file"		url _ FillInTheBlank 			request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' 			initialAnswer: 'ftp://server/books/myBook/aBook.bo'.		url size > 0 ifTrue: [self setProperty: #url toValue: url]			ifFalse: [^ self]].	onServer _ self class new fromURL: url.	"Later: test book times?"	onPgs _ onServer pages collect: [:out |		sq _ SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq ~~ nil and: [sq contentsMorph isInMemory])			ifTrue: [out sqkPage lastChangeTime > sq lastChangeTime 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]]."	pages _ onPgs.  currentPage _ nil.	self goToPage: 1."	self newPages: onPgs currentIndex: 1.		"later stay at current page"! !!BookMorph methodsFor: 'menu' stamp: 'tk 12/10/1998 11:59'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out."	| dict list pg holder mine sf remoteFile |	pages size = 0 ifTrue: [^ self].	dict _ Dictionary new.  dict at: #modTime put: Time totalSeconds.	list _ pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: [:out :ind |		out isInMemory ifTrue: [  			(pg _ out valueOfProperty: #SqueakPage) ifNil: [				out saveOnURLbasic].			pg _ (out valueOfProperty: #SqueakPage) copy.			holder _ MorphObjectOut new xxxSetUrl: pg url page: pg.			pg contentsMorph: holder.			list at: ind put: holder]].	list _ (Array with: dict), list.	mine _ self valueOfProperty: #url.	mine ifNil: [mine _ self getStemUrl, '.bo'.		self setProperty: #url toValue: mine].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: list.		remoteFile close].! !!ObjectOut methodsFor: 'basics' stamp: 'tk 12/8/1998 21:51'!ifNotNil: aBlock	"know its not nil, since we can't stand for a nil"	^ aBlock value! !!ObjectOut methodsFor: 'access' stamp: 'tk 12/4/1998 13:01'!sqkPage	^ page! !!ObjectOut methodsFor: 'access' stamp: 'tk 12/4/1998 13:01'!url	^ url! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 12/10/1998 11:44'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| returnValue aMorph myUrl |	"Transcript show: thisContext sender selector; cr." "useful for debugging"	recursionFlag == true ifTrue: [		true confirm: 'Object being fetched for a second time.This is an error that needs to be fixed.Do it anyway to recover the data?' orCancel: [		^ aMessage error: 'Recursive not understood error in ObjectOut']].		"We are not an object yet.  There is a problem in the fetching code."	recursionFlag _ true.	myUrl _ url.	"can't use inst vars after become"	"fetch the object"	aMorph _ self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	returnValue _ aMessage sentTo: aMorph.		"self == aMorph"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	^ returnValue! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 12/10/1998 11:56'!fileNamed: fullName	"Create a RemoteFileStream for writing.  If the file exists, do not complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream fileNamed: (file fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	^ remoteStrm	"no actual writing till close"! !!ServerDirectory class methodsFor: 'available servers' stamp: 'tk 12/10/1998 12:29'!serverNamed: nameString	^ Servers at: nameString asString		ifAbsent: [self error: 'Server name not found']! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 12/10/1998 11:46'!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"	(url beginsWith: 'file:') ifTrue: [Transcript show: 'Fetching  ', url; cr].		page _ strm fileInObjectAndCode.	page isMorph 		ifTrue: [contentsMorph _ page]	"may be a bare morph"		ifFalse: ["copy over the state"			temp _ url.			temp2 _ policy.			self copyFrom: page.	"including contentsMorph"			url _ temp.	"I know best!!"			temp2 ifNotNil: [policy _ temp2]].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	contentsMorph setProperty: #SqueakPage toValue: self.	self dirty: false.	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 12/4/1998 13:33'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph _ aMorph.	n _ aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor _ authorString.		creationTime _ Time totalSeconds]."	lastChangeAuthor _ authorString.	lastChangeTime _ Time totalSeconds.	do it when actually write"	self updateThumbnail.	self postChangeNotification.! !!SqueakPage methodsFor: 'saving' stamp: 'tk 12/10/1998 11:56'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		lastChangeAuthor _ Utilities authorInitialsPerSe ifNil: ['*'].		lastChangeTime _ Time totalSeconds.		Cursor wait showWhile: [			remoteFile _ sf fileNamed: url.	"no notification when overwriting"			remoteFile fileOutClass: nil andObject: self.			remoteFile close].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 12/8/1998 21:51'!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	aSqueakPage contentsMorph isInMemory ifTrue: [		aSqueakPage contentsMorph ifNotNil: [			aSqueakPage contentsMorph setProperty: #SqueakPage 				toValue: aSqueakPage]].	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'tk 12/4/1998 13:02'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		MorphObjectOut allInstancesDo: [:ticklish |			unreferenced remove: ticklish url ifAbsent: []].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !BookMorph class removeSelector: #fromURL:!ObjectOut removeSelector: #xxxPage!ObjectOut removeSelector: #xxxUrl!