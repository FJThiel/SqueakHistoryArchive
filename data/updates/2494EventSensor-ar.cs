'From Squeak2.9alpha of 12 June 2000 [latest update: #2493] on 16 August 2000 at 1:45:36 pm'!"Change Set:		EventSensor-arDate:			23 July 2000Author:			Andreas RaabA quick run for an event driven sensor which is 100% compatible with the existing primitives. All we need is two (yet to be implemented) addl. support primitives. One that will install an event semaphore (to be signaled if the support code notices any events asynchronously) and one for actually reading the events.""Install the event sensor constants dictionary"Smalltalk at: #EventSensorConstants ifAbsentPut:[Dictionary new].!InputSensor subclass: #EventSensor	instanceVariableNames: 'mouseButtons mousePosition keyboardBuffer interruptKey interruptSemaphore eventQueue inputProcess inputSemaphore '	classVariableNames: 'EventPollFrequency '	poolDictionaries: 'EventSensorConstants '	category: 'Kernel-Processes'!!EventSensor commentStamp: '<historical>' prior: 0!EventSensor is a replacement for InputSensor based on a set of (optional) event primitives. An EventSensor updates its state when events are received so that all state based users of Sensor (e.g., Sensor keyboard, Sensor leftShiftDown, Sensor mouseButtons) will work exactly as before, by moving the current VM mechanisms into EventSensor itself. An optional input semaphore is part of the new design. For platforms that support true asynchronous event notification the semaphore can be signaled to indicate pending events. However, since most platforms do not support asynchronous notifications about events EventSensor still has to poll every now and then.Instance variables:	mouseButtons <Integer>	- mouse button state as replacement for primMouseButtons	mousePosition <Point>	- mouse position as replacement for primMousePt	keyboardBuffer <SharedQueue>	- keyboard input buffer	interruptKey <Integer>			- currently defined interrupt key	interruptSemaphore <Semaphore>	- the semaphore signaled when the interruptKey is detected	eventQueue <SharedQueue>	- an optional event queue for event driven applications	inputProcess <Process>		- the process receiving low-level events	inputSemaphore <Semaphore>- the semaphore signaled by the VM if asynchronous event notification is supportedClass variables:	EventPollFrequency <Integer>	- the number of milliseconds to wait between polling for more eventsEvent format:The current event format is very simple. Each event is recorded into an 8 element array. All events must provide some SmallInteger ID (the first field in the event buffer) and a time stamp (the second field in the event buffer), so that the difference between the time stamp of an event and the current time can be reported.Currently, the following events are defined:Null event=============The Null event is returned when the ST side asks for more events but no more events are available.Structure:[1]		- event type 0[2-8]	- unusedMouse event structure==========================Mouse events are generated when mouse input is detected.Structure:[1]	- event type 1[2]	- time stamp[3]	- mouse x position[4]	- mouse y position[5]	- button state; bitfield with the following entries:		1	-	yellow (e.g., right) button		2	-	blue (e.g., middle) button		4	-	red (e.g., left) button		[all other bits are currently undefined][6]	- modifier keys; bitfield with the following entries:		1	-	shift key		2	-	ctrl key		4	-	(Mac specific) option key		8	-	Cmd/Alt key		[all other bits are currently undefined][7]	- reserved.[8]	- reserved.Keyboard events====================Keyboard events are generated when keyboard input is detected.[1]	- event type 2[2]	- time stamp[3]	- character code		For now the character code is in Mac Roman encoding.[4]	- press state; integer with the following meaning		0	-	character		1	-	key press (down)		2	- 	key release (up)[5]	- modifier keys (same as in mouse events)[6]	- reserved.[7]	- reserved.[8]	- reserved.!!InputSensor methodsFor: 'private' stamp: 'ar 7/23/2000 15:38'!primInterruptSemaphore: aSemaphore 	"Primitive. Install the argument as the semaphore to be signalled whenever the user presses the interrupt key. The semaphore will be signaled once each time the interrupt key is pressed."	<primitive: 134>	^self primitiveFailed"Note: This primitive is obsolete with the new event driven architecture in which EventSensor can handle the interrupts itself. However, for supporting older images running on newer VMs the primitive must still be implemented."! !!InputSensor methodsFor: 'private' stamp: 'ar 7/23/2000 15:38'!primSetInterruptKey: anInteger	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."	<primitive: 133>	^self primitiveFailed"Note: This primitive is obsolete with the new event driven architecture in which EventSensor can handle the interrupts itself. However, for supporting older images running on newer VMs the primitive must still be implemented."! !!InputSensor methodsFor: 'initialize' stamp: 'ar 7/23/2000 15:06'!shutDown	InterruptWatcherProcess == nil ifFalse: [		InterruptWatcherProcess terminate.		InterruptWatcherProcess terminate].! !!InputSensor methodsFor: 'initialize' stamp: 'ar 7/23/2000 00:00'!startUp	self installInterruptWatcher.! !!EventSensor methodsFor: 'initialize' stamp: 'ar 7/23/2000 14:39'!initialize	"Initialize the receiver"	mouseButtons _ 0.	mousePosition _ 0@0.	keyboardBuffer _ SharedQueue new.	interruptKey _ interruptKey ifNil:[2094].  "cmd-."	interruptSemaphore _ (Smalltalk specialObjectsArray at: 31) ifNil:[Semaphore new].	eventQueue _ nil.	inputProcess _ nil.	inputSemaphore _ Semaphore new.! !!EventSensor methodsFor: 'initialize' stamp: 'ar 7/23/2000 14:51'!shutDown	inputProcess ifNotNil:[inputProcess terminate].	inputProcess _ nil.	inputSemaphore ifNotNil:[Smalltalk unregisterExternalObject: inputSemaphore].! !!EventSensor methodsFor: 'initialize' stamp: 'ar 7/23/2000 14:51'!startUp	"Run the I/O process"	self shutDown.	self initialize.	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).	inputProcess _ [self ioProcess] forkAt: Processor lowIOPriority.	super startUp.! !!EventSensor methodsFor: 'accessing' stamp: 'ar 7/23/2000 14:37'!eventQueue	"Return the current event queue"	^eventQueue! !!EventSensor methodsFor: 'accessing' stamp: 'ar 7/23/2000 14:38'!eventQueue: aSharedQueue	"Install a new queue for events.	If an eventQueue is present all events will be queued up there.	It is assumed that a client installing an event queue will actually	read data from it, otherwise the system will overflow."	eventQueue _ aSharedQueue.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/23/2000 15:34'!ioProcess	"Run the i/o process"	| eventBuffer type |	eventBuffer _ Array new: 8.	[true] whileTrue:[		[self primGetNextEvent: eventBuffer.		type _ eventBuffer at: 1.		type = EventTypeNone] whileFalse:[self processEvent: eventBuffer].		inputSemaphore waitTimeoutMSecs: EventPollFrequency.	].! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:12'!mapButtons: buttons modifiers: modifiers	"Map the buttons to yellow or blue based on the given modifiers.	If only the red button is pressed, then map		Ctrl-RedButton -> BlueButton.		Cmd-RedButton -> YellowButton.	"	(buttons = RedButtonBit)		ifFalse:[^buttons].	(modifiers allMask: CtrlKeyBit) 		ifTrue:[^BlueButtonBit].	(modifiers allMask: CommandKeyBit) 		ifTrue:[^YellowButtonBit].	^buttons! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:15'!primGetNextEvent: array	"Store the next OS event available into the provided array.	Essential. If the VM is not event driven the ST code will fall	back to the old-style mechanism and use the state based	primitives instead."	| kbd buttons modifiers pos mapped |	<primitive: 94>	"Simulate the events"	array at: 1 put: EventTypeNone. "assume no more events"	"First check for keyboard"	kbd _ super primKbdNext.	kbd = nil ifFalse:[		"simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^self].	"Then check for mouse"	buttons _ super primMouseButtons.	pos _ super primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	mapped = buttons ifFalse:[modifiers _ 0].	(pos = mousePosition and:[(mapped bitOr: (modifiers bitShift: 3)) = mouseButtons])		ifTrue:[^self].	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/30/2000 18:16'!primSetInputSemaphore: semaIndex	"Set the input semaphore the VM should use for asynchronously signaling the availability of events. Primitive. Optional."	<primitive: 93>	^nil! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 13:37'!processEvent: evt	"Process a single event. This method is run at high priority."	| type |	type _ evt at: 1.	"Check if the event is a user interrupt"	(type = EventTypeKeyboard and:[(evt at: 2) = 0 and:[		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])			 ifTrue:["interrupt key is meta - not reported as event"					^interruptSemaphore signal].	"Store the event in the queue if there's any"	self queueEvent: evt.	"Update state for InputSensor."	EventTypeMouse = type ifTrue:[self processMouseEvent: evt].	EventTypeKeyboard = type ifTrue:[self processKeyboardEvent: evt].! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/1/2000 11:55'!processKeyboardEvent: evt	"process a keyboard event, updating InputSensor state"	| charCode pressCode |	"Never update keyboardBuffer if we have an eventQueue active"	eventQueue ifNotNil:[^self]. 	charCode _ evt at: 3.	charCode = nil ifTrue:[^self]. "extra characters not handled in MVC"	pressCode _ evt at: 4.	pressCode = EventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"	"mix in modifiers"	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).	keyboardBuffer nextPut: charCode.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/23/2000 17:21'!processMouseEvent: evt	"process a mouse event, updating InputSensor state"	| modifiers buttons mapped |	mousePosition _ (evt at: 3) @ (evt at: 4).	buttons _ evt at: 5.	modifiers _ evt at: 6.	mapped _ self mapButtons: buttons modifiers: modifiers.	mapped = buttons ifTrue:[		"We haven't mapped any buttons, so record the modifiers"		mapped _ buttons bitOr: (modifiers bitShift: 3).	].	mouseButtons _ mapped.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 7/23/2000 14:55'!queueEvent: evt	"Queue the given event in the event queue (if any).	Note that the event buffer must be copied since it	will be reused later on."	eventQueue ifNil:[^self].	eventQueue nextPut: evt clone.! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 00:34'!primInterruptSemaphore: aSemaphore 	"Primitive. Install the argument as the semaphore to be signalled whenever the user presses the interrupt key. The semaphore will be signaled once each time the interrupt key is pressed."	interruptSemaphore _ aSemaphore.	"backward compatibility: use the old primitive which is obsolete now"	super primInterruptSemaphore: aSemaphore! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 14:59'!primKbdNext	keyboardBuffer isEmpty		ifTrue:[^nil]		ifFalse:[^keyboardBuffer next]! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 14:59'!primKbdPeek	^keyboardBuffer peek! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 14:59'!primMouseButtons	^mouseButtons! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 14:59'!primMousePt	^mousePosition! !!EventSensor methodsFor: 'private' stamp: 'ar 7/22/2000 22:58'!primSetInterruptKey: anInteger	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."	interruptKey _ anInteger	"backward compatibility: use the old primitive which is obsolete now"	super primSetInterruptKey: anInteger! !!InputSensor class methodsFor: 'public' stamp: 'ar 7/23/2000 00:00'!startUp		self default startUp.! !!EventSensor class methodsFor: 'class initialization' stamp: 'ar 7/23/2000 15:33'!initialize	"EventSensor initialize"	self initializeEventSensorConstants.	EventPollFrequency _ 20.	"Note: The above is important. Most systems will not	notify the VM about the occurance of events asynchronously.	Therefore, we have to go check for ourselves every now and then."! !!EventSensor class methodsFor: 'class initialization' stamp: 'ar 7/30/2000 18:11'!initializeEventSensorConstants	"EventSensor initialize"	Smalltalk declare: #EventSensorConstants from: Undeclared.	EventSensorConstants == nil ifTrue:[EventSensorConstants _ Dictionary new].	#(		(RedButtonBit 4)		(BlueButtonBit 2)		(YellowButtonBit 1)		(ShiftKeyBit 1)		(CtrlKeyBit 2)		(OptionKeyBit 4)		(CommandKeyBit 8)		"Types of events"		(EventTypeNone 0)		(EventTypeMouse 1)		(EventTypeKeyboard 2)		"Press codes for keyboard events"		(EventKeyChar 0)		(EventKeyDown 1)		(EventKeyUp 2)	) do:[:spec|		EventSensorConstants declare: spec first from: Undeclared.		EventSensorConstants at: spec first put: spec last.	].! !!EventSensor class methodsFor: 'class initialization' stamp: 'ar 7/23/2000 15:06'!install	"EventSensor install"	"Install an EventSensor in place of the current Sensor."	| newSensor |	Sensor shutDown.	newSensor _ self new.	newSensor startUp.	"Note: We must use #become: here to replace all references to the old sensor with the new one, since Sensor is referenced from all the existing controllers."	Sensor becomeForward: newSensor. "done"! !!EventSensor class methodsFor: 'instance creation' stamp: 'ar 7/22/2000 23:22'!new	^super new initialize! !EventSensor initialize!"Postscript:Make the event sensor active."EventSensor install.!