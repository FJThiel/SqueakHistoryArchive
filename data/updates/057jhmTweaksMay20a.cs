'From Squeak 2.0 BETA of May 8, 1998 on 20 May 1998 at 4:23:47 pm'!"Change Set:		jhmTweaksMay20aDate:			20 May 1998Author:			John MaloneyVarious fixes including:  a. MorphicMenu addLine failed if if menu had no items  b. MorphicMenu pop to front when activated  c. menu in the ChangeSet name button now     pops up in Morphic world without extra click  d. added ChangeSorter>removeOldChangeSets utility  e. Player costume dictionary no longer holds onto     extra garbage; plugs a significant space leak  f. Player class>freeUnreferencedSubclasses is a utility     that attempts to delete unused Player subclasses. Does     no yet work."!!Behavior methodsFor: 'accessing instances and variables' stamp: 'jm 5/20/1998 15:53'!allInstances 	"Answer a collection of all current instances of the receiver."	| all |	all _ OrderedCollection new.	self allInstancesDo: [:x | x == all ifFalse: [all add: x]].	^ all asArray! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jm 5/20/1998 12:15'!changeSetMenuStart	| menu |	menu _ self changeSetMenu: CustomMenu new.	menu ifNotNil: [menu invokeOn: self].! !!ChangeSorter class methodsFor: 'all' stamp: 'jm 5/20/1998 10:25'!removeChangeSetsBefore: stopName	"Remove all change sets before the one with the given name."	"ChangeSorter removeChangeSetsBefore: 'Beyond'" 	| stop |	(self confirm:'Really remove all change sets before"', stopName, '"?')		ifFalse: [^ self].	self gatherChangeSets.	stop _ false.	ChangeSet allInstances do: [:changeSet |		changeSet name = stopName ifTrue: [stop _ true].		stop ifFalse: [			changeSet okayToRemove ifTrue: [				AllChangeSets remove: changeSet ifAbsent: [].				changeSet wither]]].	Smalltalk garbageCollect.	AllChangeSets _ OrderedCollection new.	self gatherChangeSets.! !!ChangeSorter class methodsFor: 'all' stamp: 'jm 5/20/1998 10:40'!removeOldChangeSets	"Ask the user to select a change set from a menu, then remove all change sets before the selected one."	"ChangeSorter removeOldChangeSets" 	| names stopName |	self gatherChangeSets.	names _ AllChangeSets collect: [:each | each name].	stopName _ (SelectionMenu labelList: names selections: names) startUp.	stopName ifNotNil: [self removeChangeSetsBefore: stopName].! !!EToySystem class methodsFor: 'development support' stamp: 'jm 5/20/1998 15:09'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph releaseTemporaryForms.	PaintBoxMorph prototype stampHolder clear.  "clear stamps"	PaintBoxMorph prototype delete.  "break link to world, if any"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Symbol rehash.! !!EToySystem class methodsFor: 'development support' stamp: 'jm 5/20/1998 15:11'!prepareForExternalReleaseNamed: aReleaseName	"EToySystem prepareForExternalReleaseNamed: '2.0Beta'"	self stripMethodsForExternalRelease.	EToySystem class compile: 'guessDOLProxy	"deleted for external release"' classified: 'stripped'.	ScriptingSystem saveFormsToFileNamed: aReleaseName, '.Dis.Forms'.	EToySystem stripGraphicsForExternalRelease.	EToySystem cleanupsForRelease.	ScreenController initialize.! !!EToySystem class methodsFor: 'creating etoys' stamp: 'jm 5/20/1998 15:03'!openDriveACar	Smalltalk at: #DriveACar ifPresent: [:driveACar |		EToyPlayer openOn: driveACar new].! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 5/20/1998 11:05'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	self isInMenu ifFalse: [^ super mouseDown: evt].	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	self bringMenuChainToFront.	self selectFromHand: evt hand.! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:03'!bringMenuChainToFront	| menusToPopUp menu owningItem |	menusToPopUp _ OrderedCollection new.	menu _ self owner.	[menu isKindOf: MenuMorph] whileTrue: [		menusToPopUp addFirst: menu.		owningItem _ menu popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [menu _ owningItem owner]			ifFalse: [menu _ nil]].	menusToPopUp do: [:m | m owner addMorphFront: m].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:58'!selectFromHand: aHand	self isSelected: true.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAt: self bounds topRight + (10@0)			forHand: aHand			from: self].! !!MenuMorph methodsFor: 'construction' stamp: 'jm 5/20/1998 10:50'!addLine	"Append a divider line to this menu. Suppress duplicate lines."	submorphs isEmpty ifTrue: [^ self].	(self lastSubmorph isKindOf: MenuLineMorph)		ifFalse: [self addMorphBack: MenuLineMorph new].! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'jm 5/20/1998 12:26'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned matches the semantics of the original MVC menu from which this menu was created. If the original menu was a PopUpMenu, the answer is the index of the selection, or zero if no selection was made. If the original menu was a SelectionMenu or CustomMenu, the answer the selection stored in the menu, or nil if no selection was made."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneCycle].	self delete.	^ selectedItem! !!PartsViewer methodsFor: 'private' stamp: 'jm 5/20/1998 14:35'!nextCostume	"The receiver's player is currently being viewed via a particular costume.  Now switch to a plausible different costume."	| ind acn c |	ind _ (acn _ scriptedPlayer availableCostumeNamesForArrows) indexOf: scriptedPlayer costume class name.	ind _ ind + 1.	ind > acn size ifTrue: [ind _ 1].	scriptedPlayer costume:		(c _ scriptedPlayer costumeNamed: (acn at: ind)) fullCopy.	c isInWorld ifTrue: [self presenter updatePartsViewer: self]! !!PartsViewer methodsFor: 'private' stamp: 'jm 5/20/1998 14:36'!previousCostume	"The receiver's player is currently being viewed via a particular costume.  Now switch to a plausible different costume."	| ind acn c |	ind _ (acn _ scriptedPlayer availableCostumeNamesForArrows) indexOf: scriptedPlayer costume class name.	ind _ ind - 1.	ind < 1 ifTrue: [ind _ acn size].	scriptedPlayer costume:		(c _ scriptedPlayer costumeNamed: (acn at: ind)) fullCopy.	c isInWorld ifTrue: [self presenter updatePartsViewer: self]! !!Player methodsFor: 'costume' stamp: 'jm 5/20/1998 14:25'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	((costume isKindOf: SketchMorph) and: [(aMorph isKindOf: SketchMorph)])		ifTrue:			[^ costume wearCostume: aMorph].	self costumeDictionary		at: aMorph formalCostumeName		put: (aMorph fullCopy costumee: nil).	costume ifNotNil:		[itsBounds _ costume bounds.		costume owner replaceSubmorph: costume by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph costumee: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'costume' stamp: 'jm 5/20/1998 14:36'!wearCostumeOfClass: aClass	self costume:		(self costumeNamed: aClass formalCostumeName) fullCopy! !!Player class methodsFor: 'other' stamp: 'jm 5/20/1998 16:06'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are otherwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes."	"Player freeUnreferencedSubclasses"	| newSubclasses |	subclasses _ subclasses select: [:c | (c name asString beginsWith: 'Player') not] fixTemps.	Smalltalk garbageCollect.	newSubclasses _ Set new.	Metaclass allInstancesDo: [:mClass |		c _ mClass soleInstance.		((c superclass = self) and:		 [(c name beginsWith: 'AnObsolete') not])			ifTrue: [newSubclasses add: c]].	subclasses _ newSubclasses.! !!PluggableButtonMorph methodsFor: 'events' stamp: 'jm 5/20/1998 11:49'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	allButtons _ nil.	evt yellowButtonPressed ifTrue: [^ self invokeMenu: evt].	triggerOnMouseDown		ifTrue: [self performAction]		ifFalse: [			allButtons _ owner submorphs select: [:m | m class = self class].			self updateFeedbackForEvt: evt].! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:34'!getMenu: evt	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: evt shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:51'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt.	menu ifNotNil: [		menu popUpAt: evt cursorPoint event: evt].! !PluggableButtonMorph removeSelector: #invokeMenu!PluggableButtonMorph removeSelector: #getMenu!