'From Squeak2.9alpha of 12 June 2000 [latest update: #2574] on 8 September 2000 at 11:33:58 am'!"Change Set:		UnifiedPolygonsDate:			7 September 2000Author:			Dan IngallsRefactors PolygonMorph, CurveMorph and the subclasses of CurveMorph to all be a single class with optional curve state.  To be followed by a similar refactoring of PolygonMorphDashed.This anticipates, among other things, Connectors being able to be a simple subclass that can inherit all these properties.  "!BorderedMorph subclass: #PolygonMorph	instanceVariableNames: 'vertices closed filledForm quickFill arrows arrowForms handles borderForm ptAfterFirst ptBeforeLast smoothCurve coeffs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!PolygonMorph commentStamp: 'di 9/8/2000 10:03' prior: 0!This class combines the old Polygon and Curve classes.The 1-bit fillForm to make display and containment tests reasonably fast.  However, this functionality is in the process of being supplanted by balloon capabilities, which should eventually provide anti-aliasing as well.!!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/8/2000 09:44'!beSmoothCurve	smoothCurve == true ifFalse:		[smoothCurve _ true.		self computeBounds]! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/8/2000 09:45'!beStraightSegments	smoothCurve == false ifFalse:		[smoothCurve _ false.		self computeBounds]! !PolygonMorph allSubInstancesDo: [:m | (m instVarNamed: 'smoothCurve') ifNil: [m beStraightSegments]].CurveMorph allSubInstancesDo: [:m | m beSmoothCurve; releaseCachedState].!PolygonMorph subclass: #BalloonMorph	instanceVariableNames: 'target offsetFromTarget '	classVariableNames: 'BalloonFont '	poolDictionaries: ''	category: 'Morphic-Widgets'!PolygonMorph subclass: #BlobMorph	instanceVariableNames: 'random velocity sneaky '	classVariableNames: 'AllBlobs '	poolDictionaries: ''	category: 'Morphic-Demo'!!CurveMorph commentStamp: 'di 9/8/2000 10:03' prior: 0!This is really only a shell for creating Shapes with smooth outlines.!!LineMorph commentStamp: 'di 9/8/2000 10:04' prior: 0!This is really only a shell for creating single-segment straight-line Shapes.!PolygonMorph subclass: #LipsMorph	instanceVariableNames: 'newVertices newScale '	classVariableNames: 'PhoneticArticulations '	poolDictionaries: ''	category: 'Speech-Gestures'!!ChangeSet methodsFor: 'private' stamp: 'di 9/8/2000 11:28'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3'		].	].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'di 9/8/2000 10:40'!acceptGraphPoint: p at: index	| ms val points whichLim linePoint other boundedP |	boundedP _ p adhereTo: graphArea bounds.	ms _ self msFromX: boundedP x.	points _ envelope points.	ms _ self constrain: ms adjacentTo: index in: points.	(index = 1 or: [(whichLim _ limits indexOf: index) > 0]) ifTrue:		["Limit points must not move laterally"		ms _ (points at: index) x].	val _ self valueFromY: boundedP y.	points at: index put: ms@val.	linePoint _ (self xFromMs: ms) @ (self yFromValue: val).	(whichLim notNil and: [whichLim between: 1 and: 2]) ifTrue:		["Loop start and loop end must be tied together"		other _ limits at: (3 - whichLim).  " 1 <--> 2 "		points at: other put: (points at: other) x @ val.		line verticesAt: other put: (line vertices at: other) x @ linePoint y].	"Make sure envelope feels the change in points array..."	envelope setPoints: points loopStart: (limits at: 1) loopEnd: (limits at: 2).	^ linePoint! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'di 9/8/2000 10:41'!limitHandleMoveEvent: evt from: handle index: index	"index is the handle index = 1, 2 or 3"	| ix p ms x points limIx |	ix _ limits at: index.  "index of corresponding vertex"	p _ evt cursorPoint adhereTo: graphArea bounds.	ms _ self msFromX: p x + (self handleOffset: handle) x.	"Constrain move to adjacent points on ALL envelopes"	sound envelopes do:		[:env | limIx _ env perform:			(#(loopStartIndex loopEndIndex decayEndIndex) at: index).		ms _ self constrain: ms adjacentTo: limIx in: env points].	"Update the handle, the vertex and the line being edited"	x _ self xFromMs: ms.	handle position: (x @ graphArea top) - (self handleOffset: handle).	line verticesAt: ix put: x @ (line vertices at: ix) y.	sound envelopes do:		[:env | limIx _ env perform:			(#(loopStartIndex loopEndIndex decayEndIndex) at: index).		points _ env points.		points at: limIx put: ms @ (points at: limIx) y.		env setPoints: points loopStart: env loopStartIndex loopEnd: env loopEndIndex].! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/8/2000 09:44'!beSmoothCurve	smoothCurve == true ifFalse:		[smoothCurve _ true.		self computeBounds]! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/8/2000 09:45'!beStraightSegments	smoothCurve == false ifFalse:		[smoothCurve _ false.		self computeBounds]! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/7/2000 15:46'!initialize	super initialize.	vertices _ Array with: 20@20 with: 40@30 with: 20@40.	borderWidth _ 2.	borderColor _ Color magenta.	closed _ true.	smoothCurve _ false.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/7/2000 13:28'!vertices: verts color: c borderWidth: bw borderColor: bc	super initialize.	vertices _ verts.	color _ c.	borderWidth _ bw.	borderColor _ bc.	closed _ vertices size > 2.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'access' stamp: 'di 9/7/2000 16:18'!isCurve	^ smoothCurve! !!PolygonMorph methodsFor: 'access' stamp: 'di 9/7/2000 16:53'!openOrClosePhrase	| curveName |	curveName _ self isCurve ifTrue: ['curve'] ifFalse: ['polygon'].	^ closed		ifTrue: ['make open ' , curveName]		ifFalse: ['make closed ' , curveName]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 9/7/2000 13:16'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed ifTrue: [aCanvas drawPolygon: self getVertices fillStyle: self fillStyle].	self drawBorderOn: aCanvas.	self drawArrowsOn: aCanvas.	"Old code:	closed & color isTransparent not		ifTrue: [aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color].	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: [aCanvas stencil: self borderForm at: bounds topLeft						color: borderColor]		ifFalse: [self drawBorderOn: aCanvas].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset			color: (borderColor isColor ifTrue: [borderColor] ifFalse: [color])]	"! !!PolygonMorph methodsFor: 'smoothing' stamp: 'di 9/7/2000 16:09'!coefficients	"Compute an array for the coeffs.  This is copied from Flegal's old	code in the Spline class."	| length extras verts |	coeffs ifNotNil: [^ coeffs].	verts _ closed ifTrue: [vertices copyWith: vertices first]				ifFalse: [vertices].	length _ verts size.	extras _ 0.	coeffs _ Array new: 8.	1 to: 8 do: [:i | coeffs at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coeffs at: k)					at: i put: (k = 1						ifTrue: [(verts at: i) x asFloat]						ifFalse: [(verts at: i) y asFloat])].			1 to: extras do: [:i | (coeffs at: k)					at: length + i put: ((coeffs at: k)						at: i + 1)].			self derivs: (coeffs at: k)				first: (coeffs at: k + 1)				second: (coeffs at: k + 2)				third: (coeffs at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coeffs at: i put: ((coeffs at: i)											copyFrom: 2 to: length + 1)]].	^ coeffs! !!PolygonMorph methodsFor: 'smoothing' stamp: 'di 9/7/2000 16:14'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coeffs) from	the Points in this Path (coeffs at: 1 and coeffs at: 5)."	| len v anArray |	len _ a size.	len < 2 ifTrue: [^self].	len > 2 ifTrue:		[v _ Array new: len.		 v  at: 1 put: 4.0.		 anArray _ Array new: len.		 anArray at: 1 put: (6.0 * ((a at: 1) - ((a at: 2) * 2.0) + (a at: 3))).		 2 to: len - 2 do:			[:i | 			v  at: i put: (4.0 - (1.0 / (v at: i-1))).			anArray at: i 				put: (6.0 * ((a at: i) - ((a at: i+1) * 2.0) + (a at: i+2))						- ((anArray at: i-1) / (v at: i-1)))].		 point2 at: len-1 put: ((anArray at: len-2) / (v at: len-2)).		 len - 2 to: 2 by: 0-1 do: 			[:i | 			point2 at: i 				put: ((anArray at: i-1) - (point2 at: i+1) / (v at: i-1))]].	point2 at: 1 put: (point2 at: len put: 0.0).	1 to: len - 1 do:		[:i | point1 at: i 				put: ((a at: i+1) - (a at: i) - 						((point2 at: i) * 2.0 + (point2 at: i+1) / 6.0)).		      point3 at: i put: ((point2 at: i+1) - (point2 at: i))]! !!PolygonMorph methodsFor: 'smoothing' stamp: 'di 9/7/2000 16:43'!lineSegmentsDo: endPointsBlock	"Emit a sequence of segment endpoints into endPointsBlock."	| n t x y x1 x2 x3 y1 y2 y3 beginPoint endPoint cs |	smoothCurve ifFalse:		[beginPoint _ nil.		vertices do:			[:vert | beginPoint ifNotNil:				[endPointsBlock value: beginPoint								value: vert].			beginPoint _ vert].		(closed or: [vertices size = 1])			ifTrue: [endPointsBlock value: beginPoint									value: vertices first].		^ self].	"For curves we include all the interpolated sub segments."	vertices size < 1 ifTrue: [^ self].	cs _ self coefficients.	beginPoint _ (x _ (cs at: 1) at: 1) @ (y _ (cs at: 5) at: 1).	1 to: (cs at: 1) size - 1 do: 		[:i |  "taylor series coefficients"		x1 _ (cs at: 2) at: i.		y1 _ (cs at: 6) at: i.		x2 _ ((cs at: 3) at: i) / 2.0.		y2 _ ((cs at: 7) at: i) / 2.0.		x3 _ ((cs at: 4) at: i) / 6.0.		y3 _ ((cs at: 8) at: i) / 6.0.		"guess n"		n _ 5 max: (x2 abs + y2 abs * 2.0 + ((cs at: 3) at: i+1) abs									+ ((cs at: 7) at: i+1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t _ j asFloat / n.			endPoint _ (x3 * t + x2 * t + x1 * t + x) @ (y3 * t + y2 * t + y1 * t + y).			endPointsBlock value: beginPoint							value: endPoint.			beginPoint _ endPoint].		endPoint _ (x _ (cs at: 1) at: i+1) @ (y _ (cs at: 5) at: i+1).		endPointsBlock value: beginPoint						value: endPoint.		beginPoint _ endPoint]! !!PolygonMorph methodsFor: 'smoothing' stamp: 'di 9/8/2000 11:33'!nextToFirstPoint  "For arrow direction"	smoothCurve		ifTrue: [ptAfterFirst ifNil: [self curveBounds].				^ ptAfterFirst]		ifFalse: [^ vertices at: 2]! !!PolygonMorph methodsFor: 'smoothing' stamp: 'di 9/8/2000 11:33'!nextToLastPoint  "For arrow direction"	smoothCurve		ifTrue: [ptBeforeLast ifNil: [self curveBounds].				^ ptBeforeLast]		ifFalse: [^ vertices at: vertices size - 1]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/7/2000 16:06'!addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[:vertPt :vertIndex |		handle _ EllipseMorph newBounds: (Rectangle center: vertPt extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		self addMorph: handle.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:fromHandle:afterVert:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	smoothCurve ifTrue: [self updateHandles; layoutChanged].	self changed! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/8/2000 10:40'!dragVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ self isCurve		ifTrue: [evt cursorPoint]		ifFalse: [self griddedPoint: evt cursorPoint].	handle position: p - (handle extent//2).	self verticesAt: ix put: p.! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/8/2000 09:56'!justDroppedInto: newOwner event: evt	| delta |	(newOwner isKindOf: PasteUpMorph) ifTrue:		["Compensate for border width so that gridded drop			is consistent with gridded drag of handles."		delta _ borderWidth+1//2.		self position: (newOwner gridPoint: self position + delta) - delta].	^ super justDroppedInto: newOwner event: evt! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/7/2000 16:27'!updateHandles	| newVert oldVert midPts nextVertIx tweens |	smoothCurve	ifTrue:		[midPts _ OrderedCollection new.		nextVertIx _ 2.		tweens _ OrderedCollection new.		self lineSegmentsDo:			[:p1 :p2 | 			tweens addLast: p2 asIntegerPoint.			p2 = (vertices atWrap: nextVertIx) ifTrue:				["Found endPoint."				midPts addLast: (tweens at: tweens size // 2)							+ (tweens at: tweens size + 1 // 2) // 2.				tweens _ OrderedCollection new.				nextVertIx _ nextVertIx + 1]].		midPts withIndexDo:			[:midPt :vertIndex |			(closed or: [vertIndex < vertices size]) ifTrue:				[newVert _ handles at: vertIndex*2.				newVert position: midPt - (newVert extent // 2)]]]	ifFalse:		[vertices withIndexDo:			[:vertPt :vertIndex |			oldVert _ handles at: vertIndex*2-1.			oldVert position: vertPt - (oldVert extent//2).			(closed or: [vertIndex < vertices size]) ifTrue:				[newVert _ handles at: vertIndex*2.				newVert position: (vertPt + (vertices atWrap: vertIndex+1)									- newVert extent) // 2 + (1@-1)]]]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/8/2000 10:39'!verticesAt: ix put: newPoint	vertices at: ix put: newPoint.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: 'di 9/7/2000 16:52'!addCustomMenuItems: aMenu hand: aHandMorph	| lineName |	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #handlesShowingPhrase target: self action: #showOrHideHandles.	vertices size > 2 ifTrue:		[aMenu addUpdating: #openOrClosePhrase target: self action: #makeOpenOrClosed.		lineName _ closed ifTrue: ['outline'] ifFalse: ['line'].		self isCurve			ifTrue: [aMenu add: 'make segmented ', lineName action: #toggleSmoothing]			ifFalse: [aMenu add: 'make smooth ', lineName action: #toggleSmoothing]]. 	aMenu addLine.	aMenu addWithLabel: '---' enablement: #enableRemoveArrows action:  #makeNoArrows.	aMenu addWithLabel: '-->' enablement: #enableForwardArrow action:  #makeForwardArrow.	aMenu addWithLabel: '<--' enablement: #enableBackArrow action:  #makeBackArrow.	aMenu addWithLabel: '<->' enablement: #enableBothArrows action:  #makeBothArrows.! !!PolygonMorph methodsFor: 'menu' stamp: 'di 9/7/2000 13:10'!quickFill: ignored! !!PolygonMorph methodsFor: 'menu' stamp: 'di 9/7/2000 15:43'!toggleSmoothing	smoothCurve _ smoothCurve not.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/8/2000 09:44'!computeBounds	vertices ifNil: [^ self].	self changed.	self releaseCachedState.	bounds _ self curveBounds.	self arrowForms do:		[:f | bounds _ bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	self layoutChanged.	self changed! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/7/2000 16:13'!curveBounds	| curveBounds |	smoothCurve ifFalse: [^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2].	"Compute the bounds from actual curve traversal, with leeway for borderWidth.	Also note the next-to-first and next-to-last points for arrow directions."	curveBounds _ vertices first corner: vertices last.	coeffs _ nil.  "Force recomputation"	ptAfterFirst _ nil.	self lineSegmentsDo:		[:p1 :p2 | ptAfterFirst == nil ifTrue: [ptAfterFirst _ p2 asIntegerPoint].		curveBounds _ curveBounds encompass: p2 asIntegerPoint.		ptBeforeLast _ p1 asIntegerPoint].	^ curveBounds expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/7/2000 13:30'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ Form extent: bounds extent+2.	"Draw the border..."	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	"Fill it in..."	filledForm convexShapeFill: Color black.	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue:		["If border is stored as a form, then erase any overlap now."		filledForm copy: self borderForm boundingBox from: self borderForm			to: 1@1 rule: Form erase].	^ filledForm! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/7/2000 16:17'!getVertices	smoothCurve ifFalse: [^ vertices].	"For curves, enumerate the full set of interpolated points"	^ Array streamContents:		[:s | self lineSegmentsDo: [:pt1 :pt2 | s nextPut: pt1]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/7/2000 16:22'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms do: [:f | f offset: f offset + delta].	coeffs _ nil.  "Force recomputation"! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/7/2000 16:24'!releaseCachedState	super releaseCachedState.	filledForm _ nil.	arrowForms _ nil.	borderForm _ nil.	coeffs _ nil.	ptAfterFirst_ ptBeforeLast_ nil.! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/8/2000 10:36'!setVertices: newVertices	vertices _ newVertices.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!BalloonMorph methodsFor: 'initialization' stamp: 'di 9/7/2000 17:20'!initialize	super initialize.	self beSmoothCurve.	color _ Color paleYellow.	borderColor _ Color black.	borderWidth _ 1.	offsetFromTarget _ 0@0! !!BlobMorph methodsFor: 'initialization' stamp: 'di 9/7/2000 17:21'!initialize	super initialize.	self beSmoothCurve.	random _ Random new.	sneaky _ random next < 0.75.	self initializeColor.	self initializeBlobShape.	self setVelocity! !!EnvelopeLineMorph methodsFor: 'as yet unclassified' stamp: 'di 9/8/2000 10:41'!dragVertex: evt fromHandle: handle vertIndex: ix	| p |	super dragVertex: evt fromHandle: handle vertIndex: ix.	p _ owner acceptGraphPoint: evt cursorPoint at: ix.	self verticesAt: ix put: p.! !!EnvelopeLineMorph methodsFor: 'as yet unclassified' stamp: 'di 9/8/2000 10:42'!newVertex: evt fromHandle: handle afterVert: ix	"Install a new vertex if there is room."	(owner insertPointAfter: ix) ifFalse: [^ self "not enough room"].	super newVertex: evt fromHandle: handle afterVert: ix.	self verticesAt: ix+1 put: (owner acceptGraphPoint: evt cursorPoint at: ix+1).! !!EnvelopeLineMorph methodsFor: 'as yet unclassified' stamp: 'di 9/7/2000 13:19'!vertices: verts borderWidth: bw borderColor: bc	super initialize.	vertices _ verts.	color _ Color transparent.	borderWidth _ bw.	borderColor _ bc.	closed _ false.	arrows _ #none.	self computeBounds.! !!LipsMorph methodsFor: 'initialization' stamp: 'di 9/7/2000 17:22'!initialize	super initialize. 	self beSmoothCurve.	vertices _ {11@3. 35@1. 60@5. 67@17. 34@24. 3@17}.	color _ Color black. "red darker."	borderColor _ Color black.	borderWidth _ 1.	closed _ true.	self neutral; updateShape! !!LipsMorph methodsFor: 'actions' stamp: 'di 9/8/2000 10:44'!updateShape	| center median |	newVertices isNil ifTrue: [^ self].	median _ 0 @ 0.	newVertices do: [ :each | median _ median + each].	median _ median / newVertices size.	center _ self center.	self setVertices: (newVertices collect: [ :each | (each - median) * newScale + median]).	self position: self position - self center + center.	newVertices _ nil! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 9/7/2000 17:05'!vertices: verts color: c borderWidth: bw borderColor: bc	^ self basicNew beStraightSegments vertices: verts color: c borderWidth: bw borderColor: bc! !!CurveMorph class methodsFor: 'as yet unclassified' stamp: 'di 9/7/2000 17:01'!new	^ PolygonMorph new beSmoothCurve! !!CurveMorph class methodsFor: 'as yet unclassified' stamp: 'di 9/7/2000 16:57'!vertices: verts color: c borderWidth: bw borderColor: bc	^ PolygonMorph basicNew beSmoothCurve		vertices: verts color: c borderWidth: bw borderColor: bc! !CurveMorph removeSelector: #addHandles!CurveMorph removeSelector: #coefficients!CurveMorph removeSelector: #computeCurve!CurveMorph removeSelector: #curveBounds!CurveMorph removeSelector: #derivs:first:second:third:!CurveMorph removeSelector: #getVertices!CurveMorph removeSelector: #isCurve!CurveMorph removeSelector: #lineSegmentsDo:!CurveMorph removeSelector: #nextToFirstPoint!CurveMorph removeSelector: #nextToLastPoint!CurveMorph removeSelector: #privateMoveBy:!CurveMorph removeSelector: #releaseCachedState!CurveMorph removeSelector: #updateHandles!PolygonMorph removeSelector: #fillPhrase!PolygonMorph removeSelector: #toggleFill!BorderedMorph subclass: #PolygonMorph	instanceVariableNames: 'vertices closed filledForm arrows arrowForms smoothCurve coeffs ptAfterFirst ptBeforeLast handles borderForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!