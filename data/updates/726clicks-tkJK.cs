'From Squeak 2.3 of January 14, 1999 on 12 March 1999 at 6:32:26 pm'!!BookPageThumbnailMorph methodsFor: 'all' stamp: 'tk 3/10/1999 11:25'!mouseDown: event	"turn the book to that page"	event setButtons: 0.	"Lie to it.  So mouseUp won't go to menu that may come up 		during fetch of a page in doPageFlip"	self doPageFlip.! !!Browser methodsFor: 'class functions' stamp: 'tk 3/12/1999 18:31'!classListMenu: aMenu^ aMenu labels: 'browse classbrowse full (b)printOutfileOuthierarchydefinitioncommentspawn hierarchyspawn protocolinst var refs..inst var defs..class var refs...class varsclass refs (N)rename...removeunsent methodsfind method...fetch documentation' 	lines: #(4 7 9 11 14 16)	selections:		#(buildClassBrowser browseMethodFull printOutClass fileOutClass		hierarchy editClass editComment		spawnHierarchy spawnProtocol		browseInstVarRefs browseInstVarDefs browseClassVarRefs 		browseClassVariables browseClassRefs		renameClass removeClass browseUnusedMethods findMethod		fetchClassDocPane)! !!Browser methodsFor: 'class functions' stamp: 'tk 3/12/1999 18:30'!fetchClassDocPane	"Look on servers to see if there is documentation pane for the selected class. Take into account the current update number.  If not, ask the user if she wants to create one."	DocLibrary external fetchDocSel: '' class: self selectedClassName! !!DocLibrary methodsFor: 'initialize' stamp: 'tk 3/9/1999 12:55'!setUp	"set up the External version"	| email |	self initialize.	External _ self.	group _ 'Squeak Public Updates'.	"right for http, but not for ftp"	lastUpdate _ 599.	lastUpdateName _ 'MTMcontainsPoint-ar.cs'.	DropBox _ ServerDirectory new.	DropBox server: 'squeak.cs.uiuc.edu'; directory: 'incoming'.	DropBox type: #ftp.	email _ nil.  "Celeste popUserName."	"If nil, we ask at drop time"	DropBox user: 'anonymous'; password: email.	DropBox moniker: 'Doc Pane DropBox'.		"later allow a second server"! !!DocLibrary methodsFor: 'doc pane' stamp: 'tk 3/12/1999 18:29'!fetchDocSel: aSelector class: className	"Look on servers to see if there is documentation pane for the selected message. Take into account the current update number.  If not, ask the user if she wants to create a blank one."	| key response docPane ext |	key _ aSelector size = 0 		ifFalse: [className, ' ', aSelector]		ifTrue: [className].	(self openDocAt: key) ifNil: [		response _ (PopUpMenu labels: 'Create new page\Cancel' withCRs)				startUpWithCaption: 'No documentation exists for this method.\Would you like to write some?' withCRs.		response = 1 ifTrue: [			docPane _ PasteUpMorph new.			docPane color: Color white; borderWidth: 2; borderColor: Color green.			docPane setProperty: #classAndMethod toValue: key.			docPane setProperty: #initialExtent toValue: (ext _ 200@200).			docPane topLeft: (RealEstateAgent initialFrameFor: docPane) origin.			docPane extent: ext.			docPane addMorph: (TextMorph new topLeft: docPane topLeft + (10@10);					extent: docPane width - 15 @ 30).			Smalltalk currentWorld addMorph: docPane]].	"If found, openDocAt: put it on the screen"! !!FileList methodsFor: 'file list menu' stamp: 'tk 3/12/1999 18:07'!putUpdate	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice) putUpdate: 				(directory oldFileNamed: self fullName).	self volumeListIndex: volListIndex.! !!MorphicEvent methodsFor: 'private' stamp: 'tk 3/10/1999 11:24'!setButtons: mask	buttons _ mask! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 3/12/1999 18:09'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	fileStrm size = 0 ifTrue: [^ self inform: 'That file has zero bytes!!  May have a new name.'].	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 65 2170)f1b,f1,f1LUtilities class readServerUpdatesThrough:saveLocally:updateImage:;,f1! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 3/11/1999 10:20'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesThrough: 828 saveLocally: false updateImage: true""Utilities readServerUpdatesThrough: 828 saveLocally: true updateImage: true"	| doc urls failed loaded str |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	Cursor wait showWhile: [(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: (Utilities serverUrls collect: [:url | url, 'updates/']) 				throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil:			[doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			doc class == String ifTrue: [failed _ this]].	"an error loading"		failed ifNil: [			doc reset; text.			doc size = 0 ifTrue: [failed _ this]].		failed ifNil: [			doc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage ifTrue:					[ChangeSorter newChangesFromStream: doc					named: (this findTokens: '/') last].			saveLocally ifTrue:				[self saveUpdate: doc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1]]].	str _ loaded printString ,' new update files processed.'.	failed ifNotNil: [str _ str, '\Could not load ' withCRs, 		(urls size - loaded) printString ,' update files.',		'\Starting with "' withCRs, failed, '".'].	failed ifNil: [DocLibrary external ifNotNil: [			DocLibrary external updateMethodVersions]].	self inform: str.! !