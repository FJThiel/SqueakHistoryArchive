'From Squeak3.1alpha of 5 February 2001 [latest update: #4346] on 25 September 2001 at 2:44:09 pm'!"Change Set:		ByteArrayRangeCheckDate:			22 September 2001Author:			Dan IngallsAndreas Raab reported...	| bb | (bb _ ByteArray new: 1) byteAt: 1 put: 257.  bb		==> a ByteArray(1)The fast version of at:put: was missing a value range check on byte values.This fileIn fixes it, but requires a new VM to be built to get the benefit.Also includes several fixes needed to run the InterpreterSimulator:	Uninitialized variable newNativeMethod	Fix to BitBlt for indexing into color maps	Ability of simulator to accept typing in Morphic (doesn't work yet on my mac)	Ability of simulator to read and write the clipboardAlso removes logging of plugin activity to Transcript in ioLoadFunction:From:."!!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 9/23/2001 10:26'!pickSourcePixels: nPixels flags: mapperFlags srcMask: srcMask destMask: dstMask srcShiftInc: srcShiftInc dstShiftInc: dstShiftInc	"Pick nPix pixels starting at srcBitIndex from the source, map by the	color map, and justify them according to dstBitIndex in the resulting destWord."	| sourceWord destWord sourcePix destPix srcShift dstShift nPix |	self inline: true. "oh please"	sourceWord _ self srcLongAt: sourceIndex.	destWord _ 0.	srcShift _ srcBitShift. "Hint: Keep in register"	dstShift _ dstBitShift. "Hint: Keep in register"	nPix _ nPixels. "always > 0 so we can use do { } while(--nPix);"	(mapperFlags = (ColorMapPresent bitOr: ColorMapIndexedPart)) ifTrue:[		"a little optimization for (pretty crucial) blits using indexed lookups only"		[	"grab, colormap and mix in pixel"			sourcePix _ sourceWord >> srcShift bitAnd: srcMask.			destPix _ self tableLookup: cmLookupTable at: (sourcePix bitAnd: cmMask).			destWord _ destWord bitOr: (destPix bitAnd: dstMask) << dstShift.			"adjust dest pix index"			dstShift _ dstShift + dstShiftInc.			"adjust source pix index"			((srcShift _ srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift _ srcShift + 32] ifFalse:[srcShift _ srcShift - 32].				sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].		(nPix _ nPix - 1) = 0] whileFalse.	] ifFalse:[		[	"grab, colormap and mix in pixel"			sourcePix _ sourceWord >> srcShift bitAnd: srcMask.			destPix _ self mapPixel: sourcePix flags: mapperFlags.			destWord _ destWord bitOr: (destPix bitAnd: dstMask) << dstShift.			"adjust dest pix index"			dstShift _ dstShift + dstShiftInc.			"adjust source pix index"			((srcShift _ srcShift + srcShiftInc) bitAnd: 16rFFFFFFE0) = 0 ifFalse:[				sourceMSB ifTrue:[srcShift _ srcShift + 32] ifFalse:[srcShift _ srcShift - 32].				sourceWord _ self srcLongAt: (sourceIndex _ sourceIndex + 4)].		(nPix _ nPix - 1) = 0] whileFalse.	].	srcBitShift _ srcShift. "Store back"	^destWord! !!BitBltSimulation methodsFor: 'memory access' stamp: 'di 9/23/2001 10:28'!tableLookup: table at: index	^ table at: index! !!BitBltSimulator methodsFor: 'as yet unclassified' stamp: 'di 9/23/2001 10:28'!tableLookup: table at: index	^ interpreterProxy longAt: (table + (index * 4))! !!EventSensor methodsFor: 'keyboard' stamp: 'di 9/23/2001 16:39'!primKbdNext	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| evtBuf |	inputSemaphore signal.	keyboardBuffer isEmpty ifFalse:[^ keyboardBuffer next].	eventQueue ifNotNil:		[evtBuf _ (Sensor eventQueue ifNil: [^nil]) nextOrNilSuchThat:			[:buf | (buf at: 1) = EventTypeKeyboard and: [(buf at: 4) = EventKeyChar]].		eventQueue flush].	^ evtBuf ifNotNil: [evtBuf at: 3]! !!EventSensor methodsFor: 'keyboard' stamp: 'di 9/23/2001 16:41'!primKbdPeek	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| char |	inputSemaphore signal.	keyboardBuffer isEmpty ifFalse: [ ^keyboardBuffer peek].	char _ nil.	eventQueue ifNotNil:		["Note: This PEEKs so it always returns nil"		eventQueue nextOrNilSuchThat:			[ :buf |			((buf at: 1) = EventTypeKeyboard and: [(buf at: 4) = EventKeyChar])				ifTrue: [char ifNil: [char _ buf at: 3]].			false]].	^ char! !!Interpreter methodsFor: 'initialization' stamp: 'di 9/23/2001 09:24'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	interpreterProxy _ self sqGetInterpreterProxy.	self initializeObjectMemory: bytesToShift.	self initCompilerHooks.	self flushExternalPrimitives.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	methodClass		_ nilObj.	lkupClass		_ nilObj.	receiverClass	_ nilObj.	newNativeMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	interruptCheckCounterFeedBackReset _ 1000.	interruptChecksEveryNms _ 5.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresUseBufferA _ true.	semaphoresToSignalCountA _ 0.	semaphoresToSignalCountB _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 9/22/2001 10:00'!commonVariable: rcvr at: index put: value cacheIndex: atIx	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields valToPut |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self storePointer: index + fixedFields - 1 ofObject: rcvr withValue: value].		fmt < 8 ifTrue:  "Bitmap"			[valToPut _ self positive32BitValueOf: value.			successFlag ifTrue: [self storeWord: index - 1 ofObject: rcvr withValue: valToPut].			^ nil].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: [valToPut _ self asciiOfCharacter: value.					successFlag ifFalse: [^ nil]]			ifFalse: [valToPut _ value].		(self isIntegerObject: valToPut) ifTrue:			[valToPut _ self integerValueOf: valToPut.			((valToPut >= 0) and: [valToPut <= 255]) ifFalse: [^ self primitiveFail].			^ self storeByte: index - 1 ofObject: rcvr withValue: valToPut]].	self primitiveFail! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 9/22/2001 22:22'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside	Smalltalk. The primary responsibility of this method is to allocate	Smalltalk Arrays for variables that will be declared as statically-allocated	global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	atCache _ Array new: AtCacheTotalSize.	self flushMethodCache.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresUseBufferA _ true.	semaphoresToSignalA _ Array new: SemaphoresToSignalSize.	semaphoresToSignalB _ Array new: SemaphoresToSignalSize.	externalPrimitiveTable _ CArrayAccessor on: (Array new: MaxExternalPrimitiveTableSize).	obsoleteNamedPrimitiveTable _ 		CArrayAccessor on: self class obsoleteNamedPrimitiveTable.	obsoleteIndexedPrimitiveTable _ CArrayAccessor on: 		(self class obsoleteIndexedPrimitiveTable collect:[:spec| 			CArrayAccessor on:				(spec ifNil:[Array new: 3] 					  ifNotNil:[Array with: spec first with: spec second with: nil])]).	pluginList _ #().	mappedPluginEntries _ #().	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 9/23/2001 09:25'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes |	"open image file and read the header"	f _ FileStream readOnlyFileNamed: fileName.	imageName _ f fullName.	f binary.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	(self readableFormat: version)		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	savedWindowSize	_ self nextLongFrom: f swap: swapBytes.	fullScreenFlag		_ self nextLongFrom: f swap: swapBytes.	extraVMMemory		_ self nextLongFrom: f swap: swapBytes.	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/2001 12:26'!clipboardRead: sz Into: actualAddress At: zeroBaseIndex	| str |	str _ Clipboard clipboardText.	1 to: sz do:		[:i | self byteAt: actualAddress + zeroBaseIndex + i - 1 put: (str at: i) asciiValue]! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/2001 12:18'!clipboardSize	^ Clipboard clipboardText size! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/2001 17:36'!clipboardWrite: sz From: actualDataAddress At: ignored	Clipboard clipboardText: (self stringOf: actualDataAddress - BaseHeaderSize)! !!InterpreterSimulator methodsFor: 'plugin support' stamp: 'di 9/23/2001 17:48'!ioLoadFunction: functionString From: pluginString	"Load and return the requested function from a module"	| plugin fnSymbol |	fnSymbol _ functionString asSymbol.	"Transcript cr; show:'Looking for ', functionString, ' in ', pluginString."	plugin _ pluginList 				detect:[:any| any key = pluginString asString]				ifNone:[self loadNewPlugin: pluginString].	plugin ifNil:[		"Transcript cr; show:'Failed ... no plugin found'." ^ 0].	plugin _ plugin value.	mappedPluginEntries doWithIndex:[:pluginAndName :index|		((pluginAndName at: 1) == plugin 			and:[(pluginAndName at: 2) == fnSymbol]) ifTrue:[				"Transcript show:' ... okay'." ^ index]].	(plugin respondsTo: fnSymbol) ifFalse:[		"Transcript cr; show:'Failed ... primitive not in plugin'." ^ 0].	mappedPluginEntries _ mappedPluginEntries copyWith: (Array with: plugin with: fnSymbol).	"Transcript show:' ... okay'."	^ mappedPluginEntries size! !