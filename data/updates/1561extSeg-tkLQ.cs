'From Squeak2.6 of 11 October 1999 [latest update: #1560] on 19 October 1999 at 7:16:46 am'!!Class methodsFor: 'accessing class hierarchy' stamp: 'tk 10/17/1999 13:31'!addSubclass: aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [^self error: aSubclass name , ' is not my subclass'].	subclasses == nil		ifTrue:	[subclasses _ Array with: aSubclass.				^self].	subclasses do:[:cl| cl == aSubclass ifTrue:[^self]]. "Already my subclass"	subclasses _ subclasses copyWith: aSubclass.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/12/1999 20:01'!copyFromRootsForExport: rootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	[self copyFromRoots: arrayOfRoots.	(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"do over to include methods pointed at by blocks"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 10/14/1999 18:14'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			aFakeClass allInstancesDo: [:misShapen | 				perfect _ smartRefStream convert: misShapen 							to: (mapFakeClassesToReal at: aFakeClass).				(bads includes: misShapen) ifFalse: [					bads add: misShapen.					goods add: perfect]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	self rehashSets.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [			Project allInstancesDo: [:pp | pp ~~ aRoot ifTrue: [				pp name = aRoot name ifTrue: [					aRoot projectChangeSet name: ChangeSet defaultName]]]].		aRoot class class == Metaclass ifTrue: [			self declare: aRoot.			aRoot category: 'Newly-Imported']].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 10/13/1999 14:49'!declare: classThatIsARoot	| existing |	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	(Smalltalk includesKey: classThatIsARoot name) ifFalse: [		"Class entry in Smalltalk not referred to in Segment, install anyway."		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing _ Smalltalk at: classThatIsARoot name.	existing xxxClass == ImageSegmentRootStub ifTrue: [		"We are that segment!!  Must ask it carefully!!"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing == false ifTrue: [		"association is in outPointers, just installed"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	"Conflict with existing global or copy of the class"	(existing isKindOf: Class) ifTrue: [		classThatIsARoot isSystemDefined not ifTrue: [			"UniClass.  give it a new name"			classThatIsARoot setName: Player chooseUniqueClassName.			^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].		"Take the incoming one"		self inform: 'Using newly arrived version of ', classThatIsARoot name.		^ (Smalltalk at: classThatIsARoot name) becomeForward: classThatIsARoot].	self error: 'Name already in use by a non-class: ', classThatIsARoot name.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 10/17/1999 19:05'!storeDataOn: aDataStream	"Don't wrote the array of Roots.  Also remember the structures of the classes of objects inside the segment."	| tempRoots tempOutP |	state = #activeCopy ifFalse: [self error: 'wrong state'].		"real state is activeCopy, but we changed it will be right when coming in"	tempRoots _ arrayOfRoots.	tempOutP _ outPointers.	outPointers _ outPointers clone.	self prepareToBeSaved.	arrayOfRoots _ nil.	state _ #imported.	super storeDataOn: aDataStream.		"record my inst vars"	arrayOfRoots _ tempRoots.	outPointers _ tempOutP.	state _ #activeCopy.	aDataStream references at: #AnImageSegment put: false.		"flag that there is one in this write"! !!Morph methodsFor: 'e-toy support' stamp: 'tk 10/19/1999 07:16'!updateCachedThumbnail	"If I have a cached thumbnail, then update it.  Copied up from Dan's original version in PasteUpMorph so it can be used by all morphs."	| cachedThumbnail |	(cachedThumbnail _ self valueOfProperty: #cachedThumbnail) ifNotNil:		[(cachedThumbnail respondsTo: #computeThumbnail) 			ifTrue: [cachedThumbnail computeThumbnail]			ifFalse: [self removeProperty: #computeThumbnail]].		"Test and removal are because the thumbnail is being replaced by another Morph.  We don't know why.  Need to fix that at the source."! !!Project methodsFor: 'file in/out' stamp: 'tk 10/17/1999 19:04'!exportSegment	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?"| is response str ans |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].is _ ImageSegment new copyFromRootsForExport: 	(Array with: self).	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anyway') startUpWithCaption: str.	ans = 1 ifTrue: [^ false]].is writeForExport: self name.^ true! !!ProjectViewMorph methodsFor: 'fileIn/out' stamp: 'tk 10/12/1999 19:38'!exportSegment	"Store my project out on the disk as an ImageSegment that can be brought into other images.  Write the outPointers on the file also.  Name it <project name>.extSeg"	project exportSegment.! !