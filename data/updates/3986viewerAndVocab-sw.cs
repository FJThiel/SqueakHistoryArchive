'From Squeak3.1alpha of 28 February 2001 [latest update: #3981] on 4 May 2001 at 9:48:41 pm'!"Change Set:		viewerAndVocab-swDate:			4 May 2001Author:			Scott WallaceMany enhancements & fixes concerning use of Viewers for objects other than morph/player pairs, and use of vocabularies other than the etoy vocabulary, and with both universal and classic tiles.Adds an example 'Quad' vocabulary to illustrate the creation and use of custom vocabularies.  To observe this custom vocabulary in action evaluate 'Quadrangle exampleInViewer'"!!ObjectWithDocumentation commentStamp: 'sw 5/3/2001 16:52' prior: 0!ObjectWithDocumentation - an abstract superclass for objects that allows maintenance of an authoring stamp, a body of documentation, and a properties dictionary.The Properties implementation has not happened yet -- it would closely mirror the implemenation of properties in the MorphExtension, for example.!!Vocabulary commentStamp: 'sw 5/3/2001 16:51' prior: 0!VocabularyvocabularyName	a Symbol -- the formal name by which this vocabulary is known.categories			a list of ElementCategory objects: the categories that comprise the vocabularymethodInterfaces 	an IdentityDictionary; keys are method selectors, values are MethodInterfacesA Vocabulary can be either be *abstract*, i.e. associated with a *class*, or it can be *bound to an instance*.  The form that is bound to an instance is still in its infancy however.object				in the *bound* form, an actual object is associated with the vocabularylimitClass			in the *bound* form, an actual limit class is assocaited with the vocabularyAllMethodInterfaces	This class variable is available to hold on to all method interfaces						defined in the system, regardless of class.  Not deployed in 						the first version of this code to be circulated externally.AllVocabularies		A dictionary associating symbols with actual abstract vocabulary instances!!Object methodsFor: 'testing' stamp: 'sw 5/3/2001 16:19'!beViewed	"Open up a viewer on the receiver.  The Presenter is invited to decide just how to present this viewer"	self uniqueNameForReference.  "So the viewer will have something nice to refer to"	self presenter viewObject: self! !!Object methodsFor: 'testing' stamp: 'sw 5/3/2001 18:22'!vocabularyDemanded	"Answer a vocabulary that the receiver insists be used when it is looked at in a Viewer.  This allows specific classes to insist on specific custom vocabularies"	^ nil! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:04'!externalName	"Answer an external name by which the receiver is known.  Generic implementation here is a transitional backstop. probably"	^ self nameForViewer! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:06'!graphicForViewerTab	"When a Viewer is open on the receiver, its tab needs some graphic to show to the user.  Answer a form or a morph to serve that purpose.  A generic image is used for arbitrary objects, but note my reimplementors"		^ ScriptingSystem formAtKey: 'Image'! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:08'!hasUserDefinedSlots	"Answer whether the receiver has any user-defined slots, in the omniuser sense of the term.  This is needed to allow Viewers to look at any object, not just at Players."	^ false! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 22:07'!offerViewerMenuFor: aViewer event: evt	"Offer the primary Viewer menu to the user.  Copied up from Player code, but most of the functions suggested here don't work for non-Player objects, many aren't even defined, some relate to exploratory sw work not yet reflected in the current corpus.  We are early in the life cycle of this method..."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu title: '**CAUTION -- UNDER CONSTRUCTION!!**Many things may not work!!', self nameForViewer.	(aViewer affordsUniclass and: [self belongsToUniClass not]) ifTrue:		[aMenu add: 'give me a Uniclass' action: #assureUniClass.		aMenu addLine].	aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary.	self belongsToUniClass ifTrue:		[aMenu add: 'add a new instance variable' target: self selector: #addInstanceVariableIn: argument: aViewer.		aMenu add: 'add a new script' target: aViewer selector: #newPermanentScriptIn: argument: aViewer.		aMenu addLine.		aMenu add: 'make my class be first-class' target: self selector: #makeFirstClassClassIn: argument: aViewer.		aMenu add: 'move my changes up to my superclass' target: self action: #promoteChangesToSuperclass.		aMenu addLine].	aMenu add: 'tear off a tile' target: self selector: #launchTileToRefer.	aMenu addLine.	aMenu add: 'inspect me' target: self selector: #inspect.	aMenu add: 'inspect my class' target: self class action: #inspect.	aMenu addLine.	aMenu add: 'browse vocabulary' action: #haveFullProtocolBrowsed.	aMenu add: 'inspect this Viewer' target: aViewer action: #inspect.	aMenu popUpEvent: evt in: aViewer currentWorld"	aMenu add: 'references to me' target: aViewer action: #browseReferencesToObject.	aMenu add: 'toggle scratch pane' target: aViewer selector: #toggleScratchPane.	aMenu add: 'make a nascent script for me' target: aViewer selector: #makeNascentScript.	aMenu add: 'rename me' target: aViewer selector: #chooseNewNameForReference.	aMenu add: 'browse full' action: #browseOwnClassFull.	aMenu add: 'browse hierarchy' action: #browseOwnClassHierarchy.	aMenu add: 'set user level...' target: aViewer action: #setUserLevel.	aMenu add: 'browse sub-protocol' action: #browseOwnClassSubProtocol.	aMenu addLine."! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:30'!tileForArgType: aType	"Anwer a default tile to represent a datum of the given argument type"	| aColor |	aType == #player ifTrue:		[^ self presenter standardPlayer tileToRefer].	aColor _ ScriptingSystem colorForType: aType.	aType == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	aType == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	aType == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	aType == #sound ifTrue: [^ SoundTile new typeColor: aColor].	aType == #graphic ifTrue: [^ GraphicTile new typeColor: aColor].	aType == #menu ifTrue: [^ MenuTile new typeColor: aColor].	aType == #object ifTrue: [^ 'arg' newTileMorphRepresentative typeColor: aColor].	aType == #color ifTrue: [^ Color blue newTileMorphRepresentative].	aType == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType: aType]. 	(aType isKindOf: Class)		ifTrue:			[^ aType name asString newTileMorphRepresentative typeColor: aColor].	(Smalltalk at: aType ifAbsent: [nil]) ifNotNilDo:		[:aClass | ^ aClass name asString newTileMorphRepresentative typeColor: aColor].	self error: 'Unrecognized type'! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:19'!tilePhrasesForCategory: aCategory inViewer: aViewer	"Return a collection of phrases for the category.  If using classic tiles, only include phrases that have fewer than two arguments, because all that they can handle."	| interfaces itsSelector |	interfaces _ self methodInterfacesForCategory: aCategory inViewer: aViewer.	Preferences universalTiles ifFalse:		[interfaces _ interfaces select:			[:int |				itsSelector _ int selector.				itsSelector numArgs < 2 or:					"The lone two-arg loophole in classic tiles"					[#(color:sees:) includes: itsSelector]]].	^ interfaces collect:		[:aMethodInterface |			aMethodInterface wantsReadoutInViewer				ifTrue:					[aViewer phraseForVariableFrom: aMethodInterface]				ifFalse:					[aViewer phraseForCommandFrom: aMethodInterface]]! !!Object methodsFor: 'viewer' stamp: 'sw 5/4/2001 04:51'!tileToRefer	"Answer a reference tile that comprises an alias to me"	^ TileMorph new setToReferTo: self! !!Object methodsFor: 'scripts-kernel' stamp: 'sw 5/4/2001 05:01'!universalTilesForGetterOf: aMethodInterface	"Return universal tiles for a getter on the given method interface.  Record who self is."	| ms argTile argArray itsSelector itsWording |	itsSelector _ aMethodInterface selector.	argArray _ #().	(itsWording _ aMethodInterface elementWording) == #colorSees ifTrue:		[itsSelector _ #color:sees:.		argTile _ self tileForArgType: #color.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy].	itsWording == #isOverColor ifTrue:		[itsSelector _ #seesColor:.		argTile _ self tileForArgType: #color.		argArray _  Array with: argTile colorSwatch color].	itsWording == #touchesA ifTrue:		[itsSelector _ #touchesA:.		argTile _ self tileForArgType: #player.		argArray _ Array with: argTile actualObject].	ms _ MessageSend receiver: self selector: itsSelector arguments: argArray.	^ ms asTilesIn: self class! !!Object methodsFor: 'scripts-kernel' stamp: 'sw 5/2/2001 23:57'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList |	itsSelector _ aMethodInterface selector.	argList _ OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile _ self tileForArgType: (aType _ aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms _ MessageSend receiver: self selector: itsSelector arguments: argList asArray.	^ ms asTilesIn: self class! !!Object methodsFor: 'scripts-kernel' stamp: 'sw 5/4/2001 18:07'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putter	"Answer a readout tile representing the given part's value, given the putter, getter, and type information"	| aColor aTile displayer putSelector |	putSelector _ putter ifNotNil:		[(#(none nil unused) includes: putter) ifTrue: [nil] ifFalse: [putter]].	aColor _ Color lightGray lighter.	typeSymbol == #number ifTrue:		[aTile _ NumericReadoutTile new typeColor: aColor].	typeSymbol == #sound ifTrue:		[aTile _ SoundReadoutTile new typeColor: aColor].	typeSymbol == #buttonPhase ifTrue:		[aTile _ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol].	aTile ifNil: [aTile _ StringReadoutTile new typeColor: aColor].	displayer _ UpdatingStringMorph new		getSelector: getSelector;		target: self;		growable: true;		minimumWidth: 24;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	typeSymbol == #string		ifTrue:			[displayer useStringFormat.			displayer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[displayer useStringFormat]				ifFalse:	[displayer useDefaultFormat]].	aTile addMorphBack: displayer.	(putSelector notNil and: [#(number sound boolean buttonPhase) includes: typeSymbol])  ifTrue: [aTile addArrows].	getSelector numArgs == 0 ifTrue:		[aTile setLiteralInitially: (self perform: getSelector)].	^ aTile! !!Behavior methodsFor: 'testing' stamp: 'sw 5/4/2001 07:44'!implementsVocabulary: aVocabulary	"Answer whether instances of the receiver respond to the messages in aVocabulary."	(aVocabulary isKindOf: FullVocabulary orOf: ScreenedVocabulary) ifTrue: [^ true].	^ self fullyImplementsVocabulary: aVocabulary! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 5/3/2001 15:06'!hasReportableSlip	"Answer whether the receiver contains anything that should be brought to the attention of the author when filing out.   Customize the lists here to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'checkForSlips' is set to true."	| assoc | 	#(doOnlyOnce: halt halt: hottest printDirectlyToDisplay toRemove personal urgent) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!Form methodsFor: 'displaying' stamp: 'sw 5/3/2001 16:23'!graphicForViewerTab	"Answer the graphic to be used in the tab of a viewer open on me"	^ self! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 5/4/2001 07:02'!selector: aSelector type: aType setter: aSetter	"Set the receiver's fields as indicated.  Values of nil or #none for the result type and the setter indicate that there is none"	selector _ aSelector.	(MethodInterface isNullMarker: aType) ifFalse:		[resultSpecification _ ResultSpecification new.		resultSpecification resultType: aType.		(MethodInterface isNullMarker: aSetter) ifFalse:			[resultSpecification companionSetterSelector: aSetter]]! !!MethodInterface methodsFor: 'attribute keywords' stamp: 'sw 5/2/2001 21:33'!wording: aWording selector: aSelector type: aType setter: aSetter	"Set the receiver's fields as indicated.  Values of nil or #none for the result type and the setter indicate that there is none"	elementWording _ aWording.	self selector: aSelector type: aType setter: aSetter! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 5/2/2001 21:19'!argumentVariables: variableList	"Set the argument variables"	argumentVariables _ variableList! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 5/4/2001 05:36'!initializeFromEToySlotSpec: tuple	"tuple holds an old etoy slot-item spec, of the form found in #additionsToViewerCategories methods.   Initialize the receiver to hold the same information"	| setter |	selector _ tuple seventh.	elementWording _ tuple second.	self documentation: tuple third.	receiverType _ #player.	resultSpecification _ ResultSpecification new.	resultSpecification resultType: tuple fourth.	self setToRefetch.	((tuple fifth == #readWrite) and: [((tuple size >= 9) and: [(setter _ tuple at: 9) ~~ #unused])]) ifTrue:		[resultSpecification companionSetterSelector: setter].		"An example of an old slot-item spec:(slot numericValue 'A number representing the current position of the knob.' number readWrite player getNumericValue player setNumericValue:)	1	#slot	2	wording	3	balloon help	4	type	5	#readOnly or #readWrite	6	#player (not used -- ignore)	7	getter selector	8	#player (not used -- ignore)	9	setter selector"	! !!MethodInterface methodsFor: 'initialization' stamp: 'sw 5/3/2001 15:59'!setToRefetch	"Set the receiver up to expect a refetch, assuming it has a result specification"	resultSpecification ifNotNil: [resultSpecification refetchFrequency: 1]! !!MethodInterface methodsFor: 'access' stamp: 'sw 5/4/2001 07:01'!elementWording: aWording	"Set the wording of the element"	elementWording _ (MethodInterface isNullMarker: aWording)		ifTrue:	[nil]		ifFalse: [aWording]! !!MethodInterface methodsFor: 'access' stamp: 'sw 5/3/2001 01:10'!wantsReadoutInViewer	"Answer whether the method represented by the receiver is one which should have a readout in a viewer"	^ resultSpecification notNil and:		[resultSpecification refetchFrequency notNil]! !!MethodInterface class methodsFor: 'utilities' stamp: 'sw 5/4/2001 07:00'!isNullMarker: aMarker	"Answer true if aMarker is nil or is one of the symbols in #(none nil unused missing) -- to service a variety of historical conventions"	^ aMarker isNil or: [#(none nil unused missing) includes: aMarker]"MethodInterface isNullMarker: nilMethodInterface isNullMarker: #noneMethodInterface isNullMarker: #znak"! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 5/3/2001 21:04'!currentVocabularyFor: aScriptableObject	"Answer the Vocabulary object to be applied when scripting an object in the world."	^ self valueOfProperty: #currentVocabulary ifAbsent:		[(aScriptableObject isKindOf: Player)			ifTrue:				[Vocabulary eToyVocabulary]			ifFalse:				[Vocabulary fullVocabulary]]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 5/3/2001 20:56'!removeAllViewers	"Delete all the viewers lined up along my right margin."	(self submorphs select: [:m | m isKindOf: ViewerFlapTab]) do:		[:m |			m referent ifNotNil: [m referent delete].			m delete.]! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'sw 5/4/2001 07:22'!makeTile	"Make a scripting tile to fetch the current phoneme's mouth position. Attach it to the hand, allowing the user to drop it directly into a tile script."	| tile argTile |	tile _ PhraseTileMorph new setSlotRefOperator: #mouthPosition type: #number.	argTile _ self tileToRefer.	argTile bePossessive.	tile firstSubmorph addMorph: argTile.	tile enforceTileColorPolicy.	ActiveHand attachMorph: tile! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/4/2001 05:04'!tilesToCall: aMethodInterface	"Answer a phrase for the non-typed command represented by aMethodInterface."	| resultType cmd argType argTile selfTile aPhrase balloonTextSelector aDocString universal |	self class namedTileScriptSelectors.	resultType _ aMethodInterface resultType.	cmd _ aMethodInterface selector.	(universal _ self isUniversalTiles)		ifTrue:			[aPhrase _ self universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType _ aMethodInterface typeForArgumentNumber: 1.				aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ self tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(self slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector _ #userSlot].	(self belongsToUniClass and: [self class includesSelector: cmd])		ifTrue:			[aDocString _ (self class userScriptForPlayer: self selector: cmd) documentationOrNil.			aDocString ifNotNil:					[aPhrase submorphs second setBalloonText: aDocString]				ifNil:					[balloonTextSelector _ #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	universal ifFalse:		[selfTile _ self tileToRefer.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile.		aPhrase makeAllTilesGreen.		aPhrase justGrabbedFromViewer: false].	^ aPhrase! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/4/2001 07:23'!universalTilesForGetterOf: aMethodInterface	"Return universal tiles for a getter on the given method interface.  Record who self is."	| ms argTile argArray itsSelector itsWording |	itsSelector _ aMethodInterface selector.	argArray _ #().	"Three gratuituous special cases..."	(itsWording _ aMethodInterface elementWording) == #colorSees ifTrue:		[itsSelector _ #color:sees:.		argTile _ self tileForArgType: #color.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy].	itsWording == #isOverColor ifTrue:		[itsSelector _ #seesColor:.		argTile _ self tileForArgType: #color.		argArray _  Array with: argTile colorSwatch color].	itsWording == #touchesA ifTrue:		[itsSelector _ #touchesA:.		argTile _ self tileForArgType: #player.		argArray _ Array with: argTile actualObject].	ms _ MessageSend receiver: self selector: itsSelector arguments: argArray.	^ ms asTilesIn: self class! !!Player methodsFor: 'misc' stamp: 'sw 5/2/2001 23:46'!graphicForViewerTab	"Answer the graphic to show in the tab of a Viewer looking at me"	^ self costume renderedMorph! !!Player methodsFor: 'misc' stamp: 'sw 5/4/2001 07:12'!tileReferringToSelf	"answer a tile that refers to the receiver"	| aTile  nn tile |	Preferences universalTiles ifTrue:		[nn _ self externalName. 	"name it, if necessary, and put in References"		(References includesKey: nn asSymbol) ifFalse: [			 References at: nn asSymbol put: self].		tile _ SyntaxMorph new parseNode: 			(VariableNode new name: nn key: nn code: nil).		tile layoutInset: 1; addMorph: (tile addString: nn special: false).		tile color: (SyntaxMorph translateColor: #variable).		tile extent: tile firstSubmorph extent + (2@2).		^ tile].	aTile _ TileMorph new setToReferTo: self.	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 5/4/2001 05:19'!tileToRefer	"Answer a reference tile that comprises an alias to me.  Forgive this temporary and seemingly gratuituous revectoring as worlds collide"	^ self tileReferringToSelf! !!Presenter methodsFor: 'viewer' stamp: 'sw 5/4/2001 04:27'!nascentPartsViewerFor: aViewee	"Create a new, naked Viewer object for viewing aViewee.  Give it a vocabulary if either the viewee insists on one or if the project insists on one."	| aViewer aVocab |	aViewer _ StandardViewer new.	(aVocab _ aViewee vocabularyDemanded)		ifNotNil:			[aViewer useVocabulary: aVocab]		ifNil:			[(aVocab _ associatedMorph currentVocabularyFor: aViewee) ifNotNil:				[aViewer useVocabulary: aVocab]].		"If the viewee does not *demand* a special kind of Viewer, and if the project has not specified a preferred vocabulary, then the system defaults will kick in later"	^ aViewer! !!Presenter methodsFor: 'viewer' stamp: 'sw 5/4/2001 07:23'!viewObject: anObject	"Open up a viewer on the given object"	|  aViewer aRect aPoint nominalHeight aFlapTab flapLoc |	anObject isMorph ifTrue: [^ self viewMorph: anObject].  "historic morph/player implementation"	associatedMorph addMorph: (aViewer _ self nascentPartsViewerFor: anObject).	"19 sept 2000 - allow flaps in any paste up (bob arning)"	flapLoc _ associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: anObject barHeight: 0.		aViewer enforceTileColorPolicy.		flapLoc hideViewerFlapsOtherThanFor: anObject.		aFlapTab _ flapLoc viewerFlapTabFor: anObject.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		^ flapLoc startSteppingSubmorphsOf: aViewer].			aViewer initializeFor: anObject barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint _ anObject bounds right @ 			(anObject center y - ((nominalHeight _ aViewer initialHeightToAllow) // 2)).		aRect _ (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ self].	anObject primaryHand attachMorph: (aViewer visible: true)! !!Quadrangle methodsFor: 'bordering' stamp: 'sw 5/4/2001 18:30'!setHeight: aNumber 	"Set the receiver's height"	self region: (origin extent: (self width @ aNumber))! !!Quadrangle methodsFor: 'bordering' stamp: 'sw 5/4/2001 17:54'!setLeft: aNumber 	"Move the receiver so that its left edge is given by aNumber.  An example of a setter to go with #left"	self region: ((aNumber @ origin y) extent: self extent)! !!Quadrangle methodsFor: 'bordering' stamp: 'sw 5/4/2001 18:19'!setRight: aNumber 	"Move the receiver so that its right edge is given by aNumber.  An example of a setter to go with #right"	self region: ((origin x + (aNumber - self right) @ origin y) extent: self extent)! !!Quadrangle methodsFor: 'bordering' stamp: 'sw 5/4/2001 18:26'!setWidth: aNumber 	"Set the receiver's width"	self region: (origin extent: (aNumber @ self height))! !!Quadrangle methodsFor: 'vocabulary' stamp: 'sw 5/4/2001 16:45'!vocabularyDemanded	"Answer the vocabulary that the receiver really would like to use in a Viewer"	^ Vocabulary quadVocabulary! !!Quadrangle class methodsFor: 'instance creation' stamp: 'sw 5/4/2001 17:12'!exampleInViewer	"Create a sample Quadrangle and open a Viewer on it"	(self region: (100@100 extent: 100@50) borderWidth: (1 + (6 atRandom)) borderColor: Color black insideColor: (Color perform: #(green red blue yellow) atRandom)) beViewed"Quadrangle exampleInViewer"! !!ResultSpecification methodsFor: 'refetch' stamp: 'sw 5/3/2001 00:07'!refetchFrequency	"Answer the frequency with which the receiver should be refetched by a readout polling values from it, as in a Viewer.  Answer nil if not ever to be refetched automatically"	^ refetchFrequency! !!ResultSpecification methodsFor: 'refetch' stamp: 'sw 5/3/2001 00:29'!refetchFrequency: aFrequency	"Set the refetch frequency"	refetchFrequency _ aFrequency! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/4/2001 07:25'!handUserTileForSelf	"Hand the user a tile representing the player who is current the 'self' of this script"	playerScripted tileToRefer openInHand! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/4/2001 07:25'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	self modernize.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	Preferences universalTiles ifFalse:		[count _ self savedTileVersionsCount.		self showingMethodPane			ifFalse:				"currently showing tiles"				[aMenu add: 'show code textually' action: #showSourceInScriptor.				count > 0 ifTrue: 					[aMenu add: 'revert to tile version...' action:	 #revertScriptVersion].				aMenu add: 'save this version'	action: #saveScriptVersion]			ifTrue:				"current showing textual source"				[count >= 1 ifTrue:					[aMenu add: 'revert to tile version' action: #revertToTileVersion]]].	aMenu addList: #(		-		('destroy this script'					destroyScript)		('rename this script'					renameScript)		('button to fire this script'			tearOfButtonToFireScript)		('edit balloon help for this script'	editMethodDescription)		-		('fires per tick...'					chooseFrequency)		('explain status alternatives' 		explainStatusAlternatives)		-		('hand me a tile for self'			handUserTileForSelf)		('hand me a "random number" tile'	handUserRandomTile)		('hand me a "button down?" tile'		handUserButtonDownTile)		('hand me a "button up?" tile'		handUserButtonUpTile)		 ).	aMenu popUpInWorld: self currentWorld.	"		('add parameter to this script'	addParameter)"! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 5/4/2001 07:28'!currentVocabulary	"Answer the current vocabulary associated with the receiver.  If none is yet set, determine an appropriate vocabulary and cache it within my properties dictionary."	| aVocab aWorld |	(aVocab _ self valueOfProperty: #currentVocabulary) ifNotNil:		[^ aVocab].	(aWorld _ self world) ifNotNil:		[aVocab _ aWorld currentVocabulary].	aVocab ifNotNil: [aVocab _ Vocabulary eToyVocabulary].	self setProperty: #currentVocabulary toValue: aVocab.	^ aVocab! !!TheWorldMenu methodsFor: 'construction' stamp: 'sw 5/4/2001 07:28'!scriptingMenu        "Build the scripting menu for the world."        ^ self fillIn: (self menu: 'authoring tools...') from: {                 { 'standard parts bin' . { self . #createStandardPartsBin}. 'A bin of standard parts, from which you can drag out useful morphs.'}.                { 'custom parts bin' . { self . #launchCustomPartsBin}. 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'}.                { 'view trash contents' . { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.'}.                { 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.			nil.                { 'new scripting area' . { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.			 { 'summary of scripts' . {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.'}.			 { 'status of scripts' . {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.'}.			 { 'remove all viewers' . {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.'}.                nil.                { 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.                { 'unhide hidden objects' . { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/4/2001 04:43'!setToReferTo: anObject	"Set the receiver to bear an object reference to the given object."	type _ #objRef.	actualObject _ anObject.	self line1: anObject nameForViewer.	self typeColor: (ScriptingSystem colorForType: #player).	self enforceTileColorPolicy! !!UndescribedTile methodsFor: 'initialization' stamp: 'sw 5/3/2001 14:57'!initialize	"Initialize the receiver.  This is in its infancy -- just a place-holder at present"	super initialize.	self extent: (20 @ 22).	self setLiteral: 'arg'! !!Variable methodsFor: 'name' stamp: 'sw 5/3/2001 00:04'!printOn: aStream	"Print the receiver on the stream"	super printOn: aStream.	aStream nextPutAll: ' named ', (self variableName ifNil: ['<unnamed>']), ' type = ', variableType printString! !!Viewer methodsFor: 'special phrases' stamp: 'sw 5/4/2001 07:45'!touchesAPhrase	"Answer a conjured-up touchesA phrase in classic tile"	| outerPhrase |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #player.	(outerPhrase submorphs at: 2) delete.	"operator"	outerPhrase addMorphBack: (TileMorph new setOperator: #touchesA:).	(outerPhrase submorphs at: 2) goBehind.		"Make it third"	outerPhrase submorphs last addMorph: scriptedPlayer tileToRefer.	^ outerPhrase! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 5/4/2001 05:31'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal |	names _ scriptedPlayer class namedTileScriptSelectors.	resultType _ aMethodInterface resultType.	cmd _ aMethodInterface selector.	(universal _ scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase _ scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType _ aMethodInterface typeForArgumentNumber: 1.				aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ self tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector _ #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString _ (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentationOrNil.			aDocString ifNotNil:					[aPhrase submorphs second setBalloonText: aDocString]				ifNil:					[balloonTextSelector _ #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script'].	universal ifFalse:		[selfTile _ self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow _ ViewerRow newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		aPhrase beTransparent.		aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.		aRow addMorphBack: (stat _ (inst _ scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).		inst updateStatusMorph: stat].	aRow beSticky; disableDragNDrop.	^ aRow! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 5/4/2001 16:40'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Answer a readout morph for the given part"	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #graphic) ifTrue:		[readout _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: getSelector.		readout extent: 21@21].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new.		readout			getSelector: getSelector;			target: scriptedPlayer;			borderWidth: 1;			extent:  22@22.		(putSelector isNil or: [#(unused none nil) includes: putSelector]) ifFalse:			[readout putSelector: putSelector]].	readout ifNil:  "player, graphic, and color types handled above, the rest fall here"		[readout _ scriptedPlayer updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 5/4/2001 05:27'!makeSetter: args event: evt from: aMorph	"Make a setter tile and hand it to the user"	| argType m argTile selfTile argValue |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argValue _ self scriptedPlayer perform: (ScriptingSystem getterSelectorFor: args first asSymbol).	(argValue isKindOf: Player)		ifTrue:			[argTile _ argValue tileReferringToSelf]		ifFalse:			[argTile _ self tileForArgType: argType.			argTile setLiteral: argValue; updateLiteralLabel.].	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	m openInHand! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 5/4/2001 05:28'!newGetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a getter on this property.  Record who self is."	| ms argTile argArray |	ms _ MessageSend receiver: aPlayer selector: aMethodInterface selector arguments: #().	"Handle three odious idiosyncratic cases..."	aMethodInterface selector == #colorSees ifTrue:		[ms selector: #color:sees:.		argTile _ self tileForArgType: #color.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy. 		ms arguments: argArray].	aMethodInterface selector == #isOverColor ifTrue:		[ms selector: #seesColor:.		argTile _ self tileForArgType: #color.		ms arguments: (Array with: argTile colorSwatch color)].	aMethodInterface selector == #touchesA ifTrue:		[ms selector: #touchesA:.		argTile _ self tileForArgType: #player.		ms arguments: (Array with: argTile actualObject)].	^ ms asTilesIn: aPlayer class! !!CategoryViewer methodsFor: 'support' stamp: 'sw 5/4/2001 05:04'!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel _ (retrieverType == #number)		ifTrue:		[#<]		ifFalse:		[#=].	outerPhrase _ PhraseTileMorph new setOperator: rel type: #boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase _  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #player.	getterPhrase submorphs last setSlotRefOperator: (Utilities inherentSelectorForGetter: retrieverOp).	getterPhrase submorphs first changeTableLayout.	receiverTile _ aPlayer tileToRefer bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile _ aPlayer tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'sw 5/4/2001 05:24'!currentVocabulary	"Answer the vocabulary currently installed in the viewer.  The outer StandardViewer object holds this information."	| outerViewer |	^  (outerViewer _ self outerViewer)		ifNotNil:			[outerViewer currentVocabulary]		ifNil:			[(self world ifNil: [ActiveWorld]) currentVocabularyFor: scriptedPlayer]! !!CategoryViewer methodsFor: 'support' stamp: 'sw 5/4/2001 05:32'!tileForSelf	"Return a tile representing the receiver's viewee"	^ scriptedPlayer tileToRefer! !!StandardViewer methodsFor: 'categories' stamp: 'sw 5/4/2001 07:27'!currentVocabulary	"Answer the vocabulary currently associated with the receiver"	^ self valueOfProperty: #currentVocabulary ifAbsent:		[(self world ifNil: [ActiveWorld]) currentVocabularyFor: scriptedPlayer]! !!StandardViewer methodsFor: 'categories' stamp: 'sw 5/4/2001 16:55'!likelyCategoryToShow	"Choose a category to show based on what's already showing and on some predefined heuristics"	| possible all |	all _ (scriptedPlayer categoriesForViewer: self) asOrderedCollection.	possible _ all copy.	self categoryMorphs do:		[:m | possible remove: m currentCategory ifAbsent: []].	((possible includes: #'instance variables') and: [scriptedPlayer hasUserDefinedSlots])		ifTrue:	[^ #'instance variables'].	((possible includes: #scripts) and: [scriptedPlayer hasUserDefinedScripts])		ifTrue:	[^ #'scripts'].	#(basic #'color & border' color flagging comparing) do:		[:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	^ possible size > 0		ifTrue:			[possible first]		ifFalse:			[all first]! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 5/3/2001 15:32'!switchToVocabulary: aVocabulary	"Make the receiver show categories and methods as dictated by aVocabulary.  If this constitutes a switch, then wipe out existing category viewers that will be showing the wrong thing."	((self valueOfProperty: #currentVocabulary ifAbsent: [nil]) == aVocabulary) ifFalse:		[self setProperty: #currentVocabulary toValue: aVocabulary.		(self submorphs select: [:m | m isKindOf: CategoryViewer]) do: [:m | m delete].		self addCategoryViewer]! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 5/3/2001 17:57'!useVocabulary: aVocabulary	"Make the receiver show categories and methods as dictated by aVocabulary"	((self valueOfProperty: #currentVocabulary ifAbsent: [nil]) == aVocabulary) ifFalse:		[self setProperty: #currentVocabulary toValue: aVocabulary.		(self submorphs select: [:m | m isKindOf: CategoryViewer]) do: [:m | m delete]]! !!ViewerFlapTab methodsFor: 'graphic' stamp: 'sw 5/4/2001 07:45'!graphicalMorphForTab	"Answer a graphical morph to serve as my tab's display"	^ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #graphicForViewerTab! !!Vocabulary methodsFor: 'initialization' stamp: 'sw 5/3/2001 16:04'!initializeFromTable: aTable	"Initialize the receiver from a list of method-specification tuples, each of the form:		(1)	selector		(2)	companion setter selector (#none or nil indicate none)		(3)  argument specification array, each element being an array of the form				<arg name>  <arg type>		(4)  result type, (#none or nil indicate none)		(5)  array of category symbols, i.e. the categories in which this element should appear.		(6)  help message. (optional)		(7)  wording (optional)		(8)  auto update flag (optional) - if #updating, set readout to refetch automatically	Consult Vocabulary class.initializeTestVocabulary for an example of use"					|  aMethodCategory categoryList aMethodInterface aSelector |	categoryList _ Set new.	aTable do:		[:tuple | categoryList addAll: tuple fifth].	categoryList _ categoryList asSortedArray.	categoryList do:		[:aCategorySymbol |			aMethodCategory _ ElementCategory new categoryName: aCategorySymbol.			aTable do:				[:tuple | (tuple fifth includes: aCategorySymbol) ifTrue:					[aMethodInterface _ MethodInterface new.					aSelector _ tuple first.					aMethodInterface selector: aSelector type: tuple fourth setter: tuple second.					aMethodCategory elementAt: aSelector put: aMethodInterface.					self atKey: aSelector putMethodInterface: aMethodInterface.					((tuple third ~~ #none) and: [tuple third isEmptyOrNil not])						ifTrue:							[aMethodInterface argumentVariables: (tuple third collect:								[:pair | Variable new name: pair first type: pair second])].					tuple size >= 6 ifTrue: [(#(nil none unused) includes: tuple sixth) ifFalse:						[aMethodInterface documentation: tuple sixth]].					tuple size >= 7 ifTrue: [(#(nil none unused) includes: tuple seventh) ifFalse:						[aMethodInterface elementWording: tuple seventh]].					tuple size >= 8 ifTrue:						[aMethodInterface setToRefetch]]].			self addCategory: aMethodCategory]! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 5/4/2001 21:29'!initializeStandardVocabularies	"Initialize a few standard vocabularies and place them in the AllVocabularies list."	AllVocabularies _ OrderedCollection new.	AllMethodInterfaces _ IdentityDictionary new.	self addVocabulary: EToyVocabulary new.	self addVocabulary: self newPublicVocabulary.	self addVocabulary: FullVocabulary new.	self addVocabulary: self newQuadVocabulary.	"self addVocabulary: self newNumberVocabulary."	"self addVocabulary: self newTestVocabulary."	"Vocabulary initialize"! !!Vocabulary class methodsFor: 'testing and demo' stamp: 'sw 5/4/2001 18:28'!newQuadVocabulary	"Answer a Quad vocabulary -- something to mess with, to illustrate and explore ideas.  Applies to Quadrangles only."	| aVocabulary  |	aVocabulary _ Vocabulary new vocabularyName: #Quad.	aVocabulary documentation: 'A highly restricted test vocabulary that can be used with Quadrangle objects'.	aVocabulary initializeFromTable:  #((borderColor borderColor: () color (basic color) 'The color of the border' unused updating)(borderWidth borderWidth: () number (basic geometry) 'The width of the border' unused updating)(insideColor insideColor: () color (basic color) 'The color of the quadrangle' unused updating)(display none () none (basic display) 'Display the quadrangle directly on the screen')(width none () number (geometry) 'The width of the object' unused updating)(left setLeft: () number (geometry) 'The left edge' unused updating)(right setRight: () number (geometry) 'The right edge' unused updating)(width setWidth: () number (geometry) 'The width of the object' unused updating)(height setHeight: () number (geometry) 'The height of the object' unused updating)(hasPositiveExtent none () boolean (tests) 'Whether the corner is to the lower-right of the origin' unused updating)(isTall none () boolean (tests) 'Whether the height is greater than the width' unused updating)).	^ aVocabulary"Vocabulary initialize""Quadrangle exampleInViewer"! !!Vocabulary class methodsFor: 'testing and demo' stamp: 'sw 5/2/2001 22:46'!newTestVocabulary	"Answer a Test vocabulary -- something to mess with, to illustrate and explore ideas."	| aVocabulary  |	aVocabulary _ Vocabulary new vocabularyName: #Test.	aVocabulary documentation: 'An illustrative vocabulary for testing'.	aVocabulary initializeFromTable:  #((isKindOf: none 	((aClass Class)) boolean (#'class membership') 'answer whether the receiver''s superclass chain includes aClass')(class none none Class (#'class membership' wimpy) 'answer the the class to which the receiver belongs')(respondsTo: none ((aSelector Symbol))	boolean (#'class membership') 'answer whether the receiver responds to the given selector')(as:	none ((aClass Class)) object (conversion) 'answer the receiver converted to be a member of aClass')).	^ aVocabulary"	#((#'class membership' 	'Whether an object can respond to a given message, etc.' 	(isKindOf: class respondsTo:))	(conversion 			'Messages to convert from one kind of object to another' 		(as:  asString))	(copying				'Messages for making copies of objects'						(copy copyFrom:))	(equality 				'Testing whether two objects are equal' 						( = ~= == ~~))	(dependents				'Support for dependency notification'						(addDependent: removeDependent: release))) do:		[:item | 			aMethodCategory _ ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | 					aMethodInterface _ MethodInterface new initializeFor: aSelector.					aVocabulary atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			aVocabulary addCategory: aMethodCategory]."! !!Vocabulary class methodsFor: 'testing and demo' stamp: 'sw 5/4/2001 16:38'!quadVocabulary	"Answer the Quad vocabulary lurking in my AllVocabularies list, creating it if necessary"	| aVocab |	^ (self vocabularyNamed: #Quad) ifNil:		[aVocab _ self newQuadVocabulary.		AllVocabularies add: aVocab.		^ aVocab]	"Vocabulary quadVocabulary"! !!Vocabulary class methodsFor: 'testing and demo' stamp: 'sw 5/3/2001 15:21'!testVocabulary	"Answer the Test vocabulary lurking in my AllVocabularies list, creating it if necessary"	| aVocab |	^ (self vocabularyNamed: #Test) ifNil:		[aVocab _ self newTestVocabulary.		AllVocabularies add: aVocab.		^ aVocab]	"Vocabulary testVocabulary"! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 5/2/2001 17:44'!eToyVocabulary	"Anser the etoy vocabulary, if one exists in the AllVocabularies list"	^ self vocabularyNamed: #eToy! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 5/2/2001 17:48'!fullVocabulary	"Answer the full vocabulary in my AllVocabularies list, creating it if necessary"	| full |	full _ self vocabularyNamed: #Full.	full ifNil:		[AllVocabularies add: (full _ FullVocabulary new)].	^ full! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 5/3/2001 15:21'!publicVocabulary	"Answer the public vocabulary, which admits through all non-private categories & selectors"	| aVocab |	^ (self vocabularyNamed: #Public) ifNil:		[aVocab _ self newPublicVocabulary.		AllVocabularies add: aVocab.		^ aVocab]	"Vocabulary publicVocabulary"! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 5/2/2001 17:44'!vocabularyNamed: aName	"Answer the standard vocabulary of the given name, or nil if none found"	^ self allVocabularies detect: [:aVocabulary | aVocabulary vocabularyName = aName] ifNone: [nil]! !!Vocabulary class reorganize!('class initialization' initialize initializeStandardVocabularies newPublicVocabulary)('access' addVocabulary: allVocabularies)('testing and demo' newQuadVocabulary newTestVocabulary quadVocabulary testVocabulary)('standard vocabularies' eToyVocabulary fullVocabulary publicVocabulary vocabularyNamed:)('method interfaces' methodInterfaceFor: resetMethodInterfaceRepository storeInterface:forSelector:)('type vocabularies' newNumberVocabulary numberVocabulary)!!ViewerFlapTab reorganize!('access' allNonSubmorphMorphs scriptedPlayer)('compact' changeCompactFlap compactFlapString isFlapCompact makeFlapCompact:)('graphic' graphicalMorphForTab isCurrentlyGraphical)('menu' addAddHandMenuItemsForHalo:hand: addCustomMenuItems:hand:)('transition' hibernate initializeFor:topAt: showFlap unhibernate)!StandardViewer removeSelector: #filteringScheme!CategoryViewer removeSelector: #newTilesFor:command:!CategoryViewer removeSelector: #newTilesFor:getter:!CategoryViewer removeSelector: #tileForPlayer:!Viewer removeSelector: #controlButtonColor!Viewer removeSelector: #filteringScheme!!Viewer reorganize!('access' objectViewed scriptedPlayer scriptedPlayer:)('commands' chooseVocabulary newPermanentScript nextCostume previousCostume)('copying' veryDeepFixupWith: veryDeepInner:)('dropping' repelsMorph:event: wantsToBeDroppedInto:)('queries' aboutMethod: browseImplementorsOf: browseMethodFull: browseMethodInheritance: browseSendersOf: browseVersionsOf:)('special phrases' colorSeesPhrase seesColorPhrase touchesAPhrase)('testing' isAViewer isCandidateForAutomaticViewing)('transition' initialize noteDeletionOf: retargetFrom:to:)!TileMorph removeSelector: #setObjectRef:actualObject:!ScriptEditorMorph removeSelector: #tileForSelf!!ResultSpecification reorganize!('companion setter' companionSetterSelector companionSetterSelector:)('refetch' refetchFrequency refetchFrequency:)('result type' resultType resultType: type)!Project removeSelector: #setPreferredVocabulary:!Player removeSelector: #tileForArgType:!Player removeSelector: #tileForArgType:inViewer:!Player removeSelector: #tileForPlayer:!Player removeSelector: #updatingTileForArgType:partName:getSelector:putSelector:!!MethodInterface class reorganize!('utilities' isNullMarker:)!Object removeSelector: #graphicSelectorForViewerTab!Object removeSelector: #tileForArgType:inViewer:!"Postscript:"Vocabulary initialize.!