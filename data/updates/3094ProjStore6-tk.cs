'From Squeak2.9alpha of 16 June 2000 [latest update: #3141] on 8 December 2000 at 10:24:15 am'!"Change Set:		ProjStore6-tkDate:			8 December 2000Author:			Ted KaehlerCorrect bug that stopped projects from being saved.  When Players in References are imported, reinstall in References, and rename if needed.Rename of a Player handles References and new tiles correctly.Prepare for deleting all new tiles in saved projects and reconstituting them."!!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/8/2000 10:00'!savePlayerReferences: dictOfAllObjects	| save world |	"Save our associations we own in the shared References table.  They will be installed when the segment is imported."	save _ OrderedCollection new.	References associationsDo: [:assoc |		(dictOfAllObjects includesKey: assoc) ifTrue: [save add: assoc]].	1 to: 5 do: [:ii | ((arrayOfRoots at: ii) respondsTo: #isCurrentProject) ifTrue: [					world _ (arrayOfRoots at: ii) world]].	world setProperty: #References toValue: save.		"assume it is not refed from outside and will be traced"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 12/7/2000 15:59'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots. 	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject | 		(importedObject isKindOf: Project) ifTrue: [			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences].		importedObject class class == Metaclass ifTrue: [self declare: importedObject].		importedObject class == ScriptEditorMorph ifTrue: [			importedObject unhibernate].		"recover objects with viewers and create the viewers"		].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!Morph methodsFor: 'naming' stamp: 'tk 12/8/2000 10:23'!renameTo: aName	| aPresenter putInViewer aPasteUp renderer oldKey assoc |	(renderer _ self topRendererOrSelf) setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: renderer player.		putInViewer ifTrue: [aPresenter viewMorph: self]].	"recreate my viewer"	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]].	"fix References dictionary"	oldKey _ References keyAtIdentityValue: renderer player ifAbsent: [^ aName].	assoc _ References associationAt: oldKey.	oldKey = aName ifFalse: [		assoc key: aName.		References rehash].	"Force strings in tiles to be remade with new name.  New tiles only."	(aPasteUp valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ aName].	aPasteUp allTileScriptingElements do: [:mm | "just ScriptEditorMorphs"		(mm isKindOf: ScriptEditorMorph) ifTrue: [			((mm playerScripted class compiledMethodAt: mm scriptName) hasLiteral: assoc)				ifTrue: [mm hibernate; unhibernate]]].	^ aName! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 12/7/2000 15:52'!hibernate	| ww |	"Delete the tiles.  If I have new universal tiles."	(ww _ self world) ifNil: [^ self].	(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ self].	submorphs size > 1 ifTrue: [submorphs second delete].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 12/7/2000 15:51'!unhibernate	| ww |	"Recreate my tiles from my method.  If I have new universal tiles."	(ww _ self world) ifNil: [^ self].	(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ self].	self showSourceInScriptor. ! !