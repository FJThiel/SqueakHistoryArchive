'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 1:10:17 pm'!"Change Set:		RealStackPointerDate:			2 December 1998Author:			Dan IngallsThis changeSet causes Squeak not to look at context fields beyond the stack pointer.  It saves a lot of time initializing contexts.Also slightly sped up the context test in the recycle routine.NOTE: These changes were developed together with several others and so may not work in isolation."!!ContextPart methodsFor: 'controlling' stamp: 'di 12/2/1998 07:06'!pop	"Answer the top of the receiver's stack and remove the top of the stack."	| val |	val _ self at: stackp.	stackp _ stackp - 1.	^val! !!ContextPart methodsFor: 'private' stamp: 'di 12/2/1998 07:03'!pop: numObjects toAddable: anAddableCollection	"Pop the top numObjects elements from the stack, and store them in	 anAddableCollection, topmost element last.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	| base |	base _ stackp - numObjects.	1 to: numObjects do:		[:i | anAddableCollection add: (self at: base+i)].	stackp _ stackp - numObjects! !!ContextPart methodsFor: 'private' stamp: 'di 12/2/1998 07:02'!pop: numObjects toIndexable: anIndexableCollection	"Pop the top numObjects elements from the stack, and store them in	 anIndexableCollection, topmost element last.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	| base |	base _ stackp - numObjects.	1 to: numObjects do:		[:i | anIndexableCollection at: i put: (self at: base+i)].	stackp _ stackp - numObjects! !!ContextPart methodsFor: 'private' stamp: 'di 12/2/1998 07:07'!push: numObjects fromIndexable: anIndexableCollection	"Push the elements of anIndexableCollection onto the receiver's stack.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	1 to: numObjects do:		[:i | self at: (stackp _ stackp + 1) put: (anIndexableCollection at: i)]! !!MethodContext methodsFor: 'initialize-release' stamp: 'di 12/2/1998 07:35'!restart	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ method initialPC.	stackp _ method numTemps! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'di 11/29/1998 16:35'!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader header |	self inline: true.	header _ self baseHeader: objectPointer.	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			" 6 fixed fields in MethodContexts and BlockContexts ***"			^ (6 + (self fetchStackPointerOf: objectPointer)) * 4].		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/4/1998 00:59'!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [	"is the context of class methodCntxClass?"	cntxHeader _ self baseHeader: cntxOop.	(self isMethodContext: cntxOop header: cntxHeader)	ifTrue: ["Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: SizeMask) = SmallContextSize				"Dont have to check after all are large"			ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 11/29/1998 20:34'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			" 6 fixed fields in MethodContexts and BlockContexts ***"			^ (6 + (self fetchStackPointerOf: oop)) * 4].		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]			ifFalse: [ size _ header bitAnd: SizeMask ].		^ size - BaseHeaderSize].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!Interpreter methodsFor: 'object memory support' stamp: 'di 12/1/1998 21:30'!preGCAction: fullGCFlag	self storeContextRegisters: activeContext.! !!Interpreter methodsFor: 'contexts' stamp: 'di 11/29/1998 16:24'!fetchStackPointerOf: aContext	"Return the stackPointer of a Context or BlockContext."	| sp |	self inline: true.	sp _ self fetchPointer: StackPointerIndex ofObject: aContext.	(self isIntegerObject: sp) ifFalse: [^ 0].	^ self integerValueOf: sp! !!Interpreter methodsFor: 'contexts' stamp: 'di 11/29/1998 15:26'!isContextHeader: aHeader	"NOTE: anOop is assumed not to be an integer"	| ccIndex |	self inline: true.	ccIndex _ (aHeader >> 12) bitAnd: 16r1F.	^ ccIndex = 13 or: [ccIndex = 14]! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/2/1998 15:14'!isMethodContext: anOop header: hdr	"NOTE: Will work (slower) if Contexts become uncompact,		but not if another class takes the ccIndex of MethodContext.	anOop is also assumed not to be an integer"	| ccIndex |	self inline: true.	ccIndex _ (hdr >> 12) bitAnd: 16r1F.	ccIndex = 14		ifTrue: [^ true]		ifFalse: [^ (self fetchClassOf: anOop) = (self splObj: ClassMethodContext)]! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/4/1998 00:49'!activateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'method lookup cache' stamp: 'di 12/2/1998 16:25'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ (selector bitXor: class) >> 2.  "shift drops two low-order zeros from addresses"	probe _ (hash bitAnd: MethodCacheMask) + 1.  "first probe"	(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:			[newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true	"found entry in cache; done"].	probe _ ((hash >> 1) bitAnd: MethodCacheMask) + 1.  "second probe"	(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:			[newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true	"found entry in cache; done"].	probe _ ((hash >> 2) bitAnd: MethodCacheMask) + 1.	(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:			[newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true].	^ false! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/29/1998 21:24'!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header |	self inline: true.	header _ self baseHeader: oop.	^ self lengthOf: oop baseHeader: header format: ((header >> 8) bitAnd: 16rF)! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/29/1998 20:54'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self quickFetchInteger: StackPointerIndex ofObject: array]		ifFalse: [stSize _ totalLength - fixedFields].	(index >= 1 and: [index <= stSize])		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [successFlag _ false.  ^ 0].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/29/1998 20:56'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self quickFetchInteger: StackPointerIndex ofObject: array]		ifFalse: [stSize _ totalLength - fixedFields].	(index >= 1 and: [index <= stSize])		ifTrue: [self subscript: array with: (index + fixedFields) storing: value format: fmt]		ifFalse: [successFlag _ false]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/29/1998 20:40'!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	| hdr fmt totalLength fixedFields |	self inline: true.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [^ self quickFetchInteger: StackPointerIndex ofObject: oop]		ifFalse: [^ totalLength - fixedFields]! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 12/1/1998 00:09'!ioLowResMSecs	^ Time millisecondClockValue! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'di 12/1/1998 00:05'!primitiveRelinquishProcessor	"No-op in simulator"	^ self pop: 1! !