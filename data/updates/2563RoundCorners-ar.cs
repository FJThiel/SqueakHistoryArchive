'From Squeak2.9alpha of 12 June 2000 [latest update: #2569] on 5 September 2000 at 8:56:42 am'!"Change Set:		RoundCorners-arDate:			1 September 2000Author:			Andreas RaabThe long-standing cleanup for rounding corners. Makes corner rounding a responsibility of the Canvas and gets rid of many of the complications in several #fullDrawOn: methods. Also changes the rules for sending #fullDrawOn: - the message should never be send to any other morph (except from super-sends) since it'll bypass the corner rounder mechanism that's supplied in Canvas>>fullDrawMorph: (which should be used instead). Any morph responding with true to #wantsRoundedCorners will get rounded corners if the canvas supports it. Optionally, morphs can implement #roundedCorners to return a list of those corners to actually round (the numbering of the corners has been taken from FlapTab so ask Scott about what number means what corner ;-))"!!Morph methodsFor: 'rounding' stamp: 'ar 9/1/2000 13:44'!roundedCorners	"Return a list of those corners to round"	^#(1 2 3 4) "all of 'em"! !!Morph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:23'!imageForm: depth forRectangle: rect	| canvas |	canvas _ Display defaultCanvasClass extent: rect extent depth: depth.	canvas translateBy: rect topLeft negated		during:[:tempCanvas| tempCanvas fullDrawMorph: self].	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:23'!imageFormWithout: stopMorph andStopThere: stopThere	"Like imageForm, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns a pair of the imageForm and a boolean that is true		if it has hit stopMorph, and display should stop."	| canvas rect |	rect _ self fullBounds.	canvas _ ColorPatchCanvas extent: rect extent depth: Display depth.	canvas stopMorph: stopMorph.	canvas doStop: stopThere.	canvas translateBy: rect topLeft negated during:[:tempCanvas| tempCanvas fullDrawMorph: self].	^ Array with: (canvas form offset: rect topLeft)			with: canvas foundMorph! !!Morph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:23'!shadowForm	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."	| canvas |	canvas _ (Display defaultCanvasClass extent: bounds extent depth: 1)				asShadowDrawingCanvas: Color black. "Color black represents one for 1bpp"	canvas translateBy: bounds topLeft negated		during:[:tempCanvas| tempCanvas fullDrawMorph: self].	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'texture support' stamp: 'ar 9/1/2000 14:22'!asTexture	"Represent the receiver as a Wonderland texture."	| canvas texture dirty hqTexture texExtent tempForm |	hqTexture _ self valueOfProperty: #highQualityTexture ifAbsent:[false].	dirty _ self valueOfProperty: #textureIsDirty ifAbsent:[false].	texture _ self valueOfProperty: #wonderlandTexture.	"Determine the size we expect the texture to be.	Note: This size must never be less than the receiver's since	this will lead to (unwanted) clipping."	texExtent _ self extent.	hqTexture ifTrue:[		"High quality textures round up to next power of two"		texExtent _ texExtent x asLargerPowerOfTwo @ texExtent y asLargerPowerOfTwo.	].	(texture == nil or:[texture extent ~= texExtent]) ifTrue:[		self removeProperty: #wonderlandTexture.		texture _ nil. "Clean up for GC"		texture _ B3DTexture extent: texExtent depth: 32.		texture interpolate: false.		texture wrap: false.		texture envMode: 0.		dirty _ true].	dirty ifTrue:[		canvas _ texture getCanvas.		canvas translateBy: self topLeft negated			during:[:tempCanvas| tempCanvas fullDrawMorph: self].		self removeProperty: #textureIsDirty.		"High quality textures need an extra pass here"		(texExtent ~= self extent) ifTrue:[			tempForm _ texture contentsOfArea: (0@0 extent: self extent).			tempForm displayInterpolatedOn: texture].	].	self setProperty: #wonderlandTexture toValue: texture.	^ texture! !!FlapTab methodsFor: 'rounding' stamp: 'ar 9/1/2000 13:49'!roundedCorners	^self orientation == #vertical		ifTrue:			[edgeToAdhereTo == #right				ifTrue:					[#(1 2)]				ifFalse:					[#(3 4)]]		ifFalse:			[edgeToAdhereTo == #top				ifTrue:					[#(2 3)]				ifFalse:					[#(1 4)]].! !!FlapTab methodsFor: 'rounding' stamp: 'ar 9/1/2000 13:53'!wantsRoundedCorners	^self isCurrentlyTextual! !!ImageMorph methodsFor: 'drawing' stamp: 'ar 9/1/2000 13:49'!drawOn: aCanvas	aCanvas paintImage: image at: bounds origin! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/1/2000 14:24'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(worldState canvas == nil or:	 [(worldState canvas extent ~= self viewBox extent) or:	 [worldState canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		worldState canvas: (Display defaultCanvasClass extent: self viewBox extent)].	worldState canvas fillColor: color.	submorphs reverseDo: [:m | worldState canvas fullDrawMorph: m].	worldState handsReverseDo: [:h | worldState canvas fullDrawMorph: h].	worldState canvas form displayOn: Display at: self viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Display forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'Nebraska' stamp: 'ar 9/1/2000 14:23'!addRemoteClient: aClient	(worldState isKindOf: NebraskaWorldState) ifFalse: [		worldState _ worldState as: NebraskaWorldState	].	self addHand: aClient hand.	worldState addRemoteCanvas: aClient canvas.	aClient canvas fullDrawMorph: self.	self changed.  "force a redraw"! !!NebraskaPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/1/2000 14:23'!addRemoteClient: aClient	self addHand: aClient hand.	self addRemoteCanvas: aClient canvas.	aClient canvas fullDrawMorph: self.	self changed.  "force a redraw"! !!Project methodsFor: 'displaying' stamp: 'ar 9/1/2000 14:24'!imageFormOfSize: extentPoint depth: d	| newDisplay |	newDisplay _ DisplayScreen extent: extentPoint depth: d.	Display replacedBy: newDisplay do:[		world isMorph 			ifTrue:[Display getCanvas fullDrawMorph: world] "Morphic"			ifFalse:[world restore]. "MVC"	].	^newDisplay! !!ProjectViewMorph methodsFor: 'accessing' stamp: 'ar 9/1/2000 13:45'!borderWidth	^1! !!ProjectViewMorph methodsFor: 'rounding' stamp: 'ar 9/1/2000 13:50'!wantsRoundedCorners	^(Preferences roundedWindowCorners and: [(owner isKindOf: SystemWindow) not])! !!SelectionMorph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:25'!drawOn: aCanvas	| canvas form1 form2 box |	super drawOn: aCanvas.	box _ self bounds.	selectedItems do: [:m | box _ box merge: m fullBounds].	box _ box expandBy: 1.	canvas _ Display defaultCanvasClass extent: box extent depth: 8.	canvas translateBy: box topLeft negated		during: [:tempCanvas | selectedItems do: [:m | tempCanvas fullDrawMorph: m]].	form1 _ (Form extent: box extent) copyBits: (0@0 extent: box extent) from: canvas form at: 0@0 colorMap: (Color maskingMap: 8).	form2 _ Form extent: box extent.	(0@0) fourNeighbors do: [:d | form1 displayOn: form2 at: d rule: Form under].	form1 displayOn: form2 at: 0@0 rule: Form erase.	aCanvas stencil: form2		at: box topLeft		sourceRect: form2 boundingBox		color: self borderColor! !!SketchMorph methodsFor: 'drawing' stamp: 'ar 9/1/2000 13:51'!drawOn: aCanvas	aCanvas paintImage: self rotatedForm at: bounds origin! !!TextContainer methodsFor: 'private' stamp: 'ar 9/1/2000 14:25'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (Display defaultCanvasClass extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [tempCanvas fullDrawMorph: (theText owner copyWithoutSubmorph: theText)]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back _ tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [tempCanvas fullDrawMorph: m]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!ThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/1/2000 14:26'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee viewedMorphBox myBox scale c shrunkForm aWorld |	super drawOn: aCanvas.	((((actualViewee _ self actualViewee) ~~ nil and: [(aWorld _ actualViewee world) ~~ nil])			and: [aWorld ~~ actualViewee or: [lastFormShown == nil]]) and: [RecursionDepth + 1 < RecursionMax])		ifTrue:			[RecursionDepth _ RecursionDepth + 1.			viewedMorphBox _ actualViewee fullBounds.			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ Display defaultCanvasClass extent: viewedMorphBox extent depth: aCanvas depth.			c translateBy: viewedMorphBox topLeft negated 				"recursion happens here"				during:[:tempCanvas| tempCanvas fullDrawMorph: actualViewee].			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:  "This branch used if we've recurred, or if the thumbnail views a World that's already been rendered once, or if the referent is not in a world at the moment"			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas paintImage: shrunkForm at: self center - shrunkForm boundingBoxcenter]	"sw 12/20/1999 13:35 special-case code for SketchMorph commented out, since it seems to have done more harm than good: 			((actualViewee isKindOf: SketchMorph) and: [false])				ifTrue:					[diag _ actualViewee form extent  asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds]."! !!WorldState methodsFor: 'update cycle' stamp: 'ar 9/1/2000 14:26'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	false ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 9/1/2000 14:26'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect gridFill |	rectList _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	damageRecorder reset.	aWorld updateTrailsForm.	(aWorld griddingOn and: [aWorld gridVisible]) ifTrue:		[gridFill _ aWorld gridFormOrigin: aWorld gridOrigin grid: aWorld gridModulus					background: nil line: Color veryLightGray].	n _ submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aWorld pseudoDraw: rectToFill on: aCanvas.				gridFill ifNotNil:					[aCanvas fillRectangle: rectToFill fillStyle: gridFill]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				c fullDrawMorph: morphs removeLast].			morphs reset.  rects reset]		ifFalse: [c _ aWorld pseudoDraw: r on: aCanvas.				submorphs reverseDo: [:m | c fullDrawMorph: m]].	].	^ rectList! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 9/1/2000 13:40'!fullDrawMorph: aMorph	(self isVisible: aMorph fullBounds) ifTrue:[		aMorph wantsRoundedCorners			ifTrue:[self fullDrawMorphWithRoundedCorners: aMorph]			ifFalse:[self fullDraw: aMorph]].! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 9/1/2000 13:41'!fullDrawMorphWithRoundedCorners: aMorph	"Generic Canvas simply ignores rounded corners since it doesn't know what to do anyways."	self fullDraw: aMorph! !!FormCanvas methodsFor: 'drawing-general' stamp: 'ar 9/1/2000 14:17'!fullDrawMorphWithRoundedCorners: aMorph	CornerRounder roundCornersOf: aMorph on: self		displayBlock: [self fullDraw: aMorph]		borderWidth: aMorph borderWidth		corners: aMorph roundedCorners! !SystemWindow removeSelector: #fullDrawOn:!ProjectViewMorph removeSelector: #fullDrawOn:!FlapTab removeSelector: #fullDrawOn:!BorderedMorph removeSelector: #fullDrawOn:!BorderedMorph removeSelector: #fullDrawWithRoundedCornersOn:!