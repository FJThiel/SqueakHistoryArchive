'From Squeak2.9alpha of 13 June 2000 [latest update: #2774] on 8 February 2001 at 3:20:43 pm'!"Change Set:		BltmodeForSPR-hgDate:			6 February 2001Author:			Henrik GedenrydAdds Blt mode needed by subpixel-rendered fonts. Regenerate VM or compile external BitBlt plugin from 'BitBltSimulation translate'. Works for 2.8-3.0 (at least). Fixes a BitBlt bug that prevents this from working in 16 bits (no mask for 5 bit values). Re-synchronizes transfer mode numbers for BitBlt and FXBlt."!!BitBltSimulation methodsFor: 'combination rules' stamp: 'hg 2/2/2001 15:23'!partitionedMul: word1 with: word2 nBits: nBits nPartitions: nParts	"Multiply word1 with word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors.	Bug in loop version when non-white background"	| sMask product result dMask |	sMask _ maskTable at: nBits.  "partition mask starts at the right"	dMask _  sMask << nBits.	result _ (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	"optimized first step"	product _ (((word1>>nBits bitAnd: sMask)+1) * ((word2>>nBits bitAnd: sMask)+1) - 1 bitAnd: dMask).	result _ result bitOr: (product bitAnd: dMask).	product _ (((word1>>(2*nBits) bitAnd: sMask)+1) * ((word2>>(2*nBits) bitAnd: sMask)+1) - 1 bitAnd: dMask).	result _ result bitOr: (product bitAnd: dMask) << nBits.	^ result"	| sMask product result dMask |	sMask _ maskTable at: nBits.  'partition mask starts at the right'	dMask _  sMask << nBits.	result _ (((word1 bitAnd: sMask)+1) * ((word2 bitAnd: sMask)+1) - 1 				bitAnd: dMask) >> nBits.	'optimized first step'	nBits to: nBits * (nParts-1) by: nBits do: [:ofs |		product _ (((word1>>ofs bitAnd: sMask)+1) * ((word2>>ofs bitAnd: sMask)+1) - 1 bitAnd: dMask).		result _ result bitOr: (product bitAnd: dMask) << (ofs-nBits)].	^ result"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'hg 8/24/2000 14:41'!rgbMul: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Mul each pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Mul RGB components of each pixel separately"		^ (self partitionedMul: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMul: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Mul RGB components of the pixel separately"		^ self partitionedMul: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]"	| scanner |	Display repaintMorphicDisplay.	scanner _ DisplayScanner quickPrintOn: Display.	MessageTally time: [0 to: 760 by: 4 do:  [:y |scanner drawString: 'qwrepoiuasfd=)(/&()=#!!¡lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,Mqwrepoiuasfd=)(/&()=#!!¡lkjzxv.,mn124+09857907QROIYTOAFDJZXNBNB,M-.,M1234124356785678' at: 0@y]]. "! !!BitBltSimulation methodsFor: 'translation support' stamp: 'hg 1/29/2001 17:03'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[34+1] = (int)alphaBlendScaledwith'.	self cCode: 'opTable[35+1] = (int)alphaBlendScaledwith'.	self cCode: 'opTable[36+1] = (int)alphaBlendScaledwith'.		self cCode: 'opTable[37+1] = (int)rgbMulwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'hg 1/29/2001 17:02'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:		"35" alphaBlendScaled:with:	"unused here - only used by FXBlt"		"36" alphaBlendScaled:with:	"unused here - only used by FXBlt"		"37" rgbMul:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!BitBltSimulation class methodsFor: 'translation' stamp: 'hg 2/2/2001 14:36'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!BitBltSimulator methodsFor: 'as yet unclassified' stamp: 'hg 2/2/2001 14:15'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 5 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].	self initializeDitherTables.	warpBitShiftTable _ CArrayAccessor on: (Array new: 32).! !!FXBltSimulation class methodsFor: 'translation' stamp: 'hg 2/2/2001 14:36'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator		var: 'colorMap' declareC:'int *colorMap';		var: 'cmShiftTable' declareC:'int *cmShiftTable';		var: 'cmMaskTable' declareC:'int *cmMaskTable';		var: 'sourceMap' declareC:'int *sourceMap';		var: 'smShiftTable' declareC:'int *smShiftTable';		var: 'smMaskTable' declareC:'int *smMaskTable';		var: 'destMap' declareC:'int *destMap';		var: 'dmShiftTable' declareC:'int *dmShiftTable';		var: 'dmMaskTable' declareC:'int *dmMaskTable';		var: 'warpQuad' declareC:'int warpQuad[8]';		var: 'tallyMap' declareC:'int *tallyMap'.	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 31, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!FXBltSimulator methodsFor: 'as yet unclassified' stamp: 'hg 2/2/2001 15:55'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 5 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].	self initializeDitherTables.	warpBitShiftTable _ CArrayAccessor on: (Array new: 32).	cmCache _ CArrayAccessor on: (Array new: ColorCacheSize*2).	warpQuad _ CArrayAccessor on: (Array new: 8).! !!Form class methodsFor: 'mode constants' stamp: 'hg 1/29/2001 17:28'!rgbMul	"Answer the integer denoting 'Multiply each color component, 	 their values regarded as fractions of 1' rule."	^ 37! !