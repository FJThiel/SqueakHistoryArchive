'From Squeak 2.3 of January 14, 1999 on 20 April 1999 at 4:35:50 pm'!!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 4/20/1999 15:42'!addVoiceControls 	| levelSlider r meterBox |	voiceRecorder _ SoundRecorder new		samplingRate: 11025.0;		codec: (ADPCMCodec new initializeForBitsPerSample: 4 samplesPerFrame: 0)..	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: voiceRecorder;		actionSelector: #recordLevel:;		adjustToValue: voiceRecorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.	meterBox _ Morph new extent: 102@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: meterBox topLeft + (1@1).	meterBox addMorph: recordMeter.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: meterBox.	self addMorphBack: r.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 3/8/1999 12:35'!stop	state = #record ifTrue:		[tape _ tapeStream contents.		saved _ false].	journalFile ifNotNil:		[journalFile close].	self pauseIn: self world.	tapeStream _ nil.	state _ nil.	statusLight color: Color green.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 3/8/1999 11:59'!pauseIn: aWorld	"Suspend playing or recording, either as part of a stop command,	or as part of a project switch, after which it will be resumed."	state = #play ifTrue:		[state _ #suspendedPlay.		playHand delete.		aWorld removeHand: playHand.		playHand _ nil].	state = #record ifTrue:		[state _ #suspendedRecord.		recHand stopReportingEventsTo: self.		recHand _ nil].	voiceRecorder ifNotNil:		[voiceRecorder pause.		startSoundEvent ifNotNil:			[startSoundEvent sound: voiceRecorder recordedSound.			voiceRecorder clearRecordedSound.			startSoundEvent _ nil]].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 4/20/1999 16:29'!resumeIn: aWorld	"Resume playing or recording after a project switch."	state = #suspendedPlay ifTrue:		[self resumePlayIn: aWorld].	state = #suspendedRecord ifTrue:		[self resumeRecordIn: aWorld].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 4/20/1999 16:34'!resumePlayIn: aWorld	playHand _ HandMorphForReplay new recorder: self.	playHand position: tapeStream peek value cursorPoint.	aWorld addHand: playHand.	playHand newKeyboardFocus: aWorld.	playHand userInitials: 'play'.	lastEvent _ nil.	lastDelta _ 0@0.	state _ #play.	self synchronize.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 3/8/1999 11:20'!resumeRecordIn: aWorld	recHand _ aWorld activeHand ifNil: [aWorld primaryHand].	recHand newKeyboardFocus: aWorld.	recHand startReportingEventsTo: self.	lastEvent _ nil.	state _ #record.	voiceRecorder ifNotNil:		[voiceRecorder clearRecordedSound.		voiceRecorder resumeRecording.		startSoundEvent _ MorphicSoundEvent new.		startSoundEvent setCursorPoint: recHand lastEvent cursorPoint.		tapeStream nextPut: 0 -> startSoundEvent].	time _ Time millisecondClockValue.! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 3/8/1999 13:51'!readTape	(Smalltalk at: #RequestBoxMorph			ifAbsent: [^ self readTape: (FillInTheBlankMorph											request: 'Tape to read'											initialAnswer: 'tapeName.tape')])		request: 'Tape to read'		respondTo: self		selector: #readTape:! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 3/8/1999 14:05'!readTape: fileName 	| file |	self writeCheck.	(FileStream isAFileNamed: fileName) ifFalse: [^ nil].	file _ FileStream oldFileNamed: fileName.	file peek isDigit		ifTrue: [self readFrom: file. file close]		ifFalse: [tape _ file fileInObjectAndCode].	saved _ true  "Still exists on file"! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 3/8/1999 14:48'!writeFileNamed: fileName	| file noVoice |	file _ FileStream newFileNamed: fileName.	noVoice _ true.	tape do:		[:cell | cell value setHand: nil.		cell value type = #startSound ifTrue: [noVoice _ false]].	noVoice		ifTrue: ["Simple format (reads fast) for no voice"				tape do: [:cell | file store: cell key; space; store: cell value; cr].				file close]		ifFalse: ["Inclusion of voice events requires general object storage"				file fileOutClass: nil andObject: tape].	saved _ true.	^ file name! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 3/8/1999 13:50'!writeTape	| args b |	args _ (b _ self button: 'writeTape') isNil				ifTrue: [#()]				ifFalse: [b arguments].	(args size > 0 and: [args first size > 0])		ifTrue: [args first.				self writeTape: args first]		ifFalse: [(Smalltalk at: #RequestBoxMorph					ifAbsent: [^ self writeTape: (FillInTheBlankMorph											request: 'Tape to write'											initialAnswer: 'tapeName.tape')])						request: 'Tape to write'						respondTo: self						selector: #writeTape:]! !!HandMorphForReplay methodsFor: 'event dispatching' stamp: 'di 4/20/1999 16:19'!processEvents	"Play back the next event"	| evt |	(evt _ recorder nextEventToPlay) ifNil: [^ self].	evt type = #EOF ifTrue: [recorder pauseIn: self world.  ^ self].	evt type = #startSound ifTrue: [evt sound play.  recorder synchronize.  ^ self].	(evt type = #mouseMove and: [lastEvent type = #mouseDown])		ifTrue: ["Since I will have inserted an extra mouseMove after the				mouseDown, skip the first one on the tape."				lastEvent _ evt]		ifFalse: [self handleEvent: (evt setHand: self)].! !