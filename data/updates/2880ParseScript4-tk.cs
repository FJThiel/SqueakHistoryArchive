'From Squeak2.9alpha of 16 June 2000 [latest update: #2922] on 31 October 2000 at 2:47:36 pm'!"Change Set:		ParseScript4-tkDate:			31 October 2000Author:			Ted KaehlerFurther attempt to fix highlighting during mouseOver and mouseDragOver.  Dan's green target pads grow and shrink in a block when dragging a statement over it."!!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 10/31/2000 11:04'!indexOfMorphAbove: aPoint	"Return index of lowest morph whose bottom is above aPoint.	Will return 0 if the first morph is not above aPoint."	submorphs withIndexDo: [:mm :ii | 		mm fullBounds bottom >= aPoint y ifTrue: [^ ii - 1]].	^ submorphs size! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 10/31/2000 11:47'!dropTargetColor	^ parseNode class == BlockNode 		ifTrue: [self stdBorderColor]		ifFalse: [self class dropTargetColor]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 10:54'!handlesMouseOverDragging: evt	| tile |	evt hand hasSubmorphs ifFalse: [^ false].	(tile _ evt hand firstSubmorph) class == SyntaxMorph ifFalse: [^ false].	^ self wantsDroppedMorph: tile event: evt! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 11:28'!mouseDown: evt 	| kind dup spacer oo |	evt yellowButtonPressed		ifTrue: [^ self showMenu: evt].	spacer _ self submorphAfter.	((oo _ owner) respondsTo: #parseNode)		ifTrue: [			(kind _ owner parseNode class) == BlockNode				ifTrue: [evt hand attachMorph: self.					self left: self left + (self width//2) + 7.					spacer class == AlignmentMorph ifTrue: [spacer delete].					^ self ownerBlocksStep: oo].			kind == MethodNode				ifTrue: [^ self].	"can't take anything out of a MethodNode"			evt hand attachMorph: (dup _ self duplicate).			^ dup left: dup left + (dup width//2) + 7]		ifFalse: [			parseNode class == MethodNode				ifTrue: [^ self "whole method not draggable"].			"bare, out in the world"			evt hand attachMorph: self.			^ self left: self left + (self width//2) + 7].	"no more cases"! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/30/2000 12:48'!mouseEnter: evt	| oo inside |	"Try to highlight the tiles we could pick up"	inside _ self class grabTargetColor.	submorphs detect: [:ss | ss class == SyntaxMorph and: [ss borderColor = inside]] ifNone: [			self borderColor: inside].	(oo _ owner) class == SyntaxMorph ifTrue: [oo borderColor: oo stdBorderColor].	oo owner class == SyntaxMorph ifTrue: [oo owner borderColor: oo owner stdBorderColor].	! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 14:32'!mouseEnterDragging: evt	| inside oo |	"Try to highlight places the hand's morph could land"	parseNode class == BlockNode 		ifTrue: [self startStepping]		ifFalse: [			inside _ self dropTargetColor.			submorphs detect: [:ss | ss class == SyntaxMorph and: [ss borderColor = inside]] 						ifNone: [self borderColor: inside].			(oo _ owner) class == SyntaxMorph ifTrue: [oo borderColor: oo stdBorderColor].			oo owner class == SyntaxMorph ifTrue: [					oo owner borderColor: oo owner stdBorderColor]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/30/2000 12:33'!mouseLeave: evt	| oo |	"Try to highlight tiles we could pick up""	Transcript cr; show: 'leave ', self printString, self hash printString."	self borderColor: self stdBorderColor."	oo _ owner.	[oo respondsTo: #parseNode] whileTrue: [		(oo handlesMouseOver: evt) ifTrue: [			oo borderColor: self class grabTargetColor.			^ oo setAllBorders].	'clear above me, not needed'.		oo _ oo owner]."! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 11:52'!mouseLeaveDragging: evt	| oo |	"Try to highlight places the hand's morph could land"	self borderColor: self stdBorderColor.	self parseNode class == BlockNode ifTrue: [		self stopStepping.		self removeSpaces].	oo _ owner.	[oo respondsTo: #parseNode] whileTrue: [		(oo handlesMouseOverDragging: evt) ifTrue: [			oo borderColor: oo dropTargetColor.			^ oo "setAllBorders"].	"clear above me, not needed"		oo _ oo owner].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 11:33'!ownerBlocksStep: formerOwner	"Hand now holds a statement, all enclosing blocks start stepping to make spaces"	self isNoun ifFalse: [^ self].	"Only if able to be a statement"	formerOwner parseNode class == BlockNode ifTrue: [				formerOwner startStepping].	formerOwner withAllOwnersDo: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode ifTrue: [				mm startStepping]]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 10:49'!removeSpaces	self submorphsDo:		[:mm | (mm isMemberOf: Morph) ifTrue: [mm delete]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 11:13'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |	hand _ self primaryHand.	(hand lastEvent redButtonPressed and: [(self hasOwner: hand) not]) ifTrue: [		hand submorphCount > 0 ifTrue: [			insertion _ hand firstSubmorph renderedMorph.			insHt _ insertion height.			self removeSpaces.			where _ self globalPointToLocal: hand position "insertion fullBounds topLeft".			i _ (ii _ self indexOfMorphAbove: where) min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]							ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty				ifTrue: [insertion]				ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (where y - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green lighter.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1).		]	] ifFalse: [		self stopStepping.		self removeSpaces.	]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/31/2000 11:10'!stepTime	^ 0! !!SyntaxMorph reorganize!('accessing' borderWidth: color: dropTargetColor externalName getCurrentValue getExplanation isNoun parseNode parseNode: parsedInClass parsedInClass: stdBorderColor)('event handling' acceptDroppingMorph:event: cleanup handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: ownerBlocksStep: removeSpaces setAllBorders setBorder step stepTime wantsDroppedMorph:event:)('menus' accept decompile getMenuBlock getMenuBlock: getMenuItemsIn: showCode showMenu:)('layout' addBlockArg: addColumn:on: addRow:on: addTempVar: addTextRow: addTextRow:getMenuBlock:explanation: addToBlock:event:)('as yet unclassified' balloonText debugger: explanation: hostContext ifNodeClass:then: implant inAScrollPane minBorderWidth: openInWindow printOn: printOn:indent: testForNode:andDo: update:)!