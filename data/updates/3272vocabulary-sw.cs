'From Squeak2.9alpha of 5 August 2000 [latest update: #3327] on 31 January 2001 at 1:11:27 am'!"Change Set:		vocabulary-swDate:			30 January 2001Author:			Scott WallaceAdds vocabularies, in preparation for forthcoming new tools that will use them."!ObjectWithDocumentation subclass: #ElementCategory	instanceVariableNames: 'categoryName keysInOrder elementDictionary '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!!ElementCategory commentStamp: 'sw 1/26/2001 22:57' prior: 0!ElementCategory	Contains a list of elements that affords keyed access but also has an inherent order.Add items to the category by sending it elementAt:put:.Obtain the elements in order by sending #elementsInOrderObtain the value of an element at a given key by sending #elementAt:!ObjectWithDocumentation subclass: #Vocabulary	instanceVariableNames: 'vocabularyName categories methodInterfaces '	classVariableNames: 'AllMethodInterfaces AllVocabularies '	poolDictionaries: ''	category: 'System-Protocols'!!Vocabulary commentStamp: 'sw 1/26/2001 23:26' prior: 0!Vocabulary  vocabularyName	a Symbol -- the formal name by which this vocabulary is known.  categories			a list of MethodCategory objects: the categories that comprise the vocabulary  methodInterfaces 	an IdentityDictionary; keys are method selectors, values are MethodInterfaces  AllMethodInterfaces		This class variable is available to hold on to all method interfaces							defined in the system, regardless of class.  Not deployed in 							the first version of this code to be circulated externally.!Vocabulary subclass: #EToyVocabulary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!!EToyVocabulary commentStamp: '<historical>' prior: 0!EToyVocabulary - a vocabulary mirroring the capabilities available to end users in Squeak's old 1997-2000 etoy prototype.!Vocabulary subclass: #FullVocabulary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!!FullVocabulary commentStamp: '<historical>' prior: 0!The vocabulary that it all-encompassing.  Its categories consist of the union of all categories of a class and all its superclasses.  The methods in each category consist of those with selectors that are associated with that category.!FullVocabulary subclass: #ScreenedVocabulary	instanceVariableNames: 'methodScreeningBlock categoryScreeningBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Protocols'!Vocabulary class	instanceVariableNames: ''!!ElementCategory methodsFor: 'elements' stamp: 'sw 12/1/2000 22:46'!elementAt: aKey	"Answer the element at the given key"	^ elementDictionary at: aKey ifAbsent: [nil]! !!ElementCategory methodsFor: 'elements' stamp: 'sw 1/26/2001 22:54'!elementAt: sym put: element	"Add symbol at the end of my sorted list (unless it is already present), and put the element in the dictionary"	(keysInOrder includes: sym) ifFalse: [keysInOrder add: sym].	^ elementDictionary at: sym put: element! !!ElementCategory methodsFor: 'elements' stamp: 'sw 12/1/2000 22:47'!elementsInOrder	"Answer the elements in order"	^ keysInOrder collect: [:aKey | elementDictionary at: aKey]! !!ElementCategory methodsFor: 'elements' stamp: 'sw 1/26/2001 23:00'!placeKey: key1 afterKey: key2	"Place the first key after the second one in my keysInOrder ordering"	keysInOrder remove: key1.	keysInOrder add: key1 after: key2! !!ElementCategory methodsFor: 'elements' stamp: 'sw 1/26/2001 23:00'!placeKey: key1 beforeKey: key2	"Place the first key before the second one in my keysInOrder ordering"	keysInOrder remove: key1.	keysInOrder add: key1 before: key2! !!ElementCategory methodsFor: 'copying' stamp: 'sw 12/1/2000 22:45'!copy	"Answer a copy of the receiver"	^ super copy copyFrom: self! !!ElementCategory methodsFor: 'copying' stamp: 'sw 12/1/2000 22:46'!copyFrom: donor	"Copy the receiver's contents from the donor"	keysInOrder _ donor keysInOrder.	elementDictionary _ donor copyOfElementDictionary! !!ElementCategory methodsFor: 'copying' stamp: 'sw 12/1/2000 22:46'!copyOfElementDictionary	"Answer a copy of the element dictionary"	^ elementDictionary copy! !!ElementCategory methodsFor: 'keys' stamp: 'sw 12/11/2000 15:36'!includesKey: aKey	"Answer whether the receiver's dictionary holds the given key"	^ elementDictionary includesKey: aKey! !!ElementCategory methodsFor: 'keys' stamp: 'sw 12/1/2000 22:47'!keysInOrder	"Answer the keys in their sorted order"	^ keysInOrder copy! !!ElementCategory methodsFor: 'category name' stamp: 'sw 1/26/2001 22:45'!categoryName	"Answer the formal name of the category"	^ categoryName! !!ElementCategory methodsFor: 'category name' stamp: 'sw 1/26/2001 22:46'!categoryName: aName	"Set the category name"	categoryName _ aName! !!ElementCategory methodsFor: 'initialization' stamp: 'sw 12/1/2000 22:01'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	super initialize.	keysInOrder _ OrderedCollection new.	elementDictionary _ IdentityDictionary new! !!ElementCategory methodsFor: 'printing' stamp: 'sw 1/26/2001 22:47'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that identifies the receiver."	super printOn: aStream.	categoryName ifNotNil: [aStream nextPutAll: ' named ', categoryName asString]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/30/2001 16:31'!allCategoryName	"Answer the name by which the 'all' category is known.  This is redundant with two other things, including ClassOrganizer allCategory, at the moment -- should be cleaned up someday."	^ '-- all --' asSymbol! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/30/2001 16:31'!allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass	"Answer a list of all methods in the etoy interface which are in the given category, on behalf of aClass and possibly anObject.  Note that there is no limitClass at play here."	| aCategory |	categoryName ifNil: [^ OrderedCollection new].	categoryName = self allCategoryName ifTrue:		[^ methodInterfaces collect: [:anInterface | anInterface selector]].	aCategory _ categories detect: [:cat | cat categoryName == categoryName asSymbol] ifNone: [^ OrderedCollection new].	^ aCategory elementsInOrder collect: [:anElement | anElement selector] thenSelect:			[:aSelector | aClass canUnderstand: aSelector]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/26/2001 16:22'!allSelectorsInVocabulary	"Answer a list of all selectors in the vocabulary"	^ methodInterfaces collect: [:m | m selector]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/6/2001 06:27'!atKey: aKey putMethodInterface: anInterface	"Place the given interface at the given key"	methodInterfaces at: aKey put: anInterface! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/13/2000 20:02'!categories	"Answer a list of the categories in the receiver"	^ categories! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/12/2000 06:13'!categoriesContaining: aSelector forClass: aClass	"Answer a list of categories that include aSelector"	^ self categories select:		[:aCategory | aCategory includesKey: aSelector]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/11/2000 15:31'!categoryAt: aSymbol	"Answer the category which has the given symbol as its categoryName, else nil if none found"	^ categories detect: [:aCategory | aCategory categoryName == aSymbol] ifNone: [nil]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/30/2001 16:31'!categoryCommentFor: aCategoryName	"Answer diocumentation for the given category name, a symbol"	categories do:		[:cat | cat categoryName == aCategoryName ifTrue: [^ cat documentation]].	aCategoryName = self allCategoryName ifTrue:		[^ 'Shows all methods, whatever other categories they may belong to'].	#(	(all					'Danger!! An old designation that usually does NOT include all of anything!!')	('as yet unclassified'	'Methods not yet given a specific classification in some class in which they are implemented')	(private				'Methods that should only be called by self'))		do:			[:pair | pair first = aCategoryName ifTrue: [^ pair second]].	^ aCategoryName, ' is a category that currently has no documentation'! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/30/2001 12:40'!categoryDefiningSelector: aSelector forClass: targetClass	"Answer which category defines the selector for the given class.  Note reimplementor"	^ self nameOfCategoryContaining: aSelector! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/26/2001 16:22'!categoryListForInstance: targetObject ofClass: aClass limitClass: mostGenericClass	"Answer the category list for the given instance (may be nil) of the given class, considering only code implemented in mostGenericClass and lower"	| classToUse foundAMethod classThatImplements |	classToUse _ targetObject ifNotNil: [targetObject class] ifNil: [aClass].	^ categories		select:			[:aCategory |				foundAMethod _ false.				aCategory elementsInOrder do:					[:aSpec |						classThatImplements _  classToUse classThatUnderstands: aSpec selector.						(classThatImplements notNil and: [classThatImplements includesBehavior: mostGenericClass])							ifTrue:								[foundAMethod _ true]].				foundAMethod]		thenCollect:			[:aCategory | aCategory categoryName]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/14/2000 05:55'!classToUseFromInstance: anInstance ofClass: aClass	"A small convenience to assist in complications arising because an instance is sometimes provided and sometimes not"	^ anInstance ifNotNil: [anInstance class] ifNil: [aClass]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/12/2000 06:06'!encompassesAPriori: aClass	"Answer whether the receiver  a priori encompasses aClass -- see implementors"	^ false! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/1/2000 21:57'!includesSelector: aSelector	"Answer whether the given selector is known to the vocabulary"	^ methodInterfaces includesKey: aSelector! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/14/2000 06:04'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given class (and instance, if provided), only considering method implementations in mostGenericClass and lower"	| classToUse aClass |	(methodInterfaces includesKey: aSelector) ifFalse: [^ false].	classToUse _ self classToUseFromInstance: anInstance ofClass: aTargetClass.	^ (aClass _ classToUse whichClassIncludesSelector: aSelector)		ifNil:			[false]		ifNotNil:			[aClass includesBehavior: mostGenericClass]! !!Vocabulary methodsFor: 'queries' stamp: 'sw 1/28/2001 01:20'!nameOfCategoryContaining: aSelector	"Answer a category that include aSelector, or nil if none"	^ (self categories detect:		[:aCategory | aCategory includesKey: aSelector] ifNone: [^ nil]) categoryName! !!Vocabulary methodsFor: 'queries' stamp: 'sw 12/1/2000 22:05'!vocabularyName	"Answer the name of the vocabulary"	^ vocabularyName! !!Vocabulary methodsFor: 'initialization' stamp: 'sw 12/11/2000 15:31'!addCategory: aCategory	"Add the given category to my categories list"	categories add: aCategory! !!Vocabulary methodsFor: 'initialization' stamp: 'sw 1/26/2001 23:03'!addCategoryNamed: aCategoryName	"Add a category of the given name to my categories list,"	categories add: (ElementCategory new categoryName: aCategoryName asSymbol)! !!Vocabulary methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:17'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	super initialize.	vocabularyName _ #unnamed.	categories _ OrderedCollection new.	methodInterfaces _ IdentityDictionary new.	self documentation: 'A vocabulary that has not yet been documented'.! !!Vocabulary methodsFor: 'initialization' stamp: 'sw 12/1/2000 22:06'!vocabularyName: aName	"Set the name of the vocabulary as indicated"	vocabularyName _ aName! !!Vocabulary methodsFor: 'printing' stamp: 'sw 12/1/2000 22:05'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that   identifies the receiver."	super printOn: aStream.	vocabularyName ifNotNil: [aStream nextPutAll: ' named "', vocabularyName, '"']! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 1/12/2001 01:17'!addGetterAndSetterInterfacesFromOldSlotSpec: aCommandSpec	"Create, given an old etoy-style command spec, appropriate MethodInterfaces, and store those interfaces in my method-interface dictionary"	| aMethodInterface aSelector |	aMethodInterface _ MethodInterface new initializeFromEToySlotSpec: aCommandSpec.	methodInterfaces at:  aCommandSpec seventh put: aMethodInterface.	(aCommandSpec size >= 9 and: [(#(unused missing) includes: aCommandSpec ninth) not])		ifTrue:			[aMethodInterface _ MethodInterface new initializeFor: (aSelector _ aCommandSpec ninth).			methodInterfaces at: aSelector put: aMethodInterface]"	1	#slot  -- indicates that is a slot specification rather than a method specification	2	slot name	3	help message	4	type	5	#readOnly or #readWrite (if #readWrite, items 8 and 9 should be present & meaningful)	6	<future use -- target for getter -- currently always set to #player>	7	getter selector	8	<future use -- target for setter -- currently always set to #player>	9	setter selector"! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 12/12/2000 06:06'!encompassesAPriori: aClass	"Answer whether an object, by its very nature, is one that the receiver embraces"	^ aClass isKindOf: Player class! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 12/18/2000 14:33'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given class (and instance, if provided), only considering method implementations in mostGenericClass and lower"	| classToUse aClass theKeys |	(aTargetClass isUniClass and:		[(aTargetClass namedTileScriptSelectors includes: aSelector) or:			[(((theKeys _ aTargetClass slotInfo keys collect:				[:anInstVarName | Utilities getterSelectorFor: anInstVarName])) includes: aSelector)					or:						[(theKeys collect: [:anInstVarName | Utilities setterSelectorFor: anInstVarName]) includes: aSelector]]]) ifTrue: [^ true].	(methodInterfaces includesKey: aSelector) ifFalse: [^ false].	classToUse _ self classToUseFromInstance: anInstance ofClass: aTargetClass.	^ (aClass _ classToUse whichClassIncludesSelector: aSelector)		ifNil:			[false]		ifNotNil:			[aClass includesBehavior: mostGenericClass]! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 1/26/2001 23:03'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	|   classes aMethodCategory selectors categorySymbols |	super initialize.	self vocabularyName: #eToy.	self documentation: '"EToy" is a vocabulary that provides the equivalent of the 1997-2000 etoy prototype'.	categorySymbols _ Set new.	classes _ Smalltalk allImplementorsOf: #additionsToViewerCategories.	classes do:		[:anItem |		MessageSet parse: anItem toClassAndSelector:			[:aClass :aSelector | aClass].		categorySymbols addAll: aClass soleInstance basicNew categoriesForViewer].	categorySymbols asOrderedCollection do:		[:aCategorySymbol |			aMethodCategory _ ElementCategory new categoryName: aCategorySymbol.				classes _ (Smalltalk allImplementorsOf: #additionsToViewerCategories) collect:					[:anItem | MessageSet parse: anItem toClassAndSelector: [:aMetaClass :aSelector | aMetaClass soleInstance]].			selectors _ Set new.			classes do:				[:aClass |					 (aClass additionsToViewerCategory: aCategorySymbol) do:						[:anElement |							anElement first == #command								ifTrue:									[selectors add: (aSelector _ anElement second).									(methodInterfaces includesKey: aSelector) ifFalse:										[methodInterfaces at: aSelector put: (MethodInterface new initializeFromEToyCommandSpec:  anElement category: aCategorySymbol)]]								ifFalse:  "#slot format"									[selectors add: (aSelector _ anElement seventh).  "the getter"									selectors add: (anElement at: 9) "the setter".									(methodInterfaces includesKey: aSelector) ifFalse:										[self addGetterAndSetterInterfacesFromOldSlotSpec: anElement]]]].			(selectors copyWithout: #unused) asSortedArray do:				[:aSelector |					aMethodCategory elementAt: aSelector put: (methodInterfaces at: aSelector)].				 			self addCategory: aMethodCategory].	#(scripts 'instance variables') do: [:sym | self addCategoryNamed: sym].	self setCategoryDocumentationStrings! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 12/18/2000 09:57'!setCategoryDocumentationStrings	"Initialize the documentation strings associated with the old etoy categories"	#(		(basic				'vitu muhimu')		('color & border'	'rangi na kadhalika')		(geometry 			'sijui neno hilo')		(motion 			'kusogea')		('pen use' 			'utumizi wa kalamu ya wino')		(tests				'majaribio')		(miscellaneous 		'mbali mbali')		(slider				'oh yeah')		(scripts				'methods added by this uniclass')		('instance variables'	'instance variables added by this uniclass')) do:		[:aPair |			(self categoryAt: aPair first asSymbol) documentation: aPair second].! !!EToyVocabulary methodsFor: 'category list' stamp: 'sw 12/18/2000 15:34'!categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass	"Answer the category list for the given object, considering only code implemented in aClass and lower"	^ (anObject isKindOf: Player)		ifTrue:			[(mostGenericClass == aClass)				ifFalse:					[anObject categories]				ifTrue:					[#(scripts #'instance variables')]]		ifFalse:			[super categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass]! !!EToyVocabulary methodsFor: 'method list' stamp: 'sw 1/30/2001 16:31'!allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass	"Answer a list of all methods in the etoy interface which are in the given category, on behalf of anObject, or if it is nil, aClass"	| aCategory unfiltered suitableSelectors isAll |	categoryName ifNil: [^ OrderedCollection new].	aClass isUniClass ifTrue:		[categoryName == #scripts ifTrue:			[^ aClass namedTileScriptSelectors].		categoryName == #'instance variables' ifTrue:			[^ aClass slotInfo keys asSortedArray collect:				[:anInstVarName | Utilities getterSelectorFor: anInstVarName]]].	unfiltered _ (isAll _ categoryName = self allCategoryName)		ifTrue:			[methodInterfaces collect: [:anInterface | anInterface selector]]		ifFalse:			[aCategory _ categories detect: [:cat | cat categoryName == categoryName asSymbol] 							ifNone: [^ OrderedCollection new].			aCategory elementsInOrder collect: [:anElement | anElement selector]].	(anObject isKindOf: Player) ifTrue:		[suitableSelectors _ anObject costume selectorsForViewer.		unfiltered _ unfiltered  select:			[:aSelector | suitableSelectors includes: aSelector]].	(isAll and: [aClass isUniClass]) ifTrue:		[unfiltered addAll: aClass namedTileScriptSelectors.		unfiltered addAll: (aClass slotInfo keys asSortedArray collect:			[:anInstVarName | Utilities getterSelectorFor: anInstVarName])].	^ (unfiltered copyWithoutAll: #(dummy unused)) asSortedArray! !!FullVocabulary methodsFor: 'initialization' stamp: 'sw 12/5/2000 11:02'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')Vocabulary initialize"	super initialize.	vocabularyName _ #Full.	self documentation: '"Full" is all-encompassing vocabulary that embraces all methods understood by an object'.	self rigAFewCategories! !!FullVocabulary methodsFor: 'initialization' stamp: 'sw 1/26/2001 23:03'!rigAFewCategories	"Rig a few catgories, mate.   'Vocabulary fullVocabulary rigAFewCategories'"	| aMethodCategory |	#(	(accessing	'Generally holds methods to read and write instance variables')		(initialization	'messages typically sent when an object is created, to set up its initial state'))		do:			[:pair |				aMethodCategory _ ElementCategory new categoryName: pair first.				aMethodCategory documentation: pair second.				self addCategory: aMethodCategory]! !!FullVocabulary methodsFor: 'category list' stamp: 'sw 12/13/2000 17:34'!categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass	"Answer the category list for the given object, considering only code implemented in mostGeneric and lower (or higher, depending on which way you're facing"	| classToUse |	classToUse _ anObject ifNil: [aClass] ifNotNil: [anObject class].	^ mostGenericClass == classToUse		ifTrue:			[mostGenericClass organization categories]		ifFalse:			[classToUse allMethodCategoriesIntegratedThrough: mostGenericClass]! !!FullVocabulary methodsFor: 'method list' stamp: 'sw 12/12/2000 12:22'!allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass	"Answer a list of all methods which are in the given category, on behalf of anObject"	| classToUse |	classToUse _ aClass ifNil: [anObject class].	^ classToUse allMethodsInCategory: categoryName! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 12/13/2000 17:44'!categoriesContaining: aSelector forClass: aTargetClass	"Answer a list of category names (all symbols) of categories that contain the given selector for the target object.  Initially, this just returns one."	| classDefiningSelector catName |	classDefiningSelector _ aTargetClass classThatUnderstands: aSelector.	classDefiningSelector ifNil: [^ OrderedCollection new].	catName _ classDefiningSelector whichCategoryIncludesSelector: aSelector.	^ OrderedCollection with: catName! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 1/30/2001 12:47'!categoryDefiningSelector: aSelector forClass: targetClass	"Answer which category defines the selector for the given class.  Note reimplementor"	| aClass |	^ (aClass _ targetClass classThatUnderstands: aSelector) 		ifNotNil:			[aClass whichCategoryIncludesSelector: aSelector]! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 12/12/2000 06:06'!encompassesAPriori: aClass	"Answer whether an object, by its very nature, is one that the receiver embraces"	^ true! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 12/1/2000 21:57'!includesSelector: aSelector	"Answer whether the given selector is known to the vocabulary"	^ true! !!FullVocabulary methodsFor: 'queries' stamp: 'sw 12/14/2000 06:00'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given class, only considering method implementations in mostGenericClass and lower"	| classToUse aClass |	classToUse _ self classToUseFromInstance: anInstance ofClass: aTargetClass.	^ (aClass _ classToUse whichClassIncludesSelector: aSelector)		ifNil:			[false]		ifNotNil:			[aClass includesBehavior: mostGenericClass]! !!ScreenedVocabulary methodsFor: 'enumeration' stamp: 'sw 1/5/2001 06:55'!allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass	"Answer a list of all methods in the vocabulary which are in the given category, on behalf of the given class and object"	^ (super allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass) select:		[:aSelector | self includesSelector: aSelector]! !!ScreenedVocabulary methodsFor: 'enumeration' stamp: 'sw 12/14/2000 14:03'!categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass	"Answer the category list for the given object/class, considering only code implemented in mostGenericClass and lower"	^ (super categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass) select:		[:aCategory | categoryScreeningBlock value: aCategory]! !!ScreenedVocabulary methodsFor: 'queries' stamp: 'sw 12/14/2000 14:06'!includesSelector: aSelector	"Answer whether the given selector is known to the vocabulary"	^ methodScreeningBlock value: aSelector! !!ScreenedVocabulary methodsFor: 'queries' stamp: 'sw 12/14/2000 06:01'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given object, only considering method implementations in mostGenericClass and lower"	^ (super includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass) and:		[self includesSelector: aSelector]! !!ScreenedVocabulary methodsFor: 'initialization' stamp: 'sw 12/14/2000 13:58'!categoryScreeningBlock: aBlock	"Set the receiver's categoryScreeningBlock to the block provided"	categoryScreeningBlock _ aBlock! !!ScreenedVocabulary methodsFor: 'initialization' stamp: 'sw 12/4/2000 04:40'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	super initialize.	vocabularyName _  #Public.	self documentation: '"Public" is vocabulary that excludes categories that start with "private" and methods that start with "private" or "pvt"'! !!ScreenedVocabulary methodsFor: 'initialization' stamp: 'sw 12/14/2000 13:57'!methodScreeningBlock: aBlock	"Set the receiver's methodScreeningBlock to the block provided"	methodScreeningBlock _ aBlock! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 1/27/2001 23:49'!initialize	"Initialize a few standard vocabularies and place them in the AllVocabularies list."	self initializeStandardVocabularies.	"Vocabulary initialize"! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 1/28/2001 02:37'!initializeStandardVocabularies	"Initialize a few standard vocabularies and place them in the AllVocabularies list."	AllVocabularies _ OrderedCollection new.	self addVocabulary: EToyVocabulary new.	self addVocabulary: self newTestVocabulary.	self addVocabulary: self newPublicVocabulary.	self addVocabulary: FullVocabulary new.	self addVocabulary: self newNumberVocabulary.	"Vocabulary initialize"! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 12/14/2000 17:29'!newPublicVocabulary	| aVocabulary |	"Answer a public vocabulary"	aVocabulary _ ScreenedVocabulary new.	aVocabulary vocabularyName: #Public.	aVocabulary documentation: '"Public" is vocabulary that excludes categories that start with "private" and methods that start with "private" or "pvt"'.	aVocabulary categoryScreeningBlock: [:aCategoryName | (aCategoryName beginsWith: 'private') not].	aVocabulary methodScreeningBlock: [:aSelector | 		((aSelector beginsWith: 'private') or: [aSelector beginsWith: 'pvt']) not].	^ aVocabulary! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 1/28/2001 23:42'!newTestVocabulary	"Answer a Test vocabulary -- something to mess with, to illustrate and explore ideas."	| aVocabulary  aMethodInterface aMethodCategory |	aVocabulary _ Vocabulary new.	aVocabulary vocabularyName: #Test.	aVocabulary documentation: 'An illustrative vocabulary for testing'.	#((#'class membership' 	'Whether an object can respond to a given message, etc.' 	(isKindOf: class respondsTo:))	(conversion 			'Messages to convert from one kind of object to another' 		(as:  asString))	(copying				'Messages for making copies of objects'						(copy copyFrom:))	(equality 				'Testing whether two objects are equal' 						( = ~= == ~~))	(dependents				'Support for dependency notification'						(addDependent: removeDependent: release))) do:		[:item | 			aMethodCategory _ ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | 					aMethodInterface _ MethodInterface new initializeFor: aSelector.					aVocabulary atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			aVocabulary addCategory: aMethodCategory].	^ aVocabulary! !!Vocabulary class methodsFor: 'access' stamp: 'sw 1/28/2001 00:28'!addVocabulary: aVocabulary	"Add a vocabulary to the list of standard vocabularies"	self allVocabularies.  "Assures initialization"	AllVocabularies add: aVocabulary! !!Vocabulary class methodsFor: 'access' stamp: 'sw 1/27/2001 23:51'!allVocabularies	"Answer a list of the currently-defined vocabularies in my AllVocabularies list"	^ (AllVocabularies ifNil: [AllVocabularies _ self initializeStandardVocabularies]) copy! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 1/26/2001 19:50'!eToyVocabulary	"Anser the etoy vocabulary, if one exists in the AllVocabularies list"	^ self allVocabularies detect: [:aVocabulary | aVocabulary vocabularyName == #eToy] ifNone: [nil]! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 1/26/2001 19:50'!fullVocabulary	"Answer the full vocabulary in my AllVocabularies list, creating it if necessary"	| it |	^ self allVocabularies detect: [:aVocabulary | aVocabulary isMemberOf: FullVocabulary]		ifNone: [AllVocabularies add: (it _ FullVocabulary new).  it]! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 1/26/2001 19:50'!publicVocabulary	"Answer the public vocabulary, which admits through all non-private categories & selectors"	^ self allVocabularies detect: [:aVocabulary | aVocabulary vocabularyName = #Public] ifNone: [self newPublicVocabulary]	"Vocabulary publicVocabulary"! !!Vocabulary class methodsFor: 'standard vocabularies' stamp: 'sw 1/28/2001 02:36'!testVocabulary	"Answer the Test vocabulary lurking in my AllVocabularies list"	^ self allVocabularies detect: [:aVocabulary | aVocabulary vocabularyName == #Test] ifNone: [nil]! !!Vocabulary class methodsFor: 'method interfaces' stamp: 'sw 1/26/2001 23:23'!methodInterfaceFor: aSelector	"Answer the methodInterface object for the given selector, or nil if none in the repository"	^ AllMethodInterfaces at: aSelector ifAbsent: [nil]! !!Vocabulary class methodsFor: 'method interfaces' stamp: 'sw 1/26/2001 23:24'!storeInterface: aMethodInterface forSelector: aSelector	"Store the given method interface at the given selector"	AllMethodInterfaces at: aSelector put: aMethodInterface! !!Vocabulary class methodsFor: 'type vocabularies' stamp: 'sw 1/28/2001 02:37'!newNumberVocabulary	"Answer a Vocabulary object representing the Number vocabulary to the list of AllVocabularies" 	| aVocabulary aMethodCategory aMethodInterface |	"Vocabulary newNumberVocabulary"	aVocabulary _ self new vocabularyName: #Number.		aVocabulary documentation: 'Numbers are things that can do arithmetic, have their magnitudes compared, etc.'.#((arithmetic 				'Basic numeric operation'		(* + - / // \\ abs negated quo: reciprocal rem:))(#'mathematical functions'	'Trigonometric and exponential functions'		(arcCos arcSin arcTan arcTan: cos exp floorLog: interpolateTo:at: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan))('comparing'				'Determining which of two numbers is larger'		(= < > <= >= ~= ~~))('converting' 				'Converting a number to another form'		(@ adaptToCollection:andSend: adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: adaptToPoint:andSend: adaptToString:andSend: asInteger asNumber asPoint asSmallAngleDegrees asSmallPositiveDegrees degreesToRadians radiansToDegrees))) do:		[:item | 			aMethodCategory _ ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | 					aMethodInterface _ MethodInterface new initializeFor: aSelector.					aVocabulary atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			aVocabulary addCategory: aMethodCategory].	^ aVocabulary"(('truncation and round off' ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated)('testing' basicType even isDivisibleBy: isInf isInfinite isNaN isNumber isZero negative odd positive sign strictlyPositive)('converting' @ adaptToCollection:andSend: adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: adaptToPoint:andSend: adaptToString:andSend: asInteger asNumber asPoint asSmallAngleDegrees asSmallPositiveDegrees degreesToRadians radiansToDegrees)('intervals' to: to:by: to:by:do: to:do:)('printing' defaultLabelForInspector isOrAreStringWith: newTileMorphRepresentative printOn: printStringBase: storeOn: storeOn:base: storeStringBase: stringForReadout)('comparing' closeTo:)('filter streaming' byteEncode:)('as yet unclassified' reduce)"! !!Vocabulary class methodsFor: 'type vocabularies' stamp: 'sw 1/28/2001 18:00'!numberVocabulary	"Answer the standard vocabulary representing numbers"	^ self allVocabularies detect: [:aVocabulary | aVocabulary vocabularyName == #number] ifNone: [nil]! !Vocabulary class removeSelector: #addNumberVocabulary!Vocabulary class removeSelector: #basicSqueakVocabulary!Vocabulary initialize!Vocabulary class removeSelector: #newBasicSqueakVocabulary!Vocabulary class removeSelector: #vocabularys!!Vocabulary class reorganize!('class initialization' initialize initializeStandardVocabularies newPublicVocabulary newTestVocabulary)('access' addVocabulary: allVocabularies)('standard vocabularies' eToyVocabulary fullVocabulary publicVocabulary testVocabulary)('method interfaces' methodInterfaceFor: storeInterface:forSelector:)('type vocabularies' newNumberVocabulary numberVocabulary)!!ScreenedVocabulary reorganize!('enumeration' allMethodsInCategory:forInstance:ofClass: categoryListForInstance:ofClass:limitClass:)('queries' includesSelector: includesSelector:forInstance:ofClass:limitClass:)('initialization' categoryScreeningBlock: initialize methodScreeningBlock:)!Vocabulary removeSelector: #namesOfCategoriesContaining:forClass:!ElementCategory removeSelector: #at:put:!!ElementCategory reorganize!('elements' elementAt: elementAt:put: elementsInOrder placeKey:afterKey: placeKey:beforeKey:)('copying' copy copyFrom: copyOfElementDictionary)('keys' includesKey: keysInOrder)('category name' categoryName categoryName:)('initialization' initialize)('printing' printOn:)!