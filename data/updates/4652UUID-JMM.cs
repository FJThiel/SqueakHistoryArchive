'From Squeak3.2alpha of 15 November 2001 [latest update: #4518] on 22 November 2001 at 11:26:24 pm'!TestCase subclass: #TestUUIDPrimitives	instanceVariableNames: ''	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Network-UUID'!ByteArray variableByteSubclass: #UUID	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-UUID'!!UUID commentStamp: '<historical>' prior: 0!A class to generate UUIDby John M McIntosh johnmci@smalltalkconsulting.comSee http://www.webdav.org/specs/draft-leach-uuids-guids-01.txtIf a plugin does not exist then we generate a UUID version 4 type GUUID!Object subclass: #UUIDGenerator	instanceVariableNames: 'timeLow timeMid timeHiAndVersion clockSeqHiAndReserved clockSeqLow node randomCounter randomGenerator semaphoreForGenerator '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Network-UUID'!!UUIDGenerator commentStamp: '<historical>' prior: 0!This class generates a pseudo-random UUIDby John M McIntosh johnmci@smalltalkconsulting.comSee http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt!TestInterpreterPlugin subclass: #UUIDPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!UUIDPlugin commentStamp: '<historical>' prior: 0!A class to generate UUIDby John M McIntosh johnmci@smalltalkconsulting.comSee http://www.webdav.org/specs/draft-leach-uuids-guids-01.txtIf a plugin does not exist then we generate a UUID version 4 type GUUID in Smalltalk!!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 17:14'!testCreation	| uuid |	uuid _ UUID new.	self should: [uuid size = 16].	self shouldnt: [uuid isNilUUID].	self should: [uuid asString size = 36].! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 17:27'!testCreationEquality	| uuid1 uuid2 |	uuid1 _ UUID new.	uuid2 _ UUID new.	self should: [uuid1 = uuid1].	self should: [uuid2 = uuid2].	self shouldnt: [uuid1 = uuid2].	self shouldnt: [uuid1 hash = uuid2 hash].! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 17:17'!testCreationFromString	| uuid string |	string _ UUID nilUUID asString.	uuid _ UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid = UUID nilUUID].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 17:18'!testCreationFromStringNotNil	| uuid string |	string _ UUID new asString.	uuid _ UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid asString size = 36].! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 17:16'!testCreationNil	| uuid |	uuid _ UUID nilUUID.	self should: [uuid size = 16].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 23:24'!testCreationNodeBased	| uuid |	(UUID new asString last: 12) = (UUID new asString last: 12) ifFalse: [^self].	1000 timesRepeat:		[uuid _ UUID new.		self should: [((uuid at: 7) bitAnd: 16rF0) = 16r10].		self should: [((uuid at: 9) bitAnd: 16rC0) = 16r80]]! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 23:24'!testCreationRandom	| uuid |	(UUID new asString last: 12) = (UUID new asString last: 12) ifTrue: [^self].	1000 timesRepeat:		[uuid _ UUID new.		self should: [((uuid at: 7) bitAnd: 16rF0) = 16r40].		self should: [((uuid at: 9) bitAnd: 16rC0) = 16r80]]! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 22:38'!testDuplicationsKinda	|check uuid size |	size _ 5000.	check _ Set new: size.	size timesRepeat: 		[uuid _ UUID new.		self shouldnt: [check includes: uuid].		check add: uuid].		! !!TestUUIDPrimitives methodsFor: 'running' stamp: 'JMM 11/22/2001 17:37'!testOrder	| uuid1 uuid2 |	100 timesRepeat:		[uuid1 _ UUID new.		uuid2 _ UUID new.		(uuid1 asString last: 12) = (uuid2 asString last: 12) ifTrue:			[self should: [uuid1 < uuid2].			self should: [uuid2 > uuid1].			self shouldnt: [uuid1 = uuid2]]]! !!UUID methodsFor: 'initalize-release' stamp: 'JMM 10/9/2001 14:21'!initialize	self primMakeUUID: self! !!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:36'!< aMagnitude 	"Answer whether the receiver is less than the argument."	1 to: self size do: [:i |		(self at: i) < (aMagnitude at: i) ifTrue: [^true]].	^false.! !!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:30'!<= aMagnitude 	"Answer whether the receiver is less than or equal to the argument."	^(self > aMagnitude) not! !!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:30'!> aMagnitude 	"Answer whether the receiver is greater than the argument."	^aMagnitude < self! !!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:30'!>= aMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	^(self < aMagnitude) not! !!UUID methodsFor: 'system primitives' stamp: 'JMM 11/22/2001 14:55'!primMakeUUID: aUUID	<primitive: 'primitiveMakeUUID' module: 'UUIDPlugin'>	UUIDGenerator default generateBytes: self forVersion: 4.! !!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 12:51'!asString	| result data |	data _ String new: 36.	result _ WriteStream on: data.	result nextPutAll: (self createStringStartingAt: 1 for: 4).	result nextPut: $-.	result nextPutAll: (self createStringStartingAt: 5 for: 2).	result nextPut: $-.	result nextPutAll: (self createStringStartingAt: 7 for: 2).	result nextPut: $-.	result nextPutAll: (self createStringStartingAt: 9 for: 2).	result nextPut: $-.	result nextPutAll: (self createStringStartingAt: 11 for: 6).	^data.	! !!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 13:09'!asUUID: aString	| stream token byte |	stream _ ReadStream on: (aString copyReplaceAll: '-' with: '') asUppercase.	1 to: stream size/2 do: [:i | 		token _ stream next: 2.		byte _ Integer readFrom: (ReadStream on: token ) base: 16.		self at: i put: byte].	^self! !!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 13:13'!createStringStartingAt: index for: bytes	| results candidate data |	data _ String new: bytes*2.	results _ WriteStream on: data.	index to: index+bytes -1 do: 		[:i |		candidate _ ((self at: i) printStringBase: 16) last: 2.		candidate first = $r ifTrue: [candidate _ String with: $0 with: candidate last].		results nextPutAll: candidate].	^data asLowercase! !!UUID methodsFor: 'testing' stamp: 'JMM 10/9/2001 14:17'!isNilUUID	1 to: self size do: [:i | (self at: i) ~= 0 ifTrue: [^false]].	^true.! !!UUID methodsFor: 'printing' stamp: 'JMM 10/9/2001 14:46'!printOn: aStream	aStream nextPutAll: 'an UUID('.	self asString printOn: aStream.	aStream nextPutAll: ')'! !!UUID class methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 13:03'!fromString: aString	| object |	aString size ~= 36 ifTrue: [Error signal].	object _ self new: 16. 	object asUUID: aString.	^object! !!UUID class methodsFor: 'instance creation' stamp: 'JMM 10/9/2001 13:56'!new	^(self new: 16) initialize! !!UUID class methodsFor: 'instance creation' stamp: 'JMM 10/9/2001 14:14'!nilUUID	^self new: 16! !!UUIDGenerator methodsFor: 'generator' stamp: 'JMM 11/22/2001 13:51'!generateOneOrZero	| result |	self semaphoreForGenerator		critical: [| value | 			value _ self randomGenerator next.			self randomCounter: self randomCounter + 1.			self randomCounter > 100000				ifTrue: [self setupRandom].			result _ value < 0.5						ifTrue: [0]						ifFalse: [1]].	^ result! !!UUIDGenerator methodsFor: 'generator' stamp: 'JMM 11/21/2001 15:12'!generateRandomBitsOfLength: aNumberOfBits| target |	target _ 0.	aNumberOfBits isZero ifTrue: [^target].	target _ self generateOneOrZero.	(aNumberOfBits - 1)  timesRepeat:		[target _ (target bitShift: 1)  bitOr: self generateOneOrZero].	^target! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:28'!randomCounter	^randomCounter! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!randomCounter: aNumber	randomCounter _ aNumber! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:27'!randomGenerator	^randomGenerator! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:27'!randomGenerator: aGenerator	randomGenerator _ aGenerator! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!semaphoreForGenerator	^semaphoreForGenerator! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!semaphoreForGenerator: aSema	semaphoreForGenerator _ aSema! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 13:45'!generateBytes: aPlaceHolder forVersion: aVersion	aVersion = 4 ifTrue: [self generateFieldsVersion4]		ifFalse: [self error: 'Unsupported version'].	self placeFields: aPlaceHolder.! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 23:13'!generateFieldsVersion4	timeLow _ self generateRandomBitsOfLength: 32.	timeMid _ self generateRandomBitsOfLength: 16.	timeHiAndVersion _ 16r4000 bitOr: (self generateRandomBitsOfLength: 12).	clockSeqHiAndReserved _ 16r80 bitOr: (self generateRandomBitsOfLength: 6).	clockSeqLow _ self generateRandomBitsOfLength: 8.	node _ self generateRandomBitsOfLength: 48.	! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/21/2001 14:30'!initialize	self setupRandom.	semaphoreForGenerator _ Semaphore forMutualExclusion.	! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 23:12'!placeFields: aByteArray	aByteArray at: 1 put: ((timeLow bitShift: -24) bitAnd: 16rFF).	aByteArray at: 2 put: ((timeLow bitShift: -16) bitAnd: 16rFF).	aByteArray at: 3 put: ((timeLow bitShift: -8) bitAnd: 16rFF).	aByteArray at: 4 put: (timeLow bitAnd: 16rFF).	aByteArray at: 5 put: ((timeMid bitShift: -8) bitAnd: 16rFF).	aByteArray at: 6 put: (timeMid bitAnd: 16rFF).	aByteArray at: 7 put: ((timeHiAndVersion bitShift: -8) bitAnd: 16rFF).	aByteArray at: 8 put: (timeHiAndVersion bitAnd: 16rFF).	aByteArray at: 9 put: clockSeqHiAndReserved.	aByteArray at: 10 put: clockSeqLow.	0 to: 5 do: [:i |		aByteArray at: 11 + i put: ((node bitShift: (-8*i)) bitAnd: 16rFF)]! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/21/2001 14:17'!setupRandom	| seed |	randomCounter _ 0.	[seed := (Time millisecondClockValue bitAnd: 16r3FFFFFFF) bitXor: self hash.	seed = 0] whileTrue: ["Try again if ever get a seed = 0"].	randomGenerator _ Random seed: seed.! !!UUIDGenerator class methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 13:41'!default	Default ifNil: [self generateDefault].	^Default! !!UUIDGenerator class methodsFor: 'instance creation' stamp: 'JMM 11/21/2001 14:13'!generateDefault	Default _ self new initialize! !!UUIDPlugin methodsFor: 'system primitives' stamp: 'JMM 10/9/2001 14:28'!primitiveMakeUUID: location	self primitive: 'primitiveMakeUUID'		parameters: #(ByteArray).	self cCode: 'MakeUUID((UUIDD *) location)' inSmalltalk: [].! !!UUIDPlugin methodsFor: 'initialize' stamp: 'JMM 10/9/2001 12:47'!initialiseModule	self export: true.	^self cCode: 'sqUUIDInit()' inSmalltalk:[true]! !!UUIDPlugin class methodsFor: 'translation' stamp: 'JMM 10/9/2001 12:46'!hasHeaderFile	"If there is a single intrinsic header file to be associated with the plugin, here is where you want to flag"	^true! !!UUIDPlugin class methodsFor: 'translation' stamp: 'JMM 10/9/2001 13:37'!requiresPlatformFiles	"this plugin requires platform specific files in order to work"	^true! !