'From Squeak2.8alpha of 12 January 2000 [latest update: #1976] on 4 April 2000 at 9:52:24 am'!"Change Set:		ModularProjects10Date:			3 April 2000Author:			Dan IngallsBrings the new changeSets to the point where they can capture all info from existing changeSets successfully.Then, in the postscript, mutate all existing changeSets and supplant the old ChangeSet class by the new one."!!ChangeSet methodsFor: 'testing' stamp: 'di 4/1/2000 22:19'!contentString   "Smalltalk changes contentString"	"Used for testing same results as existing changeSets."	| s |	s _ String streamContents: [:strm | self fileOutOn: strm].	self wither.	^ s! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/1/2000 22:33'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now.  *** Classes renamed in otherChangeSet may have problems"	| cls info selector pair |	otherChangeSet changedClassNames do: [:className |	  (cls _ Smalltalk classNamed: className) ifNotNil:		[info _ otherChangeSet classChangeAt: className.		info do: [:each | each = #add					ifTrue: [self atClass: cls add: #new.							self atClass: cls add: #change]					ifFalse: [self atClass: cls add: each]].		self absorbStructureOfClass: cls from: otherChangeSet.		info _ otherChangeSet methodChanges at: className 			ifAbsent: [Dictionary new].		info associationsDo: [:assoc |			assoc value == #remove				ifTrue:					[selector _ assoc key.					pair _ otherChangeSet methodInfoFromRemoval: {cls name. selector}.					self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]				ifFalse: 					[self atSelector: assoc key class: cls put: assoc value]]]].		classRemoves addAll: otherChangeSet classRemoves.	"names of them"! !!ChangeSetRevertable commentStamp: 'di 4/3/2000 09:08' prior: 0!ChangeSets keep track of the changes made to a system, so they can be written on a file as source code (a "fileOut").  Every project has an associated changeSet.  For simple projects, a different changeSet may be designated to capture changes at any time.For isolated projects (see Project class comment), the changeSet binding is semi-permanent.  Every project exists in an isolation layer defined by its closest enclosing parent (or itself) that is isolated.  If a project is not isolated, then changes reported to its designated changeSet must also be reported to the permanent changeSet for that layer, designated in the isolated project.  This ensures that that outer project will be able to revert all changes upon exit.Note that only certain changes may be reverted.  Classes may not be added, removed, renamed or reshaped except in the layer in which they are defined because these operations on non-local classes are not revertable.If a Squeak Project is established as being isolated, then its associated changeSet will be declared to be revertable.  In this case all changes stored can be reverted.  The changeSet associated with an isolated project is tied to that project, and cannot be edited in a changeSorter.------name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.revertable - a BooleanIf this variable is true, then all of the changes recorded by this changeSet can be reverted.isolationSet - a ChangeSet or nilThe isolationSet is the designated changeSet for an isolation layer.  If this changeSet is an isolationSet, then this variable will be nil.  If not, then it points to the isolationSet for this layer, and all changes reported here will also be reported to the isolationSet.isolatedProject - a Project or nilIf this is an isolationSet, then this variable points to the project with which it is associated.changeRecords -  Dictionary {class name -> a ClassChangeRecord}.These classChangeRecords (qv) remember all of the system changes.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.Of all classes in classChanges, and all of their superclasses.Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).NOTE:  It should be fairly simple, by adding a bit more information to the classChangeRecords, to reconstruct the information now stored in 'structures' and 'superclasses'.  This would be a welcome simplification.!!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 4/3/2000 13:34'!conversionInit	changeRecords _ Dictionary new.	revertable _ false.! !!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 4/3/2000 14:46'!initialize 	"Reset the receiver to be empty."	revertable _ false.	self clear. 	"Avoid duplicate entries in AllChanges if initialize gets called twice"	name _ ChangeSet defaultName.! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'di 4/1/2000 22:21'!contentString   "Smalltalk changes contentString"	"Used for testing same results as existing changeSets."	| s |	s _ String streamContents: [:strm | self fileOutOn: strm].	self wither.	^ s! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'di 4/1/2000 23:17'!noteRemovalOf: class	"The class is about to be removed from the system.	Adjust the receiver to reflect that fact."	(self changeRecorderFor: class)		noteChangeType: #remove fromClass: class.	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/4/2000 09:37'!absorbClass: className from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.	*** Classes renamed in otherChangeSet may have problems"	| cls |	(self changeRecorderFor: className)			assimilateAllChangesIn: (otherChangeSet changeRecorderFor: className).	(cls _ Smalltalk classNamed: className) ifNotNil:		[self absorbStructureOfClass: cls from: otherChangeSet].! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/3/2000 17:53'!absorbStructureOfClass: aClass from: otherChangeSet	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSet structures ifNil: [^ self].	(otherChangeSet structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil:		[structures _ Dictionary new.		superclasses _ Dictionary new].	sup _ aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [structures at: sup put: (otherChangeSet structures at: sup).				next _ otherChangeSet superclasses at: sup.				superclasses at: sup put: next.				(sup _ next) = 'nil']	] whileFalse.! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/4/2000 09:52'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now."	| cls info selector pair |otherChangeSet isRevertable ifTrue: [	otherChangeSet changedClassNames do:		[:className | self absorbClass: className from: otherChangeSet]] ifFalse: [	otherChangeSet changedClassNames do:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[info _ otherChangeSet classChangeAt: className.			info do: [:each | self atClass: cls add: each].			self absorbStructureOfClass: cls from: otherChangeSet.			info _ otherChangeSet methodChanges at: className 				ifAbsent: [Dictionary new].			info associationsDo:				[:assoc | selector _ assoc key.				(assoc value == #remove or: [assoc value == #addedThenRemoved])					ifTrue:						[assoc value == #addedThenRemoved							ifTrue: [self atSelector: selector class: cls put: #add].						pair _ otherChangeSet methodInfoFromRemoval: {cls name. selector}.						self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]					ifFalse: 						[self atSelector: selector class: cls put: assoc value]]]].		otherChangeSet classRemoves do:			[:className | self noteRemovalOf: className].	"names of them"]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 4/3/2000 14:46'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self notify: 'Warning: no changes to file out'].	classList _ ChangeSet superclassOrder: self changedClasses asOrderedCollection.	"First put out rename, max classDef and comment changes."	classList do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	classList do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	classList reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSetRevertable class methodsFor: 'defaults' stamp: 'di 4/3/2000 15:06'!convertAll    "ChangeSetRevertable convertAll"	"This method converts all existing ChangeSets into instances of this class,	Then renames the classes, recompiles methods referring to this one,	And finally deletes the OldChangeSet class."	| i oldOnes newOnes methodRefs |	(Smalltalk allCallsOn: (Smalltalk associationAt: #ChangeSetRevertable)) isEmpty		ifFalse: [self halt: 'something not right'].'Converting all old changeSets...'	displayProgressAt: Sensor cursorPoint	from: 1 to: ChangeSet instanceCount	during: [:bar | i _ 0.			oldOnes _ ChangeSet allInstances.			newOnes _ oldOnes collect:				[:old | bar value: (i _ i + 1).				(old as: self) conversionInit assimilateAllChangesFoundIn: old].			oldOnes asArray elementsExchangeIdentityWith: newOnes asArray.			].	ChangeSet rename: #OldChangeSet.	self rename: #ChangeSet.	methodRefs _ Smalltalk allCallsOn: (Smalltalk associationAt: #OldChangeSet).	methodRefs do:		[:ref | MessageSet parse: ref toClassAndSelector:			[:class :selector | class recompile: selector from: class]].	Smalltalk removeClassNamed: #OldChangeSet.! !!ChangeSetRevertable class methodsFor: 'defaults' stamp: 'di 4/3/2000 14:38'!test    "ChangeSetRevertable test inspect"	"This is an acid-test that compares fileOuts from simple changeSet-changeSet assimilation (drops the preamble and postscript) with changeSet-revertable-changeSet assimilation.  If it works for all changeSets, then we have some assurance that the new revertable changeSets do as well as the old.	If the result is a non-empty array, then one can paste the names of the problem sets into parts of this method to inspect the non-matching cases."    | i |^ 'Comparing all changeSets...'	displayProgressAt: Sensor cursorPoint	from: 1 to: ChangeSorter allChangeSetNames size	during: [:bar | i _ 0.	(ChangeSorter changeSetsNamedSuchThat: [:n | true]) select:		[:cs | bar value: (i _ i+1).		(ChangeSet new initialize			assimilateAllChangesFoundIn:		(self new initialize			assimilateAllChangesFoundIn:				(ChangeSorter changeSetNamed: cs name)))			contentString		 ~= 		(ChangeSet new initialize			assimilateAllChangesFoundIn:				(ChangeSorter changeSetNamed: cs name))			contentString]]! !!ChangeSorter methodsFor: 'class list' stamp: 'di 4/4/2000 09:37'!copyClassToOther	"Place these changes in the other changeSet also"	| otherSorter otherChangeSet |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self beep].	currentClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	otherSorter showChangeSet: otherChangeSet.! !!ChangeSorter methodsFor: 'class list' stamp: 'di 4/3/2000 20:31'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	self copyClassToOther.	self forgetClass! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 17:25'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	self gatherChangeSets.	^ AllChangeSets select: [:aChangeSet | nameBlock value: aChangeSet name]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 4/3/2000 14:51'!gatherChangeSets		"ChangeSorter gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets obsolete |	allChangeSets _ AllChangeSets asSet.	ChangeSet allSubInstances do: [:each |		(allChangeSets includes: each) == (obsolete _ each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 4/3/2000 14:48'!newChangeSet	"Prompt the user for a name, and establish a new change set of that name (if ok), making it the current changeset.  Return nil of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank request: 'Please name the new change set:'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue:		[self inform: 'nothing done'.		^ nil].	(self changeSetNamed: newName) ifNotNil:			[self inform: 'Sorry that name is already used'.			^ nil].	newSet _ ChangeSet new initialize name: newName.	AllChangeSets add: newSet.	Smalltalk newChanges: newSet.	Transcript cr; show: newName, ' is now the current change set'.	^ newSet! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:39'!allChangeTypes	| chgs |	(priorName ~~ nil and: [changeTypes includes: #rename]) ifTrue:		[(chgs _ changeTypes copy) add: 'oldName: ' , priorName.		^ chgs].	^ changeTypes! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:59'!assimilateAllChangesIn: otherRecord	| selector changeRecord changeType |	otherRecord isClassRemoval ifTrue: [^ self noteChangeType: #remove].	otherRecord allChangeTypes do:		[:chg | self noteChangeType: chg fromClass: self realClass].	otherRecord methodChanges associationsDo:		[:assn | selector _ assn key. changeRecord _ assn value.		changeType _ changeRecord changeType.		(changeType == #remove or: [changeType == #addedThenRemoved])			ifTrue:				[changeType == #addedThenRemoved					ifTrue: [self atSelector: selector put: #add].				self noteRemoveSelector: selector priorMethod: nil						lastMethodInfo: changeRecord methodInfoFromRemoval]			ifFalse: 				[self atSelector: selector put: changeType]].! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/1/2000 23:08'!noteChangeType: changeSymbol fromClass: class	changeSymbol = #new ifTrue:		[changeTypes add: #add.		changeTypes remove: #change ifAbsent: [].		^ self].	changeSymbol = #change ifTrue:		[(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol = #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue:		["Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName _ changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	changeSymbol = #remove ifTrue:		[(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAllFoundIn: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 4/1/2000 23:05'!isClassRemoval	"NOTE: there are other removals with changeType #addedThenRemoved,	but this message is used to write out removals in fileOut, and those	cases should not be written out."	^ (changeTypes includes: #remove) or: [changeTypes includes: #removeClass]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 4/1/2000 23:49'!methodChanges	^ methodChanges! !!Project methodsFor: 'isolation layers' stamp: 'di 4/3/2000 14:48'!beIsolated	"Establish an isolation layer at this project.	This requires clearing the current changeSet or installing a new one."	isolatedHead ifTrue: [^ self error: 'Already isolated'].	Project current == self ifFalse:		[^ self inform: 'Must be in this project to isolate it'.].	changeSet isEmpty ifFalse: [changeSet _ ChangeSorter newChangeSet].	changeSet beIsolationSetFor: self.	isolatedHead _ true.	inForce _ true.	environment _ Environment new setName: self name outerEnvt: Smalltalk.! !ChangeSetRevertable removeSelector: #isRevertable!"Postscript:The following statement mutates all existing changeSets and supplant the old ChangeSet class by the new one.  It was called ChangeSetRevertable until now.  Now it becomes the real ChangeSet..."ChangeSetRevertable convertAll!