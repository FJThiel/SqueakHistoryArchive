'From Squeak 2.3 beta of Nov 25, 1998 on 13 December 1998 at 3:43:25 pm'!"Change Set:		AtCacheOnlyDate:			12 December 1998Author:			Dan IngallsThese changes introduce a special cache to speed up the operation of at: and at:put:.This facility is also extended to next and nextPut.These changes are mingled with the MethodCacheByRow as well."!!Interpreter methodsFor: 'message sending' stamp: 'di 12/13/1998 16:04'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lookupClass rcvr |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvr _ self internalStackValue: argumentCount.	lookupClass _ self fetchClassOf: rcvr.	self internalFindNewMethodInClass: lookupClass.	self internalExecuteNewMethod: lookupClass.	self fetchNextBytecode.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/12/1998 23:12'!internalExecuteNewMethod: lookupClass	self inline: true.	primitiveIndex > 0		ifTrue: [(primitiveIndex > 255 and: [primitiveIndex < 520])				ifTrue: ["Internal return instvars"						primitiveIndex >= 264						ifTrue:						[^ self internalPop: 1 thenPush:								(self fetchPointer: primitiveIndex-264										ofObject: self internalStackTop)]						ifFalse:						["Internal return constants"						primitiveIndex = 256 ifTrue: [^ nil "^ self"].						primitiveIndex = 257 ifTrue: [^ self internalPop: 1 thenPush: trueObj].						primitiveIndex = 258 ifTrue: [^ self internalPop: 1 thenPush: falseObj].						primitiveIndex = 259 ifTrue: [^ self internalPop: 1 thenPush: nilObj].						^ self internalPop: 1 thenPush: (self integerObjectOf: primitiveIndex-261)]]				ifFalse: 	[self externalizeIPandSP.						(self primitiveResponse: lookupClass) ifTrue: [self internalizeIPandSP. ^ nil].						self internalizeIPandSP]].	"if not primitive, or primitive failed, activate the method"	self internalActivateNewMethod.	"check for possible interrupts at each real send"	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/12/1998 22:54'!internalFindNewMethodInClass: lookupClass	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: true.	ok _ self lookupInMethodCacheSel: messageSelector class: lookupClass.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: lookupClass.		self internalizeIPandSP.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: lookupClass			method: newMethod			primIndex: primitiveIndex.	].! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/12/1998 23:12'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lookupClass |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	lookupClass _ self fetchClassOf: (self internalStackValue: argumentCount).	self internalFindNewMethodInClass: lookupClass.	self internalExecuteNewMethod: lookupClass.	self fetchNextBytecode.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/12/1998 23:12'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lookupClass |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	lookupClass _ self superclassOf: (self methodClassOf: method).	self internalFindNewMethodInClass: lookupClass.	self internalExecuteNewMethod: lookupClass.	self fetchNextBytecode.! !!Interpreter methodsFor: 'method lookup cache' stamp: 'di 12/12/1998 23:37'!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	1 to: AtCacheTotalSize do: [ :i | atCache at: i put: 0 ].! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/12/1998 13:59'!bytecodePrimAt	"BytecodePrimAt will only succeed if the receiver is in the atCache.	Otherwise it will fail so that the more general primitiveAt will put it in the	cache after validating that message lookup results in a primitive response."	| index rcvr result atIx |	index _ self internalStackTop.	rcvr _ self internalStackValue: 1.	successFlag _ (self isIntegerObject: rcvr) not and: [self isIntegerObject: index].	successFlag ifTrue:		[atIx _ (rcvr bitAnd: AtCacheMask) + 1.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr		ifTrue:			[result _ self commonVariableInternal: rcvr at: (self integerValueOf: index)							cacheIndex: atIx.			successFlag ifTrue:				[self fetchNextBytecode.				^ self internalPop: 2 thenPush: result]]].	messageSelector _ self specialSelector: 16.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/12/1998 22:15'!bytecodePrimAtPut	"BytecodePrimAtPut will only succeed if the receiver is in the atCache.	Otherwise it will fail so that the more general primitiveAtPut will put it in the	cache after validating that message lookup results in a primitive response."	| index rcvr atIx value |	value _ self internalStackTop.	index _ self internalStackValue: 1.	rcvr _ self internalStackValue: 2.	successFlag _ (self isIntegerObject: rcvr) not and: [self isIntegerObject: index].	successFlag ifTrue:		[atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase + 1.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr		ifTrue:			[self commonVariable: rcvr at: (self integerValueOf: index)							put: value cacheIndex: atIx.			successFlag ifTrue:				[self fetchNextBytecode.				^ self internalPop: 3 thenPush: value]]].	messageSelector _ self specialSelector: 17.	argumentCount _ 2.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/11/1998 10:22'!bytecodePrimSize	messageSelector _ self specialSelector: 18.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'primitive support' stamp: 'di 12/12/1998 23:20'!primitiveResponse: lookupClass	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| timerPending startTime |	lkupClass _ lookupClass.	timerPending _ nextWakeupTick ~= 0.	timerPending ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	timerPending ifTrue: [		(self ioLowResMSecs ~= startTime) ifTrue: [			"primitive ran for more than a tick; check for possible timer interrupts"			((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [				successFlag					ifTrue: ["process the interrupt now"							self checkForInterrupts]					ifFalse: ["process the interrupt in primtive failure code"							interruptCheckCounter _ 0]]]].	^ successFlag! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/10/1998 14:53'!characterForAscii: ascii  "Arg must lie in range 0-255!!"	self inline: true.	^ self fetchPointer: ascii ofObject: (self splObj: CharacterTable)! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/12/1998 11:00'!commonAt: stringy	"This code is called if the receiver responds primitively to at:.	If this is so, it will be installed in the atCache so that subsequent calls of at:	or next may be handled immediately in bytecode primitive routines."	| index rcvr atIx result |	index _ self stackTop.	rcvr _ self stackValue: 1.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The at-cache, since it is specific to the non-super response to #at:.	Therefore we must determine that the message is #at: (not, eg, #basicAt:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 16)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ (rcvr bitAnd: AtCacheMask) + 1.  "Index into atCache = 4N, for N = 0 ... 7"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue: [result _ self commonVariable: rcvr									at: (self integerValueOf: index)									cacheIndex: atIx].		successFlag ifTrue: [^ self pop: 2 thenPush: result]].	"The slow but sure way..."	successFlag _ true.	result _ self stObject: rcvr at: (self integerValueOf: index).	successFlag ifTrue:		[stringy ifTrue: [result _ self characterForAscii: (self integerValueOf: result)].		^ self pop: 2 thenPush: result]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/12/1998 22:21'!commonAtPut: stringy	"This code is called if the receiver responds primitively to at:Put:.	If this is so, it will be installed in the atPutCache so that subsequent calls of at:	or  next may be handled immediately in bytecode primitive routines."	| value index rcvr atIx |	value _ self stackTop.	index _ self stackValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not		ifFalse: [^ self primitiveFail].	"NOTE:  The atPut-cache, since it is specific to the non-super response to #at:Put:.	Therefore we must determine that the message is #at:Put: (not, eg, #basicAt:Put:),	and that the send is not a super-send, before using the at-cache."	(messageSelector = (self specialSelector: 17)		and: [lkupClass = (self fetchClassOfNonInt: rcvr)])		ifTrue:		["OK -- look in the at-cache"		atIx _ (rcvr bitAnd: AtCacheMask) + AtPutBase + 1.  "Index into atPutCache"		(atCache at: atIx+AtCacheOop) = rcvr ifFalse:			["Rcvr not in cache.  Install it..."			self install: rcvr inAtCache: atCache at: atIx string: stringy].		successFlag ifTrue: [self commonVariable: rcvr at: (self integerValueOf: index)									put: value cacheIndex: atIx].		successFlag ifTrue: [^ self pop: 3 thenPush: value]].	"The slow but sure way..."	successFlag _ true.	stringy ifTrue: [self stObject: rcvr at: (self integerValueOf: index)							put: (self asciiOfCharacter: value)]			ifFalse: [self stObject: rcvr at: (self integerValueOf: index)							put: value].	successFlag ifTrue: [^ self pop: 3 thenPush: value].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/10/1998 21:27'!commonVariable: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	stSize _ atCache at: atIx+AtCacheSize.	(index >= 1 and: [index <= stSize])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result _ self fetchWord: index - 1 ofObject: rcvr.			result _ self positive32BitIntegerFor: result.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/12/1998 22:20'!commonVariable: rcvr at: index put: value cacheIndex: atIx	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields valToPut |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	(index >= 1 and: [index <= stSize])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self storePointer: index + fixedFields - 1 ofObject: rcvr withValue: value].		fmt < 8 ifTrue:  "Bitmap"			[valToPut _ self positive32BitValueOf: value.			successFlag ifTrue: [self storeWord: index - 1 ofObject: rcvr withValue: valToPut].			^ nil].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: [valToPut _ self asciiOfCharacter: value.					successFlag ifFalse: [^ nil]]			ifFalse: [valToPut _ value].		(self isIntegerObject: valToPut) ifTrue:			[^ self storeByte: index - 1 ofObject: rcvr						withValue: (self integerValueOf: valToPut)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/10/1998 21:27'!commonVariableInternal: rcvr at: index cacheIndex: atIx 	"This code assumes the reciever has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	self inline: true.	stSize _ atCache at: atIx+AtCacheSize.	(index >= 1 and: [index <= stSize])	ifTrue:		[fmt _ atCache at: atIx+AtCacheFmt.		fmt <= 4 ifTrue:			[fixedFields _ atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result _ self fetchWord: index - 1 ofObject: rcvr.			self externalizeIPandSP.			result _ self positive32BitIntegerFor: result.			self internalizeIPandSP.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/11/1998 09:46'!install: rcvr inAtCache: cache at: atIx string: stringy	"Install the oop of this object in the given cache (at or atPut), along with	its size, format and fixedSize"	| hdr fmt totalLength fixedFields |	self var: #cache declareC: 'int *cache'.	hdr _ self baseHeader: rcvr.	fmt _ (hdr >> 8) bitAnd: 16rF.	(fmt = 3 and: [self isContextHeader: hdr]) ifTrue:		["Contexts must not be put in the atCache, since their size is not constant"		^ self primitiveFail].	totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.	cache at: atIx+AtCacheOop put: rcvr.	stringy ifTrue: [cache at: atIx+AtCacheFmt put: fmt + 16]  "special flag for strings"			ifFalse: [cache at: atIx+AtCacheFmt put: fmt].	cache at: atIx+AtCacheFixedFields put: fixedFields.	cache at: atIx+AtCacheSize put: totalLength - fixedFields.! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/11/1998 10:15'!primitiveAtEnd	| stream index limit |	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamReadLimitIndex+1)]). 	successFlag ifTrue: [		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream]. 	successFlag		ifTrue: [self pushBool: (index >= limit)]		ifFalse: [self unPop: 1].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/10/1998 21:28'!primitiveNext	"PrimitiveNext will succeed only if the stream's array is in the atCache.	Otherwise failure will lead to proper message lookup of at: and	subsequent installation in the cache if appropriate."	| stream array index limit result atIx |	stream _ self stackTop.	((self isPointers: stream)		and: [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)])		ifFalse: [^ self primitiveFail].	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	atIx _ (array bitAnd: AtCacheMask) + 1.	(index < limit and: [(atCache at: atIx+AtCacheOop) = array])		ifFalse: [^ self primitiveFail].	"OK -- its not at end, and the array is in the cache"	index _ index + 1.	result _ self commonVariable: array at: index cacheIndex: atIx.	"Above may cause GC, so can't use stream, array etc. below it"	successFlag ifTrue:		[stream _ self stackTop.		self storeInteger: StreamIndexIndex ofObject: stream withValue: index.		^ self pop: 1 thenPush: result].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/12/1998 22:22'!primitiveNextPut	"PrimitiveNextPut will succeed only if the stream's array is in the atPutCache.	Otherwise failure will lead to proper message lookup of at:put: and	subsequent installation in the cache if appropriate."	| value stream index limit array atIx |	value _ self stackTop.	stream _ self stackValue: 1.	((self isPointers: stream)		and: [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)])		ifFalse: [^ self primitiveFail].	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	atIx _ (array bitAnd: AtCacheMask) + AtPutBase + 1.	(index < limit and: [(atCache at: atIx+AtCacheOop) = array])		ifFalse: [^ self primitiveFail].	"OK -- its not at end, and the array is in the cache"	index _ index + 1.	self commonVariable: array at: index put: value cacheIndex: atIx.	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream withValue: index.		^ self pop: 2 thenPush: value].! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/12/1998 23:19'!primitiveDoPrimitiveWithArgs	| argumentArray arraySize index cntxSize primIdx |	argumentArray _ self stackTop.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	primIdx _ self stackIntegerValue: 1.	successFlag ifFalse: [^ self primitiveFail].  "invalid args"	"Pop primIndex and argArray, then push args in place..."	self pop: 2.	primitiveIndex _ primIdx.	argumentCount _ arraySize.	index _ 1.	[index <= argumentCount]		whileTrue:		[self push: (self fetchPointer: index - 1 ofObject: argumentArray).		index _ index + 1].	"Run the primitive (sets successFlag)"	self pushRemappableOop: argumentArray.	"prim might alloc/gc"	self primitiveResponse: nilObj.	argumentArray _ self popRemappableOop.	successFlag ifFalse:		["If primitive failed, then restore state for failure code"		self pop: arraySize.		self pushInteger: primIdx.		self push: argumentArray.		argumentCount _ 2.		"... caller (execNewMeth) will run failure code"]! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/12/1998 23:18'!primitivePerform	| performSelector newReceiver selectorIndex lookupClass |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	"NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,		so we must adjust argument count now, so that would work."	argumentCount _ argumentCount - 1.	lookupClass _ self fetchClassOf: newReceiver.	self findNewMethodInClass: lookupClass.	self success: (self argumentCountOf: newMethod) = argumentCount.	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount.				self transfer: argumentCount					fromIndex: selectorIndex + 1					ofObject: activeContext					toIndex: selectorIndex					ofObject: activeContext.				self pop: 1.				self executeNewMethod: lookupClass.  "Recursive xeq affects successFlag"				successFlag _ true]		ifFalse: [argumentCount _ argumentCount + 1.				messageSelector _ performSelector]! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/12/1998 23:16'!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arraySize index cntxSize lookupClass |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag		ifTrue: [performSelector _ messageSelector.				messageSelector _ self popStack.				thisReceiver _ self stackTop.				argumentCount _ arraySize.				index _ 1.				[index <= argumentCount]					whileTrue:					[self push: (self fetchPointer: index - 1 ofObject: argumentArray).					index _ index + 1].				lookupClass _ self fetchClassOf: thisReceiver.				self findNewMethodInClass: lookupClass.				self success: (self argumentCountOf: newMethod) = argumentCount.				successFlag					ifTrue: [self executeNewMethod: lookupClass.  "Recursive xeq affects successFlag"							successFlag _ true]					ifFalse: [self pop: argumentCount.							self push: messageSelector.							self push: argumentArray.							argumentCount _ 2.							messageSelector _ performSelector]]	ifFalse: [self unPop: 1]! !!Interpreter class methodsFor: 'initialization' stamp: 'di 12/10/1998 22:11'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCaches.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 25.! !!Interpreter class methodsFor: 'initialization' stamp: 'di 12/12/1998 23:39'!initializeCaches 	| atCacheEntrySize |	MethodCacheEntries _ 512. 	MethodCacheSelector _ 0.	MethodCacheClass _ 1.	MethodCacheMethod _ 2.	MethodCachePrim _ 3.	MethodCacheEntrySize _ 4.  "Must be power of two for masking scheme."	MethodCacheMask _ (MethodCacheEntries - 1) * MethodCacheEntrySize.	MethodCacheSize _ MethodCacheEntries * MethodCacheEntrySize.	CacheProbeMax _ 3.	AtCacheEntries _ 8.  "Must be power of two"	AtCacheOop _ 0.	AtCacheSize _ 1.	AtCacheFmt _ 2.	AtCacheFixedFields _ 3.	atCacheEntrySize _ 4.  "Must be power of two for masking scheme."	AtCacheMask _ (AtCacheEntries-1) * atCacheEntrySize.	AtPutBase _ AtCacheEntries * atCacheEntrySize.	AtCacheTotalSize _ AtCacheEntries * atCacheEntrySize * 2.! !!Interpreter class methodsFor: 'translation' stamp: 'di 12/12/1998 22:11'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'atCache'		declareC: 'int atCache[', (AtCacheTotalSize + 1) printString, ']'.	aCCodeGenerator var: 'localIP' declareC: 'char * localIP'.	aCCodeGenerator var: 'localSP' declareC: 'char * localSP'.	aCCodeGenerator var: 'semaphoresToSignal'		declareC: 'int semaphoresToSignal[', (SemaphoresToSignalSize + 1) printString, ']'.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 12/12/1998 22:21'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside	Smalltalk. The primary responsibility of this method is to allocate	Smalltalk Arrays for variables that will be declared as statically-allocated	global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	atCache _ Array new: AtCacheTotalSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresToSignal _ Array new: SemaphoresToSignalSize.	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/12/1998 23:16'!executeNewMethod: lookupClass	primitiveIndex > 0		ifTrue: [(self primitiveResponse: lookupClass) ifTrue: [^ nil]].	"if not primitive, or primitive failed, activate the method"	self activateNewMethod.	"check for possible interrupts at each real send"	self quickCheckForInterrupts.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/13/1998 16:04'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lookupClass rcvr |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvr _ self internalStackValue: argumentCount.	lookupClass _ self fetchClassOf: rcvr.	self internalFindNewMethodInClass: lookupClass.	self internalExecuteNewMethod: lookupClass.	self fetchNextBytecode.! !Interpreter removeSelector: #executeNewMethod!Interpreter removeSelector: #internalExecuteNewMethod!Interpreter removeSelector: #primitiveResponse!Interpreter removeSelector: #internalFindNewMethodInClass!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext localReceiver messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!Interpreter initialize!