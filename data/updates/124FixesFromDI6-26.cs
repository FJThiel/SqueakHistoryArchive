'From Squeak 2.0 of May 22, 1998 on 26 June 1998 at 3:13:05 pm'!"Change Set:		FixesFromDI6-26Date:			26 June 1998Author:			Dan IngallsFixes colorUnder access to the World's background color.Makes colorUnder immune to huge coordinates.Makes method revert update properly in MVC and Morphic MessageSets.Restores access to the shifted menu in codePanes -- many removals!!Unifies normal and shift menu access in lists and text -- more removals.Uses selectWord for browseReferencesToIt.Fixes long-standing selection bug in morphic paste (by menu)."!!FormCanvas methodsFor: 'drawing' stamp: 'di 6/26/1998 15:09'!fillColor: c	"Note: This always fills, even if the color is transparent."	port combinationRule: Form over.	port fillRect: form boundingBox color: (self drawColor: c) offset: 0@0.! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 6/26/1998 11:07'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!getMenu: shiftPressed	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpAt: evt cursorPoint event: evt].! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'di 6/26/1998 11:05'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollController methodsFor: 'control defaults' stamp: 'di 6/26/1998 13:11'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's menu."	| menu sel |	menu _ view getMenu: shiftKeyState.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			self controlTerminate.			model perform: sel orSendTo: self.			self controlInitialize].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/26/1998 10:04'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectionInterval isEmpty ifTrue: [self selectWord].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:14'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:13'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:29'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableListMorph methodsFor: 'events' stamp: 'di 6/26/1998 13:33'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 6/26/1998 11:09'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/26/1998 15:04'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2].		cpHere y >= self bottom			ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]].	selRect _ transform invertRect: rectToTest.	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:51'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:46'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self changed: #contents! !!MessageSet methodsFor: 'contents' stamp: 'di 6/26/1998 09:03'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	^ true! !!WorldMorph methodsFor: 'sensing' stamp: 'di 6/26/1998 12:24'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	| c root |	(self bounds containsPoint: aPoint)		ifFalse: [^ Color black].	c _ FormCanvas extent: 1@1 depth: Display depth.	c _ c copyOrigin: aPoint negated clipRect: ((0@0) extent: 1@1).	c fillColor: color.	root _ aMorph root.	submorphs reverseDo: [:m |		m == root ifTrue: [			(m morphsAt: aPoint) reverseDo: [:subM |				subM == aMorph ifTrue: [^ c form colorAt: 0@0].				subM drawOn: c]].		m fullDrawOn: c].	hands reverseDo: [:h |		h submorphsReverseDo: [:m |			m == root ifTrue: [				(m morphsAt: aPoint) reverseDo: [:subM |					subM == aMorph ifTrue: [^ c form colorAt: 0@0].					subM drawOn: c]].			m fullDrawOn: c]].	^ c form colorAt: 0@0! !Model removeSelector: #doMenuItem:paneID:from:!PluggableButtonView removeSelector: #getMenu!PluggableListView removeSelector: #getMenu!PluggableTextView removeSelector: #getMenuShifted!PluggableTextView removeSelector: #getMenu!ScrollPane removeSelector: #getMenu!ScrollPane removeSelector: #yellowButtonActivity!Browser removeSelector: #unshiftedYellowButtonActivity!Browser removeSelector: #shiftedYellowButtonActivity!ChangeSorter removeSelector: #unshiftedYellowButtonActivity!ChangeSorter removeSelector: #shiftedYellowButtonActivity!Debugger removeSelector: #unshiftedYellowButtonActivity!Debugger removeSelector: #shiftedYellowButtonActivity!TranscriptStream removeSelector: #doMenuItem:paneID:from:!