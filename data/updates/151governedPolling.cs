'From Squeak 2.1 of June 30, 1998 on 13 July 1998 at 6:47:30 am'!"Change Set:		governedPollingDate:			12 July 1998Author:			Lex SpoonThis changeset introduces some delays into central UI loops, as suggested by John Maloney on the mailing list.  With these changes, the  (hopefully) most frequently encountered UI loops are only allowed to execute once every 10 milliseconds (ie, no more than 100 updates per second).  The aim is to keep the UI from consuming 100% of the CPU if the screen is already updating faster than a human can register.Specifically, in Morphic, existing code already calls MorphWorld>>doOneCycle whenever it is spinning awaiting input.  So an update to that one method is sufficient for all of Morphic--any change it didn't work on, would be a case where the Morphic world (ironically) froze entirely in place.For MVC, there isn't a central place that gets called in every UI loop; instead there are many scattered tight loops that spin on their own concerns without giving access to the rest of the system.  This changeset catches five cases, which seems to cover most of the cases where no mouse button is being pressed.  On the on the other hand, holding the mouse down anwhere still causes the CPU to climb back up to 100% usage until it is released."!Object subclass: #Controller	instanceVariableNames: 'model view sensor lastActivityTime '	classVariableNames: 'MinActivityLapse '	poolDictionaries: ''	category: 'Interface-Framework'!PasteUpMorph subclass: #WorldMorph	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime playerList lastCycleTime '	classVariableNames: 'DisableDeferredUpdates MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Kernel'!!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/13/1998 00:48'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!initialize	"Controller initialize"	self MinActivityLapse: 10.! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side _ #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:42'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]. ].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/12/1998 08:21'!doOneCycle	self interCyclePause.	self doOneCycleNow.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/13/1998 00:50'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	lastCycleTime _ Time millisecondClockValue.	"process user input events"	hands do: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/13/1998 00:45'!interCyclePause	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	MinCycleLapse ifNotNil: [		lastCycleTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastCycleTime + MinCycleLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinCycleLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].! !!WorldMorph class methodsFor: 'all' stamp: 'ls 7/13/1998 00:44'!MinCycleLapse: milliseconds	"set the minimum amount of time that may transpire between two calls to doOneCycle"	MinCycleLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!WorldMorph class methodsFor: 'all' stamp: 'ls 7/13/1998 00:44'!initialize	"WorldMorph initialize"	self MinCycleLapse: 10.! !Controller initialize!WorldMorph initialize!