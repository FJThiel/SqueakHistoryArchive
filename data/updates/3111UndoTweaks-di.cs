'From Squeak2.9alpha of 12 June 2000 [latest update: #3168] on 12 December 2000 at 6:45:03 pm'!"Change Set:		CipherPanelFixDate:			12 December 2000Author:			Dan IngallsPurges undo history at save/quit (and says so in the preference help)	-- this makes use of infinite undo a reasonable option.Makes the existing purge of history more complete	-- it used to leave one command in every project.Offers to purge history prior to computing 'space left'.Fixes two places where failed drops of a morph left an undo record in its properties.Supports selective purge of undo records.Implements undo for FreeCell as a multiple-undo test case.Trims undo overhead for SameGame from 34k per command to 1.5k per command."!!Object methodsFor: 'undo' stamp: 'di 12/12/2000 15:01'!purgeAllCommands	"Purge all commands for this object"	Preferences useUndo ifFalse: [^ self]. "get out quickly"	self commandHistory purgeAllCommandsSuchThat: [:cmd | cmd undoTarget == self].! !!Command methodsFor: 'private' stamp: 'di 12/12/2000 12:36'!undoTarget	^ undoTarget! !!CommandHistory methodsFor: 'command history' stamp: 'di 12/12/2000 13:46'!resetCommandHistory    "CommandHistory allInstancesDo: [:ch | ch resetCommandHistory]"	"Clear out the command history so that no commands are held"	lastCommand _ nil.	history _ OrderedCollection new.! !!CommandHistory methodsFor: 'called by programmer' stamp: 'di 12/12/2000 13:08'!purgeAllCommandsSuchThat: cmdBlock	"Remove a bunch of commands, as in [:cmd | cmd undoTarget == zort]"	Preferences useUndo ifFalse: [^ self].	history _ history reject: cmdBlock.	history isEmpty		ifTrue: [lastCommand _ nil]		ifFalse: [lastCommand _ history last]! !!CommandHistory methodsFor: 'called by programmer' stamp: 'di 12/12/2000 10:16'!rememberCommand: aCommand	"Make the supplied command be the 'LastCommand', and mark it 'done'"	| currentCommandIndex |	Preferences useUndo ifFalse: [^ self].  "Command initialize"	Preferences infiniteUndo ifTrue:		[currentCommandIndex _ history indexOf: lastCommand.		((currentCommandIndex < history size) and: [Preferences preserveCommandExcursions]) ifTrue:			[excursions add: (history copyFrom: (currentCommandIndex to: history size)).			history _ history copyFrom: 1 to: currentCommandIndex].		history addLast: aCommand].	lastCommand _ aCommand.	lastCommand phase: #done.! !!CommandHistory class methodsFor: 'system startup' stamp: 'di 12/12/2000 13:41'!initialize    "CommandHistory initialize"	Smalltalk addToShutDownList: self.! !!CommandHistory class methodsFor: 'system startup' stamp: 'di 12/12/2000 13:48'!resetAllHistory	CommandHistory allInstancesDo: [:c | c resetCommandHistory].! !!CommandHistory class methodsFor: 'system startup' stamp: 'di 12/12/2000 13:48'!shutDown: aboutToQuit	aboutToQuit ifTrue: [self resetAllHistory].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:35'!rejectDropMorphEvent: evt	"The receiver has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is whisked to the Trash"	self removeProperty: #undoGrabCommand.	(self formerOwner notNil and: [self formerOwner isPartsBin not]) ifTrue:		[^ self slideBackToFormerSituation: evt].	self formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ self vanishAfterSlidingTo: self formerPosition event: evt].			self slideToTrash: evt! !!Morph methodsFor: 'events-processing' stamp: 'di 12/12/2000 14:39'!handleDropMorph: anEvent	"Handle a dropping morph."	| aMorph localPt |	aMorph _ anEvent contents.	"Do a symmetric check if both morphs like each other"	((self wantsDroppedMorph: aMorph event: anEvent)	"I want her"		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"		ifFalse: [aMorph removeProperty: #undoGrabCommand.				^ self].	anEvent wasHandled: true.	"Transform the morph into the receiver's coordinate frame. This is currently incomplete since it only takes the offset into account where it really should take the entire transform."	localPt _ (self transformedFrom: anEvent hand world) "full transform down"				globalPointToLocal: aMorph referencePosition.	aMorph referencePosition: localPt.	self acceptDroppingMorph: aMorph event: anEvent.	aMorph justDroppedInto: self event: anEvent.! !!FreeCell methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ autoMoveRecursionCount > 0! !!FreeCellBoard methodsFor: 'initialization' stamp: 'di 12/12/2000 15:02'!resetBoard	self purgeAllCommands.	self resetFreeCells;		resetHomeCells;		resetStacks;		changed.! !!FreeCellBoard methodsFor: 'private' stamp: 'di 12/12/2000 13:09'!visiblyMove: aCard to: aCell	| p1 p2 nSteps |	self inAutoMove ifFalse: [self captureStateBeforeGrab].	owner owner addMorphFront: aCard.	p1 _ aCard position.	p2 _ aCell position.	nSteps _ 10.	1 to: nSteps-1 do: "Note final step happens with actual drop"		[:i | aCard position: ((p2*i) + (p1*(nSteps-i))) // nSteps.		self world displayWorld].	aCell acceptDroppingMorph: aCard event: nil! !!FreeCellBoard methodsFor: 'actions' stamp: 'di 12/12/2000 13:08'!inAutoMove	"Return true if an automove sequence is in progress"	^ owner inAutoMove! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:54'!captureStateBeforeGrab	self removeProperty: #stateBeforeGrab.	self setProperty: #stateBeforeGrab toValue: self capturedState! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 11:50'!capturedState	self valueOfProperty: #stateBeforeGrab ifPresentDo: [:st | ^ st].	^ {	freeCells collect: [:deck | deck submorphs].		homeCells collect: [:deck | deck submorphs].		stacks collect: [:deck | deck submorphs] }! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 12:14'!rememberUndoableAction: aBlock named: caption	self inAutoMove ifTrue: [^ aBlock value].	^ super rememberUndoableAction: aBlock named: caption! !!FreeCellBoard methodsFor: 'undo' stamp: 'di 12/12/2000 08:12'!undoFromCapturedState: st	freeCells with: st first do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	homeCells with: st second do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs].	stacks with: st third do: [:deck :morphs | deck removeAllMorphs; addAllMorphs: morphs]! !!OrderedCollection methodsFor: 'copying' stamp: 'di 12/12/2000 10:15'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection _ self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection addLast: (self at: index)].	^ targetCollection! !!PlayingCardDeck methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 13:13'!acceptDroppingMorph: aMorph event: evt	target rememberUndoableAction:			[target inAutoMove ifFalse: [target removeProperty: #stateBeforeGrab].			self addMorph: aMorph.			aMorph hasSubmorphs ifTrue:				["Just dropped a sub-deck of cards"				aMorph submorphs reverseDo: [:m | self addMorphFront: m]].			(target ~~ nil and: [cardDroppedSelector ~~ nil])				ifTrue: [target perform: cardDroppedSelector]]		named: 'move card'! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 11:47'!aboutToBeGrabbedBy: aHand	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,	then move them from the deck to being submorphs of me"	| i |	super aboutToBeGrabbedBy: aHand.	self removeProperty: #undoGrabCommand.  "So it won't interfere with overall move"	self board captureStateBeforeGrab.	i _ owner submorphs indexOf: self ifAbsent: [^ self].	i = 1 ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: i-1) do:		[:m | m class = self class ifTrue: [self addMorphBack: m]].! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'di 12/12/2000 14:52'!slideBackToFormerSituation: evt	super slideBackToFormerSituation: evt.	self board removeProperty: #stateBeforeGrab.	self hasSubmorphs ifTrue:		["Just cancelled a drop of multiple cards -- have to unload submorphs"		self submorphs reverseDo: [:m | owner addMorphFront: m]].! !!Preferences class methodsFor: 'help' stamp: 'di 12/12/2000 13:32'!helpMsgsAdditiongeneralinfiniteUndo	^ #((infiniteUndo 'if true, then where supported you will be able to roll back to prior states via repeated uses of undo.  Undo history will be purged at save/quit' ) )! !!SameGameBoard methodsFor: 'initialization' stamp: 'di 12/12/2000 15:03'!resetBoard	Collection initialize.  "randomize"	selection _ nil.	self purgeAllCommands.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom].! !!SameGameBoard methodsFor: 'private' stamp: 'di 12/12/2000 18:44'!capturedState	"Note the state stored in the second element is an array of associations	from submorph index to a shallowCopy of the morph, but only for those	morphs that change.  Therefore the capturedState record *first* delivers	all the morphs, and *then* computes the difference and stores this back.	In the end, both undo and redo records follow this format."	| prior state oldMorphs priorChanges newChanges |	(prior _ self valueOfProperty: #priorState) == nil		ifTrue: [state _ {self shallowCopy.  "selection, etc."						self submorphs collect: [:m | m shallowCopy].  "state of all tiles"						owner scoreDisplay flash.  "score display"						owner scoreDisplay value }.				self setProperty: #priorState toValue: state.				^ state].	oldMorphs _ prior second.	priorChanges _ OrderedCollection new.	newChanges _ OrderedCollection new.	1 to: oldMorphs size do: [:i |		(oldMorphs at: i) color = (submorphs at: i) color ifFalse:			[priorChanges addLast: i -> (oldMorphs at: i).			newChanges addLast: i -> (submorphs at: i) shallowCopy]].	self removeProperty: #priorState.	prior at: 2 put: priorChanges asArray.  "Store back into undo state.2"	^ {	self shallowCopy.  "selection, etc."		newChanges asArray.  "state of tiles that changed"		owner scoreDisplay flash.  "score display"		owner scoreDisplay value }! !!SameGameBoard methodsFor: 'private' stamp: 'di 12/12/2000 16:44'!undoFromCapturedState: st 	self copyFrom: st first.	st second do: [:assn | (submorphs at: assn key) copyFrom: assn value].	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil].	owner scoreDisplay flash: st third.  "score display"	owner scoreDisplay value: st fourth.	self changed.! !!ScreenController methodsFor: 'menu messages' stamp: 'di 12/12/2000 13:55'!garbageCollect	"Do a garbage collection, and report results to the user."	| cc |	Smalltalk at: #Command ifPresent:		[:cmdClass |		(cc _ cmdClass instanceCount) > 0 ifTrue:			[(self confirm: 'There are ' , cc printString , ' undo records in your system.would you like to purge them prior to measuring space left?')				ifTrue: [CommandHistory resetAllHistory]]].	self inform: (Smalltalk bytesLeft asStringWithCommas, ' bytes available').! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 12/12/2000 13:36'!send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument	"Send the message #startUp: or #shutDown: to each class named in the list.	The argument indicates if the system is about to quit (for #shutDown:) or if	the image is resuming (for #startUp:).	If any name cannot be found, then remove it from the list."	| removals class |	removals _ OrderedCollection new.	startUpOrShutDownList do:		[:name |		class _ self at: name ifAbsent: [nil].		class == nil			ifTrue: [removals add: name]			ifFalse: [class perform: startUpOrShutDown with: argument]].	"Remove any obsolete entries, but after the iteration"	startUpOrShutDownList removeAll: removals! !CommandHistory initialize!