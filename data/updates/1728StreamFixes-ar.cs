'From Squeak2.6 of 13 October 1999 [latest update: #1727] on 23 December 1999 at 4:14:06 pm'!"Change Set:		StreamFixes-arDate:			23 December 1999Author:			Andreas RaabThis change set unifies several stream methods by definining #nextInto: #nextInto:startingAt: #next:into: #next:into:startingAt: in class PositionableStream. It also cleans up the use of #nextInto: for word sized objects by introducing #nextWordsInto:." !!Bitmap methodsFor: 'initialize-release' stamp: 'ar 12/23/1999 14:35'!fromByteStream: aStream 	"Initialize the array of bits by reading integers from the argument, 	aStream."	aStream nextWordsInto: self! !!Bitmap class methodsFor: 'instance creation' stamp: 'ar 12/23/1999 14:35'!newFromStream: s	| len |	s next = 16r80 ifTrue:		["New compressed format"		len _ self decodeIntFrom: s.		^ Bitmap decompressFromByteArray: (s nextInto: (ByteArray new: len))].	s skip: -1.	len _ s nextInt32.	len <= 0		ifTrue: ["Old compressed format"				^ (self new: len negated) readCompressedFrom: s]		ifFalse: ["Old raw data format"				^ s nextWordsInto: (self new: len)]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 12/23/1999 14:35'!readFromFile	"Read in a simple segment.  Use folder of this image, even if remembered as previous location of this image"	| ff realName |	realName _ self class folder, FileDirectory slash, self localName.	ff _ FileStream oldFileNamed: realName.	segment _ ff nextWordsInto: (WordArray new: ff size//4).	ff close.	state _ #active! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:58'!next: n into: aCollection	"Read n objects into the given collection.	Return aCollection or a partial copy if less than	n elements have been read."	^self next: n into: aCollection startingAt: 1! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:54'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| obj |	0 to: n-1 do:[:i|		(obj _ self next) == nil ifTrue:[^aCollection copyFrom: 1 to: startIndex+i-1].		aCollection at: startIndex+i put: obj].	^aCollection! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:53'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:59'!nextInto: aCollection startingAt: startIndex	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex.! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:59'!nextWordsInto: aBitmap 	"Fill the word based buffer from my collection"	(collection class isBytes) ifTrue:		[1 to: aBitmap size do:			[:index | aBitmap at: index put: (self nextNumber: 4)].		^ aBitmap].	^self next: aBitmap size into: aBitmap startingAt: 1.! !!ReadStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:01'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| max |	max _ (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position _ position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 12/23/1999 15:02'!next: n into: aString startingAt: startIndex	"Read n bytes into the given string.	Return aString or a partial copy if less than	n elements have been read."	| count |	count _ self primRead: fileID into: aString				startingAt: startIndex count: n.	count = n		ifTrue:[^aString]		ifFalse:[^aString copyFrom: 1 to: startIndex+count-1]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 12/23/1999 14:59'!nextWordsInto: aBitmap	"Note: The file primitives automatically adjust for word based objects."	^self next: aBitmap size into: aBitmap startingAt: 1.! !!WordArray class methodsFor: 'as yet unclassified' stamp: 'ar 12/23/1999 14:34'!newFromStream: s	| len |	s next = 16r80 ifTrue:		["A compressed format.  Could copy what BitMap does, or use a 		special sound compression format.  Callers normally compress their own way."		^ self error: 'not implemented'].	s skip: -1.	len _ s nextInt32.	^ s nextWordsInto: (self new: len)! !StandardFileStream removeSelector: #nextInto:!StandardFileStream removeSelector: #next:into:!