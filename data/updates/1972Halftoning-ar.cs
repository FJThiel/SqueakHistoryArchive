'From Squeak2.8alpha of 16 February 2000 [latest update: #1971] on 24 March 2000 at 1:38:18 am'!"Change Set:		Halftoning-arDate:			24 March 2000Author:			Andreas RaabUse dithering when displaying colors in 8 bit depth."!!Color methodsFor: 'conversions' stamp: 'ar 3/24/2000 01:33'!balancedPatternForDepth: depth	"A generalization of bitPatternForDepth: as it exists.  Generates a 2x2 stipple of color.	The topLeft and bottomRight pixel are closest approx to this color"	| pv1 pv2 mask1 mask2 pv3 c |	(depth == cachedDepth and:[cachedBitPattern size = 2]) ifTrue: [^ cachedBitPattern].	(depth between: 4 and: 16) ifFalse: [^ self bitPatternForDepth: depth].	cachedDepth _ depth.	pv1 _ self pixelValueForDepth: depth."	Subtract error due to pv1 to get pv2.	pv2 _ (self - (err1 _ (Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	Subtract error due to 2 pv1's and pv2 to get pv3.	pv3 _ (self - err1 - err1 - ((Color colorFromPixelValue: pv2 depth: depth) - self))						pixelValueForDepth: depth."	"Above two statements computed faster by the following..."	pv2 _ (c _ self - ((Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	pv3 _ (c + (c - (Color colorFromPixelValue: pv2 depth: depth)))						pixelValueForDepth: depth.	"Return to a 2-word bitmap that encodes a 2x2 stipple of the given pixelValues."	mask1 _ (#(- - -				16r01010101 - - -			"replicates every other 4 bits"			16r00010001 - - - - - - -	"replicates every other 8 bits"			16r00000001) at: depth).	"replicates every other 16 bits"	mask2 _ (#(- - -				16r10101010 - - -			"replicates the other 4 bits"			16r01000100 - - - - - - -	"replicates the other 8 bits"			16r00010000) at: depth).	"replicates the other 16 bits"	^ Bitmap with: (mask1*pv1) + (mask2*pv2) with: (mask1*pv3) + (mask2*pv1)! !!FormCanvas methodsFor: 'private' stamp: 'ar 3/24/2000 01:35'!setClearColor: aColor	"Install a new clear color - e.g., a color is used for clearing the background"	| clearColor |	clearColor _ aColor ifNil:[Color transparent].	clearColor isColor ifFalse:[		(clearColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: clearColor; combinationRule: Form over].	"Okay, so clearColor really *is* a color"	port sourceForm: nil.	port combinationRule: Form over.	port fillPattern: clearColor.	self depth = 8 ifTrue:[		"Use a stipple pattern"		port fillColor: (clearColor balancedPatternForDepth: 8)].! !!FormCanvas methodsFor: 'private' stamp: 'ar 3/24/2000 01:31'!setFillColor: aColor	"Install a new color used for filling."	| screen patternWord fillColor |	fillColor _ self shadowColor ifNil:[aColor].	fillColor ifNil:[fillColor _ Color transparent].	fillColor isColor ifFalse:[		(fillColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: fillColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse:[		port combinationRule: Form over.		port fillPattern: fillColor.		self depth = 8 ifTrue:[			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (fillColor balancedPatternForDepth: 8)].		^self].	"fillColor is some translucent color"	self depth > 8 ifTrue:[		"We can represent actual transparency"		port fillPattern: fillColor.		self depth = 16			ifTrue:[port alphaBits: fillColor privateAlpha; combinationRule: 30]			ifFalse:[port combinationRule: Form blend].		^self].	"Less than 16bit depth -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ fillColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!FormCanvas methodsFor: 'private' stamp: 'ar 3/24/2000 01:35'!setPaintColor: aColor	"Install a new color used for filling."	| paintColor screen patternWord |	paintColor _ self shadowColor ifNil:[aColor].	paintColor ifNil:[paintColor _ Color transparent].	paintColor isColor ifFalse:[		(paintColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: paintColor; combinationRule: Form paint].	"Okay, so paintColor really *is* a color"	port sourceForm: nil.	(paintColor isTranslucent) ifFalse:[		port fillPattern: paintColor.		port combinationRule: Form paint.		self depth = 8 ifTrue:[			port fillColor: (paintColor balancedPatternForDepth: 8)]].	self depth < 16 ifTrue:[		screen _ Color translucentMaskFor: paintColor alpha depth: self depth.		patternWord _ paintColor pixelWordForDepth: self depth.		port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).		^port combinationRule: Form paint].	port fillPattern: paintColor.	self depth = 16		ifTrue:[port alphaBits: paintColor privateAlpha; combinationRule: 31]		ifFalse:[port combinationRule: Form blend].! !