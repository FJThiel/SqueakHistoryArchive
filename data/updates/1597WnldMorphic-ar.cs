'From Squeak2.6 of 13 October 1999 [latest update: #1595] on 8 November 1999 at 5:16:22 pm'!"Change Set:		WnldMorphic-arDate:			8 November 1999Author:			Andreas RaabThis change set makes 3D objects behave very much like any other morph:* get halos on 3D objects	- Cmd-Clicking on an object will cycle you through the 3D hierarchy* move and resize 3D objects using halo handles	- Shift-Move and Shift-Resize will constrain the modifications to x/y	[Side note: Shift-Move is currently unimplemented]	[Future work: rotation, duplication, picking up 3D guys etc]* change the color using the color picker	- choose 'change color' from the red halo menu* drag and drop any morph onto a 3D object as texture	- choose 'open to drag and drop' from the WonderlandCameraMorph	- drop the morph onto the object	- extract the texture/morph by selecting the gray halo to the right* automatically adjust objects to the texture aspect ratio	- select 'auto adjust to texture' from the red halo of a 3D object	- drop the texture/morph onto the object	- WARNING: The object will be adjusted in *local* x/y coordinates only* interact with morphs representing textures	- turn on 'enable active texture' from the red halo menu of a 3D object	- drop a morph onto it	- click and do whatever you like in 3D	[Fun demo: From an empty Wonderland workspace do		w makePlaneNamed: 'plane'.		- Turn on 'open to drag and drop' in the camera morph		- Turn on 'auto adjust texture' for the plane.		- Turn on 'enable active textures' for the plane		- Turn on #allowSysWindowEmbedding in the preferences		- Drop a browser onto the plane		- Go programming ;-))))]* define local viewpoints	- drive the camera to the appropriate location	- choose 'set user point of view' from the red halo menu* use local viewpoints	- turn on 'enable active texture' [must be set for keeping consistent default behavior]	- shift-click on the object will send you to the user defined POVThe morphic like behavior is implement by a set of wrappers dynamically created for the 3D objects whenever the user Cmd-Clicks on a camera morph. The wrappers basically translate standard morphic behavior into appropriate behavior for 3D actors.Note that this change set includes some really dirty hacks. These are necessary for making the event dispatch work - since Morphs are too stupid to figure out where an event should go everything must be done by a hand and this requires some ugly hacks. The same is true for stepping morphs. Since a world does only step morphs that have a valid owner chain several hacks are necessary to make this work if the morph is in fact in a 3D world (where it could even be multiply referenced).Here are a two methods to look for in case something breaks (mainly a reminder for myself):* WonderlandActor>>dispatchEvent:using:* WonderlandCameraMorph>>acceptDroppingMorph:event:[Side note: We *must* fix event dispatching, halo handling and stepping at some point. The idea that some external object (e.g., HaloMorph or HandMorph) can completely understand who might want which behavior at any given time is just ridiculous (most of these methods should be made a responsibility of Morph and are trivial to implement right there). For now, I am either living with hacks (see above) or with a duplication of many methods (for halo behavior), both of which shouldn't be necessary]ALSO: Since the change set deals with halo handling several methods in Morph and HandMorph have been changed (mainly to pass the generating event into the method).ALSO: This change set introduces 2D bounds recording of 3D Wonderland actors during rendering. This information is stored in the camera so that one can get the 2D extent of an actor with respect to any given camera in the scene. Rendering any meshes now requires to return the 2D extent or nil if the mesh is not visible (collecting the extents is done automatically by the actors).ALSO: This change set removes two now outdated classes from the system (WonderlandTextureMorph and WonderlandHandMorph). This is done in a subtle way to transform the existing textures into something that can still be used. Some small fixes may be necessary (such as re-initializing the default actions of the object the old texture was mapped on) and enabling the active textures from a halo (no big deal). Because of the transformation of morphs it is important to NEVER FILE OUT THIS CHANGE SET FOR TRANSMITTING. The recorded changes are inappropriate for transmission (e.g., the fileOut will contain a class removal before the cleanup has been done). Only transmit the change set as it has come in (e.g., use the file from the server directly)."!B3DRenderEngine class removeSelector: #preferOSMesa!B3DRenderEngine class removeSelector: #preferOSMesa:!B3DEnginePart subclass: #B3DRenderEngine	instanceVariableNames: 'vertexBuffer transformer shader clipper rasterizer properties '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!B3DEnginePart subclass: #B3DVertexRasterizer	instanceVariableNames: 'viewport dirtyRect texture textureStack vbBounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Engine'!HandMorph subclass: #FakeHandMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Morphs'!Hierarchical subclass: #WonderlandActor	instanceVariableNames: 'myName myWonderland myMesh myTexture myMaterial myColor composite scaleMatrix hidden firstClass myReactions myProperties '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Objects'!WonderlandActor subclass: #WonderlandCamera	instanceVariableNames: 'perspective viewMatrix myMorph drawSceneBackground bounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Objects'!Morph subclass: #WonderlandWrapperMorph	instanceVariableNames: 'myWonderland myActor '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Morphs'!!B3DIndexedQuadMesh methodsFor: 'displaying' stamp: 'ar 11/7/1999 18:35'!renderOn: aRenderer	^aRenderer		drawIndexedQuads: faces			vertices: vertices			normals: vtxNormals			colors: vtxColors			texCoords: vtxTexCoords.! !!B3DIndexedTriangleMesh methodsFor: 'displaying' stamp: 'ar 11/7/1999 18:35'!renderOn: aRenderer	self hasVertexColors ifTrue:[		aRenderer trackAmbientColor: true.		aRenderer trackDiffuseColor: true].	^aRenderer		drawIndexedTriangles: faces			vertices: vertices			normals: vtxNormals			colors: vtxColors			texCoords: vtxTexCoords.! !!B3DPrimitiveRasterizerData methodsFor: 'accessing' stamp: 'ar 11/7/1999 18:09'!integerAt: index	"Return the integer at the given index"	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!B3DRenderEngine methodsFor: 'draw primitives' stamp: 'ar 11/7/1999 18:12'!drawPolygonAfter: aBlock	vertexBuffer reset.	vertexBuffer primitive: 3.	aBlock value.	^self renderPrimitive.! !!B3DRenderEngine methodsFor: 'draw primitives' stamp: 'ar 11/7/1999 18:15'!drawPolygonMesh: aB3DPolygonMesh	"Draw a generic polygon mesh"	| hasVtxNormals hasTexCoords hasVtxColors bounds box |	box _ nil.	aB3DPolygonMesh polygonsDo:[:poly|		hasVtxNormals _ poly hasVertexNormals.		hasTexCoords _ poly hasTextureCoords.		hasVtxColors _ poly hasVertexColors.		"Set the normal of the polygon if we don't have normals per vertex"		hasVtxNormals 			ifFalse:[self normal: poly normal].		bounds _ self drawPolygonAfter:[			poly verticesDo:[:vtx|				hasVtxColors ifTrue:[self color: (poly colorOfVertex: vtx)].				hasVtxNormals ifTrue:[self normal: (poly normalOfVertex: vtx)].				hasTexCoords ifTrue:[self texCoord: (poly texCoordOfVertex: vtx)].				self vertex: vtx.			].		].		box == nil ifTrue:[box _ bounds] ifFalse:[box _ box quickMerge: bounds].	].	^box! !!B3DRenderEngine methodsFor: 'private-rendering' stamp: 'ar 11/7/1999 18:11'!renderPrimitive	"This is the main rendering loop for all operations"	| visible |	"Step 1: Check if the mesh is visible at all"	visible _ self privateVisibleVB: vertexBuffer.	visible == false ifTrue:[^nil].	"Step 2: Transform vertices, normals, texture coords of the mesh"	self privateTransformVB: vertexBuffer.	"Step 3: Light the vertices of the mesh."	self privateNeedsShadingVB		ifTrue:[self privateShadeVB: vertexBuffer].	"Step 4: Clip the mesh if necessary"	(self privateNeedsClipVB: visible)		ifTrue:[visible _ self privateClipVB: vertexBuffer].	visible == false ifTrue:[^nil].	"Step 5: Rasterize the mesh"	^self privateRasterizeVB: vertexBuffer.! !!B3DRenderEngine methodsFor: 'indexed primitives' stamp: 'ar 11/7/1999 18:12'!drawIndexedLines: indexArray vertices: vertexArray normals: normalArray colors: colorArray texCoords: texCoordArray	vertexBuffer reset.	vertexBuffer primitive: 4.	vertexBuffer 		loadIndexed: indexArray		vertices: vertexArray 		normals: normalArray 		colors: colorArray 		texCoords: texCoordArray.	^self renderPrimitive.! !!B3DRenderEngine methodsFor: 'indexed primitives' stamp: 'ar 11/7/1999 18:12'!drawIndexedQuads: indexArray vertices: vertexArray normals: normalArray colors: colorArray texCoords: texCoordArray	vertexBuffer reset.	vertexBuffer primitive: 6.	vertexBuffer 		loadIndexed: indexArray		vertices: vertexArray 		normals: normalArray 		colors: colorArray 		texCoords: texCoordArray.	^self renderPrimitive.! !!B3DRenderEngine methodsFor: 'indexed primitives' stamp: 'ar 11/7/1999 18:12'!drawIndexedTriangles: indexArray vertices: vertexArray normals: normalArray colors: colorArray texCoords: texCoordArray	vertexBuffer reset.	vertexBuffer primitive: 5.	vertexBuffer 		loadIndexed: indexArray		vertices: vertexArray 		normals: normalArray 		colors: colorArray 		texCoords: texCoordArray.	^self renderPrimitive.! !!B3DRenderEngine methodsFor: 'properties' stamp: 'ar 11/7/1999 18:23'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	self valueOfProperty: propName ifAbsent:[^false].	^true! !!B3DRenderEngine methodsFor: 'properties' stamp: 'ar 11/7/1999 18:25'!properties	^properties ifNil:[properties _ IdentityDictionary new].! !!B3DRenderEngine methodsFor: 'properties' stamp: 'ar 11/7/1999 18:23'!removeProperty: propName	self valueOfProperty: propName ifAbsent:[^self].	self properties removeKey: propName.! !!B3DRenderEngine methodsFor: 'properties' stamp: 'ar 11/7/1999 18:22'!setProperty: propName toValue: aValue	aValue ifNil: [^ self removeProperty: propName].	self properties at: propName put: aValue.! !!B3DRenderEngine methodsFor: 'properties' stamp: 'ar 11/7/1999 18:24'!valueOfProperty: propName	^self valueOfProperty: propName ifAbsent:[nil]! !!B3DRenderEngine methodsFor: 'properties' stamp: 'ar 11/7/1999 18:36'!valueOfProperty: propName ifAbsent: aBlock	properties == nil ifTrue: [^ aBlock value].	^properties at: propName ifAbsent: aBlock! !!B3DPickerEngine methodsFor: 'private-rendering' stamp: 'ar 11/7/1999 18:12'!renderPrimitive	"This is the main rendering loop for all operations"	| visible minVertex |	"Step 1: Check if the mesh is visible at all"	visible _ self privateVisibleVB: vertexBuffer.	visible == false ifTrue:[^nil].	"Step 2: Transform vertices, normals, texture coords of the mesh"	self privateTransformVB: vertexBuffer.	"Step 3: Clip the mesh if necessary"	visible _ self privateClipVB: vertexBuffer.	visible == false ifTrue:[^nil].	"Step 4: Collect the minimal/maximal distances for the current object."	minVertex _ self processVertexBuffer: vertexBuffer.	objects isEmpty ifFalse:[		objects last value rasterPosZ > minVertex rasterPosZ 			ifTrue:[objects last value: minVertex].	].	^nil! !!B3DSimpleMesh methodsFor: 'rendering' stamp: 'ar 11/7/1999 18:15'!renderOn: aRenderer	| box bounds |	box _ nil.	1 to: self size do:[:i|		bounds _ (self at: i) renderOn: aRenderer.		box == nil ifTrue:[box _ bounds] ifFalse:[box _ box quickMerge: bounds].	].	^box! !!B3DSimpleMeshFace methodsFor: 'rendering' stamp: 'ar 11/7/1999 18:14'!renderOn: aRenderer	^aRenderer drawPolygonAfter:[		aRenderer normal: self normal.		1 to: self size do:[:i| (self at: i) renderOn: aRenderer].	].! !!B3DVertexRasterizer methodsFor: 'processing' stamp: 'ar 11/7/1999 18:04'!processVertexBuffer: vb	vbBounds _ nil.	super processVertexBuffer: vb.	^vbBounds! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 11/7/1999 18:47'!addPrimitiveObject: vb ofSize: objSize	| obj textureIndex |	texture == nil		ifTrue:[textureIndex _ 0]		ifFalse:[textureIndex _ textures at: texture ifAbsentPut:[textures size+1]].	obj _ B3DPrimitiveRasterizerData new: objSize.	self primAddObject: obj		primitive: vb primitive		vertexArray: vb vertexArray		size: vb vertexCount		indexArray: vb indexArray		size: vb indexCount		viewport: viewport		textureIndex: textureIndex.	primObjects nextPut: obj.	"AAARRRRGGGGGHHHH - we should do this differently!!!!!!!!"	vbBounds _ (obj integerAt: 9) @ (obj integerAt: 11) corner: (obj integerAt: 10) @ (obj integerAt: 12).! !!B3DPrimitiveRasterizer methodsFor: 'processing' stamp: 'ar 11/7/1999 22:25'!mainLoop	"Do the actual rasterization"	| errCode objects textureArray |	objects _ primObjects contents.	objects size = 0 ifTrue:[^self]. "Nothing to do"	textureArray _ Array new: textures size.	textures associationsDo:[:assoc| textureArray at: assoc value put: assoc key].	state initObjects: objects size.	state initTextures: textureArray size.	textureArray do:[:tex| tex unhibernate].	[errCode _ self primStartRasterizer: state objects: objects textures: textureArray.	errCode = 0] whileFalse:[		"Not yet finished"		self processErrorCode: (errCode bitAnd: 255).		state reset].	primObjects reset.	textures _ IdentityDictionary new: textures capacity.	false ifTrue:[self printSpaceUsage: objects].! !!Form methodsFor: 'converting' stamp: 'ar 11/7/1999 20:29'!asMorph	^ImageMorph new image: self! !!Form methodsFor: 'converting' stamp: 'ar 11/7/1999 20:29'!asTexture	| newForm |	newForm _ B3DTexture extent: self extent depth: 32.	(BitBlt toForm: newForm)		colorMap: (self colormapIfNeededForDepth: 32);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	newForm interpolate: false.	newForm wrap: false.	newForm envMode: 0.	^newForm! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 11/8/1999 00:08'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the receiver.	ar 11/8/1999: Moved into morph for an incredibly ugly hack in 3D worlds"	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 11/8/1999 14:39'!aboutToBeGrabbedBy: aHand	"The receiver is being grabbed by a hand.	Perform necessary adjustments (if any) and return the actual morph	that should be added to the hand."	| extentToHandToHand |	(extentToHandToHand _ self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand].	^self "Grab me"! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 11/7/1999 18:57'!addHalo	"Invoke a halo programatically (e.g., not from a meta gesture)"	^self addHalo: nil! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 11/7/1999 18:57'!addHalo: evt	| halo |	halo _ HaloMorph new bounds: self fullBoundsInWorld.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 11/7/1999 21:55'!addHalo: evt from: formerHaloOwner	"Transfer a halo from the former halo owner to the receiver"	^self addHalo: evt! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 11/8/1999 14:30'!addHandlesTo: aHaloMorph box: box	"If the receiver responded to #definesOwnHaloHandles by returning true, this message is sent to invoke the handle construction. This default implementation uses the standard halos defined in HaloMorph itself."	^aHaloMorph addHandlesTo: aHaloMorph box: box! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 11/8/1999 14:31'!definesOwnHaloHandles	"Return true if the receiver wishes to define its own halos instead of the set of default halos. If this method returns true, the receiver must implement the #addHandlesTo:box: method and define *all* halo handles manually."	^false! !!Morph methodsFor: 'change reporting' stamp: 'ar 11/7/1999 23:13'!invalidRect: damageRect	owner ifNotNil: [owner invalidRect: damageRect].	self setProperty: #textureIsDirty toValue: true. "If I am a wonderland texture"! !!Morph methodsFor: 'caching' stamp: 'ar 11/7/1999 23:16'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'."	self removeProperty: #wonderlandTexture. "We can recreate it if needed"! !!Morph methodsFor: 'texture support' stamp: 'ar 11/7/1999 23:52'!asTexture	"Represent the receiver as a Wonderland texture."	| canvas texture dirty |	dirty _ self valueOfProperty: #textureIsDirty ifAbsent:[false].	texture _ self valueOfProperty: #wonderlandTexture.	(texture == nil or:[texture extent ~= self extent]) ifTrue:[		self removeProperty: #wonderlandTexture.		texture _ nil. "Clean up for GC"		texture _ B3DTexture extent: self extent depth: 32.		texture interpolate: false.		texture wrap: false.		texture envMode: 0.		dirty _ true].	dirty ifTrue:[		canvas _ FormCanvas on: texture.		canvas translateBy: self topLeft negated			during:[:tempCanvas| self fullDrawOn: tempCanvas].		self removeProperty: #textureIsDirty.	].	self setProperty: #wonderlandTexture toValue: texture.	^ texture! !!Morph methodsFor: 'texture support' stamp: 'ar 11/7/1999 23:17'!installAsWonderlandTextureOn: anActor	"Make the receiver a texture for the given actor"	^anActor setTexturePointer: self! !!Morph methodsFor: 'texture support' stamp: 'ar 11/7/1999 23:30'!mapPrimitiveVertex: aPrimitiveVertex	"Map the given primitive vertex into 2D space."	| pt |	pt _ aPrimitiveVertex texCoordS @ aPrimitiveVertex texCoordT.	^(self extent * pt) asIntegerPoint + self position.! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/8/1999 14:40'!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	self transform: (self transformFrom: self world).	"If extracted from player and no default AA level is set use prefs"	(player notNil and:[self defaultAALevel == nil]) ifTrue:[		Preferences extractFlashInHighQuality ifTrue:[self defaultAALevel: 2].		Preferences extractFlashInHighestQuality ifTrue:[self defaultAALevel: 4].	].	^self "Grab me"! !!GradientFillMorph methodsFor: 'private' stamp: 'ar 11/8/1999 17:14'!releaseCachedState	super releaseCachedState.	colorArray _ nil! !!HaloMorph methodsFor: 'private' stamp: 'ar 11/8/1999 14:31'!addHandles	| box |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target renderedMorph fullBoundsInWorld.  "update my size"	box _ self basicBox.	target definesOwnHaloHandles		ifTrue:[target addHandlesTo: self box: box]		ifFalse:[self addHandlesTo: self box: box].	self addName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'ar 11/8/1999 14:26'!addHandlesTo: aHaloMorph box: box	| s dismissHandle lab |	s _ aHaloMorph handleSize.	aHaloMorph addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	"innerTarget colorSettable ifTrue:		[aHaloMorph addGraphicalHandle: ColorHalo at: (box topLeft + (0@14)) on: #mouseDown send: #doRecolor:with: to: self]."  "possible future"	aHaloMorph addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	dismissHandle _ aHaloMorph addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color red muchLighter		on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.	dismissHandle on: #mouseUp send: #maybeDismiss:with: to: self.	dismissHandle on: #mouseStillDown send: #setDismissColor:with: to: self.	dismissHandle addMorphBack: (lab _ StringMorph contents: 'X' font: ScriptingSystem fontForScriptorButtons).	lab position: dismissHandle position + (4 @ 0).	lab lock.	aHaloMorph addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	aHaloMorph addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(aHaloMorph addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	aHaloMorph addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[aHaloMorph addHandleAt: ((box topRight + box rightCenter) // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: self].	target balloonText ifNotNil:		[(aHaloMorph addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(aHaloMorph addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(aHaloMorph addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(aHaloMorph addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: aHaloMorph box: box.! !!HaloMorph methodsFor: 'private' stamp: 'ar 11/7/1999 18:57'!maybeDismiss: evt with: dismissHandle	"Ask hand to dismiss my target if mouse comes up in it."	(dismissHandle containsPoint: evt cursorPoint)		ifFalse:			[self delete.			target addHalo: evt]		ifTrue:			[self delete.			target dismissViaHalo]! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/8/1999 14:40'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt m |	m _ aMorph.	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	"Check if the morph will keep it's transform while grabbed"	m keepsTransform		ifTrue:[localPt _ self position]		ifFalse:[localPt _ m pointFromWorld: self position].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m _ m aboutToBeGrabbedBy: self.			m == nil ifTrue:[^self].			m position: self position + (m position - localPt).			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'halos' stamp: 'ar 11/7/1999 18:56'!addHalo: evt	argument addHalo: evt! !!HandMorph methodsFor: 'halos' stamp: 'ar 11/7/1999 18:57'!popUpHalo: evt	"Pop up a halo on the top-most unlocked morph below the hand."	self world abandonAllHalos.	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ self].	argument submorphCount > 0 ifTrue:		[(argument _ self chooseHaloSubmorphOf: argument caption: 'Who gets halo?')			ifNil: [^ self]].	self addHalo: evt.! !!HandMorph methodsFor: 'halos' stamp: 'ar 11/7/1999 21:55'!popUpHaloFromClick: evt	"Pop up a halo on the deepest unlocked morph below the hand.	However, if there are multiple possible targets, and one of them	already has a halo, then choose the next outer target.  That is,	unless we are already at the top, in which case go deepest again."	| oldTargets targets i |	oldTargets _ OrderedCollection new.	self world haloMorphs do:		[:h | oldTargets addLast: h target. h delete].	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ owner "the world" addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument addHalo: evt "sole target"].	"Multiple possible targets, choose the deepest first, but	if one already has a halo, then choose the next farther out."	targets _ argument unlockedMorphsAt: targetOffset.	targets size = 0 ifTrue: [^ argument addHalo: evt "sole target"].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	i _ targets findFirst: [:t | oldTargets includes: t].	i = 0 ifTrue: [^ targets first addHalo: evt "deepest target"].	i < targets size ifTrue: [^ (targets at: i+1) addHalo: evt from: (targets at: i) "next outertarget"].	^ targets first addHalo: evt "All the way our already; back to deepest"! !!FakeHandMorph commentStamp: '<historical>' prior: 0!I am a fake hand morph used only for figuring out event receivers.!!FakeHandMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/1999 01:20'!attachMorph: m	"This is an accidental side effect. We don't want no morphs to grab"! !!FakeHandMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/1999 01:20'!grabMorph: m	"This is an accidental side effect. We don't want no morphs to grab"! !!FakeHandMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/1999 01:40'!handleDragOver: evt	"More stuff to ignore"! !!FakeHandMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/1999 01:41'!handleMouseMove: evt	"Dispatch a mouseMove event."	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].! !!FakeHandMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/1999 01:21'!layoutChanged	"Ignored to avoid infinite recursion"! !!HandMorphForReplay methodsFor: 'halos' stamp: 'ar 11/7/1999 18:56'!addHalo: evt	| halo |	argument isNil		ifTrue: 			[halo _ HaloMorph new bounds: self fullBoundsInWorld.			self world addMorphFront: halo.			halo target: self.			halo startStepping]		ifFalse: [argument addHalo: evt]! !!PolygonMorph methodsFor: 'private' stamp: 'ar 11/8/1999 17:14'!releaseCachedState	super releaseCachedState.	filledForm _ nil.	arrowForms _ nil.	borderForm _ nil! !!ThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/7/1999 22:55'!installAsWonderlandTextureOn: anActor	"Make the receiver a texture for the given actor"	self morphRepresented installAsWonderlandTextureOn: anActor! !!UndoColorChange methodsFor: 'accessing' stamp: 'ar 11/7/1999 21:27'!getActor	^theActor! !!UndoPOVChange methodsFor: 'accessing' stamp: 'ar 11/7/1999 20:15'!getActor	^theActor! !!UndoSizeChange methodsFor: 'accessing' stamp: 'ar 11/7/1999 20:16'!getActor	^theActor! !!WonderlandActor methodsFor: 'drawing' stamp: 'ar 11/7/1999 18:46'!drawMesh: aRenderer	"Draw the mesh for this actor."	| recorder bounds |	myMaterial ifNotNil: [			aRenderer pushMaterial.			aRenderer material: myMaterial.						].	myTexture ifNotNil: [			aRenderer pushTexture.			aRenderer texture: myTexture.						].	"Note: Using myMesh>>renderOn: here prevents meshes from being picked!!"	myMesh ifNotNil: [ bounds _ myMesh renderOn: aRenderer].	myTexture ifNotNil: [ aRenderer popTexture ].	myMaterial ifNotNil: [ aRenderer popMaterial ].	"Pass the 2D extent back to the recorder (if any)"	recorder _ aRenderer valueOfProperty: #boundsRecorder.	recorder == nil ifFalse:[recorder setBounds: bounds for: self].! !!WonderlandActor methodsFor: 'drawing' stamp: 'ar 11/7/1999 18:46'!renderOn: aRenderer	"Draw the actor."	"Save the old transformation matrix"	aRenderer pushMatrix.	"Modify the matrix using our composite matrix for position and orientation"	aRenderer transformBy: composite.	"Save the new transformation matrix"	aRenderer pushMatrix.	"Modify the matrix using our scale matrix - we do this seperately to avoid scaling space"	aRenderer transformBy: scaleMatrix.	"Draw our mesh if the object is not hidden"	(hidden) ifFalse: [ self drawMesh: aRenderer ].	"Remove the scaling matrix"	aRenderer popMatrix.	"Set the default texture for our children"	myTexture ifNotNil:[aRenderer pushTexture; texture: myTexture].	"Draw our children.	Note: For correct picking it is important to use B3DRenderEngine>>render: here."	myChildren do: [:child | aRenderer render: child].	"Restore the old texture"	myTexture ifNotNil:[aRenderer popTexture].	"Restore the old matrix"	aRenderer popMatrix.! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/7/1999 18:31'!getBounds	"Return the 2D bounds of the receiver as seen by the default camera"	^self getBoundsFor: myWonderland getDefaultCamera.! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/7/1999 18:32'!getBoundsFor: aCamera	"Return the 2D bounds of the receiver as seen by the camera"	^aCamera getBoundsForActor: self! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/7/1999 18:33'!getFullBounds	"Return the 2D bounds of the receiver and its children or nil if not visible"	^self getFullBoundsFor: myWonderland getDefaultCamera.! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/7/1999 18:32'!getFullBoundsFor: aCamera	"Return the 2D bounds of the receiver and its children or nil if not visible"	| box bounds |	box _ self getBoundsFor: aCamera.	myChildren do:[:child|		bounds _ child getFullBoundsFor: aCamera.		bounds == nil ifFalse:[			box == nil ifTrue:[box _ bounds] ifFalse:[box _ box quickMerge: bounds].		].	].	^box! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/8/1999 16:54'!getGlobalPosition: aVector	"Return the global position of the given vector"	| vv cc |	vv _ B3DVector3 x: (aVector at: 1) y: (aVector at: 2) z: (aVector at: 3).	cc _ composite composeWith: scaleMatrix.	vv _ cc localPointToGlobal: vv.	^(Array with: vv x with: vv y with: vv z)! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/8/1999 16:53'!getLocalPosition: aVector	"Return the local position of the given vector"	| vv cc |	vv _ B3DVector3 x: (aVector at: 1) y: (aVector at: 2) z: (aVector at: 3).	cc _ composite composeWith: scaleMatrix.	vv _ cc inverseTransformation localPointToGlobal: vv.	^(Array with: vv x with: vv y with: vv z)! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/7/1999 22:33'!getProperty: aSymbol	^self getProperty: aSymbol ifAbsent:[nil]! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/7/1999 22:17'!getProperty: aSymbol ifAbsent: aBlock	myProperties == nil ifTrue:[^aBlock value].	^myProperties at: aSymbol ifAbsent: aBlock! !!WonderlandActor methodsFor: 'get property' stamp: 'ar 11/8/1999 13:14'!getUserPointOfView	"Return the user defined point of view for this object"	^self getProperty: #userPointOfView! !!WonderlandActor methodsFor: 'set property' stamp: 'ar 11/7/1999 22:19'!setProperty: aSymbol toValue: anObject	anObject == nil ifTrue:["Remove property"		myProperties ifNotNil:[^myProperties removeKey: aSymbol ifAbsent:[nil]]].	myProperties == nil ifTrue:[myProperties _ IdentityDictionary new].	myProperties at: aSymbol put: anObject.! !!WonderlandActor methodsFor: 'set property' stamp: 'ar 11/8/1999 13:14'!setUserPointOfView: aPOV	"Return the user defined point of view for this object"	^self setProperty: #userPointOfView toValue: aPOV! !!WonderlandActor methodsFor: 'private' stamp: 'ar 11/8/1999 01:07'!adjustToTextureIfNecessary	| texExtent texRatio myExtent myRatio |	"Adjust the receiver to the texture extent if necessary"	(self getProperty: #adjustToTexture) == true ifFalse:[^self]. "Don't adjust"	texExtent _ self getTexturePointer extent.	texRatio _ texExtent x / texExtent y.	myExtent _ self getBoundingBox extent.	myRatio _ myExtent x / myExtent y.	self resize: (Array with: texRatio / myRatio with: 1.0 with: 1.0) duration: 2! !!WonderlandActor methodsFor: 'morphic reactions' stamp: 'ar 11/8/1999 01:22'!dispatchEvent: event using: aBlock	"This method is one big and incredibly ugly hack. I hate it."	| evt hand |	evt _ event getMorphicEvent copy.	evt setCursorPoint: (myTexture mapPrimitiveVertex: event getVertex).	hand _ self getProperty: #stupidHandThatKnowsEverything.	hand == nil ifTrue:[		hand _ FakeHandMorph new.		self setProperty: #stupidHandThatKnowsEverything toValue: hand].	hand privateOwner: myTexture.	myTexture isInWorld ifFalse:[myTexture privateOwner: event getCameraMorph].	aBlock value: evt value: hand.! !!WonderlandActor methodsFor: 'morphic reactions' stamp: 'ar 11/7/1999 23:32'!morphicKeyPress: event	"Handle the given event"	| evt |	myTexture isMorph ifTrue:[		evt _ event getMorphicEvent copy.		evt setCursorPoint: (myTexture mapPrimitiveVertex: event getVertex).		myTexture keyStroke: evt].! !!WonderlandActor methodsFor: 'morphic reactions' stamp: 'ar 11/8/1999 14:09'!morphicMouseDown: event	"Handle the given event.	If a local viewpoint is defined go to this viewpoint."	| vp |	(event getMorphicEvent shiftPressed and:[(vp _ self getUserPointOfView) notNil])		ifTrue:[event getCameraMorph getCamera 					setPointOfView: vp					duration: 2					asSeenBy: self.				"Set an additional flag to avoid inbetween shift key changes"				^self setProperty: #userTransition toValue: true].	myTexture isMorph ifTrue:[		self dispatchEvent: event using:[:evt :hand| hand handleMouseDown: evt].	].! !!WonderlandActor methodsFor: 'morphic reactions' stamp: 'ar 11/8/1999 14:02'!morphicMouseMove: event	"Handle the given event"	(event getMorphicEvent shiftPressed and:[self getUserPointOfView notNil])		ifTrue:[^self]. "Reserved for navigation"	(self getProperty: #userTransition) == true ifTrue:[^true]. "Shift key went up"	myTexture isMorph ifTrue:[		self dispatchEvent: event using:[:evt :hand| hand handleMouseMove: evt].	].! !!WonderlandActor methodsFor: 'morphic reactions' stamp: 'ar 11/8/1999 14:03'!morphicMouseUp: event	"Handle the given event"	(event getMorphicEvent shiftPressed and:[self getUserPointOfView notNil])		ifTrue:[^self]. "Reserved for navigation"	(self getProperty: #userTransition) == true ifTrue:["Shift key went up"		^self setProperty: #userTransition toValue: nil].	myTexture isMorph ifTrue:[		self dispatchEvent: event using:[:evt :hand| hand handleMouseUp: evt].	].! !!WonderlandActor methodsFor: 'testing' stamp: 'ar 11/8/1999 14:00'!hasActiveTexture	"Return true if the receiver has an active texture that wants events routed directly."	^(self getProperty: #activeTexture) == true! !!WonderlandCamera methodsFor: 'rendering' stamp: 'ar 11/7/1999 18:49'!render: aRenderEngine pickingAt: aPointOrNil withPrimitiveVertex: aBoolean	"Render one frame of the Wonderland using this camera.	If aPointOrNil is not nil then pick the top most object at this point.	For picking only: If aBoolean is true return an association 	object -> B3DPrimitiveVertex; otherwise simply return the top most object.	Note: If picking, no objects are actually drawn."	| aRenderer pickedObject |	aRenderer _ aRenderEngine. "A couple of things must be set before we can pick!!"	aRenderer viewport: (myMorph bounds insetBy: 1@1).	(drawSceneBackground)		ifTrue: [ aRenderer clearViewport: (myWonderland getScene) getColorObject. ]		ifFalse: [ ].	aRenderer clearDepthBuffer.	aRenderer loadIdentity.	"Add any existing lights to the renderer for this camera"	(myWonderland getLights) do: [:light | aRenderer addLight: light ].	"Calculate our view matrix by inverting the camera's composite matrix and hand it	to the renderer - note that this will eventually have to walk up the tree"	viewMatrix _ self getMatrixToRoot.	aRenderer transformBy: viewMatrix.	aRenderer perspective: perspective.	"Initialize picking if necessary"	aPointOrNil == nil		ifTrue:[	"Record 2D bounds if not picking"				aRenderer setProperty: #boundsRecorder toValue: self.				bounds _ IdentityDictionary new: (bounds ifNil:[10] ifNotNil:[bounds size])]		ifFalse:[	"Make us a picker"				aRenderer _ aRenderer asPickerAt: aPointOrNil].	"Now render the scene"	myWonderland renderWonderland: aRenderer.	"Force the renderer to draw to the screen"	aRenderer finish.	"Fetch the picked object"	aPointOrNil ifNotNil:[		aBoolean			ifTrue:[pickedObject _ aRenderer topMostObject -> aRenderer topMostVertex]			ifFalse:[pickedObject _ aRenderer topMostObject]].	aRenderer destroy.	^pickedObject "Will be nil if not picking"! !!WonderlandCamera methodsFor: 'get property' stamp: 'ar 11/7/1999 18:34'!getBoundsForActor: anActor	"Return the 2D bounds of the actor as seen by the receiver"	bounds == nil ifTrue:[^nil].	^bounds at: anActor ifAbsent:[nil]! !!WonderlandCamera methodsFor: 'set property' stamp: 'ar 11/7/1999 18:50'!setBounds: aRectangle for: anActor	"Record the 2D bounds for the given actor during a rendering pass"	aRectangle == nil ifFalse:[bounds at: anActor put: (aRectangle intersect: myMorph bounds)].! !!WonderlandCamera methodsFor: 'debug' stamp: 'ar 11/7/1999 18:39'!debugDrawRectsOn: aCanvas	bounds == nil ifTrue:[^self].	bounds keysAndValuesDo:[:actor :rect|		aCanvas frameRectangle: rect color: Color white.	].! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 11/7/1999 18:55'!drawOn: aCanvas	aCanvas asBalloonCanvas render: self.! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/7/1999 23:27'!keyStroke: evt	"Handle a keyboard event"	| newEvent reactions |	firstPersonControls == true "For existing camera morphs"		ifTrue:[^self firstPersonKeystroke: evt].	newEvent _ self convertEvent: evt.	newEvent ifNil:[^self].	"Check for active textures"	newEvent getActor hasActiveTexture 		ifTrue:[^newEvent getActor morphicKeyPress: newEvent].	"Route to actor"	reactions _ newEvent getActor getReactionsTo: keyPress.	reactions ifNotNil:[ 		reactions do: [:aReaction | aReaction reactTo: newEvent ]].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/8/1999 13:45'!mouseDown: evt	"When the user clicks in a camera window, determine which actor the user clicked on and have that actor respond to the event"	| newEvent reactions |	newEvent _ self convertEvent: evt.	newEvent ifNil:[^self].	newEvent getActor hasActiveTexture 		ifTrue:[^newEvent getActor morphicMouseDown: newEvent].	(evt redButtonPressed)		ifTrue: [reactions _ newEvent getActor getReactionsTo: leftMouseDown.				mouseUpButton _ leftMouseUp. ]		ifFalse: [(evt yellowButtonPressed)			ifTrue: [reactions _ newEvent getActor getReactionsTo: rightMouseDown.					mouseUpButton _ rightMouseUp. ]			ifFalse: [ reactions _ nil ]].	reactions ifNotNil:[ 		reactions do: [:aReaction | aReaction reactTo: newEvent ]].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/7/1999 23:28'!mouseMove: evt	"When the user clicks in a camera window, determine which actor the user clicked on and have that actor respond to the event"	| newEvent reactions |	newEvent _ self convertEvent: evt.	newEvent ifNil:[^self].	newEvent getActor hasActiveTexture 		ifTrue:[^newEvent getActor morphicMouseMove: newEvent].	reactions _ newEvent getActor getReactionsTo: mouseMove.	reactions ifNotNil:[ 		reactions do: [:aReaction | aReaction reactTo: newEvent]].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/7/1999 23:28'!mouseUp: evt	"When the user clicks in a camera window, determine which actor the user clicked on and have that actor respond to the event"	| newEvent reactions |	newEvent _ self convertEvent: evt.	newEvent ifNil:[^self].	newEvent getActor hasActiveTexture 		ifTrue:[^newEvent getActor morphicMouseUp: newEvent].	reactions _ newEvent getActor getReactionsTo: mouseUpButton.	reactions ifNotNil:[ 		reactions do: [:aReaction | aReaction reactTo: newEvent ]].! !!WonderlandCameraMorph methodsFor: 'accessing' stamp: 'ar 11/7/1999 19:18'!getCamera	^myCamera! !!WonderlandCameraMorph methodsFor: 'wrappers' stamp: 'ar 11/7/1999 21:57'!addHalo: evt	"Add a halo to an object"	| actor wrapper root |	self removeAllWrappers. "Get rid of them"	evt == nil ifTrue:[^super addHalo: evt].	actor _ myCamera pickAt: evt cursorPoint.	actor == nil ifTrue:[^super addHalo: evt]. "Nothing hit"	wrapper _ WonderlandWrapperMorph on: actor.	root _ wrapper createHierarchy.	root computeFullBounds: self.	self addMorphFront: root.	wrapper addHalo. "Add programatically"! !!WonderlandCameraMorph methodsFor: 'wrappers' stamp: 'ar 11/7/1999 21:57'!addHalo: evt from: formerHaloOwner	"Special case if the formerHaloOwner was a wrapper within the receiver"	self removeAllWrappers. "Get rid of them"	(formerHaloOwner isKindOf: WonderlandWrapperMorph)		ifTrue:[^super addHalo: evt] "Add a halo to me"		ifFalse:[^self addHalo: evt] "Add a halo from pick"! !!WonderlandCameraMorph methodsFor: 'wrappers' stamp: 'ar 11/7/1999 22:00'!removeAllWrappers	submorphs do:[:m|		(m isKindOf: WonderlandWrapperMorph) ifTrue:[m delete]].! !!WonderlandCameraMorph methodsFor: 'drag and drop' stamp: 'ar 11/8/1999 16:31'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	| actor |	actor _ myCamera pickAt: evt cursorPoint.	actor == nil ifTrue:[^self addMorphFront: aMorph]. "This should never happen."	myWonderland getUndoStack push: (UndoTextureChange for: actor from: actor getTexturePointer).	aMorph installAsWonderlandTextureOn: actor.	World abandonAllHalos.	"AAAARRRRGGGGGHHHH!!!!!!!!"	aMorph owner ifNotNil:[aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	"Note: The above makes aMorph invisible to stupid HandMorph but keeps it in the world so it can continue stepping"	actor adjustToTextureIfNecessary.! !!WonderlandCameraMorph methodsFor: 'drag and drop' stamp: 'ar 11/7/1999 21:09'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	| pt |	(super wantsDroppedMorph: aMorph event: evt) ifFalse:[^false].	pt _ self transformFromWorld globalPointToLocal: evt cursorPoint.	(myCamera pickAt: pt) == nil ifTrue:[^false].	^true! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 21:11'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addUpdating: #getDragAndDropState action: #toggleDragAndDropState.! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 21:22'!getDragAndDropState	self openToDragAndDrop		ifTrue:[^'close to drag and drop']		ifFalse:[^'open to drag and drop']! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 21:14'!openToDragAndDrop	^(self valueOfProperty: #openToDragAndDrop) == true! !!WonderlandCameraMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 21:13'!toggleDragAndDropState	self openToDragAndDrop		ifTrue:[self closeDragAndDrop]		ifFalse:[self openDragAndDrop]! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'ar 11/7/1999 20:13'!top	"Return the top undo action off the stack."	| lastItem |	(theStack isEmpty) ifTrue: [lastItem _ nil]					   ifFalse: [lastItem _ theStack last].	^ lastItem.! !!WonderlandWrapperMorph commentStamp: '<historical>' prior: 0!A WonderlandWrapperMorph is temporarily created by Cmd-Clicking on an object in a 3D world. The wrappers map the behavior of morphs into 3D worlds so that 2D interactions result in appropriate changes in the 3D world (e.g., dragging, resizing) and state changes as well (e.g., color).Wrappers are created as a hierarchical morph list on the object they represent. This is necessary to allow accesses to higher levels in the 3D hierarchy. Note that there are currently several inconsistent behaviors for 3D objects. This is related to the ridiculous attempt of HandMorph to completely understand the interaction hierarchy, e.g., the HandMorph dispatches all events to what it *thinks* the receiver should be. Naturally, this fails completely for 3D worlds where there is no hierarchy of morphs but which may nevertheless use input events.!!WonderlandWrapperMorph reorganize!('initialization' createHierarchy setActor:)('drawing' drawOn: fullDrawOn:)('accessing' color color: getCameraMorph knownName)('handles' addHandlesTo:box: balloonHelpTextForHandle: definesOwnHaloHandles dismissViaHalo dragEndFromHalo:with: dragMoveFromHalo:with: dragPositionOffset dragPositionOffset: dragStartFromHalo:with: dupFromHalo:with: extractTexture: grabFromHalo:with: growEndFromHalo:with: growMoveFromHalo:with: growPositionOffset growPositionOffset: growStartFromHalo:with: removeAllHandlesBut: rotateEndFromHalo:with: rotateMoveFromHalo:with: rotateStartFromHalo:with:)('private' computeBounds: computeFullBounds: undo:using: undoOnTop:using:)('menu' addCustomMenuItems:hand: getActiveTextureState getTextureAdjust setUserPointOfView toggleActiveTextureState toggleTextureAdjust)!!WonderlandWrapperMorph methodsFor: 'initialization' stamp: 'ar 11/7/1999 19:07'!createHierarchy	"Create a wrapper hierarchy representing the owners of the receiver"	| actor wrapper |	actor _ myActor getParent.	actor == myWonderland getScene ifTrue:[^self]. "At top"	"Create new wrapper"	wrapper _ self class on: actor.	wrapper addMorphFront: self.	"And continue there"	^wrapper createHierarchy! !!WonderlandWrapperMorph methodsFor: 'initialization' stamp: 'ar 11/7/1999 19:03'!setActor: anActor	myActor _ anActor.	myWonderland _ anActor getWonderland.! !!WonderlandWrapperMorph methodsFor: 'drawing' stamp: 'ar 11/8/1999 13:45'!drawOn: aCanvas	| morph |	morph _ self getCameraMorph.	morph == nil		ifTrue:[super drawOn: aCanvas]		ifFalse:[self computeBounds: morph. "Update bounds from camera"			false ifTrue:["Show a rectangle for the wrappers"				aCanvas frameRectangle: bounds color: Color white]]! !!WonderlandWrapperMorph methodsFor: 'drawing' stamp: 'ar 11/7/1999 19:12'!fullDrawOn: aCanvas	super fullDrawOn: aCanvas.	fullBounds _ nil. "Force recomputation"! !!WonderlandWrapperMorph methodsFor: 'accessing' stamp: 'ar 11/7/1999 21:36'!color	^myActor getColorVector asColor! !!WonderlandWrapperMorph methodsFor: 'accessing' stamp: 'ar 11/7/1999 21:30'!color: aColor	"Change the color of the actor"	self undoOnTop: UndoColorChange using:[myActor getColor].	myActor setColorVector: aColor asB3DColor! !!WonderlandWrapperMorph methodsFor: 'accessing' stamp: 'ar 11/7/1999 19:15'!getCameraMorph	| morph |	morph _ owner.	[morph == nil] whileFalse:[		(morph isKindOf: WonderlandCameraMorph) ifTrue:[^morph].		morph _ morph owner].	^nil! !!WonderlandWrapperMorph methodsFor: 'accessing' stamp: 'ar 11/7/1999 19:30'!knownName	^myActor getName! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:33'!addHandlesTo: aHaloMorph box: box	| dismissHandle s lab |	s _ aHaloMorph handleSize.	myActor getTexturePointer == nil ifFalse:[		aHaloMorph addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #extractTexture: to: aHaloMorph target].	aHaloMorph addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: aHaloMorph.	aHaloMorph addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #yourself "#tearOffTile" to: self.	dismissHandle _ aHaloMorph addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color red muchLighter		on: #mouseDown send: #mouseDownInDimissHandle:with: to: aHaloMorph.	dismissHandle on: #mouseUp send: #maybeDismiss:with: to: aHaloMorph.	dismissHandle on: #mouseStillDown send: #setDismissColor:with: to: aHaloMorph.	dismissHandle addMorphBack: (lab _ StringMorph contents: 'X' font: ScriptingSystem fontForScriptorButtons).	lab position: dismissHandle position + (4 @ 0).	lab lock.	aHaloMorph addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #yourself "#openViewerForArgument" to: self.	aHaloMorph addHandleAt: box topCenter color: Color black		on: #mouseDown send: #grabFromHalo:with: to: self.	(aHaloMorph addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #dragStartFromHalo:with: to: self)		on: #mouseStillDown send: #dragMoveFromHalo:with: to: self;		on: #mouseUp send: #dragEndFromHalo:with: to: self.	aHaloMorph addHandleAt: box topRight color: Color green		on: #mouseDown send: #dupFromHalo:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[aHaloMorph addHandleAt: ((box topRight + box rightCenter) // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: aHaloMorph].	(aHaloMorph addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #rotateStartFromHalo:with: to: self)		on: #mouseStillDown send: #rotateMoveFromHalo:with: to: self;		on: #mouseUp send: #rotateEndFromHalo:with: to: self.	(aHaloMorph addHandleAt: box bottomRight color: Color yellow		on: #mouseDown send: #growStartFromHalo:with: to: self)		on: #mouseStillDown send: #growMoveFromHalo:with: to: self;		on: #mouseUp send: #growEndFromHalo:with: to: self.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:29'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(rotateStartFromHalo:with:				'Rotate')		(growStartFromHalo:with:				'Change size') 		(dupFromHalo:with:				'Duplicate')		(grabFromHalo:with:				'Pick up')		(dragStartFromHalo:with:				'Move')	) do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^super balloonHelpTextForHandle: aHandle! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 14:31'!definesOwnHaloHandles	"We wish to define our own set of handles"	^true! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 14:37'!dismissViaHalo	myActor destroy.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:29'!dragEndFromHalo: evt with: handle	self dragPositionOffset: nil.	self halo endInteraction.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 16:42'!dragMoveFromHalo: evt with: handle	| morph delta screenPos scenePos |	morph _ self getCameraMorph.	morph == nil ifTrue:[^self].	delta _ (self pointFromWorld: evt cursorPoint - self dragPositionOffset) - self position.	screenPos _ (myActor getPositionInPixels: morph getCamera) + delta.	scenePos _ morph getCamera transformScreenPointToScenePoint: screenPos atDepthOf: myActor.	myActor moveToRightNow: scenePos asSeenBy: (myWonderland getScene) undoable: false.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:16'!dragPositionOffset	^self valueOfProperty: #dragPositionOffset.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:16'!dragPositionOffset: aPoint	aPoint == nil		ifTrue:[self removeProperty: #dragPositionOffset]		ifFalse:[self setProperty: #dragPositionOffset toValue: aPoint].! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:17'!dragStartFromHalo: evt with: handle	self removeAllHandlesBut: handle.	self dragPositionOffset: handle center - self positionInWorld.	self undo: UndoPOVChange using: myActor getPointOfView.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:25'!dupFromHalo: evt with: handle! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/7/1999 20:34'!extractTexture: evt	evt hand attachMorph: myActor getTexturePointer asMorph! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:25'!grabFromHalo: evt with: handle! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:30'!growEndFromHalo: evt with: handle	self growPositionOffset: nil.	self halo endInteraction.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:39'!growMoveFromHalo: evt with: handle	| newExtent scale |	newExtent _ (self pointFromWorld: (evt cursorPoint - self growPositionOffset)) - self topLeft.	newExtent _ newExtent max: 1@1.	scale _ newExtent r / bounds extent r.	evt shiftPressed		ifTrue:[scale _ B3DVector3 x: scale y: scale z: 1.0]		ifFalse:[scale _ B3DVector3 x: scale y: scale z: scale]. 	myActor resizeRightNow: scale undoable: false.	handle position: evt cursorPoint - (handle extent // 2).! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:20'!growPositionOffset	^self valueOfProperty: #growPositionOffset.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:20'!growPositionOffset: aPoint	aPoint == nil		ifTrue:[self removeProperty: #growPositionOffset]		ifFalse:[self setProperty: #growPositionOffset toValue: aPoint].! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:22'!growStartFromHalo: evt with: handle	self removeAllHandlesBut: handle.	self growPositionOffset: evt cursorPoint - (self pointInWorld: self bottomRight).	self undo: UndoSizeChange using: myActor getSize.! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:17'!removeAllHandlesBut: aHandle	| halo |	halo _ self halo.	halo == nil ifFalse:[halo removeAllHandlesBut: aHandle].! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:30'!rotateEndFromHalo: evt with: handle! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:30'!rotateMoveFromHalo: evt with: handle! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 11/8/1999 15:30'!rotateStartFromHalo: evt with: handle! !!WonderlandWrapperMorph methodsFor: 'private' stamp: 'ar 11/8/1999 14:10'!computeBounds: morph	| box |	box _ myActor getFullBoundsFor: morph getCamera.	box == nil ifFalse:[bounds _ box].! !!WonderlandWrapperMorph methodsFor: 'private' stamp: 'ar 11/8/1999 14:10'!computeFullBounds: cameraMorph	self submorphsDo:[:m| m computeFullBounds: cameraMorph].	self computeBounds: cameraMorph.	fullBounds _ nil.! !!WonderlandWrapperMorph methodsFor: 'private' stamp: 'ar 11/8/1999 15:18'!undo: anUndoClass using: aValue	"Check if we need to add an undo action."	myWonderland getUndoStack push: (anUndoClass for: myActor from: aValue).! !!WonderlandWrapperMorph methodsFor: 'private' stamp: 'ar 11/7/1999 21:29'!undoOnTop: anUndoClass using: aBlock	"Check if we need to add an undo action."	| stack top |	stack _ myWonderland getUndoStack.	top _ stack top.	((top isKindOf: anUndoClass) and:[top getActor == myActor]) ifFalse:[		stack push: (anUndoClass for: myActor from: aBlock value)].! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 11/8/1999 13:16'!addCustomMenuItems: aCustomMenu hand: aHand	super addCustomMenuItems: aCustomMenu hand: aHand.	aCustomMenu addLine.	aCustomMenu addUpdating: #getActiveTextureState action: #toggleActiveTextureState.	aCustomMenu addUpdating: #getTextureAdjust action: #toggleTextureAdjust.	aCustomMenu add:'set user point of view' action:#setUserPointOfView.! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 22:35'!getActiveTextureState	(myActor getProperty: #activeTexture) == true		ifTrue:[^'disable active texture']		ifFalse:[^'enable active texture']! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 22:38'!getTextureAdjust	(myActor getProperty: #adjustToTexture) == true		ifTrue:[^'do not adjust to texture']		ifFalse:[^'auto adjust to texture']! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 11/8/1999 13:17'!setUserPointOfView	| morph |	morph _ self getCameraMorph.	morph == nil ifTrue:[^self].	myActor setUserPointOfView: (morph getCamera getPointOfView: myActor).! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 22:35'!toggleActiveTextureState	(myActor getProperty: #activeTexture) == true		ifTrue:[myActor setProperty: #activeTexture toValue: false]		ifFalse:[myActor setProperty: #activeTexture toValue: true]! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 11/7/1999 22:36'!toggleTextureAdjust	(myActor getProperty: #adjustToTexture) == true		ifTrue:[myActor setProperty: #adjustToTexture toValue: false]		ifFalse:[myActor setProperty: #adjustToTexture toValue: true]! !!WonderlandWrapperMorph class methodsFor: 'instance creation' stamp: 'ar 11/7/1999 19:03'!on: anActor	^self new setActor: anActor! !HandMorph removeSelector: #addHalo!HandMorphForReplay removeSelector: #addHalo!PasteUpMorph removeSelector: #rootMorphsAt:!Wonderland removeSelector: #makeActiveTexture!WonderlandActor removeSelector: #setActiveTexture:!WonderlandActor removeSelector: #morphicLeftMouseUp:!WonderlandActor removeSelector: #morphicLeftMouseDown:!WonderlandActor removeSelector: #initializeMorphicReactions!"Postscript:Clean up eventual old WonderlandTextureMorphs and WonderlandHandMorphs. They are no longer needed."| newMorph |WonderlandHandMorph allInstances do:[:m| m delete]. "Get rid of old hands""Convert old texture holders to real morphs"WonderlandTextureMorph allInstances do:[:m|	newMorph _ RectangleMorph new bounds: m bounds.	"Copy properties"	newMorph color: m color.	newMorph borderWidth: m borderWidth.	newMorph borderColor: m borderColor.	"Copy submorphs"	m submorphs do:[:mm| newMorph addMorphBack: mm].	"Fix parents"	newMorph privateOwner: m owner.	"For becoming..."	newMorph submorphs do:[:mm| mm privateOwner: m].	"Exchange pointers"	m become: newMorph.].Smalltalk removeClassNamed: #WonderlandHandMorph.Smalltalk removeClassNamed: #WonderlandTextureMorph.!