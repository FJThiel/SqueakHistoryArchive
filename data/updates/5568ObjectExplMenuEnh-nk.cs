'From Squeak3.6beta of ''4 July 2003'' [latest update: #5352] on 24 July 2003 at 10:28:55 am'!"Change Set:		ObjectExplorerMenuEnh-nkDate:			24 July 2003Author:			Ned KonzThis adds the full menu of the Inspectors to the ObjectExplorers.It also adds the updating behavior from my prior change set called ObjectExplorerUpdating."!AbstractHierarchicalList subclass: #ObjectExplorer	instanceVariableNames: 'rootObject inspector monitorList '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!ListItemWrapper subclass: #ObjectExplorerWrapper	instanceVariableNames: 'itemName parent '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!!Inspector methodsFor: 'menu commands' stamp: 'nk 7/24/2003 10:11'!chasePointers	| saved |	self selectionIndex == 0 ifTrue: [^ self changed: #flash].	saved _ self object.	[self object: nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: saved]		ifFalse: [self objectReferencesToSelection]]		ensure: [self object: saved]! !!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 10:08'!explorerFor: anObject	| window listMorph |	rootObject _ anObject.	window _ (SystemWindow labelled: self label) model: self.	window addMorph: (listMorph _ SimpleHierarchicalListMorph 			on: self			list: #getList			selected: #getCurrentSelection			changeSelected: #noteNewSelection:			menu: #genericMenu:			keystroke: nil)		frame: (0@0 corner: 1@0.8).	window addMorph: ((PluggableTextMorph on: self text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.8 corner: 1@1).	listMorph autoDeselect: false.     ^ window! !!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 09:16'!getList	^Array with: (ObjectExplorerWrapper with: rootObject name: 'root' model: self parent: nil)! !!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 09:43'!object	^currentSelection ifNotNilDo: [ :cs | cs withoutListWrapper ]! !!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 10:02'!parentObject	currentSelection ifNil: [ ^nil ].	currentSelection parent ifNil: [ ^rootObject ].	^currentSelection parent withoutListWrapper! !!ObjectExplorer methodsFor: 'accessing' stamp: 'nk 7/24/2003 09:47'!selector	^currentSelection ifNotNilDo: [ :cs | cs selector ]! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:25'!chasePointers	"Open a PointerFinder on the selected item"	| path sel savedRoot saved |	path _ OrderedCollection new.	sel _ currentSelection.	[ sel isNil ] whileFalse: [ path addFirst: sel asString. sel _ sel parent ].	path addFirst: #openPath.	path _ path asArray.	savedRoot _ rootObject.	saved _ self object.	[ rootObject _ nil.	self changed: #getList.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: saved]		ifFalse: [self objectReferencesToSelection ]]		ensure: [ rootObject _ savedRoot.			self changed: #getList.			self changed: path.		]! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:25'!defsOfSelection	"Open a browser on all defining references to the selected instance variable, if that's what's currently selected."	| aClass sel |	(aClass _ self parentObject class) isVariable ifTrue: [^ self changed: #flash].	sel _ self selector.	self systemNavigation  browseAllStoresInto: sel from: aClass! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:26'!exploreSelection	"Open an ObjectExplorer on the current selection"	self object explore! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:24'!genericMenu: aMenu 	"Borrow a menu from my inspector"	| insideObject menu parentObject |	currentSelection		ifNil: [menu _ aMenu.			menu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [insideObject _ self object.			parentObject _ self parentObject.			inspector				ifNil: [inspector _ Inspector new].			inspector inspect: parentObject;				 object: insideObject.			aMenu defaultTarget: inspector.			inspector fieldListMenu: aMenu.			aMenu items				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #chasePointers ) includes: i selector)						ifTrue: [i target: self]].			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:26'!inspectSelection	"Open an Inspector on the current selection"	self object inspect! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:00'!objectReferencesToSelection	"Open a browser on all references to the selected instance variable, if that's what currently selected. "	self systemNavigation		browseAllObjectReferencesTo: self object		except: (Array with: self parentObject with: currentSelection with: inspector)		ifNone: [:obj | self changed: #flash].! !!ObjectExplorer methodsFor: 'menus' stamp: 'nk 7/24/2003 10:26'!referencesToSelection	"Open a browser on all references to the selected instance variable, if that's what's currently selected."	| aClass sel |	(aClass _ self parentObject class) isVariable ifTrue: [^ self changed: #flash].	sel _ self selector.	self systemNavigation browseAllAccessesTo: sel from: aClass! !!ObjectExplorer methodsFor: 'error handling' stamp: 'nk 7/24/2003 09:29'!doesNotUnderstand: aMessage	inspector ifNotNil: [ (inspector respondsTo: aMessage selector) ifTrue: [ ^inspector perform: aMessage selector withArguments: aMessage arguments ]].	^super doesNotUnderstand: aMessage! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 18:33'!monitor: anObjectExplorerWrapper	"Start stepping and watching the given wrapper for changes."	anObjectExplorerWrapper ifNil: [ ^self ].	ActiveWorld ifNil: [ ^self ].	self monitorList at: anObjectExplorerWrapper put: anObjectExplorerWrapper asString.	ActiveWorld startStepping: self at: Time millisecondClockValue selector: #step arguments: #() stepTime: 200.! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 17:46'!monitorList	^monitorList ifNil: [ monitorList _ WeakIdentityKeyDictionary new ].! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 17:59'!release	ActiveWorld ifNotNil: [ ActiveWorld stopStepping: self selector: #step ].	super release.! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 17:55'!shouldGetStepsFrom: aWorld	^self monitorList notEmpty! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 18:29'!step	"If there's anything in my monitor list, see if the strings have changed."	| string changes |	changes _ false.	self monitorList keysAndValuesDo: [ :k :v |		k ifNotNil: [			k refresh.			(string _ k asString) ~= v ifTrue: [ self monitorList at: k put: string. changes _ true ].		]	].	changes ifTrue: [ | sel |		sel _ currentSelection.		self changed: #getList.		self noteNewSelection: sel.	].	self monitorList isEmpty ifTrue: [ ActiveWorld stopStepping: self selector: #step ].! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nk 7/12/2003 18:34'!stopMonitoring	monitorList _ nil.	ActiveWorld stopStepping: self selector: #step! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:17'!contents	(item respondsTo: #explorerContents) ifTrue: [^item explorerContents].	"For all others, show named vars first, then indexed vars"	^(item class allInstVarNames asOrderedCollection withIndexCollect: [:each :index |		self class			with: (item instVarAt: index)			name: each			model: item			parent: self]) ,	((1 to: item basicSize) collect: [:index |		self class			with: (item basicAt: index)			name: index printString			model: item			parent: self])! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!parent	^parent! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!parent: anObject	parent _ anObject! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:49'!selector	parent ifNil: [ ^nil ].	^(parent withoutListWrapper class allInstVarNames includes: itemName) ifTrue: [ itemName asSymbol ]! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!setItem: anObject name: aString model: aModel parent: itemParent	parent _ itemParent.	self setItem: anObject name: aString model: aModel! !!ObjectExplorerWrapper methodsFor: 'converting' stamp: 'nk 7/24/2003 10:16'!itemName	^itemName! !!ObjectExplorerWrapper methodsFor: 'monitoring' stamp: 'nk 7/12/2003 18:28'!refresh	"hack to refresh item given an object and a string that is either an index or an instance variable name."	[ | index |		(model class allInstVarNames includes: itemName)			ifTrue: [ item _ model instVarNamed: itemName ]			ifFalse: [ index _ itemName asNumber.				(index between: 1 and: model basicSize) ifTrue: [ item _ model basicAt: index]]	] on: Error do: [ :ex | item _ nil ]! !!ObjectExplorerWrapper class methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:16'!with: anObject name: aString model: aModel parent: aParent	^self new 		setItem: anObject name: aString model: aModel parent: aParent! !ObjectExplorer removeSelector: #newGenericMenu:!!ObjectExplorer reorganize!('accessing' contentsSelection doItContext doItReceiver explorerFor: getList label object parentObject selector)('menus' chasePointers codePaneMenu:shifted: defsOfSelection exploreSelection genericMenu: inspectSelection objectReferencesToSelection referencesToSelection selectedClass trash trash:)('system navigation' systemNavigation)('user interface' initialExtent openBrowser: openExplorerFor:)('error handling' doesNotUnderstand:)('monitoring' monitor: monitorList release shouldGetStepsFrom: step stopMonitoring)!