'From Squeak2.8alpha of 16 February 2000 [latest update: #2302] on 8 June 2000 at 8:41:46 pm'!"Change Set:		FXColorFixesDate:			8 June 2000Author:			Andreas RaabA bunch of fixes for external forms with non-squeak RGBA formats. Found and fixed on the new demo laptop which uses a neat 5x6x5 RGB format in 16 bit depth. Very good for testing."!!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 6/8/2000 20:36'!mappingTo: aColorMap	"Compute a new color map through the receiver and aColorMap.	Both maps are assumed to be mappings into canonical ARGB space"	| fixedMap |	self = aColorMap ifTrue:[^nil]. "No mapping needed"	aColorMap isIndexed ifTrue:[^nil]. "We can't compute mappings to an indexed map yet"	fixedMap _ self class mappingFrom: self rgbaBitMasks to: aColorMap rgbaBitMasks.	self isIndexed ifFalse:[^fixedMap].	"If the receiver is indexed then we need to map the colors as well"	self flag: #untested.	^ColorMap		shifts: fixedMap shifts		masks: fixedMap masks		colors: (colors collect:[:pv| aColorMap pixelMap: pv]).! !!FXBlt methodsFor: 'accessing' stamp: 'ar 6/8/2000 20:38'!fillColor: aColorOrPattern 	"The destForm will be filled with this color or pattern of colors.  May be an old Color, a new type Color, a Bitmap (see BitBlt comment), a Pattern, or a Form.  6/18/96 tk"	aColorOrPattern == nil ifTrue: [halftoneForm _ nil. ^ self].	destForm == nil ifTrue: [self error: 'Must set destForm first'].	halftoneForm _ destForm bitPatternFor: aColorOrPattern.! !!Form methodsFor: 'color mapping' stamp: 'ar 6/8/2000 20:37'!bitPatternFor: aColor	"Return the pixel word for representing the given color on the receiver"	aColor isColor ifFalse:[^aColor bitPatternForDepth: self depth].	self isExternalForm		ifTrue:[^Bitmap with: (self pixelWordFor: aColor)]		ifFalse:[^aColor bitPatternForDepth: self depth]! !!Form methodsFor: 'color mapping' stamp: 'ar 6/8/2000 20:36'!colormapIfNeededFor: destForm	"Return a ColorMap mapping from the receiver to destForm."	"Note: This is very magical for now - we really need to switch	to palettes here but as long as this isn't done we need something	that works."	| map nBits myBits |	(self isExternalForm or:[destForm isExternalForm]) ifTrue:[		^self colormapFromARGB mappingTo: destForm colormapFromARGB].	self depth = destForm depth ifTrue:[^nil]. "no conversion"	self depth <= 8 ifTrue:["Always map indexed"		^ColorMap			shifts: nil			masks: nil			colors: (Color colorMapIfNeededFrom: self depth to: destForm depth)].	(self depth = 16 and:[destForm depth = 32]) ifTrue:["Expand bits"		^ColorMap 			shifts: #( 9 6 3 0) 			masks: #(16r7C00 16r3E0 16r1F 0)].	(self depth = 32 and:[destForm depth = 16]) ifTrue:["Contract bits"		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	"destForm is indexed, I am non-indexed"	map _ Color colorMapIfNeededFrom: self depth to: destForm depth.	map size = 512 ifTrue:[nBits _ 3].	map size = 4096 ifTrue:[nBits _ 4].	map size = 32768 ifTrue:[nBits _ 5].	myBits _ depth == 16 ifTrue:[5] ifFalse:[8].	^ColorMap		shifts: {	(3 * nBits) - (3 * myBits).				(2 * nBits) - (2 * myBits).				(1 * nBits) - (1 * myBits).				0}		masks: {	(1 bitShift: nBits) - 1 bitShift: (3 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (2 * myBits - nBits).				(1 bitShift: nBits) - 1 bitShift: (1 * myBits - nBits).				0}		colors: map.! !!ColorForm methodsFor: 'color mapping' stamp: 'ar 6/8/2000 20:39'!colormapIfNeededFor: destForm	| newMap color pv |	colors == nil ifTrue: [		"use the standard colormap"		^ super colormapIfNeededFor: destForm].	(destForm depth = cachedDepth and:[cachedColormap isColormap]) 		ifTrue: [^ cachedColormap].	newMap _ WordArray new: (1 bitShift: depth).	1 to: colors size do: [:i |		color _ colors at: i.		pv _ destForm pixelValueFor: color.		(pv = 0 and:[color isTransparent not]) ifTrue:[pv _ 1].		newMap at: i put: pv].	cachedDepth _ destForm depth.	^cachedColormap _ ColorMap shifts: nil masks: nil colors: newMap.! !ColorMap removeSelector: #mappingWith:!