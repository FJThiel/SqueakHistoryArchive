'From Squeak 2.4c of May 10, 1999 on 17 June 1999 at 4:30:02 pm'!"Change Set:		F2KDemoPrepsDate:			15 June 1999Author:			Dan IngallsThis changeSet adds the ability to scroll MidiScores and their PianoRolls.Allows dragging pitch of notes in the score.Plays all notes vertically if you click outside a note but within 30 pix vertically.Adds a note edit menu and a score edit menu.Allows selection of multiple notes in a track, and basic cut copy paste functions."PianoRollNoteMorph removeFromSystem.!Morph subclass: #PianoRollNoteMorph	instanceVariableNames: 'trackIndex indexInTrack hitLoc editMode selected '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!RectangleMorph subclass: #PianoRollScoreMorph	instanceVariableNames: 'scorePlayer score colorForTrack lowestNote leftEdgeTime timeScale indexInTrack lastUpdateTick lastMutedState cursor selection '	classVariableNames: 'NotePasteBuffer '	poolDictionaries: ''	category: 'Music-Scores'!AbstractSound subclass: #ScorePlayer	instanceVariableNames: 'score instruments overallVolume leftVols rightVols muted rate tempo secsPerTick done repeat ticksSinceStart ticksClockIncr trackEventIndex tempoMapIndex activeSounds activeMIDINotes midiPort midiPlayerProcess durationInTicks '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!AlignmentMorph subclass: #ScorePlayerMorph	instanceVariableNames: 'scorePlayer trackInstNames instrumentSelector scrollSlider '	classVariableNames: 'LastMIDIPort '	poolDictionaries: ''	category: 'Music-Scores'!!AbstractScoreEvent methodsFor: 'accessing' stamp: 'di 6/17/1999 14:28'!adjustTimeBy: delta	time _ time + delta! !!Delay class methodsFor: 'instance creation' stamp: 'di 6/16/1999 23:04'!forSeconds: aNumber	"Return a new Delay for the given number of seconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	aNumber < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: (aNumber * 1000) asInteger		forSemaphore: Semaphore new! !!MIDIScore reorganize!('as yet unclassified' addAmbientEvent: ambientEventAfter:ticks: ambientTrack cutSelection: durationInTicks eventForTrack:after:ticks: gridToNextQuarterNote: gridToQuarterNote: gridTrack:toQuarter:at: initialize insertEvents:at: jitterStartAndEndTimesBy: otherPlayersDo: pauseFrom: removeAmbientEventWithMorph: resetFrom: resumeFrom: tempoMap tempoMap: ticksPerQuarterNote ticksPerQuarterNote: trackInfo trackInfo: tracks tracks:)('accessing')!!MIDIScore methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 15:12'!cutSelection: selection	| track selStartTime delta |	track _ tracks at: selection first.	selStartTime _ (track at: selection second) time.	track _ track copyReplaceFrom: selection second to: selection third with: Array new.	track size >=  selection second ifTrue:		["Adjust times of following events"		delta _ selStartTime - (track at: selection second) time.		selection second to: track size do:			[:i | (track at: i) adjustTimeBy: delta]].	tracks at: selection first put: track! !!MIDIScore methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 11:35'!durationInTicks		| t |	t _ 0.	tracks do:		[:track |		track do:			[:n | (n isNoteEvent) ifTrue: [t _ t max: n endTime]]].	^ t! !!MIDIScore methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 16:06'!gridToNextQuarterNote: tickTime	^ self gridToQuarterNote: tickTime + ticksPerQuarterNote! !!MIDIScore methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 14:55'!gridToQuarterNote: tickTime	^ tickTime truncateTo: ticksPerQuarterNote! !!MIDIScore methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 16:14'!gridTrack: trackIndex toQuarter: quarterDelta at: indexInTrack	| track selStartTime delta |	track _ tracks at: trackIndex.	selStartTime _ (track at: indexInTrack) time.	delta _ (self gridToQuarterNote: selStartTime + (quarterDelta*ticksPerQuarterNote))				- selStartTime.	indexInTrack to: track size do:		[:i | (track at: i) adjustTimeBy: delta].! !!MIDIScore methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 15:11'!insertEvents: events at: selection	| track selStartTime delta |	track _ tracks at: selection first.	selStartTime _ (track at: selection second) time.	track _ track copyReplaceFrom: selection second to: selection second - 1				with: (events collect: [:e | e copy]).	track size >=  (selection second + events size) ifTrue:		["Adjust times of following events"		delta _ selStartTime - (track at: selection second) time.		selection second to: selection second + events size - 1 do:			[:i | (track at: i) adjustTimeBy: delta].		delta _ (self gridToNextQuarterNote: (track at: selection second + events size - 1) endTime)					- (track at: selection second + events size) time.		selection second + events size to: track size do:			[:i | (track at: i) adjustTimeBy: delta].		].	tracks at: selection first put: track! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/16/1999 22:39'!addNoteOfDuration: duration to: aSound	aSound add: (self noteOfDuration: duration)		pan: (owner scorePlayer panForTrack: trackIndex)		volume: owner scorePlayer overallVolume *				(owner scorePlayer volumeForTrack: trackIndex)! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:16'!deselect	selected ifFalse: [^ self].	self changed.	selected _ false.! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 10:56'!drawOn: aCanvas	selected		ifTrue: [aCanvas frameAndFillRectangle: self fullBounds fillColor: color borderWidth: 1 borderColor: Color black]		ifFalse: [aCanvas fillRectangle: self bounds color: color].! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 10:32'!editPitch: evt	| mk note |	mk _ owner midiKeyForY: evt cursorPoint y.	note _ (owner score tracks at: trackIndex) at: indexInTrack.	note midiKey = mk ifTrue: [^ self].	note midiKey: mk.	self playNoteOfDuration: 0.3.	self position: self position x @ ((owner yForMidiKey: mk) - 1)! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 10:55'!fullBounds	selected		ifTrue: [^ bounds expandBy: 1]		ifFalse: [^ bounds]! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 16:08'!gridToNextQuarter	owner score gridTrack: trackIndex toQuarter: 1 at: indexInTrack.	owner rebuildFromScore! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 16:08'!gridToPrevQuarter	owner score gridTrack: trackIndex toQuarter: -1 at: indexInTrack.	owner rebuildFromScore! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 14:55'!handlesMouseDown: evt	^ owner scorePlayer isPlaying not! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:17'!indexInTrack	^ indexInTrack! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 16:14'!invokeNoteMenu: evt	"Invoke the note's edit menu."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('double'		doubleNote)		('dot'		dotNote)		('halve'		halveNote)).	menu addLine.	menu addList:		#(('split 1 1 1'		split111)		('split 1 1'		split11)		('split 3 1'		split31)		('split 1 2 1'		split121)		('split 1 3'		split13)).	menu addLine.	menu addList:		#(('grid to next quarter'		gridToNextQuarter)		('grid to prev quarter'		gridToPrevQuarter)).	evt hand invokeMenu: menu event: evt.! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:49'!mouseDown: evt	hitLoc _ evt cursorPoint.	editMode _ nil.	self playNoteOfDuration: 0.3.	owner submorphsDo:		[:m | (m isKindOf: PianoRollNoteMorph) ifTrue: [m deselect]].	selected _ true.	self changed.	owner selection: (Array with: trackIndex with: indexInTrack with: indexInTrack).! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 15:31'!mouseMove: evt	| delta |	editMode == nil ifTrue:		["First movement determines edit mode"		((delta _ evt cursorPoint - hitLoc) dist: 0@0) <= 2 ifTrue:			[^ self  "No significant movement yet."].		delta x abs > delta y abs			ifTrue: [delta x > 0  "Horizontal drag"						ifTrue: [editMode _ #selectNotes]						ifFalse: [self invokeNoteMenu: evt]]			ifFalse: [editMode _ #editPitch  "Vertical drag"]].	editMode == #editPitch ifTrue: [self editPitch: evt].	editMode == #selectNotes ifTrue: [self selectNotes: evt].! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:48'!noteInScore	^ (owner score tracks at: trackIndex) at: indexInTrack! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:48'!noteOfDuration: duration	| note |	note _ self noteInScore.	^ (owner scorePlayer instrumentForTrack: trackIndex)			soundForMidiKey: note midiKey			dur: duration			loudness: (note velocity asFloat / 127.0)! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/16/1999 23:37'!playNoteOfDuration: duration	| sound |	sound _ MixedSound new.	self addNoteOfDuration: duration to: sound.	sound play.! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:16'!select	selected ifTrue: [^ self].	selected _ true.	self changed! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:30'!selectFrom: selection	(trackIndex = (selection at: 1)		and: [indexInTrack >= (selection at: 2)		and: [indexInTrack <= (selection at: 3)]])		ifTrue: [selected ifFalse: [self select]]		ifFalse: [selected ifTrue: [self deselect]]! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:53'!selectNotes: evt	| lastMorph oldEnd |	oldEnd _ owner selection last.	(owner notesInRect: (evt cursorPoint x @ owner top corner: owner bottomRight))		do: [:m | m trackIndex = trackIndex ifTrue: [m deselect]].	self select.  lastMorph _ self.	(owner notesInRect: (self left @ owner top corner: evt cursorPoint x @ owner bottom))		do: [:m | m trackIndex = trackIndex ifTrue: [m select.  lastMorph _ m]].	owner selection: (Array with: trackIndex with: indexInTrack with: lastMorph indexInTrack).	lastMorph indexInTrack > oldEnd ifTrue:		["Play last note as selection grows"		lastMorph playNoteOfDuration: lastMorph noteInScore duration / (owner scorePlayer ticksForMSecs: 1000)]! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:16'!trackIndex	^ trackIndex! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 10:46'!trackIndex: ti indexInTrack: i	trackIndex _ ti.	indexInTrack _ i.	selected _ false! !!PianoRollScoreMorph commentStamp: 'di 6/16/1999 23:09' prior: 0!timeScale is in pixels per score tick.!!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:34'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"	(track _ score ambientTrack) ifNotNil:		[i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1]].	"Then add note morphs"	1 to: score tracks size do:		[:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size or: [scorePlayer mutedForTrack: trackIndex].		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated - 1.							visibleMorphs add:								((PianoRollNoteMorph									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)									trackIndex: trackIndex indexInTrack: i)]]].			i _ i + 1].			(selection notNil				and: [trackIndex = selection first				and: [i >= selection second and: [(indexInTrack at: trackIndex) <= selection third]]])				ifTrue: [visibleMorphs do:						[:vm | (vm isKindOf: PianoRollNoteMorph) ifTrue: [vm selectFrom: selection]]].			].	"Add the cursor morph in front of all notes."	cursor ifNil: [  "create the cursor if needed; this is for legacy PianoRollScoreMorphs..."		cursor _			Morph newBounds: (self topLeft extent: 1@1)  "height and position are set later"			color: Color red].	visibleMorphs addFirst: cursor.	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:58'!copySelection	selection == nil ifTrue: [^ self].	NotePasteBuffer _ (score tracks at: selection first)		copyFrom: selection second to: selection third! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 15:29'!cutSelection	selection == nil ifTrue: [^ self].	self copySelection.	score cutSelection: selection.	(score tracks at: selection first) size >= selection second		ifTrue: [selection at: 3 put: (selection at: 2)]		ifFalse: [selection _ nil].	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 13:03'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ scoreTime - (20.0/timeScale) asInteger.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:40'!handlesMouseDown: evt	^ true! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 15:13'!insertSelection	selection == nil ifTrue: [^ self].	score insertEvents: NotePasteBuffer at: selection.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 16:29'!invokeScoreMenu: evt	"Invoke the score's edit menu."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('cut'		cutSelection)		('copy'		copySelection)		('paste'		insertSelection)).	menu addLine.	menu addList:		#(('legato'		selectionBeLegato)		('staccato'		selectionBeStaccato)		('normal'		selectionBeNormal)).	menu addLine.	menu addList:		#(('expand time'		expandTime)		('contract time'		contractTime)).	evt hand invokeMenu: menu event: evt.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 14:48'!midiKeyForY: y	^ lowestNote - ((y - (bounds bottom - borderWidth - 4)) // 3)! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 12:53'!mouseDown: evt	| noteMorphs sound chordDur chordMorph chordRect |	(self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 2@30)) isEmpty		ifTrue: ["If not near a note, then put up score edit menu"				^ self invokeScoreMenu: evt].	"Clicked near (but not on) a note, so play all notes at that time"	noteMorphs _ self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 0@self height).	noteMorphs isEmpty ifTrue: [^ self].	chordRect _ (noteMorphs collect: [:m | m bounds left]) max				@ (noteMorphs collect: [:m | m bounds top - 3]) min		corner: (noteMorphs collect: [:m | m bounds right]) min				@ (noteMorphs collect: [:m | m bounds bottom + 4]) max.	chordDur _ chordRect width / timeScale / (scorePlayer ticksForMSecs: 1000) min: 1.0.	chordMorph _ Morph newBounds: chordRect color: Color green.	self addMorphBack: chordMorph.	self world doOneCycle.		sound _ MixedSound new.	noteMorphs do: [:m | m addNoteOfDuration: chordDur to: sound].	sound play.	(Delay forSeconds: chordDur) wait.	chordMorph delete.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 13:26'!moveCursorToTime: scoreTime	| cursorOffset desiredCursorHeight |	scorePlayer isPlaying		ifTrue:			[cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger.			((cursorOffset < 0) or:			 [cursorOffset > (self width-20 - (2 * borderWidth))]) ifTrue: [				self goToTime: scoreTime.				self addNotes.				cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger]]		ifFalse:			[self goToTime: scoreTime - (self width//2 - 20 / timeScale).			self addNotes.			cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger].	cursor position: (self left + borderWidth + cursorOffset)@(self top + borderWidth).	desiredCursorHeight _ self height.	cursor height ~= desiredCursorHeight ifTrue: [cursor extent: 1@desiredCursorHeight].! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 09:36'!notesInRect: timeSlice	^ self submorphsSatisfying:		[:m | (timeSlice intersects: m bounds)				and: [m isKindOf: PianoRollNoteMorph]]! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 15:18'!rebuildFromScore	"Rebuild my submorphs from the score. This method should be invoked after changing the time scale, the color or visibility of a track, the extent of this morph, etc."	score ifNil: [^ self].	self addNotes.	"self moveCursorToTime: lastUpdateTick."! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 15:46'!score	^ score! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 14:52'!scorePlayer	^ scorePlayer! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:39'!selection	"Returns an array of 3 elements:		trackIndex		indexInTrack of first note		indexInTrack of last note"	^ selection! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'di 6/17/1999 11:38'!selection: anArray	selection _ anArray! !!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/15/1999 11:17'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	overallVolume _ 0.5.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.	durationInTicks _ 100.! !!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/15/1999 11:18'!onScore: aMIDIScore	| trackCount totalVol incr curr pan |	score _ aMIDIScore.	trackCount _ score tracks size.	durationInTicks _ score durationInTicks.	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].	leftVols _ Array new: trackCount.	rightVols _ Array new: trackCount.	muted  _ Array new: trackCount withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	trackCount = 0 ifTrue: [^ self].	1 to: trackCount do: [:i |		leftVols at: i put: ScaleFactor // 4.		rightVols at: i put: ScaleFactor // 4].	"distribute inital panning of tracks left-to-right"	totalVol _ 1.0.	incr _ totalVol / (((trackCount // 2) + 1) * 2).	curr _ 0.	1 to: trackCount do: [:t |		t even			ifTrue: [pan _ curr]			ifFalse: [				curr _ curr + incr.				pan _ totalVol - curr].		self panForTrack: t put: pan].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:28'!jumpToTick: startTick	| |	self reset.	self processTempoMapAtTick: startTick.	self skipNoteEventsThruTick: startTick.	ticksSinceStart _ startTick.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 21:04'!processTempoMapAtTick: scoreTick	"Process tempo changes through the given score tick."	| map tempoChanged |	map _ score tempoMap.	map ifNil: [^ self].	tempoChanged _ false.	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [		tempoChanged _ true.		tempoMapIndex _ tempoMapIndex + 1].	tempoChanged ifTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex - 1) tempo)) roundTo: 0.01.		self tempoOrRateChanged].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:56'!skipNoteEventsThruTick: startTick	"Skip note events through the given score tick using internal Squeak sound synthesis."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: startTick.		 evt == nil] whileFalse: [			evt isNoteEvent				ifTrue: [					(((evt time + evt duration) > startTick) and: [(muted at: i) not]) ifTrue: [						self startNote: evt forStartTick: startTick trackIndex: i]]				ifFalse: [					midiPort == nil ifFalse: [evt outputOnMidiPort: midiPort]].			j _ j + 1].		trackEventIndex at: i put: j].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:30'!startNote: noteEvent forStartTick: startTick trackIndex: trackIndex	"Prepare a note to begin playing at the given tick. Used to start playing at an arbitrary point in the score. Handle both MIDI and built-in synthesis cases."	| snd |	midiPort		ifNil: [			snd _ (instruments at: trackIndex)				soundForMidiKey: noteEvent midiKey				dur: secsPerTick * (noteEvent endTime - startTick)				loudness: noteEvent velocity asFloat / 127.0.			activeSounds add: (Array with: snd with: trackIndex)]		ifNotNil: [			noteEvent startNoteOnMidiPort: midiPort.			activeMIDINotes add: (Array with: noteEvent with: trackIndex)].! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/15/1999 11:37'!durationInTicks	durationInTicks == nil ifTrue: [^ 1000].	^ durationInTicks! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/15/1999 10:30'!positionInScore	^ self ticksSinceStart asFloat / self durationInTicks! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/16/1999 22:50'!positionInScore: pos	self isPlaying ifTrue: [^ self "ignore rude intrusion"].	ticksSinceStart _ pos * durationInTicks.	done _ false.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 6/16/1999 22:45'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	self jumpToTick: ticksSinceStart.  "Play up to here in case we got scrolled to new position."	score resumeFrom: self.	midiPort		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"! !!ScorePlayerMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 10:31'!onScorePlayer: aScorePlayer title: scoreName	| divider col r |	scorePlayer _ aScorePlayer.	scorePlayer ifNotNil:		[scorePlayer  reset.		instrumentSelector _ Array new: scorePlayer score tracks size].	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	scorePlayer ifNil: [^ self].	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	r addMorphBack: self rateControl;		addMorphBack: (Morph newBounds: (0@0 extent: 20@0) color: Color transparent);		addMorphBack: self volumeControl.	self addMorphBack: r.	self addMorphBack: self scrollControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].	LastMIDIPort ifNotNil: [		"use the most recently set MIDI port"		scorePlayer openMIDIPort: LastMIDIPort].! !!ScorePlayerMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 10:33'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 130@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 11:47'!scrollControl	| r |	scrollSlider _ SimpleSliderMorph new		color: color;		extent: 360@2;		target: scorePlayer;		actionSelector: #positionInScore:;		adjustToValue: scorePlayer positionInScore.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'start ').	r addMorphBack: scrollSlider.	r addMorphBack: (StringMorph contents: ' end').	^ r! !!ScorePlayerMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 11:48'!step	scrollSlider adjustToValue: scorePlayer positionInScore.! !!ScorePlayerMorph methodsFor: 'as yet unclassified' stamp: 'di 6/15/1999 10:33'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		extent: 130@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !MIDIScore removeSelector: #pasteSelection:at:!PianoRollNoteMorph removeSelector: #playNoteofDuration:!PianoRollNoteMorph removeSelector: #score:trackIndex:indexInTrack:!PianoRollNoteMorph removeSelector: #playNoteFor:!PianoRollNoteMorph removeSelector: #bounds!PianoRollScoreMorph removeSelector: #pasteSelection!PianoRollScoreMorph removeSelector: #highlightSelection!PianoRollScoreMorph removeSelector: #notesAtX:!ScorePlayer removeSelector: #durationInTicks:!