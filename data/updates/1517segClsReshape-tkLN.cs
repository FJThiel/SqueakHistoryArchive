'From Squeak 2.5 of August 6, 1999 [latest update: #1514] on 4 October 1999 at 10:34 pm'!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers state segmentName fileName endMarker '	classVariableNames: 'BiggestFileNumber '	poolDictionaries: ''	category: 'System-Object Storage'!!ClassDescription methodsFor: 'initialize-release' stamp: 'tk 10/4/1999 09:43'!updateInstances: oldInstances from: oldClass isMeta: isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| map variable instSize newInstances |	oldInstances isEmpty ifTrue:[^self]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		self soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map _ self instVarMappingFrom: oldClass.	variable _ self isVariable.	instSize _ self instSize.	newInstances _ Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'tk 10/4/1999 17:48'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| oldInstances |	oldInstances _ oldClass allInstances asArray.	self updateInstances: oldInstances from: oldClass isMeta: false.	"Now fix up instances in segments that are out on the disk."	ImageSegment allSubInstancesDo: [:seg |		seg segUpdateInstancesOf: oldClass toBe: self isMeta: false]."	| crashingBlock class |	class _ Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar _ value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock _ (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!ImageSegment commentStamp: 'tk 10/4/1999 19:09' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  My segment contains outward pointers that are indices into my table of outPointers.	When a segment is written out onto a file, it must be in a folder called <image name>_segs.  Short name of the segment is saved.To put out a segment that can only be read by this image, make PV be a Project (not the current project).World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].(ImageSegment new copyFromRootsLocalFileFor: 	(Array with: PV world presenter with: PV world))		extract; writeToFile: 'myFile.seg'.To discover why the whole project is not going out (***Destructive Test***).  This breaks lots of backpointers in the target project, and puts up an array of suspicious objects, a list of the classes of the outPointers, and a debugger."Close any transcripts in the target project"World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].PV _ Project named: 'xxxx'.(IS _ ImageSegment new) findRogueRootsImSeg: 	(Array with: PV world presenter with: PV world)."Quit without saving""After the destructive analysis, write a file with owner chains"IS findOwnersOutPtrs.To put out a segment that can be read into a different image:(ImageSegment new copyFromRootsForExport: (Array with: Baz with: Baz class))		writeForExport: 'myFile.extSeg'.To read into another image:  Select 'myFile.extSeg' in a FileList, Menu more..., fileIn.  It will install classes automatically.  If you need to see the roots array, it is temporarily stored in (SmartRefStream scannedObject).I may exist in several states...#activeCopyarrayOfRoots segment outPointers are all as created by the copyFromRoots: initialization message.  Nothing else has changed about the Squeak system.#activeEach of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only the array of outPointers remains in the image.(ImageSegment new copyFromRoots: (Array with: Baz with: Baz class))		writeToFile: 'myFile.extSeg'.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.	NOTE: All IdentitySets or dictionaries must be rehashed when being read back from this format.  The symbols are effectively internal.  (No, not if read back into same image.  If a different image, then use #imported.  -tk)#importedThe segment is on an external file or just read in from one.  The segment and outPointers are meant to be read into a foreign image.   (It is in SmartRefStream format.)  In this form the segment can be read from a URL, and installed.  A copy of the original array of root objects is constructed, with former outPointers bound to existing objects in the host system.  	(Any Class inside the segment MUST be in the arrayOfRoots.  This is so its association can be inserted into Smalltalk.  The class's metaclass must be in roots also.  Methods that are in outPointers because blocks point at them, are found and added to the roots.)	All IdentitySets and dictionaries are rehashed when being read back from exported segments.) #inactiveIn this state, the rootsArray is set, but the segment is invalid.!!ImageSegment reorganize!('access' allObjectsDo: arrayOfRoots outPointers segment state)('read/write segment' copyFromRoots: copyFromRootsForExport: copyFromRootsLocalFileFor: extract extractThenInstall install readFromFile rootsIncludingBlockMethods rootsIncludingPlayers segmentCopy writeForExport: writeToFile writeToFile: writeToFileWithSymbols writeToFileWithSymbols:)('primitives' loadSegmentFrom:outPointers: storeSegmentFor:into:outPointers:)('testing' deepCopyTest: errorWrongState findInOut: findOwnerMap: findOwnersOutPtrs findRogueRootsAllMorphs: findRogueRootsImSeg: findRogueRootsPrep findRogueRootsRefStrm: verify:matches:knowing: verifyCopy)('fileIn/Out' comeFullyUpOnReload: declare: prepareToBeSaved rehashSets storeDataOn:)('instance remapping' segUpdateInstancesOf:toBe:isMeta:)!!ImageSegment methodsFor: 'access' stamp: 'tk 10/4/1999 17:52'!allObjectsDo: aBlock	"Enumerate all objects that came from this segment.  NOTE this assumes that the segment was created (and extracted).  After the segment has been installed (install), this method allows you to enumerate its objects."	| obj |	endMarker == nil ifTrue: [		^ self error: 'Just extract and install, don''t writeToFile:'].	segment size ~= 1 ifTrue: [		^ self error: 'Vestigial segment size must be 1 (version word)'].	obj _ segment nextObject.  "Start with the next object after the vestigial header"	[obj == endMarker] whileFalse:  "Stop at the next object after the full segment"		[aBlock value: obj.		obj _ obj nextObject].  "Step through the objects installed from the segment."! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/4/1999 17:37'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile.		endMarker _ 'End' clone].	"for enumeration of objects"	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols.		endMarker _ 'End' clone].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	"Sensor shiftPressed ifTrue: [self halt]."	"(self confirm: 'Installing segment.  Want a debugger?') ifTrue: [self halt]."	state _ #inactive.	(PluckedSound pitch: 261.625*3 dur: 0.25 loudness: 0.1) play.	"interrupts previous sound"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/4/1999 19:15'!writeToFile	state = #active ifFalse: [self error: 'wrong state'].	segmentName ifNil: [self error: 'first use writeToFile:'].	fileName _ self class uniqueFileNameFor: segmentName.	(FileStream newFileNamed: fileName) nextPutAll: segment; close.	segment _ nil.	endMarker _ nil.	state _ #onFile! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/4/1999 19:22'!writeToFile: shortName	"The short name can't have any fileDelimiter characters in it.  It is remembered in case the segment must be brought in and then sent out again (see ClassDescription updateInstancesFrom:)."	segmentName _ (shortName endsWith: '.seg')		ifTrue: [shortName copyFrom: 1 to: shortName size - 4]		ifFalse: [shortName].	self writeToFile.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/4/1999 19:16'!writeToFileWithSymbols	| symbols nonSymbols pound |	state = #extracted ifFalse: [self error: 'wrong state'].	segmentName ifNil: [self error: 'first use writeToFile:'].	fileName _ self class uniqueFileNameFor: segmentName.	symbols _ OrderedCollection new.	nonSymbols _ OrderedCollection new.	pound _ '#' asSymbol.	outPointers do:		[:s | 		((s isMemberOf: Symbol) and: [s isLiteral and: [s ~~ pound]])			ifTrue: [symbols addLast: s]			ifFalse: [symbols addLast: pound.  nonSymbols addLast: s]].	(FileStream newFileNamed: fileName)		store: symbols asArray; cr;		nextPutAll: segment; close.	outPointers _ nonSymbols asArray.	state _ #onFileWithSymbols! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/4/1999 19:17'!writeToFileWithSymbols: shortName	segmentName _ (shortName endsWith: '.seg')		ifTrue: [shortName copyFrom: 1 to: shortName size - 4]		ifFalse: [shortName].	self writeToFileWithSymbols.! !!ImageSegment methodsFor: 'instance remapping' stamp: 'tk 10/4/1999 19:17'!segUpdateInstancesOf: oldClass toBe: newClass isMeta: isMeta	| withSymbols oldInstances |	"Bring me in, locate instances of oldClass and get them converted.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	(outPointers includes: oldClass) ifFalse: [^ self].		"If has instances, they point out at the class"	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == oldClass ifTrue: [		oldInstances add: obj]].	newClass updateInstances: oldInstances asArray from: oldClass isMeta: isMeta.	self copyFromRoots: arrayOfRoots.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!Metaclass methodsFor: 'initialize-release' stamp: 'tk 10/4/1999 17:47'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	| oldInstances |	oldInstances _ oldClass allInstances asArray.	self updateInstances: oldInstances from: oldClass isMeta: true.	"Now fix up instances in segments that are out on the disk."	ImageSegment allSubInstancesDo: [:seg |		seg segUpdateInstancesOf: oldClass toBe: self isMeta: true].! !!Project methodsFor: 'file in/out' stamp: 'tk 10/4/1999 19:20'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is response |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].is _ ImageSegment new copyFromRootsLocalFileFor: 	(Array with: world presenter with: world).	"world, and all Players"is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' not enough objects for a Segment.'; cr.	^ false].is extract; writeToFile: self name.^ true! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 10/4/1999 22:33'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities readServerUpdatesThrough: 828 saveLocally: false updateImage: true""Utilities readServerUpdatesThrough: 828 saveLocally: true updateImage: true"	| doc urls failed loaded str |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	Cursor wait showWhile: [(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: (Utilities serverUrls collect: [:url | url, 'updates/']) 				throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil:			[doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			doc class == String ifTrue: [failed _ this]].	"an error loading"		failed ifNil: [			doc reset; text.			doc size = 0 ifTrue: [failed _ this]].		failed ifNil: [			doc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage ifTrue:					[ChangeSorter newChangesFromStream: doc					named: (this findTokens: '/') last].			saveLocally ifTrue:				[self saveUpdate: doc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1]]].	str _ loaded printString ,' new update file(s) processed.'.	failed ifNotNil: [str _ str, '\Could not load ' withCRs, 		(urls size - loaded) printString ,' update file(s).',		'\Starting with "' withCRs, failed, '".'].	failed ifNil: [		"DocLibrary external ifNotNil: [			DocLibrary external updateMethodVersions] are not using this yet"].	self inform: str.! !ImageSegment removeSelector: #segUpdateInstancesOf:isMeta:!