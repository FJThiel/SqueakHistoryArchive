'From Squeak3.7beta of ''1 April 2004'' [latest update: #5923] on 1 October 2004 at 6:41:18 pm'!"Change Set:		FloatTest-additionalTestsDate:			14 September 2004Author:			Boris GaertnerThere was a question about equality of NaN values on the list. NaN values are always considered different from each other. This change set adds some test cases for NaN values to the existing class FloatTest. "!!FloatTest methodsFor: 'infinity behavior' stamp: 'BG 9/14/2004 19:07'!testInfinity1   "FloatTest new testInfinity1"  | i1  i2 |  i1 := 10000 exp.  i2 := 1000000000 exp.  self assert: i1 isInfinite & i2 isInfinite & (i1 = i2).  "  All infinities are equal. (This is a very substantial difference to NaN's, which are never equal.  "! !!FloatTest methodsFor: 'infinity behavior' stamp: 'BG 9/14/2004 19:10'!testInfinity2   "FloatTest new testInfinity2"  | i1  i2 |  i1 := 10000 exp.  i2 := 1000000000 exp.  i2 := 0 - i2. " this is entirely ok. You can compute with infinite values. "  self assert: i1 isInfinite & i2 isInfinite & i1 positive & i2 negative.  self deny: i1 = i2.  "  All infinities are signed. Negative infinity is not equal to Infinity  "! !!FloatTest methodsFor: 'NaN behavior' stamp: 'BG 9/14/2004 18:53'!testNaN1   "FloatTest new testNaN1"  self assert: Float nan == Float nan.  self deny: Float nan = Float nan.   " a NaN is not equal to itself. "! !!FloatTest methodsFor: 'NaN behavior' stamp: 'dtl 10/1/2004 18:26'!testNaN2	"Two NaN values are always considered to be different.	On an little-endian machine (32 bit Intel), Float nan is 16rFFF80000 16r00000000.	On a big-endian machine (PowerPC), Float nan is 16r7FF80000 16r00000000. Changing	the bit pattern of the first word of a NaN produces another value that is still	considered equal to NaN. This test should work on both little endian and big	endian machines. However, it is not guaranteed to work on future 64 bit versions	of Squeak, for which Float may have different internal representations."	"FloatTest new testNaN2"	| nan1 nan2 |	nan1 := Float nan copy.	nan2 := Float nan copy.	"test two instances of NaN with the same bit pattern"	self deny: nan1 = nan2.	self deny: nan1 == nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1.	"change the bit pattern of nan1"	self assert: nan1 size == 2.	self assert: (nan1 at: 2) = 0.	nan1 at: 1 put: (nan1 at: 1) + 999.	self assert: nan1 isNaN.	self assert: nan2 isNaN.	self deny: (nan1 at: 1) = (nan2 at: 1).	"test two instances of NaN with different bit patterns"	self deny: nan1 = nan2.	self deny: nan1 == nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1! !!FloatTest methodsFor: 'NaN behavior' stamp: 'BG 9/14/2004 18:57'!testNaN3   "FloatTest new testNaN3"    | set item identitySet |  set := Set new.  set add: (item := Float nan).  self deny: (set includes: item).  identitySet := IdentitySet new.  identitySet add: (item := Float nan).  self assert: (identitySet includes: item)." as a NaN is not equal to itself, it can not be retrieved from a set "! !!FloatTest methodsFor: 'NaN behavior' stamp: 'BG 9/14/2004 18:54'!testNaN4   "FloatTest new testNaN4"    | dict |  dict := Dictionary new.  dict at: Float nan put: #NaN.  self deny: (dict includes: Float nan)." as a NaN is not equal to itself, it can not be retrieved when it is used as a dictionary key "! !!FloatTest methodsFor: 'zero behavior' stamp: 'dtl 9/26/2004 10:19'!testZero1   "FloatTest new testZero1"  self assert: Float negativeZero = 0 asFloat.  self assert: (Float negativeZero at: 1) ~= (0 asFloat at: 1).  "  The negative zero has a bit representation that is different from the bit representation of the positive zero. Nevertheless, both values are defined to be equal. "! !!FloatTest reorganize!('testing - arithmetic' testDivide)('infinity behavior' testInfinity1 testInfinity2)('NaN behavior' testNaN1 testNaN2 testNaN3 testNaN4 testNaN5)('zero behavior' testIsZero testZero1)('testing - conversion' testStringAsNumber)!