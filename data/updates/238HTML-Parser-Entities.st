Object subclass: #HtmlEntity	instanceVariableNames: 'contents attribs '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!<html>When HtmlParser runs, it generates a tree whose nodes are in HtmlEntity's subclasses.  There is a separate class for most of the available elements in HTML, though some are grouped together under generic classes like HtmlBoldEntity.Methods of particular interest when modifying or adding subclasses are:<ul><li>initialize:<li>mayContain:<li>addToFormatter:</ul>!!HtmlEntity methodsFor: 'downloading' stamp: 'ls 7/29/1998 00:52'!downloadState: baseUrl	"download any state needed for full rendering.  eg, images need this"	! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrame	^false! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^false! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspect	"Open an HtmlEntityInspector on the receiver.	Use basicInspect to get a normal type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspectWithLabel: aLabel	"Open a HtmlEntityInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true withLabel: aLabel! !!HtmlEntity methodsFor: 'converting' stamp: 'djp 7/21/1998 11:58'!asHtml	| aStream |	aStream := WriteStream on: ''.	self printHtmlOn: aStream.	^aStream contents.! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:21'!add: anObject	"add an object to the receiver"	(anObject isKindOf: String)		ifTrue: [contents add: (HtmlTextEntity new text: anObject)]		ifFalse: [contents add: anObject]! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 13:51'!at: key put: anObject	self attributes ifNil: [self attributes: (HtmlAttributes new)].	(self attributes) at: key put: anObject! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:28'!attributes	^attribs ifNil: [attribs := HtmlAttributes new]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 15:01'!addToFormatter: aFormatter	"by default, just format our childer"	contents do: [ :e | e addToFormatter: aFormatter ]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 7/15/1998 18:31'!parsingFinished	"some entities need to make a final pass *after* parsing has finished and all the contents of each entity have been established; here is a place to do that"	contents do: [ :e | e parsingFinished ].! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:03'!addEntity: anEntity	"add an entity to the receiver"	contents add: anEntity! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:02'!contents	"return an ordered collection of this entity's contents"	^contents! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:37'!textualContents	"return a string with the concatenated contents of all textual sub-entities"	^String streamContents: [ :s |		contents do: [ :e | s nextPutAll: e textualContents ] ]! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'ls 7/31/1998 02:57'!initialize	contents _ OrderedCollection new.	attribs _ HtmlAttributes new.! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'djp 7/20/1998 20:52'!initialize: aTag	self initialize.	attribs _ HtmlAttributes newFrom: aTag attribs.! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isDefinitionListElement	"whether receiver can appear in a DefinitionList"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/16/1998 23:18'!isFormEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:54'!isHeadElement	"whether this can appear in a header"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:18'!isListElement	"is this an HtmlListElement, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:12'!isListItem	"is this an HtmlListItem, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	"whether this is an <option> entity"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isTextualEntity	"is receiver either text, or some low-level text-like entity such as <b> or <em>"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:09'!lint	^String streamContents: [ :s | self lint: s ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:37'!lint: aStream	"do a lint check, reporting to aStream"	self lintAttributes: aStream.	contents do: [ :c |		(c isComment not   and:  [ (self shouldContain: c) not ]) ifTrue: [ 			aStream nextPutAll: '<', self tagName, '> should not contain <', c tagName, '>'.			aStream cr. ] ].	contents do: [ :c  | c lint: aStream ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:07'!lintAttributes: aStream	"check that our attributes are okay.  Print any anomalies to aStream"	! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:03'!mayContain: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:01'!mayContainEntity: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:35'!shouldContain: anEntity	"whether, according to the HTML DTD, this element should actually contain anEntity.  Used for checking the quality of a pages HTML"	^self mayContain: anEntity! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:02'!tagName	"tag name for ourself"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/26/1998 19:59'!attributes: newAttributes	"set all of the attributes at once.  newAttributes should not be modified after passing it in"	^attribs _ newAttributes! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 02:55'!doesNotUnderstand: aMessage	"treat the message as an attribute name"	| selector |	selector _ aMessage selector.	selector asLowercase = selector ifFalse: [		"attribute accesses must be in all lowercase.  This should cut down on some false doesNotUnderstand: traps"		^super doesNotUnderstand: aMessage ].	selector numArgs == 0 ifTrue: [		"return the named attribute"		^self getAttribute: selector asString default: nil ].	selector numArgs == 1 ifTrue: [		"set the named attribute"		self setAttribute: (selector asString copyFrom: 1 to: (selector size-1)) to: aMessage argument.		^self ].	^super doesNotUnderstand: aMessage! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:20'!getAttribute: name	^self getAttribute: name  default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:52'!getAttribute: name  default: anObject	^self getAttribute: name  ifAbsent: [anObject]! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:51'!getAttribute: name  ifAbsent: aBlock	^attribs at: name ifAbsent: aBlock! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/17/1998 19:04'!name	^self getAttribute: 'name' default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 03:00'!setAttribute: name  to: value	"set the given attribute to the given value"	attribs at: name asLowercase  put: value! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/20/1998 21:12'!printHtmlOn: aStream	^self printHtmlOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/21/1998 17:43'!printHtmlOn: aStream indent: indent	aStream 		next: indent put: $ ;		nextPut: $<;		nextPutAll: self tagName asUppercase;		printHtml: self attributes;		nextPut: $>;		cr.	contents do: [ :entity | entity printHtmlOn: aStream indent: indent+3 ].	aStream		next: indent put: $ ;		nextPutAll: '</';		nextPutAll: self tagName asUppercase;		nextPut: $>;		cr.! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 6/25/1998 03:13'!printOn: aStream	^self printOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 8/11/1998 03:16'!printOn: aStream  indent: indent	aStream		next: indent put: $ ;		nextPut: $<;		print: self tagName.	self attributes associationsDo: [ :assoc |		aStream			space;			nextPutAll: assoc key;			nextPutAll: '=';			nextPutAll: assoc value ].	aStream		nextPut: $>;		cr.	contents do: [ :entity | entity printOn: aStream indent: indent+1 ].! !!HtmlEntity methodsFor: 'enumeration' stamp: 'ls 7/16/1998 23:17'!allSubentitiesDo: aBlock	"perform the block recursively on all sub-entities"	contents do: [ :e | 		aBlock value: e .		e allSubentitiesDo: aBlock.	].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlEntity class	instanceVariableNames: ''!!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 7/29/1998 01:27'!forTag: aTag	"create a new entity based on the given tag"	^self new initialize: aTag! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 13:17'!new	^super new initialize! !HtmlEntity subclass: #HtmlBlockEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlBlockEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!a moderately high level entitiy.  This includes P, FORM, and UL, among others!!HtmlBlockEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !HtmlBlockEntity subclass: #HtmlBlockQuote	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:27'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:26'!tagName	^'blockquote'! !!HtmlBlockQuote methodsFor: 'formatting' stamp: 'ls 7/17/1998 20:26'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.	formatter ensureNewlines: 1.! !HtmlEntity subclass: #HtmlBody	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlBody methodsFor: 'lint' stamp: 'ls 7/29/1998 00:24'!shouldContain: anEntity	"I don't *think* there are any elements that can be in both the header and the body..."	^anEntity isHeadElement not! !!HtmlBody methodsFor: 'testing' stamp: 'ls 7/4/1998 19:24'!mayContain: anEntity	"Body's can contain anything, so that even if we screw up the parsing, all the text will end up actually being included"	^true! !!HtmlBody methodsFor: 'testing' stamp: 'ls 6/25/1998 02:04'!tagName	^'body'! !HtmlBlockEntity subclass: #HtmlDefinitionList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!mayContain: anEntity	^anEntity isDefinitionListElement! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dl'! !!HtmlDefinitionList methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !HtmlEntity subclass: #HtmlDefinitionListElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlDefinitionListElement methodsFor: 'testing' stamp: 'ls 6/25/1998 02:19'!isDefinitionListElement	^true! !HtmlDefinitionListElement subclass: #HtmlDefinitionDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlDefinitionDefinition methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:12'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:20'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ] ! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:18'!tagName	^'dd'! !HtmlDefinitionListElement subclass: #HtmlDefinitionTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlDefinitionTerm methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:19'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dt'! !HtmlEntity subclass: #HtmlDocument	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlDocument commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entire HTML document.  It should have exactly two sub-entities when completed: a HEAD and a BODY!!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:57'!mayContain: anElement	^true 	"not strictly true, but it makes the parser simpler"! !!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:06'!tagName	^'html'! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:38'!addToBody: anObject	"add an object to the Body entity of the receiver"	self body add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:37'!addToHead: anObject	"add an object to the head entity of the receiver"	self head add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!body	^self contents at: 2! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!head	^self contents at: 1! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:25'!formattedText	"return a version of this document as a formatted Text"	| formatter |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	^formatter text ! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/29/1998 03:01'!formattedTextForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted Text (which includes links and such)"	| formatter text |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	text _ formatter text.	^text! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/14/1998 00:35'!formattedTextMorph	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter text textMorph |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	text _ formatter text .	textMorph _ TextMorph new initialize.	textMorph contentsWrapped: text.	^textMorph! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/16/1998 22:12'!formattedTextMorphForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter textMorph |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	textMorph _ formatter textMorph .	^textMorph! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HtmlDocument class	instanceVariableNames: ''!!HtmlDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 04:26'!emptyDocument	"return an empty document"	^super new add: HtmlHead new; add: HtmlBody new! !HtmlEntity subclass: #HtmlForm	instanceVariableNames: 'formEntities '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlForm methodsFor: 'testing' stamp: 'ls 7/4/1998 19:51'!isBlockElement	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/15/1998 00:24'!mayContain: anEntity	"allow anything.  People probably always put </form> anyway at the end of their forms.  And furthermore, it has no effect on the display, even if this is gotten wrong"	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/3/1998 23:30'!tagName	^'form'! !!HtmlForm methodsFor: 'formatting' stamp: 'ls 7/17/1998 00:26'!addToFormatter: formatter	formatter startForm: self.	super addToFormatter: formatter.	formatter currentFormData reset.	formatter endForm.! !!HtmlForm methodsFor: 'parsing' stamp: 'ls 7/16/1998 23:16'!parsingFinished	"figure out who our constituents are"	self allSubentitiesDo: [ :e |		e isFormEntity ifTrue: [ e form: self ] ].	super parsingFinished.	formEntities _ OrderedCollection new.	self allSubentitiesDo: [ :e |		(e isFormEntity and: [ e form == self ])			ifTrue: [ formEntities add: e ] ].! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!method	"method to submit with"	^self getAttribute: 'method' default: 'get'! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!url	"url to submit to"	^self getAttribute: 'action' default: nil.  ! !!HtmlForm methodsFor: 'access' stamp: 'ls 7/16/1998 23:29'!formEntities	^formEntities! !HtmlEntity subclass: #HtmlFormEntity	instanceVariableNames: 'form '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlFormEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!Abstract superclass for elements that only appear in forms!!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form	"return which form we are in"	^form! !!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form: aForm	"set which form we are part of"	form _ aForm! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/15/1998 00:22'!isFormEntity	^true! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/29/1998 00:15'!lint: aStream	form ifNil: [ aStream nextPutAll: '<', self tagName, '> not within a form'.		aStream cr. ].	super lint: aStream.! !HtmlFormEntity subclass: #HtmlButton	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!mayContain: anEntity	^false! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'button'! !HtmlEntity subclass: #HtmlFrame	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlFrame methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:25'!isFrame	^true! !!HtmlFrame methodsFor: 'formatting' stamp: 'ls 7/26/1998 21:53'!addToFormatter: formatter	| src |	src _ self getAttribute: 'src' default: nil.	formatter ensureNewlines: 1.	src ifNotNil: [ formatter startLink: src ].	formatter addString: 'frame '.	formatter addString: (self name ifNil: ['(unnamed)']).	src ifNotNil:  [ formatter endLink: src ].	formatter ensureNewlines: 1.! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!mayContain: anEntity	^false! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!tagName	^'frame'! !HtmlEntity subclass: #HtmlFrameSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlFrameSet methodsFor: 'lint' stamp: 'ls 7/29/1998 00:25'!shouldContain: anEntity	^anEntity isFrame or: [ anEntity isFrameSet ]! !!HtmlFrameSet methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/29/1998 00:26'!mayContain: anEntity	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/26/1998 21:45'!tagName	^'frameset'! !HtmlEntity subclass: #HtmlHead	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:03'!title	"return the title, or nil if there isn't one"	| te |	te _ self titleEntity.	te ifNil: [ ^nil ].	^te textualContents! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:02'!titleEntity	"return the title entity, or nil if there isn't one"	contents do: [ :e | e tagName = 'title' ifTrue: [ ^e ] ].	^nil! !!HtmlHead methodsFor: 'testing' stamp: 'ls 7/28/1998 20:25'!mayContain: anEntity	^anEntity isHeadElement or: [ anEntity isComment ]! !!HtmlHead methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'head'! !HtmlEntity subclass: #HtmlHeadEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlHeadEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!abstract superclass for entities that may appear in the HEAD section!!HtmlHeadEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 15:37'!isHeadElement	^true! !!HtmlHeadEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:38'!addToFormatter: formatter	"head elements are normally just meta-information, and thus don't add anything to the formatter"! !HtmlEntity subclass: #HtmlHeader	instanceVariableNames: 'level '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^true! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 6/27/1998 15:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/23/1998 05:42'!tagName	^'h', level printString! !!HtmlHeader methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:14'!addToFormatter: formatter	formatter ensureNewlines: 3.	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.	formatter ensureNewlines: 2.! !!HtmlHeader methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 05:42'!initialize: aTag	super initialize: aTag.	level _ aTag name last digitValue.! !HtmlEntity subclass: #HtmlHorizontalRule	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/27/1998 15:52'!mayContain: anEntity	^false! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'hr'! !!HtmlHorizontalRule methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:57'!addToFormatter: formatter	formatter hr! !HtmlFormEntity subclass: #HtmlInput	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlInput commentStamp: 'ls 9/8/1998 21:39' prior: 0!result of an <input> tag!!HtmlInput methodsFor: 'attributes' stamp: 'ls 7/16/1998 23:30'!defaultValue	^self getAttribute: 'value' default: ''! !!HtmlInput methodsFor: 'attributes' stamp: 'ls 7/23/1998 19:09'!type	^(self getAttribute: 'type' default: 'text') asLowercase! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:15'!isTextualEntity	^true! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!mayContain: anEntity	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/21/1998 06:51'!suppliesInput	"whether we actually have input to supply"	self type = 'text' ifTrue: [ ^true ].	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!tagName	^'input'! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 8/11/1998 20:47'!addRadioButtonToFormatter: formatter	| name formData checked buttonSet button buttonInput |	"dig up relevant attributes"	name _ self getAttribute: 'name'.	name ifNil: [ ^self ].	value _ self getAttribute: 'value'.	value ifNil: [ ^value ].		formData _ formatter currentFormData.	formData ifNil:  [ ^self ].	checked _ self getAttribute: 'checked'.	"find or create the set of buttons with our same name"	buttonSet _ formData inputs detect: [ :i | i isRadioButtonSetInput and: [ i name = name ] ] ifNone: [ nil ].	buttonSet ifNil: [ 		"create a new button set"		buttonSet _ RadioButtonSetInput name: name.		formData addInput: buttonSet. ].	"set up the form input"	buttonInput _ RadioButtonInput  inputSet: buttonSet value: value.	buttonSet addInput: buttonInput.	checked ifNotNil: [		buttonSet  defaultButton: buttonInput ].	"create the actual button"	button _ PluggableButtonMorph on: buttonInput getState: #pressed  action: #toggle.	button label: 'X'.	formatter addMorph: button.! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 8/11/1998 19:53'!addToFormatter: formatter	"is it a submit button?"	| inputMorph formData |	self type = 'submit' ifTrue: [		formatter addMorph: ((PluggableButtonMorph on: formatter currentFormData getState: nil action: #submit) label: (self getAttribute: 'value' default: 'Submit')).		^self ].	self type = 'image' ifTrue: [		"fake it"		value _ self getAttribute: 'value' default: 'Submit'.		formData _ formatter currentFormData.		formatter addMorph: ((PluggableButtonMorph on: formData getState: nil action: #submit) label: value).		formData addInput: (HiddenInput name: (value,'.x') value: '0').		formData addInput: (HiddenInput name: (value,'.y') value: '0').			^self ].	self type = 'text' ifTrue: [		inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.		inputMorph extent: 120@20.		formatter addMorph: inputMorph.		formatter currentFormData addInput: (TextInput name: self name  defaultValue: self defaultValue  textMorph: inputMorph).		^self ].	self type = 'hidden' ifTrue: [		formatter currentFormData addInput: (HiddenInput name: self name  value: self defaultValue).		^self ].	self type = 'radio' ifTrue: [ 		^self addRadioButtonToFormatter: formatter ].	formatter addString: '[form input of type: ', self type, ']'.! !HtmlBlockEntity subclass: #HtmlList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlList methodsFor: 'testing' stamp: 'ls 7/17/1998 19:20'!mayContain: anElement	"lists may only contain LI elements"	"^anElement isListItem"	"except that people write some sucky HTML out there!!!!  well, let's assume they always put the end tag.  Much safer assumption than that they only put list-items in their lists"	^true! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/28/1998 20:40'!shouldContain: anEntity	^anEntity isListItem! !HtmlEntity subclass: #HtmlListItem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:10'!isListItem	^true! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ]! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:09'!tagName	^'li'! !!HtmlListItem methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:49'!addToFormatter: formatter	formatter startListItem.	super addToFormatter: formatter.	formatter endListItem.! !HtmlHeadEntity subclass: #HtmlMeta	instanceVariableNames: 'theTag '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlMeta commentStamp: 'ls 9/8/1998 21:39' prior: 0!some result of a meta tag; unimplemented so far!!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!mayContain: anEntity	^false! !!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!tagName	^'meta'! !!HtmlMeta methodsFor: 'formatting' stamp: 'ls 8/12/1998 05:44'!addToFormatter: formatter	| httpEquiv |	httpEquiv _ self getAttribute: 'http-equiv'.	httpEquiv ifNil: [ ^self ].	httpEquiv asLowercase = 'refresh' ifTrue: [		formatter addString: '{refresh: ', (self getAttribute:  'content' default: ''), '}' ].! !!HtmlMeta methodsFor: 'initialization' stamp: 'ls 7/5/1998 02:23'!initialize: aTag	super initialize: aTag.	theTag _ aTag.! !!HtmlMeta methodsFor: 'printing' stamp: 'ls 7/5/1998 02:24'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: 'meta: '.	theTag printOn: aStream.	aStream cr.! !HtmlFormEntity subclass: #HtmlOption	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:19'!label	"label to be displayed for this morph"	^self getAttribute: 'label' ifAbsent: [self textualContents]! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 08:42'!value	"value to pass if this option is selected"	^self getAttribute: 'value' default: '(unspecified)'! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	^true! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'option'! !HtmlFormEntity subclass: #HtmlOptionGroup	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!mayContain: anEntity	^anEntity isOption! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'optgroup'! !HtmlList subclass: #HtmlOrderedList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlOrderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startOrderedList.	super addToFormatter: formatter.	formatter endOrderedList.! !!HtmlOrderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ol'! !HtmlEntity subclass: #HtmlParagraph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlParagraph methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:16'!addToFormatter: formatter	formatter ensureNewlines: 2.	super addToFormatter: formatter.! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!tagName	^'p'! !HtmlEntity subclass: #HtmlPreformattedRegion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlPreformattedRegion methodsFor: 'lint' stamp: 'ls 7/29/1998 00:27'!shouldContain: anEntity	^anEntity isTextualEntity! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!mayContain: anEntity	^true! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!tagName	^'pre'! !!HtmlPreformattedRegion methodsFor: 'formatting' stamp: 'ls 7/13/1998 23:15'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increasePreformatted.	super addToFormatter: formatter.	formatter decreasePreformatted.	formatter ensureNewlines: 1.! !HtmlFormEntity subclass: #HtmlSelect	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!isTextualEntity	^true! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^true  "end tag required"! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'select'! !!HtmlSelect methodsFor: 'formatting' stamp: 'ls 8/11/1998 03:12'!addToFormatter: formatter	| options defaultOption listMorph names |	names _ OrderedCollection new.	options _ OrderedCollection new.	defaultOption _ nil.	(self getAttribute: 'multiple') ifNotNil: [		self flag: #incomplete.		formatter addString: '[M option list]'.		^self ].	contents do: [ :c |  c isOption ifTrue: [		names add: c value.		options add: c label.		(c getAttribute: 'selected') ifNotNil: [ defaultOption _ c label ] ] ].	contents isEmpty ifTrue: [ ^self ].	defaultOption ifNil: [ defaultOption _ contents first ].	listMorph _ PluggableListMorph on: (ValueHolder new contents: (contents indexOf: defaultOption)) list: nil  selected: #contents  changeSelected: #contents:.	listMorph list: options.	formatter addMorph: listMorph.	formatter currentFormData addInput: (SelectionInput  name: self name  defaultValue: defaultOption  list: listMorph  values: names asArray)! !HtmlHeadEntity subclass: #HtmlStyle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!tagName	^'style'! !HtmlEntity subclass: #HtmlTable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!mayContain: anEntity	^anEntity isTableRow! !!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 19:07'!tagName	^'table'! !HtmlEntity subclass: #HtmlTableDataItem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTableDataItem methodsFor: 'formatting' stamp: 'ls 9/5/1998 03:37'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureSpaces: 1.! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^true! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:56'!mayContain: anEntity	^anEntity isTextualEntity or: [ anEntity isBlockEntity or: [ anEntity isHeader ] ]! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 19:01'!tagName	^'td'! !HtmlEntity subclass: #HtmlTableRow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTableRow methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:54'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^true! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!mayContain: anEntity	^anEntity isTableDataItem! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 19:00'!tagName	^'tr'! !HtmlFormEntity subclass: #HtmlTextArea	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:28'!isBlockEntity	"not sure...."	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/29/1998 00:28'!mayContain: anEntity	^true   "really we shouldn't be interpretting tags in here at all, though...."! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/17/1998 19:05'!suppliesInput	^self name ~= nil! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:40'!tagName	^'textarea'! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:17'!columns	| a |	a _ self getAttribute: 'cols' default: '70'.	^(Integer readFrom: (ReadStream on: a)) max: 5.! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:12'!defaultValue	^self textualContents  "it would be nice to through the tags in there, too....  Easiest way would probably be to modiy the tokenizer"! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:16'!rows	| a |	a _ self getAttribute: 'rows' default: '20'.	^(Integer readFrom: (ReadStream on: a)) max: 1.! !!HtmlTextArea methodsFor: 'formatting' stamp: 'ls 8/5/1998 08:50'!addToFormatter: formatter	| inputMorph |	formatter ensureNewlines: 1.	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	inputMorph extent: (self columns * 5) @ (self rows * 8).	formatter addMorph: inputMorph.	formatter currentFormData addInput: (TextInput name: self name  defaultValue:  self textualContents  textMorph: inputMorph).	formatter ensureNewlines: 1.! !HtmlEntity subclass: #HtmlTextualEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTextualEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!includes raw text, font-changing entities like <b> and <em>, and special entities like <a> and <img>.  All of these are relatively low level regarding formatting; they are superceded by higher level things like <li> and <p>.  When formatted, they flow around like characters.!!HtmlTextualEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!isTextualEntity	^true! !HtmlTextualEntity subclass: #HtmlCommentEntity	instanceVariableNames: 'commentText '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlCommentEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!a comment from the page!!HtmlCommentEntity methodsFor: 'private-iniitialization' stamp: 'ls 7/28/1998 20:28'!initializeWithText: aString	super initialize.	commentText _ aString.! !!HtmlCommentEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:30'!printOn: aStream  indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '<!!-- '.	aStream nextPutAll: self commentText.	aStream nextPutAll: ' -->'.	aStream cr.! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^true! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:27'!mayContain: anEntity	^false! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:30'!tagName		"return a bogus tag name"	^'x-comment'! !!HtmlCommentEntity methodsFor: 'formatting' stamp: 'ls 7/4/1998 12:27'!addToFormatter: formatter	"do nothing"! !!HtmlCommentEntity methodsFor: 'access' stamp: 'ls 7/4/1998 12:27'!commentText	^commentText! !HtmlTextualEntity subclass: #HtmlFontChangeEntity	instanceVariableNames: 'tagName '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlFontChangeEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entity whose effect is to change the font its constituents are displayed in in some way.  Multiple tags might generate almost any of the subclasses, so the tag name is stored explicitly.!!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 7/5/1998 01:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 12:51'!tagName	"must be stored in an i-var, because these classes work for different tags"	^tagName! !!HtmlFontChangeEntity methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:34'!initialize: aTag	super initialize: aTag.	tagName _ aTag name! !HtmlFontChangeEntity subclass: #HtmlBiggerFontEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlBiggerFontEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entity which supposedly increases the font size of its constituents!HtmlFontChangeEntity subclass: #HtmlBoldEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlBoldEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entity which displays its contents in boldface!!HtmlBoldEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 12:53'!addToFormatter: formatter	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.! !HtmlFontChangeEntity subclass: #HtmlFixedWidthEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlFixedWidthEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!An entity that (supposedly) displays its contents in a fixed-width font.  I don't know how to do this, though.  -ls!HtmlFontChangeEntity subclass: #HtmlFontEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlFontEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!the <font> tag.  it's here for future expansion....!HtmlFontChangeEntity subclass: #HtmlItalicsEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlItalicsEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entity which displays its contents in italics!!HtmlItalicsEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 13:16'!addToFormatter: formatter	formatter increaseItalics.	super addToFormatter: formatter.		formatter decreaseItalics.! !HtmlFontChangeEntity subclass: #HtmlSmallerFontEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlSmallerFontEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!supposedly decreases the font size its constituents are displayed in!HtmlTextualEntity subclass: #HtmlSpecialEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!HtmlSpecialEntity subclass: #HtmlAnchor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!tagName	^'a'! !!HtmlAnchor methodsFor: 'private-initialization' stamp: 'ls 7/1/1998 02:06'!initialize: aTag	super initialize: aTag.	href _ aTag attribs at: 'href' ifAbsent: [nil].! !!HtmlAnchor methodsFor: 'formatting' stamp: 'ls 7/31/1998 03:01'!addToFormatter: formatter	| href |	href _ self getAttribute: 'href'.	href isNil		ifTrue: [ super addToFormatter: formatter ]		ifFalse: [ 				formatter startLink: href.			super addToFormatter: formatter.			formatter endLink: href. ].! !HtmlSpecialEntity subclass: #HtmlBreak	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!mayContain: anEntity	^false! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!tagName	^'br'! !!HtmlBreak methodsFor: 'formatting' stamp: 'ls 7/17/1998 19:21'!addToFormatter: formatter	formatter addChar: Character cr.! !HtmlSpecialEntity subclass: #HtmlImage	instanceVariableNames: 'image '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlImage methodsFor: 'downloading' stamp: 'ls 8/8/1998 03:47'!downloadState: baseUrl 	|  sourceUrl imageSource |	image ifNil: [ 		sourceUrl _ self src.		sourceUrl ifNotNil: [ 			imageSource _ HTTPSocket httpGetDocument: (sourceUrl asUrlRelativeTo: baseUrl asUrl) toText.			imageSource contentType = 'image/gif'  ifTrue: [				[image _ (GIFReadWriter on: (RWBinaryOrTextStream with: imageSource content) reset binary) nextImage ]				ifError: [ :a :b |  "could not decode--ignore it"  image _ nil ] ].			 ] ].! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 8/4/1998 21:58'!alt	^(self getAttribute: 'alt') ifNil: ['[image]']! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 7/29/1998 00:56'!src	^self getAttribute: 'src' default: nil! !!HtmlImage methodsFor: 'formatting' stamp: 'ls 9/5/1998 18:17'!addToFormatter: formatter	| morph url |	self src isNil ifTrue: [ ^self ].	url _ self src.	formatter baseUrl ifNotNil: [ 		url _ url asUrlRelativeTo: formatter baseUrl ].	morph _ DownloadingImageMorph new.	morph altText: self alt.	morph url: url.	formatter addIncompleteMorph: morph.! !!HtmlImage methodsFor: 'initializing' stamp: 'ls 7/27/1998 02:17'!initialize: aTag		super initialize: aTag.! !!HtmlImage methodsFor: 'testing' stamp: 'ls 7/1/1998 02:30'!mayContain: anEntity	^false! !!HtmlImage methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'img'! !HtmlFontChangeEntity subclass: #HtmlStrikeEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlStrikeEntity commentStamp: 'ls 9/8/1998 21:39' prior: 0!the contents should be displayed struck-through!!HtmlStrikeEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 02:05'!addToFormatter: formatter	formatter increaseStrike.	super addToFormatter: formatter.	formatter decreaseStrike.! !HtmlFontChangeEntity subclass: #HtmlSubscript	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlSubscript commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entity to be displayed as a subscript!HtmlFontChangeEntity subclass: #HtmlSuperscript	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlSuperscript commentStamp: 'ls 9/8/1998 21:39' prior: 0!an entity whose contents are to be displayed as a superscript!HtmlTextualEntity subclass: #HtmlTextEntity	instanceVariableNames: 'text '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTextEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:38'!textualContents	^text! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:26'!mayContain: anEntity	^false! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!tagName	"bogus"	^'x-text'  ! !!HtmlTextEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:24'!addToFormatter: aFormatter	aFormatter addString: text! !!HtmlTextEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:28'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '['.	aStream nextPutAll: text.	aStream nextPutAll: ']'.	aStream cr.! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 6/25/1998 02:58'!text	^text! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 7/14/1998 23:58'!text: text0	text _ text0! !HtmlHeadEntity subclass: #HtmlTitle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!isHeadElement	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:36'!tagName	^'title'! !HtmlFontChangeEntity subclass: #HtmlUnderlineEntity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlUnderlineEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 01:41'!addToFormatter: formatter	formatter increaseUnderline.	super addToFormatter: formatter.		formatter decreaseUnderline.! !HtmlList subclass: #HtmlUnorderedList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Parser-Entities'!!HtmlUnorderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startUnorderedList.	super addToFormatter: formatter.	formatter endUnorderedList.! !!HtmlUnorderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ul'! !