'From Squeak2.7 of 4 January 2000 [latest update: #1761] on 5 January 2000 at 4:57:18 pm'!"Change Set:		doitTemps-tkMSDate:			3 January 2000Author:			Ted Kaehler[fix] When you do a doIt in an Inspector or Debugger pane, and temps need to be defined, it sometimes puts temps in the wrong place.  It tries to put the '| temp |' after the method name even though there is none in a doIt.  Fixed."!DataStream subclass: #ReferenceStream	instanceVariableNames: 'references objects currentReference fwdRefEnds blockers skipping '	classVariableNames: 'RefTypes '	poolDictionaries: ''	category: 'System-Object Storage'!!AlignmentMorph methodsFor: 'object fileIn' stamp: 'tk 1/3/2000 16:07'!convertbosfcebbochvimol0: varDict bosfcebbochvimolp0: smartRefStrm	"These variables are automatically stored into the new instance ('orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'openToDragNDrop' 'layoutNeeded' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('priorFullBounds' )  If a non-nil value is needed, please assign it."! !!CodeHolder methodsFor: 'object fileIn' stamp: 'tk 1/3/2000 15:59'!convertdcs0: varDict dcsc0: smartRefStrm	"These variables are automatically stored into the new instance ('showDiffs' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('currentCompiledMethod' )  If a non-nil value is needed, please assign it."! !!DataStream reorganize!('write and read' beginInstance:size: beginReference: getCurrentReference maybeBeginReference: next nextPut: nextPutAll: noteCurrentReference: objectAt: objectIfBlocked: outputReference: rTetraByteArray readArray readBitmap readBoolean readByteArray readClass readFalse readFloat readFloatString readInstance readInteger readNil readRectangle readReference readShortInst readShortRef readString readStringOld readSymbol readTrue readUser setCurrentReference: tryToPutReference:typeID: typeIDFor: writeArray: writeBitmap: writeBoolean: writeByteArray: writeClass: writeFalse: writeFloat: writeFloatString: writeInstance: writeInteger: writeNil: writeRectangle: writeString: writeStringOld: writeSymbol: writeTrue: writeUser:)('other' atEnd byteStream close errorWriteReference: flush next: nextAndClose reset rootObject rootObject: setStream: setStream:reading: size vacantRef)!!DataStream methodsFor: 'write and read' stamp: 'tk 1/5/2000 11:47'!readReference	"Read the contents of an object reference. (Cf. outputReference:)  File is not now positioned at this object."	| referencePosition |	^ (referencePosition _ (byteStream nextNumber: 4)) = self vacantRef	"relative"		ifTrue:  [nil]		ifFalse: [self objectAt: referencePosition]		"relative pos"! !!Parser methodsFor: 'expression types' stamp: 'tk 1/3/2000 13:56'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [requestor				ifNil: [tempsMark _ 1]				ifNotNil: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ prevMark + prevToken.		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!ReferenceStream commentStamp: 'tk 1/3/2000 21:11' prior: 0!This is a way of serializing a tree of objects into disk file. A ReferenceStream can storeone or more objects in a persistent form, including sharing and cycles.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.ReferenceStreams can now write "weak" references. nextPutWeak:writes a "weak" reference to an object, which refers to that object*if* it also gets written to the stream by a normal nextPut:.A ReferenceStream should be treated as a read-stream *or* as a write-stream, *not* as a read/write-stream. The reference-remembering mechanism would probably do bad things if you tried to read and write from the same ReferenceStream.[TBD] Should we override "close" to do (self forgetReferences)?Instance variables references -- an IdentityDictionary mapping objects already written	to their byteStream positions. If asked to write any object a	second time, we just write a reference to its stream position.	This handles shared objects and reference cycles between objects.	To implement "weak references" (for Aliases), the references	dictionary also maps objects not (yet?) written to a Collection	of byteStream positions with hopeful weak-references to it. If	asked to definitely write one of these objects, we'll fixup those	weak references. objects -- an IdentityDictionary mapping relative byte stream positions to	objects already read in. If asked to follow a reference, we	return the object already read.	This handles shared objects and reference cycles between objects. currentReference -- the current reference position. Positon relative to the 	start of object data in this file.  (Allows user to cut and paste smalltalk 	code from the front of the file without effecting the reference values.)  	This variable is used to help install each new object in "objects" as soon	as it's created, **before** we start reading its contents, in	case any of its content objects reference it. fwdRefEnds -- A weak reference can be a forward reference, which	requires advance-reading the referrent. When we later come to the	object, we must get its value from "objects" and not re-read it so	refs to it don't become refs to copies. fwdRefEnds remembers the	ending byte stream position of advance-read objects.If the object is referenced before it is done being created, it might get created twice.  Just store the object the moment it is created in the 'objects' dictionary.  If at the end, comeFullyUpOnReload returns a different object, some refs will have the temporary object (this is an unlikely case).  At the moment, no implementor of comeFullyUpOnReload returns a different object except DiskProxy, and that is OK.!!ReferenceStream methodsFor: 'writing' stamp: 'tk 1/5/2000 13:05'!setStream: aStream	"PRIVATE -- Initialization method."	super setStream: aStream.	references _ IdentityDictionary new: 4096 * 5.	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new.	skipping _ false.	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 1/5/2000 13:06'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		skipping _ false.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream methodsFor: 'reading' stamp: 'tk 1/5/2000 16:55'!beginReference: anObject	"Remember anObject as the object we read at the position recorded by	 noteCurrentReference:. This must be done after instantiating anObject but	 before reading any of its contents that might (directly or indirectly) refer to	 it. (It's ok to do this redundantly, which is convenient for #next.)	 Answer the reference position."	objects at: currentReference ifAbsent: [		objects at: currentReference put: anObject.		^ currentReference].	skipping ifFalse: ["If reading just to skip it, don't record this copy."			objects at: currentReference put: anObject].	^ currentReference		"position relative to start of data portion of file"! !!ReferenceStream methodsFor: 'reading' stamp: 'tk 1/5/2000 13:07'!next	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."	| curPosn skipToPosn haveIt theObject fake wasSkipping |	haveIt _ true.	curPosn _ byteStream position - basePos.	theObject _ objects at: curPosn ifAbsent: [haveIt _ false].		"probe in objects is done twice when coming from objectAt:.  This is OK."	skipToPosn _ fwdRefEnds at: curPosn ifAbsent: [nil].	haveIt 		ifFalse: [^ super next]		ifTrue: [skipToPosn 				ifNotNil: ["Skip over the object and return the already-read-in value."					byteStream position: skipToPosn + basePos]	"make absolute"				ifNil: ["File is not positioned correctly.  Read object and throw it away."					wasSkipping _ skipping.					skipping _ true.					fake _ super next.					skipping _ wasSkipping].			^ theObject].! !!Slider methodsFor: 'object fileIn' stamp: 'tk 1/3/2000 16:02'!convertbosfcebbmsosvss0: varDict bosfcebbmsosvsss0: smartRefStrm	"These variables are automatically stored into the new instance ('slider' 'value' 'setValueSelector' 'sliderShadow' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('sliderColor' )  If a non-nil value is needed, please assign it."! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 1/3/2000 16:01'!writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList	"No method sel was found in newClass.  Ask user to look for the fileIn.  Or help by writing a prototype conversion method.  "| tell choice code keywords newOthers oldOthers copied skip |choice _ 2.skip _ (byteStream isKindOf: RWBinaryOrTextStream) and: [byteStream position = 0].skip ifFalse: [	"an actual file read"	newClass name = oldName 		ifTrue: [tell _ 'The class ', oldName]		ifFalse: [tell _ 'An instance of ', oldName, ' is coming in as an ', newClass name, '.  It'].tell _ tell, ' has different instance variables than before.  It needs a conversion method.  You may:'.choice _ (PopUpMenu labels: 'Find a conversion file on the disk and file it inWrite a conversion method by editing a prototype') startUpWithCaption: tell. ].choice = 1 ifTrue: [PopUpMenu notify: 'After filing in the conversion file, please read-in the object file again.'].	"you need to restart the read-in"choice = 2 ifTrue: [	code _ WriteStream on: (String new: 500).	keywords _ sel keywords.	code nextPutAll: (keywords at: 1); nextPutAll: ' varDict '; 			nextPutAll: (keywords at: 2); nextPutAll: ' smartRefStrm'; cr; tab.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code nextPutAll: '"These variables are automatically stored into the new instance '.	code nextPutAll: copied asArray printString; nextPut: $. .	code cr; tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; cr; cr; tab.	(newOthers size = 0) & (oldOthers size = 0) 		ifTrue: [code nextPutAll: '"Instance variables are the same.  Only the order changed.  This method should work as written."'].	(newOthers size > 0) ifTrue: [code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withCRs].	(oldOthers size > 0) ifTrue: [code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in another variable?"'].	newClass compile: code contents classified: 'object fileIn'.	skip ifFalse: [		PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'].	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !