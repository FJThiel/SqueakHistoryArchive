'From Squeak 2.4c of May 10, 1999 on 16 July 1999 at 1:30:19 pm'!"Change Set:		scriptingFixes-swDate:			15 July 1999Author:			Scott Wallace1.  Fixes up the step methods of half a dozen morphs which did not call 'super step'; with this fix, those kinds of morphs can both function in the way they expect to and also obey any scripting commands.2.  Fixes the bug that made the penColor readout in a viewer for a rotated object not be hooked up properly.3.  Bulletproofs TransformationMorph.printOn: against the situation where the transformation has no submorphs (it happens -- indeed it happened when debugging the previous item.)4.  When updating a flap-based viewer after some external change, gets its header right.5.  Fixes the bug that when a morph got flexed the external name of the original got set to the string 'nil'."!!Morph methodsFor: 'naming' stamp: 'sw 7/15/1999 14:46'!setNameTo: aName	self setNamePropertyTo: (aName ifNotNil: [aName asString])	"no Texts here!!"! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'sw 7/15/1999 07:32'!step	"Bounce those atoms!!"	| r bounces |	super step.	bounces _ 0.	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces _ bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 7/15/1999 13:57'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: scriptedPlayer costume renderedMorph;		getSelector: (ScriptingSystem getterSelectorFor: partName);		borderWidth: 1;		extent:  22@22.		putSelector == #unused ifFalse: [readout putSelector: (ScriptingSystem setterSelectorFor: partName)]].	readout ifNil: [readout _ scriptedPlayer costume updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!Presenter methodsFor: 'viewer' stamp: 'sw 7/15/1999 14:33'!updateViewer: aViewer forceToShow: aCategory	| aPlayer aPosition newViewer oldOwner wasSticky barHeight |	aPlayer _ aViewer scriptedPlayer.	aPosition _ aViewer position.	wasSticky _ aViewer isSticky.	newViewer _ aViewer species new visible: false.	barHeight _ aViewer submorphs first orientation == #vertical		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton.	wasSticky ifTrue: [newViewer beSticky].	oldOwner _ aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer obtainBankInfoFrom: aViewer forceToShow: aCategory.	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world startSteppingSubmorphsOf: newViewer.	newViewer layoutChanged! !!StandardViewer methodsFor: 'as yet unclassified' stamp: 'sw 7/15/1999 14:31'!hasDismissButton	| firstSub firstSubFirstSub |	^ (((submorphs size > 0) and: [(firstSub _ self firstSubmorph) submorphs size > 0])		and: [(firstSubFirstSub _ firstSub firstSubmorph) isKindOf: SimpleButtonMorph])			and: [firstSubFirstSub actionSelector == #dismiss]! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 7/14/1999 16:49'!printOn: aStream	super printOn: aStream.	submorphs size > 0		ifFalse:			[aStream nextPutAll: ' with no transformee!!']		ifTrue:			[aStream nextPutAll: ' on ', submorphs first printString]! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/15/1999 07:27'!step	| newString enablement |	super step.	wordingProvider ifNotNil:		[newString _ wordingProvider perform: wordingSelector.		newString = contents ifFalse: [self contents: newString].		enablementSelector ifNotNil:			[enablement _ wordingProvider perform: enablementSelector.			enablement == isEnabled ifFalse:				[self isEnabled: enablement]]]! !!UpdatingRectangleMorph methodsFor: 'stepping' stamp: 'sw 7/15/1999 07:27'!step	| s |	super step.	s _ self readFromTarget.	s = contents ifFalse:		[self contents: s.		self color: s]! !!UpdatingSimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/15/1999 07:27'!step	| newString |	super step.	newString _ wordingProvider perform: wordingSelector.	newString = self label ifFalse: [self labelString: newString; changed].! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 7/15/1999 07:28'!step	| s |	super step.	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingThreePhaseButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/15/1999 07:28'!step	| newBoolean |	super step.	state == #pressed ifTrue: [^ self].	newBoolean _ target perform: getSelector.	newBoolean == self isOn		ifFalse:			[self state: (newBoolean ifTrue: [#on] ifFalse: [#off])]! !