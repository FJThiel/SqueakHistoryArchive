'From Squeak2.8alpha of 4 February 2000 [latest update: #2210] on 1 June 2000 at 1:05:26 pm'!"Change Set:		085MenuRef-smaDate:			1 Juni 2000Author:			Stefan Matthias Aust[Version 2]Menu refactorings. I always wanted keyboard support for PopupMenus.  Now it is implemented.  See PopUpMenu>>readKeyboard for details.  I also heavily refactored PopUpMenu and SelectionMenu, adding reformating, add comments and removing complexity.  This is only for MVC."!!Object methodsFor: 'error handling' stamp: 'sma 5/28/2000 15:48'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ PopUpMenu confirm: queryString! !!Object methodsFor: 'error handling' stamp: 'sma 5/28/2000 15:55'!confirm: aString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	^ PopUpMenu confirm: aString orCancel: cancelBlock! !!Object methodsFor: 'user interface' stamp: 'sma 5/28/2000 15:59'!inform: aString	"Display a message for the user to read and then dismiss. 6/9/96 sw"	aString isEmptyOrNil ifFalse: [PopUpMenu inform: aString]! !!InputSensor methodsFor: 'mouse' stamp: 'sma 5/28/2000 12:04'!waitButtonOrKeyboard	"Wait for the user to press either any mouse button or any key.	Answer the current cursor location or nil if a keypress occured."	[self anyButtonPressed] whileFalse:		[(Delay forMilliseconds: 50) wait.		self keyboardPressed ifTrue: [^ nil]].	^ self cursorPoint! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:44'!center	"Answer the point at the center of the receiver's rectangular area."	^ frame center! !!PopUpMenu methodsFor: 'accessing' stamp: 'di 4/20/1999 14:33'!frameHeight	"Designed to avoid the entire frame computation (includes MVC form),	since the menu may well end up being displayed in Morphic anyway."	| nItems |	frame ifNotNil: [^ frame height].	nItems _ 1 + (labelString occurrencesOf: Character cr).	^ (nItems * MenuStyle lineGrid) + 4 "border width"! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!labelString	^ labelString! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!lineArray	^ lineArray! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 12:32'!nItems	^ (labelString occurrencesOf: Character cr) + 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 13:04'!controlActivity	"Do whatever a menu must do - now with keyboard support."	| didNotMove downPos |	didNotMove _ true.	Sensor anyButtonPressed		ifFalse:			[didNotMove _ false.			Sensor waitButtonOrKeyboard]. 		Sensor keyboardPressed ifFalse: [self manageMarker].	(didNotMove and: [selection = 0])		ifTrue:			[downPos _ Sensor cursorPoint.			[didNotMove and: [Sensor anyButtonPressed]]				whileTrue:					[(downPos dist: Sensor cursorPoint) < 2 ifFalse: [didNotMove _ false]].			didNotMove ifTrue: [Sensor waitButtonOrKeyboard]].	[Sensor keyboardPressed] whileTrue:		[self readKeyboard ifTrue: [^ self].		Sensor waitButtonOrKeyboard].	[Sensor anyButtonPressed] whileTrue: [self manageMarker]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 10:55'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch _ Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch _ ch asCharacter asLowercase.	labels _ labelString findTokens: Character cr asString.	occurences _ 0.	1 + selection to: selection + labels size do:		[:index |		| i | i _ index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences _ occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 12:11'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location].	Smalltalk isMorphic		ifTrue:			[selection _ Cursor normal showWhile:				[(MVCMenuMorph from: self title: captionOrNil) invokeAt: location in: World].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!PopUpMenu methodsFor: 'displaying' stamp: 'sw 12/10/1999 09:55'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta _ 0 - frame width @ delta y].	frame _ frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm _ captionText form.		captionBox _ captionForm boundingBox expandBy: 4.		captionBox _ captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave _ Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 5/28/2000 15:27'!markerOff	"No item is selected. Reverse the highlight if any item has been marked 	as selected."	self setSelection: 0! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 6/1/2000 13:01'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection > 0 ifTrue: [Display reverse: marker].						marker _ 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection _ marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'private' stamp: 'sma 6/1/2000 12:59'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset _ 4@4.	paraForm _ (DisplayText text: labelString asText textStyle: MenuStyle) form.	menuForm _ Form extent: paraForm extent + (borderInset * 2).	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame _ Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection _ 1.	^ form _ menuForm! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 5/28/2000 12:27'!selection	"Answer the current selection."	^ selection! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 6/1/2000 11:01'!setSelection: index	| newSelection |	selection = index ifTrue: [^ self].	newSelection _ (0 max: index) min: frame height // marker height.	selection > 0 ifTrue: [Display reverse: marker].	marker _ marker translateBy: 0 @ (newSelection - selection * marker height).	selection _ newSelection.	selection > 0 ifTrue: [Display reverse: marker]! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:44'!labelArray: labelArray	"Answer an instance of me whose items are in labelArray."	^ self labelArray: labelArray lines: nil! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:43'!labelArray: labelArray lines: lineArray	"Answer an instance of me whose items are in labelArray, with lines 	drawn after each item indexed by anArray. 2/1/96 sw"	labelArray isEmpty ifTrue: [self error: 'Menu must not be zero size'].	^ self		labels: (String streamContents: 			[:stream |			labelArray do: [:each | stream nextPutAll: each; cr].			stream skip: -1 "remove last CR"])		lines: lineArray"Example:	(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #()) startUp"! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:36'!labels: aString	"Answer an instance of me whose items are in aString."	^ self labels: aString lines: nil! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:48'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"PopUpMenu confirm: 'Are you hungry?'"	^ self confirm: queryString trueChoice: 'Yes' falseChoice: 'No'! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:54'!confirm: queryString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"	| menu choice |	menu _ self labelArray: {'Yes'. 'No'. 'Cancel'}.	choice _ menu startUpWithCaption: queryString.	choice = 1 ifTrue: [^ true].	choice = 2 ifTrue: [^ false].	^ cancelBlock value! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:46'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice	"Put up a yes/no menu with caption queryString. The actual wording 	for the two choices will be as provided in the trueChoice and 	falseChoice parameters. Answer true if the response is the true-choice, 	false if it's the false-choice.	This is a modal question -- the user must respond one way or the other."	"PopUpMenu 		confirm: 'Are you hungry?'		trueChoice: 'yes, I''m famished'		falseChoice: 'no, I just ate'"	| menu choice |	menu _ self labelArray: {trueChoice. falseChoice}.	[(choice _ menu startUpWithCaption: queryString) isNil] whileTrue.	^ choice = 1! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:57'!inform: aString	"PopUpMenu inform: 'I like Squeak'"	(PopUpMenu labels: ' OK ') startUpWithCaption: aString! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:57'!notify: message	"Deprecated. Use #inform: instead."	self inform: message! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections	^ selections! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections: selectionArray	selections _ selectionArray! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object 	the selector corresponding to the menu item selected by the user. Return 	nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"Example:	(SelectionMenu labels: 'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!startUpWithCaption: captionOrNil at: location	"Overridden to return value returned by manageMarker."	| index |	index _ super startUpWithCaption: captionOrNil at: location.	(selections = nil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList	^ self labelArray: labelList! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList lines: lines	^ self labelArray: lines lines: lines! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList lines: lines selections: selections	^ (self labelArray: labelList lines: lines) selections: selections! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList selections: selections	^ self		labelList: labelList		lines: #()		selections: selections! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:09'!labels: labels lines: linesArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string 	with embedded CRs, or a collection of strings."	(labels isKindOf: String)		ifTrue: [^ super labels: labels lines: linesArray]		ifFalse: [^ super labelArray: labels lines: linesArray]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:09'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	^ (self labels: labels lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!labels: labels selections: selectionsArray	"Answer an instance of me whose items are in labels, recording 	the given array of selections corresponding to the items in labels."	^ self		labels: labels		lines: #()		selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray	"Answer an instance of me whose labels and selections are identical."	^ self selections: selectionsArray lines: nil! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray lines: linesArray	"Answer an instance of me whose labels and selections are identical."	^ self		labelList: (selectionsArray collect: [:each | each asString])		lines: linesArray		selections: selectionsArray! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:14'!selections: selList emphases: emphList	"Answer an instance of the receiver with the given selections and 	emphases."	^ (self selections: selList) emphases: emphList"Example:	(EmphasizedMenu		selections: #('how' 'well' 'does' 'this' 'work?') 		emphases: #(bold plain italic struckOut plain)) startUp"! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sma 5/28/2000 16:16'!example1	"EmphasizedMenu example1"	^ (self		selections: #('how' 'well' 'does' 'this' 'work?' ) 		emphases: #(#bold #plain #italic #struckOut #plain ))			startUpWithCaption: 'A Menu with Emphases'! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sma 5/28/2000 16:17'!example3	"EmphasizedMenu example3"	^ (self		selectionAndEmphasisPairs: #('how' #bold 'well' #plain 'does' #italic 'this' #struckOut 'work' #plain))		startUpWithCaption: 'A Menu with Emphases'! !!EmphasizedMenu class reorganize!('instance creation' selectionAndEmphasisPairs: selections:emphases:)('examples' example1 example2 example3)!SelectionMenu class removeSelector: #confirm:!SelectionMenu class removeSelector: #confirm:trueChoice:falseChoice:!!SelectionMenu reorganize!('accessing' selections selections:)('basic control sequence' invokeOn: startUpWithCaption:at:)!!PopUpMenu class reorganize!('class initialization' initialize setMenuFontTo:)('instance creation' labelArray: labelArray:lines: labels: labels:lines:)('dialogs' confirm: confirm:orCancel: confirm:trueChoice:falseChoice: inform: notify:)!PopUpMenu removeSelector: #setMarker:!!PopUpMenu reorganize!('accessing' center frameHeight labelString lineArray nItems)('basic control sequence' controlActivity readKeyboard startUp startUpCenteredWithCaption: startUpSegmented:withCaption:at: startUpWithCaption: startUpWithCaption:at:)('displaying' displayAt:withCaption:during:)('marker adjustment' manageMarker markerOff markerOn: markerTop: scrollIntoView:)('private' computeForm computeLabelParagraph labels:font:lines: menuForm rescan)('selecting' selection setSelection:)!