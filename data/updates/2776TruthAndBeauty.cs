'From Squeak2.9alpha of 13 June 2000 [latest update: #2810] on 5 October 2000 at 12:00:04 pm'!"Change Set:		TruthAndBeautyDate:			5 October 2000Author:			Andreas RaabThe first wave of some new event guts. Installs everything necessary to get us running under the new regime. Cleanup and some other parts will follow shortly."!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab currentCommand worldUnderCursor eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent '	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!MenuMorph subclass: #MVCMenuMorph	instanceVariableNames: 'done mvcSelection '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!AlignmentMorph subclass: #MenuMorph	instanceVariableNames: 'defaultTarget lastSelection stayUp originalEvent popUpOwner activeSubMenu selectedItem '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!!MenuMorph commentStamp: '<historical>' prior: 0!Instance variables:	defaultTarget 	<Object>				The default target for creating menu items	selectedItem		<MenuItemMorph> 	The currently selected item in the receiver	stayUp 			<Boolean>			True if the receiver should stay up after clicks	popUpOwner 	<MenuItemMorph>	The menu item that automatically invoked the receiver, if any.	activeSubMenu 	<MenuMorph>		The currently active submenu.!Morph subclass: #ModalShellMorph	instanceVariableNames: 'primaryMouseReceiver '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!ModalShellMorph commentStamp: '<historical>' prior: 0!A modal shell acts as the root of a set of morphs that should be treated as modal to the rest of the world.Instance variables:	primaryMouseReceiver	<Morph>	The morph responsible for handling any unhandled mouse clicks.!MessageSend subclass: #MorphicAlarm	instanceVariableNames: 'scheduledTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!Object subclass: #MorphicEvent	instanceVariableNames: 'type cursorPoint buttons keyValue sourceHand '	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Events'!Object subclass: #MorphicEventDispatcher	instanceVariableNames: 'lastType lastDispatch '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!MorphicEventDispatcher commentStamp: '<historical>' prior: 0!The class represents a strategy for dispatching events to some immediate child of a morph. It is used by morphs to delegate the somewhat complex action of dispatching events accurately. !MorphicEvent subclass: #MorphicSoundEvent	instanceVariableNames: 'sound '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown firstClickUp firstClickTime clickSelector dblClickSelector dblClickTime dragSelector dragThreshold '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!MouseClickState commentStamp: '<historical>' prior: 0!MouseClickState is a simple class managing the distinction between clicks, double clicks, and drag operations. It has been factored out of HandMorph due to the many instVars.Instance variables:	clickClient 	<Morph>		The client wishing to receive #click:, #dblClick:, or #drag messages	clickState 	<Symbol>	The internal state of handling the last event (#firstClickDown, #firstClickUp, #firstClickTimedOut)	firstClickDown 	<MorphicEvent>	The #mouseDown event after which the client wished to receive #click: or similar messages	firstClickUp 	<MorphicEvent>	The first mouse up event which came in before the double click time out was exceeded (it is sent if there is a timout after the first mouse up event occured)	firstClickTime 	<Integer>	The millisecond clock value of the first event	clickSelector 	<Symbol>	The selector to use for sending #click: messages	dblClickSelector 	<Symbol>	The selector to use for sending #doubleClick: messages	dblClickTime 	<Integer>	Timout in milliseconds for a double click operation	dragSelector 	<Symbol>	The selector to use for sending #drag: messages	dragThreshold 	<Integer>	Threshold used for determining if a #drag: message is sent (pixels!!)!Object subclass: #MouseOverHandler	instanceVariableNames: 'mouseOverMorphs enteredMorphs overMorphs leftMorphs isDrag '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!Object subclass: #NewMorphicEvent	instanceVariableNames: 'timeStamp source '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!NewMorphicEvent commentStamp: '<historical>' prior: 0!This class represents the base for all events.Instance variables:	stamp	<Integer>	The millisecond clock time stamp (based on Time millisecondClock)	source	<Hand | nil>	If non-nil the hand that generated the event.!NewMorphicEvent subclass: #DropEvent	instanceVariableNames: 'position contents wasHandled '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!PolygonMorph subclass: #BalloonMorph	instanceVariableNames: 'target offsetFromTarget balloonOwner '	classVariableNames: 'BalloonFont '	poolDictionaries: ''	category: 'Morphic-Widgets'!StringMorph subclass: #MenuItemMorph	instanceVariableNames: 'isInTransition isEnabled subMenu isSelected target selector arguments '	classVariableNames: 'SubMenuMarker '	poolDictionaries: ''	category: 'Morphic-Menus'!!MenuItemMorph commentStamp: '<historical>' prior: 0!I represent an item in a menu.Instance variables:	isEnabled 	<Boolean>	True if the menu item can be executed.	subMenu 	<MenuMorph | nil>	The submenu to activate automatically when the user mouses over the item.	isSelected 	<Boolean>	True if the item is currently selected.	target 		<Object>		The target of the associated action.	selector 	<Symbol>	The associated action.	arguments 	<Array>		The arguments for the associated action.!NewMorphicEvent subclass: #UserInputEvent	instanceVariableNames: 'type buttons position handler wasHandled '	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Events'!UserInputEvent subclass: #KeyboardEvent	instanceVariableNames: 'keyValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!UserInputEvent subclass: #MouseEvent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!MouseEvent subclass: #MouseButtonEvent	instanceVariableNames: 'whichButton '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!MouseEvent subclass: #MouseMoveEvent	instanceVariableNames: 'startPoint trail '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!Object methodsFor: 'testing' stamp: 'ar 9/13/2000 15:37'!isMorphicEvent	^false! !!BitBlt methodsFor: 'accessing' stamp: 'ar 10/4/2000 16:37'!clipRect: aRectangle 	"Set the receiver's clipping area rectangle to be the argument, aRectangle."	clipX _ aRectangle left truncated.	clipY _ aRectangle top truncated.	clipWidth _ aRectangle right truncated - clipX.	clipHeight _ aRectangle bottom truncated - clipY.! !!Collection methodsFor: 'converting' stamp: 'ar 9/22/2000 10:12'!asIdentitySet	^(IdentitySet new: self size) addAll: self; yourself! !!FXBlt methodsFor: 'accessing' stamp: 'ar 10/4/2000 16:37'!clipRect: aRectangle 	"Set the receiver's clipping area rectangle to be the argument, aRectangle."	clipX _ aRectangle left truncated.	clipY _ aRectangle top truncated.	clipWidth _ aRectangle right truncated - clipX.	clipHeight _ aRectangle bottom truncated - clipY.! !!Heap methodsFor: 'private' stamp: 'ar 9/15/2000 17:12'!privateRemoveAt: index	"Remove the element at the given index and make sure the sorting order is okay"	| removed |	removed _ array at: index.	array at: index put: (array at: tally).	array at: tally put: nil.	tally _ tally - 1.	index > tally ifFalse:[		"Use #downHeapSingle: since only one element has been removed"		self downHeapSingle: index].	^removed! !!IdentitySet methodsFor: 'converting' stamp: 'ar 9/22/2000 10:13'!asIdentitySet	^self! !!ImageSegment methodsFor: 'testing' stamp: 'ar 9/14/2000 16:47'!findOwnerMap: morphs	| st |	"Construct a string that has a printout of the owner chain for every morph in the list.  Need it as a string so not hold onto them."st _ ''.morphs do: [:mm |	(st includesSubString: mm printString) ifFalse: [		st _ st, '', mm allOwners printString]].Smalltalk at: #Owners put: st.! !!Morph methodsFor: 'classification' stamp: 'ar 9/15/2000 17:56'!isBalloonHelp	^false! !!Morph methodsFor: 'classification' stamp: 'ar 10/3/2000 18:11'!isModalShell	^false! !!Morph methodsFor: 'copying' stamp: 'ar 9/15/2000 20:45'!duplicate	"Make and return a duplicate of the receiver"	| newMorph aName |	self okayToDuplicate ifFalse:[^self].	aName _ self world nameForCopyIfAlreadyNamed: self.	newMorph _ self veryDeepCopy.	aName ifNotNil: [newMorph setNameTo: aName].	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!Morph methodsFor: 'structure' stamp: 'ar 9/17/2000 15:36'!allOwners	"Return the owners of the receiver"	| stream |	stream _ WriteStream on: Array new.	self allOwnersDo:[:m| stream nextPut: m].	^stream contents! !!Morph methodsFor: 'structure' stamp: 'ar 9/14/2000 16:47'!allOwnersDo: aBlock	"Evaluate aBlock with all owners of the receiver"	owner ifNotNil:[^owner withAllOwnersDo: aBlock].! !!Morph methodsFor: 'structure' stamp: 'ar 10/3/2000 15:36'!hasOwner: aMorph	"Return true if the receiver has aMorph in its owner chain"	aMorph ifNil:[^true].	self allOwnersDo:[:m| m = aMorph ifTrue:[^true]].	^false! !!Morph methodsFor: 'structure' stamp: 'ar 9/14/2000 16:49'!withAllOwners	"Return the receiver and all its owners"	| stream |	stream _ WriteStream on: Array new.	self withAllOwnersDo:[:m| stream nextPut: m].	^stream contents! !!Morph methodsFor: 'structure' stamp: 'ar 9/14/2000 16:48'!withAllOwnersDo: aBlock	"Evaluate aBlock with the receiver and all of its owners"	aBlock value: self.	owner ifNotNil:[^owner withAllOwnersDo: aBlock].! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 10/3/2000 14:45'!uncoveredAt: aPoint	"Return true if the receiver is not covered by any submorphs at the given point."	| morphsAbove |self flag: #arNote. "Remove it and check all senders"	"1 oct 2000 - a little hacking to deal with the way TextMorph reports whether it contains a point or not"	morphsAbove _ self world morphsAt: aPoint.	morphsAbove isEmpty ifTrue: [^true].	morphsAbove first = self ifTrue: [^true].	(morphsAbove first isKindOf: HaloMorph) ifFalse: [^false].	^morphsAbove size < 2 or: [morphsAbove second = self]! !!Morph methodsFor: 'geometry' stamp: 'ar 9/15/2000 14:21'!griddedPoint: ungriddedPoint	| griddingContext |	self flag: #arNote. "Used by event handling - should transform to pasteUp for gridding"	(griddingContext _ self pasteUpMorph) ifNil: [^ ungriddedPoint].	^ griddingContext gridPoint: ungriddedPoint! !!Morph methodsFor: 'geometry' stamp: 'ar 9/15/2000 20:19'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta boundingMorph |	owner ifNil:[^self].	trialRect _ aPoint extent: self bounds extent.	boundingMorph _ self owner topRendererOrSelf.	delta _ boundingMorph			ifNil:    [0@0]			ifNotNil: [trialRect amountToTranslateWithin: boundingMorph bounds].	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 9/15/2000 16:08'!rootForGrabOf: aMorph	self flag: #arNote. "TODO: Remove the entire rootForGrabOf: logic"	^ (self isSticky and: [self isPartsDonor not])		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 9/18/2000 18:58'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. Note that for a successful drop operation both parties need to agree. The symmetric check is done automatically via aMorph wantsToBeDroppedInto: self."	^self dragNDropEnabled		or: [self dropEnabled]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 9/18/2000 18:34'!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph. This check is symmetric to #wantsDroppedMorph:event: to give both parties a chance of figuring out whether they like each other."	^true! !!Morph methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:02'!handlesKeyboard: evt	"Return true if the receiver wishes to handle the given keyboard event"	^false! !!Morph methodsFor: 'event handling' stamp: 'ar 9/14/2000 18:23'!keyDown: anEvent	"Handle a key down event. The default response is to do nothing."! !!Morph methodsFor: 'event handling' stamp: 'ar 9/14/2000 18:23'!keyUp: anEvent	"Handle a key down event. The default response is to do nothing."! !!Morph methodsFor: 'event handling' stamp: 'ar 9/14/2000 17:48'!transformFrom: uberMorph	"Return a transform to be used to map coordinates in a morph above me into my childrens coordinates, or vice-versa. This is used to support scrolling, scaling, and/or rotation. This default implementation just returns my owner's transform or the identity transform if my owner is nil. 	Note:  This method cannot be used to map into the receiver's coordinate system!!"	(self == uberMorph or:[owner == nil]) ifTrue:[^IdentityTransform new].	^ owner transformFrom: uberMorph! !!Morph methodsFor: 'menus' stamp: 'ar 9/15/2000 21:05'!maybeAddCollapseItemTo: aMenu	"If appropriate, add a collapse item to the given menu"	| anOwner |	(anOwner _ self topRendererOrSelf owner) ifNotNil:			[anOwner isWorldMorph ifTrue:				[aMenu add: #collapse target: self action: #collapse]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/28/2000 17:53'!addHalo: evt	| halo prospectiveHaloClass |	prospectiveHaloClass _ Smalltalk at: self haloClass ifAbsent: [HaloMorph].	halo _ prospectiveHaloClass new bounds: self worldBoundsForHalo.	halo popUpFor: self event: evt.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/4/2000 11:49'!addHaloFor: aHand	| halo prospectiveHaloClass |	prospectiveHaloClass _ Smalltalk at: self haloClass ifAbsent: [HaloMorph].	halo _ prospectiveHaloClass new bounds: self worldBoundsForHalo.	halo popUpFor: self hand: aHand.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/11/2000 21:44'!balloonHelpDelayTime	"Return the number of milliseconds before a balloon help should be put up on the receiver. The balloon help will only be put up if the receiver responds to #wantsBalloon by returning true."	^800! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:03'!deleteBalloon	"If I am showing a balloon, delete it."	| w |	w _ self world ifNil:[^self].	w deleteBalloonTarget: self.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/15/2000 16:13'!haloClass	"Answer the name of the desired kind of HaloMorph to launch on behalf of the receiver"	^ #HaloMorph! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/11/2000 21:44'!haloDelayTime	"Return the number of milliseconds before a halo should be put up on the receiver. The halo will only be put up if the receiver responds to #wantsHalo by returning true."	^800! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/15/2000 16:16'!hasHalo	^self hasProperty: #hasHalo.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/28/2000 17:54'!hasHalo: aBool	aBool		ifTrue:[self setProperty: #hasHalo toValue: true]		ifFalse:[self removeProperty: #hasHalo]! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:05'!mouseDownOnHelpHandle: anEvent	"The mouse went down in the show-balloon handle"		| str |	anEvent shiftPressed ifTrue: [^ self editBalloonHelpText].	str _ self balloonText.	str ifNil: [str _ self noHelpString].	self showBalloon: str hand: anEvent hand.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:06'!showBalloon: msgString	"Pop up a balloon containing the given string,	first removing any existing BalloonMorphs in the world."	| w |	self showBalloon: msgString hand: ((w _ self world) ifNotNil:[w activeHand]).! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:17'!showBalloon: msgString hand: aHand	"Pop up a balloon containing the given string,	first removing any existing BalloonMorphs in the world."	| w balloon h |	h _ aHand.	h ifNil:[		(w _ self world) ifNil: [^ self].		h _ w activeHand].	balloon _ BalloonMorph string: msgString for: self balloonHelpAligner.	balloon popUpFor: self hand: h.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/4/2000 13:53'!transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| localEvt w |	(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 		ifTrue:[^self addHalo: event from: formerHaloOwner].	event shiftPressed ifFalse:[		"Pass it outwards"		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].		"We're at the top level; throw the event back in to find recipient"		formerHaloOwner removeHalo.		^self processEvent: event copy resetHandlerFields.	].	self submorphsDo:[:m|		localEvt _ event transformedBy: (m transformedFrom: self).		(m fullContainsPoint: localEvt position) 			ifTrue:[^m transferHalo: event from: formerHaloOwner].	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	formerHaloOwner removeHalo.	w _ self world.	localEvt _ event transformedBy: (self transformedFrom: w) inverseTransformation.	^w processEvent: localEvt resetHandlerFields.! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:15'!addAlarm: aSelector withArguments: args at: scheduledTime	"Add an alarm (that is an action to be executed once) with the given set of parameters"	| scheduler |	scheduler _ self alarmScheduler.	scheduler ifNotNil:[scheduler addAlarm: aSelector withArguments: args for: self at: scheduledTime].! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:14'!removeAlarm: aSelector	"Remove the given alarm"	| scheduler |	scheduler _ self alarmScheduler.	scheduler ifNotNil:[scheduler removeAlarm: aSelector for: self].! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:15'!removeAlarm: aSelector at: scheduledTime	"Remove the given alarm"	| scheduler |	scheduler _ self alarmScheduler.	scheduler ifNotNil:[scheduler removeAlarm: aSelector at: scheduledTime for: self].! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/13/2000 17:58'!containsPoint: aPoint event: anEvent	"Return true if aPoint is considered to be inside the receiver for the given event.	The default implementation treats locked children as integral part of their owners."	(self fullBounds containsPoint: aPoint) ifFalse:[^false].	(self containsPoint: aPoint) ifTrue:[^true].	self submorphsDo:[:m|		(m isLocked and:[m fullContainsPoint: 			((m transformedFrom: self) globalPointToLocal: aPoint)]) ifTrue:[^true]].	^false! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/13/2000 14:51'!defaultEventDispatcher	"Return the default event dispatcher to use with events that are directly sent to the receiver"	^MorphicEventDispatcher new! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/18/2000 18:34'!handleDropMorph: anEvent	"Handle a dropping morph."	| aMorph |	aMorph _ anEvent contents.	"Do a symmetric check if both morphs like each other"	(self wantsDroppedMorph: aMorph event: anEvent) ifFalse:[^self]. "I don't want her"	(aMorph wantsToBeDroppedInto: self) ifFalse:[^self]. "She doesn't want me"	anEvent wasHandled: true.	self acceptDroppingMorph: aMorph event: anEvent.	aMorph justDroppedInto: self event: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 21:13'!handleEvent: anEvent	"Handle the given event"	^anEvent sentTo: self.! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/4/2000 18:48'!handleFocusEvent: anEvent	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."	^self handleEvent: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 23:01'!handleKeyDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	(self handlesKeyboard: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	^self keyDown: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 23:01'!handleKeyUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	(self handlesKeyboard: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	^self keyUp: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 23:23'!handleKeystroke: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	(self handlesKeyboard: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	^self keyStroke: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/16/2000 14:22'!handleListenEvent: anEvent	"Handle the given event. This message is sent if the receiver is a registered listener for the given event."	^anEvent sentTo: self.! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/4/2000 19:23'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingTriggersFor: self. "balloon & halo"	anEvent wasHandled: true.	self flag: #arNote. "For now bail out into hand meta menu"	anEvent controlKeyPressed ifTrue:[^anEvent hand invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/28/2000 17:01'!handleMouseEnter: anEvent	"System level event handling."	self wantsHalo "If receiver wants halo and balloon, trigger balloon after halo"		ifTrue:[anEvent hand triggerHaloFor: self after: self haloDelayTime]		ifFalse:[self wantsBalloon			ifTrue:[anEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime]].	(anEvent isDraggingEvent) ifTrue:[		(self handlesMouseOverDragging: anEvent) ifTrue:[			anEvent wasHandled: true.			self mouseEnterDragging: anEvent].		^self].	(self handlesMouseOver: anEvent) ifTrue:[		anEvent wasHandled: true.		self mouseEnter: anEvent.	].! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/28/2000 17:00'!handleMouseLeave: anEvent	"System level event handling."	anEvent hand removePendingTriggersFor: self. "balloon & halo"	anEvent isDraggingEvent ifTrue:[		(self handlesMouseOverDragging: anEvent) ifTrue:[			anEvent wasHandled: true.			self mouseLeaveDragging: anEvent].		^self].	(self handlesMouseOver: anEvent) ifTrue:[		anEvent wasHandled: true.		self mouseLeave: anEvent.	].! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/19/2000 10:34'!handleMouseMove: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	"Rules say that by default a morph gets #mouseMove iff		* the hand is not dragging anything,			+ and some button is down,			+ and the receiver is the current mouse focus."	(anEvent hand hasSubmorphs) ifTrue:[^self].	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/25/2000 14:38'!handleMouseOver: anEvent	"System level event handling."	anEvent hand noticeMouseOver: self event: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/28/2000 17:03'!handleMouseUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand releaseMouseFocus: self.	anEvent wasHandled: true.	anEvent blueButtonChanged		ifTrue:[self blueButtonUp: anEvent]		ifFalse:[self mouseUp: anEvent].! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/14/2000 15:20'!handleUnknownEvent: anEvent	"An event of an unknown type was sent to the receiver. What shall we do?!!"	Smalltalk beep.	anEvent printString displayAt: 0@0.	anEvent wasHandled: true.! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 14:14'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	anEvent blueButtonPressed ifTrue:[^self handlerForBlueButtonDown: anEvent].	(self handlesMouseDown: anEvent) ifFalse:[^nil]. "not interested"	anEvent handler ifNil:[^self]. "Nobody else was interested"	self mouseDownPriority >= anEvent handler mouseDownPriority 		ifTrue:[^self] "Same priority but I am innermost"		ifFalse:[^nil]. "Other guy has higher priority than I"! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 18:02'!mouseDownPriority	"Return the default mouse down priority for the receiver"	self isPartsDonor		ifTrue:[^50]		ifFalse:[^0]! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/13/2000 17:14'!processEvent: anEvent	"Process the given event using the default event dispatcher."	^self processEvent: anEvent using: self defaultEventDispatcher! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/18/2000 19:14'!processEvent: anEvent using: defaultDispatcher	"This is the central entry for dispatching events in morphic. Given some event and a default dispatch strategy, find the right receiver and let him handle it.	WARNING: This is a powerful hook. If you want to use a different event dispatcher from the default, here is the place to hook it in. Depending on how the dispatcher is written (e.g., whether it calls simply #processEvent: or #processEvent:using:) you can change the dispatch strategy for entire trees of morphs. Similarly, you can disable entire trees of morphs from receiving any events whatsoever. Read the documentation in class MorphicEventDispatcher before playing with it. "	(self rejectsEvent: anEvent) ifTrue:[^#rejected].	^defaultDispatcher dispatchEvent: anEvent with: self! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 21:10'!rejectDropEvent: anEvent	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."	(self repelsMorph: anEvent contents event: anEvent) ifFalse:[^self]. "not repelled"	(self fullContainsPoint: anEvent position) ifFalse:[^self]. "not for me"	"Throw it away"	anEvent wasHandled: true.	anEvent hand rejectDropMorph: anEvent contents event: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/12/2000 23:40'!rejectsEvent: anEvent	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it."	^self isLocked or:[self visible not]! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 21:09'!transformedFrom: uberMorph	"Return a transform to map coordinates of uberMorph, a morph above me in my owner chain, into the coordinates of MYSELF not any of my children."	self flag: #arNote. "rename this method"	owner ifNil:[^IdentityTransform new].	^ (owner transformFrom: uberMorph)! !!Morph methodsFor: 'meta-actions' stamp: 'ar 9/18/2000 19:18'!blueButtonDown: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	self addHalo: anEvent.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 9/15/2000 20:25'!blueButtonUp: anEvent	"Ignored. Theoretically we should never get here since control is transferred to the halo on #blueButtonDown: but subclasses may implement this differently."! !!Morph methodsFor: 'meta-actions' stamp: 'ar 9/15/2000 20:26'!handlerForBlueButtonDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.	Note: Halos handle blue button events themselves so we will only be asked if there is currently no halo on top of us."	self wantsHaloFromClick ifFalse:[^nil].	anEvent handler ifNil:[^self].	anEvent shiftPressed 		ifTrue:[^nil] "let outer guy have it"		ifFalse:[^self] "let me have it"! !!BorderedMorph methodsFor: 'menu' stamp: 'ar 10/3/2000 17:04'!changeBorderWidth: evt	| handle origin aHand newWidth oldWidth |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	oldWidth _ borderWidth.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newWidth _ (newPoint - origin) r asInteger // 5.			self borderWidth: newWidth]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: 'border change';					undoTarget: self selector: #borderWidth: argument: oldWidth;					redoTarget: self selector: #borderWidth: argument: newWidth)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase border width.Click when done.' hand: evt hand.	handle startStepping! !!BookMorph methodsFor: 'navigation' stamp: 'ar 9/15/2000 23:29'!goToPageMorph: newPage transitionSpec: transitionSpec	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^ self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex _ pages identityIndexOf: newPage ifAbsent: [^ self "abort"].	readIn _ newPage isInMemory not.	oldPageIndex _ pages identityIndexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageIndex == nil) or: [newPage == currentPage])			ifTrue: [nil]			ifFalse: [oldPageIndex < pageIndex].	tSpec _ transitionSpec ifNil:  "If transition not specified by requestor..."		[newPage valueOfProperty: #transitionSpec  " ... then consult new page"			ifAbsent: [self transitionSpecFor: self  " ... otherwise this is the default"]].	self flag: #arNote. "Probably unnecessary"	(aWorld _ self world) ifNotNil:		[self primaryHand releaseKeyboardFocus].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage ~~ nil		ifTrue:		[(((pages at: pageIndex) owner isKindOf: TransitionMorph)			and: [(pages at: pageIndex) isInWorld])			ifTrue: [^ self  "In the process of a prior pageTurn"].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		ascending ifNotNil:			["Show appropriate page transition and start new page when done"			currentPage stopStepping.			(pages at: pageIndex) position: currentPage position.			^ (TransitionMorph					effect: tSpec second					direction: tSpec third					inverse: (ascending or: [transitionSpec notNil]) not)				showTransitionFrom: currentPage				to: (pages at: pageIndex)				in: self				whenStart: [self playPageFlipSound: tSpec first]				whenDone:					[currentPage delete; fullReleaseCachedState.					self addMorphBack: (currentPage _ pages at: pageIndex).					self adjustCurrentPageForFullScreen.					self snapToEdgeIfAppropriate.					aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].					self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].					(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].					readIn ifTrue: [currentPage updateThumbnailUrlInBook: self url.						currentPage sqkPage computeThumbnail].	"just store it"					]].		"No transition, but at least decommission current page"		currentPage delete; fullReleaseCachedState].	self addMorphBack: (currentPage _ pages at: pageIndex).	self adjustCurrentPageForFullScreen.	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["WHY??" aWorld displayWorld].	readIn ifTrue: [currentPage updateThumbnailUrl.		currentPage sqkPage computeThumbnail].	"just store it"! !!BookMorph methodsFor: 'other' stamp: 'ar 9/14/2000 16:46'!defersHaloOnClickTo: aSubMorph	"If a cmd-click on aSubMorph would make it a preferred recipient of the halo, answer true"	^ currentPage notNil and:		[aSubMorph hasOwner: currentPage]	! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/18/2000 18:34'!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph"	^aMorph isWorldMorph "only into worlds"! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 10/3/2000 17:05'!modalBalloonHelpAtPoint: cursorPoint	self flag: #arNote. "Throw this away. There needs to be another way."	self submorphsDo:		[:m | m wantsBalloon ifTrue:			[(m valueOfProperty: #balloon) == nil				ifTrue: [(m containsPoint: cursorPoint) ifTrue: [m showBalloon: m balloonText]]				ifFalse: [(m containsPoint: cursorPoint) ifFalse: [m deleteBalloon]]]]! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'ar 10/3/2000 17:05'!click: evt	self showBalloon: 'click' hand: evt hand.	self borderColor: (self borderColor = Color black ifTrue: [Color yellow] ifFalse: [Color black])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'ar 10/3/2000 17:05'!doubleClick: evt	self showBalloon: 'doubleClick' hand: evt hand.	self color: ((color = Color blue) ifTrue: [Color red] ifFalse: [Color blue])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'ar 10/3/2000 17:05'!startDrag: evt	"We'll get a mouseDown first, some mouseMoves, and a mouseUp event last"	| oldCenter |	evt isMouseDown ifTrue:		[self showBalloon: 'drag (mouse down)' hand: evt hand.		self world displayWorld.		(Delay forMilliseconds: 750) wait].	evt isMouseUp ifTrue:		[self showBalloon: 'drag (mouse up)' hand: evt hand].	(evt isMouseUp or: [evt isMouseDown]) ifFalse:		[self showBalloon: 'drag (mouse still down)' hand: evt hand].	(self containsPoint: evt cursorPoint)		ifFalse: [^ self].	oldCenter _ self center.	color = Color red		ifTrue:			[self extent: self extent + (1@1)]		ifFalse:			[self extent: ((self extent - (1@1)) max: (16@16))].	self center: oldCenter! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'ar 9/16/2000 14:33'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	self flag: #arNote. "if we can get rid of all the current mouse foci we could trivially make the receiver a focus which would lead to actual modality in the request"	w _ self world.	w ifNil: [^ response].	done _ false.	[done] whileFalse: [Display doOneCycleMorphic].	self delete.	Display doOneCycleMorphic.	^ response! !!FlashButtonMorph methodsFor: 'event processing' stamp: 'ar 9/12/2000 23:05'!handlerForMouseDown: anEvent	"Don't give anybody over me a chance"	^self! !!HaloMorph methodsFor: 'initialization' stamp: 'ar 9/28/2000 17:55'!delete	| label |	target ifNotNil:[target hasHalo: false].	(label _ self findA: NameStringInHalo) ifNotNil:		[label hasFocus ifTrue:			[label lostFocusWithoutAccepting]].	super delete! !!HaloMorph methodsFor: 'events' stamp: 'ar 9/15/2000 20:17'!blueButtonDown: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	target transferHalo: (event transformedBy: (target transformedFrom: self)) from: target.! !!HaloMorph methodsFor: 'events' stamp: 'ar 9/15/2000 16:54'!containsPoint: aPoint event: anEvent	"Blue buttons are handled by the halo"	(anEvent isMouse and:[anEvent isMouseDown and:[anEvent blueButtonPressed]])		ifFalse:[^super containsPoint: aPoint event: anEvent].	^bounds containsPoint: anEvent position! !!HaloMorph methodsFor: 'events' stamp: 'ar 9/15/2000 16:42'!handlerForBlueButtonDown: anEvent	"Blue button was clicked within the receiver"	^self! !!HaloMorph methodsFor: 'events' stamp: 'ar 9/18/2000 16:07'!mouseMove: evt	"Drag our target around"	| thePoint |	evt startPoint = evt endPoint ifTrue:[^self].	thePoint _ (target transformedFrom: self) globalPointToLocal: evt position.	target setConstrainedPositionFrom: (thePoint - positionOffset).! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/4/2000 13:53'!popUpFor: aMorph event: anEvent	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| tfm hand |	hand _ anEvent hand.	self target: aMorph.	hand halo: self.	hand world addMorphFront: self.	positionOffset _ anEvent position - aMorph position.	self startStepping.	"wait for drags or ignore"	tfm _ (aMorph transformedFrom: nil) inverseTransformation.	hand newMouseFocus: self. "Necessary or else we won't get #mouseMove..."	hand 		waitForClicksOrDrag: self 		event: (anEvent transformedBy: tfm)		selectors: { nil. nil. #startDragTarget:. }		threshold: 5.! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/4/2000 15:55'!popUpFor: aMorph hand: aHand	"This message is sent by the hand"	self target: aMorph.	aHand halo: self.	aHand world addMorphFront: self.	positionOffset _ aHand position - aMorph position.	self startStepping.! !!HaloMorph methodsFor: 'events' stamp: 'ar 9/18/2000 16:53'!startDragTarget: event	"Begin dragging the target"	| thePoint |	thePoint _ (target transformedFrom: self) globalPointToLocal: event position.	target setConstrainedPositionFrom: thePoint.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'events' stamp: 'ar 10/4/2000 19:26'!staysUpWhenMouseIsDownIn: aMorph	^ ((aMorph == target) or: [aMorph hasOwner: self])! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/4/2000 16:27'!addHandlesForWorldHalos	"Add handles for world halos, like the man said"	| box w |	w _ self world ifNil:[target world].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ w bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	Preferences uniqueNamesInHalos ifTrue:		[innerTarget assureExternalName].	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/4/2000 13:47'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph namePosition w |	w _ self world ifNil:[target world].	nameMorph _ NameStringInHalo contents: aString.	nameMorph color: Color magenta.	nameMorph useStringFormat; target: innerTarget; putSelector: #renameTo:.	namePosition _ outerRectangle bottomCenter -		((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).	nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).	nameMorph balloonTextSelector: #objectNameInHalo.	self addMorph: nameMorph.	^ nameMorph! !!HandMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 09:48'!mouseFocus	^mouseDownMorph! !!HandMorph methodsFor: 'accessing' stamp: 'ar 9/25/2000 14:24'!mouseOverHandler	^mouseOverHandler ifNil:[mouseOverHandler _ MouseOverHandler new].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/18/2000 00:24'!handleEvent: evt	| prevEvt |	"Handle the event."	eventSubscribers do: [:m | m handleEvent: evt]."--"	(NewEventRules == true) ifTrue:[		prevEvt _ lastEvent.		lastEvent _ evt.		self newHandleEvent: (evt asNewEventFrom: prevEvt).		^self]."--"	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]]."--"	lastEvent _ evt.	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	evt isMouse ifTrue:		[evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		self world validateMouseEvent: evt.	"allow current world to bail out"		evt isMouseDown ifTrue: [ ^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]].	evt isKeystroke ifTrue:		[^ keyboardFocus			ifNotNil:				[keyboardFocus dispatchKeystroke: evt]			ifNil:				[self unfocusedKeystroke: evt]]! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/13/2000 20:25'!moveToEvent: anEvent	"Issue a mouse move event to make the receiver appear at the given position"	self newHandleEvent: (MouseMoveEvent new		setType: #mouseMove 		startPoint: self position 		endPoint: anEvent position 		trail: #()		buttons: anEvent buttons		hand: self).! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/4/2000 18:28'!newHandleEvent: evt	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseDownMorph].ShowEvents == true ifTrue:[	evt printString displayAt: (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: 0@45.].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[self sendListenEvent: evt to: mouseListeners].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[(mouseClickState handleEvent: evt from: self) ifFalse:[^self]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseDownMorph.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on non-move mouse events"		(self hasSubmorphs) ifTrue:[self dropMorphs: evt].		self sendEvent: evt focus: mouseDownMorph.	].	ShowEvents == true ifTrue:[mouseDownMorph printString displayAt: 0@15].	evt isMouse ifTrue:[lastMouseEvent _ evt].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/18/2000 10:03'!newMouseFocus: aMorphOrNil	| itsPasteUp toView |false ifTrue:[	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: ["Crock: If a menu is proffered with the mouse up						and the user clicks down outside it (as is normal in MVC),						then the menu goes away and nothing else happens."						mouseDownMorph owner deleteIfPopUp.						^ nil]].].	aMorphOrNil ifNotNil: 		[((itsPasteUp  _ aMorphOrNil pasteUpMorph) notNil and:			[itsPasteUp automaticViewing]) ifTrue:				[toView _ itsPasteUp					submorphThat:						[:aMorph | aMorphOrNil hasOwner: aMorph]					ifNone:						[nil].				(toView notNil and: [toView isCandidateForAutomaticViewing]) ifTrue:					[toView openViewerForArgument]]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/14/2000 15:10'!newMouseFocus: aMorph event: event	aMorph == nil ifFalse:[		targetOffset _ event cursorPoint - aMorph position.	].	^self newMouseFocus: aMorph.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/25/2000 14:27'!noticeMouseOver: aMorph event: anEvent	mouseOverHandler ifNil:[^self].	mouseOverHandler noticeMouseOver: aMorph event: anEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/18/2000 10:04'!releaseAllFoci	mouseDownMorph _ nil.	keyboardFocus _ nil.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/14/2000 17:11'!releaseKeyboardFocus	"Release the current keyboard focus unconditionally"	self newKeyboardFocus: nil.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/14/2000 17:11'!releaseKeyboardFocus: aMorph	"If the given morph had the keyboard focus before, release it"	keyboardFocus == aMorph ifTrue:[self releaseKeyboardFocus].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/18/2000 10:03'!releaseMouseFocus	"Release the current mouse focus unconditionally."	self newMouseFocus: nil.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/18/2000 10:03'!releaseMouseFocus: aMorph	"If the given morph had the mouse focus before, release it"	mouseDownMorph == aMorph ifTrue:[self releaseMouseFocus].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/4/2000 18:47'!sendEvent: anEvent focus: focusHolder	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	focusHolder ifNil:[^owner processEvent: anEvent].	^self sendFocusEvent: anEvent to: focusHolder.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/14/2000 16:30'!sendFocusEvent: anEvent to: focusHolder	"Send the event to the morph currently holding the focus"	^focusHolder handleFocusEvent: 		(anEvent transformedBy: (focusHolder transformedFrom: self)).! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/16/2000 14:23'!sendListenEvent: anEvent to: listenerGroup	"Send the event to the given group of listeners"	listenerGroup ifNil:[^self].	listenerGroup do:[:listener| listener handleListenEvent: anEvent copy].! !!HandMorph methodsFor: 'double click support' stamp: 'ar 9/18/2000 17:16'!resetClickState	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	mouseClickState _ nil.! !!HandMorph methodsFor: 'double click support' stamp: 'ar 9/18/2000 17:10'!waitForClicksOrDrag: aMorph event: evt	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	^self waitForClicksOrDrag: aMorph event: evt selectors: #( #click: #doubleClick: #startDrag:) threshold: 10! !!HandMorph methodsFor: 'double click support' stamp: 'ar 9/18/2000 17:18'!waitForClicksOrDrag: aMorph event: evt selectors: clickAndDragSelectors threshold: threshold	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clickAndDragSelectors first 			dblClick: clickAndDragSelectors second 			dblClickTime: DoubleClickTime 			drag: clickAndDragSelectors third 			threshold: threshold 			event: evt.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/3/2000 20:15'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event |	event _ DropEvent new setPosition: self position contents: aMorph hand: self."event printString displayAt: 0@30."	owner processEvent: event.	event wasHandled ifFalse:[self rejectDropMorph: aMorph event: event].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 9/14/2000 11:22'!dropMorphs: anEvent	"Drop the morphs at the hands position"	self submorphsReverseDo:[:m|		"Drop back to front to maintain z-order"		self dropMorph: m event: anEvent.	].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 9/14/2000 21:39'!grabMorphInner: aMorph	"The real work of grabbing a morph.  Set up a command object to represent the forthcoming move (in support of Undo), then actually wrench the morph out of its old home and add it as one of MY submorphs."	| myPos morphPos localPt trans morphToGrab newT w |	formerOwner _ aMorph owner.	formerPosition _ aMorph position.	(formerOwner notNil and: [(aMorph isKindOf: NewHandleMorph orOf: MenuMorph) not]) ifTrue:		[(currentCommand _ Command new)			cmdWording: 'move ', (aMorph externalName truncateTo: 10);			undoTarget: aMorph				selector: #undoMove:redo:owner:bounds:predecessor:				arguments: {currentCommand. false. formerOwner. aMorph bounds. (formerOwner morphPreceding: aMorph)}].	"Check if the morph will keep its transform while grabbed"	myPos _ self position.	morphPos _ aMorph position.	w _ aMorph world ifNil: [self worldUnderCursor]. 	aMorph keepsTransform ifTrue: [		localPt _ myPos	] ifFalse: [		"fix grabbing new morph in embedded world"		localPt _ (w globalPointToLocal: myPos) truncated.	].		(formerOwner == nil		or: [aMorph keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		formerOwner ifNotNil: [			localPt _ (formerOwner transformFrom: w) globalPointToLocal: localPt.		].		aMorph position: myPos + (morphPos - localPt).		morphToGrab _ aMorph.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ aMorph addFlexShell transform: trans asMorphicTransform.		aMorph position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	(morphToGrab isKindOf: PhraseTileMorph) ifTrue:		[morphToGrab position: Sensor cursorPoint].	self addMorphBack: morphToGrab! !!HandMorph methodsFor: 'testing' stamp: 'ar 9/22/2000 10:39'!isDraggingEvent: anEvent	"Return true if the event is considered a 'dragging' event"	self hasSubmorphs ifTrue:[^true].	^anEvent anyButtonPressed! !!HandMorph methodsFor: 'listeners' stamp: 'ar 9/16/2000 14:18'!addEventListener: anObject	"Make anObject a listener for all events. All events will be reported to the object."	eventListeners		ifNil:[eventListeners _ Array with: anObject]		ifNotNil:[eventListeners _ eventListeners copyWith: anObject]! !!HandMorph methodsFor: 'listeners' stamp: 'ar 9/16/2000 14:16'!addKeyboardListener: anObject	"Make anObject a listener for keyboard events. All keyboard events will be reported to the object."	keyboardListeners		ifNil:[keyboardListeners _ Array with: anObject]		ifNotNil:[keyboardListeners _ keyboardListeners copyWith: anObject]! !!HandMorph methodsFor: 'listeners' stamp: 'ar 9/16/2000 14:15'!addMouseListener: anObject	"Make anObject a listener for mouse events. All mouse events will be reported to the object."	mouseListeners		ifNil:[mouseListeners _ Array with: anObject]		ifNotNil:[mouseListeners _ mouseListeners copyWith: anObject]! !!HandMorph methodsFor: 'listeners' stamp: 'ar 9/16/2000 14:18'!removeEventListener: anObject	"Remove anObject from the current event listeners."	eventListeners ifNil:[^self].	eventListeners _ eventListeners copyWithout: anObject.	eventListeners size = 0 ifTrue:[eventListeners _ nil].! !!HandMorph methodsFor: 'listeners' stamp: 'ar 9/16/2000 14:17'!removeKeyboardListener: anObject	"Remove anObject from the current keyboard listeners."	keyboardListeners ifNil:[^self].	keyboardListeners _ keyboardListeners copyWithout: anObject.	keyboardListeners size = 0 ifTrue:[keyboardListeners _ nil].! !!HandMorph methodsFor: 'listeners' stamp: 'ar 9/16/2000 14:16'!removeMouseListener: anObject	"Remove anObject from the current mouse listeners."	mouseListeners ifNil:[^self].	mouseListeners _ mouseListeners copyWithout: anObject.	mouseListeners size = 0 ifTrue:[mouseListeners _ nil].! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/3/2000 16:49'!balloonHelp	"Return the balloon morph associated with this hand"	^self valueOfProperty: #balloonHelpMorph! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/3/2000 16:51'!balloonHelp: aBalloonMorph	"Return the balloon morph associated with this hand"	| oldHelp |	oldHelp _ self balloonHelp.	oldHelp ifNotNil:[oldHelp delete].	aBalloonMorph		ifNil:[self removeProperty: #balloonHelpMorph]		ifNotNil:[self setProperty: #balloonHelpMorph toValue: aBalloonMorph]! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/3/2000 17:19'!deleteBalloonTarget: aMorph	"Delete the balloon help targeting the given morph"	| h |	h _ self balloonHelp ifNil:[^self].	h balloonOwner == aMorph ifTrue:[self balloonHelp: nil].! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/4/2000 13:40'!halo	"Return the halo associated with this hand, if any"	^self valueOfProperty: #halo! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/4/2000 13:40'!halo: newHalo	"Set halo associated with this hand"	| oldHalo |	oldHalo _ self halo.	(oldHalo isNil or:[oldHalo == newHalo]) ifFalse:[oldHalo delete].	newHalo		ifNil:[self removeProperty: #halo]		ifNotNil:[self setProperty: #halo toValue: newHalo]! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/4/2000 19:25'!removeHaloFromClick: anEvent on: aMorph	| halo |	halo _ self halo ifNil:[^self].	(halo target hasOwner: self) ifTrue:[^self].	(halo staysUpWhenMouseIsDownIn: aMorph) ifFalse:[halo delete].! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/4/2000 11:50'!removePendingTriggersFor: aMorph	"Get rid of pending balloon help or halo actions."	self removeAlarm: #spawnBalloonFor:.	self removeAlarm: #spawnHaloFor:.	self deleteBalloonTarget: aMorph.! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/3/2000 17:15'!spawnBalloonFor: aMorph	aMorph showBalloon: aMorph balloonText hand: self.! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/4/2000 11:49'!spawnHaloFor: aMorph	aMorph addHaloFor: self.! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/3/2000 17:14'!triggerBalloonFor: aMorph after: timeOut	"Trigger balloon help after the given time out for some morph"	self addAlarm: #spawnBalloonFor: with: aMorph after: timeOut.! !!HandMorph methodsFor: 'balloon help and halo' stamp: 'ar 10/4/2000 11:50'!triggerHaloFor: aMorph after: timeOut	"Trigger automatic halo after the given time out for some morph"	self addAlarm: #spawnHaloFor: with: aMorph after: timeOut.! !!HandMorph class methodsFor: 'utilities' stamp: 'ar 9/17/2000 17:02'!newEventRules: aBool	NewEventRules _ aBool.! !!HandMorph class methodsFor: 'utilities' stamp: 'ar 10/4/2000 18:29'!showEvents: aBool	"HandMorph showEvents: true"	"HandMorph showEvents: false"	ShowEvents _ aBool.! !!HandleMorph methodsFor: 'stepping' stamp: 'ar 9/15/2000 23:24'!startStepping	"Make the receiver the keyboard focus for editing"	super startStepping.	"owner isHandMorph ifTrue:[owner newKeyboardFocus: self]."self flag: #arNote. "make me #handleKeyboard:"! !!HandleMorph methodsFor: 'termination' stamp: 'ar 9/15/2000 23:30'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	lastPointBlock ifNotNil: [lastPointBlock value: self center].	self flag: #arNote. "Probably unnecessary"	anEvent hand releaseKeyboardFocus: self.	self changed.	self delete.! !!HandleMorph methodsFor: 'events' stamp: 'ar 9/15/2000 23:30'!keyStroke: evt	"Check for cursor keys"	| keyValue |	owner isHandMorph ifFalse:[^self].	keyValue _ evt keyValue.	keyValue = 28 ifTrue:[^self position: self position - (1@0)].	keyValue = 29 ifTrue:[^self position: self position + (1@0)].	keyValue = 30 ifTrue:[^self position: self position - (0@1)].	keyValue = 31 ifTrue:[^self position: self position + (0@1)].	"Special case for return"	keyValue = 13 ifTrue:[		"Drop the receiver and be done"	self flag: #arNote. "Probably unnecessary"		owner releaseKeyboardFocus: self.		self delete].! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:17'!allWordingsNotInSubMenu: verbotenSubmenuContents	"Answer a collection of the wordings of all items and subitems, but omit the stay-up item, and also any items in a submenu whose tag is given by erbotenSubmenuContents"	| aList |	aList _ OrderedCollection new.	self items do:[:anItem | aList addAll: (anItem allWordingsNotInSubMenu: verbotenSubmenuContents)].	^aList! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 13:19'!defaultTarget	^defaultTarget! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:18'!hasSubMenu: aMenuMorph	self items do: [:each | (each hasSubMenu: aMenuMorph) ifTrue:[^true]].	^ false! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:22'!itemWithWording: wording	"If any of the receiver's items or submenu items have the given wording (case-blind comparison done), then return it, else return nil."	| found |	self items do:[:anItem |		found _ anItem itemWithWording: wording.		found ifNotNil:[^found]].	^ nil! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 12:12'!lastSelection	"Return the label of the last selected item or nil."	selectedItem == nil		ifTrue: [^ selectedItem selector]		ifFalse: [^ nil].! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 10:06'!popUpOwner	"Return the current pop-up owner that is the menu item that automatically initiated the receiver."	^ popUpOwner! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 10:07'!popUpOwner: aMenuItemMorph	"Set the current pop-up owner"	popUpOwner _ aMenuItemMorph.! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 10/3/2000 18:57'!stayUp: aBoolean	stayUp _ aBoolean.	(stayUp and:[owner isModalShell]) ifTrue:[owner deleteWithoutSubmorphs].! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/3/2000 19:17'!aboutToBeGrabbedBy: aHand	popUpOwner ifNotNil:["Detach submenu from popUpOwner and delete its menu"		popUpOwner delete.		popUpOwner _ nil].	(owner notNil and:[owner isModalShell]) ifTrue:[owner delete].	^self! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/17/2000 20:38'!activeSubmenu: aSubmenu	activeSubMenu ifNotNil:[activeSubMenu delete].	activeSubMenu _ aSubmenu.! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/3/2000 19:12'!addModalShell	"Add a new modal shell to the receiver"	| shell |	shell _ ModalShellMorph new.	shell primaryMouseReceiver: self.	owner ifNotNil:[owner replaceSubmorph: self by: shell].	shell addMorphFront: self.	^shell! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/18/2000 18:17'!deleteIfPopUp: evt	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."	stayUp ifFalse: [self topRendererOrSelf delete].	(popUpOwner notNil) ifTrue: [		popUpOwner isSelected: false.		popUpOwner deleteIfPopUp: evt].	evt ifNotNil:[evt hand releaseMouseFocus: self].! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/18/2000 10:28'!invokeItem: aMenuItem event: evt	"Perform the action associated with the given menu item."	^aMenuItem invokeWithEvent: evt.! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/3/2000 19:13'!justDroppedInto: aMorph event: anEvent	"This menu was grabbed and moved"	super justDroppedInto: aMorph event: anEvent.	stayUp ifFalse:[self addModalShell].	self receiveNewFocus: anEvent! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/18/2000 12:15'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| delta tryToPlace selectedOffset |	hand world startSteppingSubmorphsOf: self.	popUpOwner _ sourceItem.	self fullBounds.  "ensure layout is current"	selectedOffset := (selectedItem ifNil:[self items first]) position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/3/2000 18:22'!popUpAt: aPoint forHand: hand in: aWorld	| shell |	"Present this menu at the given point under control of the given hand."	self items isEmpty ifTrue: [^ self].	self positionAt: aPoint relativeTo: (selectedItem ifNil:[self items first]) inWorld: aWorld.	shell _ self addModalShell.	aWorld addMorphFront: shell; startSteppingSubmorphsOf: shell.		hand newMouseFocus: shell.	self changed! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/18/2000 12:16'!selectItem: aMenuItem event: anEvent	selectedItem ifNotNil:[selectedItem deselect: anEvent].	selectedItem _ aMenuItem.	selectedItem ifNotNil:[selectedItem select: anEvent].! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/18/2000 18:34'!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph"	^aMorph isWorldMorph or:[Preferences systemWindowEmbedOK]! !!MenuMorph methodsFor: 'copying' stamp: 'ar 9/18/2000 09:34'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.defaultTarget _ deepCopier references at: defaultTarget ifAbsent: [defaultTarget].popUpOwner _ deepCopier references at: popUpOwner ifAbsent: [popUpOwner].activeSubMenu _ deepCopier references at: activeSubMenu ifAbsent:[activeSubMenu].! !!MenuMorph methodsFor: 'copying' stamp: 'ar 9/18/2000 12:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."defaultTarget _ defaultTarget.		Weakly copied"selectedItem _ selectedItem veryDeepCopyWith: deepCopier.stayUp _ stayUp veryDeepCopyWith: deepCopier.popUpOwner _ popUpOwner.		"Weakly copied"activeSubMenu _ activeSubMenu. "Weakly copied"! !!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/3/2000 18:49'!delete	(owner notNil and:[popUpOwner isNil])		ifTrue:[owner isModalShell ifTrue:[owner delete]].	activeSubMenu ifNotNil:[activeSubMenu delete].	^super delete! !!MenuMorph methodsFor: 'initialization' stamp: 'ar 9/18/2000 12:12'!initialize	super initialize.	self setDefaultParameters.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	selectedItem _ nil.	stayUp _ false.	popUpOwner _ nil.	Preferences roundedMenuCorners ifTrue: [self useRoundedCorners]! !!MenuMorph methodsFor: 'initialization' stamp: 'ar 9/18/2000 11:28'!setDefaultParameters	| worldColor |	((Preferences menuColorFromWorld and: [Display depth > 4]) and: [(worldColor _ self currentWorld color) isColor])		ifTrue: [self setColor: (worldColor luminance > 0.7						ifTrue: [worldColor mixed: 0.8 with: Color black]						ifFalse: [worldColor mixed: 0.4 with: Color white])						"Think about whether alpha should be included."					borderWidth: Preferences menuBorderWidth					borderColor: #raised]		ifFalse: [self setColor: Preferences menuColor					borderWidth: Preferences menuBorderWidth					borderColor: Preferences menuBorderColor].	inset _ 3! !!MenuMorph methodsFor: 'menu' stamp: 'ar 9/18/2000 13:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'add title...' action: #addTitle.	aCustomMenu add: 'set target...' action: #setTarget:.	defaultTarget ifNotNil: [		aCustomMenu add: 'add item...' action: #addItem].	aCustomMenu add: 'add line' action: #addLine.	(self items count:[:any| any hasSubMenu]) > 0		ifTrue:[aCustomMenu add: 'detach submenu' action: #detachSubMenu:].! !!MenuMorph methodsFor: 'menu' stamp: 'ar 9/18/2000 11:47'!detachSubMenu: evt	| possibleTargets item subMenu index |	possibleTargets _ self items select:[:any| any hasSubMenu].	possibleTargets size > 0 ifTrue:[		index _ PopUpMenu 				withCaption:'Which menu?' 				chooseFrom: (possibleTargets collect:[:t| t contents asString]).		index = 0 ifTrue:[^self]].	item _ possibleTargets at: index.	subMenu _ item subMenu.	subMenu ifNotNil: [		item subMenu: nil.		item delete.		subMenu stayUp: true.		subMenu popUpOwner: nil.		subMenu addTitle: item contents.		evt hand attachMorph: subMenu].! !!MenuMorph methodsFor: 'menu' stamp: 'ar 10/3/2000 18:56'!toggleStayUp: evt	"Toggle my 'stayUp' flag and adjust the menu item to reflect its new state."	self items do: [:item |		item selector = #toggleStayUp: ifTrue:			[self stayUp: stayUp not.				 stayUp				ifTrue: [item contents: 'dismiss this menu']				ifFalse: [item contents: 'keep this menu up']]].	stayUp ifFalse: [self topRendererOrSelf delete].! !!MenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 11:49'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^10		"Menus are very front-like things"! !!MenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 12:13'!positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset sub delta |	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	self right > aWorld worldBounds right		ifTrue: [self left: self left - self width + 4].	"Make sure that the menu fits in the world."	delta _ self bounds amountToTranslateWithin: aWorld worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!MenuMorph methodsFor: 'private' stamp: 'ar 10/4/2000 16:21'!receiveNewFocus: evt	"If necessary, have the receiver's owner receive the new mouse focus."	popUpOwner ifNotNil:[^popUpOwner receiveNewFocus: evt].	stayUp 		ifTrue:[evt hand newMouseFocus: nil]		ifFalse:[(owner notNil and:[owner isModalShell]) ifTrue:[^owner receiveNewFocus: evt]].! !!MenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 12:12'!selectedItem	^selectedItem! !!MenuMorph methodsFor: 'events' stamp: 'ar 9/18/2000 10:13'!handlesMouseDown: evt	^true! !!MenuMorph methodsFor: 'events' stamp: 'ar 10/3/2000 18:25'!mouseDown: evt	"Handle a mouse down event.	Note: This might be sent from a modal shell."	(self fullContainsPoint: evt position) ifFalse:[		^self setProperty: #deleteOnMouseUp toValue: true].	"Grab the menu and drag it to some other place"	evt hand grabMorph: self.! !!MenuMorph methodsFor: 'events' stamp: 'ar 10/3/2000 18:17'!mouseUp: evt	"Handle a mouse up event.	Note: This might be sent from a modal shell."	(self fullContainsPoint: evt position) ifFalse:[		(self hasProperty: #deleteOnMouseUp)			ifTrue:[self deleteIfPopUp: evt]].! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'ar 9/18/2000 12:11'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	self flag: #bob.		"is <aPoint> global or local?"	self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ mvcSelection! !!MVCMenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 12:10'!cancelValue: selectionOrNil	"Set the value to be returned if the user cancels without making a selection."	mvcSelection _ selectionOrNil.! !!MVCMenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 12:16'!selectMVCItem: item	"Called by the MenuItemMorph that the user selects.	Record the selection and set the done flag to end this interaction."	mvcSelection _ item.	done _ true.! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'ar 9/18/2000 12:16'!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j emphasis |	menu _ self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString _ aPopupMenu labelString.	items _ labelString asString findTokens: String cr.	labelString isText ifTrue:		["Pass along text emphasis if present"		j _ 1.		items _ items collect:			[:item | j _ labelString asString findString: item startingAt: j.			emphasis _ TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines _ aPopupMenu lineArray.	lines ifNil: [lines _ #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections _ (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!ModalShellMorph methodsFor: 'initialize-release' stamp: 'ar 10/4/2000 10:27'!deleteWithoutSubmorphs	"Delete the receiver but transfer all submorphs to the owner of the receiver. This is usually done if my submorph(s) want to become non-modal."	owner ifNotNil:[self submorphs reverseDo:[:m| owner addMorphFront: m]].	self delete.! !!ModalShellMorph methodsFor: 'accessing' stamp: 'ar 10/4/2000 10:27'!primaryMouseReceiver	"Return the primary mouse receiver, e.g., the morph handling clicks outside any of the children of this shell."	^primaryMouseReceiver! !!ModalShellMorph methodsFor: 'accessing' stamp: 'ar 10/4/2000 10:28'!primaryMouseReceiver: aMorph	"Register the primary mouse receiver, e.g., the morph handling clicks outside any of the children of this shell."	primaryMouseReceiver _ aMorph! !!ModalShellMorph methodsFor: 'testing' stamp: 'ar 10/4/2000 10:28'!isModalShell	"Yes I am"	^true! !!ModalShellMorph methodsFor: 'drawing' stamp: 'ar 10/3/2000 22:30'!changed	"Since I'm invisible send #changed to my children so they invalidate the appropriate regions"	self submorphsDo:[:m| m changed].! !!ModalShellMorph methodsFor: 'drawing' stamp: 'ar 10/3/2000 18:54'!drawOn: aCanvas	"I am an invisible shell so don't draw anything"! !!ModalShellMorph methodsFor: 'events' stamp: 'ar 10/3/2000 18:55'!handleFocusEvent: evt	"Handle focus events by processing them normally (e.g., passing them on to all submorphs of the modal shell). If a mouse event has not been handled and a primary mouse receiver has been installed, pass the event to the primary mouse receiver. Otherwise, delete the receiver and all it's children."	self processEvent: evt.	(evt isMouse and:[evt wasHandled not]) ifTrue:[		primaryMouseReceiver 			ifNil:[self delete]			ifNotNil:[primaryMouseReceiver handleEvent: evt]].	evt hand mouseFocus == self ifTrue:[		self isInWorld ifFalse:[evt hand newMouseFocus: nil].	] ifFalse:["*I* am the mouse focus here"		self isInWorld ifTrue:[evt hand newMouseFocus: self].	].! !!ModalShellMorph methodsFor: 'events' stamp: 'ar 10/4/2000 10:28'!receiveNewFocus: evt	"If necessary, make the receiver the new mouse focus."	(self isInWorld) ifTrue:[evt hand newMouseFocus: self]! !!MorphicEvent methodsFor: 'classification' stamp: 'ar 9/14/2000 18:31'!isKeyboard	^ (type == #keystroke) | (type == #keyDown) | (type == #keyUp)! !!MorphicEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:46'!asNewEventFrom: lastEvent	(self isMouseDown or:[self isMouseUp]) ifTrue:[		^MouseButtonEvent new 			setType: type 			position: cursorPoint 			which: (lastEvent buttons bitXor: buttons)			buttons: buttons 			hand: sourceHand.	].	self isMouseMove ifTrue:[		^MouseMoveEvent new 			setType: type 			startPoint: sourceHand position			endPoint: cursorPoint 			trail: #()			buttons: buttons 			hand: sourceHand.	].	self isKeyboard ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: sourceHand position			keyValue: keyValue			hand: sourceHand.	].! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 9/17/2000 15:12'!dispatchDefault: anEvent with: aMorph	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."	| localEvt index child morphs inside |	"See if we're fully outside aMorphs bounds"	(aMorph fullBounds containsPoint: anEvent position) ifFalse:[^#rejected]. "outside"	"Traverse children"	index _ 1.	morphs _ aMorph submorphs.	inside _ false.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Not rejected. The event was in some submorph of the receiver"			inside _ true.			index _ morphs size. "break"		].		index _ index + 1.	].	"Check for being inside the receiver"	inside ifFalse:[inside _ aMorph containsPoint: anEvent position event: anEvent].	inside ifTrue:[^aMorph handleEvent: anEvent].	^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 9/17/2000 15:14'!dispatchDropEvent: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."	| inside index morphs child localEvt |	"Try to get out quickly"	(aMorph fullBounds containsPoint: anEvent cursorPoint)		ifFalse:[^#rejected].	"Give aMorph a chance to repel the dropping morph"	aMorph rejectDropEvent: anEvent.	anEvent wasHandled ifTrue:[^self].	"Go looking if any of our submorphs wants it"	index _ 1.	inside _ false.	morphs _ aMorph submorphs.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: self).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			localEvt wasHandled ifTrue:[^anEvent wasHandled: true]. "done"			inside _ true.			index _ morphs size]. "break"		index _ index + 1.	].	inside ifFalse:[inside _ aMorph containsPoint: anEvent cursorPoint event: anEvent].	inside ifTrue:[^aMorph handleDropMorph: anEvent].	^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 9/25/2000 14:41'!dispatchEvent: anEvent with: aMorph	"Dispatch the given event for a morph that has chosen the receiver to dispatch its events. The method implements a shortcut for repeated dispatches of events using the same dispatcher."	anEvent type == lastType ifTrue:[^self perform: lastDispatch with: anEvent with: aMorph].	"Otherwise classify"	lastType _ anEvent type.	anEvent isMouse ifTrue:[		anEvent isMouseDown ifTrue:[			lastDispatch _ #dispatchMouseDown:with:.			^self dispatchMouseDown: anEvent with: aMorph]].	anEvent isDropEvent ifTrue:[		lastDispatch _ #dispatchDropEvent:with:.		^self dispatchDropEvent: anEvent with: aMorph].	lastDispatch _ #dispatchDefault:with:.	^self dispatchDefault: anEvent with: aMorph! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 9/13/2000 19:55'!dispatchMouseDown: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. Default rules:	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event."	| globalPt localEvt index child morphs handler inside lastHandler |	"Try to get out quickly"	globalPt _ anEvent cursorPoint.	(aMorph fullBounds containsPoint: globalPt) ifFalse:[^#rejected].	"Install the prospective handler for the receiver"	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"	handler _ aMorph handlerForMouseDown: anEvent.	handler ifNotNil:[anEvent handler: handler].	"Now give our submorphs a chance to handle the event"	index _ 1.	morphs _ aMorph submorphs.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Some child did contain the point so we're part of the top-most chain."			inside _ false.			localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].			index _ morphs size].		index _ index + 1.	].	(inside == false or:[aMorph containsPoint: anEvent cursorPoint event: anEvent]) ifTrue:[		"Receiver is in the top-most unlocked, visible chain."		handler ifNotNil:[handler handleMouseDown: anEvent].		"Note: Re-installing the handler is not really necessary but good style."		anEvent handler: lastHandler.		^self	].	"Mouse was not on receiver nor any of its children"	anEvent handler: lastHandler.	^#rejected! !!MouseClickState methodsFor: 'initialize' stamp: 'ar 9/18/2000 18:22'!client: aMorph click: aClickSelector dblClick: aDblClickSelector dblClickTime: timeOut drag: aDragSelector threshold: aNumber event: firstClickEvent	clickClient _ aMorph.	clickSelector _ aClickSelector.	dblClickSelector _ aDblClickSelector.	dblClickTime _ timeOut.	dragSelector _ aDragSelector.	dragThreshold _ aNumber.	firstClickDown _ firstClickEvent.	firstClickTime _ firstClickEvent timeStamp.	clickState _ #firstClickDown.! !!MouseClickState methodsFor: 'event handling' stamp: 'ar 9/18/2000 17:09'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt transformedBy: (clickClient transformedFrom: aHand owner).	isDrag _ (localEvt cursorPoint - firstClickDown cursorPoint) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag"			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			clickState _ #firstClickTimedOut.			^true].		localEvt isMouseUp ifTrue:[			"If timedOut or the client's not interested in dbl clicks get outta here"			(timedOut or:[dblClickSelector isNil]) ifTrue:[				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp _ localEvt.			clickState _ #firstClickUp.			^false].		isDrag ifTrue:["drag start w/o timout -> send extra #click:"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			self flag: #arNote.  "Should we really call dragSelector with firstClickDown?!!"			dragSelector ifNotNil:[clickClient perform: dragSelector with: firstClickDown].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click (we sent #click: already)"			aHand resetClickState.			^true].		isDrag ifTrue:["drag start"			aHand resetClickState.			self flag: #arNote. "see above - really firstClickDown?!!"			dragSelector ifNotNil:[clickClient perform: dragSelector with: firstClickDown].			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			aHand resetClickState.			clickClient handleMouseUp: firstClickUp.			^true].		localEvt isMouseDown ifTrue:["double click"			aHand resetClickState.			dblClickSelector ifNotNil:[clickClient perform: dblClickSelector with: firstClickDown].			^false]].	^true! !!MouseOverHandler methodsFor: 'initialize-release' stamp: 'ar 9/28/2000 17:08'!initialize	mouseOverMorphs _ #().! !!MouseOverHandler methodsFor: 'event handling' stamp: 'ar 9/28/2000 18:52'!noticeMouseOver: aMorph event: anEvent	"Remember that the mouse is currently over some morph"	(leftMorphs includes: aMorph) 		ifTrue:[leftMorphs remove: aMorph]		ifFalse:[enteredMorphs nextPut: aMorph].	overMorphs nextPut: aMorph.! !!MouseOverHandler methodsFor: 'event handling' stamp: 'ar 10/3/2000 15:57'!processMouseOver: anEvent	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus |	hand _ anEvent hand.	leftMorphs _ mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs _ WriteStream on: (Array new: leftMorphs size).	enteredMorphs _ WriteStream on: #().	"Now go looking for eventual mouse overs"	hand newHandleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs size = 0 and:[enteredMorphs position = 0]) 		ifTrue:[^leftMorphs _ enteredMorphs _ overMorphs _ nil].	focus _ hand mouseFocus.	"Send #mouseLeave as appropriate"	leftMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[localEvt _ anEvent transformedBy: (m transformedFrom: hand).					m handleMouseLeave: localEvt]			ifFalse:[overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	enteredMorphs _ enteredMorphs contents.	enteredMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[	localEvt _ anEvent transformedBy: (m transformedFrom: hand).					m handleMouseEnter: localEvt]].	"And remember the over list"	mouseOverMorphs _ overMorphs contents.	leftMorphs _ enteredMorphs _ overMorphs _ nil.! !!MouseOverHandler class methodsFor: 'instance creation' stamp: 'ar 9/22/2000 10:57'!new	^super new initialize! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 22:55'!handlesKeyboard: evt	^true! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:05'!mouseEnter: evt	evt hand newKeyboardFocus: self.	enteringHand _ evt hand.! !!NewMorphicEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 16:48'!hand	"Return the source that generated the event"	^source! !!NewMorphicEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:29'!timeStamp	"Return the millisecond clock value at which the event was generated"	^timeStamp ifNil:[timeStamp _ Time millisecondClockValue]! !!NewMorphicEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:34'!type	"Return a symbol indicating the type this event."	^self subclassResponsibility! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 9/22/2000 10:36'!isDraggingEvent	^false! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:17'!isDropEvent	^false! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:19'!isKeyboard	^false! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:37'!isMorphicEvent	^true! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:19'!isMouse	^false! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 9/14/2000 18:21'!isMouseOver	^self type == #mouseOver! !!NewMorphicEvent methodsFor: 'comparing' stamp: 'ar 9/13/2000 15:36'!= anEvent	anEvent isMorphicEvent ifFalse:[^false].	^self type = anEvent type! !!NewMorphicEvent methodsFor: 'comparing' stamp: 'ar 9/13/2000 15:36'!hash	^self type hash! !!NewMorphicEvent methodsFor: 'transforming' stamp: 'ar 9/13/2000 15:47'!transformedBy: aMorphicTransform	"Return the receiver transformed by the given transform into a local coordinate system."! !!NewMorphicEvent methodsFor: 'dispatching' stamp: 'ar 9/15/2000 21:12'!sentTo: anObject	"Dispatch the receiver into anObject"	^anObject handleUnknownEvent: self! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:33'!contents	^contents! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 19:21'!cursorPoint	"For compatibility with mouse events"	^position! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:33'!position	^position! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:33'!type	^#dropEvent! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:44'!wasHandled	^wasHandled! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:44'!wasHandled: aBool	wasHandled _ aBool.! !!DropEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 18:33'!isDropEvent	^true! !!DropEvent methodsFor: 'dispatching' stamp: 'ar 9/15/2000 21:12'!sentTo: anObject	"Dispatch the receiver into anObject"	^anObject handleDropMorph: self.! !!DropEvent methodsFor: 'printing' stamp: 'ar 9/14/2000 18:15'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self position printString; space.	aStream nextPutAll: self type.	aStream nextPut: $].! !!DropEvent methodsFor: 'private' stamp: 'ar 9/13/2000 19:23'!setPosition: pos contents: aMorph hand: aHand	position _ pos.	contents _ aMorph.	source _ aHand.	wasHandled _ false.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'ar 10/5/2000 11:59'!showColorPalette: evt	self comeToFront.	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 9/13/2000 19:35'!wantsDroppedMorph: aMorph event: evt	self isWorldMorph ifTrue:[^true]. "always"	aMorph willingToBeEmbeddedUponLanding ifFalse: [^ false].	self visible ifFalse: [^ false].  "will be a call to #hidden again very soon"	self dragNDropEnabled ifFalse: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	^ true! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'ar 10/3/2000 17:02'!deleteBalloonTarget: aMorph	"Delete the balloon help targeting the given morph"	self handsDo:[:h| h deleteBalloonTarget: aMorph].! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 1/25/2000 17:44'!wantsHaloFromClick	^ (owner isKindOf: SystemWindow) not! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'ar 9/15/2000 23:04'!tabHitWithEvent: anEvent	"The tab key was hit. The keyboard focus has referred this event to me, though this perhaps seems rather backwards.  Anyway, the assumption is that I have the property #tabAmongFields, so now the task is to tab to the next field"	| currentFocus fieldList anIndex itemToHighlight |	currentFocus _ anEvent hand keyboardFocus.	fieldList _ self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	anIndex _ fieldList indexOf: currentFocus ifAbsent: [nil].	itemToHighlight _ fieldList atWrap: 		(anIndex ifNotNil: [anEvent shiftPressed ifTrue: [anIndex - 1] ifFalse: [anIndex + 1]]				ifNil: [1]).	anEvent hand newKeyboardFocus: itemToHighlight. self flag: #arNote. "really???"	itemToHighlight editor selectAll.	itemToHighlight invalidRect: itemToHighlight bounds ! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 9/15/2000 23:28'!viewBox: newViewBox	| vb |	((vb _ self viewBox) == nil or: [vb extent ~= newViewBox extent])		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	super position: newViewBox topLeft."23 may 2000 - RAA - let's see if this is ok"	bounds _ newViewBox.	"0@0 extent: newViewBox extent."	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self flag: #arNote. "Probably unnecessary"	worldState handsDo: [:h | h releaseKeyboardFocus].	self fullRepaintNeeded.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/28/2000 19:25'!abandonAllHalos	self flag: #arNote. "Remove the method"	^self deleteAllHalos! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/15/2000 23:28'!deEmphasizeViewMVC: asTwoTone	self flag: #arNote. "Probably unnecessary"	worldState handsDo:          "free dependents links if any"		[:h | h releaseKeyboardFocus].	worldState canvas: nil.		"free model's canvas to save space"	self fullReleaseCachedState.	asTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		self displayWorldAsTwoTone].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/17/2000 15:33'!deleteAllHalos	self haloMorphs do:		[:m | (m target isKindOf: SelectionMorph) ifTrue: [m target delete].		m delete].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/15/2000 16:15'!haloMorphOrNil	self flag: #arNote. "Remove this method"	^self someHalo! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/28/2000 18:00'!haloMorphs	^ self hands collect:[:h| h halo] thenSelect:[:halo| halo notNil]! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 9/15/2000 11:44'!someHalo	"Return some halo that's currently visible in the world"	| m |	^ (m _ self haloMorphs) size > 0 ifTrue: [m first] ifFalse: [nil]! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/3/2000 22:46'!handlesMouseDown: evt	^true! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 16:30'!morphToGrab: event	"Return the morph to grab from a mouse down event. If none, return nil."	self submorphsDo:[:m|		(m fullContainsPoint: event cursorPoint) ifTrue:[			(m isSticky or:[m isLocked]) 				ifTrue:[^nil] "so we don't grab stuff behind"				ifFalse:[^self rootForGrabOf: m]].	].	^nil! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/3/2000 14:48'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph |	evt isMorphicEvent ifTrue:["e.g., new regime"		grabbedMorph _ self morphToGrab: evt.		grabbedMorph ifNotNil:[			evt hand grabMorph: grabbedMorph.			^evt hand releaseMouseFocus: self].		(super handlesMouseDown: evt)			ifTrue:[^super mouseDown: evt].	].	self isWorldMorph		ifTrue:			[evt isMorphicEvent ifFalse:[evt hand newKeyboardFocus: self]. self flag: #arNote. "Why???"			evt hand testEvent: evt				ifQuickClick: [self abandonAllHalos.							^ self quickClickOnDesktop: evt]				ifMoved: [evt shiftPressed							ifTrue: [^ self dragThroughOnDesktop: evt]							ifFalse: [^ super mouseDown: evt]].			self abandonAllHalos.			evt hand invokeMetaMenu: evt]		ifFalse:			[evt hand testEvent: evt				ifQuickClick: [^ super mouseDown: evt]				ifMoved: [evt shiftPressed							ifTrue: [^ self dragThroughOnDesktop: evt]							ifFalse: [^ super mouseDown: evt]].			^ super mouseDown: evt]! !!PolygonMorph methodsFor: 'menu' stamp: 'ar 10/3/2000 17:06'!customizeArrows: evt	| handle origin aHand |	aHand _ evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin _ aHand position.	handle _ HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			self arrowSpec: (newPoint - origin) / 5.0]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo doIfNotNil: [:halo | halo addHandles].].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.' hand: evt hand.	handle startStepping! !!BalloonMorph methodsFor: 'initialization' stamp: 'ar 10/4/2000 10:13'!popUpFor: aMorph hand: aHand	"Pop up the receiver as balloon help for the given hand"	balloonOwner _ aMorph.	self popUpForHand: aHand.! !!BalloonMorph methodsFor: 'initialization' stamp: 'ar 10/3/2000 16:59'!popUpForHand: aHand	"Pop up the receiver as balloon help for the given hand"	| worldBounds |	self lock.	aHand world addMorphFront: self.	"So that if the translation below makes it overlap the receiver, it won't	interfere with the rootMorphsAt: logic and hence cause flashing.  Without	this, flashing happens, believe me!!"	((worldBounds _ aHand world bounds) containsRect: self bounds) ifFalse:		[self bounds: (self bounds translatedToBeWithin: worldBounds)].	aHand balloonHelp: self.! !!BalloonMorph methodsFor: 'accessing' stamp: 'ar 10/3/2000 17:19'!balloonOwner	^balloonOwner! !!BalloonMorph methodsFor: 'testing' stamp: 'ar 9/15/2000 17:56'!isBalloonHelp	^true! !!Project methodsFor: 'menu messages' stamp: 'ar 9/18/2000 15:43'!makeThumbnail	"Make a thumbnail image of this project from the Display."	world ifNotNil:[world displayWorldSafely]. "clean pending damage"	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt current toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project class methodsFor: 'utilities' stamp: 'ar 9/16/2000 15:15'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	World primaryHand releaseAllFoci.	projectProcess _ self uiProcess.	"we still need the accessor for a while"	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 9/14/2000 16:46'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |	hand _ handWithTile ifNil: [self primaryHand].	(hand lastEvent redButtonPressed and: [(self hasOwner: hand) not]) ifTrue: [		hand submorphCount > 0 ifTrue: [			insertion _ hand firstSubmorph renderedMorph.			insHt _ insertion height.			self removeSpaces.			where _ self globalPointToLocal: hand position"insertion fullBounds topLeft".			i _ (ii _ self indexOfMorphAbove: where) min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]							ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty				ifTrue: [insertion]				ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (where y - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1).		]	] ifFalse: [		self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (ScriptingSystem unbrightColorFor: m color)			]		]	]! !!ScrollPane methodsFor: 'pane events' stamp: 'ar 9/18/2000 22:11'!handlesMouseOver: evt	"Could just ^ true, but this ensures that scroll bars won't flop out	if you mouse-over appendages such as connecting pins."	self flag: #arNote. "I have no idea how the code below could've ever worked. If the receiver does not handle mouse over events then it should not receive any #mouseLeave if the mouse leaves the receiver for real. This is because 'evt cursorPoint' describes the *end* point of the movement and considering that the code would return false if the move ends outside the receiver the scroll bars should never pop back in again. Which is exactly what happens with the new event logic if you don't just ^true. I'm leaving the code in for reference - perhaps somebody can make sense from it; I sure cannot."	^true"	| cp |	cp _ evt cursorPoint.	(bounds containsPoint: cp)		ifTrue: [^ true]					ifFalse: [self submorphsDo:					[:m | (m containsPoint: cp) ifTrue:							[m == scrollBar								ifTrue: [^ true]								ifFalse: [^ false]]].				^ false]"! !!ScrollPane methodsFor: 'pane events' stamp: 'ar 9/14/2000 18:59'!mouseMove: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	"scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseMove: (evt transformedBy: (scroller transformFrom: self))]"	self flag: #arNote. "remove me"! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/15/2000 22:57'!handlesKeyboard: evt	^true! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/14/2000 19:16'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"	| aChar aSpecialKey |	(self scrollByKeyboard: event) ifTrue: [^self].	aChar _ event keyCharacter.	aSpecialKey _ aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/14/2000 21:35'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	aMorph ifNotNil: [aMorph highlightForMouseDown]! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/15/2000 23:04'!mouseEnter: event	super mouseEnter: event.	self flag: #arNote. "remove this - keyboard input automatically goes right"	event hand newKeyboardFocus: self. ! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/18/2000 22:18'!mouseEnterDragging: anEvent onItem: aMorph 	anEvent hand hasSubmorphs ifFalse: ["no d&d"		^ self].	(self wantsDroppedMorph: anEvent hand firstSubmorph event: anEvent )		ifTrue: 			[self potentialDropMorph: aMorph]! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/15/2000 23:30'!mouseLeave: event	super mouseLeave: event.	event hand releaseKeyboardFocus: self.! !!PluggableListMorph methodsFor: 'events' stamp: 'ar 9/14/2000 21:35'!mouseUp: event onItem: aMorph 	aMorph ifNotNil: [aMorph highlightForMouseDown: false].	model okToChange ifFalse: [		^ self].	"No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].	Cursor normal show.! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'ar 9/14/2000 21:39'!startDrag: evt onItem: itemMorph 	| ddm |	evt hand hasSubmorphs		ifTrue: [^self].	itemMorph ifNotNil: [itemMorph highlightForMouseDown: false].	model okToChange ifFalse: [		Cursor normal show.		^ self].  "No change if model is locked"	"itemMorph ~= self selection ifTrue: [self setSelectedMorph: itemMorph]."	ddm _ TransferMorph withPassenger: (self model dragPassengerFor: itemMorph inMorph: self) from: self.	ddm dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation			ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].	evt hand grabMorph: ddm.	"Release the focus for the grabbed morph"	evt hand releaseMouseFocus: itemMorph.! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'ar 9/14/2000 17:48'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'ar 9/15/2000 23:21'!handlesKeyboard: evt	^true! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'ar 9/15/2000 23:22'!keyStroke: evt	textMorph keyStroke: evt! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'ar 9/15/2000 23:05'!mouseEnter: event	super mouseEnter: event.	selectionInterval ifNotNil:		[textMorph handleEdit: [textMorph editor selectInterval: selectionInterval.			textMorph editor setEmphasisHere]].	event hand newKeyboardFocus: textMorph! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'ar 9/15/2000 23:30'!mouseLeave: event	textMorph ifNotNil: [selectionInterval _ textMorph editor selectionInterval].	super mouseLeave: event.	event hand releaseKeyboardFocus: textMorph.! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'ar 9/15/2000 22:58'!handlesKeyboard: evt	^true! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'ar 9/15/2000 23:05'!mouseEnter: event	super mouseEnter: event.	event hand newKeyboardFocus: self! !!StringMorph methodsFor: 'editing' stamp: 'ar 9/14/2000 14:45'!handlesMouseDown: evt	^ (evt shiftPressed and: [self wantsKeyboardFocusOnShiftClick])		ifTrue: [evt isMorphicEvent or:[self uncoveredAt: evt cursorPoint]]		ifFalse: [super handlesMouseDown: evt].! !!StringMorph methodsFor: 'editing' stamp: 'ar 9/15/2000 23:06'!launchMiniEditor: evt	| textMorph |	hasFocus _ true.  "Really only means edit in progress for this morph"	textMorph _ StringMorphEditor new contentsAsIs: contents.	textMorph beAllFont: self fontToUse.	textMorph bounds: (self bounds expandBy: 0@2).	self addMorphFront: textMorph.	evt hand newMouseFocus: textMorph. self flag: #arNote. "Why???"	evt hand newKeyboardFocus: textMorph.	textMorph editor selectFrom: 1 to: textMorph paragraph text string size! !!MenuItemMorph methodsFor: 'initialization' stamp: 'ar 9/18/2000 18:17'!deleteIfPopUp: evt	owner ifNotNil:[owner deleteIfPopUp: evt].! !!MenuItemMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:16'!allWordingsNotInSubMenu: verbotenSubmenuContents	"Answer a collection of the wordings of all items and subitems, but omit the stay-up item, and also any items in a submenu whose tag is given by verbotenSubmenuContents"	self selector == #toggleStayUp: ifTrue:[^#()].	subMenu ifNotNil:[^subMenu allWordingsNotInSubMenu: verbotenSubmenuContents].	self contents asString = verbotenSubmenuContents ifTrue:[^#()].	^Array with: self contents asString! !!MenuItemMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:40'!hasSubMenu	"Return true if the receiver has a submenu"	^subMenu notNil! !!MenuItemMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:18'!hasSubMenu: aMenuMorph	subMenu ifNil:[^false].	subMenu == aMenuMorph ifTrue:[^true].	^subMenu hasSubMenu: aMenuMorph! !!MenuItemMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:22'!itemWithWording: wording	"If any of the receiver's items or submenu items have the given wording (case-blind comparison done), then return it, else return nil."	(self contents asString sameAs: wording) ifTrue:[^self].	subMenu ifNotNil:[^subMenu itemWithWording: wording].	^nil! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/18/2000 10:31'!handleMouseUp: evt	evt wasHandled ifTrue:[^self].	super handleMouseUp: evt.	self receiveNewFocus: evt. "pass focus explicitly"! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/16/2000 14:40'!handlesMouseOver: anEvent	^true! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/18/2000 21:46'!handlesMouseOverDragging: evt	^true! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/4/2000 10:11'!invokeWithEvent: evt	"Perform the action associated with the given menu item."	| selArgCount |	self isEnabled ifFalse: [^ self].	selector ifNil:[^self].	target class == HandMorph ifTrue: [(self notObsolete) ifFalse: [^ self]].	owner ifNotNil:[selector == #toggleStayUp: ifFalse:[owner deleteIfPopUp: evt]].	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		(selArgCount _ selector numArgs) = 0			ifTrue:				[target perform: selector]			ifFalse:				[selArgCount = arguments size					ifTrue: [target perform: selector withArguments: arguments]					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/4/2000 16:20'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	owner selectItem: self event: evt.	self receiveNewFocus: evt.! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/17/2000 20:33'!mouseEnter: evt	owner stayUp ifFalse:[self mouseEnterDragging: evt].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/18/2000 12:17'!mouseEnterDragging: evt	owner selectItem: self event: evt! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/18/2000 13:22'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	self deselect: evt.	self invokeWithEvent: evt.		! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 9/18/2000 13:22'!receiveNewFocus: evt	"If necessary, have the receiver's owner receive the new mouse focus."	owner ifNotNil:[owner receiveNewFocus: evt].! !!MenuItemMorph methodsFor: 'private' stamp: 'ar 9/18/2000 10:27'!notObsolete	"Provide backward compatibility with messages being sent to the Hand.  Remove this when no projects made prior to 2.9 are likely to be used.  If this method is removed early, the worst that can happen is a notifier when invoking an item in an obsolete menu."	(HandMorph canUnderstand: (selector)) ifTrue: [^ true]. 	"a modern one"	self inform: 'This world menu is obsolete.Please dismiss the menu and open a new one.'.	^ false! !!MenuItemMorph methodsFor: 'copying' stamp: 'ar 9/18/2000 11:57'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.isEnabled _ isEnabled veryDeepCopyWith: deepCopier.subMenu _ subMenu veryDeepCopyWith: deepCopier.isSelected _ isSelected veryDeepCopyWith: deepCopier."target _ target.		Weakly copied""selector _ selector.		a Symbol"arguments _ arguments.		"All weakly copied"! !!MenuItemMorph methodsFor: 'selecting' stamp: 'ar 9/17/2000 20:46'!deselect: evt	self isSelected: false.	subMenu ifNotNil: [subMenu delete].! !!MenuItemMorph methodsFor: 'selecting' stamp: 'ar 9/18/2000 11:09'!isSelected: aBoolean	isSelected _ aBoolean.	self changed.! !!MenuItemMorph methodsFor: 'selecting' stamp: 'ar 9/18/2000 12:17'!select: evt	self isSelected: true.	owner activeSubmenu: subMenu.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAdjacentTo: (Array with: self bounds topRight + (10@0)									with: self bounds topLeft)			forHand: evt hand			from: self.		subMenu selectItem: nil event: evt].! !!MenuItemMorph methodsFor: 'grabbing' stamp: 'ar 9/21/2000 15:43'!aboutToBeGrabbedBy: aHand	"Don't allow the receiver to act outside a Menu"	| menu box |	owner submorphs size = 1 ifTrue:[		"I am a lonely menuitem already; just grab my owner"		^owner stayUp: true].	box _ self bounds.	menu _ MenuMorph new defaultTarget: owner defaultTarget.	menu addMorphFront: self.	menu bounds: box.	menu stayUp: true.	^menu! !!MenuItemMorph methodsFor: 'object fileIn' stamp: 'ar 9/18/2000 14:47'!convertbosfcefechiisitsa0: varDict bosfcefechisitsa0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'font' 'emphasis' 'contents' 'hasFocus' 'isEnabled' 'subMenu' 'isSelected' 'target' 'selector' 'arguments').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('isInTransition').  Possibly store their info in another variable?"! !!SystemWindow methodsFor: 'top window' stamp: 'ar 9/14/2000 11:26'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph sketchEditor pal |	outerMorph _ self topRendererOrSelf.	outerMorph owner ifNil: [^ self "avoid spurious activate when drop in trash"].	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColorToUse.	self isCollapsed ifFalse:		[model modelWakeUpIn: self.		self positionSubmorphs].	(sketchEditor _ self extantSketchEditor) ifNotNil:		[sketchEditor comeToFront.		(pal _ self world findA: PaintBoxMorph) ifNotNil:			[pal comeToFront]].! !!SystemWindow methodsFor: 'top window' stamp: 'ar 9/14/2000 11:26'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColorToUse.	model modelSleep.	self submorphsDo:		[:m | (m == closeBox or: [m == collapseBox])				ifTrue: ["Control boxes remain active, except in novice mode"						Preferences noviceMode ifTrue: [m lock]]				ifFalse: [m lock]].	self world ifNotNil:  "clean damage now, so dont merge this rect with new top window"		[self world == Display bestGuessOfCurrentWorld ifTrue: [self world displayWorld]].! !!SystemWindow methodsFor: 'events' stamp: 'ar 9/14/2000 11:26'!mouseDown: evt	| cp |	TopWindow == self ifFalse: [self activate].	(Sensor redButtonPressed "If mouse is really still down after activate"			and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[^ self isSticky ifFalse:			[self fastFramingOn 				ifTrue: [self doFastFrameDrag]				ifFalse: [evt hand grabMorph: self topRendererOrSelf]]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'ar 9/18/2000 18:34'!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph"	^aMorph isWorldMorph or:[Preferences systemWindowEmbedOK]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'ar 9/14/2000 16:45'!defersHaloOnClickTo: aSubMorph	"If a cmd-click on aSubMorph would make it a preferred recipient of the halo, answer true"	^ currentPage notNil and:		[(aSubMorph hasOwner: currentPage)			and: [currentPage defersHaloOnClickTo: aSubMorph]]	! !!Tetris methodsFor: 'events' stamp: 'ar 9/15/2000 22:58'!handlesKeyboard: evt	^true! !!Tetris methodsFor: 'events' stamp: 'ar 9/15/2000 23:07'!mouseEnter: evt        evt hand newKeyboardFocus: self! !!TextMorph methodsFor: 'editing' stamp: 'ar 10/4/2000 19:09'!handlesKeyboard: evt	^true! !!TextMorph methodsFor: 'editing' stamp: 'ar 9/14/2000 14:45'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ evt isMorphicEvent or:[self uncoveredAt: evt cursorPoint]! !!TextMorph methodsFor: 'editing' stamp: 'ar 10/4/2000 18:43'!keyStroke: evt	"Handle a keystroke event."	self handleInteraction: [editor readKeyboard] fromEvent: evt.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'ar 9/15/2000 23:25'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	evt hand newKeyboardFocus: self.	self handleInteraction: [editor mouseDown: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'ar 9/15/2000 23:25'!passKeyboardFocusTo: otherMorph	| w |self flag: #arNote. "Do we need this?!!"	(w _ self world) == nil ifFalse:		[w handsDo:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].! !!StringMorphEditor methodsFor: 'all' stamp: 'ar 9/15/2000 23:06'!handlesKeyboard: evt	^true! !!StringMorphEditor methodsFor: 'all' stamp: 'ar 9/15/2000 23:29'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor oldSel newSel |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner acceptContents; doneWithEdits.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	oldSel _ self editor selectionInterval.	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	oldSel = newSel ifTrue:		["There is a bug that causes characters to be misplaced when the second		character typed is wider than the first.  This fixes it (ugh)."		self editor selectFrom: newSel first + 1 to: newSel last + 1].! !!TextMorphEditor methodsFor: 'events' stamp: 'ar 9/15/2000 23:29'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		self flag: #arNote. "Probably unnecessary"		evt hand releaseKeyboardFocus: self.		^ self].	sensor leftShiftDown		ifFalse:			[self closeTypeIn.			stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock				ifTrue: [stopBlock _ startBlock.						pivotBlock _ stopBlock]				ifFalse: [startBlock _  stopBlock.						pivotBlock _ startBlock].			self closeTypeIn].	self storeSelectionInParagraph! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'ar 9/15/2000 22:57'!handlesKeyboard: evt	^true! !!TileMorph methodsFor: 'accessing' stamp: 'ar 9/15/2000 23:31'!abandonLabelFocus	"If the receiver's label has editing focus, abandon it"	self flag: #arNote. "Probably unnecessary"	self currentHand releaseKeyboardFocus: self labelMorph.! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 9/18/2000 18:03'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	| aPoint |	upArrow ifNotNil:		[(upArrow bounds containsPoint: (aPoint _ anEvent cursorPoint))			ifTrue: [^self].		(downArrow bounds containsPoint: aPoint)			ifTrue: [^self]].	^super handlerForMouseDown: anEvent! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/3/2000 14:56'!handlesMouseDown: evt	"Answer whether the receiver would handle the mouseDown represented by evt"	| aPoint |	aPoint _ evt cursorPoint.	(operatorOrExpression notNil and: [upArrow notNil]) ifTrue: [^ true].		"Click on the operator presents list of alternatives"	upArrow ifNotNil: [((upArrow bounds containsPoint: aPoint) or: [downArrow bounds containsPoint: aPoint])		ifTrue: [^ true]].	suffixArrow ifNotNil: [(suffixArrow bounds containsPoint: aPoint)		ifTrue: [^ true]].	retractArrow ifNotNil: [(retractArrow bounds containsPoint: aPoint)		ifTrue: [^ true]].	^ super handlesMouseDown: evt! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'ar 9/12/2000 23:05'!handlerForMouseDown: anEvent	"Don't give anybody over me a chance"	^self! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 9/15/2000 23:27'!abandonLabelFocus	| aLabel |	"If the receiver's label has editing focus, abandon it"	self flag: #arNote. "Probably unnecessary"	(aLabel _ self labelMorph) ifNotNil:		[aLabel hasFocus ifTrue:			[aLabel contents: aLabel readFromTarget.			aLabel handsWithMeForKeyboardFocus do:				[:aHand | aHand releaseKeyboardFocus]]]! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 9/14/2000 14:44'!handlesMouseDown: evt	^ self inPartsBin not and: [evt isMorphicEvent or:[self uncoveredAt: evt cursorPoint]]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'ar 9/14/2000 14:45'!handlesMouseDown: evt	(owner wantsKeyboardFocusFor: self)		ifTrue:[^evt isMorphicEvent or:[self uncoveredAt: evt cursorPoint]].	^ super handlesMouseDown: evt! !!UserInputEvent methodsFor: 'initialize' stamp: 'ar 9/13/2000 15:54'!copyHandlerState: anEvent	"Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."	handler _ anEvent handler.	wasHandled _ anEvent wasHandled.! !!UserInputEvent methodsFor: 'initialize' stamp: 'ar 9/13/2000 15:54'!resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	handler _ nil.	wasHandled _ false.! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:45'!buttons	"Return the a word encoding the mouse and modifier buttons for this event."	^ buttons! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!handler	^handler! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!handler: anObject	handler _ anObject! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 22:45'!position	^position! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:45'!type	"Return a symbol indicating the type this event."	^ type! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!wasHandled	^wasHandled! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!wasHandled: aBool	wasHandled _ aBool.! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:43'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command key "	^ self buttons anyMask: 16r70	"cmd | opt | ctrl"! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:43'!commandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 64! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:44'!controlKeyPressed	"Answer true if the control key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 16! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:44'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	Preferences macOptionKeyAllowed ifFalse: [self notify: 'Portability note:MorphicEvent>>macOptionKeyPressed is not portable.Please use MorphicEvent>>yellowButtonPressed instead!!'].	^ buttons anyMask: 32! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:44'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!KeyboardEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:49'!isKeyDown	^self type == #keyDown! !!KeyboardEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:49'!isKeyUp	^self type == #keyUp! !!KeyboardEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:49'!isKeyboard	^true! !!KeyboardEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:49'!isKeystroke	^self type == #keystroke! !!KeyboardEvent methodsFor: 'comparing' stamp: 'ar 9/13/2000 15:50'!= aMorphicEvent	super = self ifFalse:[^false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	keyValue = aMorphicEvent keyValue ifFalse: [^ false].	^ true! !!KeyboardEvent methodsFor: 'comparing' stamp: 'ar 9/13/2000 15:50'!hash	^buttons hash + keyValue hash! !!KeyboardEvent methodsFor: 'keyboard' stamp: 'ar 9/13/2000 15:51'!keyCharacter	"Answer the character corresponding this keystroke. This is defined only for keystroke events."	^ keyValue asCharacter! !!KeyboardEvent methodsFor: 'keyboard' stamp: 'ar 9/13/2000 15:51'!keyValue	"Answer the ascii value for this keystroke. This is defined only for keystroke events."	^ keyValue! !!KeyboardEvent methodsFor: 'dispatching' stamp: 'ar 9/15/2000 21:13'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #keystroke ifTrue:[^anObject handleKeystroke: self].	type == #keyDown ifTrue:[^anObject handleKeyDown: self].	type == #keyUp ifTrue:[^anObject handleKeyUp: self].	^super sentTo: anObject.! !!KeyboardEvent methodsFor: 'printing' stamp: 'ar 9/13/2000 15:51'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: type.	self controlKeyPressed ifTrue: [		aStream nextPutAll: ' ''^'.		aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter.	] ifFalse: [		aStream nextPutAll: ' '''.		aStream nextPut: self keyCharacter.	].	aStream nextPut: $'.	aStream nextPut: $].! !!KeyboardEvent methodsFor: 'printing' stamp: 'ar 9/13/2000 15:52'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	buttons storeOn: aStream.	aStream space.	keyValue storeOn: aStream.! !!KeyboardEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:46'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand	type _ aSymbol.	buttons _ anInteger.	position _ pos.	keyValue _ aValue.	source _ aHand.	wasHandled _ false.! !!MouseEvent methodsFor: 'accessing' stamp: 'ar 9/25/2000 14:26'!noticeMouseOver: aMorph	source ifNotNil:[source noticeMouseOver: aMorph event: self].! !!MouseEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 22:51'!position	^position! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/22/2000 10:37'!isDraggingEvent	source ifNil:[^false].	^source isDraggingEvent: self! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:30'!isMouse	^true! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseDown	^self type == #mouseDown! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseEnter	^self type == #mouseEnter! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseLeave	^self type == #mouseLeave! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseMove	^self type == #mouseMove! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseUp	^self type == #mouseUp! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:29'!isMove	^false! !!MouseEvent methodsFor: 'comparing' stamp: 'ar 9/15/2000 22:50'!= aMorphicEvent	super = aMorphicEvent ifFalse:[^false].	position = aMorphicEvent position ifFalse: [^ false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	^ true! !!MouseEvent methodsFor: 'comparing' stamp: 'ar 9/15/2000 22:47'!hash	^ position hash + buttons hash! !!MouseEvent methodsFor: 'button state' stamp: 'ar 9/13/2000 15:38'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: 7! !!MouseEvent methodsFor: 'button state' stamp: 'ar 9/13/2000 15:38'!blueButtonPressed	"Answer true if the blue mouse button is being pressed. This is the third mouse button or cmd+click on the Mac."	^ buttons anyMask: 1! !!MouseEvent methodsFor: 'button state' stamp: 'ar 9/15/2000 22:51'!cursorPoint	"Answer the location of the cursor's hotspot when this event occured."	^ position! !!MouseEvent methodsFor: 'button state' stamp: 'ar 9/13/2000 15:39'!redButtonPressed	"Answer true if the red mouse button is being pressed. This is the first mouse button."	^ buttons anyMask: 4! !!MouseEvent methodsFor: 'button state' stamp: 'ar 9/15/2000 22:51'!targetPoint	"Answer the location of the cursor's hotspot, adjusted by the offset	of the last mouseDown relative to the recipient morph."	^ position - source targetOffset! !!MouseEvent methodsFor: 'button state' stamp: 'ar 9/13/2000 15:40'!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac."	^ buttons anyMask: 2! !!MouseEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:51'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position _  aMorphicTransform globalPointToLocal: position.! !!MouseEvent methodsFor: 'transforming' stamp: 'ar 9/13/2000 15:47'!transformedBy: aMorphicTransform	"Return the receiver transformed by the given transform into a local coordinate system."	^self shallowCopy transformBy: aMorphicTransform! !!MouseEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:51'!translateBy: delta	"add delta to cursorPoint, and return the new event"	position _ position + delta.! !!MouseEvent methodsFor: 'transforming' stamp: 'ar 9/13/2000 15:52'!translatedBy: delta	"add delta to cursorPoint, and return the new event"	^self shallowCopy translateBy: delta! !!MouseEvent methodsFor: 'converting' stamp: 'ar 9/25/2000 14:29'!asMouseOver	"Convert the receiver into a mouse over event"	^MouseEvent new setType: #mouseOver position: position buttons: buttons hand: source! !!MouseEvent methodsFor: 'dispatching' stamp: 'ar 9/25/2000 14:38'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #mouseOver ifTrue:[^anObject handleMouseOver: self].	^super sentTo: anObject.! !!MouseEvent methodsFor: 'printing' stamp: 'ar 9/13/2000 15:41'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self cursorPoint printString; space.	aStream nextPutAll: type.	aStream nextPut: $].! !!MouseEvent methodsFor: 'printing' stamp: 'ar 9/15/2000 22:50'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	position x storeOn: aStream.	aStream space.	position y storeOn: aStream.	aStream space.	buttons storeOn: aStream.! !!MouseEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:53'!setType: evtType position: evtPos buttons: evtButtons hand: evtHand	type _ evtType.	position _ evtPos.	buttons _ evtButtons.	source _ evtHand.	wasHandled _ false.! !!MouseButtonEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:53'!setType: evtType position: evtPos which: button buttons: evtButtons hand: evtHand	type _ evtType.	position _ evtPos.	buttons _ evtButtons.	source _ evtHand.	wasHandled _ false.	whichButton _ button.! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 19:58'!blueButtonChanged	"Answer true if the blue mouse button has changed. This is the third mouse button or cmd+click on the Mac."	^ whichButton anyMask: 1! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 19:58'!redButtonChanged	"Answer true if the red mouse button has changed. This is the first mouse button."	^ whichButton anyMask: 4! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 19:59'!yellowButtonChanged	"Answer true if the yellow mouse button has changed. This is the second mouse button or option+click on the Mac."	^ whichButton anyMask: 2! !!MouseButtonEvent methodsFor: 'dispatching' stamp: 'ar 9/16/2000 13:05'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #mouseDown ifTrue:[^anObject handleMouseDown: self].	type == #mouseUp ifTrue:[^anObject handleMouseUp: self].	^super sentTo: anObject! !!MouseMoveEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 22:51'!endPoint	"Return the point where the movement ended."	^position! !!MouseMoveEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 16:25'!startPoint	"Return the point where the movement started."	^startPoint! !!MouseMoveEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 16:25'!trail	"Return any immediate points that have been assembled along the move"	^trail! !!MouseMoveEvent methodsFor: 'comparing' stamp: 'ar 9/15/2000 22:49'!= aMorphicEvent	super = aMorphicEvent ifFalse:[^false].	position = aMorphicEvent position ifFalse: [^ false].	startPoint = aMorphicEvent startPoint ifFalse: [^ false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	^ true! !!MouseMoveEvent methodsFor: 'comparing' stamp: 'ar 9/15/2000 22:49'!hash	^ position hash + startPoint hash + buttons hash! !!MouseMoveEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:29'!isMove	^true! !!MouseMoveEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:52'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position _  aMorphicTransform globalPointToLocal: position.	startPoint _  aMorphicTransform globalPointToLocal: startPoint.! !!MouseMoveEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:52'!translateBy: delta	"add delta to cursorPoint, and return the new event"	position _ position + delta.	startPoint _ startPoint + delta.! !!MouseMoveEvent methodsFor: 'printing' stamp: 'ar 9/13/2000 16:26'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self startPoint printString; space.	aStream nextPutAll: self endPoint printString; space.	aStream nextPutAll: self type.	aStream nextPut: $].! !!MouseMoveEvent methodsFor: 'printing' stamp: 'ar 9/13/2000 16:28'!storeOn: aStream	super storeOn: aStream.	aStream space.	self endPoint x storeOn: aStream.	aStream space.	self endPoint y storeOn: aStream.	aStream space.	trail storeOn: aStream.! !!MouseMoveEvent methodsFor: 'dispatching' stamp: 'ar 9/15/2000 21:13'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #mouseMove ifTrue:[^anObject handleMouseMove: self].	type == #mouseEnter ifTrue:[^anObject handleMouseEnter: self].	type == #mouseLeave ifTrue:[^anObject handleMouseLeave: self].	^super sentTo: anObject.! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 9/13/2000 16:43'!beMouseEnter	"Private. Magically convert the receiver into a mouse enter event. Done when a mouse move crosses the clipping boundary of some morph in which case it is known to start outside the child."	type _ #mouseEnter.! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 9/13/2000 16:43'!beMouseLeave	"Private. Magically convert the receiver into a mouse leave event. Done when a mouse move crosses the clipping boundary of some morph in which case it is known to end outside the child."	type _ #mouseLeave! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:53'!setType: evtType startPoint: evtStart endPoint: evtEnd trail: evtTrail buttons: evtButtons hand: evtHand	type _ evtType.	startPoint _ evtStart.	position _ evtEnd.	trail _ evtTrail.	buttons _ evtButtons.	source _ evtHand.	wasHandled _ false.! !!Viewer methodsFor: 'as yet unclassified' stamp: 'ar 9/18/2000 18:34'!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph"	^aMorph isWorldMorph "only into worlds"! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'ar 9/15/2000 23:29'!viewBox: newViewBox	| vb |	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	bounds _ newViewBox.	worldState assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self flag: #arNote. "Probably unnecessary"	worldState handsDo: [:h | h releaseKeyboardFocus].	self fullRepaintNeeded.! !!MVCWiWPasteUpMorph methodsFor: 'initialization' stamp: 'ar 9/15/2000 23:27'!viewBox: newViewBox	| vb |	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	self bounds: newViewBox.		"works better here than simply storing into bounds"	worldState assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self flag: #arNote. "Probably unnecessary"	worldState handsDo: [:h | h releaseKeyboardFocus].	self fullRepaintNeeded.! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:00'!handlesKeyboard: evt	^true! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:25'!mouseEnter: evt	"When the mouse enters our window give it the keyboard focus"	evt hand newKeyboardFocus: self.	mode = #paint ifTrue: [evt hand showTemporaryCursor: palette actionCursor].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:31'!mouseLeave: evt	"When the mouse leaves our window release the keyboard focus"	evt hand releaseKeyboardFocus: self.	mode = #paint ifTrue: [evt hand showTemporaryCursor: nil]! !!WorldState methodsFor: 'update cycle' stamp: 'ar 10/4/2000 15:56'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	false ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!MouseEvent reorganize!('accessing' noticeMouseOver: position)('testing' isDraggingEvent isMouse isMouseDown isMouseEnter isMouseLeave isMouseMove isMouseUp isMove)('comparing' = hash)('button state' anyButtonPressed blueButtonPressed cursorPoint redButtonPressed targetPoint yellowButtonPressed)('transforming' transformBy: transformedBy: translateBy: translatedBy:)('converting' asMouseOver)('dispatching' sentTo:)('printing' printOn: storeOn:)('private' setType:position:buttons:hand:)!!UserInputEvent reorganize!('initialize' copyHandlerState: resetHandlerFields)('accessing' buttons handler handler: position type wasHandled wasHandled:)('modifier state' anyModifierKeyPressed commandKeyPressed controlKeyPressed macOptionKeyPressed shiftPressed)!MenuItemMorph removeSelector: #bringMenuChainToFront!MenuItemMorph removeSelector: #deletePopupBackToCommonMenuWith:!MenuItemMorph removeSelector: #deselectForNewMorph:!MenuItemMorph removeSelector: #deselectItem!MenuItemMorph removeSelector: #hideSubmenu!MenuItemMorph removeSelector: #isInMenu!MenuItemMorph removeSelector: #mouseMove:!MenuItemMorph removeSelector: #selectFromHand:!StringMorph subclass: #MenuItemMorph	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments '	classVariableNames: 'SubMenuMarker '	poolDictionaries: ''	category: 'Morphic-Menus'!MVCMenuMorph removeSelector: #invokeItem:event:!MenuMorph subclass: #MVCMenuMorph	instanceVariableNames: 'done mvcSelection '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!MenuMorph removeSelector: #canDetachSubMenu:!MenuMorph removeSelector: #deleteIfPopUp!MenuMorph removeSelector: #deleteIfPopUpFrom:event:!MenuMorph removeSelector: #invokeItem:!MenuMorph removeSelector: #lastSelection:!MenuMorph removeSelector: #notObsolete:!MenuMorph removeSelector: #popUpAt:event:!MenuMorph removeSelector: #positionAt:!MenuMorph removeSelector: #positionAt:relativeTo:!MenuMorph removeSelector: #removeItem:!AlignmentMorph subclass: #MenuMorph	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!Morph removeSelector: #classForHalo!Morph removeSelector: #eachStepInOwnerChainDo:!Morph removeSelector: #hasInOwnerChain:!Morph removeSelector: #withAllContainers!!Morph reorganize!('initialization' initialExtent initialize openInHand openInMVC openInWindow openInWindowLabeled: openInWindowLabeled:inWorld: openInWorld openInWorld: standardPalette)('classification' isAlignmentMorph isBalloonHelp isFlap isFlapOrTab isFlapTab isFlashMorph isFlexMorph isHandMorph isModalShell isMorph isPlayfieldLike isRenderer isWorldMorph isWorldOrHandMorph)('accessing' actorState actorState: actorStateOrNil asMorph balloonHelpTextForHandle: balloonText balloonTextSelector: beSticky color color: colorForInsets eventHandler eventHandler: forwardDirection hasTranslucentColor highlight highlightColor highlightColor: isLocked isSticky lock lock: modelOrNil player player: regularColor regularColor: rememberedColor rememberedColor: sqkPage toggleStickiness unHighlight unlock unlockContents url userString)('access properties' hasProperty: removeProperty: setProperty:toValue: valueOfProperty: valueOfProperty:ifAbsent:)('copying' copy copyRecordingIn: copyWithoutSubmorphs deepCopy duplicate fullCopy updateReferencesUsing: usableSiblingInstance veryDeepCopyWith: veryDeepCopyWithoutPlayer veryDeepFixupWith: veryDeepInner:)('structure' activeHand allOwners allOwnersDo: currentHand hasOwner: isInWorld morphPreceding: nearestOwnerThat: outermostMorphThat: outermostWorldMorph owner ownerThatIsA: ownerThatIsA:orA: pasteUpMorph presenter primaryHand renderedMorph root rootAt: topPasteUp topRendererOrSelf withAllOwners withAllOwnersDo: world)('submorphs-accessing' allMorphs allMorphsDo: allMorphsNotInPartsBins allMorphsNotInPartsBinsDo: allNonSubmorphMorphs couldBeOwnedBy: findA: findDeepSubmorphThat:ifAbsent: firstSubmorph hasSubmorphWithProperty: hasSubmorphs lastSubmorph morphsAt: morphsAt:addTo: morphsAtGlobal: rootMorphsAt: rootMorphsAtGlobal: shuffleSubmorphs submorphCount submorphNamed: submorphNamed:ifNone: submorphOfClass: submorphThat:ifNone: submorphWithProperty: submorphs submorphsBehind:do: submorphsDo: submorphsInFrontOf:do: submorphsReverseDo: submorphsSatisfying: uncoveredAt: unlockedMorphsAt: unlockedMorphsAt:addTo: unlockedMorphsAtGlobal:)('submorphs-add/remove' abandon addAllMorphs: addAllMorphs:after: addMorph: addMorph:after: addMorph:asElementNumber: addMorph:behind: addMorph:inFrontOf: addMorphBack: addMorphCentered: addMorphFront: addMorphFront:fromWorldPosition: addMorphNearBack: comeToFront copyWithoutSubmorph: delete deleteSubmorphsWithProperty: dismissViaHalo goBehind privateDelete removeAllMorphs removeAllMorphsIn: removeEmptyLayoutMorphs replaceSubmorph:by: submorphIndexOf:)('drawing' areasRemainingToFill: basicFullDrawOn: boundingBoxOfSubmorphs doesOwnRotation drawDropHighlightOn: drawErrorOn: drawMouseDownHighlightOn: drawOn: drawOnCanvas: drawPostscriptOn: drawSubmorphsOn: flash fullBounds fullDrawOn: fullDrawPostscriptOn: hide highlightForMouseDown highlightForMouseDown: highlightedForMouseDown imageForm imageForm:forRectangle: imageFormDepth: imageFormForRectangle: imageFormWithout:andStopThere: refreshWorld shadowForm show visible visible:)('geometry' align:with: bottom bottom: bottomLeft bottomLeft: bottomRight bottomRight: bounds bounds: boundsInOutermostWorld boundsInWorld center center: extent extent: fullBoundsInWorld globalPointToLocal: gridPoint: griddedPoint: height height: innerBounds left left: localPointToGlobal: minExtent minHeight minWidth minimumExtent minimumExtent: nextOwnerPage pointFromWorld: pointInWorld: position position: positionInWorld positionSubmorphs previousOwnerPage right right: screenLocation screenRectangle setConstrainedPositionFrom: shiftSubmorphsBy: shiftSubmorphsOtherThan:by: top top: topLeft topLeft: topRight topRight: width width: worldBounds worldBoundsForHalo)('rotate scale and flex' addFlexShell keepsTransform newTransformationMorph rotationDegrees)('geometry testing' containsPoint: fullContainsPoint: obtrudesBeyondContainer)('geometry eToy' addTransparentSpacerOfSize: beTransparent cartesianXY cartesianXY: color:sees: colorUnder degreesOfFlex forwardDirection: getIndexInOwner goHome heading heading: move:toPosition: referencePosition referencePosition: referencePositionInWorld referencePositionInWorld: rotationCenter rotationCenter: setIndexInOwner: touchesColor: transparentSpacerOfSize: wrap x x: x:y: y y:)('thumbnail' morphRepresented permitsThumbnailing representativeNoTallerThan:norWiderThan:thumbnailHeight: updateThumbnailUrl updateThumbnailUrlInBook:)('dropping/grabbing' aboutToBeGrabbedBy: acceptDroppingMorph:event: allowSubmorphExtraction asDraggableMorph disableDragNDrop dragEnabled dragNDropEnabled dragSelectionColor dropEnabled dropHighlightColor dropSuccessColor enableDrag: enableDragNDrop enableDragNDrop: enableDrop: highlightForDrop highlightForDrop: highlightedForDrop justDroppedInto:event: morphToDropFrom: repelsMorph:event: resetHighlightForDrop rootForGrabOf: slideBackToFormerSituation: slideToTrash: substituteForMorph:beingDroppedOn: toggleDragNDrop transportedMorph vanishAfterSlidingTo:event: wantsDroppedMorph:event: wantsToBeDroppedInto: wantsToBeOpenedInWorld willingToBeDiscarded willingToBeEmbeddedUponLanding)('event handling' click click: cursorPoint dispatchKeystroke: doubleClick: handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: hasFocus keyDown: keyStroke: keyUp: keyboardFocusChange: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: on:send:to: on:send:to:withValue: preemptsMouseDown: removeLink: restoreSuspendedEventHandler startDrag: suspendEventHandler transformFrom: transformFromNearestWorld transformFromOutermostWorld transformFromWorld trumpsMouseDown: wantsEveryMouseMove wantsKeyboardFocusFor: wouldAcceptKeyboardFocus wouldAcceptKeyboardFocusUponTab)('pen' choosePenColor: choosePenSize getPenColor getPenDown getPenSize liftPen lowerPen penColor: penUpWhile: trailMorph)('naming' choosePartName defaultNameStemForInstances externalName innocuousName knownName name: nameForFindWindowFeature nameInModel renameTo: setNamePropertyTo: setNameTo: specialNameInModel)('stepping and presenter' arrangeToStartStepping arrangeToStartSteppingIn: isStepping start startStepping startSteppingIn: step stepAt: stepTime stop stopStepping stopSteppingSelfAndSubmorphs wantsSteps)('menus' absorbStateFromRenderer: addAddHandMenuItemsForHalo:hand: addCustomHaloMenuItems:hand: addCustomMenuItems:hand: addDropShadow addDropShadowItemsTo:hand: addFillStyleMenuItems:hand: addPaintingItemsTo:hand: addTitleForHaloMenu: adhereToEdge adhereToEdge: adjustedCenter adjustedCenter: allMenuWordings changeColor chooseNewGraphic chooseNewGraphicCoexisting: collapse doMenuItem: inspectInMorphic lockUnlockMorph lockedString makeNascentScript maybeAddCollapseItemTo: menuItemAfter: menuItemBefore: printPSToFile resetForwardDirection setRotationCenter setRotationCenterFrom: setToAdhereToEdge: snapToEdgeIfAppropriate stickinessString transferStateToRenderer:)('halos and balloon help' addHalo addHalo: addHalo:from: addHaloFor: addHandlesTo:box: addOptionalHandlesTo:box: addSimpleHandlesTo:box: addWorldHandlesTo:box: balloonColor balloonHelpAligner balloonHelpDelayTime boundsForBalloon comeToFrontAndAddHalo defersHaloOnClickTo: deleteBalloon editBalloonHelpContent: editBalloonHelpText halo haloClass haloDelayTime hasHalo hasHalo: isLikelyRecipientForMouseOverHalos mouseDownOnHelpHandle: noHelpString removeHalo seeksOutHalo setBalloonText: setBalloonText:maxLineLength: setCenteredBalloonText: showBalloon: showBalloon:hand: transferHalo:from: wantsBalloon wantsDirectionHandles wantsHalo wantsHaloFor: wantsHaloFromClick)('change reporting' changed colorChangedForSubmorph: invalidRect: layoutChanged ownerChanged userSelectedColor:)('player' assureExternalName assuredPlayer newPlayerInstance okayToDuplicate showPlayerMenu)('player commands' beep beep: jumpTo: makeFenceSound set:)('player viewer' openViewerForArgument updateLiteralLabel)('scripting' categoriesForViewer categoryElementsFor: instantiatedUserScriptsDo: isTileLike isTileScriptingElement jettisonScripts justClonedFrom: makeAllTilesColored makeAllTilesGreen restoreTypeColor scriptEditorFor: scriptPerformer tearOffTile updatingTileForArgType:partName:getSelector:putSelector: useUniformTileColor viewAfreshIn:showingScript:at:)('e-toy support' adaptToWorld: allMorphsAndBookPagesInto: asNumber: asWearableCostume automaticViewing configureForKids containingWindow copyCostumeStateFrom: currentPlayerDo: cursor cursor: definePath deletePath embedInWindow embeddedInMorphicWindowLabeled: enforceTileColorPolicy fenceEnabled followPath getNumericValue gridFormOrigin:grid:background:line: holdsDataForEachInstance isAViewer isCandidateForAutomaticViewing makeGraphPaper makeGraphPaperGrid:background:line: mustBeBackmost nextPageButton objectViewed previousPageButton referencePlayfield rotationStyle rotationStyle: setNumericValue: setStandardTexture succeededInRevealing: textureParameters unlockOneSubpart updateCachedThumbnail wrappedInWindow: wrappedInWindowWithTitle:)('button')('parts bin' inPartsBin isPartsBin isPartsDonor isPartsDonor: markAsPartsDonor residesInPartsBin)('printing' asEPS asPostscript asPostscriptPrintJob clipPostscript colorString: constructorString defaultLabelForInspector fullPrintOn: initString printConstructorOn:indent: printConstructorOn:indent:nodeDict: printOn: printSpecs printSpecs: printStructureOn:indent: structureString)('property extension' assureExtension copyPropertiesFrom:dict: extension otherProperties)('caching' fullLoadCachedState fullReleaseCachedState loadCachedState releaseCachedState)('debug and other' addDebuggingItemsTo:hand: addMouseActionIndicatorsWidth:color: addMouseUpAction addMouseUpActionWith: allStringsAfter: altSpecialCursor0 altSpecialCursor1 altSpecialCursor2 altSpecialCursor3 altSpecialCursor3: debuggingMenuFor: defineTempCommand deleteAnyMouseActionIndicators inspectOwnerChain installModelIn: ownerChain programmedMouseDown:for: programmedMouseEnter:for: programmedMouseLeave:for: programmedMouseUp:for: programmedMouseUp:for:with: removeMouseUpAction resumeAfterDrawError resumeAfterStepError slotSpecifications tempCommand)('private' moveWithPenDownBy: moveWithPenDownByRAA: privateAddMorph:atIndex: privateBounds: privateColor: privateDeleteWithAbsolutelyNoSideEffects privateFullBounds: privateFullMoveBy: privateMoveBy: privateOwner: privateRemoveMorph: privateRemoveMorphWithAbsolutelyNoSideEffects: privateSubmorphs privateSubmorphs:)('fileIn/out' attachToResource objectForDataStream: prepareToBeSaved reserveUrl: saveAsResource saveDocPane saveOnFile saveOnURL saveOnURL: saveOnURLbasic storeDataOn: updateAllFromResources updateFromResource)('object fileIn' convertbosfcepc0:bosfce0:)('visual properties' canHaveFillStyles canSetColor defaultColor fillStyle fillStyle: fillWithRamp:oriented: useBitmapFill useDefaultFill useGradientFill useSolidFill)('texture support' asTexture installAsWonderlandTextureOn: mapPrimitiveVertex:)('WiW support' addMorphInLayer: eToyRejectDropMorph:event: morphicLayerNumber randomBoundsFor: shouldGetStepsFrom: worldMorphsDo: worldUnderCursor)('rounding' borderWidth roundedCorners roundedCornersString toggleCornerRounding wantsRoundedCorners)('undo' commandHistory refineRedoTarget:selector:arguments:in: refineUndoTarget:selector:arguments:in: undoMove:redo:owner:bounds:predecessor:)('events-alarms' addAlarm:after: addAlarm:at: addAlarm:with:after: addAlarm:with:at: addAlarm:with:with:after: addAlarm:with:with:at: addAlarm:withArguments:after: addAlarm:withArguments:at: alarmScheduler removeAlarm: removeAlarm:at:)('events-processing' containsPoint:event: defaultEventDispatcher handleDropMorph: handleEvent: handleFocusEvent: handleKeyDown: handleKeyUp: handleKeystroke: handleListenEvent: handleMouseDown: handleMouseEnter: handleMouseLeave: handleMouseMove: handleMouseOver: handleMouseUp: handleUnknownEvent: handlerForMouseDown: mouseDownPriority processEvent: processEvent:using: rejectDropEvent: rejectsEvent: transformedFrom:)('meta-actions' blueButtonDown: blueButtonUp: handlerForBlueButtonDown:)('testing' isFlexed)!"Postscript:"HandMorph newEventRules: true.Undeclared removeUnreferencedKeys.!