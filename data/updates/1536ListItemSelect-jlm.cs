'From Squeak 2.5 of August 6, 1999 [latest update: #1534] on 11 October 1999 at 8:48:15 am'!"Change Set:		ListItemSelectByLettersDate:			5 October 1999Author:			Jason McVayThis changeset is1) better factored than the previous version;2) less intrusive;3) supports typing in several letters consecutively (and quickly) to select items more specificallyTweaked by DI to init existing lists upon fileIn."!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list selectedMorph selection getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect font lastKeystrokeTime lastKeystrokes '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableListMorph commentStamp: '<historical>' prior: 0!...When a PluggableListMorph is in focus, type in a letter (or severalletters quickly) to go to the next item that begins with that letter.Special keys (up, down, home, etc.) are also supported.!!PluggableListMorph methodsFor: 'initialization' stamp: 'di 10/11/1999 08:45'!initForKeystrokes	lastKeystrokeTime _ 0.	lastKeystrokes _ ''! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 10/11/1999 08:45'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel 	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!PluggableListMorph methodsFor: 'events' stamp: 'jlm 10/4/1999 23:11'!handlesBasicKeys	" if ya don't want the list to automatically handle non-modifier key 	(excluding shift key) input, return false"	^ true! !!PluggableListMorph methodsFor: 'model access' stamp: 'JLM 10/8/1999 03:49'!basicKeyPressed: aChar 	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	milliSeconds _ Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes _ ''].	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime _ milliSeconds.	nextSelectionList _ OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self flash"match not found"].	model okToChange ifFalse: [^ self].	nextSelection _ list findFirst: [:a | a == nextSelectionText].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'model access' stamp: 'jlm 10/4/1999 23:45'!getList	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListMorph methodsFor: 'model access' stamp: 'jlm 10/4/1999 23:41'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"	| aChar aSpecialKey |	aChar _ event keyCharacter.	aSpecialKey _ aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!PluggableListMorph methodsFor: 'model access' stamp: 'jlm 10/4/1999 23:39'!modifierKeyPressed: aChar 	| args |	keystrokeActionSelector == nil ifTrue: [^ nil].	args _ keystrokeActionSelector numArgs.	args = 1 ifTrue: [^ model perform: keystrokeActionSelector with: aChar].	args = 2 ifTrue: [^ model			perform: keystrokeActionSelector			with: aChar			with: self].	^ self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListMorph methodsFor: 'model access' stamp: 'JLM 10/8/1999 03:50'!specialKeyPressed: asciiValue 	| oldSelection nextSelection max howManyItemsShowing |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	asciiValue == 31		ifTrue: 			[" down arrow"			nextSelection _ oldSelection + 1.			nextSelection > max ifTrue: [nextSelection _ 1]].	asciiValue == 30		ifTrue: 			[" up arrow"			nextSelection _ oldSelection - 1.			nextSelection < 1 ifTrue: [nextSelection _ max]].	asciiValue == 1 ifTrue: [" home"		nextSelection _ 1].	asciiValue == 4 ifTrue: [" end"		nextSelection _ max].	howManyItemsShowing _ self numSelectionsInView.	asciiValue == 11 ifTrue: [" page up"		nextSelection _ 1 max: oldSelection - howManyItemsShowing].	asciiValue == 12 ifTrue: [" page down"		nextSelection _ oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !PluggableListMorph removeSelector: #selectionIndex!PluggableListMorph removeSelector: #listHandlesBasicKeys!"Postscript:Initialize existing lists."PluggableListMorph allSubInstancesDo: [:m | m initForKeystrokes].!