'From Squeak2.7alpha of October 23, 1999 [latest update: #1655] on 27 November 1999 at 12:29:07 am'!"Change Set:		ScamperForms-Fixes1Date:			26 November 1999Author:			Bolot Kerimbaev and Lex SpoonMinor tweaks, make Scamper form handling more like industry web browsers:- drop down list (enhancement)- select list defaults to size 1- select list of size 1 uses drop down list- separate display and value options for lists- text area defaults to size 20x2- text area to use inboard scrollbars- password field support (as regular text)- checkbox now supported- form starts from/ends with a new line"!PopUpChoiceMorph subclass: #DropDownChoiceMorph	instanceVariableNames: 'items border '	classVariableNames: 'SubMenuMarker '	poolDictionaries: ''	category: 'Morphic-Widgets'!FormInput subclass: #ToggleButtonInput	instanceVariableNames: 'button name value state checkedByDefault '	classVariableNames: ''	poolDictionaries: ''	category: 'HTML-Forms'!!DropDownChoiceMorph methodsFor: 'copying' stamp: 'bolot 11/2/1999 12:17'!veryDeepInner: deepCopier	super veryDeepInner: deepCopier.	items _ items veryDeepCopyWith: deepCopier.	border _ border veryDeepCopyWith: deepCopier! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'bolot 11/2/1999 12:23'!drawOn: aCanvas	aCanvas text: contents bounds: (bounds insetBy: 2)  font: self fontToUse color: color.	border ifNotNil: [aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: 1		borderColor: Color black].	aCanvas			image: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'bolot 11/2/1999 12:24'!maxExtent: listOfStrings	| scanner h w maxW |	maxW _ 0.	listOfStrings do: [:str |		scanner _ QuickPrint newOn: Display box: Display boundingBox font: self fontToUse.		w _ (scanner stringWidth: str).		h _ scanner lineHeight.		maxW _ maxW max: w].	self extent: (maxW + 4 + h) @ (h + 4).	self changed! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!border	^border! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!border: newBorder	border _ newBorder! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!items	(target notNil and: [getItemsSelector notNil])		ifTrue: [items _ target perform: getItemsSelector withArguments: getItemsArgs].	items ifNil: [items _ #()].	^items! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!items: someItems	items _ someItems! !!DropDownChoiceMorph methodsFor: 'list access' stamp: 'bolot 11/2/1999 12:21'!getCurrentSelectionIndex	^self items indexOf: contents! !!DropDownChoiceMorph methodsFor: 'list access' stamp: 'bolot 11/2/1999 12:21'!selection: val	self contentsClipped: val! !!DropDownChoiceMorph methodsFor: 'event handling' stamp: 'bolot 11/2/1999 12:22'!mouseDown: evt	| menu selectedItem |	self items isEmpty ifTrue: [^ self].	menu _ CustomMenu new.	self items do: [:item | menu add: item action: item].	selectedItem _ menu startUp.	selectedItem ifNil: [^ self].	self contentsClipped: selectedItem.  "Client can override this if necess"	actionSelector ifNotNil: [		target			perform: actionSelector			withArguments: (arguments copyWith: selectedItem)].! !!DropDownChoiceMorph class methodsFor: 'class initialization' stamp: 'bolot 11/2/1999 12:19'!initialize	"DropDownChoiceMorph initialize"	| f |	f _ Form		extent: 5@9		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)		offset: 0@0.	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.! !!FormInput methodsFor: 'input handling' stamp: 'bolot 11/3/1999 20:39'!active	"whether this input is currently providing an input"	^self name isNil not! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/11/1998 20:11'!submit	"collect inputs and instruct the browser to do a submission"	| inputValues |	inputValues _ Dictionary new.	inputs do: [ :input |		input active ifTrue: [			(inputValues includesKey: input name) ifFalse: [				inputValues at: input name  put: (OrderedCollection new: 1) ].			(inputValues at: input name)  add: input value ] ].	browser submitFormWithInputs: inputValues  url: form url method: form method.	^true! !!HtmlForm methodsFor: 'attributes' stamp: 'bolot 11/2/1999 19:01'!encoding	"encoding for posting"	^self getAttribute: 'encoding' default: nil.  ! !!HtmlFormatter methodsFor: 'forms' stamp: 'bolot 8/29/1999 18:40'!endForm	formDatas size > 0 ifTrue: [ 		formDatas removeLast. ]	ifFalse: [ self halt: 'HtmlFormatter: ended more forms that started!!?' ].	self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'forms' stamp: 'bolot 8/29/1999 18:40'!startForm: form	"a form is beginning"	self ensureNewlines: 1.	formDatas addLast: (FormInputSet forForm: form  andBrowser: browser).! !!HtmlInput methodsFor: 'attributes' stamp: 'bolot 11/2/1999 14:14'!imageExtent	"the image extent, according to the WIDTH and HEIGHT attributes.  returns nil if either WIDTH or HEIGHT is not specified"	| widthText heightText |	widthText _ self getAttribute: 'width' ifAbsent: [ ^nil ].	heightText _ self getAttribute: 'height' ifAbsent: [ ^nil ].	^ widthText asNumber @ heightText asNumber! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/3/1999 20:31'!addCheckBoxButtonToFormatter: formatter	| name formData checked button buttonInput |	"dig up relevant attributes"	name _ self getAttribute: 'name'.	name ifNil: [ ^self ].	value _ self getAttribute: 'value'.	value ifNil: [ ^value ].		formData _ formatter currentFormData.	formData ifNil:  [ ^self ].	checked _ (self getAttribute: 'checked') isNil not.	"find or create the set of buttons with our same name"	"set up the form input"	buttonInput _ ToggleButtonInput name: name value: value checkedByDefault: checked.	formData addInput: buttonInput.	"create the actual button"	button _ PluggableButtonMorph on: buttonInput getState: #pressed  action: #toggle.	button label: 'X'.	buttonInput button: button.	formatter addMorph: button.! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/27/1999 00:10'!addImageButtonToFormatter: formatter	"is it a submit button?"	| formData |		"fake it"	value _ self getAttribute: 'value' default: 'Submit'.	formData _ formatter currentFormData.	formatter addMorph: ((PluggableButtonMorph on: formData getState: nil action: #submit) label: value).	formData addInput: (HiddenInput name: (value,'.x') value: '0').	formData addInput: (HiddenInput name: (value,'.y') value: '0').! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/27/1999 00:21'!addTextInputToFormatter: formatter	"is it a submit button?"	| inputMorph size |	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	size _ (self getAttribute: 'size' default: '12') asNumber.	inputMorph extent: (size*10@20).	formatter addMorph: inputMorph.	formatter currentFormData addInput:		(TextInput name: self name defaultValue: self defaultValue  textMorph: inputMorph).! !!HtmlInput methodsFor: 'formatting' stamp: 'bolot 11/3/1999 20:31'!addToFormatter: formatter	"is it a submit button?"	self type = 'submit' ifTrue: [		formatter addMorph: ((PluggableButtonMorph on: formatter currentFormData getState: nil action: #submit) label: (self getAttribute: 'value' default: 'Submit')).		^self ].	self type = 'image'		ifTrue: [^self addImageButtonToFormatter: formatter].	(self type = 'text' or: [self type = 'password'])		ifTrue: [^self addTextInputToFormatter: formatter].	self type = 'hidden' ifTrue: [		formatter currentFormData addInput: (HiddenInput name: self name  value: self defaultValue).		^self ].	self type = 'radio' ifTrue: [ 		^self addRadioButtonToFormatter: formatter ].	self type = 'checkbox' ifTrue: [ 		^self addCheckBoxButtonToFormatter: formatter ].	formatter addString: '[form input of type: ', self type, ']'.! !!HtmlSelect methodsFor: 'formatting' stamp: 'bolot 11/3/1999 17:35'!addToFormatter: formatter	| options defaultOption listMorph names size valueHolder |	names _ OrderedCollection new.	options _ OrderedCollection new.	defaultOption _ nil.	(self getAttribute: 'multiple') ifNotNil: [		self flag: #incomplete.		formatter addString: '[M option list]'.		^self ].	contents do: [ :c |  c isOption ifTrue: [		names add: c value.		options add: c label withBlanksCondensed.		(c getAttribute: 'selected') ifNotNil: [ defaultOption _ c label ] ] ].	contents isEmpty ifTrue: [ ^self ].	defaultOption ifNil: [ defaultOption _ options first ].	size _ (self getAttribute: 'size' default: '1') asNumber.	size = 1		ifTrue: [listMorph _ DropDownChoiceMorph new initialize; contents: defaultOption.			listMorph items: options; target: nil; getItemsSelector: nil;				maxExtent: options; border: #useBorder]		ifFalse: [valueHolder _ ValueHolder new contents: (contents indexOf: defaultOption).			listMorph _ PluggableListMorph on: valueHolder list: nil				selected: #contents  changeSelected: #contents:.			listMorph list: options.			listMorph extent: ((listMorph extent x) @ (listMorph scrollDeltaHeight * size))].	formatter addMorph: listMorph.	formatter currentFormData addInput:		(SelectionInput  name: self name  defaultValue: defaultOption			list: listMorph  values: names asArray)! !!HtmlTextArea methodsFor: 'attributes' stamp: 'bolot 11/2/1999 13:51'!columns	| a |	a _ self getAttribute: 'cols' default: '20'.	^(Integer readFrom: (ReadStream on: a)) max: 5.! !!HtmlTextArea methodsFor: 'attributes' stamp: 'bolot 11/2/1999 13:51'!rows	| a |	a _ self getAttribute: 'rows' default: '2'.	^(Integer readFrom: (ReadStream on: a)) max: 1.! !!HtmlTextArea methodsFor: 'formatting' stamp: 'bolot 11/2/1999 13:48'!addToFormatter: formatter	| inputMorph |	formatter ensureNewlines: 1.	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	inputMorph extent: (self columns * 5) @ (self rows * inputMorph scrollDeltaHeight).	inputMorph retractable: false.	formatter addMorph: inputMorph.	formatter currentFormData addInput: (TextInput name: self name  defaultValue:  self textualContents  textMorph: inputMorph).	formatter ensureNewlines: 1.! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'bolot 11/3/1999 20:40'!active	"we are active if and only if one of our buttons is pressed"	self name isNil		ifTrue: [^false].	buttons do: [ :b |		b pressed ifTrue: [ ^true ] ].	^false! !!SelectionInput methodsFor: 'handling input' stamp: 'bolot 11/3/1999 20:40'!active	^self name isNil not and: [listMorph getCurrentSelectionIndex > 0]! !!String methodsFor: 'converting' stamp: 'bolot 11/3/1999 17:35'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	| trimmed lastBlank |	trimmed _ self withBlanksTrimmed.	^String streamContents: [:stream |		lastBlank _ false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank _ c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!ToggleButtonInput methodsFor: 'accessing' stamp: 'bolot 11/3/1999 20:33'!name	^name! !!ToggleButtonInput methodsFor: 'accessing' stamp: 'bolot 11/3/1999 20:33'!value	^value! !!ToggleButtonInput methodsFor: 'private-initialize' stamp: 'bolot 11/3/1999 20:30'!button: aButtonMorph	button _ aButtonMorph! !!ToggleButtonInput methodsFor: 'private-initialize' stamp: 'bolot 11/3/1999 20:30'!name: aName value: aValue checkedByDefault: aFlag	name _ aName.	value _ aValue.	checkedByDefault _ aFlag.	state _ checkedByDefault! !!ToggleButtonInput methodsFor: 'input handling' stamp: 'bolot 11/3/1999 20:40'!active	^self name isNil not and: [state]! !!ToggleButtonInput methodsFor: 'button state' stamp: 'bolot 11/3/1999 20:25'!pressed	^state! !!ToggleButtonInput methodsFor: 'button state' stamp: 'bolot 11/3/1999 20:25'!pressed: aBoolean	state _ aBoolean.	self changed: #pressed.	^true! !!ToggleButtonInput methodsFor: 'button state' stamp: 'bolot 11/3/1999 20:25'!toggle	"my button has been clicked on!!"	self pressed: self pressed not.	^true! !!ToggleButtonInput class methodsFor: 'instance creation' stamp: 'bolot 11/3/1999 20:30'!name: aName value: aValue checkedByDefault: aFlag	^ self new name: aName value: aValue checkedByDefault: aFlag! !DropDownChoiceMorph initialize!