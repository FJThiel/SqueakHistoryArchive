'From Squeak 2.4b of April 23, 1999 on 29 April 1999 at 2:14:17 pm'!"Change Set:		Wnld-Lights-jspDate:			29 April 1999Author:			Jeff PierceA first pass at interactive lights."!WonderlandActor subclass: #WonderlandLightSource	instanceVariableNames: 'lightColor '	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Wonderland-Lights'!WonderlandLightSource subclass: #WonderlandAmbientLight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Lights'!WonderlandLightSource subclass: #WonderlandDirectionalLight	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Lights'!WonderlandLightSource subclass: #WonderlandPositionalLight	instanceVariableNames: 'attenuation '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Lights'!WonderlandPositionalLight subclass: #WonderlandSpotLight	instanceVariableNames: 'target minCos maxCos deltaCos direction '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Lights'!!WonderlandLightSource reorganize!('initialization' initializeFor:)('shading' computeAttenuationFor: computeDirectionTo: computeSpotFactor: shadeVertexBuffer:with:into:)('accessing' direction hotSpotDeltaCosine hotSpotMaxCosine hotSpotMinCosine lightColor lightColor: spotExponent)('testing' hasAmbientPart hasDiffusePart hasSpecularPart hasSpot isAttenuated)('converting' asPrimitiveLight transformedBy:)('private' setColorVector:)!!WonderlandLightSource methodsFor: 'initialization' stamp: 'jsp 4/29/1999 11:43'!initializeFor: aWonderland	"Initialize the light"	super initializeFor: aWonderland.	"Set the light's mesh and texture"	self setMesh: (WonderlandConstants at: 'lightMesh').	self setTexturePointer: (WonderlandConstants at: 'lightTexture').	lightColor _ B3DMaterialColor new.	self setColorVector: (B3DColor4 r: 1.0 g: 1.0 b: 1.0 a: 1.0).! !!WonderlandLightSource methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:04'!computeAttenuationFor: distance	^self subclassResponsibility! !!WonderlandLightSource methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:04'!computeDirectionTo: aB3DPrimitiveVertex	^self subclassResponsibility! !!WonderlandLightSource methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:04'!computeSpotFactor: light2Vertex	"Compute the spot factor for a spot light"	| lightDirection cosAngle minCos deltaCos maxCos |	lightDirection _ self direction.	cosAngle _ (lightDirection dot: light2Vertex) negated.	(cosAngle < (minCos _ self hotSpotMinCosine)) ifTrue:[^0.0].	maxCos _ self hotSpotMaxCosine."	maxCos = 1.0 ifFalse:["		deltaCos _ self hotSpotDeltaCosine.		deltaCos <= 0.00001 ifTrue:[			"No delta -- a sharp boundary between on and off.			Since off has already been determined above, we are on"			^1.0].		"Scale the angle to 0/1 range"		cosAngle _ (cosAngle - minCos) / deltaCos.		self flag: #TODO. "Don't scale by (maxCos - minCos)""	]."	self flag: #TODO. "Use table lookup for spot exponent"	^cosAngle raisedTo: self spotExponent! !!WonderlandLightSource methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:04'!shadeVertexBuffer: vb with: aMaterial into: colorArray	"This is the generic shading function similar to the primitive.	Subclasses may implement optimized versions but should evaluate	exactly to the same value as in here if they are to be converted into	B3DPrimitiveLights."	| color vtxArray ambientColor vtx direction distance scale cosAngle diffusePart specularPart specDir specularFactor |	self flag: #b3dPrimitive.	vtxArray _ vb vertexArray.	(self hasAmbientPart and:[vb trackAmbientColor not])		ifTrue:[ambientColor _ aMaterial ambientPart * lightColor ambientPart].	(self hasDiffusePart and:[vb trackDiffuseColor not])		ifTrue:[diffusePart _ aMaterial diffusePart].	(self hasSpecularPart and:[vb trackSpecularColor not])		ifTrue:[specularPart _ aMaterial specularPart].	1 to: vb vertexCount do:[:i|		vtx _ vtxArray at: i.		color _ colorArray at: i.		"Compute the direction and distance of light source from vertex"		direction _ self computeDirectionTo: vtx.		distance _ direction length.		(distance = 0.0 or:[distance = 1.0]) ifFalse:[direction /= distance negated].		"Compute the attenuation for the given distance"		self isAttenuated			ifTrue:[scale _ self computeAttenuationFor: distance]			ifFalse:[scale _ 1.0].		"Compute spot light factor"		self hasSpot			ifTrue:[scale _ scale * (self computeSpotFactor: direction)].		"Compute ambient part"		self hasAmbientPart ifTrue:[			vb trackAmbientColor 				ifTrue:[ambientColor _ vtx b3dColor * lightColor ambientPart].			color += (ambientColor * scale).		].		"Compute the diffuse part of the light"		self hasDiffusePart ifTrue:[			"Compute angle from light->vertex to vertex normal"			cosAngle _ vtx normal dot: direction.			"For one-sided lighting negate cosAngle if necessary"			(vb twoSidedLighting not and:[cosAngle < 0.0]) 				ifTrue:[cosAngle _ 0.0 - cosAngle].			"For two-sided lighting check if cosAngle > 0.0 meaning that it is a front face"			cosAngle > 0.0 ifTrue:[				vb trackDiffuseColor ifTrue:[diffusePart _ vtx b3dColor].				color += (diffusePart * lightColor diffusePart * (cosAngle * scale)).			].		].		"Compute specular part of the light"		(self hasSpecularPart and:[aMaterial shininess > 0.0]) ifTrue:[			vb useLocalViewer 				ifTrue:[specDir _ direction - vtx position safelyNormalized]				ifFalse:[specDir _ direction - (0@0@1.0)].			cosAngle _ vtx normal dot: specDir.			cosAngle > 0.0 ifTrue:[				"Normalize the angle"				cosAngle _ cosAngle / specDir length.				"cosAngle should be somewhere between 0 and 1.				If not, then the vertex normal was not normalized"				cosAngle > 1.0 ifTrue:[					specularFactor _ cosAngle raisedTo: aMaterial shininess.				] ifFalse:[					self flag: #TODO. "Use table lookup later"					specularFactor _ cosAngle raisedTo: self shininess.				].				color += (specularPart * lightColor specularPart * specularFactor).			].		].		self flag: #TODO. "Check specular part"		colorArray at: i put: color.	].! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:01'!direction	"If the light is directional, return the NORMALIZED direction of the light"	^B3DVector3 zero! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:02'!hotSpotDeltaCosine	"Return the cosine value of the delta radius of a spot light (the fall off region)"	^self hotSpotMaxCosine - self hotSpotMinCosine! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:02'!hotSpotMaxCosine	"Return the cosine value of the outer radius of a spot light (the unlit region)"	^0.0! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:02'!hotSpotMinCosine	"Return the cosine value of the inner radius of a spot light (the fully lit region)"	^0.0! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:02'!lightColor	^lightColor! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:03'!lightColor: aMaterialColor	lightColor _ aMaterialColor! !!WonderlandLightSource methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:03'!spotExponent	"Return the exponent to be used for the spot fall off computation"	^1! !!WonderlandLightSource methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:00'!hasAmbientPart	"Return true if the receiver contains an ambient part in its color"	^true! !!WonderlandLightSource methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:00'!hasDiffusePart	"Return true if the receiver contains a diffuse part in its color"	^true! !!WonderlandLightSource methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:00'!hasSpecularPart	"Return true if the receiver contains a specular part in its color"	^true! !!WonderlandLightSource methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:01'!hasSpot	"Return true if the receiver has a hot spot."	^false! !!WonderlandLightSource methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:01'!isAttenuated	"Return true if the receiver contains an attenuation.	If so, #computeAttenuationFor: must return the attenuation for the given distance."	^true! !!WonderlandLightSource methodsFor: 'converting' stamp: 'jsp 4/23/1999 12:10'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight that can be handled by the shader primitive directly. Light sources that cannot be represented as primitive should return nil. This will result in the callback of #shadeVertexBuffer from the shader."	^nil! !!WonderlandLightSource methodsFor: 'converting' stamp: 'jsp 4/23/1999 12:10'!transformedBy: aTransformer	^self clone! !!WonderlandLightSource methodsFor: 'private' stamp: 'jsp 4/23/1999 15:02'!setColorVector: aColor	"Instaneously sets the object's color/alpha vector and copies it down the object tree for all objects that are parts of this object"	"Set our color"	myColor _ aColor.	lightColor ambientPart: myColor.	lightColor diffusePart: myColor.	lightColor specularPart: myColor.	myMaterial ambientPart: myColor.	myMaterial diffusePart: myColor.	myMaterial specularPart: myColor.	"Set the color of our parts"	myChildren do: [:child | (child isPart) ifTrue: [child setColorVector: aColor] ].! !!WonderlandAmbientLight methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:47'!computeAttenuationFor: distance	^1.0! !!WonderlandAmbientLight methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:48'!computeDirectionTo: aB3DPrimitiveVertex	^B3DVector3 zero! !!WonderlandAmbientLight methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:48'!shadeVertexBuffer: vb with: aMaterial into: colorArray	"Overridden for simplicity and speed"	| color |	false ifTrue:[^super shadeVertexBuffer: vb with: aMaterial into: colorArray].	self flag: #b3dPrimitive.	vb trackAmbientColor ifTrue:[		1 to: vb vertexCount do:[:i|			color _ (vb primitiveB3dColorAt: i) * lightColor ambientPart.			colorArray add: color at: i.		].	] ifFalse:[		color _ aMaterial ambientPart * lightColor ambientPart.		colorArray += color.	].! !!WonderlandAmbientLight methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:45'!hasDiffusePart	^false! !!WonderlandAmbientLight methodsFor: 'testing' stamp: 'jsp 4/23/1999 14:46'!hasSpecularPart	^false! !!WonderlandAmbientLight methodsFor: 'converting' stamp: 'jsp 4/23/1999 14:47'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight |	primLight _ B3DPrimitiveLight new.	primLight ambientPart: lightColor ambientPart.	primLight flags: FlagAmbientPart.	^primLight! !!WonderlandAmbientLight methodsFor: 'converting' stamp: 'jsp 4/23/1999 14:47'!transformedBy: aTransformer	^self! !!WonderlandDirectionalLight methodsFor: 'shading' stamp: 'jsp 4/29/1999 13:45'!computeAttenuationFor: distance	"Since a directional light is positioned at virtual infinity, it cannot have any attenuation"	^1.0! !!WonderlandDirectionalLight methodsFor: 'shading' stamp: 'jsp 4/29/1999 13:48'!computeDirectionTo: aB3DPrimitiveVertex	"A directional light has an explicit direction regardless of the vertex position"	^ (self getRotationVector).! !!WonderlandDirectionalLight methodsFor: 'converting' stamp: 'jsp 4/29/1999 13:48'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight flags |	primLight _ B3DPrimitiveLight new.	primLight direction: (self getRotationVector).	flags _ FlagDirectional.	lightColor ambientPart isZero ifFalse:[		primLight ambientPart: lightColor ambientPart.		flags _ flags bitOr: FlagAmbientPart].	lightColor diffusePart isZero ifFalse:[		primLight diffusePart: lightColor diffusePart.		flags _ flags bitOr: FlagDiffusePart].	lightColor specularPart isZero ifFalse:[		primLight specularPart: lightColor specularPart.		flags _ flags bitOr: FlagSpecularPart].	primLight flags: flags.	^primLight! !!WonderlandDirectionalLight methodsFor: 'converting' stamp: 'jsp 4/29/1999 13:49'!transformedBy: aTransformer	^(super transformedBy: aTransformer)				setRotationVector: (aTransformer transformDirection: direction)! !!WonderlandLightSource class methodsFor: 'change logging' stamp: 'jsp 4/23/1999 11:50'!acceptsLoggingOfCompilation	^ true.! !!WonderlandLightSource class methodsFor: 'change logging' stamp: 'jsp 4/23/1999 11:49'!wantsChangeSetLogging	^ true.! !!WonderlandLightSource class methodsFor: 'class initialization' stamp: 'jsp 4/29/1999 10:51'!initialize	"Add the light names to WonderlandConstants"	WonderlandConstants at: 'ambient' put: 'ambientLight'.	WonderlandConstants at: 'positional' put: 'positionalLight'.	WonderlandConstants at: 'directional' put: 'directionalLight'.	WonderlandConstants at: 'spotlight' put: 'spotLight'.! !!WonderlandPositionalLight reorganize!('initialization' initialize initializeFor:)('accessing' attenuation attenuation: position)('shading' computeAttenuationFor: computeDirectionTo:)('converting' asPrimitiveLight transformedBy:)!!WonderlandPositionalLight methodsFor: 'initialization' stamp: 'jsp 4/23/1999 14:30'!initialize	"Initialize this light"	attenuation _ B3DLightAttenuation constant: 1.0 linear: 0.0 squared: 0.0.! !!WonderlandPositionalLight methodsFor: 'initialization' stamp: 'jsp 4/29/1999 11:10'!initializeFor: aWonderland	"Initialize this light"	super initializeFor: aWonderland.	attenuation _ B3DLightAttenuation constant: 1.0 linear: 0.0 squared: 0.0.! !!WonderlandPositionalLight methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:27'!attenuation	^attenuation! !!WonderlandPositionalLight methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:28'!attenuation: aLightAttenuation	attenuation _ aLightAttenuation! !!WonderlandPositionalLight methodsFor: 'accessing' stamp: 'jsp 4/23/1999 14:28'!position	^ self getPositionVector.! !!WonderlandPositionalLight methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:29'!computeAttenuationFor: distance	"Compute the attenuation for the given distance"	^attenuation computeAttenuationFor: distance! !!WonderlandPositionalLight methodsFor: 'shading' stamp: 'jsp 4/23/1999 14:31'!computeDirectionTo: aB3DPrimitiveVertex	"Compute the lights direction to the given vertex"	^ aB3DPrimitiveVertex B3DPrimitiveVertex position - (self getPositionVector).! !!WonderlandPositionalLight methodsFor: 'converting' stamp: 'jsp 4/23/1999 14:26'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight flags |	primLight _ B3DPrimitiveLight new.	primLight position: (self getPositionVector).	flags _ FlagPositional.	self attenuation isIdentity not ifTrue:[		primLight attenuation: self attenuation.		flags _ flags bitOr: FlagAttenuated].	lightColor ambientPart isZero ifFalse:[		primLight ambientPart: lightColor ambientPart.		flags _ flags bitOr: FlagAmbientPart].	lightColor diffusePart isZero ifFalse:[		primLight diffusePart: lightColor diffusePart.		flags _ flags bitOr: FlagDiffusePart].	lightColor specularPart isZero ifFalse:[		primLight specularPart: lightColor specularPart.		flags _ flags bitOr: FlagSpecularPart].	primLight flags: flags.	^primLight! !!WonderlandPositionalLight methodsFor: 'converting' stamp: 'jsp 4/29/1999 11:24'!transformedBy: aTransformer	^(super transformedBy: aTransformer)			setPositionVector: (aTransformer transformPosition: (self getPositionVector)).! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:53'!direction	^direction ifNil:[direction _ (target - (self getPositionVector)) safelyNormalize].! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:54'!direction: aVector	direction _ aVector! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:54'!hotSpotDeltaCosine	^deltaCos! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:54'!hotSpotMaxCosine	^maxCos! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:54'!hotSpotMinCosine	^minCos! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:54'!maxAngle	^maxCos arcCos radiansToDegrees! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:54'!maxAngle: angle	minCos _ angle degreesToRadians cos.	maxCos ifNotNil:[deltaCos _ maxCos - minCos].! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:55'!minAngle	^minCos arcCos radiansToDegrees! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:55'!minAngle: angle	maxCos _ angle degreesToRadians cos.	minCos ifNotNil:[deltaCos _ maxCos - minCos].! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:55'!target	^target! !!WonderlandSpotLight methodsFor: 'accessing' stamp: 'jsp 4/29/1999 13:55'!target: aVector	target _ aVector! !!WonderlandSpotLight methodsFor: 'testing' stamp: 'jsp 4/29/1999 13:51'!hasSpot	^ true.! !!WonderlandSpotLight methodsFor: 'converting' stamp: 'jsp 4/29/1999 13:52'!asPrimitiveLight	"Convert the receiver into a B3DPrimitiveLight"	| primLight |	primLight _ super asPrimitiveLight.	primLight flags: (primLight flags bitOr: FlagHasSpot).	primLight spotMinCos: minCos.	primLight spotMaxCos: maxCos.	primLight spotDeltaCos: deltaCos.	primLight spotExponent: self spotExponent.	primLight direction: (target - (self getPositionVector)) safelyNormalize.	^primLight! !!WonderlandSpotLight methodsFor: 'converting' stamp: 'jsp 4/29/1999 13:53'!transformedBy: aTransformer	^(super transformedBy: aTransformer) 		target: (aTransformer transformPosition: target);		direction: nil! !WonderlandLightSource removeSelector: #initialize!WonderlandLightSource removeSelector: #setColor:!WonderlandLightSource initialize!WonderlandLightSource class removeSelector: #color:!