'From Squeak 2.3 beta of Nov 25, 1998 on 5 January 1999 at 2:37:23 pm'!!Object methodsFor: 'copying' stamp: 'tk 1/5/1999 14:28'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	| copier new |	copier _ DeepCopier new initialize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	copier resolveWeakRefs.	^ new! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 1/5/1999 13:11'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, you MUST go the the method being checked (veryDeepCopyWith:) and update its code.  And then update the test here.  	DeepCopier new checkVariables	""All classes that implements veryDeepCopyWith: or veryDeepInner: for the purpose of not doing a veryDeepCopy on some inst var, must have a check here."	| str str2 list cls |	str _ '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self halt: 'Morph', str].	"added ones are OK"	list _ (cls _ SimpleButtonMorph) allInstVarNames.	(list at: 9) = 'target' ifFalse: [self error: cls name, str].	(list at: 11) = 'arguments' ifFalse: [self error: cls name, str].	list _ (cls _ SimpleSliderMorph) allInstVarNames.	(list at: 15) = 'target' ifFalse: [self error: cls name, str].	(list at: 16) = 'arguments' ifFalse: [self error: cls name, str].	list _ (cls _ BookPageThumbnailMorph) allInstVarNames.	(list at: 15) = 'page' ifFalse: [self error: cls name, str].	(list at: 17) = 'bookMorph' ifFalse: [self error: cls name, str].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' 'subclasses' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 1/5/1999 14:36'!resolveWeakRefs	"Some fields are weakly copied.  We might want to just refer to an outside object, rather than make a duplicate of it.   See veryDeepCopyWith: in the classes mentioned below."references associationsDo: [:assoc |	assoc value isMorph ifTrue: [assoc value veryDeepFixupWith: self]]! !!Morph methodsFor: 'copying' stamp: 'tk 1/4/1999 20:46'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Do not copy the owner field.  That must be filled in by the owner, if he is within the tree being copied."	| subAss new uc |	deepCopier references at: self ifPresent: [:newer | ^ newer]. 	"already did him"	new _ self clone.	self class isSystemDefined ifFalse: ["May occur in the future"		uc _ deepCopier uniClasses at: self class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: self class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	"Morph subclasses do not have variable numbers of fields (like Array does)"	new privateBounds: bounds clone.	"Points are shared with original"		"indexes used here are checked by checkVariables"	(subAss _ deepCopier references associationAt: owner ifAbsent: [nil])		ifNil: [new privateOwner: nil]	"weak reference to owner"		ifNotNil: [new privateOwner: subAss value].	new privateSubmorphs: (submorphs veryDeepCopyWith: deepCopier).	new privateFullBounds: fullBounds.	"fullBounds is shared with original!!"	new privateColor: (color veryDeepCopyWith: deepCopier).		"color, if simple, will return self. may be complex"	new instVarAt: 6 put: (extension veryDeepCopyWith: deepCopier).		"extension is treated like any generic inst var"	new veryDeepInner: deepCopier. 	"other inst vars"	new submorphsDo: [:morph | morph privateOwner: new].  "strengthen weak pointers"	^ new! !!Morph methodsFor: 'copying' stamp: 'tk 1/4/1999 16:56'!veryDeepFixupWith: aDeepCopier	"If some fields were weakly copied, fix them here.  Morph has none."! !!Morph methodsFor: 'copying' stamp: 'tk 1/4/1999 20:45'!veryDeepInner: deepCopier	"The inner loop, so it can be overridden when a field should not be traced."	| index sub |	index _ self class instSize.	[index > 6] whileTrue: 		[sub _ self instVarAt: index.		self instVarAt: index put: (sub veryDeepCopyWith: deepCopier).		index _ index - 1].! !!BalloonMorph commentStamp: 'tk 1/4/1999 22:13' prior: 0!A balloon with text used for the display of explanatory information.Balloon help is integrated into Morphic as follows:If a Morph has the property #balloonText, then it will respond to #showBalloon by adding a text balloon to the world, and to #deleteBalloon by removing the balloon.Moreover, if mouseOverEnabled is true (see class msg), then the Hand will arrange to cause display of the balloon after the mouse has lingered over the morph for a while, and removal of the balloon when the mouse leaves the bounds of that morph.  In any case, the Hand will attempt to remove any such balloons before handling mouseDown events, or displaying other balloons.Balloons should not be duplicated with veryDeepCopy unless their target is also duplicated at the same time.!!BookMorph commentStamp: 'tk 1/4/1999 17:02' prior: 0!Allows one or another "page" to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.To write a book out to the disk or to a file server, decide what folder it goes in.  Construct a url to a typical page:	file://myDisk/folder/myBook1.sp	ftp://aServer/folder/myBook1.spChoose "send all pages to server" from the book's menu (press the <> part of the controls).  Choose "use page numbers".  Paste in the url.To load an existing book, find its ".bo" file in the file list browser.  Choose "load as book".Multiple people may modify a book.  If other people may have changed a book you have on your screen, choose "reload all from server".Add or modify a page, and choose "send this page to server".The polite thing to do is to reload before changing a book.  Then write one or all pages soon after making your changes.  If you store a stale book, it will wipe out changes that other people made in the mean time.Text search:  Search for a set of fragments.  allStrings collects text of fields.  Turn to page with all fragments on it and highlight the first one.  Save the container and offset in properties: #searchContainer, #searchOffset, #searchKey.  Search again from there.  Clear those at each page turn, or change of search key.  !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/5/1999 13:08'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!"page _ deepCopier references at: page ifAbsent: [page].bookMorph _ deepCopier references at: bookMorph ifAbsent: [bookMorph].! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/5/1999 13:36'!veryDeepInner: deepCopier	"The inner loop is overridden.  target, arguments should not be traced unless we own them."| index sub |index _ self class instSize.[index > 6] whileTrue: 	[(index ~= 15 "page") & (index ~= 17 "bookMorph") ifTrue: [		sub _ self instVarAt: index.		self instVarAt: index put: (sub veryDeepCopyWith: deepCopier)].	index _ index - 1].! !!HandMorph methodsFor: 'copying' stamp: 'tk 1/4/1999 21:00'!veryDeepCopyWith: deepCopier	"Return self.  Do not copy hands this way."	^ self! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'tk 1/5/1999 14:35'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!"target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'tk 1/5/1999 13:37'!veryDeepInner: deepCopier	"The inner loop is overridden.  target, arguments should not be traced unless we own them."| index sub |index _ self class instSize.[index > 6] whileTrue: 	[(index ~= 9 "target") & (index ~= 11 "arguments") ifTrue: [		sub _ self instVarAt: index.		self instVarAt: index put: (sub veryDeepCopyWith: deepCopier)].	index _ index - 1].! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'tk 1/4/1999 21:04'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!"target _ deepCopier references at: target ifAbsent: [target].arguments _ arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'tk 1/5/1999 13:37'!veryDeepInner: deepCopier	"The inner loop is overridden.  target, arguments should not be traced unless we own them."| index sub |index _ self class instSize.[index > 6] whileTrue: 	[(index ~= 15 "target") & (index ~= 16 "arguments") ifTrue: [		sub _ self instVarAt: index.		self instVarAt: index put: (sub veryDeepCopyWith: deepCopier)].	index _ index - 1].! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'tk 1/4/1999 16:33'!veryDeepCopyWith: deepCopier	"Does a WorldMorph really need to be veryDeepCopied?  If so, only copy submorphs, model, and stepList.  Lots of special stuff.  See storeDataOn:"	^ self error: 'Worlds should not be copied'! !