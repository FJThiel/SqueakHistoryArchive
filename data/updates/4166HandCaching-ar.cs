'From Squeak3.1alpha of 28 February 2001 [latest update: #4164] on 23 June 2001 at 4:07:34 pm'!"Change Set:		HandCaching-arDate:			23 June 2001Author:			Andreas RaabThis change set changes the strategy for figuring out if morphs which are held in the hand can be cached or not. Rather than asking each and every morph about whether it has some translucent color the new strategy takes into account that most translucent morphs will be backed by some opaque morph. An example is the current use of the optional button pane which is constructed using a transparent holder embedded in an opaque system window. Before these changes any window containing such a construction was not cached - now it is."!!Morph methodsFor: 'accessing' stamp: 'ar 6/23/2001 16:06'!wantsToBeCachedByHand	"Return true if the receiver wants to be cached by the hand when it is dragged around.	Note: The default implementation queries all submorphs since subclasses may have shapes that do not fill the receiver's bounds completely."	self hasTranslucentColor ifTrue:[^false].	self submorphsDo:[:m|		m wantsToBeCachedByHand ifFalse:[^false].	].	^true! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/23/2001 15:57'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| subBnds rectList nPix |	"Note: The following is an attempt to quickly get out if there's no change"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	(rectList isEmpty and:[cacheCanvas notNil and:[cacheCanvas extent = subBnds extent]])		ifTrue:[^self].	"Always check for real translucency -- can't be cached in a form"	self submorphsDo:[:m|		m wantsToBeCachedByHand ifFalse:[			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: subBnds extent) getCanvas.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		nPix _ cacheCanvas form tallyPixelValues at: 1.		"--> begin rounded corners hack <---"		(nPix = 48 and:[submorphs size = 1 and:[submorphs first wantsRoundedCorners]])			ifTrue:[cachedCanvasHasHoles _ false]			ifFalse:[cachedCanvasHasHoles _ nPix > 0].		"--> end rounded corners hack <---"		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !!RectangleMorph methodsFor: 'testing' stamp: 'ar 6/23/2001 16:06'!wantsToBeCachedByHand	"Return true if the receiver wants to be cached by the hand when it is dragged around."	self hasTranslucentColor ifTrue:[^false].	self bounds = self fullBounds ifTrue:[^true].	self submorphsDo:[:m|		(self bounds containsRect: m fullBounds) ifFalse:[			m wantsToBeCachedByHand ifFalse:[^false].		].	].	^true! !!SystemWindow methodsFor: 'testing' stamp: 'ar 6/23/2001 16:06'!wantsToBeCachedByHand	"Return true if the receiver wants to be cached by the hand when it is dragged around."	self hasTranslucentColor ifTrue:[^false].	self bounds = self fullBounds ifTrue:[^true].	self submorphsDo:[:m|		(self bounds containsRect: m fullBounds) ifFalse:[			m wantsToBeCachedByHand ifFalse:[^false].		].	].	^true! !