'From Squeak2.9alpha of 13 June 2000 [latest update: #2799] on 28 October 2000 at 9:57:11 am'!ImageMorph subclass: #MovieFrameSyncMorph	instanceVariableNames: 'moviePlayerMorph frameNumber '	classVariableNames: 'ColorIndex '	poolDictionaries: ''	category: 'Morphic-Demo'!!MovieFrameSyncMorph commentStamp: '<historical>' prior: 0!This class and its subclasses act to syncronize movie players with the progress of a MIDI score and further background can be found in the comment for MoviePlayerMorph.There are two main forms of synchroniztion.MovieFrameSyncMorphs are used where you have a MIDI score open with a piano roll, and a separate MoviePlayer Morph.  A MovieFrameSyncMorph can be torn off from the MoviePlayer with a shift-drag gesture or menu command, and can then be dropped into a MIDI score.  They are used to start a movie player at a given place in the score, and then to stretch or compress the movie frame rate so that certain frames are synchronized with the corresponding points in the score.MovieClipStartMorphs (q.v.) and MovieClipEndMorphs are used for the other kind of synchronization, namely where you wish to assemble a number of movie clips in a sequence.!MovieFrameSyncMorph subclass: #MovieClipStartMorph	instanceVariableNames: 'movieClipPlayer movieClipFileName soundTrackFileName soundTrackPlayerReady soundTrackMorph soundTrackTimeScale scoreEvent endMorph clipColor colorMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!MovieClipStartMorph commentStamp: '<historical>' prior: 0!This class and its subclasses act to syncronize movie players with the progress of a MIDI score and further background can be found in the comment for MoviePlayerMorph.MovieClipStartMorphs are used where you have a movie clip player plex.  You can create such a plex by opening a midi score, spawning a piano roll (by the button of that name), and then choosing 'add movie clip player' from the piano roll menu.  Much simpler, you can open a MoviePlayerMorph as a new morph, and then choose 'make a new movie' from its menu.  This plex then serves as a central editable score for composing movie clips.To add a new movie clip to the score, open a movie from the fileList (or as a new morph followed by 'open a movie').  Play or otherwise position the clip to the desired starting position, and then tear off a thumbnail and drop it into the score at the desired time.  The starting thumbnail (MovieClipStartMorph) will appear in the score, tied to an endMorph by a colored stripe.  The ending time will be chosen based on the total length of the clip, a default starting clip length (200 frames), and possible interference with other clips that follow it.To reposition a clip, you can pick up its clipStart with halo black handle, and drop it elsewhere.  The rest of the clip will follow as best it can.  To delete a clip, delete its clipStart.  To change the duration of a clip, play the composition up to some point in that clip, and pause it.  Then use the  controls on the central movie player to move forward or backward to the desired ending frame, and choose 'end clip here' from the player menu.!MovieClipStartMorph subclass: #MovieClipEndMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!MovieClipEndMorph commentStamp: '<historical>' prior: 0!The idea is that soon we will show the soundtrack extending between the start cue and the end morph.!BookMorph subclass: #MoviePlayerMorph	instanceVariableNames: 'movieFileName movieFile frameSize frameDepth frameNumber frameCount playDirection msSinceStart msAtStart msAtLastSync frameAtLastSync msPerFrame frameBufferIfScaled soundTrackFileName scorePlayer soundTrackForm soundTrackMorph pianoRoll cueMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!MoviePlayerMorph commentStamp: '<historical>' prior: 0!MoviePlayerMorph plays images from a file using async io.  The file format is simple but non-standard (see below).The heart of the play logic is in the step method.  Note that play is driven by a simulated time since start.  For a movie with a sound score, this is the millisecondsSinceStart of the score player, whereas a movie by itself gets this from the millisecondClock minus msAtStart.Movie players are designed to be used in three ways	1.  Select a movie in the file list, 'open as movie', and play it.	2.  As in (1), but drop thumbnails for various frames into a		MIDI piano roll to synchronize video with music.	3.  Open a MoviePlayerMorph as a 'new morph', and choose		'make a new movie' from the menu.In (1) and (2), a shift-drag is used to 'tear off' a thumbnail reference morph to the currently visible frame of this clips.  The thumbnail can then be dropped in a MIDI score player to either syncronize that frame with what point in the music, or to cause that clip to being playing in the shared player of a SqueakMovie plex.When making a new movie, an empty score and piano roll are linked to the movie player, as a SqueakMovie plex. You can then open another movie as a clip, and drop a thumbnail morph into the score to start that clip playing at that frame in the shared player.  If you pause while playing that clip, you can manually play the clip forward and backward in the current clip.  if you stop at a given frame, you can choose 'end clip here' from the shared player menu to shorten or lengthen the clip.Clips can be moved by picking up the starting thumbnail (use halo black handle), and dropping them elsewhere.  If you try to place one clip in the middle of another, it will slide to the end.  If you position one clip close to the end of another, it will sidle up to make them contiguous.If you wish a soundtrack to be included with a clip, make sure it has been opened in the source clip player before tearing off the starting thumbnail.About the .movie file format...The following code was used to convert 27 files into a movie.  They were named	'BalloonDrop10fps003.bmp' through 'BalloonDrop10fps081.bmp'incrementing by 003.  Each was known to be a 320x240 image in 32-bit BMP format.Note the 27 in the 5th line is the number of frames, = (3 to: 81 by: 3) size.	| ps zps f32 out ff |	out _ FileStream newFileNamed: 'BalloonDrop10fps.movie'.	out binary.	ff _ Form extent: 320@240 depth: 16.	#(22 320 240 16 27 100000) , (7 to: 32)		do: [:i | out nextInt32Put: i].			3 to: 81 by: 3 do:		[:i | ps _ i printString. zps _ ps padded: #left to: 3 with: $0.		f32 _ Form fromFileNamed:			'BalloonDrop10fps' , zps , '.bmp'.		f32 displayOn: ff at: 0@0.  "Convert down to 16 bits"		ff display; writeOnMovie: out].	out close.!RectangleMorph subclass: #PianoRollScoreMorph	instanceVariableNames: 'scorePlayer score colorForTrack lowestNote leftEdgeTime timeScale indexInTrack lastUpdateTick lastMutedState cursor selection timeSignature beatsPerMeasure notePerBeat showMeasureLines showBeatLines soundsPlaying soundsPlayingMorph movieClipPlayer '	classVariableNames: 'NotePasteBuffer '	poolDictionaries: ''	category: 'Sound-Scores'!!AmbientEvent methodsFor: 'as yet unclassified' stamp: 'di 10/21/2000 13:18'!occurAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick	(target == nil or: [selector == nil]) ifTrue:		[morph ifNil: [^ self].		^ morph encounteredAtTime: ticks inScorePlayer: player atIndex: index				inEventTrack: track secsPerTick: secsPerTick].	target perform: selector withArguments: arguments! !!AsyncFile methodsFor: 'primitives' stamp: 'di 9/18/2000 21:02'!primReadStart: fHandle fPosition: fPosition count: count	"Start a read operation of count bytes starting at the given offset in the given file."	<primitive: 543>	self error: 'READ THE COMMENT FOR THIS METHOD.'"NOTE: This method will fail if there is insufficient C heap to allocate an internal buffer of the required size (the value of count).  If you are trying to read a movie file, then the buffer size will be height*width*2 bytes.  Each Squeak image retains a value to be used for this allocation, and it it initially set to 0.  If you are wish to play a 640x480 movie, you need room for a buffer of 640*480*2 = 614400 bytes.  You should execute the following...	Smalltalk extraVMMemory 2555000.Then save-and-quit, restart, and try to open the movie file again.  If you are using Async files in another way, find out the value of count when this failure occurs (call it NNNN), and instead of the above, execute...	Smalltalk extraVMMemory: Smalltalk extraVMMemory + NNNNthen save-and-quit, restart, and try again."! !!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45'!wheel: thisMany	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "	| sat bri hue step c |	sat _ self saturation.	bri _ self brightness.	hue _ self hue.	step _ 360.0 / (thisMany max: 1).	^ (1 to: thisMany) collect: [:num |		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"		hue _ hue + step.		c]."(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]"! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 10/16/2000 10:46'!targetOffset: offsetPoint	"Set the offset at which we clicked down in the target morph"	targetOffset _ offsetPoint! !!MIDIScore methodsFor: 'initialization' stamp: 'di 10/23/2000 16:19'!initialize	tracks _ #().	ambientTrack _ Array new.	tempoMap _ #().	ticksPerQuarterNote _ 100.! !!MIDIScore methodsFor: 'accessing' stamp: 'di 10/21/2000 13:41'!durationInTicks		| t |	t _ 0.	tracks, {ambientTrack} do:		[:track |		track do:			[:n | (n isNoteEvent)				ifTrue: [t _ t max: n endTime]				ifFalse: [t _ t max: n time]]].	^ t! !!MIDIScore methodsFor: 'accessing' stamp: 'di 10/21/2000 10:02'!trackInfo	^ trackInfo ifNil: [tracks collect: [:i | String new]]! !!MIDIScore methodsFor: 'ambient track' stamp: 'di 10/23/2000 16:18'!addAmbientEvent: evt	| i |	i _ ambientTrack findFirst: [:e | e time >= evt time].	i = 0 ifTrue: [^ ambientTrack _ ambientTrack , (Array with: evt)].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i-1 with: (Array with: evt)! !!MIDIScore methodsFor: 'ambient track' stamp: 'di 10/25/2000 23:34'!ambientTrack	^ ambientTrack ifNil: [ambientTrack _ Array new]! !!MIDIScore methodsFor: 'ambient track' stamp: 'di 10/23/2000 08:16'!eventMorphsDo: aBlock	"Evaluate aBlock for all morphs related to the ambient events."	ambientTrack == nil ifTrue: [^ self].	ambientTrack do: [:evt | evt morph doIfNotNil: aBlock].! !!MIDIScore methodsFor: 'ambient track' stamp: 'di 10/25/2000 22:24'!eventMorphsWithTimeDo: aBlock	"Evaluate aBlock for all morphs and times related to the ambient events."	ambientTrack == nil ifTrue: [^ self].	ambientTrack do: [:evt | evt morph ifNotNil: [aBlock value: evt morph value: evt time]].! !!MIDIScore methodsFor: 'ambient track' stamp: 'di 10/23/2000 16:19'!removeAmbientEventWithMorph: aMorph	| i |	i _ ambientTrack findFirst: [:e | e morph == aMorph].	i = 0 ifTrue: [^ self].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i with: Array new! !!MIDIScore methodsFor: 'playing' stamp: 'di 10/22/2000 12:40'!pauseFrom: scorePlayer	self eventMorphsDo: [:p | p pauseFrom: scorePlayer]! !!MIDIScore methodsFor: 'playing' stamp: 'di 10/22/2000 12:40'!resetFrom: scorePlayer	self eventMorphsDo: [:p | p resetFrom: scorePlayer]! !!MIDIScore methodsFor: 'playing' stamp: 'di 10/22/2000 12:39'!resumeFrom: scorePlayer	self eventMorphsDo: [:p | p resumeFrom: scorePlayer]! !!MovieFrameSyncMorph methodsFor: 'initialization' stamp: 'di 8/5/1998 17:04'!image: aForm player: aMoviePlayer frameNumber: n	self image: aForm.	moviePlayerMorph _ aMoviePlayer.	frameNumber _ n! !!MovieFrameSyncMorph methodsFor: 'initialization' stamp: 'di 10/26/2000 01:27'!justDroppedInto: newOwner event: evt 	| pianoRoll |	"When dropping this morph into a pianoRoll, add a corresponding	event to the score so that it will always appear when played,	in addition to possibly triggering other actions"	(newOwner isKindOf: PianoRollScoreMorph)	ifTrue:		["Legacy code for existing sync morphs"		pianoRoll _ newOwner.		pianoRoll score			removeAmbientEventWithMorph: self;			addAmbientEvent: (AmbientEvent new						morph: self;						time: (pianoRoll timeForX: self left))].	super justDroppedInto: newOwner event: evt! !!MovieFrameSyncMorph methodsFor: 'access' stamp: 'di 10/11/2000 21:39'!moviePlayerMorph 	^ moviePlayerMorph! !!MovieFrameSyncMorph methodsFor: 'access' stamp: 'di 10/25/2000 22:02'!relatedPlayer 	^ moviePlayerMorph! !!MovieFrameSyncMorph methodsFor: 'drawing' stamp: 'di 10/25/2000 22:36'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	| leftX |	t > rightTime ifTrue: [^ self  "Start time has not come into view."].  	leftX _ pianoRoll xForTime: t.	(leftX + self width) < pianoRoll left ifTrue: [^ self  "End time has passed out of view."].	morphList add: 		(self align: self bottomLeft			with: leftX @ (pianoRoll bottom - pianoRoll borderWidth)).! !!MovieFrameSyncMorph methodsFor: 'events' stamp: 'di 10/26/2000 00:08'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	| next |	"Set frame number and milliseconds since start in case of drift"	moviePlayerMorph frameNumber: frameNumber		msSinceStart: scorePlayer millisecondsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next _ self nextSyncEventAfter: index inTrack: track) == nil ifFalse:		[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0						/ (next morph frameNumber - self frameNumber)].! !!MovieFrameSyncMorph methodsFor: 'events' stamp: 'di 10/24/2000 18:22'!nextSyncEventAfter: index inTrack: track	| evt |	index to: track size do:		[:i | evt _ track at: i.		((evt morph isMemberOf: self class)			and: [evt morph moviePlayerMorph == moviePlayerMorph])			ifTrue: [^ evt]].	^ nil! !!MovieFrameSyncMorph methodsFor: 'events' stamp: 'di 10/25/2000 22:03'!pauseFrom: scorePlayer	self relatedPlayer pauseFrom: scorePlayer! !!MovieFrameSyncMorph methodsFor: 'events' stamp: 'di 10/25/2000 22:02'!resetFrom: scorePlayer	self relatedPlayer resetFrom: scorePlayer! !!MovieFrameSyncMorph methodsFor: 'events' stamp: 'di 10/25/2000 22:03'!resumeFrom: scorePlayer	self relatedPlayer resumeFrom: scorePlayer! !!MovieClipStartMorph methodsFor: 'initialization' stamp: 'di 10/23/2000 10:40'!image: aForm frameNumber: n	self image: (aForm magnifyBy: self thumbnailHeight asFloat / aForm height).	frameNumber _ n.! !!MovieClipStartMorph methodsFor: 'initialization' stamp: 'di 10/26/2000 01:44'!justDroppedInto: newOwner event: evt	| pianoRoll syncMorph |	"When dropping this morph into a pianoRoll, add a corresponding	event to the score so that it will always appear when played,	in addition to possibly triggering other actions"	(newOwner isKindOf: PianoRollScoreMorph)	ifTrue:		[pianoRoll _ newOwner.		pianoRoll score removeAmbientEventWithMorph: self.		pianoRoll movieClipPlayer ifNil:			["This PianoRoll is not a clip player -- replace me by a SyncMorph"			syncMorph _ MovieFrameSyncMorph new						image: image						player: moviePlayerMorph						frameNumber: frameNumber.			pianoRoll replaceSubmorph: self by: syncMorph.			pianoRoll score addAmbientEvent: (scoreEvent						morph: syncMorph;						time: (pianoRoll timeForX: self left)).			^ self].		self movieClipPlayer: pianoRoll movieClipPlayer.		self setTimeInScore: pianoRoll score					near: (pianoRoll timeForX: self left).		pianoRoll score addAmbientEvent: scoreEvent.		self repositionEndMorph]	ifFalse:		["Dropped it somewhere else -- delete related morphs"		endMorph ifNotNil: [endMorph delete].		soundTrackMorph ifNotNil: [soundTrackMorph delete]].	self endTime > newOwner scorePlayer durationInTicks ifTrue:		[newOwner scorePlayer updateDuration].	super justDroppedInto: newOwner event: evt! !!MovieClipStartMorph methodsFor: 'initialization' stamp: 'di 10/23/2000 10:32'!movieFileName: movieFileName soundTrackFileName: soundFileName			image: aForm player: aMoviePlayer frameNumber: n	movieClipFileName _ movieFileName.	soundTrackFileName _ soundFileName.	self image: aForm frameNumber: n.	moviePlayerMorph _ aMoviePlayer.	soundTrackPlayerReady _ moviePlayerMorph scorePlayer copy.	scoreEvent _ AmbientEvent new morph: self.! !!MovieClipStartMorph methodsFor: 'access' stamp: 'di 10/19/2000 14:27'!endMorph	^ endMorph! !!MovieClipStartMorph methodsFor: 'access' stamp: 'di 10/19/2000 16:41'!frameNumber: newFrame	frameNumber _ newFrame! !!MovieClipStartMorph methodsFor: 'access' stamp: 'di 10/4/2000 17:18'!movieClipPlayer: aMoviePlayerMorph	"For now, these morphs work both as a sync point in a long movie, and	as a cue point for a short clip in a longer score.	To a cue point, this method provides a reference to the clip player."	movieClipPlayer _ aMoviePlayerMorph! !!MovieClipStartMorph methodsFor: 'access' stamp: 'di 10/25/2000 22:02'!relatedPlayer 	^ movieClipPlayer! !!MovieClipStartMorph methodsFor: 'access' stamp: 'di 10/19/2000 12:24'!scoreEvent	^ scoreEvent! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/25/2000 22:27'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	"This code handles both the start and end morphs."	| startX endX h delta |	self startTime > rightTime		ifTrue: [^ self  "Start time has not come into view."].  	self endTime < leftTime		ifTrue: [^ self  "End time has passed out of view."].	startX _ pianoRoll xForTime: self startTime.	endX _ pianoRoll xForTime: self endTime.	h _ self colorMargin.  "Height of highlight bar over thumbnails."	morphList add: 		(self align: self bottomLeft			with: startX @ (pianoRoll bottom - pianoRoll borderWidth - h)).	morphList add: 		(endMorph align: endMorph bounds rightCenter			with: endX @ self center y).	morphList add: 		(self colorMorph bounds: (self topLeft - (0@h) corner: endMorph right @ (self bottom + h))).	(soundTrackMorph == nil and: [moviePlayerMorph scorePlayer == nil]) ifFalse:		["Wants a sound track"		(soundTrackMorph == nil or: [pianoRoll timeScale ~= soundTrackTimeScale])			ifTrue: ["Needs a new sound track"					self buildSoundTrackMorphFor: pianoRoll].		morphList add: 			(soundTrackMorph align: soundTrackMorph bottomLeft with: colorMorph topLeft).		self soundTrackOnBottom ifTrue:			[soundTrackMorph align: soundTrackMorph bottomLeft with: self bottomLeft.			delta _ 0 @ self soundTrackHeight.			self position: self position - delta.			endMorph position: endMorph position - delta.			colorMorph position: colorMorph position - delta]]! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/23/2000 10:46'!colorMargin	"How far the clip span color highlight extends outside the starting clip"	^ 5! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/23/2000 10:14'!colorMorph	colorMorph ifNotNil: [^ colorMorph].	"Make up a morph to highlight the span of this clip."	ColorIndex _ (ColorIndex ifNil: [0]) + 2 \\ 8 + 1.	^ colorMorph _ Morph newBounds: (0@0 extent: 9@9) color: ((Color wheel: 8) at: ColorIndex)! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/23/2000 10:24'!delete	(owner isKindOf: PianoRollScoreMorph) ifTrue:		[owner score removeAmbientEventWithMorph: self.		endMorph ifNotNil: [owner score removeAmbientEventWithMorph: endMorph]].	endMorph ifNotNil: [endMorph delete].	soundTrackMorph ifNotNil: [soundTrackMorph delete].	colorMorph ifNotNil: [colorMorph delete].	super delete.! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/23/2000 10:23'!soundTrackHeight	^ 40! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/23/2000 10:58'!soundTrackOnBottom  "a local preference during test"	^ false! !!MovieClipStartMorph methodsFor: 'drawing' stamp: 'di 10/23/2000 12:32'!thumbnailHeight	^ 60! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/26/2000 00:09'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"If being shown as a clip, then tell the clipPlayer to start showing this clip"	movieClipPlayer setCueMorph: self.	movieClipPlayer openFileNamed: movieClipFileName			withScorePlayer: soundTrackPlayerReady copy			andPlayFrom: frameNumber.! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/22/2000 20:24'!endTime	^ endMorph scoreEvent time! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/22/2000 20:27'!frameAtTick: time	"Return the frame number corresponding to the given tick time"	^ frameNumber +		((time - self startTime) asFloat			/ (self endTime - self startTime)			* (endMorph frameNumber - frameNumber)) asInteger! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/11/2000 21:40'!nextSyncEventAfter: index inTrack: track	| evt |	index to: track size do:		[:i | evt _ track at: i.		((evt morph isMemberOf: self class)			and: [evt morph moviePlayerMorph == moviePlayerMorph])			ifTrue: [^ evt]].	^ nil! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/26/2000 00:17'!resetFrom: scorePlayer	(movieClipPlayer cueMorph == nil or: [self startTime < movieClipPlayer cueMorph startTime]) ifTrue:		[movieClipPlayer openFileNamed: movieClipFileName				withScorePlayer: soundTrackPlayerReady copy				andPlayFrom: frameNumber;			setCueMorph: self;			step;			pauseFrom: scorePlayer]! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/25/2000 22:03'!resumeFrom: scorePlayer	| time |	"New movie clip style of use."	time _ scorePlayer ticksSinceStart.	time < self startTime ifTrue: [^ self].  "It's not my time yet"	time > self endTime ifTrue: [^ self].  "It's past my time"	"The player is starting in the midst of this clip."	movieClipPlayer openFileNamed: movieClipFileName				withScorePlayer: soundTrackPlayerReady copy				andPlayFrom: (self frameAtTick: time);		setCueMorph: self.! !!MovieClipStartMorph methodsFor: 'events' stamp: 'di 10/22/2000 20:24'!startTime	^ scoreEvent time! !!MovieClipStartMorph methodsFor: 'private' stamp: 'di 10/21/2000 23:28'!buildSoundTrackMorphFor: pianoRoll	| stopTime soundTrackForm startTime samplesPerTick samplesPerMs |	soundTrackTimeScale _ pianoRoll timeScale.  "pixels per tick"	samplesPerTick _ moviePlayerMorph scorePlayer originalSamplingRate   "Samples per sec"						* pianoRoll scorePlayer secsPerTick.  "secs per tick"	samplesPerMs _ moviePlayerMorph scorePlayer originalSamplingRate / 1000.0.	startTime _ frameNumber * moviePlayerMorph msPerFrame.  "ms"	stopTime _ endMorph frameNumber * moviePlayerMorph msPerFrame.	soundTrackForm _ moviePlayerMorph scorePlayer		volumeForm: self soundTrackHeight		from: (startTime * samplesPerMs) rounded		to: (stopTime * samplesPerMs) rounded		nSamplesPerPixel: samplesPerTick / soundTrackTimeScale.	^ soundTrackMorph _ ImageMorph new image: soundTrackForm! !!MovieClipStartMorph methodsFor: 'private' stamp: 'di 10/23/2000 11:01'!repositionEndMorph	| pianoRoll |	endMorph ifNil: [self setEndFrameNumber: (moviePlayerMorph frameCount max: 200)].	pianoRoll _ movieClipPlayer pianoRoll.	endMorph scoreEvent time: self startTime   "in ticks"		+ (pianoRoll scorePlayer ticksForMSecs:			(endMorph frameNumber - frameNumber) * moviePlayerMorph msPerFrame).	pianoRoll score removeAmbientEventWithMorph: endMorph;		addAmbientEvent: endMorph scoreEvent.	pianoRoll rebuildFromScore! !!MovieClipStartMorph methodsFor: 'private' stamp: 'di 10/23/2000 11:00'!setEndFrameNumber: frame	endMorph ifNil:		[endMorph _ MovieClipEndMorph new			movieFileName: movieClipFileName			image: (moviePlayerMorph pageFormForFrame: frame)			player: movieClipPlayer			frameNumber: frame]		ifNotNil:		[endMorph image: movieClipPlayer currentPage image frameNumber: frame].	soundTrackMorph _ nil.  "Force it to be recomputed."	self repositionEndMorph! !!MovieClipStartMorph methodsFor: 'private' stamp: 'di 10/23/2000 01:34'!setTimeInScore: score near: dropTime	"Find a time to place this clip that does not overlap other clips.	So, if I start in the middle of another clip, move me to the end of it,	and if I start very soon after another clip, put me right at the end.	Then, if my end goes beyond the start of another clip, shorten me	so I end right before that clip."	| startTime endTime delta endFrame shortened |	movieClipPlayer ifNil: [^ dropTime].  "Not a movieClip assembly"	startTime _ dropTime.	shortened _ false.	endMorph ifNil: [endFrame _ moviePlayerMorph frameCount]			ifNotNil: [endFrame _ endMorph frameNumber].	endTime _ startTime   "in ticks"		+ (movieClipPlayer pianoRoll scorePlayer ticksForMSecs:			(endFrame - frameNumber)			* moviePlayerMorph msPerFrame).	score eventMorphsDo:		[:m | (m ~~ self and: [m isMemberOf: self class]) ifTrue:				[(startTime between: m startTime and: m endTime)					ifTrue: ["If I start in the middle of another clip, move me to the end of it"							delta _ (m endTime + 1) - startTime.							startTime _ startTime + delta.							endTime _ endTime + delta].				(startTime between: m endTime and: m endTime+50)					ifTrue: ["If I start very soon after another clip, put me right at the end"							delta _ (m endTime + 1) - startTime.							startTime _ startTime + delta.							endTime _ endTime + delta].				(endTime between: m startTime and: m endTime)					ifTrue: ["If my end goes overlaps another clip, shorten me so I fit."							endTime _ m startTime - 1.							shortened _ true].				]].	scoreEvent time: startTime.	shortened ifFalse: [^ self].	self setEndFrameNumber: frameNumber + 			((endTime - startTime)			* (movieClipPlayer pianoRoll scorePlayer secsPerTick*1000.0)			/ moviePlayerMorph msPerFrame) asInteger - 1.! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/26/2000 00:25'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	"Ignored -- all display is done by the starting morph -- see superclass"! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/11/2000 23:06'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	movieClipPlayer ifNotNil:		["If being shown as a clip, then tell the clipPlayer to stop showing this clip"		movieClipPlayer stopRunning]! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/22/2000 17:28'!movieFileName: movieFileName image: aForm player: aMoviePlayer frameNumber: n	movieClipFileName _ movieFileName.	self image: aForm frameNumber: n.	moviePlayerMorph _ movieClipPlayer _ aMoviePlayer.	scoreEvent _ AmbientEvent new morph: self.! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/22/2000 12:43'!pauseFrom: scorePlayer	"Ignored"! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/22/2000 12:43'!resetFrom: scorePlayer	"Ignored"! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/22/2000 12:43'!resumeFrom: scorePlayer	"Ignored"! !!MovieClipEndMorph methodsFor: 'as yet unclassified' stamp: 'di 10/23/2000 10:42'!thumbnailHeight	^ 30! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/8/2000 21:43'!openFileNamed: fName 	self pvtOpenFileNamed: fName.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/27/2000 15:22'!openFileNamed: fName withScorePlayer: playerReady andPlayFrom: frameNo	"Note: The plan is that the score player (a SampledSound) is already spaced	forward to this frame number so it does not need to be reset as would normally	happen in startRunning."	self pvtOpenFileNamed: fName.	scorePlayer _ playerReady.	frameNumber _ frameNo.	frameAtLastSync _ frameNo.	msAtLastSync _ frameAtLastSync * msPerFrame.	self playForward.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/24/2000 17:01'!setInitialState	super setInitialState.	self inset: 3.	self borderWidth: 2.	self color: Color veryLightGray.	pageSize _ frameSize _ 200@200.	frameDepth _ 8.	self disableDragNDrop! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/27/2000 14:08'!stopSoundTrackIfAny	scorePlayer == nil ifTrue:[^ self].	(scorePlayer isKindOf: SampledSound)		ifTrue: [scorePlayer stopGracefully]		ifFalse: [scorePlayer _ nil]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 10/22/2000 23:41'!wantsRoundedCorners	^ Preferences roundedWindowCorners or: [super wantsRoundedCorners]! !!MoviePlayerMorph methodsFor: 'controls and layout' stamp: 'di 10/24/2000 16:38'!extent: newExtent	| tlMargin brMargin pageExtent scale fullSizeImage |	fullSizeImage _ frameBufferIfScaled ifNil: [currentPage image].	frameCount ifNil: [^ self].  "Not yet open"	tlMargin _ currentPage topLeft - self topLeft.	brMargin _ self bottomLeft - currentPage bottomLeft.	pageExtent _ newExtent - brMargin - tlMargin.	scale _ pageExtent x asFloat / frameSize x min: pageExtent y asFloat / frameSize y.	(scale _ scale max: 0.25) > 0.9 ifTrue: [scale _ 1.0].	pageExtent _ (frameSize * scale) rounded.	pageExtent = frameSize		ifTrue: [currentPage image: fullSizeImage.				frameBufferIfScaled _ nil]		ifFalse: [currentPage image: (Form extent: pageExtent depth: frameDepth).				frameBufferIfScaled _ fullSizeImage.				(WarpBlt current toForm: currentPage image) sourceForm: fullSizeImage;					combinationRule: 3;					copyQuad: fullSizeImage boundingBox innerCorners						toRect: currentPage image boundingBox].	^ self layoutChanged! !!MoviePlayerMorph methodsFor: 'controls and layout' stamp: 'di 10/16/2000 13:20'!fullControlSpecs	^ #(				( '¥'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			( '->'		nextPage		'Forward one frame')			( '>>'		playForward	'Play forward')			( '-->'		lastPage			'Go to final page')			( '<->'		scanBySlider	'Scan by slider'  'menu')		"Note extra spec 'menu' causes mousedown activation -- see makePageControlsFrom:"	)! !!MoviePlayerMorph methodsFor: 'controls and layout' stamp: 'di 10/24/2000 16:43'!minExtent	^ (640@480) // 4 + (14@89)! !!MoviePlayerMorph methodsFor: 'controls and layout' stamp: 'di 10/24/2000 17:22'!showHideSoundTrack	soundTrackForm ifNotNil:		[soundTrackMorph delete.		^ soundTrackForm _ soundTrackMorph _ nil].	soundTrackForm _ scorePlayer volumeForm: 20 from: 1 to: scorePlayer samples size nSamplesPerPixel: 250.	soundTrackMorph _ ImageMorph new image: (Form extent: 140 @ soundTrackForm height).	soundTrackMorph addMorph:		(Morph newBounds: (soundTrackMorph bounds topCenter extent: 1@soundTrackMorph height)					color: Color red).	self addMorph: soundTrackMorph after: currentPage.	self layoutChanged.	self stepSoundTrack.! !!MoviePlayerMorph methodsFor: 'controls and layout' stamp: 'di 10/24/2000 16:55'!showPageControls	self showPageControls: self fullControlSpecs.! !!MoviePlayerMorph methodsFor: 'controls and layout' stamp: 'di 10/24/2000 17:25'!showPageControls: controlSpecs 	| pageControls |	self hidePageControls.	pageControls _ self makePageControlsFrom: controlSpecs.	pageControls borderWidth: 0; inset: 0; extent: pageControls width@14.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	pageControls eventHandler: (EventHandler new on: #mouseDown send: #move to: self).	self addMorphBack: pageControls beSticky! !!MoviePlayerMorph methodsFor: 'events' stamp: 'di 10/16/2000 13:27'!handlesMouseDown: evt	"We use shift drag to 'tear off' a thumbnail"	evt shiftPressed ifTrue: [^ true].	^ super handlesMouseDown: evt! !!MoviePlayerMorph methodsFor: 'events' stamp: 'di 10/16/2000 13:32'!mouseDown: evt	"We use shift drag to 'tear off' a thumbnail"	evt shiftPressed ifTrue: [^ self makeThumbnailInHand: evt hand].	^ super mouseDown: evt		! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/26/2000 00:18'!cueMorph	^ cueMorph! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/4/2000 17:19'!fileName	^ movieFileName! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/22/2000 10:54'!frameCount	^ frameCount! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/22/2000 16:01'!frameNumber: n	frameNumber _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/19/2000 16:31'!msPerFrame	^ msPerFrame! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/23/2000 01:45'!pageFormForFrame: frameNo	| f form oldFrame |oldFrame _ frameNumber.self goToPage: frameNo.form _ currentPage image deepCopy.self goToPage: oldFrame.true ifTrue: [^ form].	f _ FileStream readOnlyFileNamed: movieFileName.	form _ Form extent: frameSize depth: frameDepth.	"For some weird reason, the next line does not work..."	f position: (self filePosForFrameNo: frameNo).	"... but this line was found empirically to work instead."	f position: (128 + ((frameNo-1)*(form bits size*4+4)) + 4).	f nextInto: form bits.	f close.	^ form! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/15/2000 19:15'!relativePosition	^ frameNumber asFloat / frameCount! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/11/2000 12:13'!scorePlayer	^ scorePlayer! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/11/2000 12:20'!scorePlayer: aScorePlayer	scorePlayer _ aScorePlayer! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/19/2000 10:27'!setCueMorph: aMorph	cueMorph _ aMorph! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 10/13/2000 11:51'!soundTrackFileName	^ soundTrackFileName! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 9/7/2000 09:34'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startRunning; step.  "will stop after first step"	soundTrackMorph doIfNotNil: [:m | m image fillWhite].	self stepSoundTrack.! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 10/16/2000 11:02'!goToRelativePosition: newPos	movieFile ifNotNil: [^ self].	self goToPage: ((newPos*frameCount) asInteger min: frameCount max: 1).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 10/13/2000 20:06'!stopPlay	playDirection _ 0.	self step! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 10/25/2000 22:04'!pauseFrom: player	playDirection _ 0.	self step.! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 10/25/2000 22:06'!resetFrom: player	self pauseFrom: player.	self firstPage! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 10/22/2000 12:56'!resumeFrom: player	playDirection ~= 0 ifTrue: [^ self].  "Already running"	playDirection _ 1.	pianoRoll ifNil:		["Sync movie to score player if not a clip player"		scorePlayer _ player].	self startRunning! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 9/5/2000 23:09'!fileByteCountPerFrame		^ (frameBufferIfScaled ifNil: [currentPage image]) bits size * 4! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 10/27/2000 17:39'!startRunning	| ms |	(frameBufferIfScaled ifNil: [currentPage image]) unhibernate.	movieFile _ AsyncFile new open: movieFileName forWrite: false.	movieFile primReadStart: movieFile fileHandle			fPosition: (self filePosForFrameNo: frameNumber)			count: self fileByteCountPerFrame.	scorePlayer == nil		ifTrue: [ms _ Time millisecondClockValue.				msAtStart _ ms - ((frameNumber-1) * msPerFrame).				msAtLastSync _ ms - msAtStart.				frameAtLastSync _ frameNumber]		ifFalse: [(playDirection > 0 and: [scorePlayer isKindOf: SampledSound]) ifTrue:					[scorePlayer reset;							playSilentlyUntil: (frameNumber - 1 * msPerFrame / 1000.0).					[scorePlayer resumePlaying.					msAtLastSync _ scorePlayer millisecondsSinceStart]						forkAt: Processor userInterruptPriority].				msAtLastSync _ scorePlayer millisecondsSinceStart.				frameAtLastSync _ frameNumber]! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 10/24/2000 17:31'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If scorePlayer is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  If the movie is running ahead, then some calls on step will skip their  action until the right time.  If the movie is running behind, then the frame may advance by more than one to maintain synchronization."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	"This code may not work right for playing backwards right now.	Single-step and backwards (dir <= 0) should just run open-loop."	|  byteCount simTime ms nextFrameNumber |	movieFile == nil ifTrue: [^ self].	scorePlayer == nil		ifTrue: [(ms _ Time millisecondClockValue) < msAtStart ifTrue:  "clock rollover"					[msAtStart _ ms - (frameNumber * msPerFrame)].				simTime _ ms - msAtStart]		ifFalse: [simTime _ scorePlayer millisecondsSinceStart].	playDirection > 0		ifTrue: [nextFrameNumber _ frameAtLastSync + ((simTime - msAtLastSync)//msPerFrame).				nextFrameNumber = frameNumber ifTrue:					[((scorePlayer isKindOf: AbstractSound) and: [scorePlayer isPlaying not])						ifTrue: [^ self stopRunning].					^ self]]		ifFalse: [playDirection < 0 ifTrue: [nextFrameNumber _ frameNumber - 1]								ifFalse: [nextFrameNumber _ frameNumber]].	byteCount _ self fileByteCountPerFrame.	self stepSoundTrack.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle			intoBuffer: (frameBufferIfScaled ifNil: [currentPage image]) bits			at: 1 count: byteCount//4.	frameBufferIfScaled ifNotNil:		["If this player has been shrunk, then we have to warp to the current page."		(WarpBlt current toForm: currentPage image) sourceForm: frameBufferIfScaled;				combinationRule: 3;						"Use smoothing if just stepping"				cellSize: (playDirection = 0 ifTrue: [2] ifFalse: [1]);				copyQuad: frameBufferIfScaled boundingBox innerCorners					toRect: currentPage image boundingBox].	currentPage changed.	frameNumber _ nextFrameNumber.		(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopRunning].	"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: (self filePosForFrameNo: frameNumber)			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 9/6/2000 21:55'!stepSoundTrack	| x image timeInMillisecs |	scorePlayer ifNil: [^ self].	soundTrackForm ifNil: [^ self].	playDirection = 0		ifTrue: ["Stepping forward or back"				timeInMillisecs _ frameNumber - 1 * msPerFrame]		ifFalse: ["Driven by sound track"				timeInMillisecs _ scorePlayer millisecondsSinceStart].	x _ timeInMillisecs / 1000.0 * scorePlayer originalSamplingRate // 250.	image _ soundTrackMorph image.	image copy: (image boundingBox translateBy: (x - (image width//2)) @ 0)			from: soundTrackForm to: 0@0 rule: Form over.	soundTrackMorph changed.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 10/8/2000 22:27'!stopRunning	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil: [movieFile close.  movieFile _ nil].	playDirection _ 0.	self stopSoundTrackIfAny! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/13/2000 11:47'!addSoundTrack	| fileName |	fileName _ Utilities chooseFileWithSuffixFromList: #('.aif' '.wav')					withCaption: 'Choose a sound track file'.	fileName == nil ifTrue: [^ self].	soundTrackFileName _ fileName.	self tryToShareScoreFor: soundTrackFileName.	scorePlayer ifNil:		[('*aif' match: fileName) ifTrue:			[scorePlayer _ SampledSound fromAIFFfileNamed: fileName].		('*wav' match: fileName) ifTrue:			[scorePlayer _ SampledSound fromWaveFileNamed: fileName]].	soundTrackForm ifNotNil:		["Compute new soundTrack if we're showing it."		self showHideSoundTrack; showHideSoundTrack]! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/13/2000 20:17'!duplicate	| dup |	playDirection ~= 0 ifTrue: [self stopPlay].	dup _ super duplicate.	dup scorePlayer: scorePlayer copy.  "Share sound track if any."	dup startStepping.	^ dup! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/19/2000 17:07'!endClipHere	"Change set the termination time for this clip via the endMorph"	cueMorph ifNil: [^ self].	cueMorph setEndFrameNumber: frameNumber! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/24/2000 17:02'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu add:	'make a new movie' action: #makeAMovie.	aMenu add:	'open movie file' action: #openMovieFile.	aMenu add:	'add sound track' action: #addSoundTrack.	aMenu addLine.	scorePlayer ifNotNil:		[soundTrackForm == nil			ifTrue: [aMenu add:	'show sound track' action: #showHideSoundTrack]			ifFalse: [aMenu add:	'hide sound track' action: #showHideSoundTrack]].	aMenu add:	'make thumbnail' action: #thumbnailForThisPage.	cueMorph ifNotNil:		["Should check if piano roll and score already have a start event		prior to this time."		aMenu add:	'end clip here' action: #endClipHere].	(sel _ aMenu invokeAt: self primaryHand position in: self world)		ifNotNil: [self perform: sel].! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/24/2000 17:02'!makeAMovie	| scoreController score |	frameSize _ 640@480.  frameDepth _ 16.  self makeMyPage; changed.	(score _ MIDIScore new initialize) "addAmbientEvent: (AmbientEvent new time: 200*60)".	scoreController _ ScorePlayerMorph new			onScorePlayer: (ScorePlayer onScore: score) title: 'sMovie'.	pianoRoll _ PianoRollScoreMorph new on: scoreController scorePlayer.	self pianoRoll: pianoRoll.  "back link"	pianoRoll enableDragNDrop;		useRoundedCorners;		movieClipPlayer: self;		borderWidth: 2;		extent: self width @ 120;		align: pianoRoll topLeft with: self bottomLeft - (0@2);		openInWorld.	scoreController extent: self width @ scoreController height;		align: scoreController topLeft with: pianoRoll bottomLeft - (0@2);		openInWorld.! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 9/7/2000 09:44'!openMovieFile	| fileName |	fileName _ Utilities chooseFileWithSuffixFromList: #('.movie')					withCaption: 'Choose a movie file to open'.	fileName ifNotNil:		[self openFileNamed: fileName.		self showMoreControls]! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/16/2000 13:21'!scanBySlider	| scrollSlider handle |	scrollSlider _ SimpleSliderMorph new extent: 150@10;		color: color; sliderColor: Color gray;		target: self; actionSelector: #goToRelativePosition:;		adjustToValue: self relativePosition.	(handle _ scrollSlider firstSubmorph) on: #mouseUp send: #delete to: scrollSlider.	scrollSlider align: handle center with: self activeHand position.	self world addMorph: scrollSlider.	self activeHand targetOffset: (handle width // 2) @ 0.	self activeHand newMouseFocus: handle! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/16/2000 13:31'!thumbnailForThisPage	"Overridden to make a MovieFrameSyncMorph"	^ self makeThumbnailInHand: self activeHand! !!MoviePlayerMorph methodsFor: 'movie clip player' stamp: 'di 10/19/2000 22:02'!pianoRoll	^ pianoRoll! !!MoviePlayerMorph methodsFor: 'movie clip player' stamp: 'di 10/4/2000 16:38'!pianoRoll: aPianoRollScoreMorph	"Provides access also to the score and scorePlayer"	pianoRoll _ aPianoRollScoreMorph! !!MoviePlayerMorph methodsFor: 'private' stamp: 'di 10/24/2000 16:59'!makeMyPage	currentPage ifNotNil:		[(currentPage isMemberOf: ImageMorph)			ifTrue: ["currentPage is already an ImageMorph."					(currentPage image extent = frameSize						and: [currentPage image depth = frameDepth])						ifTrue: [^ self  "page is already properly dimensioned."].					^ currentPage image: (Form extent: frameSize depth: frameDepth)]			ifFalse: [currentPage releaseCachedState; delete]].	currentPage _ ImageMorph new image: (Form extent: frameSize depth: frameDepth).	currentPage lock.	pages _ OrderedCollection with: currentPage.	self addMorphFront: currentPage! !!MoviePlayerMorph methodsFor: 'private' stamp: 'di 10/25/2000 23:01'!makeThumbnailInHand: aHand	scorePlayer ifNotNil:		["Position the soundTrack for this frameNumber"		scorePlayer reset; playSilentlyUntil: frameNumber - 1 * msPerFrame / 1000.0].	aHand attachMorph:		(MovieClipStartMorph new			movieFileName: movieFileName			soundTrackFileName: soundTrackFileName			image: currentPage image			player: self			frameNumber: frameNumber)! !!MoviePlayerMorph methodsFor: 'private' stamp: 'di 10/17/2000 08:45'!pvtOpenFileNamed: fName	| f w h d n m |	self stopRunning.	fName = movieFileName ifTrue: [^ self].  "No reopen necessary on same file"	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		m _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msAtLastSync _ 0.	msPerFrame _ m/1000.0.	self makeMyPage.	(Smalltalk extraVMMemory < self fileByteCountPerFrame) ifTrue:		[^ PopUpMenu notify:'Playing movies in Squeak requires that extra memory be allocatedfor asynchronous file IO.  This particular movie requires a buffer of' ,(self fileByteCountPerFrame printString) , ' bytes, but you only have ' , (Smalltalk extraVMMemory printString) , ' allocated.You can evaluate ''Smalltalk extraVMMemory'' to check your allocation,and ''Smalltalk extraVMMemory: 485000'' or the like to increase your allocation.Note that raising your allocation in this way only marks your image asneeding this much, so you must then save, quit, and start over againbefore you can run this movie.  Good luck.'].! !!MoviePlayerMorph methodsFor: 'private' stamp: 'di 10/22/2000 10:39'!tryToShareScoreFor: fileName	scorePlayer _ nil.	self class allInstancesDo:		[:mp | mp == self ifFalse:			[mp soundTrackFileName = fileName ifTrue:				["Found this score already open in another player					-- return a copy that shares the same sound buffer."				mp scorePlayer ifNotNil: [^ scorePlayer _ mp scorePlayer copy reset]]]]! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 10/19/2000 10:07'!movieClipPlayer	^ movieClipPlayer! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 10/21/2000 22:06'!movieClipPlayer: moviePlayer	movieClipPlayer _ moviePlayer! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 10/19/2000 21:19'!timeScale	^ timeScale  "in pixels per tick"! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 10/25/2000 22:27'!addNotes	"Recompute the set of morphs that should be visible at the current scroll position."	| visibleMorphs rightEdge topEdge trackColor i done n nLeft nTop nRight rightEdgeTime |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	rightEdgeTime _ self timeForX: rightEdge.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"	score eventMorphsWithTimeDo:		[:m :t | m addMorphsTo: visibleMorphs pianoRoll: self eventTime: t					betweenTime: leftEdgeTime and: rightEdgeTime].	"Then add note morphs"	score tracks withIndexDo:		[:track :trackIndex |		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ scorePlayer mutedForTrack: trackIndex.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				n time > rightEdgeTime					ifTrue: [done _ true]					ifFalse: [						nLeft _ self xForTime: n time.						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated - 1.							visibleMorphs add:								((PianoRollNoteMorph									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)									trackIndex: trackIndex indexInTrack: i)]]].			i _ i + 1].			(selection notNil				and: [trackIndex = selection first				and: [i >= selection second and: [(indexInTrack at: trackIndex) <= selection third]]])				ifTrue: [visibleMorphs do:						[:vm | (vm isKindOf: PianoRollNoteMorph) ifTrue: [vm selectFrom: selection]]]].	"Add the cursor morph in front of all notes; height and position are set later."	cursor ifNil: [cursor _ Morph newBounds: (self topLeft extent: 1@1) color: Color red].	visibleMorphs addFirst: cursor.	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 10/24/2000 16:17'!drawMeasureLinesOn: aCanvas	| ticksPerMeas x measureLineColor inner |	showBeatLines ifNil: [showBeatLines _ false].	showMeasureLines ifNil: [showMeasureLines _ true].	notePerBeat ifNil: [self timeSignature: 4 over: 4].	showBeatLines ifTrue:		[measureLineColor _ Color gray: 0.8.		ticksPerMeas _ score ticksPerQuarterNote.		inner _ self innerBounds.		(leftEdgeTime + ticksPerMeas truncateTo: ticksPerMeas)			to: ((self timeForX: self right - borderWidth) truncateTo: ticksPerMeas)			by: ticksPerMeas			do: [:tickTime | x _ self xForTime: tickTime.				aCanvas fillRectangle: (x @ inner top extent: 1 @ inner height)					color: measureLineColor]].	showMeasureLines ifTrue:		[measureLineColor _ Color gray: 0.7.		ticksPerMeas _ beatsPerMeasure*score ticksPerQuarterNote*4//notePerBeat.		inner _ self innerBounds.		(leftEdgeTime + ticksPerMeas truncateTo: ticksPerMeas)			to: ((self timeForX: self right - borderWidth) truncateTo: ticksPerMeas)			by: ticksPerMeas			do: [:tickTime | x _ self xForTime: tickTime.				aCanvas fillRectangle: (x @ inner top extent: 1 @ inner height)						color: (tickTime = 0 ifTrue: [Color black] ifFalse: [measureLineColor])]].! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 10/22/2000 09:34'!drawSubmorphsOn: aCanvas	aCanvas clipBy: self innerBounds			during:[:clippedCanvas| super drawSubmorphsOn: clippedCanvas].! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'di 10/12/2000 00:40'!tickTimeAtCursor	cursor ifNil: [^ 0].	^ self timeForX: cursor left! !!PianoRollScoreMorph methodsFor: 'submorphs-add/remove' stamp: 'di 10/23/2000 16:24'!privateRemoveMorph: aMorph	| trackSize |	trackSize _ score ambientTrack size.	score removeAmbientEventWithMorph: aMorph.	trackSize = score ambientTrack size ifFalse:		["Update duration if we removed an event".		scorePlayer updateDuration].	^ super privateRemoveMorph: aMorph! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 10/4/2000 16:16'!addCustomMenuItems: aMenu hand: aHandMorph	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu add: 'expand time' action: #expandTime.	aMenu add: 'contract time' action: #contractTime.	aMenu addLine.	aMenu add: 'add movie clip player' action: #addMovieClipPlayer.	(self valueOfProperty: #dragNDropEnabled) == true		ifTrue: [aMenu add: 'close drag and drop' action: #disableDragNDrop]		ifFalse: [aMenu add: 'open drag and drop' action: #enableDragNDrop].! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 10/4/2000 16:40'!addMovieClipPlayer	movieClipPlayer _ MoviePlayerMorph new.	movieClipPlayer pianoRoll: self.  "back link"	self activeHand attachMorph: movieClipPlayer! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 10/24/2000 16:14'!moveCursorToTime: scoreTime	| cursorOffset desiredCursorHeight |	scorePlayer isPlaying		ifTrue:			[cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger.			(cursorOffset < 0				or: [cursorOffset > (self width-20)])				ifTrue:				[self goToTime: scoreTime - (20/timeScale).				cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger]]		ifFalse:			[self goToTime: (scoreTime - (self width//2 / timeScale)							max: (self width//10 / timeScale) negated).			cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger].	cursor position: (self left + borderWidth + cursorOffset)@(self top + borderWidth).	desiredCursorHeight _ self height.	cursor height ~= desiredCursorHeight ifTrue: [cursor extent: 1@desiredCursorHeight].! !!SampledSound methodsFor: 'playing' stamp: 'di 10/27/2000 17:36'!playSilentlyUntil: startTime	"Used to fast foward to a particular starting time.	Overridden to be instant for sampled sounds."true ifTrue: [^ super playSilentlyUntil: startTime].	indexHighBits _ (startTime * originalSamplingRate) asInteger.	scaledIndex _ IncrementScaleFactor.	count _ initialCount - self samplingRate.	mSecsSinceStart _ (startTime * 1000) asInteger.! !!SampledSound methodsFor: 'sound tracks' stamp: 'di 9/6/2000 20:48'!sonogramMorph: height from: start to: stop nPoints: nPoints	"FYI:  It is very cool that we can do this, but for sound tracks on a movie,	simple volume is easier to read, easier to scale, and way faster to compute.	Code preserved here just in case it makes a useful example."	"In an inspector of a samplesSound...		self currentWorld addMorph: (self sonogramMorph: 32 from: 1 to: 50000 nPoints: 256)	"	| fft sonogramMorph data width |	fft _ FFT new: nPoints.	width _ stop-start//nPoints.	sonogramMorph _ Sonogram new			extent: width@height			minVal: 0.0			maxVal: 1.0			scrollDelta: width.	start to: stop-nPoints by: nPoints do:		[:i |		data _ fft transformDataFrom: samples startingAt: i.		data _ data collect: [:v | v sqrt].  "square root compresses dynamic range"		data /= 200.0.		sonogramMorph plotColumn: data].	^ sonogramMorph	! !!SampledSound methodsFor: 'sound tracks' stamp: 'di 10/22/2000 11:12'!volumeForm: height from: start to: stop nSamplesPerPixel: nPerPixel	"Note: nPerPixel can be Integer or Float for pixel-perfect alignment."	"In an inspector of a samplesSound...		self currentWorld addMorph: (ImageMorph new image:			(self volumeForm: 32 from: 1 to: samples size nSamplesPerPixel: 225))	"	| volPlot width sample min max vol |	width _ stop-start//nPerPixel.	volPlot _ Form extent: width@height.	(start max: 1) to: (stop min: samples size)-nPerPixel by: nPerPixel do:		[:i | min_ max_ 0.		i asInteger to: (i+nPerPixel-1) asInteger by: 4 do:  "by: 4 makes it faster yet looks the same"			[:j | sample _ samples at: j.			sample < min ifTrue: [min _ sample].			sample > max ifTrue: [max _ sample]].		vol _ (max - min) * height // 65536.		volPlot fillBlack: ((i-start//nPerPixel) @ (height-vol//2) extent: 1@(vol+1))].	^ volPlot	! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 10/21/2000 13:47'!isDone	| track |	activeSounds size > 0 ifTrue: [^ false].	activeMIDINotes size > 0 ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	(trackEventIndex last) <= score ambientTrack size ifTrue: [^ false].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 10/22/2000 17:19'!jumpToTick: startTick	| |	self reset.	self processTempoMapAtTick: startTick.	self skipNoteEventsThruTick: startTick.	self skipAmbientEventsThruTick: startTick.	ticksSinceStart _ startTick.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 10/22/2000 17:19'!skipAmbientEventsThruTick: startTick	"Skip ambient events through the given score tick."	score ambientTrack withIndexDo:		[:evt :i | evt time > startTick ifTrue:			[^ trackEventIndex at: trackEventIndex size put: i]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 10/19/2000 21:12'!secsPerTick	^ secsPerTick! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'di 10/22/2000 23:42'!wantsRoundedCorners	^ Preferences roundedWindowCorners or: [super wantsRoundedCorners]! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'di 10/28/2000 11:09'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MVCMenuMorph new defaultTarget: self.	aMenu add:	'make a new movie' action: #makeAMovie.	aMenu add:	'open movie file' action: #openMovieFile.	aMenu add:	'add sound track' action: #addSoundTrack.	aMenu addLine.	scorePlayer ifNotNil:		[soundTrackForm == nil			ifTrue: [aMenu add:	'show sound track' action: #showHideSoundTrack]			ifFalse: [aMenu add:	'hide sound track' action: #showHideSoundTrack]].	aMenu add:	'make thumbnail' action: #thumbnailForThisPage.	cueMorph ifNotNil:		["Should check if piano roll and score already have a start event		prior to this time."		aMenu add:	'end clip here' action: #endClipHere].	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!MoviePlayerMorph reorganize!('initialization' openFileNamed: openFileNamed:withScorePlayer:andPlayFrom: position: setInitialState stopSoundTrackIfAny wantsRoundedCorners)('controls and layout' extent: fullControlSpecs insertPage minExtent showHideSoundTrack showPageControls showPageControls:)('events' handlesMouseDown: mouseDown:)('access' cueMorph fileName frameCount frameNumber frameNumber: frameNumber:msSinceStart: msPerFrame msPerFrame: pageFormForFrame: relativePosition scorePlayer scorePlayer: setCueMorph: soundTrackFileName)('player control' firstPage goToPage: goToRelativePosition: lastPage nextPage playForward playReverse previousPage stopPlay)('score events' pauseFrom: resetFrom: resumeFrom:)('stepping' fileByteCountPerFrame filePosForFrameNo: startRunning step stepSoundTrack stepTime stopRunning)('menu' addSoundTrack duplicate endClipHere invokeBookMenu makeAMovie openMovieFile scanBySlider thumbnailForThisPage)('movie clip player' pianoRoll pianoRoll:)('private' makeMyPage makeThumbnailInHand: pvtOpenFileNamed: tryToShareScoreFor:)!MovieClipEndMorph removeSelector: #addMorphsTo:in:betweenTime:and:!MovieClipStartMorph removeSelector: #addMorphsTo:in:betweenTime:and:!MovieClipStartMorph removeSelector: #frameNumber!MovieClipStartMorph removeSelector: #moviePlayerMorph!MovieClipStartMorph removeSelector: #pauseFrom:!!MovieFrameSyncMorph reorganize!('initialization' image:player:frameNumber: justDroppedInto:event:)('access' frameNumber moviePlayerMorph relatedPlayer)('drawing' addMorphsTo:pianoRoll:eventTime:betweenTime:and:)('events' encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: nextSyncEventAfter:inTrack: pauseFrom: resetFrom: resumeFrom:)!