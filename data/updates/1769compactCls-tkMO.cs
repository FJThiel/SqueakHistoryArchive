'From Squeak2.7 of 5 January 2000 [latest update: #1768] on 10 January 2000 at 3:57:03 pm'!"Change Set:		compactCls-tkMODate:			10 January 2000Author:			Ted KaehlerHandles several tricky cases for export ImageSegments (.extSeg files).  If a class in the segment is compact, but is not compact in the importing system.  Introduces new restrictions on compact classes.  Any index may be used only once.  If a class that is compact in a release of Squeak is made uncompact, no other class may use that slot in the compactClassesArray."!!Behavior methodsFor: 'private' stamp: 'tk 12/29/1999 22:04'!becomeCompact	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct index |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'tk 1/10/2000 14:50'!becomeCompactSimplyAt: index	"Make me compact, but don't update the instances.  For importing segments.""Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	(cct at: index) ifNotNil: [^ self halt: 'compact table slot already in use'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Caller must convert the instances"! !!ImageSegment commentStamp: 'tk 1/10/2000 15:52' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  My segment contains outward pointers that are indices into my table of outPointers.	When a segment is written out onto a file, it goes in a folder called <image name>_segs.  If your image is called "Squeak2.6.image", the folder "Squeak2.6_segs" must accompany the image whenever your move, copy, or rename it.	Whenever a Class is in arrayOfRoots, its class (aClass class) must also be in the arrayOfRoots.	There are two kinds of image segments.  Normal image segments are a piece of a specific Squeak image, and can only be read back into that image.  The image holds the array of outPointers that are necessary to turn the bits in the file into objects.	To put out a normal segment that holds a Project (not the current project), execute (Project named: 'xxx') storeSegment.	The second kind of image segment is an Export Segment.  It can be read into a different Squeak image.  To create one:(ImageSegment new copyFromRootsForExport: (Array with: Baz with: Baz class))		writeForExport: 'myFile.extSeg'.To create one for a project:	(Project named: 'Play With Me - 3') exportSegment.To read it into another image:  Select 'myFile.extSeg' in a FileList, Menu 'load as project'.  It will install its classes automatically.  If you need to see the roots array, it is temporarily stored in (SmartRefStream scannedObject).arrayOfRoots	The objects that head the tree we will trace.segment			The WordArray of raw bits of all objects in the tree.outPointers		Oops of all objects outside the segment pointed to from inside.state			(see below)segmentName	Its basic name.  Often the name of a Project.fileName		The local name of the file.  'Foo-23.seg'endMarker		An object located in memory somewhere after a segment that has just been brought in.  To enumerate the objects in the segment, start at the segment and go to this object.state that an ImageSegment may exist in...#activeCopy			(has been copies, with the intent to become active)arrayOfRoots, segment, and outPointers have been created by copyFromRoots:.  The tree of objects has been encoded in the segment, but those objects are still present in the Squeak system.#active				(segment is actively holding objects)The segment is now the only holder of tree of objects.  Each of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only ImageSegmentRootStubs and the array of outPointers remains in the image.  To get this far:(ImageSegment new copyFromRoots: (Array with: Baz with: Baz class))		writeToFile: 'myFile.seg'.#inactiveThe segment has been brought back into memory and turned back into objects.  rootsArray is set, but the segment is invalid.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.	NOTE: All IdentitySets or dictionaries must be rehashed when being read back from this format.  The symbols are effectively internal.  (No, not if read back into same image.  If a different image, then use #imported.  -tk)#importedThe segment is on an external file or just read in from one.  The segment and outPointers are meant to be read into a foreign image.   In this form, the image segment can be read from a URL, and installed.  A copy of the original array of root objects is constructed, with former outPointers bound to existing objects in the host system.  	(Any Class inside the segment MUST be in the arrayOfRoots.  This is so its association can be inserted into Smalltalk.  The class's metaclass must be in roots also.  Methods that are in outPointers because blocks point at them, were found and added to the roots.	All IdentitySets and dictionaries are rehashed when being read back from exported segments.) To discover why only some of the objects in a project are being written out, try this (***Destructive Test***).  This breaks lots of backpointers in the target project, and puts up an array of suspicious objects, a list of the classes of the outPointers, and a debugger."Close any transcripts in the target project"World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].PV _ Project named: 'xxxx'.(IS _ ImageSegment new) findRogueRootsImSeg: 	(Array with: PV world presenter with: PV world).IS findOwnersOutPtrs.	"Optionally: write a file with owner chains""Quit and DO NOT save"!!ImageSegment reorganize!('access' allObjectsDo: arrayOfRoots arrayOfRoots: outPointers segment state)('read/write segment' copyFromRoots:sizeHint: copyFromRootsForExport: copyFromRootsLocalFileFor:sizeHint: extract extractThenInstall install localName readFromFile revert rootsIncludingBlockMethods rootsIncludingPlayers segmentCopy segmentName segmentName: writeForExport: writeToFile writeToFile: writeToFileWithSymbols writeToFileWithSymbols:)('primitives' loadSegmentFrom:outPointers: storeSegmentFor:into:outPointers:)('testing' deepCopyTest: errorWrongState findInOut: findOwnerMap: findOwnersOutPtrs findRogueRootsAllMorphs: findRogueRootsImSeg: findRogueRootsPrep findRogueRootsRefStrm: isOnFile verify:matches:knowing: verifyCopy)('fileIn/Out' comeFullyUpOnReload: declare: prepareToBeSaved rehashSets storeDataOn:)('instance change shape' allInstancesOf:do: ifOutPointer:thenAllObjectsDo: segUpdateInstancesOf:toBe:isMeta:)('compact classes' aComment cc:new:current:fake:refStrm: compactClassesArray compactIndexAt: objectAfter: remapCompactClasses:refStrm:)!!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/22/1999 11:21'!copyFromRoots: aRootArray sizeHint: segSizeHint	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet |	aRootArray ifNil: [self errorWrongState].	rootSet _ IdentitySet new: 150.	rootSet addAll: aRootArray.	arrayOfRoots _ rootSet asArray.	rootSet _ nil.	"be clean"	arrayOfRoots do: [:aRoot | (aRoot respondsTo: #indexIfCompact) ifTrue: [		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].		aRoot _ nil].	"clean up"	outPointers _ nil.	"may have used this instance before"	segSize _ segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	endMarker _ 'End' clone.	"for enumeration of objects"	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/22/1999 11:20'!copyFromRootsForExport: rootArray 	"Add to roots:  Any methods pointed to from the outside by blocks."	| newRoots list |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	(newRoots _ self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	Smalltalk garbageCollect.	"get contexts with Players"	[self copyFromRoots: arrayOfRoots sizeHint: 0.	(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"do over to include methods pointed at by blocks"	list _ self compactClassesArray.	outPointers _ outPointers, (list select: [:cls | cls ~~ nil]),		(Array with: 1717 with: list).! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 1/10/2000 15:36'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ 'End' clone.	"for enumeration of objects"	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	self rehashSets.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [			Project allInstancesDo: [:pp | pp ~~ aRoot ifTrue: [				pp name = aRoot name ifTrue: [					aRoot projectChangeSet name: ChangeSet defaultName]]]].		aRoot class class == Metaclass ifTrue: [			self declare: aRoot]].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'instance change shape' stamp: 'tk 12/21/1999 21:38'!segUpdateInstancesOf: oldClass toBe: newClass isMeta: isMeta	| withSymbols oldInstances segSize |	"Bring me in, locate instances of oldClass and get them converted.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols _ state = #onFileWithSymbols.	"If has instances, they point out at the class"	(outPointers includes: oldClass) ifFalse: [		oldClass == SmallInteger ifTrue: [^ self].	"instance not changable"		oldClass == Symbol ifTrue: [^ self].	"instance is never in a segment"		(Smalltalk compactClassesArray includes: oldClass) ifFalse: [^ self]].		"For a compact class, must search the segment.  Instance does not 		 point outward to class"	Cursor read showWhile: [		state = #onFile ifTrue: [self readFromFile.			endMarker _ 'End' clone]].	"for enumeration of objects"	segSize _ segment size.	self install.	oldInstances _ OrderedCollection new.	self allObjectsDo: [:obj | obj class == oldClass ifTrue: [		oldInstances add: obj]].	newClass updateInstances: oldInstances asArray from: oldClass isMeta: isMeta.	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 1/8/2000 17:39'!aComment	"Compact classes are a potential problem because a pointer to the class would not ordinarily show up in the outPointers.  We add the classes of all compact classes to outPointers, both for local and export segments.	Compact classes are never allowed as roots.  No compact class may be in an Environment that is written out to disk.  (In local segments, the compact classes array should never have an ImageSegmentRootStub in it.  For export, fileIn the class first, then load a segment with instances of it.  The fileIn code can be pasted onto the front of the .extSeg file) 	For local segments, a class may become compact while its instances are out on the disk.  Or it may become un-compact.  A compact class may change shape while some of its instances are on disk.  All three cases go through (ClassDescription updateInstancesFrom:).  If it can't rule out an instance being in the segment, it reads it in to fix the instances.  	See Behavior.becomeCompact for the rules on Compact classes.  Indexes may not be reused.  This is so that an incoming export segment has its index available.  (Changes may be needed in the way indexes are assigned.)	For export segments, a compact class may have a different shape.  The normal class reshape mechanism will catch this.  During the installation of the segment, objects will have the wrong version of their class momentarily.  We will change them back before we get caught.	For export segments, the last two items in outPointers are the number 1717 and an array of the compact classes used in this segment.  (The classes in the array are converted from DiskProxies by SmartRefStream.)  If that class is not compact in the new image, the instances are recopied.	"!]style[(8 275 5 1435)f1b,f1,f3,f1! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 1/10/2000 14:51'!cc: ind new: inTheSeg current: inTheImage fake: fakeCls refStrm: smartRefStream	"Sort out all the cases and decide what to do.  Every Fake class is uncompacted before having insts converted.  As the segment is installed, instances of reshaped compact classes will have the wrong class.  Trouble cases:	1) Existing class is compact in the segment and not compact here.  Make that compact, (error if that slot is used), load the segment.  If an class was just filed in, it is an existing class as far as we are concerned.	2) A compact class has a different shape.  We created a Fake class.  Load the segment, with instances in the seg having the Wrong Class!!!!  Find the bad instancees, and copy them over to being the real class.	3) An existing class is not compact in the segment, but is in the image.  Just let the new instance be uncompact.  That is OK, and never reaches this code.	A class that is a root in this segment cannot be compact.  That is not allowed."	(inTheImage == nil) & (fakeCls == nil) ifTrue: ["case 1 and empty slot" 		inTheSeg becomeCompactSimplyAt: ind.  ^ true].		(inTheImage == inTheSeg) & (fakeCls == nil) ifTrue: ["everything matches" 		^ true].	inTheImage ifNil: ["reshaped and is an empty slot"		fakeCls becomeCompactSimplyAt: ind.  ^ true].		"comeFullyUpOnReload: will clean up"	"Is the image class really the class we are expecting?  inTheSeg came in as a DiskProxy, and was mapped if it was renamed!!"	inTheImage == inTheSeg ifFalse: [		self inform: 'The incoming class ', inTheSeg name, ' wants compact class \location ', ind printString, ', but that is occupied by ', inTheImage name, '.  \This file cannot be read into this system.  The author of the file \should make the class uncompact and create the file again.' withCRs.		^ false].	"Instances of fakeCls think they are compact, and thus will say they are instances of the class inTheImage, which is a different shape.  Just allow this to happen.  Collect them and remap them as soon as the segment is installed."	^ true! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 12/21/1999 21:45'!compactClassesArray	| ccIndexes ind ccArray |	"A copy of the real compactClassesArray, but with only the classes actually used in the segment.  Slow, but OK for export."	ccIndexes _ Set new.	ind _ 2.	[ccIndexes add: (self compactIndexAt: ind).	"0 if has class field"	 ind _ self objectAfter: ind.	 ind > segment size] whileFalse.	ccArray _ Smalltalk compactClassesArray clone.	1 to: ccArray size do: [:ii | "only the ones we use"		(ccIndexes includes: ii) ifFalse: [ccArray at: ii put: nil]].	^ ccArray! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 12/21/1999 21:53'!compactIndexAt: ind	| word |	"Look in this header word in the segment and find it's compact class index. *** Warning: When class ObjectMemory change, be sure to change it here. *** "	((word _ segment at: ind) bitAnd: 3) = 2 ifTrue: [^ 0].  "free block"	^ (word >> 12) bitAnd: 16r1F 	"Compact Class field of header word"! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 1/4/2000 19:22'!objectAfter: ind	"Return the object or free chunk immediately following the given object or free chunk in the segment.  *** Warning: When class ObjectMemory change, be sure to change it here. ***"	| sz word newInd hdrBits |	sz _ ((word _ segment at: ind "header") bitAnd: 3) = 2   "free block?"		ifTrue: [word bitAnd: 16rFFFFFFFC]		ifFalse: [(word bitAnd: 3) = 0 "HeaderTypeSizeAndClass"			ifTrue: [(segment at: ind-2) bitAnd: 16rFFFFFFFC]			ifFalse: [word bitAnd: "SizeMask" 252]].	newInd _ ind + (sz>>2).	"adjust past extra header words"	(hdrBits _ (segment atPin: newInd) bitAnd: 3) = 3 ifTrue: [^ newInd].		"If at end, header word will be garbage.  This is OK"	hdrBits = 1 ifTrue: [^ newInd+1].	hdrBits = 0 ifTrue: [^ newInd+3].	^ newInd	"free"! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 1/10/2000 12:05'!remapCompactClasses: mapFakeClassesToReal refStrm: smartRefStream	| ccArray current fake info |	"See if our compact classes are compatible with this system.  Convert to what the system already has.  If we are adding a new class, it has already been filed in.  A compact class may not be a root."	(outPointers at: (outPointers size - 1)) = 1717 ifFalse: [^ self].	ccArray _ outPointers last.	current _ Smalltalk compactClassesArray.	1 to: ccArray size do: [:ind | 		(ccArray at: ind) ifNotNil: ["is compact in the segment"			fake _ mapFakeClassesToReal keyAtValue: (current at: ind) ifAbsent: [nil].			info _ self cc: ind new: (ccArray at: ind) current: (current at: ind) 					fake: fake refStrm: smartRefStream.			info ifFalse: [^ false]]].	^ true! !Behavior removeSelector: #becomeCompactSimply!