'From Squeak2.6 of 11 October 1999 [latest update: #1575] on 28 October 1999 at 3:11:24 pm'!"Change Set:		FlexTweaks2Date:			28 October 1999Author:			Dan IngallsTwo fixes for flexing of SystemWindows:Causes both collapse point and fullFrame point to be properly tracked.Defeats fast drag and fast reframe when flexed, as these dont' work right then."!!SystemWindow methodsFor: 'geometry' stamp: 'di 10/28/1999 13:51'!extent: newExtent	| inner labelRect |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: self paneColorToUse.	closeBox ifNotNil:		[closeBox align: closeBox topLeft with: inner topLeft + (4@0)].	menuBox ifNotNil:		[menuBox align: menuBox topLeft with: (inner topLeft + (19@1))].	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - self labelWidgetAllowance).	label align: label bounds topCenter with: inner topCenter.	isCollapsed ifFalse: [self setBoundsOfPaneMorphs].! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/28/1999 13:15'!isFlexed	^ owner isKindOf: TransformationMorph! !!SystemWindow methodsFor: 'open/close' stamp: 'di 10/28/1999 13:15'!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^ self].	model okToChange ifFalse: [^ self].	thisWorld _ self world.	sketchEditor _ self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model _ nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		thisWorld notNil ifTrue:			[(aPaintBox _ thisWorld paintBoxOrNil) ifNotNil: [aPaintBox delete]]].			SystemWindow noteTopWindowIn: thisWorld.! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/28/1999 15:10'!collapseOrExpand	isCollapsed	ifTrue:		["Expand -- restore panes to morphics structure"		isCollapsed _ false.		collapsedFrame _ self getBoundsWithFlex.  "First save latest collapsedFrame"		self setBoundsWithFlex: fullFrame.		paneMorphs reverseDo: [:m | 			self addMorph: m.			self world startSteppingSubmorphsOf: m].		self activate "-- mainly for findWindow"]	ifFalse:		["Collapse -- remove panes from morphics structure"		isCollapsed _ true.		fullFrame _ self getBoundsWithFlex.  "First save latest fullFrame"		paneMorphs do: [:m | m delete; releaseCachedState].		model modelSleep.		collapsedFrame ifNil:			[collapsedFrame _ (RealEstateAgent assignCollapsePointFor: self)						 extent: (label width + self labelWidgetAllowance) @ (self labelHeight + 2)].		self setBoundsWithFlex: collapsedFrame].	self layoutChanged! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/28/1999 13:21'!fastFramingOn	^ Preferences fastDragWindowForMorphic and: [self isFlexed not]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/28/1999 14:14'!getBoundsWithFlex	"Return the lastest bounds rectangle with origin forced to global coordinates"	self isFlexed		ifTrue: [^ ((owner transform localPointToGlobal: bounds topLeft)										extent: bounds extent)]		ifFalse: [^ self bounds].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/28/1999 14:15'!setBoundsWithFlex: newFrame	"Set bounds from newFrame with origin preserved from global coordinates"	self isFlexed		ifTrue: [super bounds: ((owner transform globalPointToLocal: newFrame topLeft)										extent: newFrame extent)]		ifFalse: [super bounds: newFrame].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/28/1999 13:23'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds vbtl adjoiningPanes limit |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	vbtl _ self world viewBox topLeft.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ (growingPane bounds translateBy: vbtl)					 newRectFrom:					[:f | (growingPane bounds translateBy: vbtl) withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: (newBounds translateBy: vbtl negated)]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/28/1999 13:23'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds vbtl |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	vbtl _ self world viewBox topLeft.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds withSideOrCorner: ptName setToPoint: localPt minExtent: 100@80.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ (self bounds translateBy: vbtl) newRectFrom:					[:f | f withSideOrCorner: ptName							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 100@80].				self bounds: (newBounds translateBy: vbtl negated)]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'events' stamp: 'di 10/28/1999 13:22'!handlesMouseDown: evt	"If I am not the topWindow, then I will only respond to dragging by the title bar.	Any other click will only bring me to the top"	(self fastFramingOn 		and: [self labelRect containsPoint: evt cursorPoint])		ifTrue: [^ true].	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'di 10/28/1999 13:22'!mouseDown: evt	| cp offset newBounds vbtl |	TopWindow == self ifFalse: [self activate].	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		["All copied from super (should use that code)"		self fastFramingOn 			ifTrue: [vbtl _ self world viewBox topLeft.					offset _ self position + vbtl - Sensor cursorPoint.					newBounds _ (self bounds translateBy: vbtl)						newRectFrom: [:f | Sensor cursorPoint + offset extent: self extent].					^ self position: newBounds topLeft - vbtl]			ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !SystemWindow removeSelector: #fastFraming!