'From Squeak2.9alpha of 13 June 2000 [latest update: #3299] on 2 February 2001 at 1:04:02 pm'!StringHolder subclass: #ColumnsTester	instanceVariableNames: 'mainIndex listMorph theList smallTest '	classVariableNames: ''	poolDictionaries: ''	category: 'sbw-experiments'!!ColumnsTester commentStamp: '<historical>' prior: 0!A lot of code in here was cloned from ChatNotes.This class is a tester for the PluggableMultiColumnListMorph.See the instance method #listArray for two ways you can exercise this widget.To use it just evaluate the #test class method.!PluggableListMorph subclass: #PluggableMultiColumnListMorph	instanceVariableNames: 'lists selectedIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableMultiColumnListMorph commentStamp: '<historical>' prior: 0!This morph can be used to show a list having multiple columns,  The columns are self width sized to make the largest entry in each list fit.  In some cases the pane may then be too narrow.Use it like a regular PluggableListMorph except pass in an array of lists instead of a single list.There are base assumptions made here that each list in the array of lists is the same size.Also, the highlight color for the selection is easy to modify in the #highlightSelection method.  I used bluewhen testing just to see it work.!PluggableMultiColumnListMorph subclass: #PluggableMultiColumnListMorphByItem	instanceVariableNames: 'itemList '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:17'!addToTestList	| entry |	entry _ self queryForNewEntry.	entry isNil		ifTrue: [^ nil].	1 to: entry size do: [:index |		(theList at: index) add: (entry at: index)].	self changed: #listArray! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:18'!bigList	^ Array		with: Smalltalk classNames asOrderedCollection		with: Smalltalk classNames reversed asOrderedCollection		with: Smalltalk classNames asSet asArray asOrderedCollection		with: (Smalltalk classNames				collect: [:each | each size printString]) asOrderedCollection! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 11/30/2000 22:14'!defaultBackgroundColor	"In a better design, this would be handled by preferences."	^ Color		r: 1.0		g: 0.9		b: 0.8! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 11/30/2000 22:15'!initialExtent	^ 300 @ 200! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:01'!inspectList	theList inspect! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:01'!inspectListMorph	listMorph inspect! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:02'!inspectMe	self inspect! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:01'!listArray	"Use #bigList here for a large four column list amd #smallList for a  	short three column test."	theList == nil ifTrue: [self populateInitialList].	^ theList! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:02'!listMenu: aMenu 	^ aMenu		labels: 'addremoveinspect meinspect listinspect list morph'		lines: #(2 )		selections: #(#addToTestList #removeFromTestList #inspectMe #inspectList inspectListMorph)! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 12/25/2000 22:29'!mainList	^ #('One' 'Two' 'Three Little Pigs Went To Market' 'Fourteen' 'Linux')! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 11/30/2000 22:21'!mainListIndex	mainIndex == nil ifTrue: [mainIndex _ 0].	^mainIndex! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 11/30/2000 22:23'!mainListIndex: index 	mainIndex _ index.	self changed: #mainListIndex! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 12/25/2000 22:29'!minorList	^ #(1.2 3.4 5.6 7.8 0.006)		collect: [:n | n printString]! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 06:56'!openAsMorph	| window |	window _ (SystemWindow labelled: 'Columns Tester')				model: self.	listMorph _ PluggableMultiColumnListMorph				on: self				list: #listArray				selected: #mainListIndex				changeSelected: #mainListIndex:				menu: #listMenu:.	window		addMorph: (listMorph				autoDeselect: false)		frame: (0 @ 0 corner: 1.0 @ 1.0).	window openInWorld! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:25'!populateInitialList	"Use #bigList here for a large four column list amd #smallList for a  	short three column test."	smallTest == nil ifTrue: [smallTest _ true].	theList _ (smallTest				ifTrue: [self smallList]				ifFalse: [self bigList]) asOrderedCollection! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:06'!queryColumnEntry: column default: defaultString	^FillInTheBlank		request: 'New entry for column ', column printString, '?'		initialAnswer: defaultString! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:10'!queryForNewEntry	| array entry |	array _ Array new: theList size.	1 to: array size do: [:column |		entry _ self queryColumnEntry: column default: column printString.		entry isEmpty ifTrue: [^nil].		array at: column put: entry].	^array! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 2/1/2001 10:59'!removeFromTestList	mainIndex = 0		ifTrue: [^ self].	(self confirm: 'Really delete row ' , mainIndex printString , '?')		ifFalse: [^ self].	1		to: theList size		do: [:index | (theList at: index)				removeAt: mainIndex].	self changed: #listArray.	self mainListIndex: 0! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 12/25/2000 22:29'!secondList	^ #('aaaa' 'bbbb' 'cccc' 'dddd' 'linux')! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:22'!setBigTest	smallTest _ false! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:21'!setSmallTest	smallTest _ true! !!ColumnsTester methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:18'!smallList	^ Array		with: self mainList asOrderedCollection		with: self secondList asOrderedCollection		with: self minorList asOrderedCollection! !!ColumnsTester class methodsFor: 'as yet unclassified' stamp: 'sbw 11/30/2000 22:13'!openAsMorph	^ self new openAsMorph! !!ColumnsTester class methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:24'!test	"(Smalltalk at: #ColumnsTester) test"	self testSmall! !!ColumnsTester class methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:23'!testBig	"(Smalltalk at: #ColumnsTester) testBig"	| model |	model _ self new.	model setBigTest.	model openAsMorph! !!ColumnsTester class methodsFor: 'as yet unclassified' stamp: 'sbw 1/31/2001 07:23'!testSmall	"(Smalltalk at: #ColumnsTester) testSmall"	| model |	model _ self new.	model setSmallTest.	model openAsMorph! !!PluggableListMorph methodsFor: 'drawing' stamp: 'sbw 12/1/2000 12:12'!superDrawOn: aCanvas 	super drawOn: aCanvas.! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/2/2000 08:37'!calculateColumnOffsetsFrom: maxWidths	| offsets previous current |	offsets _ Array new: maxWidths size.	1		to: offsets size		do: [:indx | offsets at: indx put: (maxWidths at: indx)					+ 10].	2		to: offsets size		do: [:indx | 			previous _ offsets at: indx - 1.			current _ offsets at: indx.			current _ previous + current.			offsets at: indx put: current].	^offsets! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/2/2000 08:36'!calculateColumnWidthsFrom: arrayOfMorphs 	| maxWidths |	maxWidths _ Array new: arrayOfMorphs size - 1.	1		to: maxWidths size		do: [:idx | maxWidths at: idx put: 0].	1		to: maxWidths size		do: [:idx | (arrayOfMorphs at: idx)				do: [:mitem | mitem width							> (maxWidths at: idx)						ifTrue: [maxWidths at: idx put: mitem width]]].	^maxWidths! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/1/2000 13:44'!createMorphicListsFrom: arrayOfLists 	| array |	font		ifNil: [font _ Preferences standardListFont].	array _ Array new: arrayOfLists size.	1 to: arrayOfLists size do: [:arrayIndex |		array at: arrayIndex put: (			(arrayOfLists at: arrayIndex) collect: [:item | item isText						ifTrue: [StringMorph								contents: item								font: font								emphasis: (item emphasisAt: 1)]						ifFalse: [StringMorph contents: item font: font]])		].	^array! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/2/2000 08:38'!layoutMorphicLists: arrayOfMorphs 	| maxWidths offsets locs h |	maxWidths _ self calculateColumnWidthsFrom: arrayOfMorphs.	offsets _ self calculateColumnOffsetsFrom: maxWidths.	locs _ Array new: arrayOfMorphs size.	locs at: 1 put: 0 @ 0.	2		to: locs size		do: [:indx | locs at: indx put: (offsets at: indx - 1)					@ 0].	h _ arrayOfMorphs first first height.	1		to: arrayOfMorphs size		do: [:indx | (arrayOfMorphs at: indx)				do: [:morphItem | 					morphItem						bounds: ((locs at: indx)								extent: 9999 @ h).					locs at: indx put: (locs at: indx)							+ (0 @ h)]]! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/4/2000 20:28'!list: arrayOfLists 	| listOfStrings arrayOfMorphs index |	lists _ arrayOfLists.	scroller removeAllMorphs.	listOfStrings _ arrayOfLists == nil				ifTrue: [Array new]				ifFalse: [					arrayOfLists isEmpty ifFalse: [					arrayOfLists at: 1]].	list _ listOfStrings				ifNil: [Array new].	list isEmpty		ifTrue: [self setScrollDeltas.			^ self selectedMorph: nil].	arrayOfMorphs _ self createMorphicListsFrom: arrayOfLists.	self layoutMorphicLists: arrayOfMorphs.	arrayOfMorphs		do: [:morphList | scroller addAllMorphs: morphList].	self		installEventHandlerOn: (arrayOfMorphs at: 1).	index _ self getCurrentSelectionIndex.	self		selectedMorph: ((index = 0					or: [index > (arrayOfMorphs at: 1) size])				ifFalse: [(arrayOfMorphs at: 1)						at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0! !!PluggableMultiColumnListMorph methodsFor: 'drawing' stamp: 'sbw 12/2/2000 08:41'!drawOn: aCanvas 	"Only modification here is to bypass the #drawOn: method in our superclass."	super superDrawOn: aCanvas.	selectedMorph		ifNotNil: [aCanvas				fillRectangle: (((scroller transformFrom: self)						localBoundsToGlobal: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableMultiColumnListMorph methodsFor: 'selection' stamp: 'sbw 2/1/2001 12:17'!highlightSelection	| highlightColor columnLength localIndex m properSelectedIndex |	highlightColor _ Color red.	"<-- Change the highlight color here."	selectedMorph		ifNotNil: [selectedMorph color: highlightColor;				 changed.			properSelectedIndex _ scroller submorphs						findFirst: [:mp | mp contents = selectedMorph contents].			selectedIndex = properSelectedIndex ifFalse: [selectedIndex _ properSelectedIndex].			columnLength _ lists first size.			2				to: lists size				do: [:columnIndex | 					localIndex _ selectedIndex + (columnLength * (columnIndex - 1)).					m _ scroller submorphs asArray at: localIndex.					m color: highlightColor;						 changed]]! !!PluggableMultiColumnListMorph methodsFor: 'selection' stamp: 'sbw 2/1/2001 12:14'!selectionIndex: index 	"Called internally to select the index-th item."	| theMorph range |	(index isNil			or: [index > scroller submorphs size])		ifTrue: [^ self].	(theMorph _ index = 0				ifFalse: [scroller submorphs at: index])		ifNotNil: [(theMorph bounds top - scroller offset y >= 0					and: [theMorph bounds bottom - scroller offset y <= bounds height])				ifFalse: ["Scroll into view -- should be elsewhere"					range _ self leftoverScrollRange.					scrollBar						value: (range > 0								ifTrue: [index - 1 * theMorph height / self leftoverScrollRange truncateTo: scrollBar scrollDelta]								ifFalse: [0]).					scroller offset: -3 @ (range * scrollBar value)]].	"Save the selection index to make it easy to do the highlighting work  	later."	selectedIndex _ index.	self selectedMorph: theMorph! !!PluggableMultiColumnListMorph methodsFor: 'selection' stamp: 'sbw 1/21/2001 19:41'!unhighlightSelection	| unhighlightColor columnLength localIndex m previousSelectedIndex |	unhighlightColor _ Color black.	selectedMorph		ifNotNil: [selectedMorph color: unhighlightColor;				 changed.			previousSelectedIndex _ scroller submorphs						findFirst: [:mp | mp contents = selectedMorph contents].			columnLength _ lists first size.			2				to: lists size				do: [:columnIndex | 					localIndex _ previousSelectedIndex + (columnLength * (columnIndex - 1)).					localIndex = 0 ifFalse: [						m _ scroller submorphs asArray at: localIndex.						m color: unhighlightColor;						 	changed]]]!]style[(20 3 65 4 16 3 5 9 13 14 13 8 16 19 21 3 8 29 4 2 2 12 13 15 12 3 5 16 1 9 5 15 13 8 10 3 21 4 12 4 11 3 1 41 1 3 8 23 10 8 1 8 16 20)f1b,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1! !!PluggableMultiColumnListMorphByItem methodsFor: 'as yet unclassified' stamp: 'sbw 12/25/2000 21:30'!changeModelSelection: anInteger 	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector		ifNotNil: [item _ anInteger = 0						ifFalse: [itemList at: anInteger].			model perform: setIndexSelector with: item].	self update: getIndexSelector! !!PluggableMultiColumnListMorphByItem methodsFor: 'as yet unclassified' stamp: 'sbw 2/1/2001 12:15'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector == nil		ifTrue: [^ 0].	item _ model perform: getIndexSelector.	^ itemList		findFirst: [:x | x = item]! !!PluggableMultiColumnListMorphByItem methodsFor: 'as yet unclassified' stamp: 'sbw 12/25/2000 20:52'!list: arrayOfStrings 	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.  	The instance variable 'list' is a paragraph constructed from  	this list."	itemList _ arrayOfStrings first.	^ super list: arrayOfStrings! !!PluggableMultiColumnListMorph reorganize!('initialization' calculateColumnOffsetsFrom: calculateColumnWidthsFrom: createMorphicListsFrom: layoutMorphicLists: list:)('drawing' drawOn:)('selection' highlightSelection selectionIndex: unhighlightSelection)!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."!