'From Squeak2.9alpha of 13 June 2000 [latest update: #2879] on 22 October 2000 at 5:49:50 pm'!"Change Set:		MorphicSteps-arDate:			22 October 2000Author:			Andreas RaabThe change set modifies stepping in Morphic in various ways. First of all, the stepList has been reorganized from an OrderedCollection of Arrays to a Heap of StepMessages. Since insertion  and removal are O(log n) operations in Heaps it allows for a very efficient safety feature in step lists. All morphs currently stepped are temporarily taken out of the step list so that an error during step handling will automatically stop the morph from stepping.StepMessages also allow a much more general way of handling step messages. The most important part is that a morph can have several different step methods running at once since selector (and optional arguments) can be specified. The main entry for stepping morphs is in Morph>>startStepping:at:arguments:stepTime:. If no explicit step time is given the morph itself will be queried for the #stepTime to allow for dynamic changes of the step frequency.Finally, the issue of #mouseStillDown: has been tackled. #mouseStillDown: is now send by step messages with either the last #mouseDown: or #mouseMove: event. A morph wanting to receive #mouseStillDown: needs to return true in #handlesMouseStillDown: and to return a #mouseStillDownStepTime for specifying the frequency for those repeated events. WARNING: Making the frequency very small (e.g., 1ms) makes it IMPOSSIBLE to get exactly one mouse still down event on a reasonably fast machine.Known problems: As so often, the event handler aliases (the completely different) notions of #mouseMove: and #mouseStillDown: leading to huge inefficiencies for clients not interested in #mouseStillDown. Sigh. I'm too tired to fix it up right now."!MessageSend subclass: #MorphicAlarm	instanceVariableNames: 'scheduledTime numArgs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!MorphicAlarm subclass: #StepMessage	instanceVariableNames: 'stepTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime commandHistory alarms lastAlarmTime lastStepMessage '	classVariableNames: 'CanSurrenderToOS DeferredUIMessages DisableDeferredUpdates LastCycleTime MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Worlds'!!EventHandler methodsFor: 'testing' stamp: 'ar 10/22/2000 17:05'!handlesMouseStillDown: evt	^mouseStillDownRecipient notNil and:[mouseStillDownSelector notNil]! !!Morph methodsFor: 'event handling' stamp: 'ar 10/22/2000 17:06'!handlesMouseStillDown: evt	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"	self eventHandler ifNotNil: [^ self eventHandler handlesMouseStillDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'ar 10/22/2000 17:08'!mouseStillDown: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'ar 10/22/2000 17:20'!mouseStillDownStepTime	"Return the number of milliseconds for two consecutive #mouseStillDown: events."	^self stepTime! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:43'!isSteppingSelector: aSelector	"Return true if the receiver is currently stepping in its world"	| aWorld |	^ (aWorld _ self world)		ifNil:		[false]		ifNotNil:	[aWorld isStepping: self selector: aSelector]! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:37'!startStepping	"Start getting sent the 'step' message."	self step.  "one to get started!!"	self flag: #arNote. "Why the @#$% is the above necessary???"	self startStepping: #stepAt: at: Time millisecondClockValue arguments: nil stepTime: nil.! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:36'!startStepping: aSelector at: scheduledTime arguments: args stepTime: stepTime	"Start stepping the receiver"	| w |	w _ self world.	w ifNotNil: [		w startStepping: self at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.		self changed].! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:42'!startSteppingSelector: aSelector	"Start getting sent the 'step' message."	self startStepping: aSelector at: Time millisecondClockValue arguments: nil stepTime: nil.! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:41'!stopSteppingSelector: aSelector	"Stop getting sent the given message."	| w |	w _ self world.	w ifNotNil: [		w stopStepping: self selector: aSelector.		self changed].! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/22/2000 17:21'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	anEvent controlKeyPressed ifTrue:[^self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepTime].! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/22/2000 17:21'!handleMouseMove: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	"Rules say that by default a morph gets #mouseMove iff		* the hand is not dragging anything,			+ and some button is down,			+ and the receiver is the current mouse focus."	(anEvent hand hasSubmorphs) ifTrue:[^self].	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownStepTime			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepTime].! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/22/2000 17:11'!handleMouseStillDown: anEvent	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"	(anEvent hand mouseFocus == self) 		ifFalse:[^self stopSteppingSelector: #handleMouseStillDown:].	self mouseStillDown: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/22/2000 17:09'!handleMouseUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand mouseFocus == self ifFalse:[^self]. "Not interested in other parties"	anEvent hand releaseMouseFocus: self.	anEvent wasHandled: true.	anEvent blueButtonChanged		ifTrue:[self blueButtonUp: anEvent]		ifFalse:[self mouseUp: anEvent.				self stopSteppingSelector: #handleMouseStillDown:].! !!MorphicAlarm methodsFor: 'evaluating' stamp: 'ar 10/22/2000 17:36'!value: anArgument	| nArgs |	numArgs ifNil:[numArgs _ selector numArgs].	nArgs _ arguments ifNil:[0] ifNotNil:[arguments size].	nArgs = numArgs ifTrue:[		"Ignore extra argument"		^self value].	^arguments isNil		ifTrue: [receiver perform: selector with: anArgument]		ifFalse: [receiver perform: selector withArguments: (arguments copyWith: anArgument)]! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 10/22/2000 16:43'!isStepping: aMorph selector: aSelector	^ worldState isStepping: aMorph selector: aSelector! !!PasteUpMorph methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:39'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	^self startStepping: aMorph at: Time millisecondClockValue selector: #stepAt: arguments: nil stepTime: nil! !!PasteUpMorph methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:36'!startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime	worldState startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.! !!PasteUpMorph methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:40'!stopStepping: aMorph selector: aSelector	"Remove the given morph from the step list."	worldState stopStepping: aMorph selector: aSelector! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 10/22/2000 17:46'!handlesMouseStillDown: evt	^true! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 10/22/2000 17:46'!mouseMove: evt	^self mouseStillDown: evt! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 10/22/2000 17:46'!mouseStillDown: evt	| menu selection |	(self containsPoint: evt cursorPoint) ifFalse: [		self showBorderAs: Color blue.		mouseDownTime _ nil.		^self	].	self showBorderAs: Color red.	mouseDownTime ifNil: [		mouseDownTime _ Time millisecondClockValue.		^self	].	((Time millisecondClockValue - mouseDownTime) > 1100) ifFalse: [^self].					(menu _ CustomMenu new)		add: 'enter this project' action: #enter;		add: 'ENTER ACTIVE' action: #enterAsActiveSubproject;		add: 'save (also saves a local copy)' action: #SERVERSTORE;		add: 'saveAs' action: #NEWSTORE;		add: 'see if server version is more recent' action: #loadFromServer.	selection _ (menu build preSelect: #enter) 		startUpCenteredWithCaption: ('Project Named','"', project name, '"').	selection = #enter ifTrue: [^ self enter].	selection = #enterAsActiveSubproject ifTrue: [		self setProperty: #wasOpenedAsSubproject toValue: true.		^ self enterAsActiveSubproject	].	selection = #SERVERSTORE ifTrue: [^ project storeOnServerShowProgressOn: self].	selection = #NEWSTORE ifTrue: [project urlList: nil. ^ project storeOnServerShowProgressOn: self].	selection = #loadFromServer ifTrue: [ ^ self checkForNewerVersionAndLoad].					! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 10/22/2000 17:46'!mouseStillDownStepTime	^100! !!StepMessage methodsFor: 'accessing' stamp: 'ar 10/22/2000 16:56'!stepTime	"Return the step time for this message. If nil, the receiver of the message will be asked for its #stepTime."	^stepTime! !!StepMessage methodsFor: 'accessing' stamp: 'ar 10/22/2000 16:56'!stepTime: aNumber	"Set the step time for this message. If nil, the receiver of the message will be asked for its #stepTime."	stepTime _ aNumber! !!StepMessage methodsFor: 'printing' stamp: 'ar 10/22/2000 15:59'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: receiver;		space;		print: selector;		space;		print: scheduledTime;		nextPut: $).! !!StepMessage class methodsFor: 'instance creation' stamp: 'ar 10/22/2000 15:48'!scheduledAt: scheduledTime stepTime: stepTime receiver: aTarget selector: aSelector arguments: argArray	^(self receiver: aTarget selector: aSelector arguments: argArray)		scheduledTime: scheduledTime;		stepTime: stepTime! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/22/2000 17:42'!handlesMouseStillDown: evt	^true! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/22/2000 17:43'!mouseMove: evt	^self mouseStillDown: evt! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/22/2000 17:43'!mouseStillDown: evt	| aPoint label |	"See if arrows are being pressed and call arrowAction:..."	self flag: #arNote. "Fix 'significant' events below"	upArrow ifNotNil:		[aPoint _ evt cursorPoint.		(label _ self labelMorph) ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: 1].			^ evt "hand noteSignificantEvent: evt"].		(downArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: -1].			^ evt "hand noteSignificantEvent: evt"]].	super mouseStillDown: evt.! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/22/2000 17:44'!mouseStillDownStepTime	^1! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 10/22/2000 17:41'!handlesMouseStillDown: evt	^true! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 10/22/2000 17:42'!mouseMove: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	^self mouseStillDown: evt! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 10/22/2000 17:42'!mouseStillDown: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	| p label |	self flag: #arNote. "Fix 'significant' events below"	upArrow ifNotNil:		[p _ evt cursorPoint.		self abandonLabelFocus.		label _ self findA: UpdatingStringMorph.		label ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue + 1)].					^ evt "hand noteSignificantEvent: evt"].		(downArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue - 1)].					^ evt "hand noteSignificantEvent: evt"]].	super mouseStillDown: evt.! !!WorldState methodsFor: 'initialization' stamp: 'ar 10/22/2000 16:23'!initialize	hands _ Array new.	damageRecorder_ DamageRecorder new.	stepList _ Heap sortBlock:[:stepMsg1 :stepMsg2| stepMsg1 scheduledTime <= stepMsg2 scheduledTime].	lastStepTime _ 0.	lastAlarmTime _ 0.! !!WorldState methodsFor: 'initialization' stamp: 'ar 10/22/2000 16:04'!stepListSummary	^ String streamContents:		[:aStream |			aStream nextPutAll: stepList size printString, ' items in steplist:'.			stepList do:				[:anElement | aStream nextPutAll: anElement receiver printString]]"Transcript cr show: self currentWorld stepListSummary"! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:23'!adjustWakeupTimes: now	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| deltaTime |	deltaTime _ now - lastStepTime.	stepList do:[:entry| entry scheduledTime: entry scheduledTime + deltaTime].	lastStepTime _ now.! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 15:22'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes: now].  "clock slipped"! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:04'!cleanseStepListForWorld: aWorld	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."	| deletions morphToStep |	stepList do: [:entry |		morphToStep _ entry receiver.		morphToStep world == aWorld ifFalse:[			deletions ifNil: [deletions _ OrderedCollection new].			deletions addLast: entry]].	deletions ifNotNil:[		deletions do: [:entry|			entry receiver stopStepping]].! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:09'!isStepping: aMorph	"Return true if the given morph is in the step list."	lastStepMessage ifNotNil:[(lastStepMessage receiver == aMorph) ifTrue:[^true]].	stepList do:[:entry| entry receiver == aMorph ifTrue:[^true]].	^ false! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:09'!isStepping: aMorph selector: aSelector	"Return true if the given morph is in the step list."	lastStepMessage ifNotNil:[		(lastStepMessage receiver == aMorph and:[lastStepMessage selector == aSelector])			ifTrue:[^true]].	stepList do:[:entry| (entry receiver == aMorph and:[entry selector == aSelector]) ifTrue:[^true]].	^ false! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:05'!listOfSteppingMorphs	^stepList collect:[:entry| entry receiver].! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:08'!runLocalStepMethodsIn: aWorld	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now morphToStep stepTime |	now _ Time millisecondClockValue.	self triggerAlarmsBefore: now.	stepList size = 0 ifTrue: [^ self].	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes: now].  "clock slipped"	[stepList isEmpty not and:[stepList first scheduledTime < now]] whileTrue:[		lastStepMessage _ stepList removeFirst.		morphToStep _ lastStepMessage receiver.		(morphToStep shouldGetStepsFrom: aWorld) ifTrue:[			lastStepMessage value: now.			lastStepMessage ifNotNil:[				stepTime _ lastStepMessage stepTime ifNil:[morphToStep stepTime].				lastStepMessage scheduledTime: now + (stepTime max: 1).				stepList add: lastStepMessage].		].		lastStepMessage _ nil.	].	lastStepTime _ now! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:07'!runStepMethodsIn: aWorld	"Perform periodic activity inbetween event cycles"	| queue |	queue _ self class deferredUIMessages.	[queue isEmpty] whileFalse: [		queue next value	].	self runLocalStepMethodsIn: aWorld.	"we are using a normal #step for these now"	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:36'!startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime	"Add the given morph to the step list. Do nothing if it is already being stepped."	self stopStepping: aMorph selector: aSelector.	self adjustWakeupTimesIfNecessary.	stepList add:(		StepMessage 			scheduledAt: scheduledTime			stepTime: stepTime			receiver: aMorph			selector: aSelector			arguments: args)! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:10'!stopStepping: aMorph	"Remove the given morph from the step list."	lastStepMessage ifNotNil:[		(lastStepMessage receiver == aMorph) ifTrue:[lastStepMessage _ nil]].	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph]).! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:10'!stopStepping: aMorph selector: aSelector	"Remove the given morph from the step list."	lastStepMessage ifNotNil:[		(lastStepMessage receiver == aMorph and:[lastStepMessage selector == aSelector])			ifTrue:[lastStepMessage _ nil]].	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and:[stepMsg selector == aSelector]]).! !!WorldState methodsFor: 'object fileIn' stamp: 'ar 10/22/2000 16:05'!convertStepList	"Convert the old-style step list (an Array of Arrays) into the new-style StepMessage heap"	| newList wakeupTime morphToStep |	(stepList isKindOf: Heap) ifTrue:[^self].	newList _ Heap sortBlock:[:stepMsg1 :stepMsg2| stepMsg1 scheduledTime <= stepMsg2 scheduledTime].	stepList do:[:entry|		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		newList add: (			StepMessage				scheduledAt: wakeupTime				stepTime: nil				receiver: morphToStep				selector: #stepAt:				arguments: nil).	].	stepList _ newList.! !!WorldState methodsFor: 'object fileIn' stamp: 'ar 10/22/2000 16:18'!converthavcdsllcal0: varDict havcdslllcal0: smartRefStrm	"These variables are automatically stored into the new instance #('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'lastCycleTime' 'commandHistory' 'alarms' 'lastAlarmTime').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('lastStepMessage')  If a non-nil value is needed, please assign it."	"Convert the old to new step lists"	self convertStepList.! !!WorldState methodsFor: 'alarms' stamp: 'ar 10/22/2000 16:55'!triggerAlarmsBefore: nowTime	"Trigger all pending alarms that are to be executed before nowTime."	| pending |	lastAlarmTime ifNil:[lastAlarmTime _ nowTime].	(nowTime < lastAlarmTime or:[nowTime - lastAlarmTime > 10000])		ifTrue:[self adjustAlarmTimes: nowTime].	pending _ self alarms.	[pending isEmpty not and:[pending first scheduledTime < nowTime]]		whileTrue:[pending removeFirst value: nowTime].	lastAlarmTime _ nowTime.! !WorldState removeSelector: #adjustWakeupTimes!WorldState removeSelector: #startStepping:!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime commandHistory alarms lastAlarmTime '	classVariableNames: 'CanSurrenderToOS DeferredUIMessages DisableDeferredUpdates LastCycleTime MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Worlds'!"Postscript:Convert all old step lists"WorldState allSubInstancesDo:[:ws| ws convertStepList].!