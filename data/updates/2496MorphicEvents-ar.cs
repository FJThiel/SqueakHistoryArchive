'From Squeak2.9alpha of 12 June 2000 [latest update: #2467] on 31 July 2000 at 11:37:40 pm'!"Change Set:		MorphicEvents-arDate:			30 July 2000Author:			Andreas RaabModifications of Morphic to use EventSensor in the way it's supposed to be. Or at least partly since we still have to be backward compatible here..."Sensor class == EventSensor ifFalse:[	^self error:'EventSensor must be installed'.].!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!Object subclass: #MorphicEvent	instanceVariableNames: 'type cursorPoint buttons keyValue sourceHand '	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Support'!!EventSensor methodsFor: 'accessing' stamp: 'ar 7/30/2000 15:50'!nextEvent	"Return the next event from the receiver."	eventQueue == nil 		ifTrue:[^self nextEventSynthesized]		ifFalse:[^self nextEventFromQueue]! !!EventSensor methodsFor: 'accessing' stamp: 'ar 7/30/2000 15:52'!nextEventFromQueue	"Return the next event from the receiver."	eventQueue isEmpty		ifTrue:[^nil]		ifFalse:[^eventQueue next]! !!EventSensor methodsFor: 'accessing' stamp: 'ar 7/31/2000 21:43'!nextEventSynthesized	"Return a synthesized event. This method is called if an event driven client wants to receive events but the primary user interface is not event-driven (e.g., the receiver does not have an event queue but only updates its state). This can, for instance, happen if a Morphic World is run in an MVC window. To simplify the clients work this method will always return all available keyboard events first, and then (repeatedly) the mouse events. Since mouse events come last, the client can assume that after one mouse event has been received there are no more to come. Note that it is impossible for EventSensor to determine if a mouse event has been issued before so the client must be aware of the possible problem of getting repeatedly the same mouse events. See HandMorph>>processEvents for an example on how to deal with this."	| kbd array buttons pos modifiers mapped |	"First check for keyboard"	array _ Array new: 8.	kbd _ self primKbdNext.	kbd = nil ifFalse:[		"simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^array].	"Then check for mouse"	buttons _ self primMouseButtons.	pos _ self primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	mapped = buttons ifFalse:[modifiers _ 0].	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.	^array! !!HandMorph methodsFor: 'event handling' stamp: 'ar 7/31/2000 23:37'!processEvents	"Process user input events from the local input devices.	Note: Ugly as it is, several places in Morphic currently rely on sending at least one mouse event per cycle. There's no way around this so we're checking if the first event is a mouse event and if not, we synthesize one.	Another interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt currentExtent evtBuf type hadMouse |	hadMouse _ false. "see first note above"	[evtBuf _ Sensor nextEvent.	evtBuf isNil and:[hadMouse]] whileFalse:[		evtBuf == nil ifTrue:[			"Make us a fake mouse event so hadMouse will be true"			evtBuf _ Array with: EventTypeMouse							with: Time millisecondClockValue							with: lastEvent cursorPoint x							with: lastEvent cursorPoint y							with: (lastEvent buttons bitAnd: 7)							with: (lastEvent buttons bitShift: 3)].		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		type = EventTypeMouse ifTrue:[			hadMouse _ true.			evt _ MorphicEvent new				setMousePoint: (self griddedPoint: (evtBuf at: 3) @ (evtBuf at: 4))				buttons: (evtBuf at: 5)				modifiers: (evtBuf at: 6)				lastEvent: lastEvent				hand: self].		(type = EventTypeKeyboard) ifTrue:[			evt _ MorphicEvent new				setKeyValue: (evtBuf at: 3)				type: (evtBuf at: 4)				mousePoint: (self griddedPoint: self position)				modifiers: (evtBuf at: 5)				hand: self].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				lastWorldExtent _ currentExtent].			self transmitEvent: evt].		"Finally, handle it"		self handleEvent: evt.		"See the note on running a World in MVC in the method comment"		(hadMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].	].! !!HandMorph methodsFor: 'private' stamp: 'ar 7/30/2000 15:58'!griddedPoint: aPoint	| griddedPoint |	griddedPoint _ aPoint "- owner viewBox topLeft".	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	^griddedPoint! !!MorphicEvent methodsFor: 'private' stamp: 'ar 7/30/2000 16:17'!setKeyValue: keyVal type: pressType mousePoint: aPoint modifiers: anInteger hand: hand	pressType = EventKeyDown ifTrue:[type _ #keyDown].	pressType = EventKeyUp ifTrue:[type _ #keyUp].	pressType = EventKeyChar ifTrue:[type _ #keystroke].	cursorPoint _ aPoint.	buttons _ anInteger bitShift: 3.	keyValue _ keyVal.	sourceHand _ hand.! !!MorphicEvent methodsFor: 'private' stamp: 'ar 7/30/2000 16:15'!setMousePoint: aPoint buttons: anInteger modifiers: modifiers lastEvent: lastEvent hand: hand	cursorPoint _ aPoint.	buttons _ anInteger bitOr: (modifiers bitShift: 3).	keyValue _ 0.	sourceHand _ hand.	self anyButtonPressed ifTrue: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseMove]			ifFalse: [type _ #mouseDown].	] ifFalse: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseUp]			ifFalse: [type _ #mouseMove]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 7/30/2000 16:32'!install	owner _ nil.	"since we may have been inside another world previously"	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	self viewBox: Display boundingBox.	Sensor eventQueue: SharedQueue new.	worldState handsDo: [:h | h initForEvents].	self installFlaps.	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!Project methodsFor: 'menu messages' stamp: 'ar 7/30/2000 16:29'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	Smalltalk isMorphic		ifTrue:			[world _ Display bestGuessOfCurrentWorld.			world sleep]		ifFalse:			[world _ ScheduledControllers.			ScheduledControllers unCacheWindows].	Sensor eventQueue: nil. "Will be reinstalled by World>>install"	transcript _ Transcript.	activeProcess _ nil.		"we will be doing away with this, but for now just clear it out"! !"Postscript:Re-install the current world (if any) so that events are processed from the queue."Smalltalk isMorphic ifTrue:[World install].!