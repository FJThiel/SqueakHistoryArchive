'From Squeak3.6alpha of ''17 March 2003'' [latest update: #5247] on 9 June 2003 at 5:57:45 pm'!"Change Set:		SqueakMapBase-ghDate:			20 November 2002Author:			Gšran HultgrenWe now install 'SqueakMap Base' version 1.05 as an update for 3.6alpha, with a warning prompt, and then a postscript which registers the package as 'installed'. -dew-----SqueakMap is a catalog for all published Squeak code on the planet. It gives you a local database of all available Squeak packages that very easily and efficiently is incrementally updated from the master servers.SqueakMap helps you with finding, installing and upgrading packages. It supports different formats of packages from the simplest fileouts to self installing multi changeset zip archives - '.sar' files.This is 'SqueakMap Base' version 1.05. This package includes all code that the package 'SqueakMap' had earlier. Package 'SqueakMap' is now an empty changeset with a preamble acting as a 'load script' installing extras etc."self inform: 'The SqueakMap package catalog system will now beinstalled in the image.  To access SqueakMap, select ''open...''from the World menu, then ''Package Loader'' from the submenu.'.!Object subclass: #SMInstaller	instanceVariableNames: 'package '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMInstaller commentStamp: '<historical>' prior: 0!An installer takes care of installing SqueakMap packages represented by SMCards.Deciding if a package is installable and instantiating the correct installer class is done on the class side, see implementors of #canInstall:. Two methods need to be implemented by subclasses - download and install. Upgrade can also be specialized by implementing #upgrade, otherwise it will default to #install.!Object subclass: #SMObject	instanceVariableNames: 'id map created updated name summary url registrator password newPassword categories annotations '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMObject commentStamp: '<historical>' prior: 0!SMObject is the abstract superclass for all objects living in an SMSqueakMap.It has a unique UUID and a reference to the owning SMSqueakMap.It has timestamps to record the birthtime and the last modification.It has basic attributes like name, summary and url.It keeps track of who registered it and the password used to update it. Passwords are stored as secure hashes.It holds a collection of all categories that it is classified as belonging to.Finally it also has an instance variable to hold annotations - a coming feature.!SMObject subclass: #SMCard	instanceVariableNames: 'currentVersion description downloadUrl author maintainer modulePath moduleVersion moduleTag versionComment '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMCard commentStamp: '<historical>' prior: 0!An SMCard is a library card describing a Squeak code package. It is the object representing a particularpackage and currently it has information about the current version available of the package.It contains a minimal amount of information as follows:name			A String with a name for the package. The card has an id too so the name is not what makes the card unique.currentVersion	A String with the readable version of the package. This can follow whatever style the author wants.summary		A oneline String describing shortly what the package is in one sentence.description		A 5-10 lines String describing the package in full.url				A String with the url to the WWW homepage of the package if it has one.downloadUrl		A String with the url to a download of the package. Note that if it is packaged as a Squeak Module this is not needed, see modulePath below.author			A String with the original author in format 'Joe Schmoe <joe@schmoe.com>'.maintainer		A String with the current package maintainer in format 'Joe Schmoe <joe@schmoe.com>'.registrator		A String with the the person registrating the card in format 'Joe Schmoe <joe@schmoe.com>'.password		A String with the password that the registrator selected when registering the card.modulePath		A String with the module path as 'People gh KillerApp'.  moduleVersion	A String with the specific module version.moduleTag		A String with the specific module tag (as an alternative to moduleVersion).versionComment	A String describing the specific version of the package.categories		An OrderedCollection with the SMCategories that this card belongs to.Of all these variables only the last one - categories is not a simple String. When being stored or transmitted we use the UUIDs of the SMCategory objects instead and then "reconnect" them using real references.!SMObject subclass: #SMCategory	instanceVariableNames: 'mandatory subCategories parent objects '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMCategory commentStamp: '<historical>' prior: 0!An SMCategory is a "tag" that can be attached to SMCards (packages) in order to categorize them. Name, summary etc are already inherited from SMObject but we add an instance variable called mandatory to indicate that an SMCard must belong to at least one subcategory of this SMCategory. Obviously not many categories will be of that kind.The SMCategories are arranged in a strict hierarchy and each SMCategory both knows it's parent and it's subcategories. When the category is "externalized" in the logfile using #definition: we only export the parent id - the subCategories collection will be "filled" when the other SMCategories are imported.The category tree is maintained by a few trusted people so that chaos will not reign. :-)!SMObject subclass: #SMRepository	instanceVariableNames: 'modulePath '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMRepository commentStamp: '<historical>' prior: 0!This is for the new Modules system - a sort of /etc/mtab for the global Module namespace. SqueakMap holds a register of all known Module repositories and which mountpoints they represent in the naming hierarchy. Since 3.3a Modules are not really used yet this is not used much currently. The end result of this registry is that we can use SMSqueakMap>>repositoryUrlForModulePath: to resolve a module path into a concrete url.An SMRepository is a mapping from a module path to a repository url - typically an HTTP or FTP url. This means that everyone intending to host Squeak modules on an FTP or HTTP server should register it in the SqueakMap together with the Squeak module that corresponds to the top level of the repository.For example:If Joe Schmoe would like to publish his personal Squeak modules on an FTP server residing on his own server then he could register an SMRepository using url 'ftp://ftp.joes.squeakstuff.com/joes' and modulePath 'People joe'.!Object subclass: #SMScriptEngine	instanceVariableNames: 'map '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMScriptEngine commentStamp: 'gh 12/2/2002 11:18' prior: 0!SMScriptEngine is used in load scripts so that SqueakMap can have some control over how the load scripts behave, allow limited user "interface independent" interaction etc.This class is not yet implemented :-) - today you will simply need to access the map directly. Here is an example preamble (as in ChangeSets and SAR files) that only installs one package:SMSqueakMap default doLoadScript: [:scriptEngine |	scriptEngine map installPackageNamed: 'SqueakMap Browser']!SMInstaller subclass: #SMSimpleInstaller	instanceVariableNames: 'fileName dir unpackedFileName '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMSimpleInstaller commentStamp: '<historical>' prior: 0!This is a base class that you can subclass if your package format can be downloaded usinga single file url and possibly also be decompressed using gzip.!SMSimpleInstaller subclass: #SMDefaultInstaller	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMDefaultInstaller commentStamp: '<historical>' prior: 0!An installer takes care of installing SqueakMap packages represented by SMCards.This installer handles packages that consist of classical fileins (single changesets and .st-files) and optional gzip-decompression of those. Deciding if a package is installable and instantiating the correct installer class is done on the class side in SMInstaller, to see how this installer gets chosen - see SMDefaultInstaller class>>canInstall:.!SMDefaultInstaller subclass: #SMDVSInstaller	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMDVSInstaller commentStamp: '<historical>' prior: 0!This is an installer class for DVS packages. It handles packages categorized with packageformat as DVS and with a download filename with extensions .st or .st.gz.This class can function without DVS installed, needed classes are looked up dynamically.!SMSimpleInstaller subclass: #SMProjectInstaller	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMProjectInstaller commentStamp: '<historical>' prior: 0!I am a SMInstaller that knows how to install .pr (Project) files.!SMSimpleInstaller subclass: #SMSARInstaller	instanceVariableNames: 'zip '	classVariableNames: ''	poolDictionaries: ''	category: 'SM-domain'!!SMSARInstaller commentStamp: '<historical>' prior: 0!I am a SqueakMap installer that knows how to deal with Zip format change-set archives.I recognize them by the file extension ".sar" (Squeak Archive).These have a couple of members with special names:install/preambleinstall/postscriptThese are loaded in order. Either or both can further load other members using fileInMemberNamed:.Inside a postscript or preamble, the pseudo-variable "self" is set to an instance of SARInstaller; you can then get to its ZipArchive using the method "zip". Or you can call its methods for filing in change sets, extracting files, etc.You can test this loading with:(SMSARInstaller new) directory: FileDirectory default; fileName: 'test.sar'; fileIn.See ChangeSet>>fileOutAsZipNamed: for one way to make these files. Here is another way of creating a multi change set archive installable by SqueakMap:"The following doit will create a .sar file with HVs preamble and postscript asseparate entries and the included changesets included as normal.Given a preamble as described below this will autoinstall in SqueakMap."(ChangeSorter changeSetNamed: 'HV')	fileOutAsZipNamed: 'httpview-021023.sar'	including: {		ChangeSorter changeSetNamed: 'HVFixes'.		ChangeSorter changeSetNamed: 'kom412'}Preamble in changeset HV that will install the changesets:"Change Set:		HVDate:			23 October 2002Author:			Gšran HultgrenThis is my latest developer code drop of HttpView packaged as a Squeak selfextracting archive (courtesy Ned Konz).""Standard SqueakMap installing code follows:"(self isKindOf: SARInstaller) ifTrue:[	self fileInMemberNamed: 'HVFixes'.	self fileInMemberNamed: 'kom412'.	self fileInMemberNamed: 'HV']!Object subclass: #SMSqueakMap	instanceVariableNames: 'cards categories repositories dir transactionCounter firstTransactionNumber daysBacklog adminPassword module installedPackages '	classVariableNames: 'DefaultMap ServerList '	poolDictionaries: ''	category: 'SM-domain'!!SMSqueakMap commentStamp: '<historical>' prior: 0!A SqueakMap is a Squeak code package metacatalog - a catalog of all available Squeak packages. SMSqueakMap is the class for the domain model.One master instance lives on a server on the Internet at map1.squeakfoundation.org (but there are fallback servers too). Then each Squeak connected to the Internet has one instance that is synchronized incrementally against the master. This way every user can have an updated catalog of all available Squeak software on the planet locally on their machine. :-)Typically you only need one instance of SMSqueakMap per image and it is held by a singleton class variable reached with "SMSqueakMap default". If it is not there it will then be created together with it's own filelog on disk by default in the "sm" directory created in your default directory.The map is continously mirrored in a log-file and every operation on the map open and close the log-file to ensure nothing is lost. Synching with the master is the only action that affects the map so you can actually use the same map from multiple images (they will by default use the same logfile if the images have the same default directory) and multiple tools (SMLoader, SMBrowser or others) as long as you always do a "SMSqueakMap default reloadLog" before anything else when you switch image!!An instance of SMSqueakMap contains instances of SMCard which are "library cards" for Squeak packages and SMCategories which are centrally registered values that can be included as attributes in an SMCard. An example of such a category would be different kinds of licenses, topic etc. etc.It also contains instances of SMRepository which are registered Squeak module repositories and their respective top module. This way the SqueakMap can resolve a module path to the correct repository. Note: this is for 3.3a Modules which is not really used yet.Finally SMSqueakMap also contains "in image only" state (not logged in logfile) about what packages and versions of them have been installed in the image. This is the Dictionary installedPackages.--------------------Simplest use of SMSqueakMap: SMLoader open "This will create a map if you don't have one and open a simple UI"Use these doits to play "hands on" with a SqueakMap."Creating a SqueakMap in directory 'slavemap' instead of default 'sm'"Smalltalk at: #SqueakMap put: (SMSqueakMap newIn: 'slavemap')"Synch it with a known running master - check Transcript for some numbers."SqueakMap loadUpdates"Ask the map to resolve a module path into an SMRepository and show the url.This functionality will in some way be embedded in the new Modules system."(SqueakMap repositoryUrlForModulePath: #(People gh)) url"If the map is broken in some way, reload it from the log"SqueakMap reloadLog"If you want to rotate the log and save the current SqueakMap in the new log"SqueakMap saveNewLog"Start up a web interface on the map"| service smodule |service := ComancheNetService named: 'SqueakMap' onPort: 8000.service module: (smodule _ HttpSessionModule module: (SMModule on: SqueakMap prefix: '/sm')).SqueakMap module: smodule. "this is a hack"service start"And to stop the webservice"(ComancheNetService serviceNamed: 'SqueakMap') unregister"Check which services are alive"ComancheNetService services!Magnitude subclass: #TimeStamp	instanceVariableNames: 'date time '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Magnitudes'!!TimeStamp commentStamp: '<historical>' prior: 0!An instance of this class serves as a container for a Date and a Time.  Because TimeStamp is a subclass of Magnitude, you can do lots of interesting comparisons and arithmetic operations with TimeStamps.Structure:	date	 --> a Date - The day on which the TimeStamp occurs.	time --> a Time - The time at which the TimeStamp occurs.Examples:	TimeStamp current	TimeStamp date: Date today time: Time now	TimeStamp fromString: '1-10-2000 11:55:00 am'   "MM-DD-YYYY HH:MM:SS AM"	TimeStamp current < TimeStamp noon!!SMInstaller methodsFor: 'services' stamp: 'gh 9/23/2002 14:17'!download	"This service should bring the package to the client	and also unpack it on disk if needed.	It will not install it into the running image though.	We return true if operation succeeded, false otherwise."	self subclassResponsibility ! !!SMInstaller methodsFor: 'services' stamp: 'gh 10/30/2002 13:37'!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package should be notified of the installation using	'package noteInstalled'. 	We return true if operation	succeeded, false otherwise."	self subclassResponsibility ! !!SMInstaller methodsFor: 'services' stamp: 'gh 10/22/2002 12:35'!upgrade	"This service should bring the new version of the package to the client,	unpack it if necessary and upgrade the already installed version	in the image. We return true if operation succeeded, false otherwise.	By default we simply call install!!"	^self install! !!SMInstaller methodsFor: 'accessing' stamp: 'gh 9/23/2002 13:47'!package: aPackage	package _ aPackage! !!SMInstaller class methodsFor: 'instance creation' stamp: 'gh 9/23/2002 12:32'!forPackage: aPackage directory: aDirectory	"Instantiate the first class suitable to install the package	or return nil if no installer class was found."	| class |	class _ self classForPackage: aPackage.	^class ifNotNil: [class new package: aPackage; directory: aDirectory]! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'nk 11/30/2002 17:18'!basicNewChangeSet: newName 	"This method copied here to ensure SqueakMap is independent of 	ChangeSorter. "	Smalltalk		at: #ChangeSorter		ifPresentAndInMemory: [:cs | ^ cs basicNewChangeSet: newName].	(self changeSetNamed: newName)		ifNotNil: [self error: 'The name ' , newName , ' is already used'].	^ ChangeSet basicNewNamed: newName! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'gh 10/31/2002 10:11'!changeSetNamed: newName	"This method copied here to ensure SqueakMap is independent of ChangeSorter."	Smalltalk at: #ChangeSorter ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SMInstaller class methodsFor: 'testing' stamp: 'gh 10/30/2002 12:42'!canInstall: aPackage	"Nope, I am an abstract class and can not install anything.	But my subclasses should reimplement this."
	^ false! !!SMInstaller class methodsFor: 'testing' stamp: 'gh 9/23/2002 13:44'!isInstallable: aPackage	"Detect if any subclass can handle the package."	^(self classForPackage: aPackage) notNil! !!SMInstaller class methodsFor: 'testing' stamp: 'gh 10/25/2002 10:44'!isUpgradeable: aPackage	"Detect if any subclass can handle the package.	Currently we assume that upgrade is the same as install."	^self isInstallable: aPackage! !!SMInstaller class methodsFor: 'private' stamp: 'gh 10/30/2002 12:41'!classForPackage: aPackage 	"Decide which subclass to instantiate. 	We detect and retrurn the first subclass	that wants to handle the package going	recursively leaf first so that subclasses gets	first chance if several classes compete over	the same packages, like for example SMDVSInstaller	that also uses the .st file extension."	self subclasses do: [:ea |		(ea classForPackage: aPackage)			ifNotNilDo: [:class | ^ class]].	^(self canInstall: aPackage)		ifTrue: [self]! !!SMObject methodsFor: 'initialize-release' stamp: 'gh 7/30/2002 13:41'!initialize	"Initialize."	created _ TimeStamp current asSeconds.	updated _ created.	name _ summary _ url _ registrator _ ''! !!SMObject methodsFor: 'private' stamp: 'gh 8/15/2002 08:58'!addCategory: aCategory	"Add <aCategory> to me. If I already have it do nothing."	categories ifNil: [categories _ OrderedCollection new].	(categories includes: aCategory) ifFalse:[		aCategory addObject: self.		categories add: aCategory].	^aCategory! !!SMObject methodsFor: 'private' stamp: 'gh 8/15/2002 10:12'!removeCategory: aCategory	"Remove category from me if I am in it."	(categories notNil and: [categories includes: aCategory]) ifTrue:[		aCategory removeObject: self.		categories remove: aCategory].	^aCategory! !!SMObject methodsFor: 'private' stamp: 'gh 8/1/2002 18:23'!removeFromCategories	"Remove me from all my categories."	categories ifNotNil:[		categories copy do: [:cat | self removeCategory: cat ]]! !!SMObject methodsFor: 'queries' stamp: 'gh 8/23/2002 11:04'!categoriesDo: aBlock	categories ifNil: [^self].	categories do: aBlock! !!SMObject methodsFor: 'queries' stamp: 'gh 8/13/2002 15:51'!categoryForParent: aCategory	"Answer the one of my categories with parent <aCategory>, if I have it."	categories ifNil: [^nil].	^categories detect: [:cat | cat parent = aCategory ] ifNone: [nil]! !!SMObject methodsFor: 'queries' stamp: 'gh 8/13/2002 14:15'!hasCategory: aCategory	"Answer true if I am in it."	^categories notNil and: [categories includes: aCategory]! !!SMObject methodsFor: 'passwords' stamp: 'gh 8/16/2002 14:01'!correctPassword: aPassword	"We store the password as a SHA hash so that we can let the slave maps	have them too. Also check the optional new random password."	| try |	aPassword isEmpty ifTrue:[^false].	try _ SecureHashAlgorithm new hashMessage: aPassword.	^password = try or: [newPassword = try]! !!SMObject methodsFor: 'passwords' stamp: 'gh 8/27/2002 12:59'!setNewPassword: aString	newPassword _ SecureHashAlgorithm new hashMessage: aString! !!SMObject methodsFor: 'passwords' stamp: 'gh 10/28/2002 14:05'!setPassword: aString	"We also clear the random extra password."	password _ SecureHashAlgorithm new hashMessage: aString.	newPassword _ nil! !!SMObject methodsFor: 'updating' stamp: 'gh 10/22/2002 16:53'!stampAsUpdated	updated _ TimeStamp current asSeconds! !!SMObject methodsFor: 'accessing' stamp: 'gh 8/1/2002 16:52'!categories	^categories ifNil: [OrderedCollection new]! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12'!created	^TimeStamp fromSeconds: created! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12'!created: c	created _ c! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12'!createdAsSeconds	^created! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/16/2002 23:12'!id	^id! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:11'!id: anId	id _ anId! !!SMObject methodsFor: 'accessing' stamp: 'gh 8/15/2002 08:50'!map	^map! !!SMObject methodsFor: 'accessing' stamp: 'gh 8/15/2002 08:46'!map: aMap id: anId	map _ aMap.	id _ anId! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:31'!name	^name! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:31'!name: aName	name _ aName! !!SMObject methodsFor: 'accessing' stamp: 'gh 7/30/2002 13:41'!password	^password! !!SMObject methodsFor: 'accessing' stamp: 'gh 7/31/2002 14:05'!password: aSHAHash	password _ aSHAHash! !!SMObject methodsFor: 'accessing' stamp: 'gh 7/30/2002 13:40'!registrator	^registrator! !!SMObject methodsFor: 'accessing' stamp: 'gh 7/30/2002 13:40'!registrator: aString	registrator _ aString! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:33'!summary	^summary! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:33'!summary: aString	summary _ aString! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:44'!updated	^TimeStamp fromSeconds: updated! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:44'!updated: c	updated _ c! !!SMObject methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:45'!updatedAsSeconds	^updated! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:36'!url	^url! !!SMObject methodsFor: 'accessing' stamp: 'gh 6/26/2002 15:36'!url: aString	url _ aString! !!SMObject methodsFor: 'logging' stamp: 'gh 8/15/2002 08:38'!definition: isUpdate	"Return a String with a definition used for logging."	self subclassResponsibility ! !!SMObject methodsFor: 'logging' stamp: 'gh 6/26/2002 16:11'!logDeleteOn: aStream	"Log a deletion of me on the stream."	self subclassResponsibility ! !!SMObject methodsFor: 'logging' stamp: 'gh 8/15/2002 08:39'!logOn: aStream	"Log me on the stream."	aStream cr; nextChunkPut: (self definition: false)! !!SMObject methodsFor: 'logging' stamp: 'gh 10/22/2002 17:25'!logUpdateOn: aStream	"Log an update for me on the stream.	First we update the stamp."	self stampAsUpdated.	aStream cr; nextChunkPut: (self definition: true)! !!SMObject methodsFor: 'mail' stamp: 'gh 10/28/2002 14:07'!mailRandomPasswordToRegistratorWithLink: aLink	"Change the password to a random generated one and mail it to the registrator."	| randomPass |	randomPass _ String streamContents: [:stream | 10 timesRepeat: [ stream nextPut: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' atRandom]].	self setNewPassword: randomPass.	SMTPSocket		deliverMailFrom: 'goran.hultgren@bluefish.se'		to: {self registratorEmail}		text:'From: SqueakMapTo: ', self registratorEmail, 'Subject: New password at SqueakMap!!Hi!!An extra random password has been added for updating the registration of "', name, '":"', randomPass, '"The regular password still works, so if it was not you who requested this extrarandom password you can safely just delete this email.You can edit the registration for ', name, ' at ', aLink, '.This extra password will stop working when you change your regular password.', (self randomPhrase), ', SqueakMap'		usingServer: 'leia.bluefish.se'! !!SMObject methodsFor: 'mail' stamp: 'gh 10/22/2002 16:49'!randomPhrase	"Pick a nice phrase."	^#('Debug safely' 'Happy Squeaking' 'Just do it' 'Yours truly' 'Stay a Squeaker' 'Squeak rocks') atRandom! !!SMObject methodsFor: 'mail' stamp: 'gh 10/22/2002 15:31'!registratorEmail	"Picks out the email from:		'Robert Robertson <rob@here.com>' => 'rob@here.com'	Spamblockers 'no_spam', 'no_canned_ham' and 'spam_block'	(case insensitive) will be filtered out."	| lessThan moreThan email pos |	lessThan _ registrator indexOf: $<.	moreThan _ registrator indexOf: $>.	email _ (registrator copyFrom: lessThan + 1 to: moreThan - 1) asLowercase.	#('no_spam' 'no_canned_ham' 'spam_block') do: [:block |		pos _ email findString: block.		pos = 0 ifFalse:[email _ (email copyFrom: 1 to: pos - 1), (email copyFrom: pos + block size to: email size)]].	^email! !!SMCard methodsFor: 'initialize-release' stamp: 'gh 10/22/2002 16:27'!categories: anArray	"Method used when recreating the card in the image when we need	to bind the category ids with the actual category objects."	anArray do: [:i | self addCategory: (map categoryWithId: i)]! !!SMCard methodsFor: 'initialize-release' stamp: 'gh 8/1/2002 16:52'!initialize	"Initialize card."	super initialize.	name _ currentVersion _ summary _ description _ url _ ''.	downloadUrl _ author _ maintainer _ modulePath _ ''! !!SMCard methodsFor: 'logging' stamp: 'gh 6/27/2002 13:24'!created: c updated: u name: n currentVersion: v summary: s description: d url: ur downloadUrl: du author: a maintainer: m registrator: r password: p categories: cats 	"Method used when recreating from storeOn: format."	created _ c.	updated _ u.	name _ n.	currentVersion _ v.	summary _ s.	description _ d.	url _ ur.	downloadUrl _ du.	author _ a.	maintainer _ m.	registrator _ r.	password _ p.	self categories: cats! !!SMCard methodsFor: 'logging' stamp: 'gh 10/22/2002 16:29'!definition: isUpdate	"This method is used when representing the card in the log."	^String streamContents: [:stream |		isUpdate			ifFalse:[stream nextPutAll: '(self newCardWithId: ', id asString storeString, ')']			ifTrue:[stream nextPutAll: '(self cardWithId: ', id asString storeString, ')'].		stream crtab; nextPutAll: 'created: '.		created storeOn: stream.		stream crtab; nextPutAll: 'updated:'.		updated storeOn: stream.		stream crtab; nextPutAll: 'name: '.		name storeOn: stream.		stream crtab; nextPutAll: 'currentVersion:'.		currentVersion storeOn: stream.		stream crtab; nextPutAll: 'summary: '.		summary storeOn: stream.		stream crtab; nextPutAll: 'description:'.		description storeOn: stream.		stream crtab; nextPutAll: 'url: '.		url storeOn: stream.		stream crtab; nextPutAll: 'downloadUrl:'.		downloadUrl storeOn: stream.		stream crtab; nextPutAll: 'author: '.		author storeOn: stream.		stream crtab; nextPutAll: 'maintainer:'.		maintainer storeOn: stream.		stream crtab; nextPutAll: 'registrator:'.		registrator storeOn: stream.		stream crtab; nextPutAll: 'password:'.		password storeOn: stream.		stream crtab; nextPutAll: 'categories: '.		((self categories collect: [:c | c id asString]) asArray) storeOn: stream.		stream nextPut: $;; crtab; nextPutAll: 'modulePath: '.		modulePath storeOn: stream.		stream crtab; nextPutAll: 'moduleVersion:'.		moduleVersion storeOn: stream.		stream crtab; nextPutAll: 'moduleTag:'.		moduleTag storeOn: stream.		stream crtab; nextPutAll: 'versionComment:'.		versionComment storeOn: stream.]! !!SMCard methodsFor: 'logging' stamp: 'gh 8/5/2002 14:45'!logDeleteCategory: category on: aStream	"Log a deletion of a category in me on the stream."	aStream cr; nextChunkPut: 'self deleteCategoryWithId: ', category id asString storeString, ' inCardWithId: ', id asString storeString! !!SMCard methodsFor: 'logging' stamp: 'gh 8/1/2002 18:19'!logDeleteOn: aStream	"Log a deletion of me on the stream."	aStream cr; nextChunkPut: 'self deleteCardWithId: ', id asString storeString! !!SMCard methodsFor: 'logging' stamp: 'gh 8/14/2002 14:44'!logNewCategory: category on: aStream	"Log an addition of a category in me on the stream."	aStream cr; nextChunkPut: 'self newCategoryWithId: ', category id asString storeString, ' inCardWithId: ', id asString storeString! !!SMCard methodsFor: 'logging' stamp: 'gh 6/26/2002 15:51'!modulePath: mp moduleVersion: mv moduleTag: mt versionComment: vc  	"Method used when recreating from storeOn: format."	modulePath _ mp.	moduleVersion _ mv.	moduleTag _ mt.	versionComment _ vc! !!SMCard methodsFor: 'services' stamp: 'gh 9/23/2002 14:43'!downloadFileName	"Cut out the filename from the url."	downloadUrl isEmpty ifTrue: [^nil].	^downloadUrl asUrl path last! !!SMCard methodsFor: 'services' stamp: 'gh 10/23/2002 17:21'!smartVersion	"This method is used to ensure that we always have a	version name for the package even if the maintainer didn't	bother to enter one. Is is calculated like this:		1. If the maintainer entered a currentVersion then we use that.		2. Otherwise we extract the version name from the download filename            by taking everything after the first hyphen or dot up to the next dot.		  There must be two separate characters and at least one characer between them.			'yadda.1.cs' => '1'			'yadda-1.cs.gz' => '1'			'yadda-0-94-02.cs' => '0-94-02'			'yadda.0.94.02.cs' => '0'		3. If there is no file part of the download url or if the above yields		   an empty string, we fall back on the modified date of the card in		   ISO 8601 format like '2002-10-21'."	| result fileName start stop |	currentVersion notEmpty ifTrue:[^currentVersion].	fileName _ self downloadFileName.	fileName isEmptyOrNil ifFalse:[		start _ fileName indexOfAnyOf: (CharacterSet newFrom: '-.').		start = 0 ifFalse:[ stop _ fileName indexOf: $. startingAt: start + 1.			stop > (start + 1) ifTrue: [				result _ fileName copyFrom: start + 1 to: stop - 1]]].	result ifNil: [result _ self updated date yyyymmdd].	^result	! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/19/2002 20:11'!author	^author! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:24'!author: aString	author _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/19/2002 20:11'!currentVersion	^currentVersion! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:22'!currentVersion: aString	currentVersion _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/19/2002 20:11'!description	^description! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:23'!description: aString	description _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/19/2002 20:12'!downloadUrl	^downloadUrl! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:24'!downloadUrl: aString	downloadUrl _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 12/1/2002 15:29'!fullDescription	"Return a full textual description of the package."	| s tab |	s _ TextStream				on: (Text new: 400).	tab _ String with: Character tab.	self		describe: name		withBoldLabel: 'Name:' , tab , tab		on: s.	summary isEmptyOrNil		ifFalse: [self				describe: summary				withBoldLabel: 'Summary:' , tab				on: s].	author isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Author:'];				 tab;				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self sendMailTo: author])				do: [s nextPutAll: author];				 cr].	maintainer isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Maintainer:'];				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self sendMailTo: maintainer])				do: [s nextPutAll: maintainer];				 cr].	registrator isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Registrant:'];				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self sendMailTo: registrator])				do: [s nextPutAll: self registratorEmail ];				 cr].	categories isEmptyOrNil		ifFalse: [s cr;				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Categories: ']; cr.			self				categoriesDo: [:c | s tab;						withAttribute: TextEmphasis italic						do: [c parentsDo: [:p | s nextPutAll: p name; nextPutAll: '/'].							s nextPutAll: c name];						nextPutAll: ' - ' , c summary; cr].			s cr].	currentVersion isEmptyOrNil		ifTrue: [self				describe: self smartVersion				withBoldLabel: 'Calculated version: '				on: s]		ifFalse: [self				describe: currentVersion				withBoldLabel: 'Current version: '				on: s].	versionComment isEmptyOrNil		ifFalse: [s cr;				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Version Comment:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s nextPutAll: versionComment].			s cr; cr].	url isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Homepage:']; tab;								withAttribute: (TextURL new url: url)				do: [s nextPutAll: url];				 cr].	downloadUrl isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Download:']; tab;								withAttribute: (TextURL new url: downloadUrl)				do: [s nextPutAll: downloadUrl];				 cr].	description isEmptyOrNil		ifFalse: [s cr.			s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Description:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s nextPutAll: description].			s cr; cr].	modulePath isEmptyOrNil		ifFalse: [self				describe: modulePath				withBoldLabel: 'Module path: '				on: s].	moduleVersion isEmptyOrNil		ifFalse: [self				describe: moduleVersion				withBoldLabel: 'Module version: '				on: s].	moduleTag isEmptyOrNil		ifFalse: [self				describe: moduleTag				withBoldLabel: 'Module tag: '				on: s].	^ s contents isoToSqueak! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/19/2002 20:12'!maintainer	^maintainer! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:24'!maintainer: aString	maintainer _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 7/31/2002 10:37'!modulePath	^modulePath! !!SMCard methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:25'!modulePath: aString	modulePath _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 7/31/2002 10:38'!moduleTag	^moduleTag! !!SMCard methodsFor: 'accessing' stamp: 'gh 6/27/2002 11:39'!moduleTag: aString	moduleTag _ aString! !!SMCard methodsFor: 'accessing' stamp: 'gh 7/31/2002 10:38'!moduleVersion	^moduleVersion! !!SMCard methodsFor: 'accessing' stamp: 'gh 6/27/2002 11:40'!moduleVersion: aString	moduleVersion _ aString! !!SMCard methodsFor: 'accessing' stamp: 'nk 10/25/2002 10:43'!sendMailTo: recipient	| usingCeleste userName server messageStream versionString |	versionString _ currentVersion.	versionString isEmptyOrNil ifTrue: [ versionString _ self smartVersion ].	usingCeleste _ (Smalltalk includesKey: #Celeste) and: [Celeste isSmtpServerSet].	usingCeleste		ifTrue: [server _ Celeste smtpServer.				userName _ Celeste userName.]		ifFalse: [server _  FillInTheBlank request: 'What is your mail server for outgoing mail?'.				userName _ FillInTheBlank request: 'What is your email address?'].	messageStream _ WriteStream on: (String new: 1500).	messageStream nextPutAll: 'From: '; nextPutAll: userName; cr;		nextPutAll: 'To: '; nextPutAll: recipient; cr;		nextPutAll: 'Subject: '; nextPutAll: self name; space; nextPutAll: versionString; cr.	usingCeleste ifTrue:			[CelesteComposition				openForCeleste: Celeste current 				initialText: messageStream contents]		ifFalse:			[AdHocComposition 				openForCeleste: server				initialText: messageStream contents].! !!SMCard methodsFor: 'accessing' stamp: 'gh 7/31/2002 10:38'!versionComment	^versionComment! !!SMCard methodsFor: 'accessing' stamp: 'gh 6/27/2002 11:39'!versionComment: aString	versionComment _ aString! !!SMCard methodsFor: 'view' stamp: 'gh 7/30/2002 16:35'!getLink: aBuilder	"Return a link for using on the web."	^aBuilder getLinkLocal: '/package/', id asString text: name! !!SMCard methodsFor: 'view' stamp: 'gh 7/30/2002 15:04'!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject cardViewOn: self! !!SMCard methodsFor: 'printing' stamp: 'nk 10/24/2002 19:31'!describe: string withBoldLabel: label on: stream	stream withAttribute: (TextEmphasis bold) do: [ stream nextPutAll: label ].	stream		nextPutAll: string;		cr.! !!SMCard methodsFor: 'printing' stamp: 'gh 10/25/2002 11:35'!printOn: aStream	aStream nextPutAll: self class name, '[', name, ']'! !!SMCard methodsFor: 'installation' stamp: 'gh 10/22/2002 16:32'!installedVersion	"Return the version String for the installed version.	We ask the map. Return nil if this package is not installed."	^map installedVersionOf: self! !!SMCard methodsFor: 'installation' stamp: 'gh 10/22/2002 16:32'!noteInstalled	"This package was just successfully installed.	We tell the map so that it can keep track of	what packages are intalled."	map noteInstalled: self! !!SMCard methodsFor: 'installation' stamp: 'gh 10/22/2002 15:48'!versionLabel	"Return a label indicating installed and available version as:		'1.0'      = 1.0 is installed and no new version is available		'1.0->1.1' = 1.0 is installed and 1.1 is available		'->1.1'    = No version is installed and 1.1 is available"	| installedVersion smartVersion |	installedVersion _ self installedVersion.	smartVersion _ self smartVersion.	^installedVersion		ifNil: ['->', smartVersion]		ifNotNil: [installedVersion = smartVersion					ifTrue:[installedVersion]					ifFalse:[installedVersion, '->', smartVersion]]				! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 11:49'!isAvailable	"Answer if I am old or not installed regardless of	if there is installer support for me."	^self isOld or: [self isInstalled not]! !!SMCard methodsFor: 'testing' stamp: 'gh 10/22/2002 16:33'!isDownloadable	"Answer if I can be downloaded.	We simply verify that the download url	ends with a filename."	^self downloadFileName isEmptyOrNil not! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 11:51'!isInstallable	"Answer if there is any installer for me.	This depends typically on the filename of	the download url, but can in the future	depend on other things too.	It does *not* say if the package is installed or not."	^SMInstaller isInstallable: self! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 11:08'!isInstallableAndNotInstalled	"Answer if there is any installer that	can install me and I am not yet installed."	^self isInstallable and: [self isInstalled not]! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 10:42'!isInstalled	"Answer if any version of me is installed."	^(map installedVersionOf: self) notNil! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 11:36'!isOld	"Answer if I am installed and there also is a	newer version available."	| installedVersion |	installedVersion _ map installedVersionOf: self.	^installedVersion		ifNil: [false]		ifNotNil: [installedVersion ~= self smartVersion ]! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 11:52'!isUpgradeable	"Answer if there is any installer that can upgrade me.	This depends typically on the filename of	the download url, but can in the future	depend on other things too.	It does *not* say if the package is installed or not	or if there is a newer version available or not."	^SMInstaller isUpgradeable: self! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 10:47'!isUpgradeableAndOld	"Answer if there is any installer that	can upgrade me and I can be upgraded."	^self isUpgradeable and: [self isOld]! !!SMCard methodsFor: 'testing' stamp: 'gh 10/25/2002 11:23'!isUpgradeableAndOldOrInstallableAndNotInstalled	"Well, duh. Isn't it obvious? :-)	Is the package available now for automatic install or automatic upgrade?"	^self isUpgradeableAndOld and: [self isInstallableAndNotInstalled]! !!SMCategory methodsFor: 'private' stamp: 'gh 8/15/2002 08:10'!addObject: anObject	"Add <anObject> to this category. This should only be called	from SMObject>>addCategory: to ensure consistency."		(objects includes: anObject) ifFalse:[objects add: anObject]! !!SMCategory methodsFor: 'private' stamp: 'gh 6/28/2002 12:41'!parent: aCategory	"Change the parent category.	This method relies on that somebody else	updates the parent's subCategories collection."		parent _ aCategory! !!SMCategory methodsFor: 'private' stamp: 'gh 8/1/2002 18:01'!removeDeepFromObjects	"Remove myself from my objects and then ask	my subCategories to do the same."	objects copy do: [:obj | obj removeCategory: self].	subCategories do: [:cat | cat removeDeepFromObjects]! !!SMCategory methodsFor: 'private' stamp: 'gh 8/1/2002 17:53'!removeFromParent	parent ifNotNil: [parent removeCategory: self]! !!SMCategory methodsFor: 'private' stamp: 'gh 8/1/2002 16:55'!removeObject: anObject	"Remove <anObject> from this category. This should only be called	from SMObject>>removeCategory: to ensure consistency."		^objects remove: anObject! !!SMCategory methodsFor: 'services' stamp: 'gh 6/28/2002 12:46'!addCategory: cat	"Add a category as a subcategory to self.	The collection of subcategories is lazily instantiated."	subCategories ifNil: [subCategories _ OrderedCollection new].	cat parent ifNotNil: [cat parent removeCategory: cat ].	subCategories add: cat.	cat parent: self.	^cat! !!SMCategory methodsFor: 'services' stamp: 'gh 8/1/2002 18:12'!allCategoriesDo: aBlock	self allSubCategoriesDo: aBlock.	aBlock value: self! !!SMCategory methodsFor: 'services' stamp: 'gh 8/1/2002 18:12'!allSubCategoriesDo: aBlock	subCategories ifNil: [^self].	subCategories do: [:sub |		sub allSubCategoriesDo: aBlock.		aBlock value: sub]		! !!SMCategory methodsFor: 'services' stamp: 'gh 8/5/2002 17:10'!categoryBefore	"Return the category listed before me in my parent.	If I am first or I have no parent, return nil."	parent isNil ifTrue:[^nil].	parent subCategories first = self ifTrue:[^nil].	^parent subCategories before: self	! !!SMCategory methodsFor: 'services' stamp: 'gh 8/5/2002 14:36'!move: cat toAfter: before	"Move a category to be after the category <before>."	subCategories remove: cat.	before ifNil: [subCategories addFirst: cat] ifNotNil: [subCategories add: cat after: before]! !!SMCategory methodsFor: 'services' stamp: 'gh 8/1/2002 17:30'!parentsDo: aBlock	"Run a block for all my parents starting from the top."	parent ifNotNil: [		parent parentsDo: aBlock.		aBlock value: parent]! !!SMCategory methodsFor: 'services' stamp: 'gh 6/27/2002 16:20'!removeCategory: cat	"Remove a category from subcategories of self.	No error handling is done here."	cat parent: nil.	^subCategories remove: cat! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/26/2002 16:44'!mandatory	^mandatory! !!SMCategory methodsFor: 'accessing' stamp: 'gh 3/17/2002 01:48'!mandatory: aBoolean	mandatory _ aBoolean! !!SMCategory methodsFor: 'accessing' stamp: 'gh 8/1/2002 16:54'!objects	"Return all objects in this category."	^objects! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/27/2002 16:01'!parent	^parent! !!SMCategory methodsFor: 'accessing' stamp: 'gh 6/27/2002 12:25'!subCategories	subCategories ifNil: [^#()].	^subCategories! !!SMCategory methodsFor: 'logging' stamp: 'gh 8/15/2002 08:49'!created: c updated: u name: n summary: s url: uu mandatory: m parentId: anId	"Method used when recreating from storeOn: format.	Note: That #addCategory: will set the parent variable."	created _ c.	updated _ u.	name _ n.	summary _ s.	url _ uu.	mandatory _ m.	anId ifNotNil: [(map categoryWithId: anId) addCategory: self]! !!SMCategory methodsFor: 'logging' stamp: 'gh 8/15/2002 08:38'!definition: isUpdate	^String streamContents: [:stream |		isUpdate			ifFalse:[stream nextPutAll: '(self newCategoryWithId: ', id asString storeString, ')']			ifTrue:[stream nextPutAll: '(self categoryWithId: ', id asString storeString, ')'].		stream crtab; nextPutAll: 'created: '.		created storeOn: stream.		stream crtab; nextPutAll: 'updated:'.		updated storeOn: stream.		stream crtab; nextPutAll: 'name: '.		name storeOn: stream.			stream crtab; nextPutAll: 'summary: '.		summary storeOn: stream.		stream crtab; nextPutAll: 'url: '.		url storeOn: stream.		stream crtab; nextPutAll: 'mandatory: '.		mandatory storeOn: stream.		stream crtab; nextPutAll: 'parentId: '.		(parent ifNil: [nil] ifNotNil: [parent id asString]) storeOn: stream]! !!SMCategory methodsFor: 'logging' stamp: 'gh 8/1/2002 18:16'!logDeleteOn: aStream	"Log a deletion of me on the stream."	aStream cr; nextChunkPut: 'self deleteCategoryWithId: ', id asString storeString! !!SMCategory methodsFor: 'logging' stamp: 'gh 8/22/2002 18:44'!logMoveToAfter: beforeCategory on: aStream	"Log a move of me on the stream.	If beforeCategory is nil then it will be a move	to the top."	aStream cr; nextChunkPut: 'self moveCategoryWithId: ', id asString storeString, ' toAfterWithId: ',		(beforeCategory ifNil: [nil asString] ifNotNil: [beforeCategory id asString storeString])! !!SMCategory methodsFor: 'logging' stamp: 'gh 8/22/2002 18:45'!logMoveToParent: parentCategory on: aStream	"Log a move of me on the stream.	If parentCategory is nil then it will be a move	into the topCategories."	aStream cr; nextChunkPut: 'self moveCategoryWithId: ', id asString storeString, ' toParentWithId: ',		(parentCategory ifNil: [nil asString] ifNotNil: [parentCategory id asString storeString])! !!SMCategory methodsFor: 'logging' stamp: 'gh 7/30/2002 16:22'!logRecursivelyOn: aStream	"Log me on the stream. Then log all subCategories."	self logOn: aStream.	subCategories ifNotNil: [subCategories do: [:c | c logRecursivelyOn: aStream ]]! !!SMCategory methodsFor: 'initialize-release' stamp: 'gh 8/1/2002 16:54'!initialize	super initialize.	name _ summary _ url _ ''.	mandatory _ false.	objects _ OrderedCollection new! !!SMCategory methodsFor: 'testing' stamp: 'gh 8/20/2002 10:21'!hasSubCategories	^(subCategories isNil or: [subCategories isEmpty]) not! !!SMCategory methodsFor: 'testing' stamp: 'gh 6/27/2002 13:31'!isTopCategory	^parent isNil! !!SMCategory methodsFor: 'view' stamp: 'gh 6/28/2002 13:40'!getLink: aBuilder	"Return a link for using on the web."	^aBuilder getLinkLocal: '/category/', id asString text: name! !!SMCategory methodsFor: 'view' stamp: 'gh 8/1/2002 16:38'!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject categoryViewOn: self! !!SMCategory methodsFor: 'printing' stamp: 'gh 8/16/2002 06:04'!printOn: aStream	aStream nextPutAll: self class name, ': ', name! !!SMObject class methodsFor: 'instance creation' stamp: 'gh 8/15/2002 08:47'!newIn: aMap	"Create a new object in a given map with an UUID to ensure unique identity."	^(super new initialize) map: aMap id: UUID new! !!SMObject class methodsFor: 'instance creation' stamp: 'gh 8/15/2002 08:46'!newIn: aMap withId: anUUIDString	"Create a new object in a given SMSqueakMap with a given UUID as a String.	This method is used when we create instances from a logfile etc."	^(super new initialize) map: aMap id: (UUID fromString: anUUIDString)	! !!SMRepository methodsFor: 'accessing' stamp: 'gh 6/26/2002 16:43'!modulePath	^modulePath! !!SMRepository methodsFor: 'accessing' stamp: 'gh 6/26/2002 16:43'!modulePath: aString	modulePath _ aString! !!SMRepository methodsFor: 'initialize-release' stamp: 'gh 6/26/2002 16:39'!initialize	"Initialize repository."	super initialize.	modulePath _ ''! !!SMRepository methodsFor: 'logging' stamp: 'gh 8/13/2002 15:45'!created: c updated: u name: n summary: s url: uu modulePath: m registrator: r password: p 	"Method used when recreating from storeOn: format."	created _ c.	updated _ u.	name _ n.	summary _ s.	url _ uu.	modulePath _ m.	registrator _ r.	password _ p! !!SMRepository methodsFor: 'logging' stamp: 'gh 8/15/2002 08:52'!definition: isUpdate	^String streamContents: [:stream |		isUpdate			ifFalse: [stream nextPutAll: '(self newRepositoryWithId: ', id asString storeString, ')']			ifTrue: [stream nextPutAll: '(self repositoryWithId: ', id asString storeString, ')'].		stream crtab; nextPutAll: 'created: '.		created storeOn: stream.		stream crtab; nextPutAll: 'updated:'.		updated storeOn: stream.		stream crtab; nextPutAll: 'name: '.		name storeOn: stream.			stream crtab; nextPutAll: 'summary: '.		summary storeOn: stream.		stream crtab; nextPutAll: 'url: '.		url storeOn: stream.		stream crtab; nextPutAll: 'modulePath: '.		modulePath storeOn: stream.		stream crtab; nextPutAll: 'registrator: '.		registrator storeOn: stream.		stream crtab; nextPutAll: 'password: '.		password storeOn: stream.]! !!SMRepository methodsFor: 'logging' stamp: 'gh 8/2/2002 00:57'!logDeleteOn: aStream	"Log a deletion of me on the stream."	aStream cr; nextChunkPut: 'self deleteRepositoryWithId: ', id asString storeString! !!SMRepository methodsFor: 'view' stamp: 'gh 7/30/2002 13:47'!getLink: aBuilder	"Return a link for using on the web."	^aBuilder getLinkLocal: '/repository/', id asString text: name! !!SMRepository methodsFor: 'view' stamp: 'gh 7/30/2002 15:04'!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject repositoryViewOn: self! !!SMScriptEngine methodsFor: 'accessing' stamp: 'gh 12/1/2002 16:19'!map	"Return the SMSqueakMap instance."	^map! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/23/2002 10:54'!directory	^dir! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:38'!directory: aDir	dir _ aDir! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:39'!fileName	^fileName! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/23/2002 10:54'!fileName: aFileName	fileName _ aFileName! !!SMSimpleInstaller methodsFor: 'accessing' stamp: 'gh 10/21/2002 14:39'!unpackedFileName	^unpackedFileName! !!SMSimpleInstaller methodsFor: 'services' stamp: 'nk 11/30/2002 17:45'!download	"This service should bring the package to the client  	but not unpack or install it into the running image.  	This implementation simply downloads the file pointed to by the  	downloadUrl associated with the package and saves it on disk  	(overwriting any old file).  	The local filename gets set. We return true if operation succeeded,  	false otherwise."	| url stream file u contents |	[u _ package downloadUrl.	u isEmpty		ifTrue: [self error: 'Package lacks a download url, can not download.'].	url _ u asUrl.	fileName _ url path last.	fileName isEmpty		ifTrue: [self error: 'Download url lacks filename, can not download.'].	contents _ url retrieveContents.	contents		ifNil: [self error: 'Error retrieving file'].	[(contents contentType = 'text/plain'			and: [contents contents beginsWith: 'error occured retrieving'])		ifTrue: [self error: ((contents contents copyReplaceAll: '<' with: '<' asTokens: false) withNoLineLongerThan: 80) ]]		on: MessageNotUnderstood		do: [:ex | ex				resignalAs: (Error new messageText: 'response is not a correct MIME document')].	stream _ contents contentStream binary.	(dir fileExists: fileName)		ifTrue: [dir deleteFileNamed: fileName].	file _ dir newFileNamed: fileName.	file nextPutAll: stream contents]		ensure: [file				ifNotNil: [file close]].	^ true! !!SMSimpleInstaller methodsFor: 'services' stamp: 'gh 10/31/2002 10:10'!fileIntoChangeSetNamed: aString fromStream: stream	"We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| changeSet newName oldChanges |	newName _ aString.	changeSet _ SMInstaller changeSetNamed: newName.	changeSet ifNotNil: [		newName _ FillInTheBlank						request: 'ChangeSet already present, just confirm to overwrite or enter a new name:' 						initialAnswer: newName.		newName isEmpty ifTrue:[self error: 'Cancelled by user'].		changeSet _ SMInstaller changeSetNamed: newName].		changeSet ifNil:[changeSet _ SMInstaller basicNewChangeSet: newName].		changeSet ifNil:[self error: 'User did not specify a valid ChangeSet name'].		oldChanges _ Smalltalk changes. 		[Smalltalk newChanges: changeSet.		stream fileInAnnouncing: 'Loading ', newName, ' into change set ''', newName, ''''.		stream close] ensure: [Smalltalk newChanges: oldChanges]! !!SMSimpleInstaller methodsFor: 'services' stamp: 'nk 11/30/2002 16:54'!unpack	"This basic installer simply checks the file extension of	the downloaded file to choose suitable method for unpacking.	Currently it only supports .gz decompression, see SMZipInstaller	for another multi changeset package format using the zip format.	If a file exists with the same name it is first deleted.	The unpacked filename is set. We return true on successfull	decompression or if the file was not recognized as a compressed file.	On failure to decompress a known compression we return false."	| unzipped zipped buffer |	(fileName endsWith: '.gz')		ifTrue:[			unpackedFileName _ fileName copyUpToLast: FileDirectory extensionDelimiter.			(dir fileExists: unpackedFileName) ifTrue:[ dir deleteFileNamed: unpackedFileName ].			unzipped _ dir newFileNamed: unpackedFileName.			unzipped binary.			zipped _ GZipReadStream on: (dir readOnlyFileNamed: fileName).			buffer _ ByteArray new: 50000.			'Extracting ' , fileName				displayProgressAt: Sensor cursorPoint				from: 0				to: zipped sourceStream size				during: [:bar | 					[zipped atEnd]						whileFalse: 							[bar value: zipped sourceStream position.							unzipped nextPutAll: (zipped nextInto: buffer)].					zipped close.					unzipped close].			^true]		ifFalse:[			unpackedFileName _ fileName.			^true]! !!SMDefaultInstaller methodsFor: 'private' stamp: 'gh 10/23/2002 12:25'!fileIn	"Installing in the standard installer is simply filing in.	Both .st and .cs files will file into a ChangeSet of their own.	We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| fileStream |	((unpackedFileName endsWith: '.st') or: [unpackedFileName endsWith: '.cs'])		ifTrue:[			fileStream _ dir readOnlyFileNamed: unpackedFileName.			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix)				fromStream: fileStream]		ifFalse:[self error: 'Filename should end with .cs or .st']! !!SMDefaultInstaller methodsFor: 'services' stamp: 'nk 11/30/2002 16:55'!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation.	We return true if operation succeeded, false otherwise."	self download ifFalse: [^false].	self unpack ifFalse: [^false].	self fileIn.	package noteInstalled.	^true! !!SMDVSInstaller methodsFor: 'services' stamp: 'nk 11/30/2002 16:56'!install	"Install using DVS. The dynamic lookup of class FilePackageLoader	is to make this code happy even if DVS is not installed."	self download		ifFalse: [^ false].	self unpack		ifFalse: [^ false].	Smalltalk at: #FilePackageLoader ifPresentAndInMemory: [ :loader |		loader			fileInFromStream: (dir readOnlyFileNamed: unpackedFileName)			fileName: unpackedFileName.		package noteInstalled.		^true].	self error: 'DVS is not installed.  Cannot proceed with installation.'! !!SMProjectInstaller methodsFor: 'services' stamp: 'nk 11/30/2002 16:57'!install	"This service should bring the package to the client, 	unpack it if necessary and install it into the image. 	The package is notified of the installation. 	We return true if operation succeeded, false otherwise."	Project canWeLoadAProjectNow ifFalse: [^ false].	self download ifFalse: [^ false].	fileName ifNil: [^ false].	[[ ProjectLoading openFromDirectory: dir andFileName: fileName ]		on: ProgressTargetRequestNotification do: [ :ex | ex resume ]]			ensure: [package noteInstalled].	^ true! !!SMSARInstaller methodsFor: 'private' stamp: 'gh 10/31/2002 11:19'!fileIn	Smalltalk at: #SARInstaller ifPresentAndInMemory: [:installer |		(installer directory: dir fileName: fileName) fileIn. ^self].	self error: 'SAR support not installed in image, can not install.'! !!SMSARInstaller methodsFor: 'services' stamp: 'nk 11/30/2002 16:56'!install	"This service should bring the package to the client,	unpack it if necessary and install it into the image.	The package is notified of the installation.	We return true if operation succeeded, false otherwise."	self download ifFalse: [^false].	self fileIn.	package noteInstalled.	^true! !!SMSimpleInstaller class methodsFor: 'testing' stamp: 'gh 10/22/2002 11:55'!canInstall: aPackage	"Answer if this class can install the package.	This class is abstract so we return false."	^false! !!SMDefaultInstaller class methodsFor: 'testing' stamp: 'gh 10/23/2002 09:51'!canInstall: aPackage	"Answer if this class can install/upgrade the package.	This installer handles .st, .cs, .st.gz and .cs.gz files."	| fileName |	fileName _ aPackage downloadFileName.	fileName ifNil: [^false].	fileName _ fileName asLowercase.	^(fileName endsWith: '.cs') or: [		(fileName endsWith: '.st') or: [			(fileName endsWith: '.cs.gz') or: [				fileName endsWith: '.st.gz']]]! !!SMDVSInstaller class methodsFor: 'testing' stamp: 'gh 10/31/2002 10:00'!canInstall: aPackage	"Can I install this? First we check if class FilePackageLoader	is available, otherwise DVS isn't installed.	The call to super makes sure the filename is .st with	optional .gz tacked on. Then we check if the package is	categorized with package format DVS - currently we have	hardcode the id of that category - not very pretty."	| fileName |
	Smalltalk at: #FilePackageLoader ifPresentAndInMemory: [ :loader |		fileName _ aPackage downloadFileName.		fileName ifNil: [^false].		fileName _ fileName asLowercase.		^((fileName endsWith: '.st') or: [fileName endsWith: '.st.gz'])			and: [aPackage categories includes:					(SMSqueakMap default						categoryWithId: 'b02f51f4-25b4-4117-9b65-f346215a8e41')]].	^false! !!SMProjectInstaller class methodsFor: 'testing' stamp: 'nk 10/26/2002 15:55'!canInstall: aPackage	"Answer if this class can install the package.	We handle .pr files (upper and lowercase)"	| fileName |	fileName _ aPackage downloadFileName.	fileName ifNil: [^false].	^'pr' = (FileDirectory extensionFor: fileName) asLowercase! !!SMSARInstaller class methodsFor: 'testing' stamp: 'gh 10/31/2002 10:03'!canInstall: aPackage	"Answer if this class can install the package.	We handle it if the filename has the extension	.sar (upper and lowercase) and SARInstaller is	present in the image to handle the install."	| fileName |	fileName _ aPackage downloadFileName.	fileName ifNil: [^false].	Smalltalk at: #SARInstaller ifPresentAndInMemory: [ :installer |			^'sar' = (FileDirectory extensionFor: fileName) asLowercase].	^false! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 6/27/2002 14:37'!adminPassword: aString	adminPassword _ aString! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 3/19/2002 22:22'!cards	^cards! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 3/19/2002 22:22'!categories	^categories! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 3/19/2002 23:06'!daysBacklog	^daysBacklog! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 3/19/2002 23:06'!daysBacklog: days	daysBacklog _ days! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 10/31/2002 11:31'!directory	(FileDirectory default fileOrDirectoryExists: dir)		ifTrue:[^FileDirectory default directoryNamed: dir]		ifFalse:[self error: 'SqueakMap can not find the directory ''', dir, ''' where it keeps the logfiles!!']! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 8/2/2002 14:26'!firstTransactionNumber	^firstTransactionNumber! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 6/27/2002 14:46'!module: aModule	module _ aModule! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 6/26/2002 16:14'!repositories	^repositories! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 7/31/2002 14:27'!transactionCounter	"Get the last known transaction number."	^transactionCounter! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gh 3/19/2002 23:08'!transactionCounter: aCount	"Set the last known transaction number."	transactionCounter _ aCount! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 8/15/2002 07:33'!createNewLog	"Create a new empty logfile. First chunk is current date."	^self createNewLogWithInitialContent: nil! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 10/31/2002 11:25'!createNewLogWithInitialContent: content	"Create a new logfile. First chunk is current date.	Fill it with optional content."	| file directory |	directory _ self directory.	[file _ directory newFileNamed: (directory nextNameFor: 'squeakmap' extension: 'log').	file nextChunkPut: Date today storeString.	content ifNotNil: [file nextPutAll: content]]		ensure: [file close]! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 3/19/2002 19:30'!loadDateFrom: aStream	"Load the creation date from the first chunk."	^Compiler evaluate: aStream nextChunk! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 3/19/2002 23:06'!loadLog	"Pick the current logfile - if there is none, create a new and return.	Otherwise we load the creation date (stored in the beginning).	Then load all cards in it and build the model. If the creation date is older than 6 months	we recreate a new logfile in a condensed form and rotate to that."		| file creationDate |	[ file _ self openLogFile.	file ifNil: [^self createNewLog].	creationDate _ self loadDateFrom: file.	self loadUpdatesFrom: file log: false. "we don't log since we are reading from it!!"	(creationDate < (Date today subtractDays: daysBacklog))		ifTrue:[self saveNewLog]] ensure: [file ifNotNil: [file close]]! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 8/2/2002 01:36'!loadUpdatesFrom: aStream log: doLogging	"Load updates from the stream.	This updates the model in memory and if <doLogging>	is true we also log the updates in the local log file."	| chunk file |	[ doLogging ifTrue:[ file _ self openLogFile setToEnd ].	[aStream atEnd]		whileFalse: [			chunk _ aStream nextChunk.			Compiler evaluate: chunk for: self logged: false.			doLogging ifTrue: [file cr; nextChunkPut: chunk].		]] ensure: [			aStream close.			doLogging ifTrue:[file close]]! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 6/26/2002 16:17'!log: anSMObject	"Pick the newest logfile available and log the object in it."		| file |	[ file _ self openLogFile setToEnd.	anSMObject logOn: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close]! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 6/26/2002 16:11'!logDelete: anSMObject	"Pick the newest logfile available and log the deletion in it."		| file |	[ file _ self openLogFile setToEnd.	anSMObject logDeleteOn: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close]! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 10/31/2002 11:24'!logFileName	"Pick the newest logfile available."	^self directory lastNameFor: 'squeakmap' extension: 'log'! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 8/14/2002 08:14'!logFirstTransactionNumberOn: aStream	"Log the transaction number as the first available in the logfile being produced."	aStream cr; nextChunkPut: 'self firstTransactionNumber: ', transactionCounter storeString! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 3/19/2002 23:15'!logIncrementedTransactionCounterOn: aStream	"Increment the transaction counter and	log the current number."	transactionCounter _ transactionCounter + 1.	self logTransactionCounterOn: aStream! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 3/19/2002 23:16'!logTransactionCounterOn: aStream	"Log the current transaction number."	aStream cr; nextChunkPut: 'self transactionCounter: ', transactionCounter storeString! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 8/15/2002 08:35'!logUpdate: anSMObject	"Pick the newest logfile available and log the updated object in it."		| file |	[ file _ self openLogFile setToEnd.	anSMObject logUpdateOn: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close]! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 10/31/2002 11:23'!openLogFile	"Pick the newest logfile available and open it."	| fileName |	fileName _ self logFileName.	fileName ifNil: [^nil].	^self directory oldFileNamed: fileName! !!SMSqueakMap methodsFor: 'logging' stamp: 'gh 10/31/2002 11:23'!openLogFileReadOnly	"Pick the newest logfile available and open it."	| fileName |	fileName _ self logFileName.	fileName ifNil: [^nil].	^self directory readOnlyFileNamed: fileName! !!SMSqueakMap methodsFor: 'initialize-release' stamp: 'gh 10/31/2002 11:25'!initializeOn: directoryName	"Create the local directory for the SqueakMap.	We also try to load the map from the log	if there is one present."	dir _ directoryName.	(FileDirectory default directoryExists: dir)		ifFalse:[FileDirectory default createDirectory: dir].	transactionCounter _ 0.	daysBacklog _ 182. "about 6 months"	self reloadLog! !!SMSqueakMap methodsFor: 'views' stamp: 'gh 3/19/2002 18:56'!viewFor: uiObject	"This is a double dispatch mechanism for multiple views	for multiple uis."	^uiObject squeakMapViewOn: self! !!SMSqueakMap methodsFor: 'testing' stamp: 'gh 6/27/2002 14:38'!verifyAdminPassword: aString	"Answer true if it is the correct password."	^adminPassword = aString! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/24/2002 15:10'!allPackages	"Answer all packages."	^cards values! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:13'!availablePackages	"Answer all packages that are old or not installed."	^self allPackages select: [:package | package isAvailable]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:21'!installableAndNotInstalledPackages	"Answer all installable but not installed packages."	^self allPackages select: [:package | package isInstallableAndNotInstalled]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/24/2002 15:10'!installablePackages	"Answer all packages that can be (auto)installed -	we have installers that can install them."	^self allPackages select: [:package | package isInstallable]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:18'!notInstalledPackages	"Answer all packages that are not installed."	^self allPackages reject: [:package | package isInstalled]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 10:51'!oldPackages	"Answer all packages that are installed with a newer version available."	^self installedPackages select: [:package | package isOld]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:33'!upgradeableAndOldOrInstallableAndNotInstalledPackages	"This would give you all packages that are available now	for automatic install or automatic upgrade."	^self upgradeableAndOldPackages union: self installableAndNotInstalledPackages! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:16'!upgradeableAndOldPackages	"Answer all packages that are installed and that can be	upgraded by an installer and also have a newer version available."	^self oldPackages select: [:package | package isUpgradeable]! !!SMSqueakMap methodsFor: 'public-packages' stamp: 'gh 10/25/2002 11:11'!upgradeablePackages	"Answer all packages that has an installer that can upgrade them.	Note that this doesn't mean they are old, see #upgradeableAndOldPackages."	^self allPackages select: [:package | package isUpgradeable]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 10/22/2002 14:58'!clearInstalledPackages	"Simply clear the dictionary with information on installed packages.	Might be good if things get corrupted etc."	installedPackages _ nil! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 12/2/2002 11:24'!doLoadScript: aBlock	"This method can be called from within preambles	to execute default loadscripts embedded in packages.	IMPORTANT NOTE:	Future versions of SqueakMap will be able to	override these scripts in favour of more sophisticated	dependency handling. Use only sparingly since it	goes against the design idea of having the dependencies	outside of the package.	The block <aBlock> is called with a	SqueakMap script engine frontend."	aBlock value: (SMScriptEngine on: self)! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 10/31/2002 12:23'!installPackageNamed: aString	"Look up a package given aString (see method comment	of #cardWithNameBeginning:) and install the package using	FileDirectory default as download area."	(SMInstaller		forPackage: (self cardWithNameBeginning: aString)		directory: FileDirectory default) install! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 12/2/2002 14:34'!installPackageWithId: anUUIDString	"Look up and install the given package using	FileDirectory default as download area."	(SMInstaller		forPackage: (self cardWithId: anUUIDString)		directory: FileDirectory default) install! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 10/22/2002 11:24'!installedPackages	"Answer all packages that we know are installed.	Lazily initialize. The Dictionary contains the installed packages	using their UUIDs as keys and the version string as the value."	^installedPackages ifNil: [#()] ifNotNil: [		installedPackages keys collect: [:k | cards at: k ]]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 10/22/2002 13:15'!upgradeCard: card directory: downloadDirectory	"Upgrade package using downloadDirectory.	Return false if failed, otherwise true."	^(SMInstaller forPackage: card directory: downloadDirectory) upgrade! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 10/25/2002 10:49'!upgradeOldPackagesConfirmBlock: aBlock directory: downloadDirectory	"First we find out which of the installed packages are upgradeable and old.	Then we upgrade them if confirmation block yields true.	The block will be called with each SMCard to upgrade.	We return a Dictionary with the cards we tried to upgrade as keys	and the value being the result of the upgrade, true or false."	| result |	result _ Dictionary new.	self upgradeableAndOldPackages		do: [:card |			(aBlock value: card)				ifTrue:[ result at: card put: (self upgradeCard: card directory: downloadDirectory)]].	^result! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'gh 10/25/2002 10:50'!upgradeOldPackagesDirectory: downloadDirectory	"Upgrade all upgradeable old packages without confirmation on each."	^self upgradeOldPackagesConfirmBlock: [:card | true ] directory: downloadDirectory! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 7/30/2002 15:01'!cardWithId: anIdString	"Look up a card. Return nil if missing."	^cards at: (UUID fromString: anIdString) ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 7/31/2002 15:39'!cardWithName: aName	"Look up a package by name. Return nil if missing."	^cards values detect: [:card | card name = aName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 12/1/2002 15:40'!cardWithNameBeginning: aString	"Look up a package beginning with <aString>. Return nil if missing.	We return the shortest matching one. We also strip out spaces and	ignore case in both <aString> and the names."		| candidates shortest answer searchString |	searchString _ (aString asLowercase) copyWithout: Character space.	candidates _ self allPackages select: [:package |		((package name asLowercase) copyWithout: Character space)			beginsWith: searchString ].	shortest _ 1000.	candidates do: [:package |		package name size < shortest ifTrue:[answer _ package. shortest _ package name size]].	^answer! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 10/21/2002 11:46'!cardsByName	"Return the cards sorted by their name."	| cardsByName |	cardsByName _ SortedCollection sortBlock: [:x :y | x name <= y name ].	cardsByName addAll: cards.	^cardsByName! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 7/30/2002 15:01'!categoryWithId: anIdString	"Look up a category. Return nil if missing."	^categories at: (UUID fromString: anIdString) ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 9/24/2002 19:43'!installedVersionOf: aPackage	"If the package is installed, return the version string.	Otherwise return nil."	installedPackages ifNil: [^nil].	^installedPackages at: aPackage id ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 7/30/2002 15:00'!repositoryWithId: anIdString	"Look up a repository. Return nil if missing."	^repositories at: (UUID fromString: anIdString) ifAbsent: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 7/31/2002 15:38'!repositoryWithName: aName	"Look up a repository by name. Return nil if missing."	^repositories values detect: [:repo | repo name = aName ] ifNone: [nil]! !!SMSqueakMap methodsFor: 'queries' stamp: 'gh 8/14/2002 11:25'!topCategories	^categories select: [:cat | cat isTopCategory ]! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/31/2002 11:59'!checkVersion: string	"Check the content for a SqueakMap version conflict notification.	Return true if no conflict is reported, otherwise ask user if we	should upgrade SqueakMap using the bootstrap method."	(string beginsWith: 'Server version:')		ifTrue:[(self confirm: ('The SqueakMap master server is running another version (', (string last: (string size - 15)), ') than the client (', SMSqueakMap version, ').You need to upgrade the SqueakMap package, would you like to do that now?'))			ifTrue: [self class bootStrap. ^false]			ifFalse: [^false]	].	^true! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 8/2/2002 01:29'!deleteCard: aCard	"Delete a card, first remove it from its categories."	aCard removeFromCategories.	^cards removeKey: aCard id! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 8/14/2002 11:40'!deleteCategory: cat	"Delete a category. Remove it and all its subCategories	from all objects. Remove the category from its parent.	Finally remove them all from my collections."	cat removeDeepFromObjects.	cat removeFromParent.	cat allCategoriesDo: [:c |		"c isTopCategory ifFalse: [topCategories remove: c]."		"c mandatory ifTrue: [mandatoryCategories remove: c]."		categories removeKey: c id ].	^cat! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 8/14/2002 11:29'!deleteRepository: aRepository	"Delete a repository."	"repositoryPaths removeKey: aRepository modulePath."	^repositories removeKey: aRepository id! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/21/2002 13:04'!loadFullFrom: aServerName	"Contact the SqueakMap at the url <aSqueakMapUrl>	and load a full map from scratch."	| url  zipped full |	url _ 'http://', aServerName, '/sm/loadgz?mapversion=', SMSqueakMap version.	Transcript show: 'Fetch: ', (Time millisecondsToRun: [ zipped _ (HTTPSocket httpGet: url) contents]) asString, ' ms';cr.	Transcript show: 'Size: ', zipped size asString, ' bytes';cr.	Transcript show: 'Decompress time: ', (Time millisecondsToRun: [full _ (GZipReadStream on: zipped) upToEnd]) asString, ' ms';cr.	(self checkVersion: full)		ifTrue:[			Transcript show: 'Save full log: ', (Time millisecondsToRun: [			self createNewLogWithInitialContent: full]) asString, ' ms';cr.			Transcript show: 'Full reload from log: ', (Time millisecondsToRun: [			self reloadLog]) asString, ' ms';cr.]! !!SMSqueakMap methodsFor: 'private' stamp: 'nk 11/30/2002 17:18'!loadUpdatesFrom: aServerName 	"Contact the SqueakMap at the url <aServerName> 	and load needed updates from it based on our last known 	transaction number which we send as an urlencoded argument. 	If the master answers 'DO FULL!!' we issue a full load instead. 	If the master answers 'STALE SERVER!!' we notify the user and bail 	out. "	| url zipped updates |	url _ 'http://' , aServerName , '/sm/updatesgz?mapversion=' , SMSqueakMap version , '&transaction=' , transactionCounter asString.	Transcript show: 'Fetch: ' , (Time				millisecondsToRun: [zipped _ (HTTPSocket httpGet: url) contents]) asString , ' ms';		 cr.	Transcript show: 'Size: ' , zipped size asString , ' bytes';		 cr.	Transcript show: 'Decompress time: ' , (Time				millisecondsToRun: [updates _ (GZipReadStream on: zipped) upToEnd]) asString , ' ms';		 cr.	(self checkVersion: updates)		ifTrue: [updates = 'STALE SERVER!!'				ifTrue: [self error: 'Server ' , aServerName printString , ' is stale!! Aborting update.'.					^ self].			updates = 'DO FULL!!'				ifTrue: [Transcript show: 'Master can not deliver updates this far back, falling back on full load.';						 cr.					^ self loadFullFrom: aServerName].			Transcript show: 'Load updates with logging time: ' , (Time						millisecondsToRun: [self								loadUpdatesFrom: (ReadStream on: updates)								log: true]) asString , ' ms';				 cr]! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/31/2002 11:51'!loadUpdatesFull: full	"Find a server and load updates from it." 	| server |	server _ self class findServer.	server ifNotNil: [		full ifTrue: [self loadFullFrom: server]			ifFalse:[self loadUpdatesFrom: server]]! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 11/14/2002 16:53'!noteInstalled: aPackage	"The package was just successfully installed.	We record this in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The map used is the default map."	installedPackages ifNil: [installedPackages _ Dictionary new].	installedPackages at: aPackage id put: aPackage smartVersion.	Smalltalk logChange: '"Installed ', aPackage name, ' version ', aPackage smartVersion, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackage: ', aPackage id asString storeString, ' version: ', aPackage smartVersion storeString, ']'! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/22/2002 13:33'!noteInstalledPackage: uuidString version: version	"We are replaying a change that indicates that a package	was just installed. We mark it as installed in the Dictionary.	This may be a false conclusion, but it is more likely to be correct."	installedPackages ifNil: [installedPackages _ Dictionary new].	installedPackages at: (UUID fromString: uuidString) put: version! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/21/2002 13:51'!pingServer: aServerName	"Check if the SqueakMap server is responding.	We first make sure the name resolves - the #httpGet: had such a long	timeout (and hanging?) for resolving the name." 	| url serverAddr answer |	serverAddr _ NetNameResolver addressForName: (aServerName upTo: $:) timeout: 5.	serverAddr = nil ifTrue: [^false].	url _ 'http://', aServerName, '/sm/ping'.	answer _ HTTPSocket httpGet: url.	^answer isString not and: [answer contents = 'pong']! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 8/15/2002 07:07'!storeOn: aStream	"Store the model condensed on the stream.	First chunk is current date. Categories are saved first (in a top down	manner so that loading will be able to resolve parents directly),	then all the cards followed by the repositories.	At the end we tack on the last known transactionId."	self topCategories do: [:cat | cat logRecursivelyOn: aStream].	cards valuesDo: [:card | card logOn: aStream].	repositories valuesDo: [:repository | repository logOn: aStream].	self logFirstTransactionNumberOn: aStream! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 8/2/2002 14:31'!updatesSinceFirstTransaction	"Produce a String with all recorded transactions from the logfile.	We go to the beginning of the file,	then we search for the text 'firstTransactionNumber: xxx'.	Finally we return all transactions from then on.	The implementation uses the new method #findString: which	should be reasonably fast."	| file found result key |	[ file _ self openLogFileReadOnly.	key _ 'self firstTransactionNumber:'.	found _ file findString: key.	found = 0		ifTrue:[result _ nil]		ifFalse: [			file skip: key size; upTo: $!!; next.			result _ file upToEnd ]]				ensure: [file close].	^result! !!SMSqueakMap methodsFor: 'private' stamp: 'gh 10/21/2002 14:21'!updatesSinceTransaction: lastTransaction	"Produce a String with all transactions from the logfile	since <lastTransaction>. We go to the end of the file,	then we search backwards for the text 'transactionCounter: xxx'.	The implementation uses the new method #findStringFromEnd: which	should be reasonably fast. If we find no such marker it means that	this logfile has been condensed and does not have enough transactions	to return, then we return 'DO FULL!!'.	The client will have to ask for the whole file instead.	If the server has a lower transaction counter than the one sent	the server is stale, let the client know this."	| file found result key |	lastTransaction = transactionCounter ifTrue:[^''].	lastTransaction > transactionCounter ifTrue:[^'STALE SERVER!!'].	lastTransaction = firstTransactionNumber ifTrue:[^self updatesSinceFirstTransaction ].	[ file _ self openLogFileReadOnly setToEnd.	key _ 'self transactionCounter: ', lastTransaction storeString, '!!'.	found _ file findStringFromEnd: key.	found = 0 ifTrue:[result _ 'DO FULL!!'] ifFalse: [ file skip: key size. result _ file upToEnd ]]		ensure: [file close].	^result! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/2/2002 01:33'!deleteCardWithId: anIdString	"Delete a card."	^self deleteCard: (self cardWithId: anIdString)! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/1/2002 18:18'!deleteCategoryWithId: anIdString	"Delete a category."	^self deleteCategory: (self categoryWithId: anIdString)! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/5/2002 14:43'!deleteCategoryWithId: catIdString inCardWithId: cardIdString	"Delete a category from a card."	^(self cardWithId: cardIdString) removeCategory: (self categoryWithId: catIdString)! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/2/2002 01:32'!deleteRepositoryWithId: anIdString	"Delete a repository."	^self deleteRepository: (self repositoryWithId: anIdString)! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/2/2002 14:28'!firstTransactionNumber: aCount	"Set the first known transaction number."	firstTransactionNumber _ transactionCounter _ aCount! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 10/30/2002 13:48'!moveCategoryWithId: anIdString toAfterWithId: beforeIdString	"Move a category to be before another category.	If beforeIdString is nil then we move it up to be first."	| cat before |	cat _ self categoryWithId: anIdString.	before _ beforeIdString ifNotNil: [self categoryWithId: beforeIdString].	cat parent move: cat toAfter: before! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/14/2002 11:24'!moveCategoryWithId: anIdString toParentWithId: parentIdString	"Move a category to another parent.	If parentIdString is nil then we move it up as a top category."	| cat parent |	cat _ self categoryWithId: anIdString.	parentIdString		ifNil: [cat parent removeCategory: cat.			"topCategories add: cat"]		ifNotNil: [			parent _ self categoryWithId: parentIdString.			parent addCategory: cat.			"topCategories remove: cat ifAbsent: [nil]"]! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/15/2002 08:47'!newCardWithId: anIdString	"Create or update a category and add it to me."	| card |	card _ SMCard newIn: self withId: anIdString.	^cards at: card id put: card! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/15/2002 08:47'!newCategoryWithId: anIdString	"Create or update a category and add it to me."	| cat |	cat _ SMCategory newIn: self withId: anIdString.	^categories at: cat id put: cat! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/5/2002 14:41'!newCategoryWithId: catIdString inCardWithId: cardIdString	"Add a category to a card."	^(self cardWithId: cardIdString) addCategory: (self categoryWithId: catIdString)! !!SMSqueakMap methodsFor: 'log messages' stamp: 'gh 8/15/2002 08:47'!newRepositoryWithId: anIdString	"Create or update a repository and add it to me."	| repository |	repository _ SMRepository newIn: self withId: anIdString.	^repositories at: repository id put: repository! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/15/2002 08:34'!addCard: aCard	"Add a new card.	Log it in the logfile and register it in the cards."	self log: aCard.	^cards at: aCard id put: aCard! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/15/2002 08:34'!addCategory: aCategory	"Add a new category.	Log it in the logfile."	self log: aCategory.	^categories at: aCategory id put: aCategory! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 6/27/2002 16:09'!addCategory: category inCard: card	"Add a category in a card.	Log the addition."	| file |	[ file _ self openLogFile setToEnd.	card logNewCategory: category on: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close].	^card addCategory: category! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/15/2002 08:34'!addRepository: aRepository	"Add a repository.	Log it in the logfile and register it	in the repositories collection."	self log: aRepository.	^repositories at: aRepository id put: aRepository! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/13/2002 14:19'!changeCategoriesTo: newCategories inCard: card	"Remove or add categories in a card such that	it belongs to the categories in <newCategories>.	Logs the changes."	newCategories do: [:cat |		(card hasCategory: cat)			ifFalse:[self addCategory: cat inCard: card]].	card categories do: [:cat |		(newCategories includes: cat)			ifFalse: [self removeCategory: cat inCard: card]]! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/14/2002 11:41'!mandatoryCategories	^categories select: [:c | c mandatory]! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/5/2002 14:32'!moveCategory: category toAfter: categoryBefore inParent: parent	"Move a category to be listed after <categoryBefore> in <parent>.	Log the move."	| file |	[ file _ self openLogFile setToEnd.	category logMoveToAfter: categoryBefore on: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close].	parent move: category toAfter: categoryBefore.	^category	! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/14/2002 11:25'!moveCategory: category toParent: parentCategory	"Move a category into another parent category.	Log the move."	| file |	[ file _ self openLogFile setToEnd.	category logMoveToParent: parentCategory on: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close].	parentCategory		ifNil: [category parent: nil]		ifNotNil: [parentCategory addCategory: category].	"self updateTopCategories: category."	^category	! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/2/2002 01:30'!removeCard: aCard	"Log it in the logfile and remove it."		self deleteCard: aCard.	self logDelete: aCard.	^aCard! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/1/2002 18:14'!removeCategory: aCategory	"Remove a category. Same as deleting it but we log it too."	self deleteCategory: aCategory.	self logDelete: aCategory.	^aCategory! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 3/19/2002 23:14'!removeCategory: category inCard: card	"Remove a category from a card.	Log the removal."	| file |	[ file _ self openLogFile setToEnd.	card logDeleteCategory: category on: file.	self logIncrementedTransactionCounterOn: file ]		ensure: [file close].	^card removeCategory: category! !!SMSqueakMap methodsFor: 'public-master' stamp: 'gh 8/2/2002 01:32'!removeRepository: aRepository	"Log it in the logfile and delete it."		self deleteRepository: aRepository.	self logDelete: aRepository.	^aRepository! !!SMSqueakMap methodsFor: 'public-slave' stamp: 'gh 10/21/2002 14:08'!loadFull	"Go through the list of known master servers, ping	each one using simple http get on a known 'ping'-url	until one responds and then load the full map from it." 	self loadUpdatesFull: true! !!SMSqueakMap methodsFor: 'public-slave' stamp: 'gh 10/21/2002 14:07'!loadUpdates	"Go through the list of known master servers, ping	each one using simple http get on a known 'ping'-url	until one responds and then load updates from it." 	self loadUpdatesFull: false! !!SMSqueakMap methodsFor: 'public' stamp: 'gh 8/15/2002 07:12'!reloadLog	"First we clear the current content and then we load the log.	This should not lead to any differences!!"		categories _ Dictionary new.	cards _ Dictionary new.	repositories _ Dictionary new.	self loadLog! !!SMSqueakMap methodsFor: 'public' stamp: 'gh 8/15/2002 10:32'!repositoryUrlForModulePath: aPath	"Return the SMRepository that holds the module given by <aPath>.	<aPath> is given as an Array of Symbols. We will return the repository matching	the path most explicit."	| path best |	path _ (String streamContents: [:stream |		aPath do: [:sym | stream nextPutAll: sym; nextPut: Character space ]]) withoutTrailingBlanks.	repositories do: [:repository |		(path beginsWith: repository modulePath) ifTrue:[			best 				ifNil:[best _ repository]				ifNotNil: [					(repository modulePath size > best modulePath size)						ifTrue:[best _ repository]]]].	^best! !!SMSqueakMap methodsFor: 'public' stamp: 'gh 8/15/2002 07:07'!saveNewLog	"Create a new logfile and store the model condensed in it.	A slave SqueakMap can do this at any time, it is done automatically at least	once every 6 months. A master SqueakMap should not do this often at all -	the more seldom it does the longer backlog it has and can feed slaves with incremental	updates instead of forcing them to a complete download.	First chunk is current date. Categories are saved first (top down),	then all the cards followed by the repositories.	At the end we tack on the last known transactionId."	| file |	self createNewLog.	[ file _ self openLogFile setToEnd.	self storeOn: file.	firstTransactionNumber _ transactionCounter]		ensure: [file close]! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/31/2002 12:27'!clear	"Clear out the model in the image. This will forget	about what packages are installed and what versions.	The map is itself on disk though and will be reloaded.	If you only want to reload the map and not forget about	installed packages then use 'SqueakMap default reloadLog'.	This method is typically used when preparing an image and	should be included in all shrink methods etc."	"SMSqueakMap clear"	DefaultMap _ nil! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/22/2002 14:14'!default	"Return the default map, create one if missing."	"SMSqueakMap default"	^DefaultMap ifNil: [DefaultMap _ self new]! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/21/2002 15:05'!defaultNoCreate	"Return the default map or nil if there is none."	"SMSqueakMap defaultNoCreate"	^DefaultMap! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 10/22/2002 17:41'!new	"Create a new server in a new directory	under the default directory called 'sm'."	^super new initializeOn: 'sm'! !!SMSqueakMap class methodsFor: 'instance creation' stamp: 'gh 8/15/2002 07:02'!newIn: directoryName	"Create a new server in a new directory	under the default directory called <directoryName>."	^super new initializeOn: directoryName! !!SMSqueakMap class methodsFor: 'class initialization' stamp: 'gh 10/21/2002 13:37'!initialize	"Initialize the list of master servers.	If the first three don't answer I just added the Bluefish	names so that I (gh) could get it up and running myself."	"self initialize"	ServerList _ #('map1.squeakfoundation.org' 'map2.squeakfoundation.org' 'map.squeak.org' 'map.bluefish.se' 'marvin.bluefish.se:8000')! !!SMSqueakMap class methodsFor: 'constants' stamp: 'gh 10/31/2002 14:25'!version	"This is the protocol version number used for clients to decide if	they need to update SMSqueakMap before synching with	the master. In short - only increase this if changes have made	the clients incompatible so that they need to be updated."	^'1.0'! !!SMSqueakMap class methodsFor: 'changelog replay' stamp: 'gh 10/22/2002 17:14'!noteInstalledPackage: uuidString version: version	"We are replaying a change that indicates that a package	was just installed. If there is a map we let it record this,	otherwise we ask the user if we should create/recreate the map."	| choice |	DefaultMap		ifNotNil: [DefaultMap noteInstalledPackage: uuidString version: version]		ifNil: [			[choice _ PopUpMenu withCaption:'There is no SqueakMap in this image,do you wish to create/recreate it? (typical answer is Yes)' chooseFrom: 'Yes\No\More info'.			choice = 3] whileTrue: [self inform:'When packages are installed using SqueakMap a little mark is madein the change log. When an image is reconstructed from the changelogthese marks are intended to keep your map informed about what packagesare installed. You probably already have a map on disk which will automatically bereloaded if you choose ''Yes'', otherwise an new empty map will be created.If you choose ''No'', it will only result in that SqueakMap will not know that this packageis installed in your image.If you are still unsure - answer ''Yes'' since that is probably the best.'].			choice = 1				ifTrue:[self default noteInstalledPackage: uuidString version: version]]! !!SMSqueakMap class methodsFor: 'bootstrap upgrade' stamp: 'gh 10/31/2002 15:22'!bootStrap	"Bootstrap upgrade. Only used when SqueakMap itself is too old to	communicate with the server. This relies on the existence of a package	called SqueakMap that is packaged as a .cs.gz."	| server set oldChanges url |	server _ self findServer.	server ifNotNil: ["Ok, found a SqueakMap server"		url _ (('http://', server, '/sm/packagebyname/squeakmap/downloadurl')				asUrl retrieveContents content) asUrl.		name _ url path last sansPeriodSuffix.		set _ SMInstaller changeSetNamed: name.		set ifNil: [set _ SMInstaller basicNewChangeSet: name].		oldChanges _ Smalltalk changes.			[Smalltalk newChanges: set.		(url retrieveContents content unzipped readStream)				fileInAnnouncing: 'Loading ', name, '...']			ensure: [Smalltalk newChanges: oldChanges].	]! !!SMSqueakMap class methodsFor: 'server detection' stamp: 'nk 11/30/2002 17:18'!findServer	"Go through the list of known master servers, ping 	each one using simple http get on a known 'ping'-url 	until one responds return the server name. 	If some servers are bypassed we write that to Transcript. 	If all servers are down we inform the user and return nil."	| notAnswering deafServers |	Socket initializeNetwork.	notAnswering _ OrderedCollection new.	Cursor wait		showWhile: [ServerList				do: [:server | (self pingServer: server)						ifTrue: [notAnswering isEmpty								ifFalse: [deafServers _ String												streamContents: [:str | notAnswering														do: [:srvr | str nextPutAll: srvr printString;																 nextPut: Character cr]].									Transcript show: ('These SqueakMap master servers did not respond:\' , deafServers , 'Falling back on ' , server printString , '.') withCRs].							^ server]						ifFalse: [notAnswering add: server]]].	deafServers _ String				streamContents: [:str | notAnswering						do: [:srvr | str nextPutAll: srvr printString;								 nextPut: Character cr]].	self error: ('All SqueakMap master servers are down:\' , deafServers , '\ \Can not update SqueakMap...') withCRs.	^ nil! !!SMSqueakMap class methodsFor: 'server detection' stamp: 'gh 10/31/2002 11:56'!pingServer: aServerName	"Check if the SqueakMap server is responding.	We first make sure the name resolves - the #httpGet: had such a long	timeout (and hanging?) for resolving the name." 	| url serverAddr answer |	serverAddr _ NetNameResolver addressForName: (aServerName upTo: $:) timeout: 5.	serverAddr = nil ifTrue: [^false].	url _ 'http://', aServerName, '/sm/ping'.	answer _ HTTPSocket httpGet: url.	^answer isString not and: [answer contents = 'pong']! !!TimeStamp methodsFor: 'accessing' stamp: 'ccn 10/6/2000 22:51'!date	"Answer the date of the receiver."	^date! !!TimeStamp methodsFor: 'accessing' stamp: 'ccn 10/6/2000 22:52'!date: aDate	"Private - set the date of the receiver."	date := aDate! !!TimeStamp methodsFor: 'accessing' stamp: 'ccn 10/6/2000 22:53'!time	"Answer the time of the receiver."	^time! !!TimeStamp methodsFor: 'accessing' stamp: 'ccn 10/6/2000 22:54'!time: aTime	"Private - set the time of the receiver."	time := aTime! !!TimeStamp methodsFor: 'arithmetic' stamp: 'ccn 10/7/2000 00:00'!minusDays: anInteger	"Answer a TimeStamp which is anInteger days before the receiver."	^self class date: (self date addDays: anInteger negated) time: self time! !!TimeStamp methodsFor: 'arithmetic' stamp: 'ccn 10/7/2000 00:03'!minusSeconds: anInteger	"Answer a TimeStamp which is anInteger number of seconds before the receiver."	^self class fromSeconds: ((self asSeconds) - anInteger)! !!TimeStamp methodsFor: 'arithmetic' stamp: 'ccn 10/7/2000 00:00'!plusDays: anInteger	"Answer a TimeStamp which is anInteger days after the receiver."	^self class date: (self date addDays: anInteger) time: self time! !!TimeStamp methodsFor: 'arithmetic' stamp: 'ccn 10/7/2000 00:02'!plusSeconds: anInteger	"Answer a TimeStamp which is anInteger number of seconds after the receiver."	^self class fromSeconds: ((self asSeconds) + anInteger)! !!TimeStamp methodsFor: 'comparing' stamp: 'ccn 10/6/2000 23:22'!< aTimeStamp	"Answer true if the receiver is less than aTimeStamp, otherwise answer false."	^self date < aTimeStamp date 		or: [self date = aTimeStamp date and: [self time < aTimeStamp time]]! !!TimeStamp methodsFor: 'comparing' stamp: 'ccn 10/6/2000 23:23'!<= aTimeStamp	"Answer true if the receiver is less than or equal to aTimeStamp, otherwise answer false."	^self date < aTimeStamp date		or: [self date = aTimeStamp date and: [self time <= aTimeStamp time]]! !!TimeStamp methodsFor: 'comparing' stamp: 'ccn 10/6/2000 23:41'!= aTimeStamp	"ccn Note:  this does not take TimeZones into account.  Some day that should be fixed..."	^self class = aTimeStamp class		and: [self date = aTimeStamp date		and: [self time = aTimeStamp time]]! !!TimeStamp methodsFor: 'comparing' stamp: 'ccn 10/6/2000 23:23'!> aTimeStamp	"Answer true if the receiver is greater than aTimeStamp, otherwise answer false."	^self date > aTimeStamp date		or: [self date = aTimeStamp date and: [self time > aTimeStamp time]]! !!TimeStamp methodsFor: 'comparing' stamp: 'ccn 10/6/2000 23:24'!>= aTimeStamp	"Answer true if the receiver is greater than or equal to aTimeStamp, otherwise answer false."	^self date > aTimeStamp date		or: [self date = aTimeStamp date and: [self time >= aTimeStamp time]]! !!TimeStamp methodsFor: 'comparing' stamp: 'ccn 10/6/2000 23:06'!hash	"Answer the Integer hash value for the receiver."	^self date hash bitXor: self time hash! !!TimeStamp methodsFor: 'converting' stamp: 'ccn 10/6/2000 23:04'!asDate	"Answer the receiver as an instance of Date."	^self date! !!TimeStamp methodsFor: 'converting' stamp: 'ccn 10/6/2000 23:25'!asSeconds	"Return the number of seconds in the receiver."	^(self date asSeconds + self time asSeconds)! !!TimeStamp methodsFor: 'converting' stamp: 'ccn 10/6/2000 23:04'!asTime	"Answer the receiver as an instance of Time."	^self time! !!TimeStamp methodsFor: 'converting' stamp: 'ccn 10/6/2000 23:33'!asTimeStamp	"Answer the receiver as an instance of TimeStamp."	^self! !!TimeStamp methodsFor: 'converting' stamp: 'ccn 10/6/2000 23:34'!dateAndTime	"Answer a two element Array containing the receiver's date and time."	^Array with: self date with: self time! !!TimeStamp methodsFor: 'printing' stamp: 'ccn 10/6/2000 23:51'!printOn: aStream	"Print receiver's date and time on aStream."	| dateString timeString |	dateString _ (self date isNil)		ifTrue: ['no date']		ifFalse: [self date printString].	timeString _ (self time isNil)		ifTrue: ['no time']		ifFalse: [self time printString].	(self date isNil and: [self time isNil])		ifTrue:			[super printOn: aStream.			aStream nextPutAll: ' '].	aStream 		nextPutAll: dateString;		nextPutAll: ', ';		nextPutAll: timeString! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/6/2000 22:59'!current	"Answer the current date and time as a TimeStamp."	| array |	array _ Time dateAndTimeNow.	^self date: array first time: array last! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/6/2000 23:00'!date: aDate time: aTime	"Answer a new instance based on the given date and time."	^self		new date: aDate;		time: aTime;		yourself! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/7/2000 00:07'!fromSeconds: anInteger	"Answer a new instance based on the given number of seconds."	| date |	date _ Date fromSeconds: anInteger.	^self date: date time: (Time fromSeconds: (anInteger - date asSeconds))! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/7/2000 00:36'!fromString: aString	"Answer a new instance for the value given by aString.	 TimeStamp fromString: '1-10-2000 11:55:00 am'. 	"	| stream |	stream := ReadStream on: aString withBlanksTrimmed.	^self 		date: (Date fromString: (stream upTo: $ )) 		time: (Time fromString: (stream upTo: nil))! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/7/2000 00:18'!midnight	"Answer a new instance that represents today at midnight."	^self midnightOn: Date today! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/7/2000 00:19'!midnightOn: aDate	"Answer a new instance that represents aDate at midnight."	^self date: aDate time: Time midnight! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/7/2000 00:16'!noon	"Answer a new instance that represents today at noon."	^self noonOn: Date today! !!TimeStamp class methodsFor: 'instance creation' stamp: 'ccn 10/7/2000 00:16'!noonOn: aDate	"Answer a new instance that represents aDate at noon."	^self date: aDate time: Time noon! !SMSqueakMap initialize!!SMDVSInstaller class reorganize!('testing' canInstall:)!"Postscript:""Register 'SqueakMap Base' 1.05 package as installed"SMSqueakMap default noteInstalledPackage:  'fffa45d3-2459-4b7d-b594-9cfae17c864d' version: '1.05'.!