'From Squeak2.8alpha of 11 February 2000 [latest update: #1919] on 20 March 2000 at 12:06:57 am'!"Change Set:		debuggerfix-tfei.csDate:			20 March 2000Author:			Paul McDonoughContext ensure: is implemented with some tricky coding that actually breaks the calling chain.  This allows the debugger to show the stack above where it was stitched.  It restores your ability to see the whole stack.  Very useful when you interrupt to see what is happening."!!ContextPart methodsFor: 'debugger access' stamp: 'tfei 3/20/2000 00:04'!stackOfSize: limit 	"Answer an OrderedCollection of the top 'limit' contexts		on the receiver's sender chain."	| a stack cachedStackTop newLimit |	stack _ OrderedCollection new.	stack addLast: (a _ self).	[(a _ a sender) ~~ nil and: [stack size < limit]]		whileTrue:			[stack addLast: a.			a cachesStack ifTrue: [cachedStackTop := a cachedStackTop]].	^cachedStackTop == nil 		ifTrue: [stack]		ifFalse:			[newLimit := limit - stack size.			newLimit > 0				ifTrue: [stack addAllLast: (cachedStackTop stackOfSize: newLimit); yourself]				ifFalse: [stack]]! !!ContextPart methodsFor: 'private-debugger' stamp: 'tfei 3/19/2000 23:24'!cachesStack	^false! !!MethodContext methodsFor: 'private-debugger' stamp: 'tfei 3/19/2000 23:55'!cachedStackTop	"WARNING - this method depends on a very dirty trick, viz. snitching information off the variable stack of a particular CompiledMethod.  So if you add/remove a temp in BlockContext>>valueUninterruptably, this method will fail, probably with some horrible consequences I'd rather not think through just now ... assumption is that the variable declaration in that method looks like:		| sendingContext result homeSender |"	^self tempAt: 3! !!MethodContext methodsFor: 'private-debugger' stamp: 'tfei 3/20/2000 00:05'!cachesStack	^self selector == #valueUninterruptably		and: [self receiver class == BlockContext]! !