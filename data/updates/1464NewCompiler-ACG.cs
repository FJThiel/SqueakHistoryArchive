'From Squeak 2.5 of August 6, 1999 on 21 September 1999 at 2:01:07 am'!CObjectAccessor subclass: #CArrayAccessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!WordArray variableWordSubclass: #ExternalData	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!ExternalData variableWordSubclass: #AEDesc	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!ExternalData variableWordSubclass: #ComponentInstance	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!ExternalData variableWordSubclass: #DescType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!Array variableSubclass: #FlippyArray2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!Object subclass: #Foo2	instanceVariableNames: 'myInteger '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!Object subclass: #InterpreterPlugin	instanceVariableNames: 'interpreterProxy '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!ExternalData variableWordSubclass: #OSAID	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!Behavior subclass: #Oop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!PluggableCodeGenerator subclass: #TestCodeGenerator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!InterpreterPlugin subclass: #TestInterpreterPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!TestInterpreterPlugin variableSubclass: #FlippyArrayPlugin2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!TestInterpreterPlugin subclass: #FooPlugin2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!TestInterpreterPlugin subclass: #TestOSAPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Werdna-Applescript'!TMethod subclass: #TestTMethod	instanceVariableNames: 'isPrimitive fullSelector fullArgs parmSpecs rcvrSpec '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!Behavior subclass: #Unsigned	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-TestPlugins'!!Object methodsFor: 'translation support' stamp: 'acg 9/19/1999 20:39'!asIf: aClass var: aString	|index|	index _ aClass allInstVarNames 		indexOf: aString		ifAbsent: [self error: 'must use instVar name'].	^self instVarAt: index! !!Object methodsFor: 'translation support' stamp: 'acg 9/19/1999 20:40'!asIf: aClass var: aString put: aValue	|index|	index _ aClass allInstVarNames 		indexOf: aString		ifAbsent: [self error: 'must use instVar name'].	^self instVarAt: index put: aValue! !!Object methodsFor: 'translation support' stamp: 'acg 9/20/1999 11:30'!asOop: aClass	(self class isVariable and: [self class instSize > 0])		ifTrue: [self error: 'cannot auto-coerce indexable objects with named instance variables'].	(aClass ccgCanConvertFrom: self)		ifFalse: [self error: 'incompatible object for this coercion'].	^self! !!Object methodsFor: 'translation support' stamp: 'acg 9/19/1999 20:21'!asSmallIntegerObj	^self! !!Object methodsFor: 'translation support' stamp: 'acg 9/19/1999 11:51'!primitive: primID parameters: parmSpecs receiver: rcvrSpec	| tMethod |	tMethod _ TestTMethod new 		fromContext: thisContext sender 		primitive: primID 		parameters: parmSpecs 		receiver: rcvrSpec.	^tMethod simulatePrologInContext: thisContext sender! !!CObjectAccessor methodsFor: 'converting' stamp: 'acg 9/20/1999 11:08'!asOop: aClass	(aClass ccgCanConvertFrom: object)		ifFalse: [^self error: 'incompatible object for autocoercion'].	^object! !!CArrayAccessor methodsFor: 'accessing' stamp: 'acg 9/19/1999 01:50'!cPtrAsOop	offset = 0 ifFalse: [self error: 'offset must be zero'].	^object! !!CArrayAccessor methodsFor: 'accessing' stamp: 'acg 9/19/1999 01:48'!next	|val|	val _ self at: 0.	offset _ offset + 1.	^val! !!CArrayAccessor methodsFor: 'accessing' stamp: 'acg 9/19/1999 01:46'!size	^object size! !!ExternalData commentStamp: 'acg 9/12/1999 17:54' prior: 0!I am a collection of word-aligned external data!!ExternalData reorganize!('accessing' at:put: byteAt: byteAt:put: fourBytesAt: fourBytesAt:put: handleSizeAt:)('printing' printAt:on: printOn:)('private' primGetHandleSize:)!!ExternalData methodsFor: 'accessing' stamp: 'acg 9/12/1999 17:24'!at: index put: datum	datum >= 0 ifTrue: [^super at: index put: datum].			^super at: index put: (16rFFFFFFFF + datum + 1)! !!ExternalData methodsFor: 'accessing' stamp: 'acg 9/12/1999 17:20'!byteAt: anInteger	| loc offset |	loc _ ((anInteger-1) // 4) + 1.	offset _ 24 - (8*((anInteger-1) \\ 4)).	^ ((self at: loc) >> offset) bitAnd: 16rFF! !!ExternalData methodsFor: 'accessing' stamp: 'acg 9/12/1999 17:47'!byteAt: index put: datum	| loc offset val |	(datum > 255 or: [datum<0]) ifTrue: [^self error: 'not a byte quantity'].	loc _ ((index-1) // 4) + 1.	offset _ 24 - (8*((index-1) \\ 4)).	val _ ((16rFF << offset) bitInvert32) bitAnd: (self at: loc).	val _ val bitOr: (datum<<offset).	^super at: loc put: val! !!ExternalData methodsFor: 'accessing' stamp: 'acg 9/12/1999 17:56'!fourBytesAt: anInteger	"Answer a string corresponding to the word at anInteger, in accordance with Apple's four byte code convention"	| val |	val _ self at: anInteger.	^String streamContents: [:aStream |		(3 to: 0 by: -1) do: [:i |			aStream nextPut: (((val >> (i*8)) bitAnd: 16rFF) asCharacter)]]	! !!ExternalData methodsFor: 'accessing' stamp: 'acg 9/12/1999 17:56'!fourBytesAt: anInteger put: aString	"Store a word corresponding to Apple's four byte code convention at anIntger"	| str |	aString size > 4 ifTrue: [^self error: 'string too long'].	str _ aString padded: #right to: 4 with: $ .	self at: anInteger put: 		(str inject: 0 into: [:val :each | val * 256 + each asciiValue])! !!ExternalData methodsFor: 'accessing' stamp: 'acg 9/12/1999 21:31'!handleSizeAt: anInteger	(anInteger < 1 or: [anInteger> self size]) ifTrue: 		[self error: 'invalid index'].	^self primGetHandleSize: anInteger - 1! !!ExternalData methodsFor: 'printing' stamp: 'acg 9/12/1999 17:55'!printAt: index on: aStream	aStream 		nextPutAll: (self at: index) hex8;		nextPutAll: '(''';		nextPutAll: (self fourBytesAt: index);		nextPutAll: ''')'! !!ExternalData methodsFor: 'printing' stamp: 'acg 9/20/1999 11:56'!printOn: aStream	aStream 		nextPutAll: self species asString;		nextPutAll: '('.	(1 to: self size)		do: [:i | self printAt: i on: aStream]		separatedBy: [aStream nextPutAll: '; '].	aStream nextPut: $)! !!ExternalData methodsFor: 'private' stamp: 'acg 9/20/1999 13:54'!primGetHandleSize: anIndex	<primitive: 'primGetHandleSize' module: 'TestOSAPlugin'>	TestOSAPlugin 		doPrimitive: 'primGetHandleSize'		withArguments: {anIndex}! !!AEDesc reorganize!('as yet unclassified' asString asStringThenDispose dataSize dispose)('private' createFromText: primAECreateDesc:from: primAEDescToString: primAEDisposeDesc)!!AEDesc methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:19'!asString	| theSize |	((self at: 1) ~= 16r54455854) ifTrue:		[^self error: 'AEDesc is not of type ''TEXT'''].	(theSize _ self dataSize) < 0 ifTrue: [^self error: 'Invalid size for data'].	^self primAEDescToString: (String new: theSize).! !!AEDesc methodsFor: 'as yet unclassified' stamp: 'acg 9/21/1999 00:13'!asStringThenDispose	| string |	string _ self asString.	self dispose.	^string! !!AEDesc methodsFor: 'as yet unclassified' stamp: 'acg 9/12/1999 21:33'!dataSize	^self handleSizeAt: 2! !!AEDesc methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:22'!dispose	(0 = (self at: 2)) ifTrue:		[self error: 'cannot dispose of unallocated space'].	self primAEDisposeDesc isZero ifFalse: 		[self error: 'dispose operation failed'].	self at: 1 put: 0.	self at: 2 put: 0.	^nil! !!AEDesc methodsFor: 'private' stamp: 'acg 9/20/1999 14:39'!createFromText: aString	(aString class = String) ifFalse:		[^self error: 'TextType Data Not From String'].	(self 		primAECreateDesc: (DescType of: 'TEXT')		from: aString) isZero ifTrue: [^self].	self error: 'failed to create aeDesc'.	^nil! !!AEDesc methodsFor: 'private' stamp: 'acg 9/20/1999 13:25'!primAECreateDesc: typeCode from: aString	<primitive: 'primAECreateDesc' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primAECreateDesc:from:'			withArguments: {typeCode. aString}! !!AEDesc methodsFor: 'private' stamp: 'acg 9/20/1999 13:27'!primAEDescToString: aString	<primitive: 'primAEDescToString' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primAEDescGetData:'		withArguments: {aString}! !!AEDesc methodsFor: 'private' stamp: 'acg 9/20/1999 13:28'!primAEDisposeDesc	<primitive: 'primAEDisposeDesc' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primAEDisposeDesc'		withArguments: {}! !Smalltalk renameClassNamed: #OSAComponent as: #ComponentInstance!!ComponentInstance commentStamp: 'acg 9/21/1999 00:50' prior: 0!c _ ComponentInstance newc scriptingName 'Generic Scripting System'"A mandatory first script"c doScript: '3 + 4'"A script that beeps 4 times"c doScript: 'beep 4'"A script that shows a button display"c doScript: 'display dialog "The Mouse that Roars!!" ',	'buttons {"One", "Two", "Three"} default button "One"'"A script that engages in a (very) little dialog"c doScript: 'display dialog "Enter a number between 1 and 10." default answer ""set userValue to {text returned of result} as realif (userValue < 1) or (userValue > 10) then	display dialog "That Value is out of range." buttons {"OK"} default button 1else 	display dialog "Thanks for playing." buttons {"OK"} default button 1end if'"Apple's Select a file dialog"c doScript: '(choose file with prompt "Hi guys!!" of type "TEXT") as string'"Apple's Select a folder dialog"c doScript: '(choose folder with prompt "Hi guys!!") as string'"Open Microsoft's Web Browser to a proper page"c doScript: 'tell application "Internet Explorer"	activate	openURL "http://www.squeak.org"end tell'!!ComponentInstance reorganize!('category name' doScript: doScript:in:mode: scriptingName)('sample scripts' beep: browse: mandatoryDemo selectFile selectFolder sillyButtons sillyDialog)('private' openNewGenericComponent primOSACompile:mode:to: primOSADisplay:as:mode:to: primOSADispose: primOSADoScript:in:mode:resultType:to: primOSAExecute:in:mode:to: primOSAScriptingComponentNameTo: primOpenDefaultConfiguration:subtype:)!!ComponentInstance methodsFor: 'category name' stamp: 'acg 9/21/1999 01:06'!doScript: aString	"Answer text result of compiling script in null context"	^self doScript: aString in: OSAID new mode: 0	"Examples:"	"ComponentInstance new doScript: 'beep 7'"! !!ComponentInstance methodsFor: 'category name' stamp: 'acg 9/21/1999 01:04'!doScript: aString in: contextOSAID mode: anInteger	"Answer text result of executing Applescript aString in context contexOSAID in mode: anInteger"	| source object result |	source _ AEDesc textTypeOn: aString.	object _ AEDesc new.	result _ self			primOSADoScript: source		in: contextOSAID		mode: anInteger		resultType: (DescType of: 'TEXT')		to: object.	source dispose.	result isZero ifFalse: [self error: 'operation failed: ', result asString].	^object asStringThenDispose! !!ComponentInstance methodsFor: 'category name' stamp: 'acg 9/21/1999 00:14'!scriptingName"Answer the name of my generic scripting component"	|aeDesc result |	aeDesc _ AEDesc new.	result _ self primOSAScriptingComponentNameTo: aeDesc.	result isZero ifFalse: 		[^self error: 'can''t load scripting name: ', result asString].	^aeDesc asStringThenDispose.! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:42'!beep: anInteger	"Beep n times"	^self doScript: 'beep ', anInteger asString! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:42'!browse: anUrl	"Open Microsoft's Web Browser to a page"		^self doScript: 'tell application "Internet Explorer"		activate		openURL "', anUrl, '"	end tell'! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:42'!mandatoryDemo	"A mandatory first script"	^self doScript: '3 + 4'! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:43'!selectFile	"Harness Apple's select file dialog for Squeak"	^self doScript: '(choose file with prompt "Hi guys!!" of type "TEXT") as string'! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:43'!selectFolder	"Harness Apple's select Folder dialog for Squeak"	^self doScript: '(choose folder with prompt "Hi guys!!") as string'! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:44'!sillyButtons	"A silly Apple GUI demo"	self doScript: '		display dialog "The Mouse that Roars!!" ',			'buttons {"One", "Two", "Three"} default button "One"'! !!ComponentInstance methodsFor: 'sample scripts' stamp: 'acg 9/21/1999 01:45'!sillyDialog	"A silly Apple GUI demo"	self doScript: 'display dialog "Enter a number between 1 and 10." default answer ""set userValue to {text returned of result} as realif (userValue < 1) or (userValue > 10) then	display dialog "That Value is out of range." buttons {"OK"} default button 1else 	display dialog "Thanks for playing." buttons {"OK"} default button 1end if'! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 23:49'!openNewGenericComponent"Associate this object instance with an instance of the generic scripting component.  Answer self."	self 		primOpenDefaultConfiguration: (DescType of: 'osa ')		subtype: (DescType of: 'scpt')! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:48'!primOSACompile: source mode: mode to: object	<primitive: 'primOSACompile' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSACompile:mode:to:'		withArguments: {source. mode. object}! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:48'!primOSADisplay: source as: type mode: mode to: result	<primitive: 'primOSADisplay' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSADisplay:as:mode:to:'		withArguments: {source. type. mode. result}! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:56'!primOSADispose: anOSAID	<primitive: 'primOSADispose' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSADispose:'		withArguments: {anOSAID}! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:57'!primOSADoScript: source in: context mode: mode resultType: type to: result	<primitive: 'primOSADoScript' module: 'TestOSAPlugin'>	^TestOSAPlugin		doPrimitive: 'primOSADoScript:in:mode:resultType:to:'		withArguments: {source. context. mode. type. result}! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:57'!primOSAExecute: script in: context mode: mode to: result	<primitive: 'primOSAExecute' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAExecute:in:mode:to:'		withArguments: { script. context. mode. result }! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:54'!primOSAScriptingComponentNameTo: anAEDesc	<primitive: 'primOSAScriptingComponentName' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOSAScriptingComponentNameTo:'		withArguments: {anAEDesc}! !!ComponentInstance methodsFor: 'private' stamp: 'acg 9/20/1999 21:55'!primOpenDefaultConfiguration: type subtype: subtype	<primitive: 'primOpenDefaultConfiguration' module: 'TestOSAPlugin'>	^TestOSAPlugin 		doPrimitive: 'primOpenDefaultConfiguration:subtype:'		withArguments: {type. subtype}! !!DescType methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:36'!printOn: aStream	aStream 		nextPutAll: self species asString;		nextPutAll: '(''';		nextPutAll: (self fourBytesAt: 1);		nextPutAll: ''')'! !!FlippyArray2 methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 08:22'!reverse	<primitive: 'primReverse' module: 'FlippyArrayPlugin2'>	^FlippyArrayPlugin2		doPrimitive: 'primReverse'		withArguments: {}! !!FlippyArray2 methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 08:24'!reverseFrom: x to: y	<primitive: 'primReverseFromto' module: 'FlippyArrayPlugin2'>	^FlippyArrayPlugin2 		doPrimitive: 'primReverseFrom:to:'		withArguments: {x. y}! !!Foo2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 20:31'!myInteger: anInteger	^myInteger _ anInteger! !!Foo2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 20:55'!primFooIntegerIdentity: x	<primitive: 'primFooIntegerIdentity' module: 'FooPlugin2'>	^"FooPlugin2 		doPrimitive: 'primFooIntegerIdentity:'		withArguments: {x}" 'Whoops!!'! !!Foo2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 20:55'!primFooIntegerSeventeen	<primitive: 'primFooIntegerSeventeen' module: 'FooPlugin2'>	^"FooPlugin2 		doPrimitive: 'primFooIntegerSeventeen'		withArguments: {}" 'Whoops!!'! !!Foo2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 20:55'!primFooIntegerSumAnd: x with: y	<primitive: 'primFooIntegerSumAnd' module: 'FooPlugin2'>	^"FooPlugin2 		doPrimitive: 'primFooIntegerSumAnd:with:'		withArguments: {x . y}" 'Whoops!!'! !!Foo2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 20:56'!primFooIntegerSumWith: x	<primitive: 'primFooIntegerSumWith' module: 'FooPlugin2'>	^"FooPlugin2 		doPrimitive: 'primFooIntegerSumWith:'		withArguments: {x}" 'Whoops!!'! !!InterpreterProxy methodsFor: 'testing' stamp: 'acg 9/19/1999 13:11'!isIndexable: oop	^oop class isVariable! !!ListController methodsFor: 'menu messages' stamp: 'acg 9/18/1999 14:09'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !!MethodNode methodsFor: 'C translation' stamp: 'acg 9/16/1999 19:48'!asTestTMethodFromClass: aClass 	^ TestTMethod new		setSelector: selectorOrFalse		args: arguments		locals: encoder tempsAndBlockArgs		block: block		primitive: primitive! !!OSAID methodsFor: 'as yet unclassified' stamp: 'acg 9/21/1999 00:05'!initialize	self at: 1 put: 0! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:05'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asNakedOopFrom: anInteger on: aStream! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 13:01'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 16:09'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asKindOf: self from: anInteger! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:12'!ccgCanConvertFrom: anObject	^anObject isKindOf: self! !!Object class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 00:19'!ccgDeclareCForVar: aSymbolOrString	^'int ', aSymbolOrString! !!ArrayedCollection class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 10:03'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	self instSize > 0 ifTrue: 		[self error: 'cannot auto-coerce arrays with named instance variables'].	cg generateCoerceToObjectFromPtr: aNode on: aStream! !!Array class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:12'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asIntPtrFrom: anInteger on: aStream! !!Array class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 13:10'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asIntPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isIndexable')! !!Array class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:12'!ccgDeclareCForVar: aSymbolOrString	^'int *', aSymbolOrString! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:06'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asBooleanValueFrom: anInteger on: aStream ! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 09:44'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToBooleanFrom: aNode on: aStream! !!Boolean class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:08'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asBooleanValueFrom: anInteger! !!ByteArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:13'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asCharPtrFrom: anInteger on: aStream! !!ByteArray class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 00:25'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isBytes')! !!ByteArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:13'!ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:08'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString floatValueFrom: anInteger on: aStream! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 09:45'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToFloatFrom: aNode on: aStream! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:08'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asFloatValueFrom: anInteger! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:22'!ccgCanConvertFrom: anObject	^anObject class == self! !!Float class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:09'!ccgDeclareCForVar: aSymbolOrString	^'double ', aSymbolOrString! !!FloatArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:17'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asFloatPtrFrom: anInteger on: aStream! !!FloatArray class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:07'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asWBFloatPtrFrom: anInteger! !!FloatArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:14'!ccgDeclareCForVar: aSymbolOrString	^'float *', aSymbolOrString! !!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:17'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asIntPtrFrom: anInteger on: aStream! !!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 00:25'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isWords')! !!IntegerArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:18'!ccgDeclareCForVar: aSymbolOrString	^'int *', aSymbolOrString! !!Oop class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 13:02'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg emitCExpression: aNode on: aStream! !!Oop class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 15:58'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asRawOopFrom: anInteger! !!Oop class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:17'!ccgCanConvertFrom: anObject	^(anObject isKindOf: SmallInteger) not! !!Oop class methodsFor: 'plugin generation' stamp: 'acg 9/16/1999 21:53'!ccgDeclareCForVar: aSymbolOrString	^'int ', aSymbolOrString! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 09:46'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToSmallIntegerFrom: aNode on: aStream! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:09'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asIntegerValueFrom: anInteger! !!SmallInteger class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 11:20'!ccgCanConvertFrom: anObject	^anObject class == self! !!String methodsFor: 'converting' stamp: 'acg 9/11/1999 15:43'!asFourCode	|result|	self size = 4 ifFalse: [^self error: 'must be exactly four characters'].	result _ self inject: 0 into: [:val :each | 256 * val + each asciiValue].	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^result! !!String class methodsFor: 'plugin generation' stamp: 'acg 9/19/1999 00:21'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asCharPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isBytes')! !!String class methodsFor: 'plugin generation' stamp: 'acg 9/18/1999 17:10'!ccgDeclareCForVar: aSymbolOrString	^'char *', aSymbolOrString! !!TestCodeGenerator methodsFor: 'as yet unclassified' stamp: 'acg 9/16/1999 19:49'!addClass: aClass	"Add the variables and methods of the given class to the code base."	| source |	self checkClassForNameConflicts: aClass.	aClass classPool associationsDo: [ :assoc |		constants at: assoc key put: (TConstantNode new setValue: assoc value).	].	"ikp..."	aClass sharedPools do: [:pool |		pool associationsDo: [ :assoc |			constants at: assoc key put: (TConstantNode new setValue: assoc value).		].	].	variables addAll: aClass instVarNames.'Adding Class ' , aClass name , '...'displayProgressAt: Sensor cursorPointfrom: 0 to: aClass selectors sizeduring: [:bar |	aClass selectors doWithIndex: [ :sel :i | bar value: i.		source _ aClass sourceCodeAt: sel.		self addMethod: ((Compiler new parse: source in: aClass notifying: nil) asTestTMethodFromClass: aClass).	]].! !!TestCodeGenerator methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 02:48'!codeStringForPrimitives: classAndSelectorList	| sel aClass source s verbose meth |	self initialize.	classAndSelectorList do: [:classAndSelector |		aClass _ Smalltalk at: (classAndSelector at: 1).		self addClassVarsFor: aClass.		sel _ classAndSelector at: 2.		(aClass includesSelector: sel)			ifTrue: [source _ aClass sourceCodeAt: sel]			ifFalse: [source _ aClass class sourceCodeAt: sel].		meth _ ((Compiler new parse: source in: aClass notifying: nil)				asTestTMethodFromClass: aClass).		meth primitive > 0 ifTrue: [meth preparePrimitiveInClass: aClass].		"for old-style array accessing:			meth covertToZeroBasedArrayReferences."		meth replaceSizeMessages.		self addMethod: meth].	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr].	"code generation"	self doInlining: true.	s _ ReadWriteStream on: (String new: 1000).	methods _ methods asSortedCollection: [:m1 :m2 | m1 selector < m2 selector].	self emitCHeaderForPrimitivesOn: s.	self emitCVariablesOn: s.	self emitCFunctionPrototypesOn: s.	methods do: [:m | m emitCCodeOn: s generator: self].	^ s contents! !!TestCodeGenerator methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 10:01'!nameOrValue: aNode	aNode isVariable ifTrue: [^aNode name].	aNode isConstant ifTrue: [^aNode value].	self error: 'object is neither variable nor constant'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:43'!emitLoad: aString asBooleanValueFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: ' = interpreterProxy->booleanValueOf(';		crtab: 2;		nextPutAll: 'interpreterProxy->stackValue(';		nextPutAll: anInteger asString;		nextPutAll: '))'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:43'!emitLoad: aString asCharPtrFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = (char *) interpreterProxy->firstIndexableField(';		crtab: 2;		nextPutAll: 	'interpreterProxy->stackValueOf(';		nextPutAll: anInteger asString;		nextPutAll: '))'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:43'!emitLoad: aString asFloatPtrFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = (float *) interpreterProxy->firstIndexableField(';		crtab: 2;		nextPutAll: 	'interpreterProxy->stackValueOf(';		nextPutAll: anInteger asString;		nextPutAll: '))'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:43'!emitLoad: aString asFloatValueFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = interpreterProxy->stackFloatValue(';		nextPutAll: anInteger asString;		nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:43'!emitLoad: aString asIntPtrFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = (int *) interpreterProxy->firstIndexableField(';		crtab: 2;		nextPutAll: 	'interpreterProxy->stackValueOf(';		nextPutAll: anInteger asString;		nextPutAll: '))'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:43'!emitLoad: aString asIntegerValueFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = interpreterProxy stackIntegerValue(';		nextPutAll: anInteger asString;		nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:42'!emitLoad: aString asKindOf: aClass from: anInteger on: aStream	self emitLoad: aString asNakedOopFrom: anInteger on: aStream.	aStream		crtab;		nextPutAll: 'interpreterProxy->success(interpreterProxy->isKindOf(';		nextPutAll: aString;		nextPutAll: 	', ''';		nextPutAll:	aClass asString;		nextPutAll: '''))'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:02'!emitLoad: aString asMemberOf: aClass from: anInteger on: aStream	self emitLoad: aString nakedOopFrom: anInteger on: aStream.	aStream		crtab;		nextPutAll: 'interpreterProxy->success(interpreterProxy->isMemberOf(';		nextPutAll: aString;		nextPutAll: 	', ''';		nextPutAll:	aClass asString;		nextPutAll: '''))'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/18/1999 14:23'!emitLoad: aString asNakedOopFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: ' = interpreterProxy stackValue(';		nextPutAll: anInteger asString;		nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:44'!emitLoad: aString asNonIntegerValueFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = interpreterProxy stackObjectValue(';		nextPutAll: anInteger asString;		nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C linkage' stamp: 'acg 9/17/1999 01:44'!emitLoad: aString asUnsignedValueFrom: anInteger on: aStream	aStream		nextPutAll: aString;		nextPutAll: 	' = interpreterProxy->positive32BitValueOf(';		crtab: 2;		nextPutAll: 	'interpreterProxy->stackValue(';		nextPutAll: anInteger asString;		nextPutAll: '))'! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 15:19'!ccgLoad: aBlock expr: aString asBooleanValueFrom: anInteger	"Answer boolean coercion (with validating side-effect) of object, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy booleanValueOf:';		crtab: 2;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	')'])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 23:41'!ccgLoad: aBlock expr: aString asCharPtrFrom: anInteger	"Answer character pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/19/1999 14:01'!ccgLoad: aBlock expr: aString asCharPtrFrom: anInteger andThen: valBlock	"Answer character pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''char *''']))	 ! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 15:43'!ccgLoad: aBlock expr: aString asFloatValueFrom: anInteger	"Answer double precision coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackFloatValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 23:41'!ccgLoad: aBlock expr: aString asIntPtrFrom: anInteger	"Answer integer pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/19/1999 14:02'!ccgLoad: aBlock expr: aString asIntPtrFrom: anInteger andThen: valBlock	"Answer integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''int *''']))! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 15:43'!ccgLoad: aBlock expr: aString asIntegerValueFrom: anInteger	"Answer integer coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackIntegerValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/19/1999 20:28'!ccgLoad: aBlock expr: aString asKindOf: aClass from: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: (interpreterProxy stackValue: ';		nextPutAll: anInteger asString;		nextPutAll: ')';		crtab: 2;		nextPutAll: 	'KindOf: ''';		nextPutAll:	aClass asString;		nextPutAll: ''').';		crtab;		nextPutAll: (self 						ccgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/19/1999 20:28'!ccgLoad: aBlock expr: aString asMemberOf: aClass from: anInteger	^String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy success: (interpreterProxy';		crtab: 2;		nextPutAll: 'is: (interpreterProxy stackValue: ';		nextPutAll: anInteger asString;		nextPutAll: ')';		crtab: 2;		nextPutAll: 	'MemberOf: ''';		nextPutAll:	aClass asString;		nextPutAll: ''').';		crtab;		nextPutAll: (self 						ccgLoad: aBlock 						expr: aString 						asRawOopFrom: anInteger)]! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 12:10'!ccgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger	"Answer integer pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *'''])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 22:12'!ccgLoad: aBlock expr: exprString asNamedPtr: recordString from: anInteger andThen: valBlock	"Answer integer pointer to first indexable field of object (without validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''';		nextPutAll: recordString;		nextPutAll: ' *''']))! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 15:39'!ccgLoad: aBlock expr: aString asNonIntegerValueFrom: anInteger	"Answer oop (with validating side effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackObjectValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 15:42'!ccgLoad: aBlock expr: aString asRawOopFrom: anInteger	"Answer a string for a Slang expression that will load an oop (without validation) from stack index anInteger.  aBlock is a BlockContext instance that when passed an expression, will return a string assigning the expression to the desired value.  aString is a Slang expression that refers to the stack value, once it has been loaded."	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy stackValue: ';		nextPutAll: anInteger asString])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 13:16'!ccgLoad: aBlock expr: aString asUnsignedPtrFrom: anInteger andThen: valBlock	"Answer integer pointer to first indexable field of object (without validating side-effect unless specified in valBlock), as described in comment to ccgLoad:expr:asRawOopFrom:"	^(valBlock value: anInteger), '.',	 (aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy firstIndexableField:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''unsigned *''']))! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 15:43'!ccgLoad: aBlock expr: aString asUnsignedValueFrom: anInteger	"Answer positive integer coercion (with validating side-effect) of oop, as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'interpreterProxy positive32BitValueOf:';		crtab: 2;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	')'])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 23:41'!ccgLoad: aBlock expr: aString asWBCharPtrFrom: anInteger	"Answer char pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''char *'''])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 23:41'!ccgLoad: aBlock expr: aString asWBFloatPtrFrom: anInteger	"Answer single-precision float pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''float *'''])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 23:41'!ccgLoad: aBlock expr: aString asWBIntPtrFrom: anInteger	"Answer integer pointer to first indexable field of object (with validating side-effect), as described in comment to ccgLoad:expr:asRawOopFrom:"	^aBlock value: (String streamContents: [:aStream | aStream		nextPutAll: 'self cCoerce: (interpreterProxy arrayValueOf:';		crtab: 4;		nextPutAll: '(interpreterProxy stackValue:';		nextPutAll: anInteger asString;		nextPutAll:	'))';		crtab: 3;		nextPutAll: 'to: ''int *'''])! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/18/1999 14:27'!ccgSetBlock: aString	^[:expr | aString, ' _ ', expr]! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/19/1999 13:05'!ccgTVarBlock: anInteger	^[:expr | '(thisContext tempAt: 1) tempAt: ', anInteger asString, ' put: (', expr, ')']! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 08:35'!ccgValBlock: valString	^[:index | String streamContents:		[:aStream | aStream			nextPutAll: 'interpreterProxy success: (interpreterProxy ';			nextPutAll: valString;			nextPutAll: ': (interpreterProxy stackValue: ';			nextPutAll: index asString;			nextPutAll: '))']]! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 09:31'!generateCoerceToBooleanFrom: aNode on: aStream	aStream nextPutAll: '('.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: '? interpreterProxy->trueObject: interpreterProxy->falseObject)'! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 09:34'!generateCoerceToFloatFrom: aNode on: aStream	aStream nextPutAll: 'interpreterProxy->floatObjectOf('.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 23:44'!generateCoerceToObjectFromPtr: aNode on: aStream	"This code assumes no named instance variables"	aStream nextPutAll: '((int) '.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: ') - 4'! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 09:36'!generateCoerceToSmallIntegerFrom: aNode on: aStream	aStream nextPutAll: 'interpreterProxy->integerObjectOf('.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C linkage new' stamp: 'acg 9/20/1999 09:35'!generateCoerceToUnsignedFrom: aNode on: aStream	aStream nextPutAll: 'interpreterProxy->positive32BitIntegerFor('.	self emitCExpression: aNode on: aStream.	aStream nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:08'!generateAsBooleanObj: aNode on: aStream indent: anInteger	aStream nextPutAll: '('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: 		') ? interpreterProxy->trueObject(): interpreterProxy->falseObject()'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:09'!generateAsCBoolean: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->booleanValueOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:09'!generateAsCDouble: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->floatValueOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 21:53'!generateAsCInt: aNode on: aStream indent: anInteger	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ' >> 1'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:09'!generateAsCUnsigned: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->positive32BitValueOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:10'!generateAsCharPtr: aNode on: aStream indent: anInteger	aStream nextPutAll: '(char *) interpreterProxy->firstIndexableField('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:10'!generateAsFloatObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->floatObjectOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 23:37'!generateAsIfVar: aNode on: aStream indent: anInteger	| cName fName class index |	cName _ String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	fName _ aNode args second value.	index _ class instVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	aStream 		nextPutAll: 'interpreterProxy->fetchPointerofObject(';		nextPutAll: (index - 1) asString;		nextPutAll: ','.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 23:40'!generateAsIfVarPut: aNode on: aStream indent: anInteger	| cName fName class index |	cName _ String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	fName _ aNode args second value.	index _ class instVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	aStream 		nextPutAll: 'interpreterProxy->storePointerofObjectwithValue(';		nextPutAll: (index - 1) asString;		nextPutAll: ','.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode args third on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:10'!generateAsIntPtr: aNode on: aStream indent: anInteger	aStream nextPutAll: '(int *) interpreterProxy->firstIndexableField('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/20/1999 10:02'!generateAsOop: aNode on: aStream indent: anInteger	| cName class |	cName _ self nameOrValue: aNode args first.	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	class ccg: self generateCoerceToOopFrom: aNode receiver on: aStream! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:10'!generateAsPositiveIntegerObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->positive32BitIntegerFor('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 20:47'!generateAsSmallIntegerObj: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->integerObjectOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 01:41'!generateCPtrAsOop: aNode on: aStream indent: anInteger	aStream nextPutAll: '(int) (('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: '-4))'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:11'!generateClass: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->fetchClassOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:11'!generateField: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->fetchPointerofObject('.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 23:40'!generateFieldPut: aNode on: aStream indent: anInteger			aStream nextPutAll: 'interpreterProxy->storePointerofObjectwithValue('.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode args second on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/16/1999 08:02'!generateFromStack: aNode on: aStream indent: anInteger	| idList |	aNode args first isConstant ifFalse: [^self error: 'arg must be constant'].	idList _ aNode args first value.	(1 to: idList size)		do: [:i | 			aStream 				nextPutAll: (idList at: i);				nextPutAll: ' = interpreterProxy->stackValue(';				nextPutAll: (idList size - i) asString;				nextPutAll: ')']		separatedBy: [aStream nextPut: $;; crtab: anInteger].! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 20:50'!generateIsBytes: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isBytes('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 20:50'!generateIsFloat: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isFloatObject('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 20:49'!generateIsIndexable: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isIndexable('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 20:49'!generateIsInteger: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isIntegerValue('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:13'!generateIsIntegerOop: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isIntegerObject('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:13'!generateIsIntegerValue: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isIntegerValue('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:20'!generateIsKindOf: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isKindOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','''.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ''')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:20'!generateIsMemberOf: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isMemberOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','''.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ''')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:14'!generateIsPointers: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isPointers('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:14'!generateIsWords: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isWords('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:13'!generateIsWordsOrBytes: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->isWordsOrBytes('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 01:56'!generateNext: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'next can only be applied to variables' ].	aStream nextPutAll: '*'.	aStream nextPutAll: varNode name.	aStream nextPutAll: '++'! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:15'!generateStAt: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->stObjectat('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/15/1999 22:17'!generateStAtPut: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->stObjectatput('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode args first on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode args second on: aStream.	aStream nextPutAll: ')'! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/19/1999 01:16'!generateStSize: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->stSize('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'C translation' stamp: 'acg 9/20/1999 08:57'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	super initializeCTranslationDictionary.	pairs _ #(		#asCInt						#generateAsCInt:on:indent:		#asCUnsigned				#generateAsCUnsigned:on:indent:		#asCBoolean					#generateAsCBoolean:on:indent:		#asCDouble					#generateAsCDouble		#asSmallIntegerObj			#generateAsSmallIntegerObj:on:indent:		#asPositiveIntegerObj		#generateAsPositiveIntegerObj:on:indent:		#asBooleanObj				#generateAsBooleanObj:on:indent:		#asFloatObj					#generateAsFloatObj:on:indent:		#asIf:var:					#generateAsIfVar:on:indent:		#asIf:var:put:				#generateAsIfVarPut:on:indent:		#field:						#generateField:on:indent:		#field:put:					#generateFieldPut:on:indent:				#class						#generateClass:on:indent:		#stSize						#generateStSize:on:indent:		#stAt:						#generateStAt:on:indent:		#stAt:put:					#generateStAtPut:on:indent:		#asCharPtr					#generateAsCharPtr:on:indent:		#asIntPtr					#generateAsIntPtr:on:indent:		#cPtrAsOop					#generateCPtrAsOop:on:indent:		#next						#generateNext:on:indent:		#asOop:						#generateAsOop:on:indent:		#isFloat						#generateIsFloat:on:indent:		#isIndexable					#generateIsIndexable:on:indent:		#isIntegerOop				#generateIsIntegerOop:on:indent:		#isIntegerValue				#generateIsIntegerValue:on:indent:		#FloatOop					#generateIsFloatValue:on:indent:		#isWords					#generateIsWords:on:indent:		#isWordsOrBytes				#generateIsWordsOrBytes:on:indent:		#isPointers					#generateIsPointers:on:indent:		#isNil						#generateIsNil:on:indent:		#isMemberOf:				#generateIsMemberOf:on:indent:		#isKindOf:					#generateIsKindOf:on:indent:		#fromStack:					#generateFromStack:on:indent:		#clone						#generateClone:on:indent		#new						#generateNew:on:indent		#new:						#generateNewSize:on:indent		#superclass					#generateSuperclass:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!FlippyArrayPlugin2 commentStamp: 'acg 9/20/1999 08:17' prior: 0!FlippyArrayPlugin2 translateSmalltalk garbageCollect!!FlippyArrayPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 10:08'!primReverse	| rcvr t a b |	rcvr _ self 		primitive:	'primReverse'		parameters:	#()		receiver:	#Array.	a _ 0. b _ rcvr size - 1.	[a < b] whileTrue:		[t _ rcvr at: a.		 rcvr at: a put: (rcvr at: b).		 rcvr at: b put: t.		 a _ a + 1. b _ b - 1].	^rcvr asOop: #Array! !!FlippyArrayPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 09:52'!primReverseFrom: fromInteger to: toInteger	| rcvr t a b |	rcvr _ self		primitive:	'primReverseFromto'		parameters:	#(SmallInteger SmallInteger)		receiver:	#Array.	a _ fromInteger - 1. b _ toInteger - 1.	[a < b] whileTrue:		[t _ rcvr at: a.		 rcvr at: a put: (rcvr at: b).		 rcvr at: b put: t.		 a _ a + 1. b _ b - 1].	^rcvr asOop: Array! !!FooPlugin2 commentStamp: 'acg 9/19/1999 00:47' prior: 0!FooPlugin2 translate!!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 20:29'!primFooIntegerIdentity: x	|rcvr|	rcvr _ self 		primitive: 	'primFooIntegerIdentity'		parameters: #(SmallInteger)		receiver: 	#Foo2.	^ x asSmallIntegerObj! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 00:47'!primFooIntegerSeventeen	self primitive: 'primFooIntegerSeventeen'		parameters: #()		receiver: #Oop.	^ 17 asSmallIntegerObj! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 00:45'!primFooIntegerSumAnd: x with: y	self 		primitive: 	'primFooIntegerSumAnd'		parameters: #(SmallInteger SmallInteger)		receiver: 	#Oop.	^ x + y! !!FooPlugin2 methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 21:02'!primFooIntegerSumWith: x	|rcvr myInteger|	rcvr _ self 		primitive: 	'primFooIntegerSumWith'		parameters: #(SmallInteger)		receiver: 	#Foo2.	myInteger _ (rcvr asIf: Foo2 var: 'myInteger') asCInt.	^ (x + myInteger) asSmallIntegerObj! !!TestInterpreterPlugin class methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 14:09'!doPrimitive: primitiveName withArguments: argArray	| proxy plugin |	proxy _ InterpreterProxy new.	proxy loadStackFrom: thisContext sender.	plugin _ self simulatorClass new.	plugin setInterpreter: proxy.	^plugin perform: primitiveName asSymbol withArguments: argArray! !!TestInterpreterPlugin class methodsFor: 'as yet unclassified' stamp: 'acg 9/16/1999 19:58'!generateVMProxyOn: fileName	| cg proxyClass catList |	proxyClass _ InterpreterProxy.	cg _ TestCodeGenerator new initialize.	cg addClass: proxyClass.	catList _ proxyClass organization categories copy asOrderedCollection.	catList remove: 'initialize' ifAbsent:[].	catList remove: 'private' ifAbsent:[].	catList _ catList collect:[:cat| cat -> (proxyClass organization listAtCategoryNamed: cat)].	cg storeVirtualMachineProxyHeader: catList on: (fileName,'.h').	cg storeVirtualMachineProxyImplementation: catList on: (fileName,'.c').	"InterpreterProxy generateVMProxyOn:'sqVirtualMachine'"! !!TestInterpreterPlugin class methodsFor: 'as yet unclassified' stamp: 'acg 9/16/1999 19:58'!translate: fileName all: classes doInlining: inlineFlag	"Time millisecondsToRun: [		InterpreterPlugin translate:'all.c' all:{FloatArrayPlugin. FFTPlugin} doInlining: true.		Smalltalk beep]"	| cg theClass |	cg _ TestCodeGenerator new initialize.	classes do:[:cls|		theClass _ cls.		theClass initialize.		[theClass == InterpreterPlugin] whileFalse:[			cg addClass: theClass.			theClass declareCVarsIn: cg.			theClass _ theClass superclass]].	(classes includes: InterpreterPlugin) ifFalse:[		cg addClass: InterpreterPlugin.		InterpreterPlugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!TestInterpreterPlugin class methodsFor: 'as yet unclassified' stamp: 'acg 9/16/1999 19:58'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ TestCodeGenerator new initialize.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!TestOSAPlugin commentStamp: 'acg 9/20/1999 15:56' prior: 0!TestOSAPlugin translateSmalltalk garbageCollect!!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 12:37'!primAECreateDesc: typeCode from: aString	|rcvr size |	rcvr _ self 	primitive: 	'primAECreateDesc'				parameters:	#(DescType String)				receiver:	#AEDesc.	size _ aString size.	^(self 		cCode: 'AECreateDesc(*typeCode, aString, size, rcvr)'		inSmalltalk: [[rcvr. size]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:16'!primAEDescToString: aString	| rcvr size |	rcvr _ self	primitive: 	'primAEDescToString'				parameters: #(String)				receiver: #AEDesc.	size _ aString size.	self cCode: 'BlockMove(*(rcvr->dataHandle), aString, size)'		 inSmalltalk: [rcvr. size].	^aString asOop: String! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 12:38'!primAEDisposeDesc		|rcvr|	rcvr _	self	primitive: 	'primAEDisposeDesc'				parameters:	#()				receiver: 	#AEDesc.	^(self 		cCode: 'AEDisposeDesc(rcvr)'		inSmalltalk: [[rcvr]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 12:56'!primGetHandleSize: anIndex	|rcvr|	rcvr _ self	primitive: 'primGetHandleSize'				parameters: #(SmallInteger)				receiver:	#WordArray.	^(self		cCode: 'GetHandleSize((Handle) *(rcvr+anIndex))'		inSmalltalk: [[rcvr]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 16:08'!primOSACompile: source mode: mode to: object	|component|	component _ self primitive: 	'primOSACompile'					parameters: #(AEDesc SmallInteger OSAID)					receiver:	#ComponentInstance.	^(self cCode: 'OSACompile(*component,source,mode,object)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 16:08'!primOSADisplay: source as: type mode: mode to: result	|component|	component _ self primitive: 	'primOSADisplay'					parameters: #(OSAID DescType SmallInteger AEDesc)					receiver:	#ComponentInstance.	^(self cCode: 'OSADisplay(*component,*source,*type,mode,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 15:39'!primOSADispose: anOSAID	|component|	component _ self primitive: 	'primOSADispose'					parameters: #(OSAID)					receiver:	#ComponentInstance.	^(self cCode: 'OSADispose(*component,*anOSAID)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 16:09'!primOSADoScript: source in: context mode: mode resultType: type to: result	|component|	component _ self primitive: 	'primOSADoScript'					parameters: #(AEDesc OSAID SmallInteger DescType AEDesc)					receiver:	#ComponentInstance.	^(self cCode: 'OSADoScript(*component,source,*context,*type,mode,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 16:06'!primOSAExecute: script in: context mode: mode to: result	|component|	component _ self primitive: 	'primOSAExecute'					parameters: #(OSAID OSAID SmallInteger OSAID)					receiver:	#ComponentInstance.	^(self cCode: 'OSAExecute(*component,*script,*context,mode,result)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 21:53'!primOSAScriptingComponentNameTo: anAEDesc	|component|	component _ self	primitive: 	'primOSAScriptingComponentName'						parameters: #(AEDesc)						receiver:	#ComponentInstance.		^(self cCode: 'OSAScriptingComponentName(*component,anAEDesc)'			inSmalltalk: [[component]. -1]) asOop: Unsigned! !!TestOSAPlugin methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 23:42'!primOpenDefaultConfiguration: type subtype: subtype	| component |	component _ self	primitive: 	'primOpenDefaultConfiguration'						parameters: #(DescType DescType)						receiver:	#ComponentInstance.	self	cCode: '*component = OpenDefaultComponent(*type,*subtype)'		inSmalltalk: [component at: 0 put: 0].	^component asOop: ComponentInstance! !!TestOSAPlugin class methodsFor: 'as yet unclassified' stamp: 'acg 9/21/1999 01:29'!declareCVarsIn: cg	cg addHeaderFile: '<AppleEvents.h>'.	cg addHeaderFile: '<AppleScript.h>'.	cg addHeaderFile: '<OSA.h>'.	cg addHeaderFile: '<OSAGeneric.h>'.	cg addHeaderFile: '<Script.h>'.! !!TestTMethod reorganize!('initialization' fromContext:primitive:parameters:receiver: setSelector:args:locals:block:primitive:)('accessing' args: parmSpecs rcvrSpec)('transformations' recordDeclarations removeFinalSelfReturn)('C code generation' emitCHeaderOn:generator:)('named primitives' buildNamedPrimitiveProlog checkSuccessExpr extractPrimitiveDirectives fixUpReturnOneStmt:on: fixUpReturns handlePrimitiveDirective:on: isPrimitiveDirectiveSend: oldReplaceSizeMessages primitive:parameters:receiver: primitiveDirectiveWasHandled:on: replaceSizeMessages simulatePrologInContext: statementsFor:varName:)!!TestTMethod methodsFor: 'initialization' stamp: 'acg 9/19/1999 11:46'!fromContext: aContext primitive: aString parameters: aClassList receiver: aClass	fullArgs _ args _ aContext tempNames				copyFrom: 1				to: aContext method numArgs.	self 		primitive: aString		parameters: aClassList		receiver: aClass! !!TestTMethod methodsFor: 'initialization' stamp: 'acg 9/18/1999 01:48'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	isPrimitive _ false.  "set to true only if you find a primtive direction."	export _ self extractExportDirective.	self recordDeclarations.	self extractPrimitiveDirectives.! !!TestTMethod methodsFor: 'accessing' stamp: 'acg 9/19/1999 11:19'!args: anInteger	^args _ anInteger! !!TestTMethod methodsFor: 'accessing' stamp: 'acg 9/19/1999 11:18'!parmSpecs	^parmSpecs! !!TestTMethod methodsFor: 'accessing' stamp: 'acg 9/19/1999 11:50'!rcvrSpec	^rcvrSpec! !!TestTMethod methodsFor: 'transformations' stamp: 'acg 9/17/1999 18:18'!recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'	 and remove the declarations from the method body."	| newStatements isDeclaration |	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		isDeclaration _ false.		stmt isSend ifTrue: [			stmt selector = #var:declareC: ifTrue: [				isDeclaration _ true.				declarations at: stmt args first value asString put: stmt args last value.			].			stmt selector = #returnTypeC: ifTrue: [				isDeclaration _ true.				returnType _ stmt args last value.			].		].		isDeclaration ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.! !!TestTMethod methodsFor: 'transformations' stamp: 'acg 9/17/1999 18:18'!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	stmtList _ parseTree statements asOrderedCollection.	lastStmt _ stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 ['self' = lastStmt expression name]]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].! !!TestTMethod methodsFor: 'C code generation' stamp: 'acg 9/17/1999 07:51'!emitCHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr.	self emitCFunctionPrototype: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	locals do: [ :var |		aStream 			tab; 			nextPutAll: (declarations 				at: var 				ifAbsent: [ 'int ', var]);			nextPut: $;; 			cr].	locals isEmpty ifFalse: [ aStream cr ].! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/18/1999 16:40'!buildNamedPrimitiveProlog	| cg |	cg _ TestCodeGenerator new.	^Array streamContents: [:sStream |		1 to: fullArgs size do:			[:i |			 sStream nextPutAll: 				(self 					statementsFor: 						((parmSpecs at: i) 							ccg: 	cg							prolog:  [:expr | (fullArgs at: i), ' _ ', expr]							expr: (fullArgs at: i)							index: (fullArgs size - i))					varName: '')]]! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/19/1999 20:53'!checkSuccessExpr	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."	| expr |	expr _ 'interpreterProxy failed ifTrue: [^nil]'.	^ self statementsFor: expr varName: ''! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/19/1999 21:07'!extractPrimitiveDirectives	"Save selector in fullSelector and args in fullArgs.  Scan top-level statements for a directive of the form:		self				primitive: 	<string>or		self			primitive:	<string>			parameters: <list of class names>or		self			primitive:	<string>			parameters: <list of class names>			receiver: <class name>or an assignment of that expression to a local, and manipulate the state and parse tree accordingly."	parseTree setStatements: (Array streamContents:		[:sStream |			parseTree statements do:				[:stmt |				 (self primitiveDirectiveWasHandled: stmt on: sStream)					ifFalse: [sStream nextPut: stmt]]]).	isPrimitive ifTrue:		[export _ true.		 parseTree 			setStatements: self buildNamedPrimitiveProlog, 							parseTree statements.		 self fixUpReturns.		 self replaceSizeMessages.		 ^true].	^false! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/20/1999 13:21'!fixUpReturnOneStmt: stmt on: sStream	stmt isReturn ifFalse: [^sStream nextPut: stmt].	(stmt expression isSend and: ['primitiveFail' = stmt expression selector]) ifTrue: 		["failure return"		 sStream nextPut: stmt expression.		 sStream nextPut: (TReturnNode new			setExpression: (TVariableNode new setName: 'null')).		 ^nil].	(stmt expression isVariable and: ['nil' = stmt expression name]) ifTrue: 		["nil return -- this is never right unless automatically generated"		 sStream nextPut: stmt.		 ^nil].	(stmt expression isVariable and: ['self' = stmt expression name]) ifTrue: 		["self return"		 sStream nextPutAll: self checkSuccessExpr.		 sStream nextPut: (TSendNode new			 setSelector: #pop:			 receiver: (TVariableNode new setName: 'interpreterProxy')			 arguments: (Array 				with: (TConstantNode new 					setValue: fullArgs size))).		 sStream nextPut: (TReturnNode new		 	setExpression: (TVariableNode new setName: 'null')).		 ^nil].	"general return"	sStream nextPutAll: self checkSuccessExpr.	sStream nextPut: (TSendNode new		setSelector: #pop:thenPush:		receiver: (TVariableNode new setName: 'interpreterProxy')		arguments: (Array 			with: (TConstantNode new 				setValue: fullArgs size + 1)			with: stmt expression)).	sStream nextPut: 		(TReturnNode new setExpression: (TVariableNode new setName: 'null'))! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/18/1999 01:49'!fixUpReturns	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			node setStatements: (Array streamContents:				[:sStream |				 node statements do: 					[:stmt | self fixUpReturnOneStmt: stmt on: sStream]])]]! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/18/1999 23:42'!handlePrimitiveDirective: aStmt on: sStream	isPrimitive _ true.	fullArgs _ args.	locals addAll: args.	args _ OrderedCollection new.	fullArgs with: parmSpecs do:		[:argName :spec |			declarations				at: argName				put: (spec ccgDeclareCForVar: argName)].	aStmt isAssignment ifTrue:		[declarations			at: aStmt variable name			put: (rcvrSpec ccgDeclareCForVar: aStmt variable name).		 sStream nextPutAll: (self			statementsFor:				(rcvrSpec					ccg:		TestCodeGenerator new					prolog:  [:expr | aStmt variable name, ' _ ', expr]					expr: 	aStmt variable name					index: 	(fullArgs size))			varName: '')].	sStream nextPutAll: self checkSuccessExpr.	^true.! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/19/1999 11:25'!isPrimitiveDirectiveSend: stmt		stmt isSend ifTrue:		[stmt selector = #primitive ifTrue:			[^self primitive: 	stmt args first value				   parameters:	(Array new: args size withAll: #Oop)				   receiver:		#Oop].		 stmt selector = #primitive:parameters: ifTrue:			[^self primitive: 	stmt args first value				   parameters: 	stmt args second value				   receiver:		#Oop].		 stmt selector = #primitive:parameters:receiver: ifTrue:			[^self primitive:		stmt args first value				   parameters:	stmt args second value				   receiver:		stmt args third value].		^false].	^false.! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/20/1999 14:04'!oldReplaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	| argExpr |	parseTree nodesDo: [:n |		(n isSend and: [n selector = #size]) ifTrue: [			argExpr _ TSendNode new				setSelector: #+				receiver: n receiver				arguments: (Array with: (TConstantNode new setValue: 1)).			n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TVariableNode new setName: 'interpreterProxy')				arguments: (Array with: argExpr)]].! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/20/1999 13:00'!primitive: aString parameters: anArray receiver: aClassSymbol	fullSelector _ selector.	selector _ aString asSymbol.	anArray size == args size ifFalse: 		[^self error: selector, ': incorrect number of parameter specifications'].	parmSpecs _ anArray collect:		[:each | Smalltalk at: each ifAbsent:			[^self error: selector, ': parameter spec must be a Behavior']].	parmSpecs do: [:each | each isBehavior ifFalse:		[^self error: selector, ': parameter spec must be a Behavior']].	rcvrSpec _ Smalltalk at: aClassSymbol asSymbol ifAbsent:		[^self error: selector, ': receiver spec must be a Behavior'].	rcvrSpec isBehavior ifFalse:		[^self error: selector, ': receiver spec must be a Behavior'].	^true! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/17/1999 22:41'!primitiveDirectiveWasHandled: stmt on: sStream	(self isPrimitiveDirectiveSend: stmt) ifTrue:		[^self handlePrimitiveDirective: stmt on: sStream].	(stmt isAssignment and: 		[self isPrimitiveDirectiveSend: stmt expression]) ifTrue:			[^self handlePrimitiveDirective: stmt on: sStream].	^false.! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/20/1999 14:04'!replaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	parseTree nodesDo: [:n |		(n isSend and: [n selector = #size]) ifTrue: [			n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TVariableNode new setName: 'interpreterProxy')				arguments: (Array with: n receiver)]].! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/19/1999 14:06'!simulatePrologInContext: aContext	|cg instructions |	cg _ TestCodeGenerator new.	parmSpecs keysAndValuesDo: 		[:index :each |		 instructions _ ((parmSpecs at: index)			ccg: cg 			prolog: (cg ccgTVarBlock: index) 			expr: '<foo>' 			index: args size - index).		 Compiler new 			evaluate: instructions			in: aContext 			to: aContext receiver			notifying: nil			ifFail: nil].	instructions _ (rcvrSpec		ccg: cg 		prolog: [:expr | '^', expr]		expr: '<foo>' 		index: args size).	 ^Compiler new 		evaluate: instructions		in: aContext 		to: aContext receiver		notifying: nil		ifFail: nil! !!TestTMethod methodsFor: 'named primitives' stamp: 'acg 9/18/1999 01:49'!statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s _ WriteStream on: ''.	s nextPutAll: 'temp'; cr; cr; tab.	s nextPutAll: '| rcvr stackPointer successFlag ', varName,' |'; cr.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil)			asTestTMethodFromClass: Object) statements allButLast! !!TestTMethod class methodsFor: 'as yet unclassified' stamp: 'acg 9/19/1999 11:47'!fromContext: aContext primitive: aString parameters: aClassList receiver: aClass	^super new 		fromContext: aContext 		primitive: aString 		parameters: aClassList 		receiver: aClass! !!Unsigned methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 09:49'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToUnsignedFrom: aNode on: aStream! !!Unsigned methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 09:49'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg ccgLoad: aBlock expr: aString asUnsignedValueFrom: anInteger! !!Unsigned methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 09:50'!ccgDeclareCForVar: aSymbolOrString	^'unsigned ', aSymbolOrString! !!Unsigned class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 13:43'!ccg: cg generateCoerceToOopFrom: aNode on: aStream	cg generateCoerceToUnsignedFrom: aNode on: aStream! !!Unsigned class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 11:30'!ccgCanConvertFrom: anObject	anObject isInteger ifFalse: 		[self error: 'Not an Integer object'. ^false].	anObject >= 0 ifFalse: 		[self error: 'Object is negative integer'. ^false].	anObject < (2 raisedToInteger: 32) ifFalse: 		[self error: 'Object is too large'. ^false].	^true! !!WordArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:19'!ccg: cg emitLoadFor: aString from: anInteger on: aStream	cg emitLoad: aString asIntPtrFrom: anInteger on: aStream! !!WordArray class methodsFor: 'plugin generation' stamp: 'acg 9/20/1999 13:16'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asUnsignedPtrFrom: anInteger		andThen: (cg ccgValBlock: 'isWords')! !!WordArray class methodsFor: 'plugin generation' stamp: 'acg 9/17/1999 01:19'!ccgDeclareCForVar: aSymbolOrString	^'unsigned *', aSymbolOrString! !!ExternalData class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 22:08'!ccg: cg prolog: aBlock expr: aString index: anInteger	^cg 		ccgLoad: aBlock 		expr: aString 		asNamedPtr: self asString		from: anInteger		andThen: (cg ccgValBlock: 'isWordsOrBytes')! !!ExternalData class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 12:01'!ccgDeclareCForVar: aSymbolOrString	^self asString, ' *', aSymbolOrString! !!ExternalData class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:53'!fromValue: aNumber	^(super new: 1) at: 1 put: aNumber; yourself! !!AEDesc class reorganize!('as yet unclassified' new textTypeOn:)('private' primSizeAEDesc)!!AEDesc class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 22:17'!new	^super new: 2! !!AEDesc class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 13:30'!textTypeOn: aString	^(self new) createFromText: aString		! !!AEDesc class methodsFor: 'private' stamp: 'acg 9/12/1999 20:49'!primSizeAEDesc	<primitive: 'primSizeAEDesc' module: 'OSAPlugin'>	^-1! !!ComponentInstance class reorganize!('instance creation' new)!!ComponentInstance class methodsFor: 'instance creation' stamp: 'acg 9/20/1999 23:56'!new	^(super new: 1) openNewGenericComponent! !!DescType class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:29'!fromString: aString	^(super new: 1) 		fourBytesAt: 1 put: aString;		yourself! !!DescType class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:28'!fromUnsigned: anInteger	^(super new: 1) 		at: 1 put: anInteger;		yourself! !!DescType class methodsFor: 'as yet unclassified' stamp: 'acg 9/20/1999 14:37'!of: aString	^self fromString: aString! !!OSAID class methodsFor: 'as yet unclassified' stamp: 'acg 9/21/1999 00:05'!new	^(super new: 1) initialize; yourself! !CArrayAccessor removeSelector: #asOop:!ExternalData removeSelector: #hexByteAt:!ExternalData removeSelector: #strAt:!ExternalData removeSelector: #printAT:on:!ExternalData removeSelector: #strAt:put:!AEDesc removeSelector: #printOn:!AEDesc removeSelector: #data!AEDesc removeSelector: #primAEDescToString!AEDesc removeSelector: #primTestAEDescToString!AEDesc removeSelector: #str!AEDesc removeSelector: #fromText:!ComponentInstance removeSelector: #mandatory!ComponentInstance removeSelector: #primOSADispose:result:!ComponentInstance removeSelector: #primOSACompile:source:object:!ComponentInstance removeSelector: #primOSAScriptingComponentName:to:!ComponentInstance removeSelector: #primOpenDefaultConfiguration:subType:to:!ComponentInstance removeSelector: #primOSAExecute:script:context:result:!ComponentInstance removeSelector: #primOpenDefaultConfiguration:subType:!ComponentInstance removeSelector: #primOSADoScript:script:context:result:!ComponentInstance removeSelector: #primOSADisplay:result:type:object:!Object class removeSelector: #ccgEmitLoadFor:from:on:!Object class removeSelector: #ccg:emitPrologFor:from:on:!Object class removeSelector: #ccgEmitPrologFor:from:on:!Object class removeSelector: #ccg:EmitLoadFor:from:on:!Array class removeSelector: #ccg:emitPrologFor:from:on:!Boolean class removeSelector: #ccg:emitPrologFor:from:on:!ByteArray class removeSelector: #ccg:emitPrologFor:from:on:!Float class removeSelector: #ccg:emitPrologFor:from:on:!FloatArray class removeSelector: #ccg:emitPrologFor:from:on:!IntegerArray class removeSelector: #ccg:emitPrologFor:from:on:!InterpreterPlugin class removeSelector: #doPrimitive:withArguments:!Oop class removeSelector: #ccg:emitPrologFor:from:on:!Oop class removeSelector: #ccg:load:expr:index:!Oop class removeSelector: #ccgEmitLoadFor:from:on:!Oop class removeSelector: #Occg:emitPrologFor:from:on:!Oop class removeSelector: #ccgEmitPrologFor:from:on:!Oop class removeSelector: #ccgVar:declareC:!Oop class removeSelector: #ccg:generateOopFrom:on:!PluggableCodeGenerator removeSelector: #generateAsCUnsigned:on:indent:!PluggableCodeGenerator removeSelector: #generateAsCharPtr:on:indent:!PluggableCodeGenerator removeSelector: #asCDouble:on:indent:!PluggableCodeGenerator removeSelector: #generateClass:on:indent:!PluggableCodeGenerator removeSelector: #generateIsPointers:on:indent:!PluggableCodeGenerator removeSelector: #asCBoolean:on:indent:!PluggableCodeGenerator removeSelector: #generateAsUnsigned:on:indent:!PluggableCodeGenerator removeSelector: #generateStAt:on:indent:!PluggableCodeGenerator removeSelector: #generateStAtPut:on:indent:!PluggableCodeGenerator removeSelector: #generateAsIfVarPut:on:indent:!PluggableCodeGenerator removeSelector: #generateIsBytes:on:indent:!PluggableCodeGenerator removeSelector: #generateIsMemberOf:on:indent:!PluggableCodeGenerator removeSelector: #generateAsPositiveIntegerObj:on:indent:!PluggableCodeGenerator removeSelector: #generateFromStack:on:indent:!PluggableCodeGenerator removeSelector: #generateIsFloat:on:indent:!PluggableCodeGenerator removeSelector: #generateAsCBoolean:on:indent:!PluggableCodeGenerator removeSelector: #generateAtStack:on:indent:!PluggableCodeGenerator removeSelector: #generateAsIfVar:on:indent:!PluggableCodeGenerator removeSelector: #generateFieldPut:on:indent:!PluggableCodeGenerator removeSelector: #generateIsIntegerOop:on:indent:!PluggableCodeGenerator removeSelector: #generateIsBytesOrWords:on:indent:!PluggableCodeGenerator removeSelector: #generateIsIntegerValue:on:indent:!PluggableCodeGenerator removeSelector: #generateField:on:indent:!PluggableCodeGenerator removeSelector: #initializeCTranslationDictionary!PluggableCodeGenerator removeSelector: #generateFart:on:indent:!PluggableCodeGenerator removeSelector: #generateSize:on:indent:!PluggableCodeGenerator removeSelector: #generatePtrSize:on:indent:!PluggableCodeGenerator removeSelector: #generateBitAnd:on:indent:!PluggableCodeGenerator removeSelector: #generateAsBooleanObj:on:indent:!PluggableCodeGenerator removeSelector: #generateIsKindOf:on:indent:!PluggableCodeGenerator removeSelector: #generateIsWordsOrBytes:on:indent:!PluggableCodeGenerator removeSelector: #generateAsCInt!PluggableCodeGenerator removeSelector: #generateIsIndexable:on:indent:!PluggableCodeGenerator removeSelector: #generateAsIntPtr:on:indent:!PluggableCodeGenerator removeSelector: #generateIsInteger:on:indent:!PluggableCodeGenerator removeSelector: #generateAsCDouble:on:indent:!PluggableCodeGenerator removeSelector: #generateIsAtStack:on:indent:!PluggableCodeGenerator removeSelector: #generateAsSmallIntegerObj:on:indent:!PluggableCodeGenerator removeSelector: #generateIsNil:on:indent:!PluggableCodeGenerator removeSelector: #generateAsCInt:on:indent:!PluggableCodeGenerator removeSelector: #generateAsFloatObj:on:indent:!PluggableCodeGenerator removeSelector: #generateIsWords:on:indent:!SmallInteger class removeSelector: #ccg:emitLoadFor:from:on:!SmallInteger class removeSelector: #ccg:emitPrologFor:from:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asNakedOopFrom:!TestCodeGenerator removeSelector: #emitLoad:unsignedValueFrom:on:!TestCodeGenerator removeSelector: #emitLoad:memberOf:from:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asBooleanValueFrom:andThen:!TestCodeGenerator removeSelector: #ccgLoad:expr:asWBPtrFrom:!TestCodeGenerator removeSelector: #emitLoad:intPtrFrom:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asFloatPtrFrom:!TestCodeGenerator removeSelector: #ccgLoad:expr:asMemberOf:From:!TestCodeGenerator removeSelector: #emitLoad:nakedOopfrom:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asKindOf:index:!TestCodeGenerator removeSelector: #emitLoad:nonIntegerValueFrom:on:!TestCodeGenerator removeSelector: #generatePtrSize:on:indent:!TestCodeGenerator removeSelector: #generateSize:on:indent:!TestCodeGenerator removeSelector: #generateAsLoadAndVerifyFrom:on:indent:!TestCodeGenerator removeSelector: #emitLoad:kindOf:from:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asBooleanFrom:!TestCodeGenerator removeSelector: #emitLoad:charPtrFrom:on:!TestCodeGenerator removeSelector: #emitLoad:floatValueFrom:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asKindOf:From:!TestCodeGenerator removeSelector: #generateIsNil:on:indent:!TestCodeGenerator removeSelector: #ccgSetString:!TestCodeGenerator removeSelector: #emitLoad2:asNakedOopFrom:on:!TestCodeGenerator removeSelector: #ccgProlog:expr:asNakedOopFrom:!TestCodeGenerator removeSelector: #generatePrologFrom:on:indent:!TestCodeGenerator removeSelector: #emitLoad:nakedOopFrom:on:!TestCodeGenerator removeSelector: #ccgValidate:expr:asNakedOopFrom:!TestCodeGenerator removeSelector: #statementsFor:varName:!TestCodeGenerator removeSelector: #test!TestCodeGenerator removeSelector: #emitLoad:booleanValueFrom:on:!TestCodeGenerator removeSelector: #ccgLoad:expr:asMemberOf:index:!TestCodeGenerator removeSelector: #ccgLoad:expr:asArrayPtrFrom:!TestCodeGenerator removeSelector: #emitLoad:integerValueFrom:on:!TestCodeGenerator removeSelector: #generateAsPrologFrom:on:indent:!TestInterpreterPlugin removeSelector: #primitive:parameters:receiver:!TestInterpreterPlugin removeSelector: #generateVMProxyOn:!TestInterpreterPlugin removeSelector: #primitive:parameters:receiver:inContext:!TestInterpreterPlugin removeSelector: #primitive:!TestInterpreterPlugin removeSelector: #primitive:parameters:!TestInterpreterPlugin removeSelector: #translate:all:doInlining:!TestInterpreterPlugin removeSelector: #translate:doInlining:!FlippyArrayPlugin2 removeSelector: #test!TestOSAPlugin removeSelector: #primOSACompile:as:return:!TestOSAPlugin removeSelector: #primAECreateDesc!TestOSAPlugin removeSelector: #primOSAScriptingComponentName:storeIn:!TestOSAPlugin removeSelector: #primOSAExecute:in:mode:return:!TestOSAPlugin removeSelector: #primOSADisplay:as:to:!TestOSAPlugin removeSelector: #primAECreateDesc:from:to:!TestOSAPlugin removeSelector: #primOSADisplay:in:mode:resultType:return:!TestOSAPlugin removeSelector: #primAEDescGetData!TestOSAPlugin removeSelector: #primOSADisplay:as:return:!TestOSAPlugin removeSelector: #primOSACompile:to:!TestOSAPlugin removeSelector: #primOSAScriptingComponentName:to:!TestOSAPlugin removeSelector: #primOSAScriptingComponentName:result:!TestOSAPlugin removeSelector: #primOpenDefaultConfiguration:subType:!TestOSAPlugin removeSelector: #primOSADoScript:in:mode:resultType:return:!TestOSAPlugin removeSelector: #primOSAExecute:inContext:return:!TestOSAPlugin class removeSelector: #glueDeclareCVarsIn:!TestTMethod removeSelector: #fixUpReturns:postlog:!TestTMethod removeSelector: #oldfixUpReturns!TestTMethod removeSelector: #extractPrimitiveDirective!TestTMethod removeSelector: #simulatePrologInContext!TestTMethod removeSelector: #extractPrimitiveDirectives2!TestTMethod removeSelector: #fixUpOneReturnStmt:on:!TestTMethod removeSelector: #oldBuildNamedPrimitiveProlog!TestTMethod removeSelector: #buildListOfPrologStmts:!TestTMethod removeSelector: #fixUpReturns:!TestTMethod removeSelector: #emitCFunctionPrototype:generator:!TestTMethod removeSelector: #extractExportDirective!TestTMethod removeSelector: #buildNamedPrimitiveProlog2!TestTMethod removeSelector: #fixUpOneReturn:on:!TestTMethod removeSelector: #isSendToCPtrNode:!TestTMethod removeSelector: #buildListOfPrologStmts!TestTMethod removeSelector: #primitive:parameters:return:!TestTMethod removeSelector: #buildPrologListFromParms:andRcvr:!TestTMethod removeSelector: #oldfixUpOneReturn:on:!WordArray class removeSelector: #ccg:emitPrologFor:from:on:!ExternalData class removeSelector: #ccg:generateCoerceToOopFrom:on:!AEDesc class removeSelector: #on:!Smalltalk removeClassNamed: #OSARef!Smalltalk removeClassNamed: #InterpreterRuntimeSupport!Smalltalk removeClassNamed: #OSA!Smalltalk removeClassNamed: #OSAPlugin!