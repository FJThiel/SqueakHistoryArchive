'From R&DSqueak2.8 of 6 June 2001 [latest update: #28] on 26 November 2001 at 7:02:25 am'!"Change Set:		fastJPEGReadWriter-jmvDate:			26 November 2001Author:			Juan Manuel VuletichJPEGReadWriter2 uses a free JPEG library from the IndependentJPEG Group to provide:  1. encoding, as well as decoding of JPEG images  2. very good performanceIt has many applications, including JPEG movies. Many thanksto Juan Manual for this splendid addition to the Squeak toolbox!!"!ImageReadWriter subclass: #JPEGReadWriter2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Files'!!JPEGReadWriter2 commentStamp: 'jm 11/26/2001 06:30' prior: 0!I provide fast JPEG compression and decompression. I require the VM pluginJPEGReadWriter2Plugin, which is typically stored in same directory as the Squeak virtual machine.JPEGReadWriter2Plugin is based on LIBJPEG library. This sentence applies to the plugin:   "This software is based in part on the work of the Independent JPEG Group".The LIBJPEG license allows it to be used free for any purpose so long as its origin and copyright are acknowledged. You can read more about LIBJPEG and get the complete source code at www.ijg.org.!!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/25/2001 20:23'!compress: aForm quality: quality	"Encode the given Form and answer the compressed ByteArray. Quality goes from 0 (low) to 100 (high), where -1 means default."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |	aForm unhibernate.	"odd width images of depth 16 give problems; avoid them."	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	buffer _ ByteArray new: sourceForm width * sourceForm height.	byteCount _ self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: false		errorMgr: jpegErrorMgr2Struct.	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].	^ buffer copyFrom: 1 to: byteCount! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:01'!imageExtent: aByteArray 	"Answer the extent of the compressed image encoded in the given ByteArray."	| jpegDecompressStruct jpegErrorMgr2Struct w h |	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	self		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w _ self primImageWidth: jpegDecompressStruct.	h _ self primImageHeight: jpegDecompressStruct.	^ w @ h! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:23'!nextImage	"Decode and answer a Form from my stream."	^ self nextImageSuggestedDepth: Display depth! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:24'!nextImageSuggestedDepth: depth	"Decode and answer a Form of the given depth from my stream. Close the stream if it is a file stream. Possible depths are 16-bit and 32-bit."	| bytes width height form jpegDecompressStruct jpegErrorMgr2Struct depthToUse |	bytes _ stream upToEnd.	(stream respondsTo: #close) ifTrue: [stream close].	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: bytes		errorMgr: jpegErrorMgr2Struct.	width _ self primImageWidth: jpegDecompressStruct.	height _ self primImageHeight: jpegDecompressStruct.	"Odd width images of depth 16 gave problems. Avoid them (or check carefully!!)"	depthToUse _ ((depth = 32) | width odd) ifTrue: [32] ifFalse: [16].	form _ Form extent: width@height depth: depthToUse.	self		primJPEGReadImage: jpegDecompressStruct		fromByteArray: bytes		onForm: form		errorMgr: jpegErrorMgr2Struct.	^ form! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:21'!nextPutImage: aForm	"Encode the given Form on my stream with default quality."	^ self nextPutImage: aForm quality: -1 progressiveJPEG: false! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/25/2001 20:24'!nextPutImage: aForm quality: quality progressiveJPEG: progressiveFlag	"Encode the given Form on my stream with the given settings. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |	aForm unhibernate.	"odd width images of depth 16 give problems; avoid them."	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	buffer _ ByteArray new: sourceForm width * sourceForm height.	byteCount _ self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: progressiveFlag		errorMgr: jpegErrorMgr2Struct.	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].	stream next: byteCount putAll: buffer startingAt: 1.	self close.! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/25/2001 20:23'!uncompress: aByteArray into: aForm	"Uncompress an image from the given ByteArray into the given Form. Fails if the given Form has the wrong dimensions or depth."	| jpegDecompressStruct jpegErrorMgr2Struct w h |	aForm unhibernate.	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w _ self primImageWidth: jpegDecompressStruct.	h _ self primImageHeight: jpegDecompressStruct.	((aForm width = w) & (aForm height = h)) ifFalse: [		^ self error: 'form dimensions do not match'].	"odd width images of depth 16 give problems; avoid them"	w odd		ifTrue: [			aForm depth = 32 ifFalse: [^ self error: 'must use depth 32 with odd width']]		ifFalse: [			((aForm depth = 16) | (aForm depth = 32)) ifFalse: [^ self error: 'must use depth 16 or 32']].	self primJPEGReadImage: jpegDecompressStruct		fromByteArray: aByteArray		onForm: aForm		errorMgr: jpegErrorMgr2Struct.! !!JPEGReadWriter2 methodsFor: 'testing' stamp: 'jm 11/25/2001 20:20'!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:34'!primImageHeight: aJPEGCompressStruct	<primitive: 'primImageHeight' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primImageWidth: aJPEGCompressStruct	<primitive: 'primImageWidth' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGCompressStructSize	<primitive: 'primJPEGCompressStructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGDecompressStructSize	<primitive: 'primJPEGDecompressStructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGErrorMgr2StructSize	<primitive: 'primJPEGErrorMgr2StructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGReadHeader: aJPEGDecompressStruct fromByteArray: source errorMgr: aJPEGErrorMgr2Struct	<primitive: 'primJPEGReadHeaderfromByteArrayerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGReadImage: aJPEGDecompressStruct fromByteArray: source onForm: form errorMgr: aJPEGErrorMgr2Struct	<primitive: 'primJPEGReadImagefromByteArrayonFormerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!JPEGReadWriter2 methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGWriteImage: aJPEGCompressStruct onByteArray: destination form: form quality: quality progressiveJPEG: progressiveFlag errorMgr: aJPEGErrorMgr2Struct	<primitive: 'primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !TestInterpreterPlugin subclass: #JPEGReadWriter2Plugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!JPEGReadWriter2Plugin commentStamp: 'jm 11/26/2001 08:04' prior: 0!The following sentence applies to this class:  "This software is based in part on the work of the Independent JPEG Group".You can read more about it at www.ijg.org!!JPEGReadWriter2Plugin methodsFor: 'initialize-release' stamp: 'JMV 2/6/2001 15:02'!initialiseModule	self export: true! !!JPEGReadWriter2Plugin methodsFor: 'initialize-release' stamp: 'JMV 2/6/2001 15:02'!shutdownModule	self export: true! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/14/2001 21:19'!primImageHeight: aJPEGDecompressStruct	| rcvr |	self export: true.	rcvr _ self		primitive: 'primImageHeight'		parameters: #(ByteArray)		receiver: #Oop.	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct jpeg_decompress_struct))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	^(self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_height' inSmalltalk: [rcvr. 0])		 asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/14/2001 21:19'!primImageWidth: aJPEGDecompressStruct	| rcvr |	self export: true.	rcvr _ self		primitive: 'primImageWidth'		parameters: #(ByteArray)		receiver: #Oop.	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct jpeg_decompress_struct))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	^(self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_width' inSmalltalk: [rcvr. 0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/8/2001 12:21'!primJPEGCompressStructSize	| rcvr |	self export: true.	rcvr _ self		primitive: 'primJPEGCompressStructSize'		parameters: #()		receiver: #JPEGReadWriter2.	^(self cCode: 'sizeof(struct jpeg_compress_struct)' inSmalltalk: [rcvr. 0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/8/2001 12:21'!primJPEGDecompressStructSize	| rcvr |	self export: true.	rcvr _ self		primitive: 'primJPEGDecompressStructSize'		parameters: #()		receiver: #JPEGReadWriter2.	^(self cCode: 'sizeof(struct jpeg_decompress_struct)' inSmalltalk: [rcvr. 0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/8/2001 12:21'!primJPEGErrorMgr2StructSize	| rcvr |	self export: true.	rcvr _ self		primitive: 'primJPEGErrorMgr2StructSize'		parameters: #()		receiver: #JPEGReadWriter2.	^(self cCode: 'sizeof(struct error_mgr2)' inSmalltalk: [rcvr. 0])		asOop: SmallInteger! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/14/2001 21:25'!primJPEGReadHeader: aJPEGDecompressStruct fromByteArray: source errorMgr: aJPEGErrorMgr2Struct	| rcvr pcinfo pjerr sourceSize |	self export: true.	rcvr _ self		primitive: 'primJPEGReadHeaderfromByteArrayerrorMgr'		parameters: #(ByteArray ByteArray ByteArray)		receiver: #Oop. 	self var: #pcinfo declareC: 'j_decompress_ptr pcinfo'. 	self var: #pjerr declareC: 'error_ptr2 pjerr'.	"Avoid warnings when saving method"	self cCode: '' inSmalltalk: [		rcvr _ nil. pcinfo _ nil. pjerr _ nil. sourceSize _ nil.		rcvr. pcinfo. pjerr. sourceSize.	].	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(2))) >= (sizeof(struct jpeg_decompress_struct)));		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct error_mgr2))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	self cCode: '		sourceSize = interpreterProxy->stSizeOf(interpreterProxy->stackValue(1));		pcinfo = (j_decompress_ptr)aJPEGDecompressStruct;		pjerr = (error_ptr2)aJPEGErrorMgr2Struct;		if (sourceSize) {			pcinfo->err = jpeg_std_error(&pjerr->pub);			pjerr->pub.error_exit = error_exit;			if (setjmp(pjerr->setjmp_buffer)) {				jpeg_destroy_decompress(pcinfo);				sourceSize = 0;			}			if (sourceSize) {				jpeg_create_decompress(pcinfo);				jpeg_mem_src(pcinfo, source, sourceSize);				jpeg_read_header(pcinfo, TRUE);			}		}	' inSmalltalk: [].! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/15/2001 12:10'!primJPEGReadImage: aJPEGDecompressStruct fromByteArray: source onForm: form errorMgr: aJPEGErrorMgr2Struct	| rcvr pcinfo pjerr buffer rowStride formBits formDepth i j formPix ok rOff gOff bOff rOff2 gOff2 bOff2 formWidth formHeight pixPerWord formPitch formBitsSize sourceSize |	self export: true.	rcvr _ self		primitive: 'primJPEGReadImagefromByteArrayonFormerrorMgr'		parameters: #(ByteArray ByteArray Form ByteArray)		receiver: #Oop. 	self var: #pcinfo declareC: 'j_decompress_ptr pcinfo'. 	self var: #pjerr declareC: 'error_ptr2 pjerr'.	self var: #buffer declareC: 'JSAMPARRAY buffer'.	self var: #formBits declareC: 'unsigned * formBits'.	"Avoid warnings when saving method"	self cCode: '' inSmalltalk: [		rcvr _ nil. pcinfo _ nil. pjerr _ nil. buffer _ nil. rowStride _ nil.		formDepth _ nil. formBits _ nil. i _ nil. j _ nil. formPix _ nil.		ok _ nil. rOff _ nil. gOff _ nil. bOff _ nil. rOff2 _ nil. gOff2 _ nil. bOff2 _ nil. sourceSize _ nil.		rcvr. pcinfo. pjerr. buffer. rowStride. formBits. formDepth. i. j. formPix. ok.		rOff. gOff. bOff. rOff2. gOff2. bOff2. sourceSize.	].	formBits _self cCoerce: (interpreterProxy fetchPointer: 0 ofObject: form)  to: 'unsigned *'.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(3))) >= (sizeof(struct jpeg_decompress_struct)));		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct error_mgr2))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	formWidth _ (self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_width' inSmalltalk: [0]).	formHeight _ (self cCode: '((j_decompress_ptr)aJPEGDecompressStruct)->image_height' inSmalltalk: [0]).	pixPerWord _ 32 // formDepth.	formPitch _ formWidth + (pixPerWord-1) // pixPerWord * 4.	formBitsSize _ interpreterProxy byteSizeOf: formBits.	interpreterProxy success: 		((interpreterProxy isWordsOrBytes: formBits)			and: [formBitsSize = (formPitch * formHeight)]).	interpreterProxy failed ifTrue: [^ nil].	self cCode: '		sourceSize = interpreterProxy->stSizeOf(interpreterProxy->stackValue(2));		pcinfo = (j_decompress_ptr)aJPEGDecompressStruct;		pjerr = (error_ptr2)aJPEGErrorMgr2Struct;		pcinfo->err = jpeg_std_error(&pjerr->pub);		pjerr->pub.error_exit = error_exit;		ok = 1;		if (setjmp(pjerr->setjmp_buffer)) {			jpeg_destroy_decompress(pcinfo);			ok = 0;		}		if (ok) {			ok = jpeg_mem_src_newLocationOfData(pcinfo, source, sourceSize);			if (ok) {				jpeg_start_decompress(pcinfo);				rowStride = pcinfo->output_width * pcinfo->output_components;				if (pcinfo->out_color_components == 3) {					rOff = 0; gOff = 1; bOff = 2;					rOff2 = 3; gOff2 = 4; bOff2 = 5;				} else {					rOff = 0; gOff = 0; bOff = 0;					rOff2 = 1; gOff2 = 1; bOff2 = 1;				}				/* Make a one-row-high sample array that will go away when done with image */				buffer = (*(pcinfo->mem)->alloc_sarray)					((j_common_ptr) pcinfo, JPOOL_IMAGE, rowStride, 1);				/* Step 6: while (scan lines remain to be read) */				/*           jpeg_read_scanlines(...); */				/* Here we use the library state variable cinfo.output_scanline as the				 * loop counter, so that we dont have to keep track ourselves.				 */				while (pcinfo->output_scanline < pcinfo->output_height) {					/* jpeg_read_scanlines expects an array of pointers to scanlines.					 * Here the array is only one element long, but you could ask for					 * more than one scanline at a time if thats more convenient.					 */					(void) jpeg_read_scanlines(pcinfo, buffer, 1);					switch (formDepth) {						case 32:							for(i = 0, j = 1; i < rowStride; i +=(pcinfo->out_color_components), j++) {								formPix = (255 << 24) | (buffer[0][i+rOff] << 16) | (buffer[0][i+gOff] << 8) | buffer[0][i+bOff];								formBits [ ((pcinfo->output_scanline - 1) * (pcinfo->image_width)) + j ] = formPix;							}							break;						case 16:							for(i = 0, j = 1; i < rowStride; i +=(pcinfo->out_color_components*2), j++) {								formPix = ((buffer[0][i+rOff] & 248) << 23) | ((buffer[0][i+gOff] & 248) << 18) | 									((buffer[0][i+bOff] & 248) << 13) | ((buffer[0][i+rOff2] & 248) << 7) | 									((buffer[0][i+gOff2] & 248) << 2) | ((buffer[0][i+bOff2] & 248) >> 3);								formBits [ ((pcinfo->output_scanline - 1) * (pcinfo->image_width)) / 2 + j ] = formPix;							}							break;					}				}				jpeg_finish_decompress(pcinfo);			}			jpeg_destroy_decompress(pcinfo);		}	' inSmalltalk: [].! !!JPEGReadWriter2Plugin methodsFor: 'primitives' stamp: 'JMV 10/14/2001 21:26'!primJPEGWriteImage: aJPEGCompressStruct onByteArray: destination form: form quality: quality progressiveJPEG: progressiveFlag errorMgr: aJPEGErrorMgr2Struct	| rcvr pcinfo pjerr buffer rowStride formBits formWidth formHeight formDepth i j formPix destinationSize pixPerWord formPitch formBitsSize |	self export: true.	rcvr _ self		primitive: 'primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr'		parameters: #(ByteArray ByteArray Form SmallInteger Boolean ByteArray)		receiver: #Oop. 	self var: #pcinfo declareC: 'j_compress_ptr pcinfo'. 	self var: #pjerr declareC: 'error_ptr2 pjerr'.	self var: #buffer declareC: 'JSAMPARRAY buffer'.	self var: #formBits declareC: 'unsigned * formBits'.	"Avoid warnings when saving method"	self cCode: '' inSmalltalk: [		rcvr _ nil. pcinfo _ nil. pjerr _ nil. buffer _nil. rowStride _ nil. formBits _ nil. 		formWidth _ nil. formHeight _ nil. formDepth _ nil. i _ nil. j _ nil. formPix _ nil. destinationSize _ nil.		rcvr. pcinfo. pjerr. buffer. rowStride. formBits. formWidth. formHeight. formDepth. i. j. formPix. destinationSize.	].	formBits _self cCoerce: (interpreterProxy fetchPointer: 0 ofObject: form)  to: 'unsigned *'.	formWidth _ interpreterProxy fetchInteger: 1 ofObject: form.	formHeight _ interpreterProxy fetchInteger: 2 ofObject: form.	formDepth _ interpreterProxy fetchInteger: 3 ofObject: form.	"Various parameter checks"	self cCode: '		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(5))) >= (sizeof(struct jpeg_compress_struct)));		interpreterProxy->success			((interpreterProxy->stSizeOf(interpreterProxy->stackValue(0))) >= (sizeof(struct error_mgr2))); 		if (interpreterProxy->failed()) return null;	' inSmalltalk: [].	pixPerWord _ 32 // formDepth.	formPitch _ formWidth + (pixPerWord-1) // pixPerWord * 4.	formBitsSize _ interpreterProxy byteSizeOf: formBits.	interpreterProxy success: 		((interpreterProxy isWordsOrBytes: formBits)			and: [formBitsSize = (formPitch * formHeight)]).	interpreterProxy failed ifTrue: [^ nil].	self cCode: '		destinationSize = interpreterProxy->stSizeOf(interpreterProxy->stackValue(4));		pcinfo = (j_compress_ptr)aJPEGCompressStruct;		pjerr = (error_ptr2)aJPEGErrorMgr2Struct;		if (destinationSize) {			pcinfo->err = jpeg_std_error(&pjerr->pub);			pjerr->pub.error_exit = error_exit;			if (setjmp(pjerr->setjmp_buffer)) {				jpeg_destroy_compress(pcinfo);				destinationSize = 0;			}			if (destinationSize) {				jpeg_create_compress(pcinfo);				jpeg_mem_dest(pcinfo, destination, &destinationSize);				pcinfo->image_width = formWidth;				pcinfo->image_height = formHeight;				pcinfo->input_components = 3;				pcinfo->in_color_space = JCS_RGB;				jpeg_set_defaults(pcinfo);				if (quality > 0)					jpeg_set_quality (pcinfo, quality, 1);				if (progressiveFlag)					jpeg_simple_progression(pcinfo);				jpeg_start_compress(pcinfo, TRUE);				rowStride = formWidth * 3;				/* Make a one-row-high sample array that will go away 				  when done with image */				buffer = (*(pcinfo->mem)->alloc_sarray)					((j_common_ptr) pcinfo, JPOOL_IMAGE, rowStride, 1);				while (pcinfo->next_scanline < pcinfo->image_height) {					switch (formDepth) {						case 32:							for(i = 0, j = 1; i < rowStride; i +=3, j++) {								formPix = formBits [ ((pcinfo->next_scanline) * formWidth) + j ];								buffer[0][i] = (formPix >> 16) & 255;								buffer[0][i+1] = (formPix >> 8) & 255;								buffer[0][i+2] = formPix & 255;							}							break;						case 16:							for(i = 0, j = 1; i < rowStride; i +=6, j++) {								formPix = formBits [ ((pcinfo->next_scanline) * formWidth) / 2 + j ];								buffer[0][i] = (formPix >> 23) & 248;								buffer[0][i+1] = (formPix >> 18) & 248;								buffer[0][i+2] = (formPix >> 13) & 248;								buffer[0][i+3] = (formPix >> 7) & 248;								buffer[0][i+4] = (formPix >> 2) & 248;								buffer[0][i+5] = (formPix << 3) & 248;							}							break;					}					(void) jpeg_write_scanlines(pcinfo, buffer, 1);				}				jpeg_finish_compress(pcinfo);				jpeg_destroy_compress(pcinfo);			}		}	' inSmalltalk: [].	^(self cCode: 'destinationSize' inSmalltalk: [0])		asOop: SmallInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JPEGReadWriter2Plugin class	instanceVariableNames: ''!!JPEGReadWriter2Plugin class methodsFor: 'translation' stamp: 'JMM 10/3/2001 11:44'!hasHeaderFile	"If there is a single intrinsic header file to be associated with the plugin, here is where you want to flag"	^true! !!JPEGReadWriter2Plugin class methodsFor: 'translation' stamp: 'JMV 10/8/2001 12:15'!headerFile^'/*#include <stdio.h>*//* Interface to JPEG code */#include "jpeglib.h"#include <setjmp.h>struct error_mgr2 {  struct jpeg_error_mgr pub;	/* "public" fields */  jmp_buf setjmp_buffer;	/* for return to caller */};typedef struct error_mgr2* error_ptr2;void error_exit (j_common_ptr cinfo);'! !!JPEGReadWriter2Plugin class methodsFor: 'translation' stamp: 'JMM 10/3/2001 11:48'!requiresPlatformFiles	"default is ok for most, any plugin needing platform specific files must say so"	^true! !