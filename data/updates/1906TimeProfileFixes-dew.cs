'From Squeak2.8alpha of 4 February 2000 [latest update: #1873] on 3 March 2000 at 1:11:52 pm'!"Change Set:		28TimeProfileFixes-dewDate:			4 March 2000Author:			Doug WayFixes a couple of parsing bugs with the TimeProfileBrowser.  It no longer truncates the first character of each line, and class-side non-super methods now show up properly.The browser no longer throws an exception when clicking on something other than a method. --sma"!!MessageSet methodsFor: 'message list' stamp: 'sma 3/3/2000 11:17'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^ nil].	^ self setClassAndSelectorIn: [:class :selector | ^ selector]! !!TimeProfileBrowser methodsFor: 'private' stamp: 'sma 3/3/2000 10:57'!runBlock	| stream list |	tally := MessageTally new.	tally spyEvery: 16 on: block.	stream := ReadWriteStream with: (String streamContents: [:s | tally report: s; close]).	stream reset.	list := OrderedCollection new.	[stream atEnd] whileFalse: [list add: stream nextLine].	self initializeMessageList: list.	self changed: #messageList.	self changed: #messageListIndex.! !!TimeProfileBrowser methodsFor: 'private' stamp: 'dew 3/2/2000 20:04'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	| string strm class sel parens |	messageListIndex < 3 ifTrue: [^contents := nil].		"Ignore first 2 lines"	string _ self selection asString.	string isEmpty ifTrue: [^contents := nil].	string first == $* ifTrue: [^contents := nil].		"Ignore lines starting with *"	parens := string includes: $(.					"Does it have open-paren?"	strm := ReadStream on: string.	parens		ifTrue: [strm skipTo: $(.		"easy case"			class := strm upTo: $).			strm next: 2.			sel := strm upToEnd]		ifFalse: [strm position: (string findString: ' class>>').			strm position > 0				ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]				ifTrue:					[ | subString |  "find the next to last space character"					subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.					strm position: (subString findLast: [ :ch | ch == $ ])].		"ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])."			class := strm upTo: $>.			strm next.			sel := strm upToEnd].	class isEmpty ifTrue: [^contents := nil].	sel isEmpty ifTrue: [^contents := nil].	^MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock! !