'From Squeak2.9alpha of 13 June 2000 [latest update: #2907] on 27 October 2000 at 12:21:27 am'!"Change Set:		DieDropShadow-arDate:			26 October 2000Author:			Andreas RaabBummer. DropShadowMorph died - it's now incorporated into Morph itself.But first transfer all information over to the current wrappees..."| hadHalo first |DropShadowMorph allInstancesDo:[:ds|	"bullet proof agains obsolete guys"	ds renderedMorph ifNotNil:[		ds renderedMorph setProperty: #hasDropShadow toValue: true.		ds renderedMorph setProperty: #shadowColor toValue: ds color.		ds renderedMorph setProperty: #shadowOffset toValue: ds shadowOffset.		(hadHalo _ ds hasHalo) ifTrue: [ds halo delete].		first _ ds submorphs size > 0 ifTrue: [ds firstSubmorph] ifFalse: [nil].		ds owner ifNotNil: [ds owner addAllMorphs: ds submorphs].		first ifNotNil: [first absorbStateFromRenderer: ds.			hadHalo ifTrue: [first addHalo]].		ds delete].	ds delete].!!Canvas methodsFor: 'drawing-general' stamp: 'ar 10/26/2000 19:45'!fullDrawMorph: aMorph	(self isVisible: aMorph fullBounds) ifTrue:[self fullDraw: aMorph].! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 10/26/2000 19:39'!roundCornersOf: aMorph during: aBlock	^aBlock value! !!CornerRounder methodsFor: 'all' stamp: 'ar 10/26/2000 20:03'!tweakCornersOf: aMorph on: aCanvas borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits c fourColors c14 c23 insetColor mask outBits shadowColor |	shadowColor _ aCanvas shadowColor.	aCanvas shadowColor: nil. "for tweaking it's essential"	w > 0 ifTrue:		[c _ shadowColor ifNil:[aMorph borderColor].		fourColors _ Array new: 4 withAll: c.		c == #raised ifTrue:			[c14 _ aMorph color lighter. c23 _ aMorph color darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14].		(c == #inset and: [aMorph owner notNil]) ifTrue:			[insetColor _ aMorph owner colorForInsets.			c14 _ insetColor lighter. c23 _ insetColor darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	1 to: 4 do:[:i | 		(cornerList includes: i) ifTrue:			[corner _ aMorph bounds corners at: i.			saveBits _ underBits at: i.			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:				["Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]].	aCanvas shadowColor: shadowColor. "restore shadow color"! !!FillStyle methodsFor: 'testing' stamp: 'ar 10/26/2000 19:24'!isTransparent	^false! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 10/26/2000 19:26'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: aFillStyle asColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'ar 10/26/2000 19:26'!fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc	"Fill the given oval."	self shadowColor ifNotNil:		[^self fillOval: aRectangle color: aFillStyle asColor borderWidth: bw borderColor: bc].	(aFillStyle isBitmapFill and:[aFillStyle isKindOf: InfiniteForm]) ifTrue:[		self flag: #fixThis.		^self fillOval: aRectangle color: aFillStyle borderWidth: bw borderColor: bc].	(aFillStyle isSolidFill) ifTrue:[		^self fillOval: aRectangle color: aFillStyle asColor borderWidth: bw borderColor: bc].	"Use a BalloonCanvas instead"	self asBalloonCanvas fillOval: aRectangle fillStyle: aFillStyle borderWidth: bw borderColor: bc! !!FormCanvas methodsFor: 'drawing-general' stamp: 'ar 10/26/2000 19:41'!roundCornersOf: aMorph during: aBlock	aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesNothingOutside: (CornerRounder rectWithinCornersOf: aMorph bounds))		ifTrue: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CornerRounder roundCornersOf: aMorph on: self		displayBlock: aBlock		borderWidth: aMorph borderWidth		corners: aMorph roundedCorners! !!Morph methodsFor: 'drawing' stamp: 'ar 10/26/2000 22:10'!basicFullDrawOn: aCanvas	"Draw the receiver and its submorphs in a single pass. Used by fullDrawOn: but there more than one pass may be involved"	aCanvas roundCornersOf: self during:[aCanvas drawMorph: self].	self drawSubmorphsOn:aCanvas.	self drawDropHighlightOn: aCanvas.	self drawMouseDownHighlightOn: aCanvas.! !!Morph methodsFor: 'drawing' stamp: 'ar 10/26/2000 19:55'!drawOnCanvas: aCanvas	^aCanvas fullDraw: self.! !!Morph methodsFor: 'drawing' stamp: 'ar 10/27/2000 00:21'!fullBounds	| delta |	fullBounds ifNil: [		fullBounds _ self bounds.		self hasDropShadow ifTrue:[			delta _ self shadowOffset.			delta x >= 0 				ifTrue:[fullBounds _ fullBounds right: fullBounds right + delta x]				ifFalse:[fullBounds _ fullBounds left: fullBounds left + delta x].			delta y >= 0				ifTrue:[fullBounds _ fullBounds bottom: fullBounds bottom + delta y]				ifFalse:[fullBounds _ fullBounds top: fullBounds top + delta y]].		submorphs size > 0 ifTrue: [			submorphs do: [:m | (m visible)					ifTrue: [fullBounds _ fullBounds quickMerge: m fullBounds]]].	].	^ fullBounds! !!Morph methodsFor: 'drawing' stamp: 'ar 10/26/2000 22:14'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	"Note: At some point we should generalize this into some sort of 	multi-canvas so that we can cross-optimize some drawing operations."	"Pass 1: Draw eventual drop-shadow"	self hasDropShadow ifTrue:[		aCanvas translateBy: self shadowOffset during:[:shadowCanvas|			shadowCanvas shadowColor: self shadowColor.			shadowCanvas roundCornersOf: self during:[shadowCanvas drawMorph: self]]].	"Pass 2: Draw receiver itself"	aCanvas roundCornersOf: self during:[aCanvas drawMorph: self].	self drawSubmorphsOn:aCanvas.	self drawDropHighlightOn: aCanvas.	self drawMouseDownHighlightOn: aCanvas.! !!Morph methodsFor: 'menus' stamp: 'ar 10/26/2000 20:08'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' target: self action: #makeNewPlayerInstance:.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' target: self action: #embedInto:].	aMenu defaultTarget: self.	aMenu addUpdating: #lockedString action: #lockUnlockMorph.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'ar 10/26/2000 20:09'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| realOwner realMorph |	"Add morph-specific items to the given menu which was invoked by the given hand.  Note the special-casing of Worlds, for which some of the the otherwise generic items are excluded."	self isWorldMorph		ifFalse:			[(self isKindOf: SystemWindow)				ifFalse: [aCustomMenu add: 'put in a window' action: #embedInWindow].			aCustomMenu addUpdating: #stickinessString target: self action: #toggleStickiness.			aCustomMenu add: 'adhere to edge...' action: #adhereToEdge]		ifTrue:			[aCustomMenu add: 'desktop menu...' target: self action: #putUpDesktopMenu:.			aCustomMenu addLine].	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aCustomMenu hand: aHandMorph].	realOwner _ (realMorph _ self topRendererOrSelf) owner.	(realOwner isKindOf: TextPlusPasteUpMorph) ifTrue:		[aCustomMenu add: 'GeeMail stuff...' subMenu: (realOwner textPlusMenuFor: realMorph)]! !!Morph methodsFor: 'object fileIn' stamp: 'ar 10/26/2000 21:26'!convertbosfces0: varDict bosfce0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('shadowOffset').  Possibly store their info in another variable?"! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/26/2000 20:08'!buildMetaMenu: evt	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph:.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	self maybeAddCollapseItemTo: menu.	menu add: 'delete' action: #dismissMorph:.	menu addLine.	menu add: 'copy Postscript' action: #clipPostscript.	menu add: 'print PS to file...' action: #printPSToFile.	menu addLine.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo:.	menu add: 'duplicate' action: #maybeDuplicateMorph:.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #embedInto:].	menu add: 'resize' action: #resizeMorph:.	"Give the argument control over what should be done about fill styles"	self addFillStyleMenuItems: menu hand: evt hand.	self addDropShadowMenuItems: menu hand: evt hand.	(self morphsAt: evt position) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #invokeMetaMenuAt:event:			argument: evt position].	menu addLine.	menu add: 'inspect' selector: #inspectAt:event: argument: evt position.	menu add: 'explore' action: #explore.	menu add: 'browse hierarchy' action: #browseHierarchy.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #choosePartName.	(self isMorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(self ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	(self hasProperty: #resourceFilePath)		ifTrue: [((self valueOfProperty: #resourceFilePath) endsWith: '.morph')				ifTrue: [menu add: 'save as resource' action: #saveAsResource].				menu add: 'update from resource' action: #updateFromResource]		ifFalse: [menu add: 'attach to resource' action: #attachToResource].	menu add: 'show actions' action: #showActions.	menu addLine.	self addCustomMenuItems: menu hand: evt hand.	^ menu! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 19:22'!addDropShadow	self hasDropShadow ifTrue:[^self].	self changed.	self hasDropShadow: true.	self shadowOffset: 3@3.	fullBounds _ nil.	self changed.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 20:17'!addDropShadowMenuItems: aMenu hand: aHand	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addUpdating: #hasDropShadowString		action: #toggleDropShadow.	menu addLine.	menu add: 'shadow color...' target: self selector: #changeShadowColor.	menu add: 'shadow offset...' target: self selector: #setShadowOffset:.	aMenu add: 'drop shadow' subMenu: menu.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 20:22'!changeShadowColor	"Change the shadow color of the receiver -- triggered, e.g. from a menu"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #shadowColor:;		originalColor: self shadowColor;		putUpFor: self near: self fullBoundsInWorld! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 19:02'!hasDropShadow	^self valueOfProperty: #hasDropShadow ifAbsent:[false]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 19:03'!hasDropShadow: aBool	aBool		ifTrue:[self setProperty: #hasDropShadow toValue: true]		ifFalse:[self removeProperty: #hasDropShadow]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 20:17'!hasDropShadowString 	^self hasDropShadow 		ifTrue:['<on>show shadow'] 		ifFalse:['<off>show shadow']! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 19:22'!removeDropShadow	self hasDropShadow ifFalse:[^self].	self changed.	self hasDropShadow: false.	fullBounds _ nil.	self changed.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 18:58'!setShadowOffset: evt	| handle |	handle _ HandleMorph new forEachPointDo:		[:newPoint | self shadowPoint: newPoint].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 18:59'!shadowColor	^self valueOfProperty: #shadowColor ifAbsent:[Color black]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 20:22'!shadowColor: aColor	self shadowColor = aColor ifFalse:[self changed].	self setProperty: #shadowColor toValue: aColor.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 18:57'!shadowOffset	"Return the current shadow offset"	^self valueOfProperty: #shadowOffset ifAbsent:[0@0]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 19:00'!shadowOffset: aPoint	"Set the current shadow offset"	(aPoint isNil or:[(aPoint x isZero) & (aPoint y isZero)])		ifTrue:[self removeProperty: #shadowOffset]		ifFalse:[self setProperty: #shadowOffset toValue: aPoint].! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 19:22'!shadowPoint: newPoint	self changed.	self shadowOffset: newPoint - self center // 5.	fullBounds _ nil.	self changed.! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 20:16'!toggleDropShadow	self hasDropShadow		ifTrue:[self removeDropShadow]		ifFalse:[self addDropShadow].! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'ar 10/26/2000 20:09'!fancyText: aString ofSize: pointSize color: aColor	| answer tm |	answer _ self inAColumn: {		tm _ TextMorph new 			beAllFont: ((TextStyle default fontOfSize: pointSize) emphasized: 1);			color: aColor;			contents: aString	}.	tm addDropShadow.	tm shadowPoint: (5@5) + tm bounds center.	tm lock.	^answer! !!CategoryViewer methodsFor: 'header pane' stamp: 'ar 10/26/2000 20:09'!addHeaderMorph	"Add the header at the top of the viewer, with a control for choosing the category, etc."	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ Preferences standardButtonFont.	header addMorph: (aButton _ SimpleButtonMorph new label: 'O' font: aFont).	aButton target: self;			color:  Color tan;			actionSelector: #delete;			setBalloonText: 'remove this pane from the screendon''t worry -- nothing will be lost!!.'.	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.		wrpr submorphs first  setBalloonText: 'next category'.	header beSticky.	self addMorph: header.	namePane _ RectangleMorph newSticky color: Color brown veryMuchLighter.	namePane borderWidth: 0.	aButton _ (StringButtonMorph contents: '-----' font: (StrikeFont familyName: #NewYork size: 12)) color: Color black.	aButton target: self; arguments: Array new; actionSelector: #chooseCategory.	aButton actWhen: #buttonDown.	namePane addMorph: aButton.	aButton position: namePane position.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category (click here to choose a different one)'.	header addMorphBack: namePane.	(namePane isKindOf: RectangleMorph) ifTrue:		[namePane addDropShadow.		namePane shadowColor: Color gray].	self categoryChoice: #basic! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/26/2000 20:08'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my inner target."	| menu |	evt hand obtainHalo: self.	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	menu _ innerTarget buildHandleMenu: evt hand.	self showingDirectionHandles		ifTrue: [menu add: 'hide direction handles' target: self selector: #showDirectionHandles: argument: false]		ifFalse: [menu add: 'show direction handles' target: self selector: #showDirectionHandles: argument: true].	innerTarget addTitleForHaloMenu: menu.	menu popUpEvent: evt in: self world.! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!bottom: aNumber	^origin corner: corner x @ aNumber! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:16'!left: aNumber	^aNumber @ origin y corner: corner! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!right: aNumber	^origin corner: aNumber @ corner y! !!Rectangle methodsFor: 'accessing' stamp: 'ar 10/26/2000 22:17'!top: aNumber	^origin x @ aNumber corner: corner! !!SmartRefStream methodsFor: 'conversion' stamp: 'ar 10/26/2000 21:24'!dropShadowMorphbosfces0	^ Morph! !!SolidFillStyle methodsFor: 'testing' stamp: 'ar 10/26/2000 19:25'!isTransparent	^color isTransparent! !!TextContainer methodsFor: 'private' stamp: 'ar 10/26/2000 20:04'!bounds	| bounds theText |	self fillsOwner ifFalse: [^ textMorph textBounds].	theText _ textMorph.	bounds _ theText owner innerBounds.	bounds _ bounds insetBy: (textMorph valueOfProperty: #margins ifAbsent: [1@1]).	theText owner submorphsBehind: theText do:		[:m | bounds _ bounds merge: m fullBounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'ar 10/26/2000 20:05'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph.	canvas _ (Display defaultCanvasClass extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [tempCanvas fullDrawMorph: (theText owner copyWithoutSubmorph: theText)]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back _ tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [tempCanvas fullDrawMorph: m]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextMorph methodsFor: 'menu' stamp: 'ar 10/26/2000 20:05'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	(Preferences valueOfFlag: #noviceMode) not & 		(Preferences valueOfFlag: #simpleMenus) not ifTrue: [			aCustomMenu add: 'code pane menu...' action: #yellowButtonActivity.			aCustomMenu add: 'code pane shift menu....' action: #shiftedYellowButtonActivity].	outer _ self owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'private' stamp: 'ar 10/26/2000 20:05'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: self owner)					compose: text style: textStyle copy					from: self startingIndex in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !TextMorph removeSelector: #meOrMyDropShadow!Morph removeSelector: #addDropShadowItemsTo:hand:!FormCanvas removeSelector: #fullDrawMorphWithRoundedCorners:!Canvas removeSelector: #fullDrawMorphWithRoundedCorners:!Smalltalk removeClassNamed: #DropShadowMorph!