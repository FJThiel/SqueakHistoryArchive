'From Squeak2.8alpha of 4 February 2000 [latest update: #2052] on 28 April 2000 at 6:39:05 pm'!"Change Set:		009PaintingTools-kfrDate:			26 April 2000Author:			Karl RambergHere is a complete changeset for the stuff I (with plenty of help from Bob Arning) have done with SketchEditorMorph and PaintBoxMorph.The paintbrush cursor is now a paintbrush with a circle indicating the size of the brush. The circle is displayed in a color distinctive from the one selected to paint with. The color picker cursor is now a eyedropper. The ellipse, rectangle, star and polygon tools now draw the selected color without a black outline. Exception is when a ""no color"" color selection is made when a black outline the size of the brush is drawn. Exception to this again is the polygon and star tool that does not handle thick brushes so a 1 pixel black outline is fixed for them."!!PaintBoxMorph methodsFor: 'actions' stamp: 'kfr 4/26/2000 21:42'!actionCursor	"Return the cursor to use with this painting action/tool. Offset of the form must be set."	| ff width co larger c box |action == #paint: ifTrue: ["Make a cursor from the brush and the color"		width _ self getNib width.		c _ self ringColor.		co _ (currentCursor offset - ((width//4)@34-(width//6))) min: (0@0).				larger _ width negated + 10@0 extent: currentCursor extent + (width@width).		ff _ currentCursor copy: larger.		ff colors at: 1 put: Color transparent.         	ff colors at: 2 put: Color transparent.	          ff offset: co - (width@width //2).            (FormCanvas on: ff) fillOval: (Rectangle center: ff offset negated						extent: width@width)                        color: Color transparent                        borderWidth: 1                        borderColor: c.	 	 ^ ff].		action == #erase: ifTrue: ["Make a cursor from the cursor and the color"		width _ self getNib width.		co _ (currentCursor offset + (width//2@4)) min: (0@0).		larger _ 0@0 extent: currentCursor extent + (width@width).		ff _ currentCursor copy: larger.		ff offset: co - (width@width //2).		ff fill: (box _ co negated extent: (width@width)) 					fillColor: (Color r: 0.5 g: 0.5 b: 1.0).		ff fill: (box insetBy: 1@1) fillColor: Color transparent.				^ ff].	^ currentCursor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'kfr 4/26/2000 22:25'!eyedropper: aButton action: aSelector cursor: aCursor         "Take total control and pick up a color!!!!"        | pt feedbackColor |        aButton state: #on.        tool ifNotNil: [tool state: #off].        currentCursor _ aCursor.        self activeHand                showTemporaryCursor: currentCursor                 hotSpotOffset: 6 negated @ 4 negated.    "<<<< the form was changed a bit??"        feedbackColor _ Display colorAt: Sensor cursorPoint.        self addMorphFront: colorMemory.        "Full color picker"        [Sensor anyButtonPressed]                whileFalse:                         [pt _ Sensor cursorPoint.                        "deal with the fact that 32 bit displays may have garbage in the alpha bits"                        feedbackColor _ Display depth = 32 ifTrue: [                                Color colorFromPixelValue: ((Display pixelValueAt: pt)														bitOr: 16rFF000000) depth: 32                        ] ifFalse: [                                Display colorAt: pt                        ].                        "the hand needs to be drawn"                        self activeHand position: pt.                        self world displayWorldSafely.                        Display fill: colorPatch bounds fillColor: feedbackColor].        Sensor waitNoButton.        self activeHand showTemporaryCursor: nil hotSpotOffset: 0 @ 0.        self currentColor: feedbackColor.        colorMemory delete.		         tool                ifNotNil:                         [tool state: #on.                        currentCursor _ tool arguments at: 3].        aButton state: #off! !!PaintBoxMorph methodsFor: 'actions' stamp: 'kfr 4/26/2000 21:17'!ringColor	"Choose a color that contrasts with my current color. If that color isn't redish, return red. Otherwise, return green"	currentColor isTransparent ifTrue: [^ Color red].	currentColor red < 0.5 ifTrue: [^ Color red].	currentColor red > (currentColor green + (currentColor blue * 0.5))		ifTrue: [^ Color green]		ifFalse: [^ Color red].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'kfr 4/26/2000 22:25'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| curs poly top |	super mouseEnter: evt.	top _ evt hand recipientForMouseDown: evt.	top == self ifTrue: ["none of my buttons in the way"		curs _ palette actionCursor.		evt hand showTemporaryCursor: curs.		palette getSpecial == #polygon: ifTrue:			[(poly _ self valueOfProperty: #polygon) ifNil: [^ self].			currentColor _ palette getColor.			poly color: currentColor; borderWidth: 1.			poly changed]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'kfr 4/25/2000 17:50'!ellipse: evt	"Draw an ellipse from the center. "	| rect oldRect ww ext oldExt |	ext _ (strokeOrigin - evt cursorPoint) abs * 2.	evt shiftPressed ifTrue: [ext _ ext r].	rect _ Rectangle center: strokeOrigin extent: ext.	ww _ palette getNib width.	lastEvent ifNotNil: [		oldExt _ (strokeOrigin - lastEvent cursorPoint) abs + ww * 2.		lastEvent shiftPressed ifTrue: [oldExt _ oldExt r].		(oldExt < ext) ifFalse: ["Last draw sticks out, must erase the area"			oldRect _ Rectangle center: strokeOrigin extent: oldExt.			self restoreRect: oldRect]].	currentColor == Color transparent	ifFalse:[	formCanvas fillOval: rect color: currentColor 		borderWidth: 0 borderColor: Color transparent.]	ifTrue:[	formCanvas fillOval: rect color: currentColor 		borderWidth: ww borderColor: Color black].	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'kfr 4/25/2000 17:51'!polyNew: evt	"Create a new polygon.  Add it to the sketch, and let the user dragits vertices around!!  Freeze it into the painting when the user choosesanother tool."	| poly |	self polyFreeze.		"any old one we were working on"	poly _ PolygonMorph new addHandles. 	currentColor == Color transparent	ifFalse:[	poly color: currentColor; borderWidth: 0;	borderColor: Color transparent]	ifTrue:[	poly color: currentColor; borderWidth: 1;     "still some problems with brushsize !!!!"	borderColor: Color black].	poly position: evt cursorPoint.	self addMorph: poly.	poly changed.	self setProperty: #polygon toValue: poly.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'kfr 4/25/2000 17:52'!rect: evt	"While moving corner, just write on the canvas.  When done, writeon the paintingForm"	| rect within oldRect now diff cor |	rect _ strokeOrigin rect: (now _ evt cursorPoint).	evt shiftPressed ifTrue:		[diff _ evt cursorPoint - strokeOrigin.		now _ strokeOrigin +			(Point r: (diff x abs min: diff y abs)*2 degrees:(diff degrees // 90 * 90 + 45)).		rect _ strokeOrigin rect: now].	lastEvent == nil ifFalse:		[oldRect _ strokeOrigin rect: lastEvent cursorPoint.		lastEvent shiftPressed ifTrue:			[diff _ lastEvent cursorPoint - strokeOrigin.			cor _ strokeOrigin + (Point r: (diff x abs min:diff y abs)*2						degrees: (diff degrees //90 * 90 + 45)).			oldRect _ strokeOrigin rect: cor].		within _ (rect containsRect: oldRect).		within & (currentColor isTransparent not) ifFalse:			["Last draw will stick out, must erase the area"			self restoreRect: oldRect]].	currentColor == Color transparent	ifFalse:[	formCanvas frameAndFillRectangle: rect fillColor: currentColor		borderWidth: 0 borderColor: Color transparent.]	ifTrue:[	formCanvas frameAndFillRectangle: rect fillColor: currentColor		borderWidth: (palette getNib width) borderColor: Color black].	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'kfr 4/25/2000 17:54'!star: evt	"Draw an star from the center. "	| poly ext ww rect oldExt oldRect oldR verts pt |	ww _ palette getNib width.	ext _ (pt _ strokeOrigin - evt cursorPoint) r + ww * 2.	rect _ Rectangle center: strokeOrigin extent: ext.	ww _ palette getNib width.	lastEvent ifNotNil: [		oldExt _ (strokeOrigin - lastEvent cursorPoint) r + ww * 2.		"Last draw sticks out, must erase the area"		oldRect _ Rectangle center: strokeOrigin extent: oldExt.		self restoreRect: oldRect].	ext _ pt r.	oldR _ ext.	verts _ (0 to: 350 by: 36) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext]) degrees: angle + pt degrees)			+ strokeOrigin].		poly _ PolygonMorph new addHandles.	currentColor == Color transparent	ifFalse:[	poly color: currentColor; borderWidth: 0; borderColor: Color transparent.]	ifTrue:[	poly color: currentColor; borderWidth: 1; borderColor: Color black ]. " can't handle thick brushes"	self invalidRect: rect.		"self addMorph: poly."	poly privateOwner: self.	poly bounds: (strokeOrigin extent: ext).	poly setVertices: verts.	poly drawOn: formCanvas.	"poly delete."	self invalidRect: rect.! !