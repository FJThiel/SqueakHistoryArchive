'From Squeak 2.2 of Sept 23, 1998 on 20 November 1998 at 5:27:08 pm'!!Set methodsFor: 'converting' stamp: 'ar 11/20/1998 16:34'!asSet	^self! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/20/1998 16:24'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	aSet equalBlock: self equalBlock fixTemps.	aSet hashBlock: self hashBlock fixTemps.	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/20/1998 16:08'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 16:08'!destString: aString	realDst := self split: aString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 16:08'!sourceString: aString	realSrc := self split: aString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:35'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht für n-m matches"	matches := PluggableDictionary new.	matches hashBlock: self pointHashBlock.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:57'!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index@index2 put: line]	].	srcLines doWithIndex:[:line :index|		(dstPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index2@index put: line]	].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:34'!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := PluggableDictionary new.	runList hashBlock: self pointHashBlock.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 17:26'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy _ srcPos copy.	srcPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	dstPosCopy _ dstPos copy.	dstPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:35'!pointHashBlock	^[:pt| (pt x bitShift: 12) + pt y] fixTemps! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:31'!remove: pointKey from: aSet	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	aSet copy do:[:obj|		obj x = pointKey x ifTrue:[			aSet remove: obj.		] ifFalse:[			obj y = pointKey y ifTrue:[				aSet remove: obj.			].		]	].! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:26'!split: aString by: splitChar	| lines index nextIndex |	lines := OrderedCollection new.	index _ 1.	[index <= aString size] whileTrue:[		nextIndex _ aString 						indexOf: splitChar 						startingAt: index 						ifAbsent:[aString size+1].		lines add: (aString copyFrom: index to: nextIndex-1).		index _ nextIndex+1].	^lines! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:06'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[(string at: 1) asInteger +					((string at: stringSize // 3) asInteger bitShift: 4) +					((string at: stringSize // 2) asInteger bitShift: 8) +					((string at: stringSize * 2 // 3) asInteger bitShift: 12) +					((string at: stringSize) asInteger bitShift: 16)]] fixTemps! !