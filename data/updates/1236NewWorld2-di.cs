'From Squeak 2.4c of May 10, 1999 on 9 June 1999 at 2:43:05 pm'!"Change Set:		NewWorld2Date:			8 June 1999Author:			Dan IngallsThis is phase 2 of the refactoring of WorldMorph.All accesses to project state get turned into messages.All methods that are defined BOTH in World and PasteUp (except initialize and access to inst vars) get merged.All methods that are defined BOTH in World and above PasteUp (except initialize) get merged.All non-conflicting methods of WorldMorph get (programatically) promoted to PasteUp and removed from World.Finally, all morphic projects get mutated into MorphicProjects and initialized from their worlds.When all is done, WorldMorph instanceCount should be zero (and everything else should work ;-).[Disney images may require   ScheduledControllers release; initializeto be rid of all WorldMorphs]"!!Object methodsFor: 'macpal'!currentWorld	"Answer a morphic world that is the current UI focus.		If in a morphic project, it's that project's world.  		If in an mvc project, it is the topmost morphic-mvc-window's worldMorph. 		If in an mvc project that has no morphic-mvc-windows, then it's just some existing worldmorph instance.		If in an mvc project in a Squeak that has NO WorldMorph instances, one is created.	This method will never return nil, it will always return its best effort at returning a relevant world morph, but if need be -- if there are no worlds anywhere, it will create a new one."	| aView aSubview |	World ifNotNil: [^ World].	aView _ ScheduledControllers controllerSatisfying:		[:ctrl | (aSubview _ ctrl view firstSubView) notNil and:			[aSubview model isMorph and: [aSubview model isWorldMorph]]].	^ aView		ifNotNil:			[aSubview model]		ifNil:			[PasteUpMorph newWorldForProject: nil]! !!EventHandler methodsFor: 'initialization'!adaptToWorld: aWorld	"If any of my recipients refer to a world or a hand, make them now refer to the corresponding items in the new world"	| value newValue |	#(mouseDownRecipient mouseStillDownRecipient mouseUpRecipient  mouseEnterRecipient  mouseLeaveRecipient  mouseEnterDraggingRecipient  mouseLeaveDraggingRecipient  keyStrokeRecipient valueParameter) do:		[:aName |			(value _ self instVarNamed: aName asString) ifNotNil:				[(value isMorph and: [value isWorldMorph]) ifTrue:						[newValue _ aWorld].				(value isKindOf: HandMorph) ifTrue:						[newValue _ aWorld primaryHand].				(value isKindOf: Presenter) ifTrue:						[newValue _ aWorld presenter].			(newValue notNil and: [newValue ~~ value])				ifTrue:					[self instVarNamed: aName asString put: newValue]]]! !!MenuItemMorph methodsFor: 'accessing'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	(target isMorph and: [target isWorldMorph]) ifTrue: [self target: aWorld].	(target isKindOf: HandMorph) ifTrue: [self target: aWorld primaryHand].	(target isKindOf: Presenter) ifTrue: [self target: aWorld presenter]! !!MorphWorldView class methodsFor: 'instance creation'!openWorldWith: aMorph labelled: labelString	| w |	(w _ PasteUpMorph newWorldForProject: nil) addMorph: aMorph.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 6/8/1999 14:49'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	self isWorldMorph ifTrue:		["Add the given morph to this world and start stepping it if it wants to be."		self addMorphFront: aMorph.		(aMorph fullBounds intersects: (0@0 extent: self viewBox extent)) ifFalse:			[self beep.  aMorph position: self bounds center].		self startSteppingSubmorphsOf: aMorph.		^ self].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 6/8/1999 14:19'!color: aColor	self isWorldMorph		ifTrue: ["Set the background color of this world."				color = aColor ifFalse: [					fillColor2 _ color _ aColor.					self fullRepaintNeeded.					"Propagate to view"					self changed: #newColor]]		ifFalse: [super color: aColor.				fillColor2 _ aColor]! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 6/8/1999 14:01'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [self damageRecorder ifNotNil:					[self damageRecorder recordInvalidRect: damageRect]]		ifFalse: [owner ifNotNil:					[owner invalidRect: (damageRect intersect: bounds)]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 6/8/1999 14:06'!presenter	"Normally only the world will have a presenter, but the architecture supports individual localized presenters as well"	^ presenter ifNil:		[self isWorldMorph			ifTrue: [presenter _ Presenter new associatedMorph: self]			ifFalse: [super presenter]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 6/8/1999 14:22'!residesInPartsBin	"Answer true if the receiver is, or has some ancestor owner who is, a parts bin"	self isWorldMorph		ifTrue: [^ self isPartsBin]		ifFalse: [^ self isPartsBin or: [super residesInPartsBin]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 6/8/1999 14:33'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	self isWorldMorph	ifTrue:		[aBank = 2 ifTrue:			[^ #(				(color			color		readWrite	getColor				setColor:)				(mouseX			number		readOnly	getMouseX			unused)				(mouseY		number		readOnly	getMouseY			unused))].		^ Array new]	ifFalse:		[aBank = 2 ifTrue: 			[^ #(	"		name			type		r/w			get selector			put selector			-----------		---------		-----------	---------------------	-------------   "			(color			color		readWrite	getColor				setColor:)			(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)			(borderColor		color		readWrite	getBorderColor		setBorderColor:)			(mouseX			number		readOnly	getMouseX			unused)			(mouseY		number		readOnly	getMouseY			unused))].		aBank = 3 ifTrue: 		[^ #(	"		name			type		r/w			get selector			put selector			-----------		---------		-----------	---------------------	-------------   "			(cursor 			number		readWrite	getCursor			setCursor:)			(valueAtCursor	player		readOnly	getValueAtCursor	unused)										"readWrite						setValueAtCursor:")].		^ Array new]! !!PasteUpMorph class methodsFor: 'as yet unclassified'!newWorldForProject: projectOrNil	"Return a new pasteUpMorph configured as a world (ie project notNil).	If projectOrNil is nil, then create a new one just to hold the state."	^ self new initForProject:		(projectOrNil == nil			ifTrue: [MorphicProject basicNew]			ifFalse: [projectOrNil])! !!Player methodsFor: 'costume'!hasCostumeThatIsAWorld	(costume renderedMorph isWorldMorph) ifTrue: [^ true].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume isWorldMorph) ifTrue: [^ true]]].	^ false! !!Player methodsFor: 'slots-kernel'!categories	| aList aRef |	(self hasCostumeThatIsAWorld)		ifTrue:	[^ self categoriesForWorld].	aList _ #('basic' ) asOrderedCollection.	self slotNames size > 0 ifTrue:		[aList add: 'instance variables'].	self class scripts size > 0 ifTrue:		[aList add: 'scripts'].	(self hasCostumeOfClass: JoystickMorph)		ifTrue:	[aList add: 'joystick'].	(self hasCostumeOfClass: BookMorph)		ifTrue:	[aList add: 'book navigation'].	(self hasCostumeOfClass: PaintBoxMorph)		ifTrue:	[aList add: 'paintbox'].	(self hasCostumeOfClass: PasteUpMorph)		ifTrue:	[aList addAll: #('pen trails' 'card/stack' 'playfield')].	aList addAll: #('tests' 'color & border' 'geometry' 'motion' 'pen use' 'miscellaneous' ).	((aRef _ self existingCostumeOfClass: ReferenceMorph) notNil and:		[aRef referent isKindOf: PaintBoxMorph])			ifTrue:	[aList add: 'paintbox'].	Preferences showPlayerSource ifTrue:		[aList addAll: Player organization categories].	aList removeAllFoundIn: #('card/stack commands' 'object fileIn').	^ aList! !!Player methodsFor: 'slots-kernel'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isWorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(isUnderMouse					boolean		readOnly	getIsUnderMouse		unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-kernel'!tilePhrasesSpecsForCategory: aCategory	"Return an array of slot and script names and info for use in a viewer on the receiver.  These can be of two flavors - script and slot.		(slot		heading		number				readWrite	getHeading		setHeading:)		(script		command 	wearCostumeOf: 	player)"	| aList nameString isWorld categorySymbol categoryString |	categoryString _ aCategory asString.	isWorld _ self hasCostumeThatIsAWorld.	(categoryString = 'instance variables') ifTrue:		[^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with:	#slot			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]].	"set selector"	(categoryString = 'scripts') ifTrue:		[^ self tileScriptCommands].	(categoryString = 'basic') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot x) (slot y) (slot heading) (slot colorUnder) (script forward:) (script turn:) (script beep:))]			ifTrue:				[#((script beep:))]].	(categoryString = 'tests') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot isOverColor) (slot isUnderMouse) (slot colorSees))]			ifTrue:				[#()]].	(categoryString = 'color & border') ifTrue:		[aList _ isWorld			ifFalse:				[#((slot color) (slot colorUnder) (slot borderColor) (slot borderWidth))]			ifTrue:				[#((slot color))]].	(categoryString = 'geometry') ifTrue:		[aList _ #((slot scaleFactor) (slot left) (slot right) (slot top) (slot bottom) (slot width) (slot height) (slot x) (slot y) (slot heading))].	(categoryString = 'miscellaneous') ifTrue:		[aList _ isWorld			ifFalse:				[#((script show) (script hide) (script wearCostumeOf:) (script startScript:) (script stopScript:) (script pauseScript:))]			ifTrue:				[#((script startScript:) (script stopScript:) (script pauseScript:))]].	(categoryString = 'motion') ifTrue:		[aList _ #((slot x) (slot y) (slot heading) (script forward:) (script moveToward:) (script turn:) (script bounce:) (script wrap) (script followPath) (script goToRightOf:))].	(categoryString = 'pen trails') ifTrue:		[aList _ #((script liftAllPens) (script lowerAllPens) (script clearTurtleTrails))].	(categoryString = 'pen use') ifTrue:		[aList _ #((slot penColor) (slot penSize) (slot penDown))].	(categoryString = 'card/stack') ifTrue:		[aList _ #((script goToNextCard) (script goToPreviousCard) (script deleteCard) (script newCard))].	(categoryString = 'joystick') ifTrue:		[aList _ #((slot amount) (slot angle) (slot leftRight) (slot upDown))].	(categoryString = 'playfield') ifTrue:		[aList _ #((script initiatePainting) (slot cursor) (slot valueAtCursor) (slot mouseX) (slot mouseY)(script roundUpStrays) (script unhideHiddenObjects))].	(categoryString = 'paintbox') ifTrue:		[aList _ #((script makeNewDrawingIn:))].	(categoryString = 'book navigation') ifTrue:		[aList _ #((script nextPage) (script previousPage) (script firstPage) (script lastPage) (script goto:))].	aList ifNil:		[^ (Player organization categories includes: (categorySymbol _ aCategory asSymbol))			ifTrue:				[self tilePhraseSpecsForPlayerCategory: categorySymbol]			ifFalse:				[self error: 'faulty category: ', categorySymbol.				Array new]].	^ aList collect: [:aPair | self phraseSpecFor: aPair]! !!Preferences class methodsFor: 'preferences panel'!openPreferencesControlPanel        "Preferences openPreferencesControlPanel"        | aPanel aWindow aRow wrapper but aList odd aColor w width1 width2 spacer |        Smalltalk verifyMorphicAvailability ifFalse: [^ self beep].        aPanel _ AlignmentMorph newColumn.        aPanel beSticky.        aList _ OrderedCollection new.        FlagDictionary associationsDo: [:assoc | aList add: (Array                                with: assoc key                                with: assoc value                                with: (self helpMessageForPreference: assoc key))].        odd _ false.        width1 _ 172.        spacer _ 4.        width2 _ 14.        (aList asSortedCollection: [:a :b | a first < b first])                do:                         [:triplet |                         aPanel addMorphBack: (aRow _ AlignmentMorph newRow).                        aRow color: (aColor _ odd                                                        ifTrue: [Color green muchLighter]                                                        ifFalse: [Color red veryMuchLighter]).                        odd _ odd not.                        aRow addMorph: (wrapper _ Morph new color: aColor).                        wrapper setBalloonText: triplet third.                        wrapper extent: width1 @ 15.                        wrapper addMorph: (StringMorph new contents: triplet first).                        aRow addMorphBack: (Morph new color: aColor; extent: (spacer @ 15)).                        aRow addMorphBack: (wrapper _ Morph new color: aColor).                        wrapper extent: width2 @ 15.                        wrapper addMorphBack: (but _ UpdatingBooleanStringMorph new contents: triplet second printString).                        but getSelector: triplet first;                        putSelector: #setPreference:toValue:;                        stepTime: 1800;                         target: self].                wrapper _ ScrollPane new.                wrapper scroller addMorph: aPanel.        Smalltalk isMorphic                ifTrue:                        [aWindow _ SystemWindow new model: self.                        aWindow addMorph: wrapper frame: (0 @ 0 extent: 1 @ 1).                        aWindow setLabel: 'Preferences'.                        aWindow openInWorld]                ifFalse:                        [(w _ PasteUpMorph newWorldForProject: nil)						addMorph: wrapper.                        wrapper                                retractable: false;                                extent: self initialExtent + (wrapper scrollbarWidth @ 0).                        w startSteppingSubmorphsOf: wrapper.                        MorphWorldView openOn: w                                label: 'Preferences'                                extent: w fullBounds extent]! !!Project methodsFor: 'initialization'!defaultBackgroundColor	^ world isMorph		ifTrue: [self backgroundColorForMorphicProject]		ifFalse: [self backgroundColorForMvcProject]! !!Project methodsFor: 'initialization' stamp: 'di 6/8/1999 23:17'!initFromParent:  aProject	"Written so that Morphic can still be removed."	Smalltalk verifyMorphicAvailability ifFalse: [^ nil].	world _ PasteUpMorph newWorldForProject: self.	changeSet _ ChangeSet new initialize.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ aProject! !!Project methodsFor: 'initialization' stamp: 'di 6/9/1999 14:42'!wedToWorldIfMorphic	"Converts an existing morphic project to an instance of MorphicProject,	with project state copied from its world.	Then it also converts its world to a pasteUpMorph, and points that back	at the new project for its project state."	| newProject |	self isMorphic ifFalse: [^ self].	newProject _ self as: MorphicProject.	newProject copySameFrom: world.	world instVarNamed: 'project' put: self.  "Will become newProject, heh-heh"	world become: (world as: PasteUpMorph).	self become: newProject.! !!Project class methodsFor: 'instance creation' stamp: 'di 6/8/1999 23:16'!newMorphic   "ProjectView open: Project newMorphic"	self == Project ifTrue: [self error: 'Should only be sent to MorphicProject'].	^ self basicNew initFromParent: CurrentProject! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'di 6/8/1999 23:13'!newMorphicConstruction	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ MorphicProject newMorphicConstruction.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'di 6/8/1999 23:14'!newMorphicProject	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ MorphicProject newMorphic.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ScreenController methodsFor: 'menu messages' stamp: 'di 6/8/1999 23:12'!openConstructionProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView openAndEnter: MorphicProject newMorphicConstruction! !!ScreenController methodsFor: 'menu messages'!openMorphicConstructionWorld 	| aWorld anExtent aWindow |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	anExtent _  700 @ 500.	aWorld _ PasteUpMorph newWorldForProject: nil.	aWorld setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aWorld addMorph: (aWindow _ aWorld presenter standardPartsWindow position: 10@10).	aWindow activate.	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !!ScreenController methodsFor: 'menu messages' stamp: 'di 6/8/1999 23:14'!openMorphicProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView open: MorphicProject newMorphic.! !!ScreenController methodsFor: 'menu messages'!openMorphicWorld 	"Create and schedule a StringHolderView for use as a workspace."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	(PasteUpMorph newWorldForProject: nil) open.! !!SimpleButtonMorph methodsFor: 'initialization'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	(target isMorph and: [target isWorldMorph]) ifTrue: [self target: aWorld].	(target isKindOf: HandMorph) ifTrue: [self target: aWorld primaryHand].	(target isKindOf: Presenter) ifTrue: [self target: aWorld presenter]! !!StringButtonMorph methodsFor: 'initialization'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	(target isMorph and: [target isWorldMorph]) ifTrue: [self target: aWorld].	(target isKindOf: HandMorph) ifTrue: [self target: aWorld primaryHand].	(target isKindOf: Presenter) ifTrue: [self target: aWorld presenter]! !!SystemDictionary class methodsFor: 'initialization'!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	Smalltalk addToStartUpList: DisplayScreen.	Smalltalk addToStartUpList: Cursor.	Smalltalk addToStartUpList: InputSensor.	Smalltalk addToStartUpList: ProcessorScheduler.  "Starts low space watcher and bkground."	Smalltalk addToStartUpList: Delay.	Smalltalk addToStartUpList: FileDirectory.  "Enables file stack dump and opens sources."	Smalltalk addToStartUpList: ShortIntegerArray.	Smalltalk addToStartUpList: ShortRunArray.	Smalltalk addToStartUpList: CrLfFileStream.	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	Smalltalk addToStartUpList: PasteUpMorph.	Smalltalk addToStartUpList: ControlManager.	oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	Smalltalk addToShutDownList: DisplayScreen.	Smalltalk addToShutDownList: Form.	Smalltalk addToShutDownList: ControlManager.	Smalltalk addToShutDownList: StrikeFont.	Smalltalk addToShutDownList: Color.	Smalltalk addToShutDownList: FileDirectory.	Smalltalk addToShutDownList: Delay.	Smalltalk addToShutDownList: SoundPlayer.	Smalltalk addToShutDownList: HttpUrl.	Smalltalk addToShutDownList: Password.	Smalltalk addToShutDownList: PWS.	Smalltalk addToShutDownList: MailDB.	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!ThreePhaseButtonMorph methodsFor: 'as yet unclassified'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	(target isMorph and: [target isWorldMorph]) ifTrue: [self target: aWorld].	(target isKindOf: HandMorph) ifTrue: [self target: aWorld primaryHand].	(target isKindOf: Presenter) ifTrue: [self target: aWorld presenter]! !!Utilities class methodsFor: 'durable menus'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld _ PasteUpMorph newWorldForProject: nil.	colorList _  (1 to: labelList size) collect:		[:ind | Color colorFrom: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!WorldMorph methodsFor: 'initialization' stamp: 'di 6/8/1999 15:00'!initForProject: aProject	project _ aProject.	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	self hands: Array new.	self addHand: HandMorph new.	self damageRecorder: DamageRecorder new.	self stepList: OrderedCollection new.	self lastStepTime: 0.	self setProperty: #automaticPhraseExpansion toValue: true.	model _ nil.! !!WorldMorph methodsFor: 'initialization' stamp: 'di 6/8/1999 13:55'!initialize	super initialize.	project _ self.  "For local access during conversion."	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	self hands: Array new.	self addHand: HandMorph new.	self damageRecorder: DamageRecorder new.	self stepList: OrderedCollection new.	self lastStepTime: 0.	self setProperty: #automaticPhraseExpansion toValue: true.	model _ nil.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/7/1999 20:14'!install	self viewBox: Display boundingBox.	self handsDo: [:h | h initForEvents].	self installFlaps.	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/8/1999 13:32'!sleep	self canvas ifNil: [^ self  "already called (clean this up)"].	Cursor normal show.	"restore the normal cursor"	(turtleTrailsForm ~~ nil and: [self confirm: 'May I clear the pen trailsin this project to save space?']) ifTrue: [self clearTurtleTrails].	self canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!WorldMorph methodsFor: 'submorphs-accessing' stamp: 'di 6/8/1999 22:49'!allMorphsDo: aBlock	"Enumerate all morphs in the world, including those held in hands."	super allMorphsDo: aBlock.	self isWorldMorph		ifTrue: [self hands reverseDo: [:h | h allMorphsDo: aBlock]].! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:33'!assuredCanvas	(self canvas == nil or:	 [(self canvas extent ~= self viewBox extent)		or: [self canvas form depth ~= Display depth]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (FormCanvas extent: self viewBox extent)].	^ self canvas! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:41'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ self damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		self handsDo: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: self canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: self canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: self canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	self canvas flush.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: self viewBox origin)]]		ifFalse: [self canvas showAt: self viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: self canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:31'!displayWorldAsTwoTone	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f _ ColorForm extent: self viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: (FormCanvas on: f).	"force the entire canvas to be redrawn"	self fullRepaintNeeded.	self drawInvalidAreasOn: self canvas.  "redraw on offscreen canvas"	self canvas showAt: self viewBox origin.  "copy redrawn areas to Display"	Display forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:39'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(self canvas == nil or:	 [(self canvas extent ~= self viewBox extent) or:	 [self canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: self viewBox extent)].	self canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: self canvas].	self hands reverseDo: [:h | h fullDrawOn: self canvas].	self canvas form displayOn: Display at: self viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Display forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:35'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false].	DisableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self == World		ifTrue: [  "this world fills the entire Display"			((self canvas == nil) or: [self canvas form ~~ Display]) ifTrue: [				self canvas: (FormCanvas on: Display).				self viewBox: Display boundingBox]]		ifFalse: [  "this world is inside an MVC window"			((self canvas == nil) or:			 [(self canvas form ~~ Display) or:			 [(self canvas origin ~= self viewBox origin)]]) ifTrue: [				self canvas:					((FormCanvas on: Display)						copyOffset: self viewBox origin clipRect: self viewBox)]].	^ true! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:42'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ self damageRecorder invalidRectsFullBounds: (0@0 extent: self viewBox extent).	self damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm visible]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0].				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/8/1999 13:26'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: self viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r translateBy: self viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!WorldMorph methodsFor: 'drawing' stamp: 'di 6/7/1999 20:21'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result _ OrderedCollection new.	self handsDo: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds _ h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!WorldMorph methodsFor: 'events' stamp: 'di 6/8/1999 22:51'!handlesMouseDown: evt	self isWorldMorph		ifTrue: [^ true]		ifFalse: [^ super handlesMouseDown: evt]! !!WorldMorph methodsFor: 'events' stamp: 'di 6/8/1999 22:53'!mouseDown: evt	"Handle a mouse down event."	self isWorldMorph		ifTrue: [evt hand newKeyboardFocus: self.				evt hand invokeMetaMenu: evt]		ifFalse: [^ super mouseDown: evt]! !!WorldMorph methodsFor: 'stepping' stamp: 'di 6/8/1999 13:47'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now m oldWakeupTime |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	self stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	self stepList do: [:entry |		m _ entry at: 1.		oldWakeupTime _ entry at: 2.		entry at: 2 put: now + ((oldWakeupTime - earliestTime) min: m stepTime)].	self lastStepTime: now.! !!WorldMorph methodsFor: 'stepping' stamp: 'di 6/8/1999 13:46'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < self lastStepTime) or: [(now - self lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"! !!WorldMorph methodsFor: 'stepping' stamp: 'di 6/8/1999 13:45'!isStepping: aMorph	"Return true if the given morph is in the step list."	self stepList do: [:entry | entry first == aMorph ifTrue: [^ true]].  "already stepping"	^ false! !!WorldMorph methodsFor: 'stepping' stamp: 'di 6/8/1999 13:49'!runStepMethods	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	self stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < self lastStepTime) or: [(now - self lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[self stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == self			ifTrue: [				wakeupTime <= now					ifTrue: [						morphToStep step.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse: [				deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]].	] ifError:[:err :rcvr|		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"	].	deletions ifNotNil: [		deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	self lastStepTime: now.! !!WorldMorph methodsFor: 'stepping' stamp: 'di 6/8/1999 13:44'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	self stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	self adjustWakeupTimesIfNecessary.	self stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!WorldMorph methodsFor: 'stepping' stamp: 'di 6/8/1999 13:44'!stopStepping: aMorph	"Remove the given morph from the step list."	self stepList copy do: [:entry |		entry first == aMorph ifTrue: [self stepList remove: entry ifAbsent: []]].! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/7/1999 20:16'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	self hands: (self hands copyWith: aHandMorph).	aHandMorph privateOwner: self.! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/8/1999 13:18'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(self hands includes: aHandMorph) ifTrue: [		aHandMorph dropMorphsEvent: MorphicEvent new.		self hands: (self hands copyWithout: aHandMorph).		self invalidRect: aHandMorph fullBounds.		self activeHand == aHandMorph ifTrue: [self activeHand: nil]].! !!WorldMorph methodsFor: 'change reporting' stamp: 'di 6/8/1999 13:41'!fullRepaintNeeded	self damageRecorder doFullRepaint.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 6/8/1999 13:21'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."	"process user input events, but only for remote hands"	self handsDo: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			self activeHand: h.			h processEvents.			self activeHand: nil]].	self runStepMethods.	self displayWorldSafely.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 6/7/1999 20:13'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	self handsDo: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorldSafely.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 6/8/1999 13:20'!doOneSubCycle	"Like doOneCycle, but preserves activeHand."	| currentHand |	currentHand _ self activeHand.	self interCyclePause: MinCycleLapse.	self doOneCycleNow.	self activeHand: currentHand! !!WorldMorph methodsFor: 'interaction loop' stamp: 'di 6/8/1999 13:50'!interCyclePause: milliSecs	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	currentTime _ Time millisecondClockValue.	self lastCycleTime ifNotNil: [ 		wait _ self lastCycleTime + milliSecs - currentTime.		wait > 0 ifTrue: [ 			wait < milliSecs  "big waits happen after a snapshot"				ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ].	self lastCycleTime: currentTime! !!WorldMorph methodsFor: 'painting support' stamp: 'di 6/7/1999 20:15'!installForm: aForm	"Accept a Form from the outside, create a SketchMorph, and put it on the Hand."	| f |	f _ SketchMorph new form: aForm.	self firstHand attachMorph: f.! !!WorldMorph methodsFor: 'sensing' stamp: 'di 6/7/1999 20:14'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	submorphs reverseDo:		[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ c form]]				ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)							ifTrue: [^ c form]]].  	self hands reverseDo: [:h |		h submorphsReverseDo:		[:m | m == stopMorph			ifTrue: [stopThere ifTrue: [^ c form]]			ifFalse: [(m fullDrawOn: c without: stopMorph andStopThere: stopThere)						ifTrue: [^ c form]]]].  	^ c form! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'di 6/8/1999 22:56'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	self isWorldMorph		ifTrue: ["Note, when this file is loaded in an MVC project, this will return nil.				The MenuItemMorph that has this in a field will have that item not work.				Maybe warn the user at load time?"				^ DiskProxy global: #World selector: #yourself args: #()]		ifFalse: [^ super objectForDataStream: refStrm]	! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'di 6/8/1999 22:59'!storeDataOn: aDataStream	"WorldMorphs only save certain fields when written to the disk.  Save only the world's submorphs, model, and stepList. See DataStream.typeIDFor:  "	| cntInstVars cntIndexedVars instVars data ind |	self isWorldMorph		ifTrue: [^ self error: 'Worlds may not be stored out this way']		ifFalse: [^ super storeDataOn: aDataStream]."NOTE: code below is inaccessible..."	"Why would we want to do it this way, as opposed to installing in the target system's world?"	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	instVars _ self class allInstVarNames.	data _ Array new: instVars size.	"Add any additional fields to write here"	ind _ (instVars indexOf: 'model').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: model].	ind _ (instVars indexOf: 'submorphs').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: submorphs].	ind _ (instVars indexOf: 'stepList').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: self stepList].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (data at: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'di 6/8/1999 23:01'!veryDeepCopyWith: deepCopier	"See storeDataOn:"	self isWorldMorph		ifTrue: ["maybe ^ self later?  For now, catch all offenders."				^ self error: 'Worlds should not be copied']		ifFalse: [^ super veryDeepCopyWith: deepCopier]! !!WorldMorph methodsFor: 'etoy support' stamp: 'di 6/8/1999 22:57'!referencePlayfield	self isWorldMorph		ifTrue: [^ self submorphNamed: 'playfield']		ifFalse: [^ super referencePlayfield]! !!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'di 6/8/1999 22:49'!addAllMorphs: array	super addAllMorphs: array.	self isWorldMorph		ifTrue: [array do: [:m | self startSteppingSubmorphsOf: m]].! !SystemDictionary initialize!WorldMorph removeSelector: #invalidRect:!WorldMorph removeSelector: #world!WorldMorph removeSelector: #project:!WorldMorph removeSelector: #color:!WorldMorph removeSelector: #presenter!WorldMorph removeSelector: #residesInPartsBin!WorldMorph removeSelector: #handsDo:!WorldMorph removeSelector: #slotNamesAndTypesForBank:!WorldMorph removeSelector: #isWorldMorph!WorldMorph removeSelector: #acceptDroppingMorph:event:!WorldMorph removeSelector: #firstHand!WorldMorph class removeSelector: #includeInNewMorphMenu!WorldMorph class removeSelector: #openWithStandardPartsBinShowing!"Postscript:Promote all WorldMorph methods to PasteUpMorph.Mutate all morphic projects into MorphicProjects.Mutate all remaining WorldMorphs to PasteUpMorphs with project state..."Utilities authorInitials.  "So it doesnt come at a bad time"PasteUpMorph ensureClassPool.WorldMorph classPool keys do:	[:var | PasteUpMorph classPool declare: var from: WorldMorph classPool].(WorldMorph selectors reject: [:s | PasteUpMorph includesSelector: s]) do:	[:sel | PasteUpMorph compile: (WorldMorph sourceCodeAt: sel) classified: 'project'.	WorldMorph removeSelector: sel].(WorldMorph class selectors reject: [:s | PasteUpMorph class includesSelector: s]) do:	[:sel | PasteUpMorph class compile: (WorldMorph class sourceCodeAt: sel) classified: 'project'.	WorldMorph class removeSelector: sel].WorldMorph organization removeEmptyCategories.WorldMorph class organization removeEmptyCategories.Smalltalk garbageCollect.Project allInstances do:	[:proj | proj wedToWorldIfMorphic].Smalltalk garbageCollect.WorldMorph allInstances do:	[:wm | Project basicNew instVarNamed: 'world' put: wm; wedToWorldIfMorphic].PasteUpMorph allInstances do:	[:wm | wm borderWidth ifNil: [wm borderWidth: 0]].!