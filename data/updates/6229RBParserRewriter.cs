'From Squeak3.8alpha of ''17 July 2004'' [latest update: #6228] on 23 September 2004 at 3:40:29 pm'!"Change Set:		RBParserRewriterDate:			23 September 2004Author:			Marcus DenkerThis adds the ParseTreeRewriter and RBParser (for now)"!RBProgramNodeVisitor subclass: #ParseTreeSearcher	instanceVariableNames: 'searches answer argumentSearches context messages'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!ParseTreeSearcher subclass: #ParseTreeRewriter	instanceVariableNames: 'tree'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!Object subclass: #RBParseTreeRule	instanceVariableNames: 'searchTree owner'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!Object subclass: #RBParser	instanceVariableNames: 'scanner currentToken nextToken emptyStatements negatedNumbers errorBlock tags source'	classVariableNames: 'BRAraryNode ParserType'	poolDictionaries: ''	category: 'Compiler-AST-RBParser'!RBBlockNode subclass: #RBPatternBlockNode	instanceVariableNames: 'valueBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!RBProgramNodeVisitor subclass: #RBReadBeforeWrittenTester	instanceVariableNames: 'read checkNewTemps scopeStack'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!RBParseTreeRule subclass: #RBReplaceRule	instanceVariableNames: 'verificationBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!RBReplaceRule subclass: #RBBlockReplaceRule	instanceVariableNames: 'replaceBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!Stream subclass: #RBScanner	instanceVariableNames: 'stream buffer tokenStart currentCharacter characterType classificationTable numberType separatorsInLiterals extendedLiterals extendedSymbols comments extendedLanguage errorBlock nameSpaceCharacter'	classVariableNames: 'ClassificationTable PatternVariableCharacter'	poolDictionaries: ''	category: 'Compiler-AST-RBParser'!RBParseTreeRule subclass: #RBSearchRule	instanceVariableNames: 'answerBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!Dictionary subclass: #RBSmallDictionary	instanceVariableNames: 'keys values size'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!RBReplaceRule subclass: #RBStringReplaceRule	instanceVariableNames: 'replaceTree'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-ParseTree Matching'!!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!answer	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!context	^context! !!ParseTreeSearcher methodsFor: 'accessing'!executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree 	"Save our current context, in case someone is performing another search inside a match."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree! !!ParseTreeSearcher methodsFor: 'accessing'!messages	messages notNil ifTrue: [^messages].	argumentSearches isEmpty ifFalse: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray! !!ParseTreeSearcher methodsFor: 'private'!foundMatch! !!ParseTreeSearcher methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]! !!ParseTreeSearcher methodsFor: 'private'!performSearches: aSearchCollection on: aNode 	| value |	1 to: aSearchCollection size		do: 			[:i | 			value := (aSearchCollection at: i) performOn: aNode.			value notNil 				ifTrue: 					[self foundMatch.					^value]].	^nil! !!ParseTreeSearcher methodsFor: 'private'!recusivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self lookForMoreMatchesInContext: oldContext.	context := oldContext! !!ParseTreeSearcher methodsFor: 'searching'!matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'visiting'!visitArgument: aNode 	| value |	value := self performSearches: argumentSearches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]! !!ParseTreeSearcher methodsFor: 'visiting'!visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]! !!ParseTreeSearcher methodsFor: 'testing'!canMatchMethod: aCompiledMethod 	^self messages isEmpty or: 			[(self messages detect: [:each | aCompiledMethod sendsSelector: each]				ifNone: [nil]) notNil]! !!ParseTreeSearcher methodsFor: 'initialize-release'!answer: anObject	answer := anObject! !!ParseTreeSearcher methodsFor: 'initialize-release'!initialize	super initialize.	context := RBSmallDictionary new.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptBlockNode: aBlockNode 	aBlockNode arguments: (self visitArguments: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								show: 'Cannot replace message node inside of cascaded node with non-message node.';								cr.							newMessages add: each]]].	notFound size == aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptMessageNode: aMessageNode 	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode 		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptMethodNode: aMethodNode 	aMethodNode arguments: (self visitArguments: aMethodNode arguments).	aMethodNode body: (self visitNode: aMethodNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptOptimizedNode: anOptimizedNode 	anOptimizedNode body: (self visitNode: anOptimizedNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptSequenceNode: aSequenceNode 	aSequenceNode temporaries: (self visitArguments: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'accessing'!executeTree: aParseTree 	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeRewriter methodsFor: 'accessing'!tree	^tree! !!ParseTreeRewriter methodsFor: 'private'!foundMatch	answer := true! !!ParseTreeRewriter methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: 					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]! !!ParseTreeRewriter methodsFor: 'visiting'!visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]! !!ParseTreeSearcher class methodsFor: 'private'!buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]! !!ParseTreeSearcher class methodsFor: 'instance creation'!getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!justSendsSuper	^(self new)		matchesAnyMethodOf: 				#('`@method: `@Args ^super `@method: `@Args' 				'`@method: `@Args super `@method: `@Args')			do: [:aNode :ans | true];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatchingStatements: aString in: aParseTree 	| notifier tree lastIsReturn |	notifier := self new.	tree := RBParser parseExpression: aString.	lastIsReturn := tree lastIsReturn.	notifier matches: (lastIsReturn 				ifTrue: ['| `@temps | `@.S1. ' , tree formattedCode]				ifFalse: ['| `@temps | `@.S1. ' , tree formattedCode , '. `@.S2'])		do: [:aNode :answer | ^tree].	notifier executeTree: aParseTree.	^nil! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree searchStmt replaceStmt |	tree := self buildTree: code method: false.	tree lastIsReturn		ifTrue: 			[searchStmt := '| `@temps | `@.Statements. ' , code.			replaceStmt := '| `@temps | `@.Statements. ^' , newCode]		ifFalse: 			[searchStmt := '| `@temps | `@.Statements1. ' , code , '.  `@.Statements2'.			replaceStmt := '| `@temps | `@.Statements1. ' , newCode , '.  `@.Statements2'].	^self		replace: searchStmt		with: replaceStmt		in: aParseTree		onInterval: anInterval! !!ParseTreeRewriter class methodsFor: 'instance creation'!classVariable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self class'! !!ParseTreeRewriter class methodsFor: 'instance creation'!removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule 		replace: '`#literal'		withValueFrom: [:aNode | aNode]		when: 			[:aNode | 			self 				replaceLiteral: literal				with: newLiteral				inToken: aNode token].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!variable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self'! !!ParseTreeRewriter class methodsFor: 'instance creation'!variable: aVarName getter: getMethod setter: setMethod receiver: aString 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: aString , ' ' , setMethod , ' ``@object';		replace: aVarName with: aString , ' ' , getMethod.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'private'!replaceLiteral: literal with: newLiteral inToken: literalToken 	| value |	value := literalToken realValue.	(value class = literal class and: [value = literal]) 		ifTrue: 			[literalToken 				value: newLiteral				start: nil				stop: nil.			^true].	^value class == Array and: 			[literalToken value inject: false				into: 					[:bool :each | 					bool | (self 								replaceLiteral: literal								with: newLiteral								inToken: each)]]! !!RBParseTreeRule methodsFor: 'matching'!canMatch: aProgramNode 	^true! !!RBParseTreeRule methodsFor: 'matching'!foundMatchFor: aProgramNode	^aProgramNode! !!RBParseTreeRule methodsFor: 'matching'!performOn: aProgramNode 	self context empty.	^((searchTree match: aProgramNode inContext: self context) 		and: [self canMatch: aProgramNode]) 			ifTrue: 				[owner recusivelySearchInContext.				self foundMatchFor: aProgramNode]			ifFalse: [nil]! !!RBParseTreeRule methodsFor: 'initialize-release'!initialize! !!RBParseTreeRule methodsFor: 'initialize-release'!methodSearchString: aString 	searchTree := RBParser parseRewriteMethod: aString! !!RBParseTreeRule methodsFor: 'initialize-release'!owner: aParseTreeSearcher	owner := aParseTreeSearcher! !!RBParseTreeRule methodsFor: 'initialize-release'!searchString: aString 	searchTree := RBParser parseRewriteExpression: aString! !!RBParseTreeRule methodsFor: 'accessing'!sentMessages	^searchTree sentMessages! !!RBParseTreeRule methodsFor: 'private'!context	^owner context! !!RBParseTreeRule class methodsFor: 'instance creation'!methodSearch: aString 	^(self new)		methodSearchString: aString;		yourself! !!RBParseTreeRule class methodsFor: 'instance creation'!new	^(super new)		initialize;		yourself! !!RBParseTreeRule class methodsFor: 'instance creation'!search: aString 	^(self new)		searchString: aString;		yourself! !!RBParser methodsFor: 'private-parsing'!parseArgs	| args |	args := OrderedCollection new.	[currentToken isIdentifier]		whileTrue: [args add: self parseVariableNode].	^args! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/24/2000 00:11'!parseArray	"parse Squeak's {} construct"	| leftBrace node rightBrace |	leftBrace _ currentToken start.	self step.	node _ RBArrayNode new.	self parseStatementList: false  into: node.	(currentToken isSpecial and: [currentToken value == $}]) ifFalse: [		self parserError: 'expected }' ].	rightBrace _ currentToken start.	self step.	node leftBrace: leftBrace.	node rightBrace: rightBrace.	^node! !!RBParser methodsFor: 'private-parsing'!parseAssignment	"Need one token lookahead to see if we have a ':='. This method could 	make it possible to assign the literals true, false and nil."	| node position |	(currentToken isIdentifier and: [self nextToken isAssignment]) 		ifFalse: [^self parseCascadeMessage].	node := self parseVariableNode.	position := currentToken start.	self step.	^RBAssignmentNode 		variable: node		value: self parseAssignment		position: position! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessage	| node |	node := self parseUnaryMessage.		[currentToken isLiteral ifTrue: [self patchNegativeLiteral].	currentToken isBinary] 			whileTrue: [node := self parseBinaryMessageWith: node].	^node! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessageWith: aNode 	| binaryToken |	binaryToken := currentToken.	self step.	^RBMessageNode 		receiver: aNode		selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseUnaryMessage)! !!RBParser methodsFor: 'private-parsing'!parseBinaryPattern	| binaryToken |	currentToken isBinary 		ifFalse: [self parserError: 'Message pattern expected'].	binaryToken := currentToken.	self step.	^RBMethodNode selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseVariableNode)! !!RBParser methodsFor: 'private-parsing'!parseBlock	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: RBBlockNode new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $]]) 		ifFalse: [self parserError: ''']'' expected'].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing'!parseBlockArgsInto: node 	| verticalBar args colons |	args := OrderedCollection new: 2.	colons := OrderedCollection new: 2.	verticalBar := false.	[currentToken isSpecial and: [currentToken value == $:]] whileTrue: 			[colons add: currentToken start.			self step.	":"			verticalBar := true.			args add: self parseVariableNode].	verticalBar 		ifTrue: 			[currentToken isBinary 				ifTrue: 					[node bar: currentToken start.					currentToken value == #| 						ifTrue: [self step]						ifFalse: 							[currentToken value == #'||' 								ifTrue: 									["Hack the current token to be the start 									of temps bar"									currentToken										value: #|;										start: currentToken start + 1]								ifFalse: [self parserError: '''|'' expected']]]				ifFalse: 					[(currentToken isSpecial and: [currentToken value == $]]) 						ifFalse: [self parserError: '''|'' expected']]].	node		arguments: args;		colons: colons.	^node! !!RBParser methodsFor: 'private-parsing'!parseCascadeMessage	| node receiver messages semicolons |	node := self parseKeywordMessage.	(currentToken isSpecial 		and: [currentToken value == $; and: [node isMessage]]) ifFalse: [^node].	receiver := node receiver.	messages := OrderedCollection new: 3.	semicolons := OrderedCollection new: 3.	messages add: node.	[currentToken isSpecial and: [currentToken value == $;]] whileTrue: 			[semicolons add: currentToken start.			self step.			messages add: (currentToken isIdentifier 						ifTrue: [self parseUnaryMessageWith: receiver]						ifFalse: 							[currentToken isKeyword 								ifTrue: [self parseKeywordMessageWith: receiver]								ifFalse: 									[| temp |									currentToken isLiteral ifTrue: [self patchNegativeLiteral].									currentToken isBinary ifFalse: [self parserError: 'Message expected'].									temp := self parseBinaryMessageWith: receiver.									temp == receiver ifTrue: [self parserError: 'Message expected'].									temp]])].	^RBCascadeNode messages: messages semicolons: semicolons! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessage	^self parseKeywordMessageWith: self parseBinaryMessage! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessageWith: node 	| args isKeyword keywords |	args := OrderedCollection new: 3.	keywords := OrderedCollection new: 3.	isKeyword := false.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseBinaryMessage.			isKeyword := true].	^isKeyword 		ifTrue: 			[RBMessageNode 				receiver: node				selectorParts: keywords				arguments: args]		ifFalse: [node]! !!RBParser methodsFor: 'private-parsing'!parseKeywordPattern	| keywords args |	keywords := OrderedCollection new: 2.	args := OrderedCollection new: 2.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseVariableNode].	^RBMethodNode selectorParts: keywords arguments: args! !!RBParser methodsFor: 'private-parsing'!parseMessagePattern	^currentToken isIdentifier		ifTrue: [self parseUnaryPattern]		ifFalse: 			[currentToken isKeyword				ifTrue: [self parseKeywordPattern]				ifFalse: [self parseBinaryPattern]]! !!RBParser methodsFor: 'private-parsing'!parseMethod	| methodNode |	methodNode := self parseMessagePattern.	self parseResourceTag.	self addCommentsTo: methodNode.	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^methodNode! !!RBParser methodsFor: 'private-parsing' stamp: 'bh 3/7/2000 01:36'!parseMethodWithNoComments	| methodNode |	methodNode _ self parseMessagePattern.	self parseResourceTag.	"self addCommentsTo: methodNode."	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^ methodNode! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/30/2000 18:16'!parseNegatedNumber	| token |	(self nextToken isLiteral not or: [ self nextToken realValue isNumber not ])		ifTrue: [ self parserError: 'only numbers may be negated' ].	"create a new token out of the $- and the number"	token := RBLiteralToken value: (self nextToken realValue negated) start: currentToken start stop: nextToken stop.	self step.	self step.	^RBLiteralNode literalToken: token! !!RBParser methodsFor: 'private-parsing'!parseOptimizedExpression	| position node |	position := currentToken start.	self step.	node := RBOptimizedNode 				left: position				body: (self parseStatements: false)				right: currentToken start.	(currentToken isSpecial and: [currentToken value == $)]) 		ifFalse: [self parserError: ''')'' expected'].	self step.	^node! !!RBParser methodsFor: 'private-parsing'!parseParenthesizedExpression	| leftParen node |	leftParen := currentToken start.	self step.	node := self parseAssignment.	^(currentToken isSpecial and: [currentToken value == $)])		ifTrue: 			[node addParenthesis: (leftParen to: currentToken start).			self step.			node]		ifFalse: [self parserError: ''')'' expected']! !!RBParser methodsFor: 'private-parsing'!parsePatternBlock	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: RBPatternBlockNode new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $}]) 		ifFalse: [self parserError: '''}'' expected'].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing'!parsePrimitiveIdentifier	| token |	token := currentToken.	self step.	^RBVariableNode identifierToken: token! !!RBParser methodsFor: 'private-parsing'!parsePrimitiveLiteral	| token |	token := currentToken.	self step.	^RBLiteralNode literalToken: token! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/30/2000 18:13'!parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	currentToken isLiteral ifTrue: [^self parsePrimitiveLiteral].	currentToken isSpecial ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == $( ifTrue: [^self parseParenthesizedExpression].			currentToken value == ${ ifTrue: [^self parseArray]].	currentToken isOptimized ifTrue: [^self parseOptimizedExpression].	(negatedNumbers and: 		[ currentToken isBinary and:		[ currentToken value == #- ] ]) 	ifTrue:		[ ^self parseNegatedNumber ].	currentToken isPatternBlock ifTrue:[^self parsePatternBlock].	self parserError: 'Variable expected'! !!RBParser methodsFor: 'private-parsing'!parseResourceTag	| start |	[currentToken isBinary and: [currentToken value == #<]] whileTrue: 			[start := currentToken start.			self step.			[scanner atEnd or: [currentToken isBinary and: [currentToken value == #>]]] 				whileFalse: [self step].			(currentToken isBinary and: [currentToken value == #>]) 				ifFalse: [self parserError: '''>'' expected'].			tags isNil 				ifTrue: [tags := OrderedCollection with: (start to: currentToken stop)]				ifFalse: [tags add: (start to: currentToken stop)].			self step]! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/24/2000 02:26'!parseStatementList: tagBoolean into: sequenceNode 	| statements return periods returnPosition node |	return := false.	statements := OrderedCollection new.	periods := OrderedCollection new.	self addCommentsTo: sequenceNode.	tagBoolean ifTrue: [self parseResourceTag].		["skip empty statements"		emptyStatements ifTrue: 			[[currentToken isSpecial and: [currentToken value == $.]] whileTrue: 					[periods add: currentToken start.					self step]].		"check if we are finished yet"	 	self atEnd 			or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 			whileFalse: 				[return ifTrue: [self parserError: 'End of statement list encounted'].				(currentToken isSpecial and: [currentToken value == $^]) 					ifTrue: 						[returnPosition := currentToken start.						self step.						node := RBReturnNode return: returnPosition value: self parseAssignment.						self addCommentsTo: node.						statements add: node.						return := true]					ifFalse: 						[node := self parseAssignment.						self addCommentsTo: node.						statements add: node].				(currentToken isSpecial and: [currentToken value == $.]) 					ifTrue: 						[periods add: currentToken start.						self step]					ifFalse: [return := true].				].	sequenceNode		statements: statements;		periods: periods.	^sequenceNode! !!RBParser methodsFor: 'private-parsing'!parseStatements: tagBoolean 	| args leftBar rightBar |	args := #().	leftBar := rightBar := nil.	currentToken isBinary 		ifTrue: 			[currentToken value == #| 				ifTrue: 					[leftBar := currentToken start.					self step.					args := self parseArgs.					(currentToken isBinary and: [currentToken value = #|]) 						ifFalse: [self parserError: '''|'' expected'].					rightBar := currentToken start.					self step]				ifFalse: 					[currentToken value == #'||' 						ifTrue: 							[rightBar := (leftBar := currentToken start) + 1.							self step]]].	^self parseStatementList: tagBoolean		into: (RBSequenceNode 				leftBar: leftBar				temporaries: args				rightBar: rightBar)! !!RBParser methodsFor: 'private-parsing'!parseUnaryMessage	| node |	node := self parsePrimitiveObject.		[currentToken isLiteral ifTrue: [self patchLiteralMessage].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	^node! !!RBParser methodsFor: 'private-parsing'!parseUnaryMessageWith: aNode 	| selector |	selector := currentToken.	self step.	^RBMessageNode 		receiver: aNode		selectorParts: (Array with: selector)		arguments: #()! !!RBParser methodsFor: 'private-parsing'!parseUnaryPattern	| selector |	selector := currentToken.	self step.	^RBMethodNode selectorParts: (Array with: selector) arguments: #()! !!RBParser methodsFor: 'private-parsing'!parseVariableNode	currentToken isIdentifier 		ifFalse: [self parserError: 'Variable name expected'].	^self parsePrimitiveIdentifier! !!RBParser methodsFor: 'private' stamp: 'bh 4/29/2000 16:28'!addCommentsTo: aNode 	aNode comments: scanner getComments! !!RBParser methodsFor: 'private'!nextToken	^nextToken isNil		ifTrue: [nextToken := scanner next]		ifFalse: [nextToken]! !!RBParser methodsFor: 'private' stamp: 'ls 1/24/2000 02:19'!patchLiteralMessage	currentToken value == true 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].	currentToken value == false 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].	currentToken value == nil 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]! !!RBParser methodsFor: 'private'!patchNegativeLiteral	"Handle the special negative number case for binary message sends."	(currentToken value isKindOf: Number) ifFalse: [^self].	currentToken value <= 0 ifFalse: [^self].	currentToken value = 0 		ifTrue: 			[(source notNil and: 					[source isEmpty not 						and: [(source at: (currentToken start min: source size)) == $-]]) 				ifFalse: [^self]].	nextToken := currentToken.	currentToken := RBBinarySelectorToken value: #- start: nextToken start.	nextToken value: nextToken value negated.	nextToken start: nextToken start + 1! !!RBParser methodsFor: 'private'!step	nextToken notNil ifTrue: 			[currentToken := nextToken.			nextToken := nil.			^currentToken].	currentToken := scanner next! !!RBParser methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock.	scanner notNil ifTrue: [scanner errorBlock: aBlock]! !!RBParser methodsFor: 'accessing'!initializeParserWith: aString type: aSymbol 	source := aString.	self scanner: (RBScanner 				perform: aSymbol				with: (ReadStream on: aString)				with: self errorBlock)! !!RBParser methodsFor: 'accessing'!parseExpression	| node |	node := self parseStatements: false.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	^node! !!RBParser methodsFor: 'accessing'!parseMethod: aString 	| node |	node := self parseMethod.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	node source: aString.	^node! !!RBParser methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:40'!parseMethodWithNoComments: aString 	| node |	node _ self parseMethodWithNoComments.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	node source: aString.	^ node! !!RBParser methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 17:55'!initializeForIBM	emptyStatements := true.	negatedNumbers := false.	scanner notNil ifTrue: [scanner initializeForIBM]! !!RBParser methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 17:55'!initializeForSqueak	emptyStatements := true.	negatedNumbers := true.	scanner notNil ifTrue: [scanner initializeForSqueak]! !!RBParser methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 17:55'!initializeForVisualWorks	emptyStatements := false.	negatedNumbers := false.	scanner notNil ifTrue: [scanner initializeForVisualWorks]! !!RBParser methodsFor: 'initialize-release' stamp: 'ls 1/24/2000 02:20'!scanner: aScanner 	scanner := aScanner.	tags := nil.	self class isIBM 		ifTrue: [self initializeForIBM].	self class isVisualWorks		ifTrue: [self initializeForVisualWorks].	self class isSqueak		ifTrue: [ self initializeForSqueak].	self step! !!RBParser methodsFor: 'testing'!atEnd	^currentToken class == RBToken! !!RBParser methodsFor: 'error handling'!errorBlock	^errorBlock isNil		ifTrue: [[:message :position | ]]		ifFalse: [errorBlock]! !!RBParser methodsFor: 'error handling'!errorPosition	^currentToken start! !!RBParser methodsFor: 'error handling'!parserError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString! !!RBParser class methodsFor: 'accessing'!parseExpression: aString 	^self parseExpression: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'dvf 11/8/2003 15:02'!parseExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #on:errorBlock:.	node := parser parseExpression.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'accessing'!parseMethod: aString 	^self parseMethod: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'dvf 11/8/2003 04:44'!parseMethod: aString onError: aBlock 	| parser squeakString |	squeakString := aString .	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: squeakString type: #on:errorBlock:.	^parser parseMethod: squeakString! !!RBParser class methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:35'!parseMethodWithNoComments: aString 	^ self parseMethodWithNoComments: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:34'!parseMethodWithNoComments: aString onError: aBlock 	| parser |	parser _ self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #on:errorBlock:.	^ parser parseMethodWithNoComments: aString! !!RBParser class methodsFor: 'accessing'!parseRewriteExpression: aString 	^self parseRewriteExpression: aString onError: nil! !!RBParser class methodsFor: 'accessing'!parseRewriteExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #rewriteOn:errorBlock:.	node := parser parseExpression.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'accessing'!parseRewriteMethod: aString 	^self parseRewriteMethod: aString onError: nil! !!RBParser class methodsFor: 'accessing'!parseRewriteMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #rewriteOn:errorBlock:.	^parser parseMethod: aString! !!RBParser class methodsFor: 'parsing'!parseMethodPattern: aString 	| parser |	parser := self new.	parser errorBlock: [:error :position | ^nil].	parser initializeParserWith: aString type: #on:errorBlock:.	^parser parseMessagePattern selector! !!RBParser class methodsFor: 'testing'!isIBM	^ParserType == #IBM! !!RBParser class methodsFor: 'testing' stamp: 'ls 1/24/2000 02:19'!isSqueak	^ParserType == #Squeak! !!RBParser class methodsFor: 'testing'!isVisualWorks	^ParserType == #VisualWorks! !!RBParser class methodsFor: 'class initialization' stamp: 'ls 1/24/2000 02:19'!initialize	"Try to determine which image we're running in"	ParserType _ #Squeak! !!RBPatternBlockNode methodsFor: 'accessing'!sentMessages	^OrderedCollection new! !!RBPatternBlockNode methodsFor: 'matching'!addArgumentWithNameBasedOn: aString 	| name index vars |	name := aString.	vars := self allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	arguments := arguments copyWith: (RBVariableNode named: name)! !!RBPatternBlockNode methodsFor: 'matching'!copyInContext: aDictionary 	^self replacingBlock value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching'!createBlock	| source |	source := self formattedCode.	^Compiler evaluate: source! !!RBPatternBlockNode methodsFor: 'matching'!createMatchingBlock	self arguments size > 2 		ifTrue: 			[self 				error: 'Search blocks can only contain arguments for the node and matching dictionary'].	self arguments size == 0 		ifTrue: [self error: 'Search blocks must contain one argument for the node'].	self arguments size = 1 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary'].	^self createBlock! !!RBPatternBlockNode methodsFor: 'matching'!createReplacingBlock	self arguments size > 1 		ifTrue: 			[self 				error: 'Replace blocks can only contain an argument for the matching dictionary'].	self arguments size = 0 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary'].	^self createBlock! !!RBPatternBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	^self matchingBlock value: aNode value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching'!matchingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createMatchingBlock]		ifFalse: [valueBlock]! !!RBPatternBlockNode methodsFor: 'matching'!replacingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createReplacingBlock]		ifFalse: [valueBlock]! !!RBPatternBlockToken methodsFor: 'testing'!isPatternBlock	^true! !!RBPatternMessageNode methodsFor: 'matching'!copyInContext: aDictionary 	| selectors |	self isList ifTrue: [^aDictionary at: self].	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMessageNode new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		yourself! !!RBPatternMessageNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self isSelectorList ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector])				== aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments])							= aNode arguments]].	^self matchArgumentsAgainst: aNode inContext: aDictionary! !!RBPatternMessageNode methodsFor: 'matching'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary) 				ifFalse: [^false]].	^true! !!RBPatternMessageNode methodsFor: 'matching'!matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isList	^isCascadeList and: [parent notNil and: [parent isCascade]]! !!RBPatternMessageNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isSelectorList	^isList! !!RBPatternMessageNode methodsFor: 'initialize-release'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	| message |	super 		receiver: aValueNode		selectorParts: keywordTokens		arguments: valueNodes.	isCascadeList := isList := false.	message := keywordTokens first value.	2 to: message size		do: 			[:i | 			| character |			character := message at: i.			character == self listCharacter 				ifTrue: [isList := true]				ifFalse: 					[character == self cascadeListCharacter 						ifTrue: [isCascadeList := true]						ifFalse: [^self]]]! !!RBPatternMessageNode methodsFor: 'private'!matchingClass	^RBMessageNode! !!RBPatternMessageNode methodsFor: 'accessing'!sentMessages	^(super sentMessages)		remove: self selector ifAbsent: [];		yourself! !!RBPatternMethodNode methodsFor: 'matching'!copyInContext: aDictionary 	| selectors |	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMethodNode new)		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBPatternMethodNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self isSelectorList ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector])				= aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments])							= aNode arguments and: [body match: aNode body inContext: aDictionary]]].	^(self matchArgumentsAgainst: aNode inContext: aDictionary)		and: [body match: aNode body inContext: aDictionary]! !!RBPatternMethodNode methodsFor: 'matching'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary) 				ifFalse: [^false]].	^true! !!RBPatternMethodNode methodsFor: 'matching'!matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true! !!RBPatternMethodNode methodsFor: 'testing'!isSelectorList	^isList! !!RBPatternMethodNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMethodNode methodsFor: 'private'!matchingClass	^RBMethodNode! !!RBPatternMethodNode methodsFor: 'initialize-release'!selectorParts: tokenCollection arguments: variableNodes 	super selectorParts: tokenCollection arguments: variableNodes.	isList := (tokenCollection first value at: 2) == self listCharacter! !!RBPatternVariableNode methodsFor: 'testing-matching'!isAnything	^isAnything! !!RBPatternVariableNode methodsFor: 'testing-matching'!isList	^isList! !!RBPatternVariableNode methodsFor: 'testing-matching'!isLiteral	^isLiteral! !!RBPatternVariableNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternVariableNode methodsFor: 'testing-matching'!isStatement	^isStatement! !!RBPatternVariableNode methodsFor: 'testing-matching'!recurseInto	^recurseInto! !!RBPatternVariableNode methodsFor: 'matching'!copyInContext: aDictionary 	^aDictionary at: self! !!RBPatternVariableNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	self isAnything ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].	self isLiteral ifTrue: [^self matchLiteral: aNode inContext: aDictionary].	self isStatement		ifTrue: [^self matchStatement: aNode inContext: aDictionary].	aNode class == self matchingClass ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'matching'!matchLiteral: aNode inContext: aDictionary 	^aNode class == RBLiteralNode 		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]! !!RBPatternVariableNode methodsFor: 'matching'!matchStatement: aNode inContext: aDictionary 	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'accessing'!parent: aBRProgramNode 	"Fix the case where '``@node' should match a single node, not a sequence node."	super parent: aBRProgramNode.	parent isSequence 		ifTrue: 			[(self isStatement or: [parent temporaries includes: self]) 				ifFalse: [isList := false]]! !!RBPatternVariableNode methodsFor: 'initialize-release'!identifierToken: anIdentifierToken 	super identifierToken: anIdentifierToken.	self initializePatternVariables! !!RBPatternVariableNode methodsFor: 'initialize-release'!initializePatternVariables	| name |	name := self name.	isAnything := isList := isLiteral := isStatement := recurseInto := false.	2 to: name size		do: 			[:i | 			| character |			character := name at: i.			character == self listCharacter 				ifTrue: [isAnything := isList := true]				ifFalse: 					[character == self literalCharacter 						ifTrue: [isLiteral := true]						ifFalse: 							[character == self statementCharacter 								ifTrue: [isStatement := true]								ifFalse: 									[character == self recurseIntoCharacter 										ifTrue: [recurseInto := true]										ifFalse: [^self]]]]]! !!RBPatternVariableNode methodsFor: 'private'!matchingClass	^RBVariableNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:45'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode value.	self variableWritten: anAssignmentNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptBlockNode: aBlockNode 	self processBlock: aBlockNode.! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptMessageNode: aMessageNode 	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 		ifTrue: [self executeTree: aMessageNode receiver body]		ifFalse: 			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 				ifTrue: [self visitNode: aMessageNode receiver]].	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 		and: 			[(aMessageNode arguments detect: [:each | each isBlock not] ifNone: [nil]) 				isNil]) 			ifTrue: [^self processIfTrueIfFalse: aMessageNode].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptSequenceNode: aSequenceNode 	self processStatementNode: aSequenceNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:47'!acceptVariableNode: aVariableNode 	self variableRead: aVariableNode! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:40'!copyDictionary: aDictionary 	"We could send aDictionary the copy message, but that doesn't copy the associations."	| newDictionary |	newDictionary := Dictionary new: aDictionary size.	aDictionary		keysAndValuesDo: [:key :value | newDictionary at: key put: value].	^newDictionary! !!RBReadBeforeWrittenTester methodsFor: 'private'!createScope	scopeStack add: (self copyDictionary: scopeStack last)! !!RBReadBeforeWrittenTester methodsFor: 'private'!currentScope	^scopeStack last! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:41'!processBlock: aNode 	| newScope |	self createScope.	self executeTree: aNode body.	newScope := self removeScope.	newScope keysAndValuesDo: 			[:key :value | 			(value == true and: [(self currentScope at: key) isNil]) 				ifTrue: [self currentScope at: key put: value]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:42'!processIfTrueIfFalse: aNode 	| trueScope falseScope |	self createScope.	self executeTree: aNode arguments first body.	trueScope := self removeScope.	self createScope.	self executeTree: aNode arguments last body.	falseScope := self removeScope.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: 					[(trueScope at: key) == (falseScope at: key) 						ifTrue: [self currentScope at: key put: (trueScope at: key)]						ifFalse: 							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 								ifTrue: [self currentScope at: key put: true]]]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:42'!processStatementNode: aNode 	| temps |	(checkNewTemps not or: [aNode temporaries isEmpty]) 		ifTrue: 			[aNode statements do: [:each | self executeTree: each].			^self].	self createScope.	temps := aNode temporaries collect: [:each | each name].	self initializeVars: temps.	aNode statements do: [:each | self executeTree: each].	self removeScope keysAndValuesDo: 			[:key :value | 			(temps includes: key) 				ifTrue: [value == true ifTrue: [read add: key]]				ifFalse: 					[(self currentScope at: key) isNil 						ifTrue: [self currentScope at: key put: value]]]! !!RBReadBeforeWrittenTester methodsFor: 'private'!removeScope	^scopeStack removeLast! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:44'!variableRead: aNode 	(self currentScope includesKey: aNode name) ifTrue: 			[(self currentScope at: aNode name) isNil				ifTrue: [self currentScope at: aNode name put: true]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:45'!variableWritten: aNode 	(self currentScope includesKey: aNode variable name) ifTrue: 			[(self currentScope at: aNode variable name) isNil				ifTrue: [self currentScope at: aNode variable name put: false]]! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!checkNewTemps: aBoolean 	checkNewTemps := aBoolean! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release' stamp: 'bh 3/15/2000 16:37'!initialize	scopeStack _ OrderedCollection with: Dictionary new.	read _ Set new.	checkNewTemps _ true.! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!initializeVars: varNames 	varNames do: [:each | self currentScope at: each put: nil]! !!RBReadBeforeWrittenTester methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:39'!executeTree: aParseTree 	^self visitNode: aParseTree! !!RBReadBeforeWrittenTester methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:39'!read	self currentScope		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].	^read! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:48'!isVariable: aString readBeforeWrittenIn: aBRProgramNode 	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!isVariable: aString writtenBeforeReadIn: aBRProgramNode 	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 		isEmpty! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!readBeforeWritten: varNames in: aParseTree 	^(self new)		checkNewTemps: false;		initializeVars: varNames;		executeTree: aParseTree;		read! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!variablesReadBeforeWrittenIn: aParseTree 	^(self new)		executeTree: aParseTree;		read! !!RBReadBeforeWrittenTester class methodsFor: 'instance creation'!new	^super new initialize! !!RBReplaceRule methodsFor: 'matching'!canMatch: aProgramNode 	^verificationBlock value: aProgramNode! !!RBReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'initialize-release'!initialize	super initialize.	verificationBlock := [:aNode | true]! !!RBBlockReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	^replaceBlock value: aProgramNode! !!RBBlockReplaceRule methodsFor: 'initialize-release'!initialize	super initialize.	replaceBlock := [:aNode | aNode]! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: aBlock 	self searchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replBlock when: verifyBlock 	self searchFor: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: aBlock 	self methodSearchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replBlock when: verifyBlock 	self searchForMethod: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: aBlock 	searchTree := aBRProgramNode.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 	self searchForTree: aBRProgramNode replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock 	^self new searchFor: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock 	^self new searchForMethod: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceBlock 	^self new searchForTree: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBScanner methodsFor: 'accessing'!classificationTable: anObject	classificationTable := anObject! !!RBScanner methodsFor: 'accessing'!contents	| contentsStream |	contentsStream := WriteStream on: (Array new: 50).	self do: [:each | contentsStream nextPut: each].	^contentsStream contents! !!RBScanner methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock! !!RBScanner methodsFor: 'accessing'!extendedLanguage	^extendedLanguage! !!RBScanner methodsFor: 'accessing'!extendedLanguage: aBoolean 	extendedLanguage := aBoolean! !!RBScanner methodsFor: 'accessing'!flush! !!RBScanner methodsFor: 'accessing'!getComments	| oldComments |	comments isEmpty ifTrue: [^nil].	oldComments := comments.	comments := OrderedCollection new: 1.	^oldComments! !!RBScanner methodsFor: 'accessing'!next	| token |	buffer reset.	tokenStart := stream position.	characterType == #eof ifTrue: [^RBToken start: tokenStart + 1].	"The EOF token should occur after the end of input"	token := self scanToken.	self stripSeparators.	^token! !!RBScanner methodsFor: 'accessing'!nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement! !!RBScanner methodsFor: 'accessing' stamp: 'bh 3/7/2000 02:17'!scanToken	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 	case statement. Didn't use Dictionary because lookup is pretty slow."	characterType == #alphabetic ifTrue: [^self scanIdentifierOrKeyword].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].	characterType == #special ifTrue: [^self scanSpecialCharacter].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $# ifTrue: [^self scanLiteral].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	extendedLanguage 		ifTrue: 			[currentCharacter == PatternVariableCharacter 				ifTrue: [^self scanPatternVariable].			currentCharacter == $} ifTrue: [^self scanSpecialCharacter]].	^self scannerError: 'Unknown character'! !!RBScanner methodsFor: 'private-scanning'!scanAnySymbol	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary ifTrue: [^self scanBinary: RBLiteralToken].	^RBToken new! !!RBScanner methodsFor: 'private-scanning'!scanBinary: aClass 	"This doesn't parse according to the ANSI draft. It only parses 1 or 2 letter binary tokens."	| val |	buffer nextPut: currentCharacter.	self step.	(characterType == #binary and: [currentCharacter ~~ $-]) ifTrue: 			[buffer nextPut: currentCharacter.			self step].	val := buffer contents.	val := val asSymbol.	^aClass value: val start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanByteArray	| byteStream number |	byteStream := WriteStream on: (ByteArray new: 100).	self step.		[self stripSeparators.	characterType == #digit] whileTrue: 				[number := self scanNumber value.				(number isInteger and: [number between: 0 and: 255]) 					ifFalse: [self scannerError: 'Expecting 8-bit integer'].				byteStream nextPut: number].	currentCharacter == $] ifFalse: [self scannerError: ''']'' expected'].	self step.	"]"	^RBLiteralToken 		value: byteStream contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanExponentMultipler	| exponent isExpNegative position |	currentCharacter == $e		ifTrue: 			[position := stream position.			self step.			(isExpNegative := currentCharacter == $-) ifTrue: [self step].			exponent := self scanNumberOfBase: 10.			exponent isNil				ifTrue: 					["Did not read a valid exponent, e must be start of a message send"					stream position: position - 1.					self step.					exponent := 0]				ifFalse: [isExpNegative ifTrue: [exponent := exponent negated]]]		ifFalse: [exponent := 0].	^10 raisedToInteger: exponent! !!RBScanner methodsFor: 'private-scanning' stamp: 'dvf 9/17/2001 00:18'!scanExtendedLiterals	| token |	self step.	separatorsInLiterals ifTrue: [self stripSeparators].	token := characterType == #alphabetic 				ifTrue: [self scanSymbol]				ifFalse: 					[characterType == #binary 						ifTrue: [(self scanBinary: RBLiteralToken) stop: self previousStepPosition]						ifFalse: 							[currentCharacter == $' 								ifTrue: [self scanStringSymbol]								ifFalse: 									[currentCharacter == $( 										ifTrue: 											[self step.											^RBOptimizedToken start: tokenStart]]]].	token isNil ifTrue: [self scannerError: 'Expecting a extended literal'].	token value: (Symbol intern: token value asString).	^token! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/30/2000 19:21'!scanExtendedSymbol	"scan symbols like #. which are allowed by Squeak but aren't standard"	| token |	token := RBLiteralToken value: (currentCharacter asString asSymbol) start: tokenStart stop: stream position.	self step.	^token! !!RBScanner methodsFor: 'private-scanning'!scanIdentifierOrKeyword	| tokenType token name |	self scanName.	currentCharacter == nameSpaceCharacter 		ifTrue: 			[token := self scanNamespaceName.			token notNil ifTrue: [^token]].	(currentCharacter == $: and: [stream peek ~~ $=]) 		ifTrue: 			[buffer nextPut: currentCharacter.			self step.	":"			tokenType := RBKeywordToken]		ifFalse: [tokenType := RBIdentifierToken].	name := buffer contents.	name = 'true' 		ifTrue: 			[^RBLiteralToken 				value: true				start: tokenStart				stop: self previousStepPosition].	name = 'false' 		ifTrue: 			[^RBLiteralToken 				value: false				start: tokenStart				stop: self previousStepPosition].	name = 'nil' 		ifTrue: 			[^RBLiteralToken 				value: nil				start: tokenStart				stop: self previousStepPosition].	^tokenType value: name start: tokenStart! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/30/2000 19:16'!scanLiteral	self step.	separatorsInLiterals ifTrue: [self stripSeparators].	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanStringSymbol].	currentCharacter == $( ifTrue: [^self scanLiteralArray].	currentCharacter == $[ ifTrue: [^self scanByteArray].	(extendedSymbols and: [ '._' includes: currentCharacter ])		ifTrue: [^self scanExtendedSymbol ].	(separatorsInLiterals and: [currentCharacter == ${]) 		ifTrue: [^self scanQualifier].	(extendedLiterals and: [currentCharacter == $#]) 		ifTrue: [^self scanExtendedLiterals].	self scannerError: 'Expecting a literal type'! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArray	| arrayStream start |	arrayStream := WriteStream on: (Array new: 10).	self step.	start := tokenStart.		[self stripSeparators.	tokenStart := stream position.	currentCharacter == $)] 			whileFalse: 				[arrayStream nextPut: self scanLiteralArrayParts.				buffer reset].	self step.	^RBLiteralToken 		value: arrayStream contents		start: start		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArrayParts	currentCharacter == $# ifTrue: [^self scanLiteral].	characterType == #alphabetic 		ifTrue: 			[| token value |			token := self scanSymbol.			value := token value.			value == #nil ifTrue: [token value: nil].			value == #true ifTrue: [token value: true].			value == #false ifTrue: [token value: false].			^token].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	currentCharacter == $( ifTrue: [^self scanLiteralArray].	currentCharacter == $[ ifTrue: [^self scanByteArray].	^self scannerError: 'Unknown character in literal array'! !!RBScanner methodsFor: 'private-scanning'!scanLiteralCharacter	| token |	self step.	"$"	token := RBLiteralToken 				value: currentCharacter				start: tokenStart				stop: stream position.	self step.	"char"	^token! !!RBScanner methodsFor: 'private-scanning'!scanLiteralString	self step.		[currentCharacter isNil 		ifTrue: [self scannerError: 'Unmatched '' in string literal.'].	currentCharacter == $' and: [self step ~~ $']] 			whileFalse: 				[buffer nextPut: currentCharacter.				self step].	^RBLiteralToken 		value: buffer contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanName	[characterType == #alphabetic or: [characterType == #digit]] whileTrue: 			[buffer nextPut: currentCharacter.			self step]! !!RBScanner methodsFor: 'private-scanning'!scanNamespaceName	extendedLiterals 		ifTrue: 			[stream peek == $: ifFalse: [^nil].			buffer next: 2 put: $:.			self step]		ifFalse: 			[(stream atEnd or: [(self classify: stream peek) ~~ #alphabetic]) 				ifTrue: [^nil].			buffer nextPut: $.].	self step.	self scanName.	currentCharacter == nameSpaceCharacter ifTrue: [self scanNamespaceName].	^RBIdentifierToken value: buffer contents start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanNumber	^RBLiteralToken 		value: (self perform: numberType)		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanNumberIBM	| number isNegative |	isNegative := false.	currentCharacter == $- 		ifTrue: 			[isNegative := true.			self step].	number := self scanNumberWithoutExponent.	^(isNegative ifTrue: [number negated] ifFalse: [number]) 		* self scanExponentMultipler! !!RBScanner methodsFor: 'private-scanning'!scanNumberOfBase: anInteger 	"Scan a number. Return the number or nil if the current input isn't a valid number."	| number digits fraction isFloat succeeded |	digits := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: 1 to: anInteger.	number := 0.	succeeded := false.	[digits includes: currentCharacter] whileTrue: 			[number := number * anInteger + (digits indexOf: currentCharacter) - 1.			self step.			succeeded := true].	succeeded ifFalse: [^nil].	isFloat := false.	(currentCharacter == $. and: [digits includes: stream peek]) ifTrue: 			[self step.			isFloat := true.			fraction := 1 / anInteger.			[digits includes: currentCharacter] whileTrue: 					[number := number + (((digits indexOf: currentCharacter) - 1) * fraction).					fraction := fraction / anInteger.					self step]].	^isFloat ifTrue: [number asFloat] ifFalse: [number]! !!RBScanner methodsFor: 'private-scanning' stamp: 'bh 4/29/2000 17:59'!scanNumberVisualWorks	| number |	stream skip: -1.	number _ Number readSmalltalkSyntaxFrom: stream.	self step.	^ number! !!RBScanner methodsFor: 'private-scanning'!scanNumberWithoutExponent	"Scan an IBM number with the radix -- don't scan the exponent though"	| number base |	base := self scanNumberOfBase: 10.	(currentCharacter == $r and: [base isInteger])		ifTrue: 			[| position |			position := stream position.			self step.			number := self scanNumberOfBase: base.			number isNil ifTrue: 					["Did not read a correct number, r must be start of a message send."					stream position: position - 1.					self step.					number := base]]		ifFalse: [number := base].	^number! !!RBScanner methodsFor: 'private-scanning'!scanPatternVariable	buffer nextPut: currentCharacter.	self step.	currentCharacter == ${ 		ifTrue: 			[self step.			^RBPatternBlockToken value: '`{' start: tokenStart].	[characterType == #alphabetic] whileFalse: 			[characterType == #eof 				ifTrue: [self scannerError: 'Meta variable expected'].			buffer nextPut: currentCharacter.			self step].	^self scanIdentifierOrKeyword! !!RBScanner methodsFor: 'private-scanning' stamp: 'bh 4/29/2000 18:01'!scanQualifier	| nameStream qualifierClass |	qualifierClass _ Smalltalk at: #QualifiedName ifAbsent: [].	qualifierClass isNil ifTrue: [^ self scannerError: 'Unknown character'].	self step.	"{"	nameStream _ WriteStream on: (String new: 10).	[currentCharacter == $}]		whileFalse: 			[nameStream nextPut: currentCharacter.			self step].	self step.	"}"	^ RBLiteralToken		value: (qualifierClass pathString: nameStream contents)		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/21/2000 22:38'!scanSpecialCharacter	| character |	currentCharacter == $: ifTrue: 			[self step.			^currentCharacter == $=				ifTrue: 					[self step.					RBAssignmentToken start: tokenStart]				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].	currentCharacter = $_ ifTrue:		[ self step.  ^RBShortAssignmentToken start: tokenStart ].	character := currentCharacter.	self step.	^RBSpecialCharacterToken value: character start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanStringSymbol	| literalToken |	literalToken := self scanLiteralString.	literalToken value: literalToken value asSymbol.	^literalToken! !!RBScanner methodsFor: 'private-scanning'!scanSymbol	| lastPosition hasColon value startPosition |	hasColon := false.	startPosition := lastPosition := stream position.	[characterType == #alphabetic] whileTrue: 			[self scanName.			currentCharacter == $: 				ifTrue: 					[buffer nextPut: $:.					hasColon := true.					lastPosition := stream position.					self step]].	value := buffer contents.	(hasColon and: [value last ~~ $:]) 		ifTrue: 			[stream position: lastPosition.			self step.			value := value copyFrom: 1 to: lastPosition - startPosition + 1].	^RBLiteralToken 		value: value asSymbol		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!stripComment	| start stop |	start := stream position.	[self step == $"] whileFalse: 			[characterType == #eof				ifTrue: [self scannerError: 'Unmatched " in comment.']].	stop := stream position.	self step.	comments add: (start to: stop)! !!RBScanner methodsFor: 'private-scanning'!stripSeparators		[[characterType == #separator]		whileTrue: [self step].	currentCharacter == $"]		whileTrue: [self stripComment]! !!RBScanner methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 19:14'!initializeForIBM	numberType := #scanNumberIBM.	separatorsInLiterals := false.	extendedLiterals := true.	extendedSymbols := false.	nameSpaceCharacter := $:! !!RBScanner methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 19:14'!initializeForSqueak	numberType := #scanNumberIBM.	separatorsInLiterals := true.	extendedLiterals := true.	extendedSymbols := true.	nameSpaceCharacter := nil.! !!RBScanner methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 19:14'!initializeForVisualWorks	numberType := #scanNumberVisualWorks.	separatorsInLiterals := true.	extendedLiterals := false.	extendedSymbols := false.	(Smalltalk includesKey: #QualifiedName) ifTrue: [nameSpaceCharacter := $.]! !!RBScanner methodsFor: 'initialize-release' stamp: 'ls 1/24/2000 02:21'!on: aStream 	buffer := WriteStream on: (String new: 60).	stream := aStream.	classificationTable := self class classificationTable.	extendedLanguage := false.	comments := OrderedCollection new.	RBParser isIBM 		ifTrue: [self initializeForIBM].	RBParser isVisualWorks		ifTrue: [self initializeForVisualWorks].	RBParser isSqueak		ifTrue: [ self initializeForSqueak].! !!RBScanner methodsFor: 'private'!classify: aCharacter 	| index |	aCharacter isNil ifTrue: [^nil].	index := aCharacter asInteger.	index == 0 ifTrue: [^#separator].	index > 255 ifTrue: [^nil].	^classificationTable at: index! !!RBScanner methodsFor: 'private'!previousStepPosition	^characterType == #eof 		ifTrue: [stream position]		ifFalse: [stream position - 1]! !!RBScanner methodsFor: 'private'!step	stream atEnd ifTrue: 			[characterType := #eof.			^currentCharacter := nil].	currentCharacter := stream next.	characterType := self classify: currentCharacter.	^currentCharacter! !!RBScanner methodsFor: 'testing'!atEnd	^characterType == #eof! !!RBScanner methodsFor: 'testing'!isReadable	^true! !!RBScanner methodsFor: 'testing'!isWritable	^false! !!RBScanner methodsFor: 'error handling'!errorBlock	^errorBlock isNil		ifTrue: [[:message :position | ]]		ifFalse: [errorBlock]! !!RBScanner methodsFor: 'error handling'!errorPosition	^stream position! !!RBScanner methodsFor: 'error handling'!scannerError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString! !!RBScanner class methodsFor: 'instance creation'!on: aStream 	| str |	str := self basicNew on: aStream.	str		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!on: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!rewriteOn: aStream 	| str |	str := self basicNew on: aStream.	str		extendedLanguage: true;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!rewriteOn: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		extendedLanguage: true;		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'class initialization' stamp: 'ls 3/20/2004 14:17'!initialize	PatternVariableCharacter := $`.	ClassificationTable := Array new: 255.	self initializeChars: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' to: #alphabetic.	self initializeChars: (128 to: 255) asByteArray asString to: #alphabetic.	self initializeChars: '01234567890' to: #digit.	self initializeChars: '!!!!%&*+,-/<=>?@\~|' to: #binary.	ClassificationTable at: 177 put: #binary.	"plus-or-minus"	ClassificationTable at: 183 put: #binary.	"centered dot"	ClassificationTable at: 215 put: #binary.	"times"	ClassificationTable at: 247 put: #binary.	"divide"	self initializeChars: '().:;[]^{}_' to: #special.	#(9 10 12 13 26 32) do: [:i | ClassificationTable at: i put: #separator]! !!RBScanner class methodsFor: 'class initialization'!initializeChars: characters to: aSymbol 	characters do: [:c | ClassificationTable at: c asInteger put: aSymbol]! !!RBScanner class methodsFor: 'testing'!isSelector: aSymbol 	| scanner token |	scanner := self basicNew.	scanner on: (ReadStream on: aSymbol asString).	scanner step.	token := scanner scanAnySymbol.	token isLiteral ifFalse: [^false].	token value isEmpty ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'testing'!isVariable: aString 	| scanner token |	aString isString ifFalse: [^false].	aString isEmpty ifTrue: [^false].	(ClassificationTable at: aString first asInteger) == #alphabetic		ifFalse: [^false].	scanner := self basicNew.	scanner on: (ReadStream on: aString asString).	scanner errorBlock: [:s :p | ^false].	scanner step.	token := scanner scanIdentifierOrKeyword.	token isKeyword ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'accessing'!classificationTable	ClassificationTable isNil ifTrue: [self initialize].	^ClassificationTable! !!RBScanner class methodsFor: 'accessing'!patternVariableCharacter	^PatternVariableCharacter! !!RBSearchRule methodsFor: 'testing' stamp: 'bh 4/29/2000 18:15'!canMatch: aProgramNode 	self needsWork.	"testing #copy to attempt to fix block closure issue"	owner answer: (answerBlock copy value: aProgramNode value: owner answer).	^ true! !!RBSearchRule methodsFor: 'initialize-release'!searchFor: aString thenDo: aBlock 	self searchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForMethod: aString thenDo: aBlock 	self methodSearchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode thenDo: aBlock 	searchTree := aBRProgramNode.	answerBlock := aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchFor: aString thenDo: aBlock 	^self new searchFor: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForMethod: aString thenDo: aBlock 	^self new searchForMethod: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForTree: aBRProgramNode thenDo: aBlock 	^self new searchForTree: aBRProgramNode thenDo: aBlock! !!RBSmallDictionary methodsFor: 'removing' stamp: 'bh 3/14/2000 22:59'!remove:anAssociation	self removeKey:anAssociation key.! !!RBSmallDictionary methodsFor: 'removing'!remove: oldObject ifAbsent: anExceptionBlock 	self removeKey: oldObject key ifAbsent: anExceptionBlock.	^oldObject! !!RBSmallDictionary methodsFor: 'removing'!removeKey: key ifAbsent: aBlock 	| index value |	index := self findIndexFor: key.	index == 0 ifTrue: [^aBlock value].	value := values at: index.	index to: size - 1		do: 			[:i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1)].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^value! !!RBSmallDictionary methodsFor: 'private'!findIndexFor: aKey 	1 to: size do: [:i | (keys at: i) = aKey ifTrue: [^i]].	^0! !!RBSmallDictionary methodsFor: 'private'!growKeysAndValues	self growTo: size * 2! !!RBSmallDictionary methodsFor: 'private'!growTo: aSize 	| newKeys newValues |	newKeys := Array new: aSize.	newValues := Array new: aSize.	1 to: size		do: 			[:i | 			newKeys at: i put: (keys at: i).			newValues at: i put: (values at: i)].	keys := newKeys.	values := newValues! !!RBSmallDictionary methodsFor: 'private'!privateAt: key put: value 	size == keys size ifTrue: [self growKeysAndValues].	size := size + 1.	keys at: size put: key.	^values at: size put: value! !!RBSmallDictionary methodsFor: 'enumerating'!associationsDo: aBlock 	self keysAndValuesDo: [:key :value | aBlock value: key -> value]! !!RBSmallDictionary methodsFor: 'enumerating'!do: aBlock 	1 to: size do: [:i | aBlock value: (values at: i)]! !!RBSmallDictionary methodsFor: 'enumerating'!keysAndValuesDo: aBlock 	1 to: size do: [:i | aBlock value: (keys at: i) value: (values at: i)]! !!RBSmallDictionary methodsFor: 'enumerating'!keysDo: aBlock 	1 to: size do: [:i | aBlock value: (keys at: i)]! !!RBSmallDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 ifTrue: [aBlock value] ifFalse: [values at: index]! !!RBSmallDictionary methodsFor: 'accessing'!at: key ifAbsentPut: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: aBlock value]		ifFalse: [values at: index]! !!RBSmallDictionary methodsFor: 'accessing'!empty	size := 0! !!RBSmallDictionary methodsFor: 'accessing'!size	^size! !!RBSmallDictionary methodsFor: 'initialize-release'!initialize	keys := Array new: 2.	values := Array new: 2.	size := 0! !!RBSmallDictionary methodsFor: 'adding'!add: anAssociation 	self at: anAssociation key put: anAssociation value.	^anAssociation! !!RBSmallDictionary methodsFor: 'adding'!at: key put: value 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: value]		ifFalse: [values at: index put: value]! !!RBSmallDictionary methodsFor: 'copying' stamp: 'bh 3/11/2000 02:18'!copy	^ self shallowCopy postCopy.! !!RBSmallDictionary methodsFor: 'copying'!postCopy	keys := keys copy.	values := values copy! !!RBSmallDictionary methodsFor: 'testing'!includesKey: aKey 	^(self findIndexFor: aKey) ~~ 0! !!RBSmallDictionary class methodsFor: 'instance creation'!new	^self basicNew initialize! !!RBSmallDictionary class methodsFor: 'instance creation'!new: aSize 	"Ignore the size"	^self basicNew initialize! !!RBStringReplaceRule methodsFor: 'initialize-release'!methodReplaceString: replaceString 	replaceTree := RBParser parseRewriteMethod: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!replaceString: replaceString 	replaceTree := RBParser parseRewriteExpression: replaceString.	searchTree isSequence = replaceTree isSequence 		ifFalse: 			[searchTree isSequence 				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString 	self searchString: searchString.	self replaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString when: aBlock 	self searchFor: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString 	self methodSearchString: searchString.	self methodReplaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	self searchForMethod: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceNode 	searchTree := aBRProgramNode.	replaceTree := replaceNode! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self searchForTree: aBRProgramNode replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	| newTree |	newTree := replaceTree copyInContext: self context.	newTree copyCommentsFrom: aProgramNode.	^newTree! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString 	^self new searchFor: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString	^self new searchForMethod: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceString 	^self new searchForTree: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForTree: searchString		replaceWith: replaceString		when: aBlock! !RBScanner initialize!RBParser initialize!