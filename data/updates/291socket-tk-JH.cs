'From Squeak 2.2beta of Sept 16, 1998 on 21 September 1998 at 5:45:42 pm'!!FileList commentStamp: 'tk 9/17/1998 18:11' prior: 0!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:57'!path: anArray	path _ anArray! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'tk 9/21/1998 10:45'!blabEmail: aRequest	"Of the form 'From: me@isp.com <crlf>'"	HTTPBlabEmail _ aRequest! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:56'!path: anArray	path _ anArray! !!PWS methodsFor: 'Accessing' stamp: 'tk 9/16/1998 15:50'!message: anArray   message _ anArray! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/18/1998 23:25'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: (resp _			FileStream oldFileNamed: server,(self serverDelimiter asString), self bareDirectory,				(self serverDelimiter asString),fileNameOnServer) contentsOfEntireFile.		^ resp].	type == #http ifTrue: [].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/16/1998 08:46'!openNoDataFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  No dataPort is opened.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	^ so! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:24'!bareDirectory	^ directory first == $/ 		ifTrue: [directory copyFrom: 2 to: directory size]		ifFalse: [directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/19/1998 18:54'!copy	| new |	new _ self clone.	new urlObject: urlObject copy.	^ new! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 11:50'!directory	^ directory! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:18'!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		(start beginsWith: 'ftp:') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer _ bare copyUpTo: self pathNameDelimiter.	both _ userAndServer findTokens: '@'.	slash _ both size.	"absolute = 1, relative = 2"	server _ both last.	both size > 1 ifTrue: [user _ both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory _ bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:23'!moniker	"a plain language name for this directory"	moniker ifNotNil: [^ moniker].	directory ifNotNil: [^ self slashDirectory].	urlObject ifNotNil: [^ urlObject toText].	^ ''! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:22'!slashDirectory	^ directory first == $/ 		ifTrue: [directory]		ifFalse: ['/', directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:04'!createDirectory: localName	"Create a new sub directory within the current one"	| so rr |	type == #file ifTrue: [FileDirectory createDirectory: localName].	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'MKD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:20'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| so rr |	type == #file ifTrue: [FileDirectory deleteFileNamed: localName].		"Is this the right command???"	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RMD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:49'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'DELE ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:58'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self copy.	urlObject ifNotNil: [		new urlObject path: (new urlObject path) copy.		(new urlObject path) removeLast; addLast: localFileName; addLast: ''.		^ new].	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 19:29'!fullNameFor: aFileName	"Convention: 	If it is an absolute path, directory stored with a leading slash, and url has no user@.	If relative path, directory stored with no leading slash, and url begins user@.	Should we include ftp:// on the front?"	urlObject ifNotNil: [^ urlObject pathString, aFileName].	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	directory isEmpty ifTrue: [^ server, 		self pathNameDelimiter asString, aFileName].	^ (directory first == $/ ifTrue: [''] ifFalse: [user,'@']), 		server, self slashDirectory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:40'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:59'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/18/1998 23:26'!pathName	urlObject ifNotNil: [^ urlObject pathForFile].	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [user, '@', server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 15:11'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RNFR ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'RNTO ', newName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 9/16/1998 15:58'!process: request	"URLs are of the form:	{swikiname} 		browse Front Page	{swikiname}.{coreID} browse the page number coreID	{swikiname}.{coreID}.edit  request to edit the page	{swikiname}.{coreID}.versions show the last three versions of the page	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}.insert.{placeID}  request to insert text in aspecific place in a page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  storetext in a specific place	-------	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for referencesto coreID's key	{swikiname}.{picName}.gif   or .jpeg, .jpg, .jpe, .html (upper orlower case) return	the picture or static page stored in the {swikiname} folder."	| coreRef pageRef command formattedPage theLast pvtPageRef htmlForUser |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request reply: PWS success;		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf , ((self formatterFor: 'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[request reply: ((self formatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].			command = 'insert' ifTrue:					[pvtPageRef _ pageRef clone.					pvtPageRef placeID: (request message at: 4).	"so <?request placeID?> can get it"					htmlForUser _ ((self formatterFor: 'insert') format: pvtPageRef).					htmlForUser size = 0 ifTrue: [						self error: 'template file ''insert.html'' not found'].					request reply: htmlForUser.					pageRef noteEditRequest.					^ self].			command = 'searchresult' ifTrue:					[request reply: ((self formatterFor: 'results')						format: (urlmap searchFor: pageRef name)).					^ self].			command = 'all' ifTrue:					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: ((self formatterFor: 'page') format: formattedPage).					^ self].			(request message at: 1) = (request message at: 2) ifTrue: [				request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.				request message: (request message copyFrom: 2 to: request message size).				^ self process: request].	"(success and contentHTML will be sent twice!!)"			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/21/1998 08:23'!authorizer	"*** Do not use this method to add or delete users!!  The change will not be recorded on the disk!!  Instead call mapName:password:to: in this class.***"	^authorizer! !!PSwikiAction methodsFor: 'all' stamp: 'tk 9/16/1998 16:21'!process: request	"URLs are of the form:	{swikiname} to browse Front Page	{swikiname}.{coreID} to browse the page	{swikiname}.{coreID}.edit  to edit the page	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.{coreID}.versions displays the last three versions of the page	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for references to coreID's key	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, upper or lower case) 		return the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"		(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf, (HTMLformatter					evalEmbedded: (self fileContents: source, 'recent.html')					with: urlmap recent).			^ self]."	request reply: PWS crlf.		End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: ["SearchResult, All, Versions, or Edit"		command _ request message at: 3.		command = 'edit' ifTrue:			[^self edit: pageRef from: request].		command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].		command = 'searchresult' ifTrue:			[request reply: (HTMLformatter evalEmbedded:							(self fileContents: source , 'results.html')						with: (urlmap searchFor: pageRef name)).			^ self].		command = 'all' ifTrue:			[formattedPage _ urlmap allPagesFrom: pageRef for: request.			request reply: (HTMLformatter evalEmbedded:							(self fileContents: source, 'page.html')						with: formattedPage).			^ self].		(request message at: 1) = (request message at: 2) ifTrue: [			request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.			request message: (request message copyFrom: 2 to: request message size).			^ self process: request].	"(success and contentHTML will be sent twice!!)"		Transcript show: 'Unknown command: ', command; cr.		^ self].	"Just a browse"	^ self browse: pageRef from: request! !