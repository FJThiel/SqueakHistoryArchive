'From Squeak2.8alpha of 13 January 2000 [latest update: #1979] on 2 April 2000 at 4:15:51 pm'!!FileDirectory methodsFor: 'file operations' stamp: 'tk 3/31/2000 21:09'!rename: oldFileName toBe: newFileName	| selection |	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	"Modified for retry after GC ar 3/21/98 18:09"	(self retryWithGC:[self primRename: (self fullNameFor: oldFileName)						to: (self fullNameFor: newFileName)]		until:[:result| result notNil]) ~~ nil ifTrue:[^self].	(self fileExists: oldFileName) ifFalse:[		^self error:'Attempt to rename a non-existent file'.	].	(self fileExists: newFileName) ifTrue:[		selection _ (PopUpMenu labels:'delete old versioncancel')				startUpWithCaption: 'Trying to rename a file to be', newFileName , 'and it already exists.'.		selection = 1 ifTrue:			[self deleteFileNamed: newFileName.			^ self rename: oldFileName toBe: newFileName]].	^self error:'Failed to rename file'.! !!HandMorph methodsFor: 'world menu' stamp: 'tk 3/30/2000 17:30'!projectMenu	"Build the project menu for the world."	| menu |	menu _ (MenuMorph entitled: 'projects...') defaultTarget: self.	menu addStayUpItem.	menu add: 'save project on file...' target: self world 		action: #saveOnFile.	menu add: 'load project from file...' target: self 		action: #loadProject.	menu addLine.	(Preferences mvcProjectsAllowed and: [Smalltalk includesKey: #StandardSystemView])		ifTrue: [menu add: 'create new mvc project' action: #openMVCProject].	menu add: 'create new morphic project' action: #openMorphicProject.	menu addLine.	menu add: 'go to previous project' target: Project action: #advanceToPreviousProject.	menu add: 'go to next project' target: Project action: #returnToPreviousProject.	menu add: 'jump to project...' target: owner action: #jumpToProject.	menu addLine.	menu add: 'save on server (also makes a local copy)' target: self world project 		action: #storeOnServer.	menu add: 'saveAs' target: self world project 		action: #saveAs.	menu add: 'see if server version is more recent...' target: self world project 		action: #loadFromServer.	Preferences simpleMenus ifFalse:		[menu addLine.		menu add: 'save for future revert' target: self world project 			action: #saveForRevert.		menu add: 'revert to saved copy' target: self world project action: #revert].	^ menu! !!Process methodsFor: 'objects from disk' stamp: 'tk 3/31/2000 20:46'!objectForDataStream: refStrm	"I am not allowed to be written on an object file."	^ nil! !!ProcessorScheduler methodsFor: 'objects from disk' stamp: 'tk 3/31/2000 20:43'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: Processor selector: #yourself args: #()! !!Project commentStamp: 'tk 4/1/2000 07:19' prior: 0!A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet.  A project knows who its parent project is.  When you change projects, whether by entering or exiting, the screen state of the project being exited is saved in that project.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.-----Projects may be stored on the disk in external format.  (Project named: 'xxx') exportSegment.Projects may be loaded from a server and stored back.  Storing on a server never overwrites.  It always makes a new version.A project remembers the url of where it lives (in urlList.  The list is length one, for now).The url may point to a local disk instead of a server.All projects that the user looks at, are cached in the Squeaklet folder.  Sorted by server.  The cache holds the most recent version only.For now, control of saving an reloading is from the thumbnail that owns the project.-----When you accept a method, the entire system feels the change, except projects that are "isolated".  In an "isolated" project, changes are revoked when you leave the project.  When you enter another project, that project's changes are installed.  (To make a project be isolated, choose "isolate changes of this project" from the "changes..." section of the screen menu.)  You can use an isolated project for making dangerous change to a system, and you can get out if it crashes.  A foreign application can have the separate environment it wants.  Also, you can freeze part of the system for a demo that you don't want to disturb.	An isolated project shares methods with all subprojects inside it, unless they are isolated themselves.   Each isolated project is the head of a tree of projects it shares all methods with.	You may 'assert' all changes ever made in the current project to take effect everywhere.  You are first informed if there are any direct method conflicts with other projects.  The conflicts are presented in a ChangeList Browser.	[Later: A project may be 'frozen'.  Asserts do not apply to it after that.  (Great for demos.)  You should be informed when an assert was blocked in a frozen project.]	Class definitions are global.  If you add an instance variable, it happens in all projects.  All versions of the methods are recompiled, in all projects.  If you remove an inst var that is in use in another isolated project, it will become an Undeclared global.  It is best not to remove an inst var when it is being used in another isolated project.   	Senders and Implementors do not see other versions of a method in other isolated projects.	When you ask for versions of a method, you will not get the history in other isolated projects.	Moving methods and classes between changeSets, and merging changeSets has no effect on which methods are in force.  But, when you look at a changeSet from a different isolated project, the methods will contain the 'wrong' code.  A changeSet is just a list of method names, and does not keep separate copies of any code.	When finer grained assertion is needed, use the method (aProject assertClass: aClass from: thisProject warn: warnConflicts).	How isolated changes work: The first time a class changes, store its MethodDictionary object.  Keep parallel arrays of associations to Classes and MethodDictionaries.  Traverse these and install them when you enter an "ioslated project".  When you leave, store this project's own MethodDictionaries there.	To do an assert, we must discover which methods changed here, and which changed only in the project we are asserting into.  There is one copy of the 'virgin' method dictionaries in the system.  It is always being temporarily stored by the currently inForce isolated project.isolatedHead - true for the "top project", and the origin of each "isolated project".  false or nil for any subproject that shares all methods with its parent project.inForce -  true if my methods are installed now.  false if I am dormant.classArray - list of associations to classes methodDictArray - the method dictionaries of those classes before we started changing methods.  They hang onto the original compiledMethods.  (If this project is dormant, it contains the method dictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - true when more than one isolated project exists.  When false, only top project has (isolatedHead = true), and no project records any method dictionaries.  This is to save space when not using Isolated Projects.------Tricky case when want to save a project in export format from within the project.  Set two flags in parentProject, exit, and let parentProject write the project.  Project must be inactive so we are not trying to write Processes that are running.  (Delay wait was an issue when trying to do it internally.)  ProjectViewMorph in parentProject checks in its step method, does the store, clears the flags, and reenters the subProject.!!Project methodsFor: 'accessing' stamp: 'tk 4/2/2000 15:28'!findProjectView: projectDescription	| pName |	"In this world, find the morph that holds onto the project described by projectDescription.  projectDescription can be a project, or the name of a project.  The project may be represented by a DiskProxy.  The holder morph may be at any depth in the world.	Need to fix this if Projects have subclasses, or if a class other than ProjectViewMorph can officially hold onto a project.  (Buttons, links, etc)"	pName _ (projectDescription isKindOf: String) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	world allMorphsDo: [:pvm |		pvm class == ProjectViewMorph ifTrue: [			(pvm project class == Project and: 				[pvm project name = pName]) ifTrue: [^ pvm].			(pvm project class == DiskProxy and: 				[pvm project constructorArgs first = pName])					ifTrue: [^ pvm]]].	^ nil! !!Project methodsFor: 'file in/out' stamp: 'tk 4/2/2000 15:09'!armsLengthCommand: aCommand	| pvm |	"Set things up so that this aCommand is sent to self as a message after jumping to the parentProject.  For things that can't be executed while in this project, such as saveAs, loadFromServer, storeOnServer.  See ProjectViewMorph step."	parentProject ifNil: [^ self inform: 'The top project can''t do that'].	pvm _ parentProject findProjectView: self.	pvm setProperty: #armsLengthCmd toValue: aCommand.	pvm setProperty: #wasStepping toValue: false.	pvm world startStepping: pvm.	self exit.! !!Project methodsFor: 'file in/out' stamp: 'tk 3/31/2000 11:17'!exportSegmentWithCatagories: catList classes: classList	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is response str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allInstances.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].is _ ImageSegment new copyFromRootsForExport: roots asArray.	"world, and all Players"is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.'].(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs].(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: self name, '.pr'.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 4/2/2000 15:48'!installRemoteFrom: strm named: otherProjectName	| projViewer is proj |	"Find the current ProjectViewMorph, fetch the project, install in ProjectViewMorph without changing size, and jump into new project."	projViewer _ self findProjectView: otherProjectName.	projViewer 		ifNotNil: [is _ strm asUnZippedStream fileInObjectAndCode.			(is isKindOf: ImageSegment) ifTrue: [				proj _ is arrayOfRoots detect: [:mm | mm class == Project] 							ifNone: [nil].				proj ifNotNil: [proj versionFrom: strm.					proj setParent: Project current.					(projViewer owner isKindOf: SystemWindow) ifTrue: [						projViewer owner model: proj].					^ projViewer project: proj]]]		ifNil: [(SelectionMenu confirm: 'No old thumbnail found. Debug?') 					ifTrue: [self halt]].	"replace with a new one"	ProjectViewMorph openFromFile: strm.		"Later check rest of servers if fails.  Still have list here"! !!Project methodsFor: 'file in/out' stamp: 'tk 4/2/2000 16:05'!loadFromServer	| servers pair resp thumbnailWindow |	"If a newer version of me is on the server, load it."	self == CurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #loadFromServer].	(servers _ self serverList) isEmpty 		ifTrue: [^ self inform: 'This project thinks it has never been on a server'].	pair _ self class mostRecent: self name onServer: servers first.	pair first ifNil: [^ self inform: 'can''t find file on serverfor ', self name].	(Base64MimeConverter decodeInteger: version unescapePercents) > pair second ifTrue: [		^ self inform: 'That server has an older version of the project.'].	version = (pair first findTokens: '|.') second 		ifTrue: [resp _ (PopUpMenu labels: 'Reload anyway\Cancel' withCRs) startUpWithCaption: 					'The only changes are the ones you made here.'.				resp ~= 1 ifTrue: [^ nil]]		ifFalse: [resp _ (PopUpMenu labels: 'Load it\Cancel' withCRs) startUpWithCaption: 					'A newer version exists on the server.'.				resp ~= 1 ifTrue: [^ nil]].	"Find parent project, go there, zap old thumbnail"	thumbnailWindow _ parentProject findProjectView: self.	thumbnailWindow 		ifNotNil: [thumbnailWindow delete.			thumbnailWindow owner ifNotNil: [^ self]]	"user refused"		ifNil: [(SelectionMenu confirm: 'no thumbnail. Debug?') ifTrue: [self halt]].	"replace with a new one"	ProjectViewMorph openFromFile: (servers first oldFileNamed: pair first).		"Later check rest of servers if fails.  Still have list here"! !!Project methodsFor: 'file in/out' stamp: 'tk 4/2/2000 15:52'!saveAs	"Forget where stored before, and store.  Will ask user where."	self urlList: nil.	self storeOnServer.! !!Project methodsFor: 'file in/out' stamp: 'tk 4/2/2000 16:04'!storeOnServer	| servers pair newVersion resp newName local folder |	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	self == CurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer].	"write locally"	self exportSegment.	(FileStream oldFileNamed: self name, '.pr') compressFile.	"Find out what version"	(servers _ self serverList) isEmpty 		ifTrue: [folder _ PluggableFileList getFolderDialog openLabel:					 'Select a folder on a server:'.			folder ifNil: [^ self].			servers _ Array with: folder.			urlList _ Array with: folder realUrl.			pair _ Array with: nil with: -1]		ifFalse: [pair _ self class mostRecent: self name onServer: servers first].	(newVersion _ self newVersion: pair) ifNil: [^ self].	newName _ self name, '|', newVersion, '.pr'.	local _ FileStream oldFileNamed: self name, '.pr.gz'.	resp _ servers first putFile: local named: newName retry: false.	resp ifFalse: [self inform: 'the primary server of this project seems to be down'.  ^ self].	version _ newVersion.	"committed"	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."	"Rename disk file to be the final name"	local reset.	local localName = newName 		ifFalse: [FileDirectory default rename: local localName toBe: newName]		ifTrue: [local close].! !!Project methodsFor: 'file in/out' stamp: 'tk 4/2/2000 16:15'!storeToMakeRoom	| params memoryEnd goalFree cnt gain proj skip tried |	"Write out enough projects to fulfill the space goals.  Include the size of the project about to come in."	GoalFreePercent ifNil: [GoalFreePercent _ 33].	GoalNotMoreThan ifNil: [GoalNotMoreThan _ 20000000].	params _ Smalltalk getVMParameters.	memoryEnd	_ params at: 3."	youngSpaceEnd	_ params at: 2.	free _ memoryEnd - youngSpaceEnd."	goalFree _ GoalFreePercent asFloat / 100.0 * memoryEnd.	goalFree _ goalFree min: GoalNotMoreThan.	world isInMemory ifFalse: ["enough room to bring it in"		goalFree _ goalFree + (self projectParameters at: #segmentSize ifAbsent: [0])].	cnt _ 30.	gain _ Smalltalk garbageCollectMost.	"skip a random number of projects that are in memory"	proj _ self.  skip _ 6 atRandom.	[proj _ proj nextInstance ifNil: [Project someInstance].		proj world isInMemory ifTrue: [skip _ skip - 1].		skip > 0] whileTrue.	cnt _ 0.  tried _ 0.	[gain > goalFree] whileFalse: [		proj _ proj nextInstance ifNil: [Project someInstance].		proj storeSegment ifTrue: ["Yes, did send its morphs to the disk"			gain _ gain + (proj projectParameters at: #segmentSize 						ifAbsent: [20000]).	"a guess"			(PluckedSound pitch: 261.625*4 dur: 1 loudness: 0.1) play.			(cnt _ cnt + 1) > 5 ifTrue: [^ self]].	"put out 5 at most"		(tried _ tried + 1) > 23 ifTrue: [^ self]].	"don't get stuck in a loop"! !!Project class methodsFor: 'squeaklet on server' stamp: 'tk 3/31/2000 11:12'!fromUrl: urlString	| serverFile pair pvm thumbnailWindow pr |	"Load the project, and make a thumbnail to it in the current project.  Replace the old one if necessary.Project fromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/SqueakEasy.extSeg'."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	World ifNil: [^ self inform: 			'Later, allow jumping from MVC to Morphic Projects.'].	serverFile _ ServerFile new fullPath: urlString.	(pr _ Project named: (serverFile fileName findTokens: '|.') first) 		ifNotNil: ["it appeared" ^ pr enter].	pair _ self mostRecent: serverFile fileName onServer: serverFile.	pair first ifNil: [^ self inform: 'can''t find file on server'].	"Find parent project, go there, zap old thumbnail"	World submorphsDo: [:sub | 		(sub isKindOf: SystemWindow) ifTrue: [			(pvm _ sub findA: ProjectViewMorph) ifNotNil: [				(pvm class == DiskProxy and: 					[pvm constructorArgs first = urlString])						ifTrue: [thumbnailWindow _ sub]]]].	thumbnailWindow ifNotNil: [		thumbnailWindow delete.		thumbnailWindow owner ifNotNil: [^ self]].	"user refused"	"replace with a new one"	ProjectViewMorph openFromFile: serverFile asStream.! !!ProjectViewMorph reorganize!('copying' veryDeepFixupWith: veryDeepInner:)('drawing' borderColor borderWidth: fullDrawOn: showBorderAs:)('events' abandon balloonText deletingProject: drawOn: enter extent: handlesMouseDown: handlesMouseOver: initialize mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp: on: project: step)('fileIn/out' exportSegment storeSegment)('accessing' project)('object fileIn' convertbosfceipl0:bosfceiplcm0:)!!ProjectViewMorph methodsFor: 'events' stamp: 'tk 4/1/2000 18:55'!step	| cmd |	"Check for a command that could not be executed in my subproject.  Once it is done, remove the trigger.  If this is too slow, make armsLengthCmd an inst var."	cmd _ self valueOfProperty: #armsLengthCmd.	cmd ifNil: [^ super step].	self removeProperty: #armsLengthCmd.	(self valueOfProperty: #wasStepping) ifFalse: [		self stopStepping].	self removeProperty: #wasStepping.	project perform: cmd.	project enter.! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'tk 3/31/2000 21:16'!openFromFile: preStream	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList window proj |	morphOrList _ preStream asUnZippedStream fileInObjectAndCode.	(morphOrList isKindOf: ImageSegment) ifTrue: [		(morphOrList arrayOfRoots count: [:mm | mm class == Project]) > 1 ifTrue: [			self error: 'which project is main?']. 	"debug"		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [proj versionFrom: preStream.			window _ (SystemWindow labelled: proj name) model: proj.			window				addMorph: (self on: proj)				frame: (0@0 corner: 1.0@1.0).			window openInWorld.			proj setParent: Project current.			^ proj enter]].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'].	(window _ self newMorphicProjectOn: morphOrList) openInWorld.	window model enter! !