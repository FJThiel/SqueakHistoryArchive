'From Squeak 2.1 of June 30, 1998 on 18 August 1998 at 4:47:35 pm'!"Change Set:		Celeste98Date:			18 August 1998Author:			John MaloneyThis is a fairly complete mail and news reader and organizer. It can currentlyparse various kinds of mail and news files, including Eudora 3.0 and several flavorsof Unix mail and news files. Celeste supports light-weight categorization and messagefilters. It stores messages in a single text file that is treated as append-only.Thus, the message data itself is quite robust and recoverable.  Index and categoryinformation is kept in separate files which are read into memory at the start ofa session and saved at the end of a session. The index file can be completelyreconstructed from the message file if necessary. Outgoing messages are appendedto a file named 'outbox'.What is most needed is support for POP3 and SMTP for fetching and postingmail. (Celeste was originally written for a Smalltalk that lacked networkingsupport). News can be supported via the NTTP protocol. In addition, it wouldbe nice to add some nice user feedback during long-running operations such ascompacting the messages file, and it would be terrific to make mail fetchingwork nicely in the background (including graceful handling of timeouts andnetwork errors). Finally, closing the Celeste window should checkpoint and closethe mail database (if there are no other Celeste windows on it) and snapshottingshould checkpoint the database. (These are features that used to work buthave not yet been ported to Squeak.)Stay tuned for future developements!!"!!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:44'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [^ OrderedCollection new].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:43'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 162>	^ #badDirectoryPath! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !Model subclass: #Celeste	instanceVariableNames: 'mailDB currentCategory currentMessages currentTOC currentMsgID lastCategory subjectFilter fromFilter dateFilter customFilterBlock formatMessages lastCategoryList lastCategoryMenu messageTextView '	classVariableNames: 'CCList CustomFilters DeleteInboxAfterFetching FormatWhenFetching InOutFolder SuppressWorthlessHeaderFields UserName '	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!Celeste commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am the core of a mail reading and organizing program. The name "Celeste" is a reference to an earlier mail reader named "Babar", which was written at Xerox PARC by Steve Putz and John Maloney.This object provides a user interface and some higher-level functionality for the application. The foundation of of the mail reader is really the mail database, implemented by the class MailDB.!!Celeste methodsFor: 'open-close'!close	"Close the mail database."	mailDB release.	"closes the mail database"	mailDB _ nil.! !!Celeste methodsFor: 'open-close' stamp: 'jm 8/14/1998 15:28'!openOnDatabase: aMailDB	"Initialize myself for the mail database with the given root filename."	mailDB _ aMailDB.	mailDB addDependent: self.	currentCategory _ 'new'.	lastCategory _ ''.	subjectFilter _ ''.	fromFilter _ ''.	dateFilter _ nil.	self changed: #categoryList.! !!Celeste methodsFor: 'categories pane'!addCategory	"Create a new category with the user-specified name. This does nothing if the category already exists."	| newCatName |	newCatName _ FillInTheBlank request: 'Name for new category?'.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB addCategory: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane'!category	"Answer the currently selected category or nil."	^currentCategory! !!Celeste methodsFor: 'categories pane'!categoryList	"Answer a list of categories for the categories pane."	^mailDB allCategories! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/18/1998 16:26'!categoryMenu: shiftDown	"Answer the menu for the categories pane."	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [^ SelectionMenu			labels: 'save\close\fetch mail\fetch news\add category\rename category\remove category\export category\empty trash\compact\toggle headers\set user name\set cc: list\ set in/outbox folder ' withCRs			lines: #(2 4 8 10 11)			selections: #(save saveAndClose fetchMail fetchNews addCategory renameCategory removeCategory exportCategory emptyTrash compact toggleSuppressHeaders setUserName setCCList setInOutFolder)]		ifFalse: [^ SelectionMenu			labels: 'save\close\fetch mail\fetch news\add category\empty trash\compact\toggle headers\set user name\set cc: list\ set in/outbox folder ' withCRs			lines: #(2 4 5 7 8)			selections: #(save saveAndClose fetchMail fetchNews addCategory emptyTrash compact toggleSuppressHeaders setUserName setCCList setInOutFolder)].! !!Celeste methodsFor: 'categories pane'!compact	"Compact the messages file."	| stats |	Transcript cr; show: 'Compacting message file...'.	Cursor execute showWhile: [stats _ mailDB compact].	Transcript show: 'Done.'; cr.	Transcript show:		'Recovered ',		(stats at: 1) printString, ' message',		(((stats at: 1) > 1) ifTrue: ['s, '] ifFalse: [', ']),		(stats at: 2) printString, ' bytes.'; cr.! !!Celeste methodsFor: 'categories pane'!emptyTrash	"Delete all messages in the '.trash.' category.	WARNING: The messages will be completely removed from the database."	| msgList |	msgList _ self filteredMessagesIn: '.trash.'.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB deleteAll: msgList.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'categories pane'!exportCategory	"Store the filtered message list of the current category to another mail database. The user is prompted for the name of the other database."	| destDBName destDB |	destDBName _ FillInTheBlank		request: 'Destination mail database?'		initialAnswer: ''.	(destDBName isEmpty) ifTrue: [^self].	destDB _ MailDB openOn: destDBName.	(destDB isNil) ifTrue: [^self].	destDB mergeMessages: (self filteredMessagesIn: currentCategory) from: mailDB.	destDB saveDB.	destDB changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/18/1998 15:51'!fetchMail	"Add the messages from the mail inbox file into this mail database."	| inboxPath count |	inboxPath _ Celeste inOutFolder.	inboxPath size > 0		ifTrue: [ inboxPath _ inboxPath, ':inbox' ]		ifFalse: [ inboxPath _ 'inbox' ].	Transcript show: 'Fetching mail from ', inboxPath.	count _ mailDB fetchMailFrom: inboxPath		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching.	Transcript nextPutAll: count printString, ' messages'; cr; endEntry.	currentCategory _ 'new'.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/18/1998 15:51'!fetchNews	"Add the messages from the news inbox file into this mail database."	| inboxPath count |	inboxPath _ Celeste inOutFolder.	inboxPath size > 0		ifTrue: [ inboxPath _ inboxPath, ':newsInbox' ]		ifFalse: [ inboxPath _ 'newsInbox' ].	Transcript show: 'Fetching news from ', inboxPath.	count _ mailDB fetchNewsFrom: inboxPath		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching. 	Transcript nextPutAll: count printString, ' messages'; cr; endEntry.	count > 0 ifTrue: [		self changed: #categoryList.		self updateTOC].! !!Celeste methodsFor: 'categories pane'!removeCategory	"Remove the existing category with the user-specified name."	| msgList |	(currentCategory notNil) ifTrue: [		msgList _ mailDB messagesIn: currentCategory.		(mailDB messagesIn: '.trash.') do: [: id |			msgList remove: id ifAbsent: []].		msgList isEmpty ifFalse: [			(self confirm:'This category is not empty. Areyou sure you wish to remove it?') ifFalse: [^self]].		mailDB removeCategory: currentCategory.		currentCategory _ nil.		self changed: #categoryList].! !!Celeste methodsFor: 'categories pane'!renameCategory	"Rename the category with the user-specified name."	| newCatName |	newCatName _ FillInTheBlank		request: 'New name?'		initialAnswer:			((currentCategory notNil) ifTrue: [currentCategory] ifFalse: ['']).	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB renameCategory: currentCategory to: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.! !!Celeste methodsFor: 'categories pane'!save	"Snapshot the database to disk."	mailDB saveDB.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/18/1998 16:25'!saveAndClose	self close.	self topView ifNotNil: [self topView controller close].! !!Celeste methodsFor: 'categories pane'!setCCList	"Change the default cc: list for use in composing messages."	self class setCCList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/14/1998 14:00'!setCategory: newCategory	"Change the currently selected category. We must also compute the table of contents and message list for the new category."	currentCategory _ newCategory.	(newCategory isNil)		ifTrue:			[currentMessages _ currentTOC _ currentMsgID _ nil]		ifFalse:			[currentMessages _ self filteredMessagesIn: newCategory.			 currentTOC _ OrderedCollection new: currentMessages size.			 1 to: currentMessages size do:				[: i |				 currentTOC add:					(i printString, ' ',					 (mailDB getTOCstring: (currentMessages at: i)))].			 currentTOC _ currentTOC asArray.			 (currentMessages includes: currentMsgID) ifFalse:				[currentMsgID _ nil]].	self changed: #tocEntryList.! !!Celeste methodsFor: 'categories pane'!setInOutFolder	"Change the folder used to store the inbox and outbox files."	self class setInOutFolder.! !!Celeste methodsFor: 'categories pane'!setUserName	"Change the user's email name for use in composing messages."	self class setUserName.! !!Celeste methodsFor: 'categories pane'!toggleSuppressHeaders	SuppressWorthlessHeaderFields _		SuppressWorthlessHeaderFields not.	self changed: #message.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/14/1998 16:50'!underConstruction	self halt: 'Sorry, that is still under construction!!'.! !!Celeste methodsFor: 'table of contents pane'!deleteAll	"Move all visible messages in the current category to '.trash.'."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: '.trash.'.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 16:32'!deleteMessage	"Move the current message to the '.trash.' category and select the next message. Deleted messages can later purged by invoking the 'deleteAll' command in the '.trash.' category."	currentMsgID isNil ifTrue: [^ self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: '.trash.'.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAgain	"File the current message in the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAll	"File all visible messages in the current category in some other category as well."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileMessage	"File the current message in another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!getCategoryNameIfNone: aBlock	"Prompt the user for a category name, remembering it for the next time."	| catList categoryName |	catList _ self categoryList.	catList remove: '.all.' ifAbsent: [].	catList remove: '.trash.' ifAbsent: [].	catList remove: '.unclassified.' ifAbsent: [].	catList add: '<new category>'.	((lastCategoryList ~= catList) or: [lastCategoryMenu = nil])		ifTrue: [lastCategoryMenu _ SelectionMenu selections: catList].	categoryName _ lastCategoryMenu startUp.	categoryName = nil ifTrue: [^aBlock value].	categoryName = '<new category>' ifTrue: [		categoryName _ FillInTheBlank			request: 'New category name?'			initialAnswer: ''.		(categoryName isEmpty) ifTrue: [^aBlock value].		lastCategoryMenu _ nil.		mailDB addCategory: categoryName.		self changed: #categoryList.	].	lastCategoryList _ catList.	^lastCategory _ categoryName! !!Celeste methodsFor: 'table of contents pane'!moveAgain	"Move the current message to the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveAll	"Move all visible messages in the current category to another category."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveMessage	"Move the current message to another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 14:00'!nextMessage	"Select the next message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index < currentMessages size ifTrue: [		currentMsgID _ currentMessages at: index + 1.		self changed: #tocEntry].! !!Celeste methodsFor: 'table of contents pane'!otherCategories	"Prompt the user with a menu of all other categories in which the currently selected message appears. If the user chooses a category from this menu, go to that category."	| otherCategories choice |	otherCategories _		(mailDB categoriesThatInclude: currentMsgID) asOrderedCollection.	otherCategories remove: currentCategory ifAbsent: [].	(otherCategories isEmpty) ifTrue: [^self].	choice _ (SelectionMenu selections: otherCategories) startUp.	choice = nil ifFalse: [self setCategory: choice].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 14:00'!previousMessage	"Select the previous message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index > 1 ifTrue: [		currentMsgID _ currentMessages at: index - 1.		self changed: #tocEntry].! !!Celeste methodsFor: 'table of contents pane'!removeAll	"Remove all messages from the current category."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!removeMessage	"Remove the current message from the current category."	mailDB remove: currentMsgID fromCategory: currentCategory.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!search	| destCat matchString msgText |	destCat _ FillInTheBlank		request: 'In what category should the search results be filed?'		initialAnswer: '.search results.'.	(destCat isEmpty) ifTrue: [^self].	matchString _ FillInTheBlank		request: 'String sought in message text?'		initialAnswer: ''.	(self filteredMessagesIn: currentCategory) do:		[: msgID |		 msgText _ mailDB getText: msgID.		 ((msgText findString: matchString startingAt: 1) > 0) ifTrue:			[mailDB file: msgID inCategory: destCat]].	self changed: #categoryList.! !!Celeste methodsFor: 'table of contents pane'!setTOCEntry: newTOCentry	"Change the currently selected message. This is done by finding the message ID corresponding to the selected table of contents entry."	| i |	(newTOCentry isNil | currentTOC isNil)		ifTrue: [currentMsgID _ nil]		ifFalse:			[i _ currentTOC indexOf: newTOCentry ifAbsent: [nil].			 (i isNil)				ifTrue: [currentMsgID _ nil]				ifFalse: [currentMsgID _ currentMessages at: i]].	self changed: #message.  "update the message pane"! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:56'!tocEntry	"Answer the table of contents entry for the currently selected message or nil."	(currentMsgID isNil)		ifTrue: [^nil]		ifFalse: [^currentTOC at: (currentMessages indexOf: currentMsgID)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocEntryList	"Answer a collection of table-of-contents entries for the currently selected category or an empty collection if no category is selected."	currentCategory		ifNil: [^ #()]		ifNotNil: [^ currentTOC].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocKeystroke: aCharacter	aCharacter = Character backspace ifTrue: [self deleteMessage].	aCharacter asciiValue = 30 ifTrue: [self previousMessage].	aCharacter asciiValue = 31 ifTrue: [self nextMessage].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 15:45'!tocMenu: shiftDown	"Answer the menu for the table of contents pane."	currentCategory ifNil: [^ nil].	currentMsgID		ifNil: [			^ SelectionMenu				labels: 'compose\file all\move all\ remove all \delete all\search' withCRs				lines: #(1 5)				selections: #(compose fileAll moveAll removeAll deleteAll search)]		ifNotNil: [			^ SelectionMenu				labels: 'delete\compose\reply\forward\file again\move again\file\move\remove\file all\move all\remove all\delete all\ other categories \search' withCRs				lines: #(1 4 6 9 13 14)				selections: #(deleteMessage compose reply forward fileAgain moveAgain fileMessage moveMessage removeMessage fileAll moveAll removeAll deleteAll otherCategories search)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 14:01'!updateTOC	"Update the table of contents after a moving, removing, or deleting a message. Select a message near the removed message in the table of contents if possible."	| currentMsgIndex |	((currentCategory isNil) |	 (currentMsgID isNil) |	 (currentMessages size < 2))		ifTrue: [currentMsgIndex _ 1]		ifFalse: [currentMsgIndex _ currentMessages indexOf: currentMsgID].	currentMsgID _ nil.	self setCategory: currentCategory.  "update currentMessages, currentTOC"	currentMessages isEmpty ifFalse: [		(currentMsgIndex <= currentMessages size)			ifTrue: [currentMsgID _ currentMessages at: currentMsgIndex]			ifFalse: [currentMsgID _ currentMessages last].	].	self changed: #tocEntryList.! !!Celeste methodsFor: 'filtering'!customFilterOff	"Cancel custom filtering."	customFilterBlock _ nil.	self updateTOC.! !!Celeste methodsFor: 'filtering'!customFilterOn	"Select or define and activate a custom filter."	| filterList filterName filterExpr |	filterList _ CustomFilters keys asOrderedCollection.	filterList addLast: '<define new filter...>'.	filterList addLast: '<edit exising filter...>'.	filterList addLast: '<delete a filter...>'.	filterName _ (SelectionMenu selections: filterList)			startUpWithCaption: 'Select a filter:'.	filterName = nil ifTrue: [^self].	filterName = '<delete a filter...>' ifTrue: [^ self deleteFilter].	filterName = '<edit exising filter...>'		ifTrue: [filterExpr _ self editFilter]		ifFalse: [			filterName = '<define new filter...>'				ifTrue: [filterExpr _ self defineFilter]				ifFalse: [filterExpr _ CustomFilters at: filterName]].	filterExpr isEmpty ifTrue: [^self].	customFilterBlock _ Compiler evaluate: '[ :m | ', filterExpr, ']'.	self updateTOC.! !!Celeste methodsFor: 'filtering'!defineFilter	| filterName expr |	filterName _ FillInTheBlank request: 'Filter name?'.	filterName isEmpty ifTrue: [^''].	(CustomFilters includesKey: filterName)		ifTrue: [expr _ CustomFilters at: filterName]		ifFalse: [expr _ ''].	^self editFilterNamed: filterName filterExpr: expr! !!Celeste methodsFor: 'filtering'!deleteFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (SelectionMenu selections: filterList)		startUpWithCaption: 'Filter to delete?'.	filterName = nil ifTrue: [^''].	CustomFilters removeKey: filterName ifAbsent: [].! !!Celeste methodsFor: 'filtering'!editFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (SelectionMenu selections: filterList)		startUpWithCaption: 'Filter to edit?'.	filterName = nil ifTrue: [^''].	^self editFilterNamed: filterName filterExpr: (CustomFilters at: filterName)! !!Celeste methodsFor: 'filtering'!editFilterNamed: filterName filterExpr: oldExpr	| newDefinition |	newDefinition _ FillInTheBlank		request:'Enter a filter definition where "m" is the message being testing. The expression can send"fromHas:", "toHas:", "ccHas:", "subjectHas:", "participantHas:", or "textHas:" to m to test forinclusion of a string--or one of an array of strings--in a field. It can also test m''s timeand/or date and can combine several tests with logical operators. Examples:	(m fromHas: ''johnm'') or: [m toHas: ''johnm'']	m participantHas: ''johnm''				-- messages from, to, or cc-ing johnm	m textHas: #(squeak smalltalk java)		-- messages with any of these words	m subjectHas: #(0 1 2 3 4 5 6 7 8 9)		-- numbers in lists treated as stringsNOTE: "textHas:" is very slow, since it must read the message from disk.'		initialAnswer: oldExpr.	newDefinition isEmpty ifTrue: [^''].	CustomFilters at: filterName put: newDefinition.	^newDefinition! !!Celeste methodsFor: 'filtering'!filteredMessagesIn: categoryName	| msgList |	msgList _ mailDB messagesIn: categoryName.	(categoryName = '.trash.') ifFalse: [		"suppress deleted messages"		(mailDB messagesIn: '.trash.') do: [: id |			msgList remove: id ifAbsent: [].		].	].	(customFilterBlock notNil) ifTrue:		[msgList _ msgList select:			[: id | customFilterBlock value: (mailDB getTOCentry: id) ]].	(fromFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) from includesSubstring: fromFilter caseSensitive: false]].	(subjectFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) subject includesSubstring: subjectFilter caseSensitive: false]].	^msgList! !!Celeste methodsFor: 'filtering'!fromFilterOff	"Cancel from filtering."	fromFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering'!fromFilterOn	"Show only those messages from the same person as the currently selected message. The user is given a chance to edit the pattern string used to match 'From:' fields."	fromFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) from].	fromFilter _ FillInTheBlank		request: '''From:'' filter pattern?'		initialAnswer: fromFilter.	self updateTOC.! !!Celeste methodsFor: 'filtering'!subjectFilterOff	"Cancel subject filter."	subjectFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/14/1998 16:33'!subjectFilterOn	"Show only those messages whose subject matches the currently selected message. The user is given a chance to edit the pattern string used to match 'Subject:' fields."	subjectFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) subject].	subjectFilter _ FillInTheBlank		request: '''Subject:'' filter pattern?'		initialAnswer: subjectFilter.	self updateTOC.! !!Celeste methodsFor: 'message text pane'!changeMessage: newText	"Accept an edited version of a message and store it away. Answer true if successful."	(currentCategory isNil | currentMsgID isNil)		ifTrue: [^false]		ifFalse: [			mailDB newText: newText asString for: currentMsgID.			self updateTOC.			^ true].! !!Celeste methodsFor: 'message text pane'!compose	"Make a MailSendTool for composing a new message."	Celeste openMailSenderOn: mailDB composeText.! !!Celeste methodsFor: 'message text pane'!contents	"Interface to StringHolderView."	(SuppressWorthlessHeaderFields and: [FormatWhenFetching not])		ifTrue: [^self formatedMessage]		ifFalse: [^self message].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/14/1998 15:25'!contents: newText	"Interface to StringHolderView."	currentCategory isNil | currentMsgID isNil ifTrue: [^ self].	mailDB newText: newText asString for: currentMsgID.	self updateTOC.  "in case the message header was changed"	messageTextView hasUnacceptedEdits: false.! !!Celeste methodsFor: 'message text pane'!formatedMessage	"Answer a string that is my formatted mail message."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getMessage: currentMsgID) formattedText].! !!Celeste methodsFor: 'message text pane'!forward	"Make a MailSendTool for forwarding the current message."	(currentMsgID notNil) ifTrue:		[Celeste openMailSenderOn: (mailDB forwardTextFor: currentMsgID)].! !!Celeste methodsFor: 'message text pane'!message	"Answer the text of the currently selected message or nil if there isn't one."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getText: currentMsgID) asText]! !!Celeste methodsFor: 'message text pane'!messageMenu	"Answer the menu for the message text pane."	(currentMsgID notNil)		ifTrue: [^SelectionMenu			labels: 'again\undo\copy\cut\paste\format\accept\cancelcompose\reply\forward' withCRs			lines: #(2 5 6 8)			selections: #(again undo copySelection cut paste format accept cancelcompose reply forward)]		ifFalse: [^SelectionMenu			labels: 'again\undo\copy\cut\paste\compose' withCRs			lines: #(2 5)			selections: #(again undo copySelection cut paste compose)].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/14/1998 15:13'!messageTextView: aView	messageTextView _ aView.! !!Celeste methodsFor: 'message text pane'!reply	"Make a MailSendTool for replying to the current message."	(currentMsgID notNil) ifTrue:		[Celeste openMailSenderOn: (mailDB replyTextFor: currentMsgID)].! !!Celeste methodsFor: 'other' stamp: 'jm 8/14/1998 15:26'!clearUserEditFlag	messageTextView hasUnacceptedEdits: false.! !!Celeste methodsFor: 'other' stamp: 'jm 8/14/1998 15:30'!okToChange	"This message is sent when changing the selection in either the message cateory or message list panes. Eventually, this should ask the user if it is okay to throw away and unaccepted edits of the current message. For now, it always gives permission."	currentCategory isNil | currentMsgID isNil ifTrue: [		"no message selected; discard edits in message pane silently"		messageTextView hasUnacceptedEdits: false.		^ true].	messageTextView hasUnacceptedEdits ifFalse: [^ true].	(SelectionMenu confirm: 'Discard changes to currently selected message?')		ifTrue: [messageTextView hasUnacceptedEdits: false. ^ true]		ifFalse: [^ false].! !!Celeste methodsFor: 'other' stamp: 'jm 8/14/1998 14:28'!perform: selector orSendTo: otherTarget	"Celeste handles all menu commands."	self perform: selector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Celeste class	instanceVariableNames: ''!!Celeste class methodsFor: 'class initialization'!initialize	"Celeste initialize"	"user preferences"	InOutFolder _ nil.	UserName _ nil.	CCList _ nil.	SuppressWorthlessHeaderFields _ true.	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	DeleteInboxAfterFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:29'!addButtons: topView model: model	"Add some handy buttons to the interface window."	| subjectFButton fromFButton customFButton deleteButton replyButton forwardButton |	subjectFButton _ PluggableButtonView on:		(Switch new			onAction: [model subjectFilterOn];			offAction: [model subjectFilterOff]).	subjectFButton		label: ('Subj. F.' asParagraph centered);		borderWidth: 1;		window: (0@0 extent: 17@5).	fromFButton _ PluggableButtonView on:		(Switch new			onAction: [model fromFilterOn];			offAction: [model fromFilterOff]).	fromFButton		label: ('From F.' asParagraph centered);		borderWidth: 1;		window: (0@0 extent: 17@5).	customFButton _ PluggableButtonView on:		(Switch new			onAction: [model customFilterOn];			offAction: [model customFilterOff]).	customFButton		label: ('Custom F.' asParagraph centered);		borderWidth: 1;		window: (0@0 extent: 16@5).	replyButton _		PluggableButtonView new			model: (Button new onAction: [model reply]);			action: #turnOn;			label: ('Reply' asParagraph centered);			borderWidth: 1;			window: (0@0 extent: 17@5).	forwardButton _		PluggableButtonView new			model: (Button new onAction: [model forward]);			action: #turnOn;			label: ('Forward' asParagraph centered);			borderWidth: 1;			window: (0@0 extent: 16@5).	deleteButton _		PluggableButtonView new			model: (Button new onAction: [model deleteMessage]);			action: #turnOn;			label: ('Delete' asParagraph centered);			borderWidth: 1;			window: (0@0 extent: 17@5).	topView		addSubView: subjectFButton;		addSubView: fromFButton toRightOf: subjectFButton;		addSubView: customFButton toRightOf: fromFButton;		addSubView: replyButton toRightOf: customFButton;		addSubView: forwardButton toRightOf: replyButton;		addSubView: deleteButton toRightOf: forwardButton.	^ subjectFButton! !!Celeste class methodsFor: 'instance creation'!openOn: rootFilename	"Open a MailReader on the mail database with the given root filename."	"Celeste openOn: 'test'"	^ self openOnDatabase: (MailDB openOn: rootFilename)! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 15:13'!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model categoryListView tableOfContentsView messageTextView topView firstButton |	model _ self new openOnDatabase: aMailDB.	categoryListView _ PluggableListViewByItem		on: model		list: #categoryList		selected: #category		changeSelected: #setCategory:		menu: #categoryMenu:		keystroke: nil.	categoryListView window: (0@0 extent: 40@25).	tableOfContentsView _ PluggableListViewByItem		on: model		list: #tocEntryList		selected: #tocEntry		changeSelected: #setTOCEntry:		menu: #tocMenu:		keystroke: #tocKeystroke:.	tableOfContentsView window: (0@0 extent: 60@25).	messageTextView _ StringHolderView new		model: model;		controller: MailTextController new;		window: (0@0 extent: 100@70);		borderWidth: 1.	model messageTextView: messageTextView.	topView _ StandardSystemView new		model: model;		label: 'Celeste';		minimumSize: 400@250.	firstButton _ self addButtons: topView model: model.	topView		addSubView: categoryListView below: firstButton;		addSubView: tableOfContentsView toRightOf: categoryListView;		addSubView: messageTextView below: categoryListView.	topView controller open.! !!Celeste class methodsFor: 'user preferences'!ccList	"Answer the default cc list to be used in composing messages."	CCList isNil ifTrue: [self setCCList].	^CCList! !!Celeste class methodsFor: 'user preferences'!inOutFolder	"Answer the folder for the inbox/outbox files."	InOutFolder isNil ifTrue: [self setInOutFolder].	^InOutFolder! !!Celeste class methodsFor: 'user preferences'!setCCList	"Change the list of names used in the default cc list. Items in the list should be valid mail addresses and should be separated by commas."	| newList |	(CCList isNil) ifTrue: [CCList _ ''].	newList _ FillInTheBlank		request: 'Please type a list of email addresses for the cc: field,separated by commas:'		initialAnswer: CCList.	newList isEmpty ifFalse: [CCList _ newList].! !!Celeste class methodsFor: 'user preferences'!setInOutFolder	"Change the folder used to store the inbox and outbox files."	(InOutFolder isNil) ifTrue: [InOutFolder _ ''].	InOutFolder _ FillInTheBlank		request: 'Where are the inbox and outbox files kept?'		initialAnswer: InOutFolder.	((InOutFolder size > 0) and:	 [(InOutFolder last = $:) or: [InOutFolder last = $/]]) ifTrue: [		"remove folder or directory delimitor"		InOutFolder _ InOutFolder copyFrom: 1 to: InOutFolder size - 1.	].! !!Celeste class methodsFor: 'user preferences'!setUserName	"Change the user's email name for use in composing messages."	(UserName isNil) ifTrue: [UserName _ ''].	UserName _ FillInTheBlank		request: 'What is your email address?'		initialAnswer: UserName.! !!Celeste class methodsFor: 'user preferences'!userName	"Answer the user name to be used in composing messages."	[UserName isNil or: [UserName isEmpty]]		whileTrue: [self setUserName].	^UserName! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:50'!addMessageToInbox: msgString	"Append a copy of the given message to the inbox file."	| mailBox |	mailBox _ FileStream fileNamed: Celeste inOutFolder, ':inbox'.	mailBox setToEnd.	"append this message to inbox"	mailBox nextPutAll: 'From local Sun 1990' ; cr.	mailBox nextPutAll: 'Date: ', Date today printString, ' ', Time now printString; cr.	mailBox nextPutAll: msgString; cr.	mailBox close.! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:45'!addSenderButtons: topView textView: mailTextView	"Add some handy buttons to the mail sender window."	| sendButton sendAndKeepButton doneButton |	sendButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents]);			action: #turnOn;			label: ('Send' asParagraph centered);			window: (0@0 extent: 34@10);			borderWidth: 1.	sendAndKeepButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents.					 Celeste addMessageToInbox: mailTextView model contents]);			action: #turnOn;			label: ('Send&Keep' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	doneButton _		PluggableButtonView new			model: (Button new onAction: [topView controller close]);			action: #turnOn;			label: ('Done' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	topView		addSubView: sendButton above: topView firstSubView;		addSubView: sendAndKeepButton toRightOf: sendButton;		addSubView: doneButton toRightOf: sendAndKeepButton.! !!Celeste class methodsFor: 'sending'!eudoraSeparator	"Return a Eudora-style message separator string."	| s today dateString |	s _ WriteStream on: (String new: 50).	today _ Date today.	dateString _ today printFormat: #(2 1 3 32 2 1).	dateString _ dateString copyFrom: 1 to: dateString size - 4.	s nextPutAll: 'From ???@??? '.	s nextPutAll: (today weekday copyFrom: 1 to: 3); space.	s nextPutAll: dateString.	Time now print24: true on: s.	s space.	s print: today year; cr.	^s contents! !!Celeste class methodsFor: 'sending'!openMailSenderOn: aString	"Open an instance of me for editing with the given initial message text."	| model messageTextView topView |	model _ StringHolder new.	model contents: aString asString.	messageTextView _ StringHolderView container: model.	messageTextView		window: (0@0 extent: 100@90);		borderWidth: 1.	topView _ StandardSystemView new.	topView		model: model;		label: 'Mister Postman';		minimumSize: 300@200;		addSubView: messageTextView.	self addSenderButtons: topView textView: messageTextView.	topView controller open.! !!Celeste class methodsFor: 'sending'!postMessage: msgString	"Send the message on its merry way..."	self postToEudoraOutbox: msgString.! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:50'!postToEudoraOutbox: msgString	"Append the given message to a Eudora outbox."	| mailBox |	mailBox _ FileStream fileNamed: self inOutFolder, ':outbox'.	mailBox setToEnd.	mailBox nextPutAll: self eudoraSeparator.	mailBox nextPutAll: (MailMessage from: msgString) eudoraOutboxText.	mailBox cr.	mailBox close.! !!Celeste class methodsFor: 'sending'!postToUnixOutbox: msgString	"Append the given message to a Unix shell-script outbox."	| mailBox |	mailBox _ FileStream fileNamed: self inOutFolder, ':outbox'.	mailBox setToEnd.	"append this message to outbox"	mailBox nextPutAll: 'cat - >outgoingMsg <<\endmsg'; cr.	mailBox nextPutAll: msgString; cr.	mailBox nextPutAll: 'endmsg'; cr.	mailBox nextPutAll: '/usr/lib/sendmail -v -t <outgoingMsg'; cr.	mailBox close.! !Celeste initialize!Object subclass: #IndexFileEntry	instanceVariableNames: 'messageFile msgID location textLength time from to cc subject tocLineCache '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!IndexFileEntry commentStamp: 'jm 8/18/1998 16:48' prior: 0!An IndexFileEntry contains enough information to present a table-of-contents entry for the message and to support simple filtering based on a subset of the mail header information. The IndexFile maps unique message ID's to IndexFileEntries.!!IndexFileEntry methodsFor: 'access'!cc	^cc! !!IndexFileEntry methodsFor: 'access'!cc: aString	cc _ aString.! !!IndexFileEntry methodsFor: 'access'!date	"Answer a date string for this index entry."	^Date fromDays: (time + (Date newDay: 1 year: 1980) asSeconds) // 86400! !!IndexFileEntry methodsFor: 'access'!from	^from! !!IndexFileEntry methodsFor: 'access'!from: aString	from _ aString.! !!IndexFileEntry methodsFor: 'access'!location	^location! !!IndexFileEntry methodsFor: 'access'!location: anInteger	location _ anInteger.! !!IndexFileEntry methodsFor: 'access'!messageFile	^messageFile! !!IndexFileEntry methodsFor: 'access'!messageFile: aMessageFile	messageFile _ aMessageFile.! !!IndexFileEntry methodsFor: 'access'!msgID	^msgID! !!IndexFileEntry methodsFor: 'access'!msgID: anID	msgID _ anID.! !!IndexFileEntry methodsFor: 'access'!subject	^subject! !!IndexFileEntry methodsFor: 'access'!subject: aString	subject _ aString.! !!IndexFileEntry methodsFor: 'access'!textLength	^textLength! !!IndexFileEntry methodsFor: 'access'!textLength: anInteger	textLength _ anInteger.! !!IndexFileEntry methodsFor: 'access'!time	^time! !!IndexFileEntry methodsFor: 'access'!time: anInteger	time _ anInteger.! !!IndexFileEntry methodsFor: 'access'!to	^to! !!IndexFileEntry methodsFor: 'access'!to: aString	to _ aString.! !!IndexFileEntry methodsFor: 'printing'!computeTOCString	"Answer a string for the table of contents."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	| fromFieldSize s |	fromFieldSize _ 17.	s _ WriteStream on: (String new: 120).	s nextPutAll: self dateString.	[s position <= 9] whileTrue: [s space].	s nextPutAll: (self fromStringLimit: fromFieldSize).	[s position <= (9 + fromFieldSize + 2)] whileTrue: [s space].	s nextPutAll: subject.	^s contents! !!IndexFileEntry methodsFor: 'printing'!dateString	"Answer a date string for this index entry."	^self date printFormat: #(2 1 3 47 1 2)! !!IndexFileEntry methodsFor: 'printing'!flushTOCCache	"Flush my cached table-of-contents entry string."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	tocLineCache _ nil.! !!IndexFileEntry methodsFor: 'printing'!fromStringLimit: limit	"Answer a cleaned up 'from' field for the table of contents."	| editedFrom s ch i |	editedFrom _ WriteStream on: (String new: limit + 1).	s _ ReadStream on: from.	s skipSeparators.	(s peek = $") ifTrue: [s next].	((i _ from indexOf: $() > 0) ifTrue: [s position: i].	[s atEnd] whileFalse: [		ch _ s next.		((ch = $@) or: [(ch = $<) or: [(ch = $)) or: [(ch = $") or:		 [editedFrom position >= limit]]]])			ifTrue: [^editedFrom contents]			ifFalse: [editedFrom nextPut: ch]].	^editedFrom contents! !!IndexFileEntry methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self dateString; cr.	aStream nextPutAll: from; cr.	aStream nextPutAll: to; cr.	aStream nextPutAll: cc; cr.	aStream nextPutAll: subject; cr.	aStream nextPut: $(; nextPutAll: location printString; space.	aStream nextPutAll: textLength printString; nextPut: $).	aStream cr.! !!IndexFileEntry methodsFor: 'printing'!tocString	"Answer a string for the table of contents."	(tocLineCache isNil) ifTrue:		[tocLineCache _ self computeTOCString].	^tocLineCache! !!IndexFileEntry methodsFor: 'read-write'!readFrom: aStream	"Initialize myself from the given text stream."	location _ MailDB readIntegerLineFrom: aStream.	textLength _ MailDB readIntegerLineFrom: aStream.	time _ MailDB readIntegerLineFrom: aStream.	from _ MailDB readStringLineFrom: aStream.	to _ MailDB readStringLineFrom: aStream.	cc _ MailDB readStringLineFrom: aStream.	subject _ MailDB readStringLineFrom: aStream.! !!IndexFileEntry methodsFor: 'read-write'!writeOn: aStream	"Write a human-readable representation of myself on the given text stream."	aStream		print: location; cr;		print: textLength; cr;		print: time; cr;		nextPutAll: from; cr;		nextPutAll: to; cr;		nextPutAll: cc; cr;		nextPutAll: subject; cr.! !!IndexFileEntry methodsFor: 'filtering support'!ccHas: stringOrList	^ self field: cc has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 8/14/1998 13:39'!field: field has: stringOrList	"Return true if either the given field contains the argument string or, if the argument is a collection, return true if the given field contains any of the strings in that collection."	| s |	(stringOrList isKindOf: String) ifTrue: [		^ field includesSubstring: stringOrList caseSensitive: false	] ifFalse: [		1 to: stringOrList size do: [ :i |			s _ stringOrList at: i.			s isNumber ifTrue: [s _ s printString].			(field includesSubstring: s caseSensitive: false) ifTrue: [^ true].		].		^ false	].! !!IndexFileEntry methodsFor: 'filtering support'!fromHas: stringOrList	^ self field: from has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!getMessage	"Answer the MailMessage for this index file entry."	^MailMessage from:		(messageFile			getMessage: msgID			at: location			textLength: textLength).! !!IndexFileEntry methodsFor: 'filtering support'!participantHas: stringOrList	^ (self field: from has: stringOrList) or:	   [(self field: self to has: stringOrList) or:	   [self field: self cc has: stringOrList]]! !!IndexFileEntry methodsFor: 'filtering support'!subjectHas: stringOrList	^ self field: subject has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!textHas: stringOrList	^ self field: self getMessage has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!toHas: stringOrList	^ self field: to has: stringOrList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IndexFileEntry class	instanceVariableNames: ''!!IndexFileEntry class methodsFor: 'instance creation'!message: aMailMessage location: location messageFile: aMessageFile msgID: msgID	"Answer a new instance of me for the given message and message file location."	^self new		messageFile: aMessageFile;		msgID: msgID;		location: location;		textLength: aMailMessage text size;		time: aMailMessage time;		from: aMailMessage from;		to: aMailMessage to;		cc: aMailMessage cc;		subject: aMailMessage subject! !!IndexFileEntry class methodsFor: 'instance creation'!readFrom: aStream messageFile: aMessageFile msgID: msgID	"Answer a new instance of me initialized from the given text stream."	^(self new readFrom: aStream)		messageFile: aMessageFile;		msgID: msgID! !Model subclass: #MailDB	instanceVariableNames: 'rootFilename messageFile indexFile categoriesFile '	classVariableNames: 'LastID '	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MailDB commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am the in-memory representation of a Celeste mail database. A mail database named "current" consists of three files:	current.messages	-- an append-only file containing the full content of all messages	current.index		-- an index of all messages in the messages file that maps unique						   message ID's to index entries containing some header information						   and the offset of the full message in the .messages file	current.categories	-- maps category names to collections of message ID'sEach open mail database has a MailDB object that manages these three files. Operations such as fetching a message given its unique ID and finding out which messages are in which category are supported by the MailDB object. It also supports incorporating new messages (reading mail), message editing and deletions, and message file compaction and recovery.!!MailDB methodsFor: 'initialize-release'!close	"Save and close the messageFile."	self saveDB.	(messageFile notNil) ifTrue: [messageFile close].	rootFilename _ nil.	messageFile _ indexFile _ categoriesFile _ nil.! !!MailDB methodsFor: 'initialize-release'!openOn: rootNameString	"Open a mail database with the given root file name."	| status |	rootFilename _ rootNameString.	status _ self dbStatus.	messageFile _ indexFile _ categoriesFile _ nil.	(status = #exists) ifTrue: [^self openDB].	(status = #partialDatabase) ifTrue: [^self recoverDB].	(status = #doesNotExist) ifTrue: [^self createDB].! !!MailDB methodsFor: 'initialize-release'!release	"Close this database."	self close.	super release.! !!MailDB methodsFor: 'open-create-save'!createDB	"Create a new mail database."	(self confirm:'Shall I create a new mail databasenamed: ', rootFilename, '?')		ifFalse:	"abort create operation"			[rootFilename _ nil.			 self release.			^nil].	self openDB.							"creates new DB files"	self saveDB.							"save the new mail database to disk"! !!MailDB methodsFor: 'open-create-save' stamp: 'jm 8/14/1998 13:43'!dbStatus	"See if my database exists. Since the database has several components, the answer is one of:	#exists				all files exist	#partialDatabase	only some of the files exist	#doesNotExist		none of the files exist"	messageFile _ FileDirectory default includesKey: rootFilename, '.messages'.	indexFile _ FileDirectory default includesKey: rootFilename, '.index'.	categoriesFile _ FileDirectory default includesKey: rootFilename, '.categories'.	(messageFile & indexFile & categoriesFile) ifTrue: [^ #exists].	(messageFile | indexFile | categoriesFile) ifFalse: [^ #doesNotExist].	^ #partialDatabase! !!MailDB methodsFor: 'open-create-save'!openDB	"Open an existing mail database."	Transcript show: 'Opening mail database ''', rootFilename, '''...'.	messageFile _ MessageFile openOn: rootFilename, '.messages'.	indexFile _ IndexFile openOn: rootFilename, '.index' messageFile: messageFile.	categoriesFile _ CategoriesFile openOn: rootFilename, '.categories'.	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'open-create-save'!recoverDB	"Open a mail database with the given root file name."	(self confirm:'The mail database named:    ', rootFilename, 'appears to be damaged. Shall I fix it?')		ifFalse: [^self release].	self openDB.	self compact.! !!MailDB methodsFor: 'open-create-save'!rootFilename	"Answer my root filename."	^rootFilename! !!MailDB methodsFor: 'open-create-save'!saveDB	"Write all database files to disk."	(rootFilename notNil)		ifTrue: [Transcript show: 'Saving mail database ''', rootFilename, '''...']		ifFalse: [Transcript show: 'Saving mail database...'].	(messageFile notNil) ifTrue: [messageFile save].	(indexFile notNil) ifTrue: [indexFile save].	(categoriesFile notNil) ifTrue: [categoriesFile save].	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'fetch-merge-compact'!appendMessages: msgBuffer messageFile: msgFile indexFile: idxFile	"Append the given collection of messages to the message file. msgBuffer is a collection of (message ID, message text) pairs."	| id msgText location entry |	msgBuffer do:		[: idAndText |		 id _ idAndText at: 1.		 msgText _ idAndText at: 2.		 location _ msgFile basicAppend: msgText id: id.		 entry _ indexFile			at: id			ifAbsent:				[IndexFileEntry					message: (MailMessage from: msgText)					location: location					messageFile: msgFile					msgID: id].		 entry _ (entry copy) location: location; textLength: msgText size.		 idxFile at: id put: entry].! !!MailDB methodsFor: 'fetch-merge-compact'!cleanUpCategories	"Prune the dead wood out of all categories."	categoriesFile categories do:		[: category |		 categoriesFile removeMessagesInCategory: category butNotIn: indexFile].! !!MailDB methodsFor: 'fetch-merge-compact'!compact	"Compact the message file and rebuild the index file. Answer an array containing with the number of messages and the number of bytes recovered."	| newMessageFile newIndexFile stats |	newMessageFile _ MessageFile openOn: rootFilename, '.messages.tmp'.	newIndexFile _ IndexFile openOn: rootFilename, '.index.tmp' messageFile: newMessageFile.	stats _ self copyUndeletedTo: newMessageFile indexFile: newIndexFile.	newMessageFile save.	newIndexFile save.	messageFile rename: rootFilename, '.messages.bak'.	indexFile rename: rootFilename, '.index.bak'.	newMessageFile rename: rootFilename, '.messages'.	newIndexFile rename: rootFilename, '.index'.	indexFile delete.	messageFile delete.	indexFile _ newIndexFile.	messageFile _ newMessageFile.	self cleanUpCategories.	categoriesFile save.	^stats! !!MailDB methodsFor: 'fetch-merge-compact'!copyUndeletedTo: newMsgFile indexFile: newIndexFile	"Copy all the undeleted messages in my current message file into the new message file, recording their locations in the new index file. Answer an array containing with the number of messages and the number of bytes recovered."	"Note: To minimize disk seeks, messages are buffered and written in large batches. You may wish to tune the amount of buffering if you have a particular shortage or abundance of physical memory. bufferLimit is the approximate number of bytes of messages that will be accumulated before writing the buffered messages to disk."	| bufferLimit msgBuffer bufferSize deletedCount deletedBytes |	Smalltalk garbageCollect.	bufferLimit _ Smalltalk bytesLeft // 2.	"use half of the available memory"	msgBuffer _ OrderedCollection new: 1000.	bufferSize _ 0.	deletedCount _ deletedBytes _ 0.	newMsgFile beginAppend.	messageFile messagesDo:		[: deleted : msgID : msgText |		 (deleted)			ifTrue:				[deletedCount _ deletedCount + 1.				 deletedBytes _ deletedBytes + msgText size]			ifFalse:				[msgBuffer addLast: (Array with: msgID with: msgText).				 bufferSize _ bufferSize + msgText size.				 (bufferSize >= bufferLimit) ifTrue:					[self						appendMessages: msgBuffer						messageFile: newMsgFile						indexFile: newIndexFile.					 msgBuffer _ OrderedCollection new: 1000.					 bufferSize _ 0]]].	"flush remaining buffered messages"	self		appendMessages: msgBuffer		messageFile: newMsgFile		indexFile: newIndexFile.	newMsgFile endAppend.	"return statistics"	^Array with: deletedCount with: deletedBytes! !!MailDB methodsFor: 'fetch-merge-compact'!fetchMailFrom: inboxFileName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given mail inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any mail?"	(StandardFileStream isAFileNamed: inboxFileName) ifFalse: [^0].	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo:		[: msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^count! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'jm 8/14/1998 16:47'!fetchNewsFrom: inboxPathName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given news inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any news?"	((FileDirectory on: inboxPathName) includesKey: 'news') ifFalse: [^ 0].	inbox _ RNInboxFile openOn: inboxPathName, ':news'.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox newsMessagesDo:		[: newsgroup : msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: newsgroup.		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^ count! !!MailDB methodsFor: 'fetch-merge-compact'!fileDuplicatesIn: categoryName	"MailDB someInstance fileDuplicatesIn: '.duplicates.'"	self fileAll: self findDuplicates inCategory: categoryName.! !!MailDB methodsFor: 'fetch-merge-compact'!findDuplicates	"MailDB someInstance findDuplicates"	| msgsAtTime m duplicates dupList firstDupText thisDupID thisDupText |	msgsAtTime _ Dictionary new.	(self messagesIn: '.all.') do: [ :msgID |		m _ indexFile at: msgID.		(msgsAtTime includesKey: m time) ifFalse: [			msgsAtTime at: m time put: OrderedCollection new.		].		(msgsAtTime at: m time) add: (Array with: msgID with: m).	].	duplicates _ OrderedCollection new.	msgsAtTime associationsDo: [ :assoc |		dupList _ assoc value asSortedCollection:			[ :m1 :m2 | m1 last location < m2 last location ].		firstDupText _ self getText: dupList first first.		2 to: dupList size do: [ :i |			thisDupID _ (dupList at: i) first.			thisDupText _ self getText: thisDupID.			firstDupText = thisDupText ifTrue: [				duplicates add: thisDupID.			].		].	].	^duplicates asArray! !!MailDB methodsFor: 'fetch-merge-compact'!mergeMessages: msgIDList from: sourceDB	"Merge the given collection of messages from the source database into the receiver. When a message being added has the same message ID as an existing message, check to see if the two message texts are identical. If so, do not store the duplicate message. If the texts are different, make a new ID for the message being added. This operation will also copy the category information from the sourceDB, creating new catetories if necessary."	| msgText newMsgID saveIt msg location entry |	messageFile beginAppend.	msgIDList do:		[: oldMsgID |		 msgText _ sourceDB getText: oldMsgID.		 "resolve ID conflicts"		 (indexFile includesKey: oldMsgID)			ifFalse:	"no ID conflict"				[newMsgID _ oldMsgID.				 saveIt _ true]			ifTrue:	"resolve an ID conflict"				[(msgText = (self getText: oldMsgID))					ifTrue:	"identical text; don't save again"						[newMsgID _ oldMsgID.						 saveIt _ false]					ifFalse:	"different text; save with new ID"						[newMsgID _ self nextUnusedID.						 saveIt _ true]].		 "save the message in the destination DB"		 saveIt ifTrue:			[msg _ MailMessage from: msgText.			 location _ messageFile basicAppend: msg text id: newMsgID.			 entry _ IndexFileEntry						message: msg						location: location 						messageFile: messageFile						msgID: newMsgID.			 indexFile at: newMsgID put: entry].		 "update the categories for the message in the destination DB"		 (sourceDB categoriesThatInclude: oldMsgID) do:			[: categoryName |			 self file: newMsgID inCategory: categoryName]].	messageFile endAppend.! !!MailDB methodsFor: 'fetch-merge-compact'!nextUnusedID	"Answer the next unused message identifier. Message ID's are a monotonically increasing series roughly related to the time that they were requested. We use a block of message ID's based on the starting ID computed here. The last ID used is kept in LastID, to be sure that we don't reuse an already allocated ID."	| id |	"initialize LastID the first time it is used"	(LastID isNil) ifTrue: [LastID _ 0]. 	"message ID's are roughly the number of seconds since the beginning of 1980"	id _ Date today asSeconds + Time now asSeconds -		(Date newDay: 1 year: 1980) asSeconds.	id _ id max: (LastID + 1).	"never go backwards!!"	^id! !!MailDB methodsFor: 'categories'!addCategory: categoryName	"Create a category with the given name if one doesn't already exist."	categoriesFile addCategory: categoryName.! !!MailDB methodsFor: 'categories'!allCategories	"Answer a list of categories sorted in alphabetical order, including the special categories."	^categoriesFile categories asSortedCollection asOrderedCollection! !!MailDB methodsFor: 'categories'!categoriesThatInclude: msgID	"Answer a collection of names for real categories that include the message with the given ID. Pseudo-categories (such as '.unclassified.') are not considered real categories."	^categoriesFile categories select:		[: catName |		 (categoriesFile messagesIn: catName) includes: msgID]! !!MailDB methodsFor: 'categories'!file: msgID inCategory: categoryName	"File the message with the given ID in the given category."	categoriesFile file: msgID inCategory: categoryName.! !!MailDB methodsFor: 'categories'!fileAll: msgIDList inCategory: categoryName	"File all the messages with ID's in the given list in the given category."	msgIDList do:		[: msgID |		 categoriesFile file: msgID inCategory: categoryName].! !!MailDB methodsFor: 'categories'!messagesIn: categoryName	"Answer a collection of message ID's for the messages in the given category, sorted in ascending time order.  If the category does not exist, answer an empty collection. The pseudo-categories '.all.' and '.unclassified.' are computed dynamically, which may take a little time."	| msgList category |	(categoryName = '.unclassified.') ifTrue:		[Cursor execute showWhile:			[msgList _ categoriesFile unclassifiedFrom: indexFile keys].		 ^msgList].	(categoryName = '.all.') ifTrue:		[^indexFile keys].	"otherwise, it is a real category"	category _ categoriesFile messagesIn: categoryName.	^indexFile keys select:		"indexFile keys is sorted"		[: msgID | category includes: msgID]! !!MailDB methodsFor: 'categories'!remove: msgID fromCategory: categoryName	"Remove the message with the given ID from the given category."	categoriesFile remove: msgID fromCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeAll: msgIDList fromCategory: categoryName	"Remove all the messages with ID's in the given list from the given category."	msgIDList do:		[: msgID |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!removeCategory: categoryName	"Remove the category with the given name. This does nothing if the category does not exist or if it is a pseudo-category."	categoriesFile removeCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeFromAllCategories: msgID	"Remove the message with the given ID from all categories. The message will appear in 'unclassified'."	categoriesFile categories do:		[: categoryName |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!renameCategory: oldName to: newName	"Rename the given category. This does nothing if the category does not exist or if it is a special category ('new', '.all.', or '.unclassified.')."	categoriesFile renameCategory: oldName to: newName.! !!MailDB methodsFor: 'messages'!delete: msgID	"Delete the messages with the given ID from the message file. In contrast to simply removing a message from a category, this is permanent!!"	messageFile		deleteMessageAt: (indexFile at: msgID) location		id: msgID.	indexFile remove: msgID.	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!deleteAll: msgIDList	"Delete all the messages with ID's in the given list from the message file. This is permanent!!"	msgIDList do:		[: msgID |		 messageFile			deleteMessageAt: (indexFile at: msgID) location			id: msgID.		 indexFile remove: msgID].	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!getMessage: msgID	"Answer the MailMessage with the given ID."	^MailMessage from: (self getText: msgID)! !!MailDB methodsFor: 'messages'!getTOCentry: msgID	"Answer the table-of-contents entry for the message with the given ID."	^indexFile at: msgID! !!MailDB methodsFor: 'messages'!getTOCstring: msgID	"Answer the table-of-contents string for the message with the given ID."	^(indexFile at: msgID) tocString! !!MailDB methodsFor: 'messages'!getText: msgID	"Answer the text for the message with the given ID."	| entry |	entry _ indexFile at: msgID.	^messageFile		getMessage: msgID		at: entry location		textLength: entry textLength! !!MailDB methodsFor: 'messages'!newText: newText for: msgID	"Replace the text for the message with the given ID."	| oldLocation newLocation newEntry |	oldLocation _ (indexFile at: msgID) location.	newLocation _ messageFile update: newText at: oldLocation id: msgID.	newEntry _ IndexFileEntry		message: (MailMessage from: newText)		location: newLocation		messageFile: messageFile		msgID: msgID.	indexFile at: msgID put: newEntry.! !!MailDB methodsFor: 'composing'!composeText	"Answer the template for a new message."^'From: ', Celeste userName, 'To: cc: ', Celeste ccList, 'cc: ', Celeste userName, 'Subject:'! !!MailDB methodsFor: 'composing'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^self composeText, '---------- Forwarded ----------',	(self getText: msgID), '-------------------------------'! !!MailDB methodsFor: 'composing'!hasUsername: aString	"Answer true if the given string contains the user's name."	^((aString asLowercase)		findString: (Celeste userName) asLowercase		startingAt: 1) ~= 0! !!MailDB methodsFor: 'composing'!replyTextFor: msgID	"Answer the template for a reply to the message with the given ID."	| msg s |	msg _ self getMessage: msgID.	s _ WriteStream on: (String new: 500).	s nextPutAll: 'From: ', Celeste userName; cr.	s nextPutAll: 'To: ', msg from; cr.	(msg to isEmpty) ifFalse: [s nextPutAll: 'cc: ', msg to; cr].	(msg cc isEmpty) ifFalse: [s nextPutAll: 'cc: ', msg cc; cr].	s nextPutAll: 'cc: ', Celeste ccList; cr.	((self hasUsername: msg to) or: [self hasUsername: msg cc]) ifFalse:		[s nextPutAll: 'cc: ', Celeste userName; cr].	((msg subject asLowercase indexOfSubCollection: 're:' startingAt: 1) ~= 0)		ifTrue: [s nextPutAll: 'Subject: ', msg subject]		ifFalse: [s nextPutAll: 'Subject: Re: ', msg subject].	^s contents! !!MailDB methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'a MailDB on ''', rootFilename, ''''.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MailDB class	instanceVariableNames: ''!!MailDB class methodsFor: 'instance creation'!openOn: rootFilename	"Open or create a mail database with the given root filename. If an instance of me exists with the given root filename, return a reference to that instance rather than creating a new one. This allows multiple MailReaders to be open on the same database without synchronization problems."	| alreadyOpenDB |	alreadyOpenDB _ self allInstances		detect:			[: db |			 (db rootFilename notNil) and:			 [db rootFilename = rootFilename]]		ifNone: [nil].	(alreadyOpenDB notNil)		ifTrue: [^alreadyOpenDB]		ifFalse: [^(self new) openOn: rootFilename].! !!MailDB class methodsFor: 'utilities'!readIntegerLineFrom: aStream	"Read a positive integer from the given stream. Answer zero if there are no digits. Consume the stream through the next carriage return."	| digit value |	value _ 0.	[aStream atEnd] whileFalse: 		[digit _ aStream next digitValue.		 ((digit >= 0) & (digit <= 9))			ifTrue: 				[value _ (value * 10) + digit]			ifFalse:				[(digit == Character cr digitValue) ifFalse:					[self skipRestOfLine: aStream].				 ^value]].	^value! !!MailDB class methodsFor: 'utilities'!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	| newStream crValue char |	newStream _ WriteStream on: (String new: 64).	crValue _ Character cr asciiValue.	[aStream atEnd or: [(char _ aStream next) asciiValue == crValue]]		whileFalse: [newStream nextPut: char].	^newStream contents! !!MailDB class methodsFor: 'utilities'!skipRestOfLine: aStream	"Consume characters from the given stream through the next carriage return."	| crValue |	crValue _ Character cr asciiValue.	[aStream atEnd or:	 [aStream next asciiValue == crValue]] whileFalse:		["consume until end of stream or a carriage return"].! !Object subclass: #MailDBFile	instanceVariableNames: 'filename '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MailDBFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am an abstract class that collects some of the operations common to all mail database files.!!MailDBFile methodsFor: 'file operations' stamp: 'ls 7/9/1998 12:34'!delete	"Delete this file."	FileDirectory splitName: filename to: [:dirPath :name |		(FileDirectory on: dirPath) deleteFileNamed: name ifAbsent: []].! !!MailDBFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 7/9/1998 12:35'!rename: newFileName	"Rename this file."	FileDirectory splitName: filename to: [:dirPath :oldFileName |		(FileDirectory on: dirPath) rename: oldFileName toBe: newFileName].	filename _ newFileName.! !!MailDBFile methodsFor: 'file operations' stamp: 'jm 8/14/1998 13:52'!save	"Atomically save a representation of this object to its file. The old file is renamed to '<oldname>.bak' before the new file is written. If the write operation fails, the old file may be restored by renaming it. If it succeeds, the .bak file is deleted."	| f dir shortName |	"create the file if it doesn't already exist"	(StandardFileStream isAFileNamed: filename) ifFalse: [		f _ StandardFileStream new open: filename forWrite: true.		f close].	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory on: (FileDirectory dirPathFor: filename).	dir rename: shortName toBe: shortName, '.bak'.	f _ FileStream fileNamed: filename.	self writeOn: f.	f setToEnd; close.	dir deleteFileNamed: (shortName, '.bak') ifAbsent: [].! !!MailDBFile methodsFor: 'read-write'!readFrom: aStream	"Subclasses must override this method to provide a means of reading themselves into memory."	self subclassResponsibility! !!MailDBFile methodsFor: 'read-write'!writeOn: aStream	"Subclasses must override this method to provide a means of writing themseves out on their files."	self subclassResponsibility! !!MailDBFile methodsFor: 'error reporting'!reportInconsistency	"Report that the index file is not consistent with the messages file."	self error:'The .index file is not consistent with the .messages file. Thismay be fixed by compacting the mail database, whichwill rebuild the index file from scratch.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MailDBFile class	instanceVariableNames: ''!!MailDBFile class methodsFor: 'instance creation'!openOn: fileName	"Answer a new instance of me, backed by the file with the given name."	^(super new) openOn: fileName! !MailDBFile variableSubclass: #CategoriesFile	instanceVariableNames: 'categories '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!CategoriesFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I represent the organization of the mail database into set of message lists called "categories". Each category contains a collection of message ID's. The same message may be cross-filed quite cheaply by storing it's ID in multiple categories.The categories information is kept in a binary file on the disk. It is read into memory in its entirety when the mail database is opened. To make changes persist, the categories information must be saved out to disk. This should be done after fetching new mail and when the mail database is closed. It could also be done periodically by some sort of background process. Note that the categories file, unlike the index file, cannot be re-created from the messages file.!!CategoriesFile methodsFor: 'categories access'!addCategory: categoryName	"Add a new category, if it doesn't already exist."	(self categories includes: categoryName) ifFalse:		[categories at: categoryName put: Set new].! !!CategoriesFile methodsFor: 'categories access'!categories	"Answer a collection of my categories, including the pseudo-categories '.unclassified.' and '.all.'. '.unclassified.' contains the orphaned messages that would otherwise not appear in any category. '.all.' contains all the messages in the database. Since these pseudo-categories are computed on the fly, there may be a noticable delay when one of them is selected."	^(categories keys)		add: '.all.';		add: '.unclassified.';		yourself! !!CategoriesFile methodsFor: 'categories access'!file: messageID inCategory: categoryName	"Add the given message ID to the given category. The target category must be a real category, not a pseudo-category."	(categoryName = '.unclassified.' | categoryName = '.all.') ifTrue: [^self].	(categories includesKey: categoryName) ifFalse:		[categories at: categoryName put: Set new].	(categories at: categoryName) add: messageID.! !!CategoriesFile methodsFor: 'categories access'!isUnclassified: messageID	"Answer true if the given message ID does not appear in any of my real (not pseudo) categories."	categories do:		[: category | (category includes: messageID) ifTrue: [^false]].	^true! !!CategoriesFile methodsFor: 'categories access'!messagesIn: category	"Answer a collection of message ID's for the messages in the given category. The pseudo-categories are dynamically computed and so they cannot be accessed in this manner."	^categories at: category ifAbsent: [#()]! !!CategoriesFile methodsFor: 'categories access'!remove: messageID fromCategory: categoryName	"Remove the given message ID from the given category."	| msgList |	msgList _ categories at: categoryName ifAbsent: [^self].	msgList remove: messageID ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeCategory: categoryName	"Remove the given category, if it exists."	categories removeKey: categoryName ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeMessagesInCategory: categoryName butNotIn: indexFile	"Used to clean the dead wood out of a category."	| oldMsgs newMsgs |	oldMsgs _ categories at: categoryName ifAbsent: [^self].	newMsgs _ oldMsgs copy.	oldMsgs do:		[: msgID |		 (indexFile includesKey: msgID) ifFalse:			[newMsgs remove: msgID]].	categories at: categoryName put: newMsgs.! !!CategoriesFile methodsFor: 'categories access'!renameCategory: oldName to: newName	"Rename the given category."	| oldEntry |	(oldName = 'new' | oldName = '.unclassified.' | oldName = '.all.' |	 (self categories includes: newName)) ifTrue:		[^self].	"can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [Set new].	categories at: newName put: oldEntry.! !!CategoriesFile methodsFor: 'categories access'!unclassifiedFrom: messageIDs	"Answer the subset of the given set of message ID's that do not appear in any category."	^messageIDs select:		[: msgID | self isUnclassified: msgID]! !!CategoriesFile methodsFor: 'read-write' stamp: 'jm 8/18/1998 16:24'!readFrom: aFileStream	"Read the categories from the given FileStream."	| name categorySize messageIDs |	categories _ Dictionary new: 64.	aFileStream binary; position: 0.	[aFileStream atEnd] whileFalse:		[name _ aFileStream ascii; nextString.		 categorySize _ aFileStream binary; nextWord.		 messageIDs _ Set new: categorySize * 4.		 categorySize timesRepeat:			[messageIDs add: aFileStream nextInt32].		 categories at: name put: messageIDs].! !!CategoriesFile methodsFor: 'read-write'!writeOn: aFileStream	"Write the categories to the given FileStream. The categories data is stored in binary (as opposed to a human-readable form) to save space."	aFileStream binary; position: 0.	categories associationsDo:		[: category |		 "(category key) is the category name"		 "(category value) is the set of message ID's in that category"		 aFileStream nextStringPut: (category key).		 aFileStream nextWordPut: (category value) size.		 (category value) do:			[: messageID |			 aFileStream nextInt32Put: messageID]].! !MailDBFile subclass: #IndexFile	instanceVariableNames: 'msgDictionary timeSortedEntries '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!IndexFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I represent an index for the messages in a mail database. I acts like a dictionary that maps unique message ID's to IndexFileEntry objects.The index file is read into memory in its entirety and kept there for the duration of a mail reading session. It should be stored back to disk at the end of the session, or after a major change, such as fetching new mail. If necessary, it can be completely recreated by scanning the messages file.!!IndexFile methodsFor: 'file operations'!openOn: aFileName messageFile: messageFile	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream messageFile: messageFile.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!IndexFile methodsFor: 'dictionary access'!at: msgID	"Answer the IndexFileEntry for the message with the given ID."	^msgDictionary at: msgID ifAbsent: [self reportInconsistency]! !!IndexFile methodsFor: 'dictionary access'!at: msgID ifAbsent: aBlock	"Answer the IndexFileEntry for the message with the given ID. Evaluate the given block if there is no entry for the given ID."	^msgDictionary at: msgID ifAbsent: aBlock! !!IndexFile methodsFor: 'dictionary access'!at: msgID put: anIndexFileEntry	"Associate the given IndexFileEntry with the given message ID."	timeSortedEntries removeAllSuchThat:		[: assoc | assoc key = msgID].	"don't duplicate the entry!!"	msgDictionary at: msgID put: anIndexFileEntry.	timeSortedEntries add: (Association key: msgID value: anIndexFileEntry).! !!IndexFile methodsFor: 'dictionary access'!includesKey: msgID	"Answer true if my message dictionary contains an entry for the message with the given ID."	^msgDictionary includesKey: msgID! !!IndexFile methodsFor: 'dictionary access'!keys	"Answer a collection of message IDs for the messages in this IndexFile, sorted in ascending timestamp order. Because sorting is expensive, the sorted key list is cached."	| keys |	keys _ OrderedCollection new: timeSortedEntries size * 2.	timeSortedEntries do: [: assoc | keys addLast: assoc key].	^keys! !!IndexFile methodsFor: 'dictionary access'!remove: msgID	"Remove the entry with the given ID from my Dictionary."	timeSortedEntries removeAllSuchThat: [: assoc | assoc key = msgID].	msgDictionary removeKey: msgID ifAbsent: [].! !!IndexFile methodsFor: 'read-write'!readFrom: aStream messageFile: messageFile	"Initialize myself from the given text stream. It is assumed that the .index file was written in order of ascending message timestamps, although this method is only less efficient, not incorrect, if this is not the case."	| sorted lastTime msgID entry |	msgDictionary _ Dictionary new: 1000.	timeSortedEntries _ (SortedCollection new: 1000) sortBlock:		[: m1 : m2 | m1 value time <= m2 value time].	sorted _ true.	lastTime _ nil.	[aStream atEnd] whileFalse:		[msgID _ MailDB readIntegerLineFrom: aStream.		 entry _ IndexFileEntry readFrom: aStream messageFile: messageFile msgID: msgID.		 msgDictionary at: msgID put: entry.		 timeSortedEntries addLast: (Association key: msgID value: entry).		 ((sorted & lastTime notNil) and: [lastTime > entry time]) ifTrue:			[sorted _ false].		 lastTime _ entry time].	sorted ifFalse: [timeSortedEntries reSort]. 	"re-sort if necessary"! !!IndexFile methodsFor: 'read-write'!writeOn: aStream	"Write my index entries to the given text stream in human-readable form."	"Note: For efficiency, this is done in order of increasing message timestamps, to save the cost of sorting when we read it back in. It is assumed that timeSortedEntries should contains exactly the same message ID's as msgDictionary."	timeSortedEntries do:		[: assoc |		 (assoc key) printOn: aStream.		"message ID"		 aStream cr.		 (assoc value) writeOn: aStream].	"index entry"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IndexFile class	instanceVariableNames: ''!!IndexFile class methodsFor: 'instance creation'!openOn: fileName messageFile: messageFile	"Answer a new instance of me for the given message file, backed by the file with the given name."	^(super new) openOn: fileName messageFile: messageFile! !MailDBFile subclass: #MailInboxFile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MailInboxFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am a parser for mail inboxes in a form found in the Unix '/var/spool' inboxes. This is also the format used by Eudora 3.0 on the Macintosh (and perhaps by other versions of Eudora as well).!!MailInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for mail inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!MailInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for mail inboxes."	self error: 'Mail inboxes are read only!!'! !!MailInboxFile methodsFor: 'scanning'!delimitersDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText delim |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue: [		aBlock value: (MailDB readStringLineFrom: stream)].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!findPossibleMessageStart: aStream	"Find the next line starting with the string 'From' followed by a space. Leave the input stream positioned at the character following the space."	(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].	[true] whileTrue: [		aStream skipTo: Character cr.		[aStream peek = Character cr] whileTrue: [aStream next].		(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].		aStream atEnd ifTrue: [^false].	].! !!MailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	self scanToNextMessageIn: stream.	MailDB skipRestOfLine: stream.  "skip message delimiter"	msgStart _ stream position.	[self scanToNextMessageIn: stream] whileTrue: [		msgSize _ stream position - msgStart.		stream position: msgStart.		msgText _ stream next: msgSize.		MailDB skipRestOfLine: stream.  "skip message delimiter"		msgStart _ stream position.		aBlock value: msgText].	"process final message"	msgSize _ stream position - msgStart.	msgSize > 0 ifTrue: [		stream position: msgStart.		msgText _ stream next: msgSize.		aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!nextStringIs: aString in: aStream	"If the next characters of the given stream form the given string, then advance the stream position by the size of the string and return true. Otherwise, leave the stream untouched and return false."	| oldPosition |	oldPosition _ aStream position.	1 to: aString size do: [ :i |		aStream next = (aString at: i) ifFalse: [			aStream position: oldPosition.			^false		].	].	aStream position: oldPosition.	^true! !!MailInboxFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message or at the end of the stream."	| msgStart line dayOfWeek year |	[aStream atEnd] whileFalse: [		(self findPossibleMessageStart: aStream) ifFalse: [^false].		msgStart _ aStream position.		aStream next: 5.  "skip 'From '"		"skip address"		[aStream peek isSeparator] whileFalse: [aStream next].		aStream peek = Character space ifTrue: [aStream next].		line _ MailDB readStringLineFrom: aStream.		line size >= 7 ifTrue: [			dayOfWeek _ (line copyFrom: 1 to: 3) asLowercase.			year _ (line copyFrom: line size - 3 to: line size) asNumber.			((#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: dayOfWeek) and:			[(year > 1900) and: [year < 2100]]) ifTrue: [				aStream position: msgStart.				^true  "found a message!!"			].		].	].	^false! !MailInboxFile subclass: #MHMailInboxFile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MHMailInboxFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am a parser for mail files in the format output by the Unix 'mh' program.!!MHMailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream textStart textSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue:			["if possible, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile).			 fileStream _ nil]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue:		["skip the three-line message delimiter"		 3 timesRepeat: [MailDB skipRestOfLine: stream].		 textStart _ stream position.		 self scanToNextMessageIn: stream.		 textSize _ stream position - textStart.		 stream position: textStart.		 msgText _ stream next: textSize.		 aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MHMailInboxFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message delimiter (if there is one) or at the end of the stream."	| msgStart |	[true] whileTrue:		[(aStream skipTo: $:) ifFalse: [^false].	"end of stream"		 msgStart _ aStream position - 1.		 ((MailDB readStringLineFrom: aStream) = ':::::::::::::') ifTrue:			["looking good..."			 MailDB skipRestOfLine: aStream.	"skip message number"			 ((MailDB readStringLineFrom: aStream) = '::::::::::::::') ifTrue:				["found a message!!"				 aStream position: msgStart. ^true]].		 "false alarm, keep scanning"		 aStream position: msgStart + 1].! !Object subclass: #MailMessage	instanceVariableNames: 'time from to cc subject text '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MailMessage commentStamp: 'jm 8/18/1998 16:48' prior: 0!I represent a mail or news message. I parse the message header and keep certain header fields in instance variables for rapid access.!!MailMessage methodsFor: 'initialize-release'!from: aString	"Parse the given string to initialize myself. The given string will become my text."	time _ 0.	from _ to _ cc _ subject _ ''.	text _ self removeTrailingSeparators: aString.	self fieldsFrom: (ReadStream on: text) do:		[: fName : fValue |		 (fName = 'date') ifTrue: [time _ self timeFrom: fValue].		 (fName = 'from') ifTrue: [from _ fValue].		 (fName = 'to') ifTrue: [to isEmpty ifTrue: [to _ fValue] ifFalse: [to _ to, ', ', fValue]].		 (fName = 'cc') ifTrue: [cc isEmpty ifTrue: [cc _ fValue] ifFalse: [cc _ cc, ', ', fValue]].		 (fName = 'subject') ifTrue: [subject _ fValue]].! !!MailMessage methodsFor: 'initialize-release'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^aString copyFrom: 1 to: i]		ifFalse: [^''].! !!MailMessage methodsFor: 'access'!cc	^cc! !!MailMessage methodsFor: 'access'!date	"Answer a date string for this message."	^(Time aTime: (time + (Date newDay: 1 year: 1980) asSeconds)) first		printFormat: #(2 1 3 47 1 2)! !!MailMessage methodsFor: 'access'!from	^from! !!MailMessage methodsFor: 'access'!subject	^subject! !!MailMessage methodsFor: 'access'!text	^text! !!MailMessage methodsFor: 'access'!time	^time! !!MailMessage methodsFor: 'access'!to	^to! !!MailMessage methodsFor: 'parsing'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value."	| savedLine line s fieldName fieldValue |	savedLine _ MailDB readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line _ savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine _ MailDB readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s _ ReadStream on: savedLine.			s skipSeparators; skip: -1.			line _ line, s upToEnd].		self reportField: line to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine to: aBlock].! !!MailMessage methodsFor: 'parsing'!readDateFrom: aStream	"Parse a date from the given stream and answer nil if the date can't be parsed. The date may be in any of the following forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>		(4/5/82)	In addition, the date may be preceded by the day of the week and an optional comma, such as:		Tue, November 14, 1989"	| day month year |	self skipWeekdayName: aStream.	aStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue:		"month name or weekday name"			[month _ WriteStream on: (String new: 10).			 [aStream peek isLetter] whileTrue: [month nextPut: aStream next].			 month _ month contents.			 day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				 (aStream peek isDigit) ifFalse: [^nil].				 day _ Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month _ Date nameOfMonth: day.			 day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	(aStream peek isDigit) ifFalse: [^nil].	year _ Integer readFrom: aStream.	^Date newDay: day month: month year: year! !!MailMessage methodsFor: 'parsing'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field has an empty value part."	| s fieldName fieldValue |	s _ ReadStream on: aString.	fieldName _ (s upTo: $:) asLowercase.	s skipSeparators.	(s atEnd) ifFalse: [		"field is not empty"		fieldValue _ s upToEnd.		aBlock value: fieldName value: fieldValue].! !!MailMessage methodsFor: 'parsing'!skipWeekdayName: aStream	"If the given stream starts with a weekday name or its abbreviation, advance the stream to the first alphaNumeric character following the weekday name."	| position name abbrev |	aStream skipSeparators.	(aStream peek isDigit) ifTrue: [^self].	(aStream peek isLetter) ifTrue:		[position _ aStream position.		 name _ WriteStream on: (String new: 10).		 [aStream peek isLetter] whileTrue: [name nextPut: aStream next].		 abbrev _ (name contents copyFrom: 1 to: (3 min: name position)).		 abbrev _ abbrev asLowercase.		 (#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: abbrev asLowercase)			ifTrue:				["found a weekday; skip to the next alphanumeric character"				 [aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]			ifFalse:				["didn't find a weekday so restore stream position"				 aStream position: position]].! !!MailMessage methodsFor: 'parsing'!timeFrom: aString	"Parse the date and time and answer the result as the number of seconds since the start of 1980. The time is interpreted in the sender's time-zone; it should really be converted to GMT, depending on the timezone of the sender..."	| s t |	s _ ReadStream on: aString.	t _ (self readDateFrom: s) asSeconds.  "date part"	[s atEnd or: [s peek isAlphaNumeric]] whileFalse: [s next].	(s atEnd) ifFalse:		["read time part (interpreted as local, regardless of sender's timezone)"		 t _ t + (Time readFrom: s) asSeconds].	^t - (Date newDay: 1 year: 1980) asSeconds		"time started with 1980..."! !!MailMessage methodsFor: 'printing/formatting'!eudoraOutboxText	"Return this message formatted for inclusion in a Eudora outbox."	| old new |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	MailMessage new fieldsFrom: old do: [ :fName :fValue | "skip header fields" ].	new nextPutAll: 'To: ';		nextPutAll: to; cr.	new nextPutAll: 'From: ';	nextPutAll: from; cr.	new nextPutAll: 'Subject: ';	nextPutAll: subject; cr.	new nextPutAll: 'Cc: ';		nextPutAll: cc; cr.	new nextPutAll: 'Bcc: '; cr.	new nextPutAll: 'X-attachments: '; cr.	new cr.	new nextPutAll: old upToEnd.	^new contents! !!MailMessage methodsFor: 'printing/formatting'!format	"Replace the text of this message with a formatted version."	"NOTE: This operation discards extra header fields."	text _ self formattedText.! !!MailMessage methodsFor: 'printing/formatting' stamp: 'jm 8/18/1998 15:38'!formattedText	"Answer a version of my text with a cleaned up header."	| old new header body |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do:		[: fName : fValue |		 (#('received'			'return-path'			'newsgroups'			'message-id'			'path'			'reply-to'			'in-reply-to'			'sender'			'x-sender'			'fonts'			'x-mailer'			'mime-version'			'x-uidl'			'status'			'content-type'			'content-transfer-encoding'			'errors-to'			'keywords'			'references'			'x-vms-to'			'x-delivery-notice'			'x-reply-of'			'x-newsreader'			'x-icon'			'x-mailing-list'			'x-loop'			'x-priority'			'x-msmail-priority'			'x-mimeole'			'x-organization'			'x-originating-ip'			'x-sun-charset'			'x-url'			'x-nextstep-mailer'			'x-authentication-warning'			'x-lotus-fromdomain'			'x-blackmail'			'x-authenticated-timestamp'			'nntp-posting-host'			'lines'			'return-receipt-to'			'precedence'			'originator'			'distribution'			'content-disposition'			'importance'			'resent-to'			'resent-cc'			'resent-message-id'			'resent-date'			'resent-sender'			'resent-from') includes: fName) ifFalse:				[new nextPut: fName first asUppercase.				 new nextPutAll: (fName copyFrom: 2 to: fName size).				 new nextPutAll: ': '.				 new nextPutAll: fValue; cr]].	new cr.	header _ new contents.	body _ old upToEnd.	header _ self replace: ' -0700' with: '' in: header.	header _ self replace: ' -0800' with: '' in: header.	header _ self replace: ' PST' with: '' in: header.	header _ self replace: ' PDT' with: '' in: header.	^header, body! !!MailMessage methodsFor: 'printing/formatting'!replace: oldString with: newString in: aString	"Replace all occurances of oldString in the given string with newString."	| target where |	target _ aString.	where _ 1.	[(where _ target findString: oldString startingAt: where) = 0] whileFalse:		[target _ target					copyReplaceFrom: where					to: where + oldString size - 1					with: newString].	^target! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MailMessage class	instanceVariableNames: ''!!MailMessage class methodsFor: 'instance creation'!from: aString	"Initialize a new instance from the given string."	^(self new) from: aString! !StringHolderController subclass: #MailTextController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MailTextController commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am a subclass of StringHolderController that supports mail message formatting.!!MailTextController methodsFor: 'formatting'!format	"Format my mail message text."	self deselect.	self controlTerminate.	startBlock _ paragraph characterBlockForIndex: 1.	stopBlock _ paragraph characterBlockForIndex: paragraph text size + 1.	self replaceSelectionWith: model formatedMessage asText.	startBlock _ paragraph characterBlockForIndex: 1.	stopBlock _ startBlock copy.	self controlInitialize.	self select.! !MailDBFile subclass: #MessageFile	instanceVariableNames: 'file '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!MessageFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I represent the messages file of a mail database. This file is treated as (mostly) append-only. All new messages or edited messages are appended to the end of this file.Messages are stored as ASCII text with seperator strings and some additional information between each message. If necessary, this file can be inspected or edited with a text editor; after editing, the index file should be recreated using the "compact" command. (This is necessary because the offsets kept in the index file will probably be different after the edits.)When a message is deleted, its delimiter is changed to mark it as deleted, but it is left in the mail file until the next time "compact" command is executed. Generally, the reduction in disk fragmentation resulting from keeping the messages in a single file more than offsets the temporary space lost by having a few deleted messages hanging around between compactions. Compaction is done into a new copy of the file, followed by a renaming operation. Thus, if compaction fails, the original messages file will not be lost.!!MessageFile methodsFor: 'file operations'!close	"Close the file."	(file notNil) ifTrue:		[file setToEnd; close; release.		 file _ nil].! !!MessageFile methodsFor: 'file operations'!delete	"I must close my file handle before the file can be deleted."	self close.	super delete.! !!MessageFile methodsFor: 'file operations'!ensureFileIsOpen	"Make sure that my file is open. The file is automatically closed on snapshots."	(file isNil) ifTrue:		[file _ FileStream fileNamed: filename.		 file reset].	"make sure the file is really open"! !!MessageFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself for the message file with the given name."	filename _ aFileName.	file _ nil.	self ensureFileIsOpen.! !!MessageFile methodsFor: 'file operations'!rename: newFileName	"I must close my file handle before the file can be renamed."	self close.	super rename: newFileName.! !!MessageFile methodsFor: 'file operations'!save	"Make sure the message file is flushed to disk. This is NOT atomic because MessageFiles can get large and there might not be enough disk space to save them atomically. Besides, it would be very slow."	(file notNil) ifTrue:		[file setToEnd; close; reopen].! !!MessageFile methodsFor: 'message operations'!append: messageText id: messageID	"Append the given message text with the given unique identifier. Answer the new location of the message."	| location |	self beginAppend.	location _ self basicAppend: messageText id: messageID.	self endAppend.	^location! !!MessageFile methodsFor: 'message operations'!assertValidMessageAt: filePosition id: msgID	"Verify that the given filePosition is, indeed, the start of a message (possibly deleted) with the given ID and raise an error if this assertion is false."	| delimiter fileMsgID |	"assume file is open"	file position: filePosition.	delimiter _ file next: 10.	((delimiter = '&&&&&start') or: [delimiter = '&&&&&XXXXX']) ifFalse:		[^self reportInconsistency].	file next. "skip cr"	fileMsgID _ MailDB readIntegerLineFrom: file.	(msgID = fileMsgID) ifFalse:		[^self reportInconsistency].! !!MessageFile methodsFor: 'message operations'!basicAppend: messageText id: messageID	"Append the given message text with the given message ID. Answer the new location of the message."	"WARNING: This operation assumes:		1. the sender positioned the stream to the end of the file (using beginAppend), and		2. the sender will do an endAppend operation after all messages are appended to flush all file buffers to disk."	| location |	file setToEnd.	location _ file position.	file nextPutAll: '&&&&&start'.	"message delimiter"	file cr.	messageID printOn: file.		"message ID"	file cr.	file nextPutAll: messageText.	^location! !!MessageFile methodsFor: 'message operations'!beginAppend	"Set the file to the end prior to performing a sequence of basicAppend operations."	self ensureFileIsOpen.	file setToEnd.! !!MessageFile methodsFor: 'message operations'!deleteMessageAt: filePosition id: msgID	"Mark as deleted the message with the given ID located at the given file position."	self ensureFileIsOpen.	self assertValidMessageAt: filePosition id: msgID.	file position: filePosition.	file nextPutAll: '&&&&&XXXXX'.		"delimiter for deleted messages"	file flush.! !!MessageFile methodsFor: 'message operations'!endAppend	"Complete an append transaction by flushing the file to disk."	self save.! !!MessageFile methodsFor: 'message operations'!getMessage: msgID at: start textLength: textSize	"Retrieve the message with the given ID, location, and text size."	self ensureFileIsOpen.	self assertValidMessageAt: start id: msgID.	^file next: textSize! !!MessageFile methodsFor: 'message operations'!update: messageText at: oldMessagePosition id: msgID	"Atomically update the message having the old location and ID with the given new text (e.g. when the user has edited a message). Answer the new location of the message."	| newLocation |	newLocation _ self append: messageText id: msgID.	self deleteMessageAt: oldMessagePosition id: msgID.	^newLocation! !!MessageFile methodsFor: 'scanning'!messagesDo: aBlock	"Scan the message file and invoke the given block for each message in it. The block arguments are:	deleted			true if this message is marked deleted	msgID			the message ID	msgBody			the message textThis operation is very expensive."	| more deleted msgID textStart textSize msgBody |	self ensureFileIsOpen.	file position: 0.	more _ self scanToNextMessageIn: file.	[more] whileTrue:		[deleted _								"deleted"			(MailDB readStringLineFrom: file) = '&&&&&XXXXX'.		 msgID _ MailDB readIntegerLineFrom: file.	"msgID"		 textStart _ file position.		 more _ self scanToNextMessageIn: file.		 textSize _ file position - textStart.		 file position: textStart.		 msgBody _ file next: textSize.				"msgBody"		 aBlock valueWithArguments:			(Array				with: deleted				with: msgID				with: msgBody)].! !!MessageFile methodsFor: 'scanning'!scanToNextAndSigns: aStream	"Scan the given stream for a pair of and-sign (&) characters and answer true if they are found before the end of the stream is reached. The stream is left positioned after the second and-sign or at the end of the stream."	| ch |	[true] whileTrue:		[ch _ aStream next.		 ((ch == $&) and:		   [aStream next == $&]) ifTrue: [^true].	"found"		 (ch == nil) ifTrue: [^false]].	"end of file"! !!MessageFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message. Answer true if we find a message delimiter, false if we hit the end of the file first. The stream is left positioned at the start of the next message (at the message delimiter) or at the end of the stream."	| delimiter |	[self scanToNextAndSigns: aStream] whileTrue:		[delimiter _ aStream next: 8.		 ((delimiter = '&&&start') or: [delimiter = '&&&XXXXX'])			ifTrue: [aStream skip: -10. ^true]			ifFalse: [(delimiter includes: $&) ifTrue: [aStream skip: -8]]].	^false	"end of file"! !MailDBFile subclass: #ReadNewsInboxFile	instanceVariableNames: 'currentNewsgroup msgBuffer '	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!ReadNewsInboxFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am a parser for news files in the format output by the Unix 'readnews' program.!!ReadNewsInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for news inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!ReadNewsInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for news inboxes."	self error: 'News inboxes are read only!!'! !!ReadNewsInboxFile methodsFor: 'scanning'!allDashes: aString	"Answer true if the given string is not empty and consists entirely of dash characters."	(aString isEmpty) ifTrue: [^false].	aString detect: [: ch | ch ~= $-] ifNone: [^true].	^false	"we must have detected a non-dash"! !!ReadNewsInboxFile methodsFor: 'scanning'!appendLine: aString	"Append the given line to the buffer."	msgBuffer nextPutAll: aString; cr.! !!ReadNewsInboxFile methodsFor: 'scanning'!endOfArticleDo: aBlock	"We've just hit the end of an article. Evaluate the given block on the article we've been accumulating in the buffer (if any) and reset the buffer for the next article."	| msgText end |	"get text and remove trailing separators (blanks, cr's, etc)"	msgText _ msgBuffer contents.	end _ msgText size.	[(end > 0) and: [(msgText at: end) isSeparator]] whileTrue: [end _ end - 1].	(end > 1) ifTrue:		[aBlock value: currentNewsgroup value: (msgText copyFrom: 1 to: end)].	msgBuffer reset.	"reset the buffer for the next message"! !!ReadNewsInboxFile methodsFor: 'scanning'!newsMessagesDo: aBlock	"Invoke the given block for each message in the news inbox file. The block arguments are the newsgroup name and the text of a new message."	| fileStream stream |	fileStream _ FileStream fileNamed: filename.	(fileStream size < 50000)		ifTrue:			["for small inboxes, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile)]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	self parse: stream do: aBlock.	fileStream close.! !!ReadNewsInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by two kinds of delimiters. The first kind indicates the start of a new newsgroup and includes the newsgroup name. The second kind indicates the start of a new article within a newsgroup."	| done line nextLine |	currentNewsgroup _ 'unknown newsgroup'.	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 (self allDashes: line) ifTrue:	"leading line of dashes"			["could be a newsgroup header"			 nextLine _ MailDB readStringLineFrom: aStream.			 ((nextLine size >= 10) and:			  [(nextLine copyFrom: 1 to: 10) = 'Newsgroup '])				ifTrue:					["yep, it is a newsgroup header"					 self endOfArticleDo: aBlock.					 self setNewsGroup: nextLine.					 MailDB skipRestOfLine: aStream.	"skip trailing line of dashes"					 MailDB skipRestOfLine: aStream.	"skip blank line"					 MailDB skipRestOfLine: aStream.	"skip next article delimiter"					 line _ MailDB readStringLineFrom: aStream]				ifFalse:					["nope, it's not a newsgroup header"					 self appendLine: line.					 line _ nextLine]].		 (self startOfArticle: line) ifTrue:			[self endOfArticleDo: aBlock.			 line _ MailDB readStringLineFrom: aStream].		 self appendLine: line].	"normal line: append it to the message buffer"! !!ReadNewsInboxFile methodsFor: 'scanning'!setNewsGroup: aLine	"Set the current newsgroup name from the given line of text, which is of the form:		Newsgroup comp.lang.smalltalk"	(aLine size > 11)		ifTrue: [currentNewsgroup _ aLine copyFrom: 11 to: aLine size]		ifFalse: [currentNewsgroup _ 'unknown newsgroup'].! !!ReadNewsInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer true if the given string is the start of a new news article. That is, does it start with the string 'Article ' and end with a period?"	^((aString size >= 8) and:	   [((aString copyFrom: 1 to: 8) = 'Article ') & (aString last = $.)])! !ReadNewsInboxFile subclass: #RNInboxFile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NetTools-Mail Reader'!!RNInboxFile commentStamp: 'jm 8/18/1998 16:48' prior: 0!I am a parser for news files in the format output by the Unix 'rn' program.!!RNInboxFile methodsFor: 'scanning'!nextStringOf: aStream equals: aString	aString do:		[: c | (c == (aStream next) ) ifFalse: [^false]].	^true! !!RNInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by delimiters that includes the newsgroup name. Ignore text before the first article delimiter."	| done line groupName |	currentNewsgroup _ nil.  "have not found start of article"	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 groupName _ self startOfArticle: line.		 (groupName notNil) ifTrue:			[self endOfArticleDo: aBlock.			 currentNewsgroup _ groupName.			 line _ MailDB readStringLineFrom: aStream].		 (currentNewsgroup notNil) ifTrue: [self appendLine: line]].! !!RNInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer the newsgroup name if the given string is the start of a news article, for example:		Article 2958 of comp.lang.smalltalk:	Otherwise, answer nil."	| s name |	s _ ReadStream on: aString.	(self nextStringOf: s equals: 'Article ') ifFalse: [^nil].	[s next isDigit] whileTrue.	"consumes digits plus the following space"	(self nextStringOf: s equals: 'of ') ifFalse: [^nil].	name _ s through: $:.	((name size > 1) & (s atEnd)) ifFalse: [^nil].	^name copyFrom: 1 to: (name size - 1)! !