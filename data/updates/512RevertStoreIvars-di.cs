'From Squeak 2.3 beta of Nov 25, 1998 on 28 December 1998 at 3:31:54 pm'!"Change Set:		RevertStoreIvarsDate:			26 December 1998Author:			Dan IngallsRemoves all uses of the store-instvar primitive (#255), since it never helped much, and made for a backward incompatibility.Properly decompiles methods whose source trailer is #(251 0 0 0) as well as those with #(0 0 0 0).  This is necessary for reverting some store ivar methods."!!CompiledMethod methodsFor: 'testing' stamp: 'di 12/26/1998 21:31'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'printing' stamp: 'di 12/26/1998 21:30'!symbolic	"Answer a String that contains a list of all the byte codes in a method 	with a short description of each." 	| aStream |	self isQuick ifTrue: 		[self isReturnSpecial ifTrue:			[^ 'Quick return ' , (#('self' 'true' 'false' 'nil' '-1' '0' '1' '2')									at: self primitive - 255)].		^ 'Quick return field ' , self returnField printString , ' (0-based)'].	aStream _ WriteStream on: (String new: 1000).	self printPrimitiveOn: aStream.	(InstructionPrinter on: self) printInstructionsOn: aStream.	^aStream contents! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 12/26/1998 21:30'!writesField: field 	"Answer whether the receiver stores into the instance variable indexed 	by the argument."	self isQuick ifTrue: [^ false].	field <= 8 ifTrue:		[^ (self scanFor: 96 + field - 1) or: [self scanLongStore: field - 1]].	field <= 64 ifTrue:		[^ self scanLongStore: field - 1].	^ self scanVeryLongStore: 160 offset: field - 1! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 12/26/1998 22:34'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte |	flagByte _ self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	(source _ self getSourceFromFile) == nil ifFalse: [^ source].	"Something really wrong -- decompile blind (no temps)"	^ (class decompilerClass new decompile: selector in: class method: self)			decompileString! !!ContextPart methodsFor: 'private'!tryPrimitiveFor: method receiver: receiver args: arguments 	"Simulate a primitive method, method for the receiver and arguments given	as arguments to this message.  Answer resuming the context if successful, else	answer the symbol, #simulatorFail."	| flag primIndex |	(primIndex _ method primitive) = 0 ifTrue: [^#simulatorFail].	^ self doPrimitive: primIndex receiver: receiver args: arguments! !!Decompiler methodsFor: 'private' stamp: 'di 12/26/1998 21:29'!quickMethod	| |	method isReturnSpecial		ifTrue: [^ constructor codeBlock:				(Array with: (constTable at: method primitive - 255)) returns: true].	method isReturnField		ifTrue: [^ constructor codeBlock:				(Array with: (constructor codeInst: method returnField)) returns: true].	self error: 'improper short method'! !!Interpreter methodsFor: 'quick primitives' stamp: 'di 12/28/1998 09:28'!primitiveInstVarsPutFromStack	"Note:  this primitive has been decommissioned.  It is only here for short-term compatibility with an internal 2.3beta-d image that used this.  It did not save much time and it complicated several things.  Plus Jitter will do it right anyway."	| rcvr offsetBits |	rcvr _ self stackValue: argumentCount.	"Mark dirty so stores below can be unchecked"	(rcvr < youngStart) ifTrue: [ self beRootIfOld: rcvr ].	0 to: argumentCount-1 do:		[:i | (i bitAnd: 3) = 0 ifTrue:			[offsetBits _ self positive32BitValueOf: (self literal: i//4 ofMethod: newMethod)].		self storePointerUnchecked: (offsetBits bitAnd: 16rFF) ofObject: rcvr						withValue: (self stackValue: i).		offsetBits _ offsetBits >> 8].	self pop: argumentCount! !!MethodNode methodsFor: 'code generation' stamp: 'di 12/26/1998 21:35'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs |	self generateIfQuick: 		[:method | 		1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].		method cacheTempNames: self tempNames.		^method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	encoder maxTemp > 31		ifTrue: [^self error: 'Too many temporary variables'].		literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].	method cacheTempNames: self tempNames.	^ method! !CompiledMethod removeSelector: #storeOffsets!CompiledMethod removeSelector: #isQuickStore!CompiledMethod class removeSelector: #installQuickStores!CompiledMethod class removeSelector: #toStoreInstVars:!"Postscript:Revert all store-ivar methods to old style activating method."	Smalltalk allBehaviorsDo:	[:c | c selectors do:		[:s | (c compiledMethodAt: s) primitive = 255 ifTrue:			[c recompile: s from: c]]].!