'From Squeak2.8alpha of 26 March 2000 [latest update: #2299] on 10 June 2000 at 6:57:49 pm'!"Change Set:		LargeIntegersPlugin-updateDate:			10 June 2000Author:			Stephan RudlofVersion:			1.1- >>primGetModuleName for checking the version of the plugin -> 'v1.1';- >>primDigitBitShiftMagnitude and >>primAnyBitFrom:to: for supporting - not installing!! - unification of shift semantics of negative Integers; look for Fix-negativeRightShift-sr changeset for a description and installing this functionality;v1.0 (not named in the previous update)- speeds up digitDiv:neg: at about 20%.Precondition: 2163LargeIntegersPluginIf you don't know how to compile a plugin, this changeset is probably of no interest for you.Translation-------------LargeIntegersPlugin translateDoInlining: trueEvaluations-------------Try	LargeIntegersTest getModuleName.If it is nil, you probably have the older LargeInteger module or none at all; now you should see the version number 'v1.1'.And	| divident divisor |	divident _ 1 << 1000. divisor _ 7.	[10000 timesRepeat: [divident digitDiv: divisor neg: false]] timeToRunwith the 2163LargeIntegersPlugin (store it!!) and the current variant of the module.Implementation notes:In >>cCoreDigitDivDiv:len:rem:len:quo:len: the 'nibble' arithmetic is removed."!TestInterpreterPlugin subclass: #LargeIntegersPlugin	instanceVariableNames: 'andOpIndex orOpIndex xorOpIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!LargeIntegersPlugin commentStamp: 'sr 6/10/2000 18:42' prior: 0!LargeIntegersPlugin provides functions for speeding up LargeInteger arithmetics.Inst vars:	andOpIndex			C constant	orOpIndex			C constant	xorOpIndex 			C constantUsed like an enum, in ST one would use symbols instead.Class vars:	noneEvaluations-------------Try	LargeIntegersTest getModuleName.If it is nil, you probably have an older LargeInteger module or none at all; it works for version number 'v1.1' or higher.History--------v1.1- >>primGetModuleName for checking the version of the plugin;- >>primDigitBitShiftMagnitude and >>primAnyBitFrom:to: for supporting - not installing!! - unification of shift semantics of negative Integers;v1.0- speeds up digitDiv:neg: at about 20%.	In >>cCoreDigitDivDiv:len:rem:len:quo:len: the 'nibble' arithmetic is removed.!Object subclass: #LargeIntegersTest	instanceVariableNames: 'oc1 oc2 ocShift ocShift2 stream '	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!LargeIntegersTest commentStamp: 'sr 6/10/2000 18:43' prior: 0!Some tests for LargeIntegersPlugin functions and their binding to Integer methods.Evaluate...without module:	LargeIntegersTest doItInFile: '/tmp/withoutModule.txt' withModule: false.with module:	LargeIntegersTest doItInFile: '/tmp/withModule.txt' withModule: true..After these computations both files have to be the same contents!!Speed:	[LargeIntegersTest bigFactorial: 3 depth: 3] timeToRunor	[1000 factorial] timeToRun!!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 6/9/2000 10:25'!primAnyBitFrom: from to: to 	| integer large |	self debugCode: [self msg: 'primAnyBitFrom: from to: to'].	integer _ self				primitive: 'primAnyBitFromTo'				parameters: #(#SmallInteger #SmallInteger )				receiver: #Integer.	(interpreterProxy isIntegerObject: integer)		ifTrue: ["convert it to a not normalized LargeInteger"			large _ self createLargeFromSmallInteger: integer]		ifFalse: [large _ integer].	^ (self		anyBitOfBytes: large		from: from		to: to)		asOop: Boolean! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 6/9/2000 10:49'!primDigitBitShiftMagnitude: shiftCount 	| rShift aLarge anInteger |	self debugCode: [self msg: 'primDigitBitShiftMagnitude: shiftCount'].	anInteger _ self				primitive: 'primDigitBitShiftMagnitude'				parameters: #(#SmallInteger )				receiver: #Integer.	(interpreterProxy isIntegerObject: anInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			aLarge _ self createLargeFromSmallInteger: anInteger]		ifFalse: [aLarge _ anInteger].	shiftCount >= 0		ifTrue: [^ self bytes: aLarge Lshift: shiftCount]		ifFalse: 			[rShift _ 0 - shiftCount.			^ self normalize: (self					bytes: aLarge					Rshift: (rShift bitAnd: 7)					bytes: (rShift bitShift: -3)					lookfirst: (self byteSizeOfBytes: aLarge))]! !!LargeIntegersPlugin methodsFor: 'control & support primitives' stamp: 'sr 6/9/2000 18:05'!primGetModuleName	"If calling this primitive fails, then C module does not exist."	| strLen strOop strPtr |	self var: #cString declareC: 'char *cString'.	self var: #strPtr declareC: 'char *strPtr'.	self debugCode: [self msg: 'primGetModuleName'].	self		primitive: 'primGetModuleName'		parameters: #()		receiver: #Oop.	strLen _ self strlen: self getModuleName.	strOop _ interpreterProxy instantiateClass: interpreterProxy classString indexableSize: strLen.	strPtr _ interpreterProxy firstIndexableField: strOop.	0 to: strLen - 1 do: [:i | strPtr at: i put: (self getModuleName at: i)].	^ strOop! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 6/9/2000 04:02'!normalize: aLargeInteger 	"Check for leading zeroes and return shortened copy if so."	self debugCode: [self msg: 'normalize: aLargeInteger'].	(interpreterProxy fetchClassOf: aLargeInteger)		= interpreterProxy classLargePositiveInteger		ifTrue: [^ self normalizePositive: aLargeInteger]		ifFalse: [^ self normalizeNegative: aLargeInteger]! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 6/9/2000 03:11'!anyBitOfBytes: aBytesOop from: start to: stopArg 	"Argument has to be aBytesOop!!"	"Tests for any magnitude bits in the interval from start to stopArg."	| magnitude rightShift leftShift stop firstByteIx lastByteIx |	self debugCode: [self msg: 'anyBitOfBytes: aBytesOop from: start to: stopArg'].	start < 1 | (stopArg < 1) ifTrue: [^ interpreterProxy primitiveFail].	magnitude _ aBytesOop.	stop _ stopArg min: (self highBitOfBytes: magnitude).	start > stop ifTrue: [^ false].	firstByteIx _ start - 1 // 8 + 1.	lastByteIx _ stop - 1 // 8 + 1.	rightShift _ 0 - (start - 1 \\ 8).	leftShift _ 7 - (stop - 1 \\ 8).	firstByteIx = lastByteIx		ifTrue: 			[| digit mask | 			mask _ (255 bitShift: 0 - rightShift)						bitAnd: (255 bitShift: 0 - leftShift).			digit _ self digitOfBytes: magnitude at: firstByteIx.			^ (digit bitAnd: mask)				~= 0].	((self digitOfBytes: magnitude at: firstByteIx)		bitShift: rightShift)		~= 0 ifTrue: [^ true].	firstByteIx + 1 to: lastByteIx - 1 do: [:ix | (self digitOfBytes: magnitude at: ix)			~= 0 ifTrue: [^ true]].	((self digitOfBytes: magnitude at: lastByteIx)		bitShift: leftShift)		~= 0 ifTrue: [^ true].	^ false! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 6/9/2000 00:24'!highBitOfBytes: aBytesOop 	^ self cBytesHighBit: (interpreterProxy firstIndexableField: aBytesOop)		len: (self byteSizeOfBytes: aBytesOop)! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 6/9/2000 00:31'!negative: aLarge 	^ (interpreterProxy fetchClassOf: aLarge)		= interpreterProxy classLargeNegativeInteger! !!LargeIntegersPlugin methodsFor: 'debugging' stamp: 'sr 6/9/2000 03:39'!debugCode: aBlock! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 6/1/2000 08:03'!cCoreDigitDivDiv: pDiv len: divLen rem: pRem len: remLen quo: pQuo len: quoLen 	| dl ql dh dnh j t hi lo r3 l a cond q r1r2 mul |	self var: #pDiv declareC: 'unsigned char * pDiv'.	self var: #pRem declareC: 'unsigned char * pRem'.	self var: #pQuo declareC: 'unsigned char * pQuo'.	dl _ divLen - 1.	"Last actual byte of data (ST ix)"	ql _ quoLen.	dh _ pDiv at: dl - 1.	dl = 1		ifTrue: [dnh _ 0]		ifFalse: [dnh _ pDiv at: dl - 2].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading two bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		"Nibbles are kicked off!! We use full 16 bits now, because we are in  		the year 2000 ;-) [sr]"		j _ remLen + 1 - k.		"r1 _ rem digitAt: j."		(pRem at: j - 1)			= dh			ifTrue: [q _ 255]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.                				Note that r1,r2 are bytes, not nibbles.                				Be careful not to generate intermediate results exceeding 13  				            bits."				"r2 _ (rem digitAt: j - 2)."				r1r2 _ ((pRem at: j - 1)							bitShift: 8)							+ (pRem at: j - 2).				t _ r1r2 \\ dh.				q _ r1r2 // dh.				"Next compute (hi,lo) _ q*dnh"				mul _ q * dnh.				hi _ mul bitShift: -8.				lo _ mul bitAnd: 255.				"Correct overestimate of q.                				Max of 2 iterations through loop -- see Knuth vol. 2"				j < 3					ifTrue: [r3 _ 0]					ifFalse: [r3 _ pRem at: j - 3].								[(t < hi					or: [t = hi and: [r3 < lo]])					ifTrue: 						["i.e. (t,r3) < (hi,lo)"						q _ q - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						cond _ hi >= dh]					ifFalse: [cond _ false].				cond]					whileTrue: [hi _ hi - dh]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: divLen do: 			[:i | 			hi _ (pDiv at: i - 1)						* (q bitShift: -8).			lo _ a + (pRem at: l - 1) - ((pDiv at: i - 1)							* (q bitAnd: 255)).			"pRem at: l - 1 put: lo - (lo // 256 * 256)."			"sign-tolerant form of (lo bitAnd: 255) -> obsolete..."			pRem at: l - 1 put: (lo bitAnd: 255).			"... is sign-tolerant!! [sr]"			a _ lo // 256 - hi.			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				q _ q - 1.				l _ j - dl.				a _ 0.				1 to: divLen do: 					[:i | 					a _ (a bitShift: -8)								+ (pRem at: l - 1) + (pDiv at: i - 1).					pRem at: l - 1 put: (a bitAnd: 255).					l _ l + 1]].		pQuo at: quoLen - k put: q]! !!LargeIntegersPlugin methodsFor: 'obsolete' stamp: 'sr 4/8/2000 02:08'!primDigitBitShift: shiftCount 	| rShift aLarge anInteger |	self debugCode: [self msg: 'primDigitBitShift: shiftCount'].	anInteger _ self				primitive: 'primDigitBitShift'				parameters: #(SmallInteger )				receiver: #Integer.	(interpreterProxy isIntegerObject: anInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			aLarge _ self createLargeFromSmallInteger: anInteger]		ifFalse: [aLarge _ anInteger].	shiftCount >= 0		ifTrue: [^ self bytes: aLarge Lshift: shiftCount]		ifFalse: 			[rShift _ 0 - shiftCount.			^ self normalize: (self					bytes: aLarge					Rshift: (rShift bitAnd: 7)					bytes: (rShift bitShift: -3)					lookfirst: (self byteSizeOfBytes: aLarge))]! !!LargeIntegersTest methodsFor: 'as yet unclassified' stamp: 'sr 6/9/2000 09:00'!createTestData	| tmpPos1 tmpPos2 tmpNeg1 tmpNeg2 tmp tmp2 |	tmpPos1 _ OrderedCollection new.	tmpPos2 _ OrderedCollection new.	tmpPos1 add: 0.	tmpPos2 add: 0.	tmpPos1 add: 1.	tmpPos2 add: 1.	tmpPos1 add: SmallInteger maxVal + 1 * 1000.	tmpPos2 add: SmallInteger maxVal.	tmpPos1 add: SmallInteger maxVal.	tmpPos2 add: 77.	tmpPos1 add: (2 raisedTo: 7).	tmpPos2 add: (2 raisedTo: 7).	tmpPos1 add: (2 raisedTo: 31).	tmpPos2 add: (2 raisedTo: 31).	tmpPos1 add: (2 raisedTo: 7).	tmpPos2 add: (2 raisedTo: 31).	tmpPos1 add: (2 raisedTo: 31).	tmpPos2 add: (2 raisedTo: 7).	tmpPos1 add: (2 raisedTo: 100).	tmpPos2 add: (2 raisedTo: 100)			- 1.	tmpPos1 add: (2 raisedTo: 1000).	tmpPos2 add: (2 raisedTo: 1000)			- 1.	tmpPos1 add: 65535.	tmpPos2 add: 3.	tmpPos1 add: 3.	tmpPos2 add: 65535.	tmpNeg1 _ tmpPos1 collect: [:e | e negated].	tmpNeg2 _ tmpPos2 collect: [:e | e negated].	oc1 _ tmpPos1 , tmpPos1 , tmpNeg1 , tmpNeg1.	oc2 _ tmpPos2 , tmpNeg2 , tmpNeg2 , tmpPos2.	ocShift _ (tmpPos1 collect: [:e | e])				, (tmpPos2 collect: [:e | e]) , (tmpPos1 collect: [:e | e + (2 raisedTo: 32)]) , (tmpPos2 collect: [:e | e + (2 raisedTo: 32)]).	ocShift2 _ OrderedCollection new.	0 to: ocShift size - 1 do: [:ix | ocShift2 add: ix].	ocShift _ ocShift , ocShift.	ocShift2 addAll: (ocShift2 collect: [:e | e negated]).	tmp _ OrderedCollection new. tmp2 _ OrderedCollection new.	ocShift do: [:e | tmp add: e. tmp add: e+1.].	ocShift2 do: [:e | tmp2 add: e. tmp2 add: e.].	ocShift _ tmp.	ocShift2 _ tmp2.	ocShift _ (ocShift collect: [:e | e negated]), ocShift, ocShift, (ocShift collect: [:e | e negated]).	ocShift2 _ (ocShift2 collect: [:e | e negated]), (ocShift2 collect: [:e | e negated]), ocShift2 , ocShift2.! !!LargeIntegersTest class methodsFor: 'user interface' stamp: 'sr 6/9/2000 18:17'!getModuleName	"self getModuleName"	<primitive: 'primGetModuleName' module: 'LargeIntegers'>	^ nil! !!LargePositiveInteger class methodsFor: 'testing' stamp: 'sr 6/10/2000 18:24'!testTwoComplementRightShift	"self testTwoComplementRightShift"	| large small |	small _ 2 << 16.	large _ 2 << 32.	"2-complement test"	(small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1)		== ((large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1))		ifFalse: [^ self inform: 'ERROR: Two-complement shifts of negative Integers are NOT consistent!!'].	(small bitShift: -1) ~= (small + 1 bitShift: -1)		== ((large bitShift: -1) ~= (large + 1 bitShift: -1))		ifFalse: [^ self inform: 'ERROR: Two-complement shifts of negative Integers are NOT consistent!!'].	^ self inform: 'OK: Two-complement shifts of negative Integers are consistent!!'.! !!TestInterpreterPlugin class methodsFor: 'translation' stamp: 'sr 6/9/2000 03:04'!translate: fileName doInlining: inlineFlag debug: debugFlag 	^ self translate: fileName doInlining: inlineFlag locally: false debug: debugFlag ! !!TestInterpreterPlugin class methodsFor: 'translation' stamp: 'sr 4/8/2000 01:14'!translateDoInlining: inlineFlag debug: debugFlag 	^ self		translate: self moduleName , '.c'		doInlining: inlineFlag		debug: debugFlag! !!TestInterpreterPlugin class methodsFor: 'as yet unclassified' stamp: 'sr 6/9/2000 03:03'!translate: fileName doInlining: inlineFlag locally: localFlag debug: debugFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass fullName fd |	fullName _ self baseDirectoryName.	fd _ FileDirectory on: fullName.	localFlag ifFalse:[		(fd directoryExists: self moduleName) 			ifFalse:[fd createDirectory: self moduleName].		fd _ fd on: (fd fullNameFor: self moduleName)].	fullName _ fd fullNameFor: fileName.	self initialize.	self headerFile ifNotNil:[		(CrLfFileStream newFileNamed: (fd fullNameFor: self moduleName,'.h'))			nextPutAll: self headerFile;			close].	cg _ self codeGeneratorClass new initialize.	cg generateDebugCode: debugFlag.	localFlag ifTrue:[cg pluginPrefix: self moduleName].	"Add an extra declaration for module name"	cg declareModuleName: self moduleNameAndVersion local: localFlag.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fullName doInlining: inlineFlag.	^cg! !!LargeIntegersPlugin class methodsFor: 'translation' stamp: 'sr 6/9/2000 15:47'!moduleNameAndVersion	"Answer the receiver's module name and version info that is used for the plugin's C code. The default is to append the code generation date, but any useful text is ok (keep it short)"	^ self moduleName, Character space asString, self version, Character space asString, Date today asString! !!LargeIntegersPlugin class methodsFor: 'translation' stamp: 'sr 6/9/2000 18:28'!version	"Answer the receiver's version info as String."	^ 'v1.1'! !