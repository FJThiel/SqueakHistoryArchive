'From Squeak2.8alpha of 12 January 2000 [latest update: #2002] on 21 April 2000 at 7:54:39 am'!"Change Set:		BigSourcesDate:			17 April 2000Author:			Dan IngallsA slightly ugly hack that doubles the capacity of both the sources and changes files to 32MB, at the expense of limiting the number of changes files to two.Includes a repeating warning message as you approach the 32MB limit of either of these files."!!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 4/17/2000 21:23'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile position: oldPos.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.	"The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos _ outStream position.			self checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr.! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/21/2000 07:54'!checkOKToAdd: size at: filePosition	"Issue several warnings as the end of the changes file approaches its limit,	and finally halt with an error when the end is reached."	| fileSizeLimit margin |	fileSizeLimit _ 16r2000000.	3 to: 1 by: -1 do:		[:i | margin _ i*100000.		(filePosition + size + margin) > fileSizeLimit			ifTrue: [(filePosition + margin) > fileSizeLimit ifFalse:						[self notify: 'WARNING: your changes file is within' , margin printString , ' characters of its size limit.You should take action soon to reduce its size.You may proceed.']]			ifFalse: [^ self]].	(filePosition + size > fileSizeLimit) ifFalse: [^ self].	self error: 'You have reached the size limit of the changes file.You must take action now to reduce it.Close this error.  Do not attempt to proceed.'! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/17/2000 18:06'!fileIndex	"Answer the index of the sources file on which this method is stored, as follows:		1:	.sources file		2:	.changes file		3 and 4 are equivalent to 1 and 2 for files longer than 16M"	| fileIndex |	self last < 252 ifTrue: [^ 0  "no source"].	fileIndex _ self last - 251.	fileIndex <= 2		ifTrue: [^ fileIndex]		ifFalse: [^ fileIndex - 2]! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/17/2000 18:08'!filePosition	"Answer the file position of this method's source code."	| pos fileIndex |	self last < 252 ifTrue: [^ 0  "no source"].	pos _ 0.	self size - 1 to: self size - 3 by: -1 do: [:i | pos _ pos * 256 + (self at: i)].	fileIndex _ self last - 251.	fileIndex <= 2		ifTrue: [^ pos]		ifFalse: [^ pos + 16r1000000]! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/21/2000 07:53'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString  |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	Smalltalk assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString _ RemoteString newString: sourceStr						onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '; flush.	self checkOKToAdd: sourceStr size at: remoteString position.	self setSourcePosition: remoteString position inFile: fileIndex! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/17/2000 17:58'!setSourcePosition: position inFile: fileIndex 	| posLoBits indexAndHiBit |	"Store the location of the source code for the receiver in the receiver. The 	location consists of which source file (*.sources or *.changes) and the 	position in that file.  Properly replicate a null source pointer as well."	"In order to compatibly encode filePositions > 16M in version 2.8ff, we effectively add two to the file index.  This will be cleaned up when we rewrite all sources for v3.0."	position < 16r1000000		ifTrue: [posLoBits _ position.				indexAndHiBit _ fileIndex]		ifFalse: [posLoBits _ position - 16r1000000.				indexAndHiBit _ fileIndex + 2].	(indexAndHiBit > 4 or: [posLoBits >= 16r1000000])		ifTrue: [^ self error: 'invalid source code pointer'].	self at: self size put: 		((indexAndHiBit = 0 and: [posLoBits = 0])			ifTrue:[0  "null source pointer"]			ifFalse: [251 + indexAndHiBit]).	1 to: 3 do: 		[:i | self at: self size - i				put: ((posLoBits bitShift: (i-3)*8) bitAnd: 16rFF)].! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/17/2000 17:57'!sourcePointer	"In order to compatibly encode filePositions > 16M in version 2.8ff, we effectively add two to the file index.  This will be cleaned up when we rewrite all sources for v3.0."	| fp |	fp _ self filePosition.	fp >= 16r1000000		ifTrue: [^ ((self fileIndex+2) * 16r1000000) + (fp-16r1000000)]		ifFalse: [^ (self fileIndex * 16r1000000) + fp]" When we condense sources for v3.0, this can be simplified to...	^ (self fileIndex * 16r2000000) + self filePosition"! !