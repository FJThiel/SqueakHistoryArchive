'From Squeak 2.4c of May 10, 1999 on 19 July 1999 at 7:29:27 pm'!"Change Set:		ClassBuilder-arDate:			9 July 1999Author:			Your NameA complete new class for creating or modifying classes. Also does a number of things like:* Fixing the meta class structure for subclasses of nil (e.g., ObjectOut class was a subclass of Object class and not a subclass of Class as it should be)* Changing the instVar Class>>subclasses to use an Array instead of a Set (for compactness; but mainly for allowing #become: on the classes ;)* Of course, using #become: to fix up references to the classes getting recompiled (but very, very carefully ;-)* Changing Encoder>>bindTemp: to only print a warning when non-interactive (very annoying otherwise)* Adding the method #keysAndValuesDo: to the appropriate subclasses of Collection (Dictionary and SequenceableCollection).* Adding a morphic-style progress indication when recompiling classes (which may be turned off such as for the end-user system)"!Object subclass: #ClassBuilder	instanceVariableNames: 'environ classMap progress maxClassIndex currentClassIndex '	classVariableNames: 'QuietMode '	poolDictionaries: ''	category: 'Kernel-Classes'!!Object methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior.	Note: Do not override in any class except behavior."	^false! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 00:25'!obsolete	"Invalidate and recycle local messages.	Note: Do not remove the method dictionary here.	It is better to keep obsolete instances alive."! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 16:39'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ aClass.	format _ fmt.	methodDict _ mDict.! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/11/1999 05:17'!environment	"Return the environment in which the receiver is visible"	^Smalltalk! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/12/1999 11:10'!name	"Answer a String that is the name of the receiver."	^'a sublcass of ', superclass name! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/13/1999 22:00'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self instSpec = CompiledMethod instSpec ifTrue:[^#compiledMethod]. "Very special!!"	self isBytes ifTrue:[^#bytes].	(self isWords and:[self isPointers not]) ifTrue:[^#words].	self isWeak ifTrue:[^#weak].	self isVariable ifTrue:[^#variable].	^#normal.! !!Behavior methodsFor: 'testing' stamp: 'ar 7/15/1999 14:03'!autoMutateInstances	"Return true if the receiver should automatically mutate its instances to a new class layout on recompilation."	^true! !!Behavior methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior"	^true! !!Behavior methodsFor: 'testing' stamp: 'ar 7/14/1999 02:38'!isObsolete	"Return true if the receiver is obsolete."	^self instanceCount = 0! !!Behavior methodsFor: 'testing' stamp: 'ar 7/11/1999 05:36'!shouldNotBeRedefined	"Return true if the receiver should not be redefined.	The assumption is that compact classes,	classes in Smalltalk specialObjects and 	Behaviors should not be redefined"	^(Smalltalk compactClassesArray includes: self)		or:[(Smalltalk specialObjectsArray includes: self)			or:[self isKindOf: self]]! !!Behavior methodsFor: 'creating class hierarchy' stamp: 'ar 7/10/1999 12:10'!superclass: aClass 	"Change the receiver's superclass to be aClass."	"Note: Do not use 'aClass isKindOf: Behavior' here		in case we recompile from Behavior itself."	(aClass == nil or: [aClass isBehavior])		ifTrue: [superclass _ aClass.				Object flushCache]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 7/10/1999 12:37'!compileAllFrom: oldClass	"Compile all the methods in the receiver's method dictionary.	This validates sourceCode and variable references and forces	all methods to use the current bytecode set"	"ar 7/10/1999: Use oldClass selectors not self selectors"	oldClass selectorsDo: [:sel | self recompile: sel from: oldClass].	Project current compileAllIsolated: self from: oldClass.! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 7/11/1999 05:11'!methodDictionary	"Convenience"	^self methodDict! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 7/12/1999 07:45'!methodDictionary: aDictionary 	"Store the argument, aDictionary, as the method dictionary of the 	receiver."	methodDict _ aDictionary.! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 7/10/1999 12:38'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method _ oldClass compiledMethodAt: selector.	trailer _ (method size - 3 to: method size) collect: [:i | method at: i].	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ar 7/11/1999 08:03'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 7/15/1999 15:41'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal.  Dives into the compact literal notation, making it slow but thorough"	| who |	who _ Set new.	self selectorsAndMethodsDo:		[:sel :method |		((method hasLiteralSuchThat: [:lit | lit == literal]) or:				[specialFlag and: [method scanFor: specialByte]])			ifTrue:			[((literal isMemberOf: Association) not				or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])				ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'enumerating' stamp: 'ar 7/11/1999 04:21'!withAllSuperclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	aBlock value: self.	superclass == nil		ifFalse: [superclass withAllSuperclassesDo: aBlock]! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/15/1999 15:27'!class: oldClass instanceVariableNames: instVarString	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass |	oldClass isMeta ifFalse:[^self error: oldClass name, 'is not a Metaclass'].	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	"Run validation checks so we know that we have a good chance for recompilation"	(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].	(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass.	newClass == nil ifTrue:[^nil]. "Some error"	newClass _ self recompile: false from: oldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/13/1999 06:07'!superclass: newSuper	subclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class."	^self 		name: t		inEnvironment: newSuper environment		subclassOf: newSuper		type: newSuper typeOfClass		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/13/1999 05:22'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #bytes		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/13/1999 05:23'!superclass: aClass	variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #variable		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/13/1999 05:23'!superclass: aClass	variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable word-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a word subclass of a class with named fields'].	(aClass isVariable and: [aClass isBytes])		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a word subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #words		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/13/1999 05:23'!superclass: aClass	weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #weak		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/15/1999 14:40'!mutate: oldClass to: newClass	"Mutate oldClass to newClass.	Convert all instances of oldClass and recursively update	the subclasses."	| subs newSubclass oldSubclass |	subs _ oldClass subclasses asArray.	"Walk down"	1 to: subs size do:[:i|		oldSubclass _ subs at: i.		self showProgressFor: oldSubclass.		"Create the new class"		newSubclass _ self reshapeClass: oldSubclass toSuper: newClass.		self mutate: oldSubclass to: newSubclass.	].	oldClass obsolete.	newClass isObsolete ifTrue:[newClass obsolete].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/15/1999 16:26'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category	"Define a new class in the given environment"	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	(self validateClassName: className) ifFalse:[^nil].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	"Run validation checks so we know that we have a good chance for recompilation"	(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].	(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].	(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].	(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass.	newClass == nil ifTrue:[^nil]. "Some error"	newClass setName: className.	"Export the new class into the environment.	Note: It is absolutely necessary to remove any outdated association first,	since these are used to indicate the method class and any older class	with sends to super might go nuts over the changed class."	(environ at: className ifAbsent:[nil]) == newClass ifFalse:[		environ removeKey: className ifAbsent:[].		environ declare: className from: Undeclared.		environ at: newClass name put: newClass.	]. "So far, so good."	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	"... record any new class ..."	oldClass == nil ifTrue:[Smalltalk changes addClass: newClass].	"... and recompile."	newClass _ self recompile: force from: oldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/19/1999 19:26'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass.	Note: The new class may be meta."	| newFormat newClass meta |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	"Check if we really need a new subclass"	(oldClass ~~ nil and:[		newSuper == oldClass superclass and:[			newFormat = oldClass format and:[				instVars = oldClass instVarNames]]]) 					ifTrue:[^oldClass].	"Make sure we don't redefine any dangerous classes"	oldClass == Object ifTrue:["Never redefine Object"		self error:'Object cannot be changed'.		^nil].	"Check if the receiver should not be redefined"	(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[		self notify: oldClass name asText allBold, 					' should not be redefined!! \Proceed to store over it.' withCRs].	oldClass == nil ifTrue:["Requires new metaclass"		meta _ Metaclass new.		meta			superclass: (newSuper ifNil:[Class] ifNotNil:[newSuper class])			methodDictionary: MethodDictionary new			format: (newSuper ifNil:[Class format] ifNotNil:[newSuper class format]).		meta superclass addSubclass: meta. "In case of Class"		newClass _ meta new.	] ifFalse:[ newClass _ oldClass shallowCopy ].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars;		organization: (oldClass ifNotNil:[oldClass organization]).	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/15/1999 18:51'!recompile: force from: oldClass to: aClass	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses"	| newClass |	newClass _ aClass.	oldClass == nil ifTrue:[		newClass superclass addSubclass: newClass.		^newClass]. "newClass has an empty method dictionary"	(newClass == oldClass and:[force not])			ifTrue:[^newClass]. "No recompilation necessary"	Smalltalk changes changeClass: newClass from: oldClass.	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	oldClass == newClass ifTrue:[		"Recompile from newClass without mutating"		self informUserDuring:[			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	oldClass becomeUncompact.	classMap _ WeakValueDictionary new.	oldClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	self informUserDuring:[		self showProgressFor: oldClass.		"newClass will recompiled later but we need the methodDict for the source"		newClass methodDictionary: oldClass methodDictionary.		newClass _ self reshapeClass: newClass toSuper: newClass superclass.		"Adopt all the instances of the old class"		oldClass autoMutateInstances			ifTrue:[newClass updateInstancesFrom: oldClass].		"Record the change"		self recordClass: oldClass replacedBy: newClass.		self mutate: oldClass to: newClass.		"Fix all global references"		self fixGlobalReferences.		Smalltalk flushClassNameCache.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/15/1999 17:15'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given old class to the new super class"	| fmt newClass newMeta newSuperMeta oldMeta |	oldClass becomeUncompact.	"Compute the new format of the class"	fmt _ self computeFormat: oldClass typeOfClass				instSize: oldClass instVarNames size				forSuper: newSuper				ccIndex: 0."Known to be 0 since we uncompacted oldClass first"	fmt == nil ifTrue:[^nil].	oldClass isMeta ifFalse:["Create a new meta class"		oldMeta _ oldClass class.		newMeta _ oldMeta clone.		newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].		newMeta 			superclass: newSuperMeta			methodDictionary: MethodDictionary new			format: (self computeFormat: oldMeta typeOfClass 							instSize: oldMeta instVarNames size 							forSuper: newSuperMeta							ccIndex: 0);			setInstVarNames: oldMeta instVarNames;			organization: oldMeta organization.	].	newClass _ newMeta == nil		ifTrue:[oldClass clone]		ifFalse:[newMeta adoptInstance: oldClass from: oldMeta].	newClass		superclass: newSuper		methodDictionary: MethodDictionary new		format: fmt;		setInstVarNames: oldClass instVarNames;		organization: oldClass organization.	"Note: This is a possibly dangerous state. As long as the 	meta class is not recompiled we should not send any 	messages to the non-meta class."	oldClass isMeta ifFalse:[		"Note: It is deadly important to remove the Smalltalk association name->class		before exporting the class -- sends to super are encoded by the ST association		and exporting the old class by simply doing 			Smalltalk at: newClass name put: newClass		would result in a (possibly fatal) redefinition of the method class.		Unfortunately, exporting newClass might be problem too. Since it is		not yet recompiled sending messages to it during the recompilation		might be fatal. This, however, should not happen as long as the		new class is not referenced from recompilation by means of a message		send -- e.g., the old association is still kept around all direct refs		to the global are still okay. Trouble would start if in the recompilation		something like 'Smalltalk at: #Array' occurs and we were just about		to recompile Array."		environ removeKey: oldClass name ifAbsent:[].		environ at: newClass name put: newClass.		"Recompile the meta class"		oldMeta hasMethods 			ifTrue:[newMeta compileAllFrom: oldMeta].		"Fix up meta class structure"		oldMeta superclass removeSubclass: oldMeta.		newMeta superclass addSubclass: newMeta.		"And record the change so we can fix global refs later"		self recordClass: oldMeta replacedBy: newMeta].	"Recompile the class"	oldClass hasMethods 		ifTrue:[newClass compileAllFrom: oldClass].	"Fix up the class hierarchy"	oldClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Adopt all the instances of the old class"	oldClass autoMutateInstances		ifTrue:[newClass updateInstancesFrom: oldClass].	"And record the change"	self recordClass: oldClass replacedBy: newClass.	^newClass! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 7/15/1999 17:14'!computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex	"Compute the new format for making oldClass a subclass of newSuper.	Return the format or nil if there is any problem."	| instSize isVar isWords isPointers isWeak |	instSize _ newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).	instSize > 254 ifTrue:[		self error: 'Class has too many instance variables (', instSize printString,')'.		^nil].	type == #compiledMethod		ifTrue:[^CompiledMethod instSpec].	type == #normal ifTrue:[isVar _ isWeak _ false. isWords _ isPointers _ true].	type == #bytes ifTrue:[isVar _ true. isWords _ isPointers _ isWeak _ false].	type == #words ifTrue:[isVar _ isWords _ true. isPointers _ isWeak _ false].	type == #variable ifTrue:[isVar _ isPointers _ isWords _ true. isWeak _ false].	type == #weak ifTrue:[isVar _ isWeak _ isWords _ isPointers _ true].	^(self format: instSize 		variable: isVar 		words: isWords 		pointers: isPointers 		weak: isWeak) + (ccIndex bitShift: 11).! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 7/11/1999 06:39'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Compute the format for the given instance specfication."	| cClass instSpec sizeHiBits fmt |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	fmt _ sizeHiBits.	fmt _ (fmt bitShift: 5) + cClass.	fmt _ (fmt bitShift: 4) + instSpec.	fmt _ (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	fmt _ (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"	^fmt! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/13/1999 05:26'!validateClassName: aString	"Validate the new class name"	aString first isUppercase ifFalse:[		self error: 'Class names must be capitalized'.		^false].	environ at: aString ifPresent:[:old|		(old isKindOf: Behavior) ifFalse:[			self notify: aString asText allBold, 						' already exists!!\Proceed will store over it.' withCRs]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:48'!validateClassvars: classVarArray from: oldClass forSuper: newSuper	"Check if any of the classVars of oldClass conflict with the new superclass"	| usedNames classVars temp |	classVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the class var names"	usedNames _ classVarArray asSet.	usedNames size = classVarArray size 		ifFalse:[	classVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allClassVarNames asSet.		classVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl classVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv, ' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl classVarNames].		classVars _ classVarArray.		newSuper == nil ifFalse:[classVars _ classVars, newSuper allClassVarNames asArray].		classVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:49'!validateInstvars: instVarArray from: oldClass forSuper: newSuper	"Check if any of the instVars of oldClass conflict with the new superclass"	| instVars usedNames temp |	instVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the inst var names"	usedNames _ instVarArray asSet.	usedNames size = instVarArray size 		ifFalse:[	instVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allInstVarNames asSet.		instVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl instVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv,' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].		instVars _ instVarArray.		newSuper == nil ifFalse:[instVars _ instVars, newSuper allInstVarNames].		instVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 17:03'!validateSubclassFormat: newType from: oldClass forSuper: newSuper extra: newInstSize	"Validate the # of instVars and the format of the subclasses"	| deltaSize oldType |	oldClass == nil ifTrue:[^true]. "No subclasses"	"Compute the # of instvars needed for all subclasses"	deltaSize _ newInstSize.	(oldClass notNil)		ifTrue:[deltaSize _ deltaSize - oldClass instVarNames size].	(newSuper notNil)		ifTrue:[deltaSize _ deltaSize + newSuper instSize].	(oldClass notNil and:[oldClass superclass notNil]) 		ifTrue:[deltaSize _ deltaSize - oldClass superclass instSize].	oldClass == nil ifTrue:[		deltaSize > 254 ifTrue:[			self error: 'More than 254 instance variables'.			^false].		^true].	oldClass withAllSubclassesDo:[:sub|		sub instSize + deltaSize > 254 ifTrue:[			self error: sub name,' has more than 254 instance variables'.			^false]].	"And check if the immediate subclasses of oldClass can keep its layout"	oldClass subclassesDo:[:sub|		oldType _ sub typeOfClass.		oldType == newType ifFalse:[			self error: sub name,' cannot be recompiled'.			^false]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:50'!validateSuperclass: aSuperClass forSubclass: aClass	"Check if it is okay to use aSuperClass as the superclass of aClass"	aClass == nil ifTrue:["New class"		(aSuperClass == nil or:[aSuperClass isBehavior and:[aSuperClass isMeta not]])			ifFalse:[self error: aSuperClass name,' is not a valid superclass'.					^false].		^true].	aSuperClass == aClass superclass ifTrue:[^true]. "No change"	(aClass isMeta) "Not permitted - meta class hierarchy is derived from class hierarchy"		ifTrue:[^self error: aClass name, ' must inherit from ', aClass superclass name].	"Check for circular references"	(aSuperClass ~~ nil and:[aSuperClass == aClass or:[aSuperClass inheritsFrom: aClass]])		ifTrue:[self error: aSuperClass name,' inherits from ', aClass name.				^false].	^true! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 18:52'!fixGlobalReferences	"Fix all the references to globals which are now outdated.	Care must be taken that we do not accidentally 'fix' dangerous stuff."	| oldClasses newClasses |	(classMap contains:[:any| any notNil and:[any isObsolete]])		ifFalse:[^self]. "Great - no references pending"	any _ nil. "Grrrr. Must clean up the temp of the block above"	Smalltalk garbageCollect. "Try to get rid of as many refs as we can"	"Collect the old and the new refs"	oldClasses _ OrderedCollection new.	newClasses _ OrderedCollection new.	classMap keysAndValuesDo:[:new :old|		old == nil ifFalse:[			newClasses add: new.			oldClasses add: old]].	oldClasses isEmpty ifTrue:[^self]. "GC cleaned up the rest"	"Now fix all the known dangerous pointers to old classes by creating	copies of those still needed. Dangerous pointers should come only	from obsolete subclasses (where the superclass must be preserved)."	self fixObsoleteReferencesTo: oldClasses.	"After this has been done fix the remaining references"	progress == nil ifFalse:[progress value: 'Fixing references to globals'].	"Forward all old refs to the new ones"	oldClasses asArray		elementsForwardIdentityTo:			newClasses asArray.	"Done"! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 15:48'!fixObsoleteReferencesTo: oldClasses	"Fix all obsolete references to the given set of outdated classes"	| obsoleteClasses obj oldMeta tempMeta nLits |	progress == nil ifFalse:[progress value:'Fixing obsolete class references...'].	"Prepare a map of obsolete classes"	obsoleteClasses _ IdentityDictionary new: oldClasses size.	"Map the old classes to temporary classes"	oldClasses do:[:oldClass| 		"Note: If a class is getting obsolete here so is its metaclass"		oldMeta _ oldClass isMeta ifTrue:[oldClass] ifFalse:[oldClass class].		tempMeta _ obsoleteClasses at: oldMeta ifAbsentPut:[oldMeta clone].		oldClass isMeta ifFalse:[			tempMeta adoptInstance: oldClass from: oldMeta.			obsoleteClasses at: oldClass put: tempMeta soleInstance.			"Note: If we haven't mutated the instances of the old class to the new			layout we must do it here."			oldClass autoMutateInstances ifFalse:[				tempMeta soleInstance updateInstancesFrom: oldClass]]].	"Sanity check for debugging"	oldClasses size = obsoleteClasses size ifFalse:[self error:'Obsolete classes size mismatch'].	"Fix the superclasseses of the clones"	obsoleteClasses keysAndValuesDo:[:old :temp|		temp superclass: 			(obsoleteClasses 				at: temp superclass				"Might be a subclass of a live class"				ifAbsent:[temp superclass])].	"Fix the methods referring to super"	oldClasses do:[:class|		class selectorsAndMethodsDo:[:sel :meth|			meth sendsToSuper ifTrue:[				nLits _ meth numLiterals.				meth literalAt: nLits put: 					(Association new value: 						(obsoleteClasses at: class ifAbsent:[class])).				class recompile: sel from: class]]].	"Now search and fix all dangerous objects"	obj _ 0 someObject.	[0 == obj] whileFalse:[		(obj isBehavior and:[obsoleteClasses includesKey: obj superclass]) ifTrue:[			(obsoleteClasses includesKey: obj) ifFalse:[				obj superclass: (obsoleteClasses at: obj superclass)].		].		obj _ obj nextObject.	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 18:52'!informUserDuring: aBlock	self class isSilent ifTrue:[^aBlock value].	Utilities informUserDuring:[:bar|		progress _ bar.		aBlock value].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 13:40'!recordClass: oldClass replacedBy: newClass	"Record the replacement of oldClass by newClass so that we can	fix any references to oldClass later on."	classMap at: newClass put: oldClass.	(classMap includesKey: oldClass) ifTrue:[		"This will happen if we recompile from Class		in which case the metaclass gets recorded twice"		classMap at: newClass put: (classMap at: oldClass).		classMap removeKey: oldClass.	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 13:39'!reservedNames	"Return a list of names that must not be used for variables"	^#('self' 'super' 'thisContext' 'true' 'false' 'nil' 		self super thisContext true false nil).! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 14:01'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	currentClassIndex _ currentClassIndex + 1.	aClass hasMethods ifTrue:[		progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')].! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 7/14/1999 04:41'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	organization _ nil.	super obsolete.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 01:17'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	subclasses _ nil.	organization _ nil.	instanceVariables _ nil.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 11:04'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	Here's a simple example:	| crashingBlock class |	class _ Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar _ value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock _ (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"	| map variable instSize oldInstances newInstances |	oldInstances _ oldClass allInstances asArray.	oldInstances isEmpty ifTrue:[^self]. "no instances to convert"	map _ self instVarMappingFrom: oldClass.	variable _ self isVariable.	instSize _ self instSize.	newInstances _ Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/11/1999 11:41'!instVarMappingFrom: oldClass	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."	| oldInstVarNames |	oldInstVarNames _ oldClass allInstVarNames.	^self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/10/1999 11:17'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| new |	variable		ifTrue: [new _ self basicNew: oldInstance basicSize]		ifFalse: [new _ self basicNew].	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[new instVarAt: offset					put: (oldInstance instVarAt: (map at: offset))]].	variable 		ifTrue: [1 to: oldInstance basicSize do: 					[:offset |					new basicAt: offset put: (oldInstance basicAt: offset)]].	^new! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/15/1999 17:04'!setInstVarNames: instVarArray	"Private - for class initialization only"	| required |	required _ self instSize.	superclass notNil ifTrue:[required _ required - superclass instSize].	instVarArray size = required		ifFalse:[^self error: required printString, ' instvar names are required'].	instVarArray isEmpty		ifTrue:[instanceVariables _ nil]		ifFalse:[instanceVariables _ instVarArray asArray].! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:57'!printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subclassNames |	aStream crtab: level.	aStream nextPutAll: self name.	aStream space; print: self instVarNames.	self == Class		ifTrue: 			[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.			^self].	subclassNames _ self subclasses asSortedCollection:[:c1 :c2| c1 name <= c2 name].	"Print subclasses in alphabetical order"	subclassNames do:		[:subclass | subclass printSubclassesOn: aStream level: level + 1]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/15/1999 16:35'!subclasses	^subclasses ifNil:[#()]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/10/1999 08:22'!subclassesDo: aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	^self subclasses do: aBlock! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 15:37'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue:[^self error:'Object is NOT obsolete'].	self subclassesDo:[:sub| sub obsolete].	name _ 'AnObsolete' , name.	classPool _ Dictionary new.	self class obsolete.	super obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 16:39'!superclass: sup methodDict: md format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ sup.	methodDict _ md.	format _ ft.	name _ nm.	organization _ org.	instanceVariables _ nilOrArray.	classPool _ pool.	sharedPools _ poolSet! !!Class methodsFor: 'testing' stamp: 'ar 7/15/1999 15:36'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent:[nil]) ~~ self! !!Class methodsFor: 'instance variables' stamp: 'ar 7/15/1999 18:56'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: self instanceVariablesString , aString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'instance variables' stamp: 'ar 7/15/1999 18:56'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: newInstVarString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'compiling' stamp: 'ar 7/14/1999 04:56'!compileAll	super compileAll.	self class compileAll.! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:57'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	^(ClassBuilder new)		superclass: self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:57'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: d		classVariableNames: s		poolDictionaries: s		category: cat! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 11:06'!addSubclass: aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [^self error: aSubclass name , ' is not my subclass'].	subclasses == nil		ifTrue:	[subclasses _ Array with: aSubclass.				^self].	subclasses do:[:cl| cl = aSubclass ifTrue:[^self]]. "Already my subclass"	subclasses _ subclasses copyWith: aSubclass.! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:54'!removeSubclass: aSubclass 	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."	subclasses == nil ifFalse:		[subclasses _  subclasses copyWithout: aSubclass.		subclasses isEmpty ifTrue: [subclasses _ nil]].! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 11:00'!subclasses	"Answer a Set containing the receiver's subclasses."	^subclasses == nil		ifTrue: [#()]		ifFalse: [subclasses copy]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 11:00'!subclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil 		ifFalse:[subclasses do: aBlock]! !!Class methodsFor: 'private' stamp: 'ar 7/15/1999 15:37'!setName: aSymbol	"Private - set the name of the class"	name _ aSymbol.! !!ClassBuilder class methodsFor: 'testing' stamp: 'ar 7/15/1999 14:04'!autoMutateInstances	"Don't mutate me while I'm compiling myself"	^false! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:50'!beSilent: aBool	"ClassDefiner beSilent: true"	"ClassDefiner beSilent: false"	QuietMode _ aBool.! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:53'!beSilentDuring: aBlock	"Temporarily suppress information about what is going on"	| wasSilent result |	wasSilent _ self isSilent.	self beSilent: true.	result _ aBlock value.	self beSilent: wasSilent.	^result! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:48'!isSilent	^QuietMode == true! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 7/9/1999 19:01'!sourceCode	| selector methodClass |	selector _ self receiver class selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^self method getSourceFor: selector in: methodClass	"Note: The above is a bit safer than		^ methodClass sourceCodeAt: selector	which may fail if the receiver's method has been changed in	the debugger (e.g., the method is no longer in the methodDict	and thus the above selector is something like #Doit:with:with:with:)	but the source code is still available."! !!Encoder methodsFor: 'temps' stamp: 'ar 7/12/1999 00:24'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp or:[requestor interactive])			ifTrue:[^self notify:'Name is already defined']			ifFalse:[Transcript show: '(', name, ' is shadowed)']].	^self reallyBind: name! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'ar 7/15/1999 17:24'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title |	World ifNil: [^ self].	title _ submorphs first submorphs first.	self visible: false.	aBlock value:[:string|		self visible ifFalse:[			World addMorph: self centeredNear: (aPoint - World viewBox origin).			self visible: true].		title contents: string.		self setConstrainedPositionFrom: Sensor cursorPoint.		self changed.		World displayWorld].  "show myself"	self delete.	World displayWorld.! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/13/1999 04:52'!adoptInstance: oldInstance from: oldMetaClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	thisClass class == self ifTrue:[^self error:'Metaclasses have only one instance'].	oldMetaClass isMeta ifFalse:[^self error:'Argument must be Metaclass'].	oldInstance class == oldMetaClass ifFalse:[^self error:'Not the class of argument'].	^thisClass _ self 		newInstanceFrom: oldInstance 		variable: self isVariable 		size: self instSize 		map: (self instVarMappingFrom: oldMetaClass)! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 18:56'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	^(ClassBuilder new)		class: self		instanceVariableNames: instVarString! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/12/1999 09:03'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	| oldInstances newInstances |	oldInstances _ oldClass allInstances asArray.	oldInstances isEmpty ifTrue:[^self]. "no instances to convert"	oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].	thisClass class == self ifTrue:[^self error:'Metaclasses can only have one instance'].	newInstances _ Array with:		(self newInstanceFrom: (oldInstances at: 1) 				variable: self isVariable 				size: self instSize 				map: (self instVarMappingFrom: oldClass)).	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.! !!Metaclass methodsFor: 'accessing' stamp: 'ar 7/11/1999 08:14'!allInstances	thisClass class == self ifTrue:[^Array with: thisClass].	^super allInstances! !!Metaclass methodsFor: 'accessing' stamp: 'ar 7/11/1999 05:19'!environment	^thisClass environment! !!Metaclass methodsFor: 'instance creation' stamp: 'ar 7/11/1999 10:07'!new	"The receiver can only have one instance. Create it or complain that	one already exists."	thisClass class ~~ self		ifTrue: [^thisClass _ super new]		ifFalse: [self error: 'A Metaclass should only have one instance!!']! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/11/1999 15:43'!addSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/11/1999 15:43'!removeSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/14/1999 11:19'!subclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass subclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses_nil' for: m logged: false]"! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/9/1999 14:11'!subclassesDo: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	thisClass subclassesDo:[:aSubclass|		"The following test is for Class class which has to exclude		the Metaclasses being subclasses of Class."		aSubclass isMeta ifFalse:[aBlock value: aSubclass class]].! !!Metaclass methodsFor: 'testing' stamp: 'ar 7/11/1999 07:27'!isObsolete	"Return true if the receiver is obsolete"	^thisClass == nil "Either no thisClass"		or:[thisClass class ~~ self "or I am not the class of thisClass"			or:[thisClass isObsolete]] "or my instance is obsolete"! !!Metaclass methodsFor: 'enumerating' stamp: 'ar 7/15/1999 16:43'!allInstancesDo: aBlock	"There should be only one"	thisClass class == self ifTrue:[^aBlock value: thisClass].	^super allInstancesDo: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 7/11/1999 08:06'!keysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values"	1 to: self size do:[:i|		aBlock value: i value: (self at: i).	].! !!Set methodsFor: 'removing' stamp: 'ar 7/14/1999 11:04'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any elements equal	to oldElement."	^ (self copy)		 remove: oldElement ifAbsent:[];		yourself! !!Dictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 07:28'!values	"Answer a Collection containing the receiver's values."	| out |	out _ WriteStream on: (Array new: self size).	self valuesDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'enumerating' stamp: 'ar 7/11/1999 08:04'!keysAndValuesDo: aBlock	^self associationsDo:[:assoc|		aBlock value: assoc key value: assoc value].! !!Dictionary methodsFor: 'enumerating' stamp: 'ar 7/11/1999 07:29'!valuesDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | aBlock value: association value]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 08:05'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys and values passed to the block"	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil ifFalse:			[aBlock value: key value: (array at: i)]		]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 07:29'!valuesDo: aBlock 	| value |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (value _ array at: i) == nil			ifFalse: [aBlock value: value]]! !!SystemDictionary methodsFor: 'retrieving' stamp: 'ar 7/15/1999 15:25'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: Object.	Object allSubclassesDo: aBlock.	"Classes outside the Object hierarchy"	Class subclassesDo:[:aClass|		aClass == Object class ifFalse:["Do not enumerate Object"			"Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDo: aBlock]].! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'ar 7/15/1999 16:05'!obsoleteBehaviors   "Smalltalk obsoleteBehaviors inspect"	"Find all obsolete behaviors including meta classes"	| obs |	obs _ OrderedCollection new.	Smalltalk garbageCollect.	self allObjectsDo:[:cl|		(cl isBehavior and:[cl isObsolete]) ifTrue:[obs add: cl]].	^ obs asArray! !!SystemDictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 21:56'!organization	"Return the organizer for the receiver"	^SystemOrganization! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:49'!addSubclass: aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:57'!environment	"Necessary to support disjoint class hierarchies."	^Smalltalk! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 18:56'!subclass: nameOfClass  "Define root (superclass = nil) of a class hierarchy"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category	^(ClassBuilder new)		superclass: self		subclass: nameOfClass		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictnames		category: category! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:55'!subclasses	"Return all the subclasses of nil"	| classList |	classList _ WriteStream on: Array new.	self subclassesDo:[:class| classList nextPut: class].	^classList contents! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 15:44'!subclassesDo: aBlock	"Evaluate aBlock with all subclasses of nil."	^Class subclassesDo:[:cl| 		cl isMeta ifTrue:[aBlock value: cl soleInstance]].! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/13/1999 06:08'!typeOfClass	"Necessary to support disjoint class hierarchies."	^#normal! !!Utilities class methodsFor: 'user interface' stamp: 'ar 7/15/1999 15:46'!informUserDuring: aBlock	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUserDuring:[:bar|		#(one two three) do:[:info|			bar value: info.			(Delay forSeconds: 1) wait]]"	World ifNotNil: [		(MVCMenuMorph from: (SelectionMenu labels: '') title: '						')			informUserAt: Sensor cursorPoint during: aBlock.		^ self].	aBlock value:[:string| Transcript cr; show: string].! !Behavior removeSelector: #format:variable:words:pointers:!Behavior removeSelector: #format:variable:words:pointers:weak:!ClassDescription removeSelector: #validateFrom:in:instanceVariableNames:methods:wasPresent:!ClassDescription removeSelector: #subclassOf:oldClass:instanceVariableNames:variable:words:pointers:weak:ifBad:!ClassDescription removeSelector: #name!Class removeSelector: #copyForValidation!Class removeSelector: #validateFrom:in:instanceVariableNames:methods:wasPresent:!Metaclass removeSelector: #name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:weak:classVariableNames:poolDictionaries:category:comment:changed:!Metaclass removeSelector: #subclassOf:!Metaclass removeSelector: #copyForValidation!Metaclass removeSelector: #newNamed:!Metaclass removeSelector: #name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed:!Metaclass class removeSelector: #subclassOf:!MethodDictionary removeSelector: #keyValueDo:!"Postscript:Force the instVar ClassDescription>>subclasses to use Arrays."| cl subs idx |Utilities informUserDuring:[:bar|	bar value: 'Fixing class hierarchy'.	Metaclass allInstancesDo:[:meta|		cl _ meta soleInstance.		subs _ cl subclasses.		subs do:[:sub| cl removeSubclass: sub].		cl subclasses isEmpty ifFalse:[			"Fix it the hard way"			idx _ cl class allInstVarNames indexOf: 'subclasses'.			cl instVarAt: idx put: nil].		"After removing all subclasses add'em back in"		subs do:[:sub| 			sub superclass == cl ifTrue:[cl addSubclass: sub]].	].].!