'From Squeak 2.4b of April 23, 1999 on 4 May 1999 at 8:55:39 am'!"Change Set:		ReframeTweakDate:			4 May 1999Author:			Dan IngallsA second pass at non-composing reframe for morphic.This one uses proper morphic rectangles for better appearance, but still avoids recomposition in the inner loop.Reclassifies HandleMoprh and NewHandleMorph under Widgets."!EllipseMorph subclass: #HandleMorph	instanceVariableNames: 'pointBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!HandleMorph subclass: #NewHandleMorph	instanceVariableNames: 'hand offset lastPointBlock waitingForClickInside '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!NewHandleMorph reorganize!('all' followHand:forEachPointDo:lastPointDo: initialize justDroppedInto:event: step)!!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/4/1999 08:51'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds frameRect |	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	frameRect _ nil.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt.			Preferences fastDragWindowForMorphic			ifTrue:				["For fast display, only higlight the rectangle during loop"				frameRect == nil				ifTrue: [frameRect _ (RectangleMorph newBounds: growingPane bounds											color: Color transparent)											borderColor: Color gray.						self world addMorph: frameRect]				ifFalse: [frameRect bounds: newBounds]]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo:			[:p | Preferences fastDragWindowForMorphic ifTrue:				["After loop, fast display needs to really do the reframe"				frameRect delete.				self reframePanesAdjoining: growingPane along: side to: newBounds]].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/4/1999 08:51'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds frameRect |	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) 		ifTrue:  [^ self].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	frameRect _ nil.	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds withSideOrCorner: ptName setToPoint: localPt.			Preferences fastDragWindowForMorphic			ifTrue:				["For fast display, only higlight the rectangle during loop"				frameRect == nil				ifTrue: [frameRect _ (RectangleMorph newBounds: self bounds											color: Color transparent)											borderColor: Color gray.						self world addMorph: frameRect]				ifFalse: [frameRect bounds: newBounds]]			ifFalse:				[newBounds extent > (60@40) ifTrue: [self bounds: newBounds]]]		lastPointDo:			[:p | Preferences fastDragWindowForMorphic ifTrue:				["After loop, fast display needs to really do the reframe"				frameRect delete.				newBounds extent > (60@40) ifTrue: [self bounds: newBounds]]].	event hand world addMorph: resizer.	resizer startStepping! !