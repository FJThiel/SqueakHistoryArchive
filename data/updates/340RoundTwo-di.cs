'From Squeak 2.0 of May 22, 1998 on 6 October 1998 at 8:47:20 am'!"Change Set:		RoundTwo-diDate:			5 October 1998Author:			Dan IngallsAdds a method canvasForSubmorphs: that allows three formerly idiosyncratic implementations of fullDrawOn: to be replaced by simple inheritance of the general method in Morph.Failure to click in a morphic menu should now result in dismissal as expected.Drop shadows are no longer incorrectly affected by text color emphasis.MVC inspect no longer offered in a morphic world (duh).Numerous fixes for flexed SystemWindows, including	Coming to the top when clicked	Only getting control when cursor is over flexed shape	Retaining control when scrollbar flops out of window bounds	Making reshape handles work properly.Introduces a mechanism for retaining ParagraphEditor state across reinstantiation such as happens when an edit causes recomposition due to line break.  This corrects the multiple selections and erroneous screen artifacts.Makes repeated edits and undos work right in morphic, even when line breaks are involved.Makes the find command defeat substitution from a prior change command.Makes text deletion set typing emphasis according to the first character deleted."!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX foregroundColor backgroundColor lastSourceDepth fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!DisplayScanner methodsFor: 'scanning' stamp: 'di 10/5/1998 09:29'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern displaying: true.		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		fillBlt == nil ifFalse:			[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/5/1998 09:30'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges _ shadowMode! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/5/1998 09:33'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!FormCanvas methodsFor: 'drawing' stamp: 'di 10/5/1998 09:32'!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c) background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil])		ignoreColorChanges: shadowDrawing.	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!GrafPort methodsFor: 'all' stamp: 'di 10/5/1998 09:31'!displayScannerFor: para foreground: foreColor background: backColor		rule: rule halftone: halftone ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setDestForm: destForm sourceForm: destForm			fillColor: halftone combinationRule: rule			destOrigin: 0@0 sourceOrigin: 0@0			extent: 0@0 clipRect: self clipRect! !!Morph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:09'!canvasForSubmorphs: canvasForMe	"Provide a canvas for drawing my submorphs.  This may be overridden	to provide for clipping and other related behavior."	^ canvasForMe! !!Morph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:17'!fullDrawOn: aCanvas	| canvasForSubmorphs |	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	submorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!Morph methodsFor: 'geometry testing' stamp: 'di 10/4/1998 20:53'!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(self containsPoint: aPoint) ifTrue: [^ true].  "quick acceptance"	submorphs do: [:m |		m allMorphsDo: [:n |			(n fullContainsPoint: aPoint) ifTrue: [^ true]]].	^ false! !!Morph methodsFor: 'apr98 additions' stamp: 'di 10/5/1998 11:50'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	World ifNil:		[aMenu add: 'inspect morph (in MVC)' action: #inspectArgument.		aMenu add: 'inspect morph' action: #inspectArgumentInMorphic]		ifNotNil:		[aMenu add: 'inspect morph' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	aMenu add: 'temp command' action: #tempCommand.	^ aMenu! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 00:37'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				self newMouseFocus: m.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 00:57'!newMouseFocus: aMorphOrNil	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: [mouseDownMorph owner deleteIfPopUp]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 10/5/1998 11:58'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	World ifNil:		[menu add: 'inspect (in MVC)' action: #inspectMorph.		menu add: 'inspect' action: #inspectMorphInMorphic]		ifNotNil:		[menu add: 'inspect' action: #inspectMorphInMorphic].	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'special gestures' stamp: 'di 10/6/1998 00:38'!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be grabbed or bring up a halo for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph"	self newMouseFocus: nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	evt shiftPressed		ifTrue: [argument ifNotNil: [self grabMorph]]		ifFalse: [self popUpHaloFromClick: evt].! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!Paragraph methodsFor: 'character location' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/6/1998 08:41'!initialize	"Initialize a new ParagraphEditor."	super initialize.	self initializeYellowButtonMenu.! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 11/30/97 10:13'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultCharacterBlock.	stopBlock _ startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 23:57'!stateArray	^ (Array with: ChangeText		with: FindText		with: UndoInterval		with: UndoMessage) ,	(Array  with: UndoParagraph		with: UndoSelection		with: Undone) ,	(Array with: self selectionInterval		with: self startOfTyping		with: emphasisHere)! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText _ stateArray at: 1.	FindText _ stateArray at: 2.	UndoInterval _ stateArray at: 3.	UndoMessage _ stateArray at: 4.	UndoParagraph _ stateArray at: 5.	UndoSelection _ stateArray at: 6.	Undone _ stateArray at: 7.	sel _ stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock _ stateArray at: 9.	emphasisHere _ stateArray at: 10.! !!ParagraphEditor methodsFor: 'accessing' stamp: 'di 10/6/1998 00:02'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/5/1998 21:55'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:43'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection _ self nullText. stopBlock stringIndex]		ifFalse: [self startOfTyping].	startBlock _ paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ startBlock stringIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	startBlock _ stopBlock copy! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:31'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin start stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			start _ startBlock stringIndex.			stop _ stopBlock stringIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:39'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ startBlock stringIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!PasteUpMorph methodsFor: 'display' stamp: 'di 10/6/1998 01:15'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for drawing my submorphs."	^ canvasForMe copyClipRect: self innerBounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 10/6/1998 01:15'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for drawing my submorphs."	^ canvasForMe copyClipRect: self innerBounds! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/5/1998 08:54'!enterHandle: event morph: handle pointName: ptName	"The mouse has entered reframing mark.  Start a reframe operation."	| resizer b localPt |	event anyButtonPressed		ifTrue: [^ self  "Don't activate resizer if button down"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			b _ self bounds.			ptName = #topCenter ifTrue: [self bounds: (b withTop: localPt y)].			ptName = #bottomCenter ifTrue: [self bounds: (b withBottom: localPt y)].			ptName = #leftCenter ifTrue: [self bounds: (b withLeft: localPt x)].			ptName = #rightCenter ifTrue: [self bounds: (b withRight: localPt x)].			ptName = #topLeft ifTrue: [self bounds: (b bottomRight rect: localPt)].			ptName = #bottomRight ifTrue: [self bounds: (b topLeft rect: localPt)].			ptName = #bottomLeft ifTrue: [self bounds: (b topRight rect: localPt)].			ptName = #topRight ifTrue: [self bounds: (b bottomLeft rect: localPt)]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'top window' stamp: 'di 10/5/1998 08:20'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph _ self topRendererOrSelf.	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse: [model modelWakeUp]! !!SystemWindow methodsFor: 'events' stamp: 'di 10/5/1998 08:20'!mouseDown: evt	| cp offset newBounds |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[Preferences fastDragWindowForMorphic		ifTrue: [offset _ self position - Sensor cursorPoint.				newBounds _ self bounds newRectFrom:					[:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft]		ifFalse: [^ evt hand grabMorph: self topRendererOrSelf]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!TextMorph methodsFor: 'accessing' stamp: 'di 10/5/1998 13:56'!editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseEmphasis	self editor changeEmphasis.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseFont	self editor offerFontMenu.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseStyle	self editor changeStyle.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:59'!handleInteraction: interactionBlock fromEvent: evt	"Perform the changes in interactionBlock, noting any change in selection"	"Also couple ParagraphEditor to Morphic keyboard events"	self editor sensor: (KeyboardBuffer new startingEvent: evt).	self selectionChanged.  "Note old selection"		interactionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 14:02'!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self editor "Forces install"]]		ifFalse: ["A hand has clicked elsewhere..."				w _ self world.				(w notNil and: 					[(w hands collect: [:h | h keyboardFocus]) includes: self])					ifFalse: ["Release control unless some hand is still holding on"							self releaseEditor]].! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 13:53'!installEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 17:04'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray _ priorEditor stateArray].	editor _ TextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 16:39'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 21:59'!updateFromParagraph  	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be release, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [oldEditor _ editor.					sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				editor ifNotNil: [self installEditorToReplace: editor]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditorToReplace: editor.							^ self passKeyboardFocusTo: m]].		self error: 'Inconsistency in text editor' "Must be somewhere in the successor chain"].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditorToReplace: oldEditor]! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/5/1998 21:48'!find	super find.	morph installEditorToReplace: self! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 10/6/1998 00:02'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 10/5/1998 14:03'!handleInteraction: interActionBlock fromEvent: evt	"Overridden to pass along a model to the editor for, eg, link resolution, doits, etc"	self editor model: editView model.  "For evaluateSelection, etc"	^ super handleInteraction: interActionBlock fromEvent: evt! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:25'!canvasForSubmorphs: canvasForMe	"Provide a clipping canvas for simple translation."	^ canvasForMe copyOffset: transform offset negated truncated									clipRect: self innerBounds! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 01:28'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds, and to translate, rotate and scale as appropriate."	| sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	transform isPureTranslation ifTrue:		[^ super fullDrawOn: aCanvas].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ self innerBounds.	patchRect _ transform transformBoundsRect:					(aCanvas clipRect intersect: innerRect).	sourceQuad _ (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.	warp cellSize: smoothing.  "installs a colormap if smoothing > 1"	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [aCanvas shadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: aCanvas stipple].					warp combinationRule: Form paint].		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!TransformMorph methodsFor: 'geometry' stamp: 'di 10/4/1998 02:34'!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullBounds containsPoint: (transform transform: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !DisplayScanner removeSelector: #text:textStyle:foreground:background:fillBlt:!GrafPort removeSelector: #displayScannerFor:foreground:background:rule:halftone:!NewParagraph removeSelector: #defaultStartBlock!NewParagraph removeSelector: #defaultStopBlock:!Paragraph removeSelector: #defaultStartBlock!Paragraph removeSelector: #defaultStopBlock:!PasteUpMorph removeSelector: #fullDrawOn:!PianoRollScoreMorph removeSelector: #fullDrawOn:!TextMorphEditor removeSelector: #storeSelectionInParagraph:!