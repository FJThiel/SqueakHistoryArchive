'From Squeak2.6 of 11 October 1999 [latest update: #1559] on 20 October 1999 at 4:33:51 pm'!"Change Set:		smartUpdating-swDate:			20 October 1999Author:			Scott WallaceFor Morphic, makes list panes and text panes of browsers, inspectors, and other tools 'smart' in the sense that they keep themselves up to date, and react intelligently when they find that changes have happened underneath them.Two levels of service are available -- the most obliging service continuously keeps lists and code panes up to date in all windows, both active and inactive.   Where this proves to be a performance problem, users may wish to set the #smartUpdating preference to false, in which case the service is only provided at the moment of window activation.Enhances the stepping protocol by calling #stepAt:, with the millisecondClockValue as argument, rather than simple #step, thus allowing morphs, if they care, to do something special depending on the clock value.The 'recent submissions' browser is particularly enhanced -- try it, in Morphic, with smartUpdating set to true, and notice how it nicely tracks all incoming code.The mvc environment benefits somewhat from these changes as well, but only upon window activation and only in the face of code disparities, rather than also list disparities.  In due course, mvc could be made to benefit more comprehensively."!StringHolder subclass: #CodeHolder	instanceVariableNames: 'showDiffs currentCompiledMethod methodChangedElsewhere '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!StringHolder subclass: #Inspector	instanceVariableNames: 'object selectionIndex timeOfLastListUpdate '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Inspector'!PluggableListMorph subclass: #PluggableMessageCategoryListMorph	instanceVariableNames: 'getRawListSelector priorRawList '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!ScrollPane subclass: #PluggableTextMorph	instanceVariableNames: 'textMorph getTextSelector setTextSelector getSelectionSelector hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!MorphicModel subclass: #SystemWindow	instanceVariableNames: 'labelString stripes label closeBox collapseBox activeOnlyOnTop paneMorphs paneRects collapsedFrame fullFrame isCollapsed menuBox mustNotClose labelWidgetAllowance updatablePanes '	classVariableNames: 'TopWindow '	poolDictionaries: ''	category: 'Morphic-Windows'!!Object methodsFor: 'testing' stamp: 'sw 10/20/1999 14:52'!stepAt: millisecondClockValue in: aWindow	^ self stepIn: aWindow! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:16'!stepIn: aWindow	^ self step! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:21'!stepTime		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:22'!stepTimeIn: aSystemWindow		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:26'!wantsStepsIn: aSystemWindow		^ self wantsSteps! !!Object methodsFor: 'updating' stamp: 'sw 10/12/1999 18:15'!handledListVerification	"When a self-updating PluggableListMorph lazily checks to see the state of affairs, it first gives its model an opportunity to handle the list verification itself (this is appropriate for some models, such as VersionsBrowser); if a list's model has indeed handled things itself, it returns true here"	^ false! !!Object methodsFor: 'updating' stamp: 'sw 10/19/1999 14:39'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Object methodsFor: 'user interface' stamp: 'sw 10/16/1999 22:45'!modelWakeUpIn: aWindow	"A window with me as model is being entered or expanded.  Default response is no-op" 	self modelWakeUp! !!ClassOrganizer methodsFor: 'method dictionary' stamp: 'sw 10/20/1999 16:24'!renameCategory: oldCatString toBe: newCatString	"Rename a category. No action if new name already exists, or if old name does not exist."	| index oldCategory newCategory |	oldCategory _ oldCatString asSymbol.	newCategory _ newCatString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^ self].	"new name exists, so no action"	(index _ categoryArray indexOf: oldCategory) = 0		ifTrue: [^ self].	"old name not found, so no action"	categoryArray _ categoryArray copy.  "need to change identity so smart list update will notice the change"	categoryArray at: index put: newCategory! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/10/1999 13:59'!currentCompiledMethod: aMethod	currentCompiledMethod _ aMethod! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 17:29'!didCodeChangeElsewhere	| aClass aSelector |	"Determine whether the code for the currently selected method and class has been changed somewhere else."	currentCompiledMethod ifNil: [^ false].	(aClass _ self selectedClassOrMetaClass) ifNil: [^ false].	(aSelector _ self selectedMessageName) ifNil: [^ false].	^ (aClass compiledMethodAt: aSelector ifAbsent: [nil]) ~~ currentCompiledMethod	! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 08:36'!modelWakeUpIn: aWindow	self updateListsAndCodeIn: aWindow! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 08:37'!stepIn: aSystemWindow	self updateListsAndCodeIn: aSystemWindow! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 17:30'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue:			[self hasUnacceptedEdits				ifFalse:					[contents _ nil.					self contentsChanged]				ifTrue:					[self changed: #codeChangedElsewhere]]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 14:14'!updateListsAndCodeIn: aWindow	super updateListsAndCodeIn: aWindow.	self updateCodePaneIfNeeded! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/20/1999 12:22'!wantsStepsIn: aWindow	^ Preferences smartUpdating! !!CodeHolder methodsFor: 'object fileIn' stamp: 'sw 10/19/1999 15:38'!convertdcs0: varDict dcscm0: smartRefStrm	"These variables are automatically stored into the new instance ('showDiffs' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('currentCompiledMethod' 'methodChangedElsewhere' )  If a non-nil value is needed, please assign it."! !!Browser methodsFor: 'initialize-release' stamp: 'sw 10/19/1999 10:09'!openAsMorphClassEditing: editString	"Create a pluggable version a Browser on just a single class."	| window switches codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #classListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0@0 extent: 0.5@0.06).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.5@0 extent: 0.5@0.06).	switches borderWidth: 0.	window addMorph: (PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from:	 getRawListSelector: #rawMessageCategoryList)		frame: (0@0.06 extent: 0.5@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0.5@0.06 extent: 0.5@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	window setUpdatablePanesFrom: #(messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 10/19/1999 10:02'!openAsMorphEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane aListMorph baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu: keystroke: #systemCatListKey:from:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0.25@0 extent: 0.25@0.3).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.25@0.3 extent: 0.25@0.1).	switches borderWidth: 0.	window addMorph: (PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from: getRawListSelector: #rawMessageCategoryList)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.4]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.4 corner: 1@0.45).			baseline _ 0.45].	Preferences optionalMorphicButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0 @ baseline corner: 1 @ 1).	window setUpdatablePanesFrom: #(systemCategoryList classList messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 10/19/1999 10:05'!openAsMorphMessageEditing: editString	"Create a pluggable version a Browser that shows just one message"	| window codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0 extent: 1.0@0.06).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.06 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 10/19/1999 10:07'!openAsMorphMsgCatEditing: editString	"Create a pluggable version a Browser on just a messageCategory."	| window codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #messageCatListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageCategoryMenu:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0.06 extent: 1.0@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	window setUpdatablePanesFrom: #(messageCatListSingleton messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 10/19/1999 10:08'!openAsMorphSysCatEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #systemCategoryMenu: keystroke: #systemCatListKey:from:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0@0.06 extent: 0.3333@0.24).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0@0.3 extent: 0.3333@0.06).	switches borderWidth: 0.	window addMorph: (PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from:	 getRawListSelector: #rawMessageCategoryList)		frame: (0.3333@0.06 extent: 0.3333@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0.6666@0.06 extent: 0.3333@0.30).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.36 corner: 1@1).	window setUpdatablePanesFrom: #( classList messageCategoryList messageList).	^ window! !!Browser methodsFor: 'accessing' stamp: 'sw 10/10/1999 21:51'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ Class template: self selectedSystemCategoryName].	editSelection == #editClass 		ifTrue: [^ self selectedClassOrMetaClass definition].	editSelection == #editComment 		ifTrue: [(theClass _ self selectedClass) ifNil: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [ ^ 'This class has not yet been commented.']				ifFalse: [ ^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [^ self selectedClassOrMetaClass sourceCodeTemplate].	editSelection == #editMessage		ifTrue:			[currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	editSelection == #byteCodes ifTrue:		[^ (self selectedClassOrMetaClass compiledMethodAt: 				self selectedMessageName) symbolic asText].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'message category list' stamp: 'sw 10/16/1999 22:56'!rawMessageCategoryList	^ classListIndex = 0		ifTrue: [Array new]		ifFalse: [self classOrMetaClassOrganizer categories]! !!Browser methodsFor: 'message category functions' stamp: 'sw 10/14/1999 16:53'!messageCategoryMenu: aMenu^ aMenu labels:'browseprintOutfileOutreorganizealphabetizeremove empty categoriesnew category...rename...remove'	lines: #(3 7)	selections:		#(buildMessageCategoryBrowser printOutMessageCategories fileOutMessageCategories		editMessageCategories alphabetizeMessageCategories removeEmptyCategories		addCategory renameCategory removeMessageCategory)! !!Browser methodsFor: 'message list' stamp: 'sw 10/10/1999 14:08'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector.	currentCompiledMethod _ method.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil].	self showDiffs ifTrue:		[contents _ self diffFromPriorSourceFor: contents].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!Browser methodsFor: 'message list' stamp: 'sw 10/19/1999 17:39'!selectedMessageName	| aList |	"Answer the message selector of the currently selected message, if any. 	Answer nil otherwise."	messageListIndex = 0 ifTrue: [^ nil].	^ (aList _ self messageList) size >= messageListIndex		ifTrue:			[aList at: messageListIndex]		ifFalse:			[nil]! !!Browser methodsFor: 'message functions' stamp: 'sw 10/10/1999 22:42'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList aClass |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ (aClass _ self selectedClassOrMetaClass)				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ nil].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)]		ifFalse:			[self changed: #annotation].	currentCompiledMethod _ aClass compiledMethodAt: selector.	^ selector! !!ChangeList class methodsFor: 'instance creation' stamp: 'sw 10/19/1999 16:11'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window boundary aListMorph |	window _ (SystemWindow labelled: labelString) model: aChangeList.	Preferences optionalMorphicButtons		ifFalse:			[boundary _ 0]		ifTrue:			[boundary _ 0.08.			window addMorph: aChangeList optionalMorphicButtons frame: (0 @ 0 corner: 1 @ boundary)].	window addMorph: (aListMorph _ (multiSelect ifTrue: [PluggableListMorphOfMany]									ifFalse: [PluggableListMorph])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])			keystroke: nil)		frame: (0@boundary corner: 1@0.4).	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@1).	^ window openInWorld! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/19/1999 14:27'!modelWakeUpIn: aWindow	self updateListsAndCodeIn: aWindow! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/20/1999 15:55'!stepAt: millisecondClockValue in: aWindow	| newText |	(Preferences smartUpdating and: [(millisecondClockValue - self timeOfLastListUpdate) > 8000]) "Not more often than once every 8 seconds"		ifTrue:			[self updateListsAndCodeIn: aWindow.			timeOfLastListUpdate _ millisecondClockValue].	newText _ self contentsIsString		ifTrue: [newText _ self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selection printStringLimitedTo: 5000].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/20/1999 15:54'!timeOfLastListUpdate	^ timeOfLastListUpdate ifNil: [timeOfLastListUpdate _ 0]! !!Inspector methodsFor: 'object fileIn' stamp: 'sw 10/20/1999 16:20'!convertdcos0: varDict dcost0: smartRefStrm	"These variables are automatically stored into the new instance ('object' 'selectionIndex' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('timeOfLastListUpdate' )  If a non-nil value is needed, please assign it."	timeOfLastListUpdate _ 0! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/19/1999 14:38'!horizontalDividerProportion	^ 0.3! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 10/19/1999 16:30'!openAsMorphOn: anObject withLabel: aLabel	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel) model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: ((inspector isMemberOf: DictionaryInspector)						ifTrue: [#dictionaryMenu:]						ifFalse: [#fieldListMenu:])				keystroke: #inspectorKey:from:)		frame: (0@0 corner: self horizontalDividerProportion @ self verticalDividerProportion).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (self horizontalDividerProportion @0 corner: 1@self verticalDividerProportion).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@self verticalDividerProportion corner: 1@1).	window setUpdatablePanesFrom: #(fieldList).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/19/1999 14:38'!verticalDividerProportion	^ 0.7! !!InspectorBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 10:11'!openAsMorphOn: anObject	"(InspectorBrowser openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: anObject defaultLabelForInspector)				model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex: menu: #fieldListMenu:)		frame: (0@0 corner: 0.3@0.5).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1.0@0.5).	window addMorph: (PluggableListMorph on: inspector list: #msgList				selected: #msgListIndex changeSelected: #msgListIndex: menu: #msgListMenu:)		frame: (0@0.5 corner: 0.3@1.0).	window addMorph: (PluggableTextMorph on: inspector text: #msgText accept: #msgAccept:from:				readSelection: nil menu: #msgPaneMenu:shifted:)		frame: (0.3@0.5 corner: 1.0@1.0).		window setUpdatablePanesFrom: #(fieldList msgList).	window position: 16@0.  "Room for scroll bar."	^ window! !!MessageSet methodsFor: 'message list' stamp: 'sw 10/10/1999 14:25'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		self showDiffs ifTrue:			[source _ self diffFromPriorSourceFor: source].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'contents' stamp: 'sw 10/10/1999 14:15'!contents	^ contents == nil		ifTrue: [currentCompiledMethod _ nil.  '']		ifFalse: [messageListIndex = 0 			ifTrue: [currentCompiledMethod _ nil.  contents]			ifFalse: [self selectedMessage]]! !!MessageSet methodsFor: 'contents' stamp: 'sw 10/19/1999 17:30'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits.	Overridden here in order not to set contents to nil"	self didCodeChangeElsewhere		ifTrue:			[self hasUnacceptedEdits				ifFalse:					[self contentsChanged]				ifTrue:					[self changed: #codeChangedElsewhere]]! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'sw 10/10/1999 14:27'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse:			[source _ class sourceMethodAt: selector.			currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil]..			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 10/19/1999 10:12'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph aTextMorph baseline |	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: (0@0 extent: 1@0.2).	Preferences useAnnotationPanes		ifFalse:			[baseline  _ 0.2]		ifTrue:			[aTextMorph _ PluggableTextMorph on: aMessageSet					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.2 corner: 1@0.25).			baseline _ 0.25].	Preferences optionalMorphicButtons		ifTrue:			[window addMorph: aMessageSet optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@baseline corner: 1@1).		window setUpdatablePanesFrom: #(messageList).	window openInWorld: aWorld! !!Morph methodsFor: 'accessing' stamp: 'sw 10/18/1999 14:12'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(addFullHandles					'More halo handles')		(addSimpleHandles				'Fewer halo handles')		(chooseEmphasisOrAlignment		'Emphasis & alignment')		(chooseFont						'Change font')		(chooseStyle						'Change style')		(dismiss							'Remove')		(doDebug:with:					'Debug')		(doDirection:with:				'Forward direction')		(doDup:with:					'Duplicate')		(doMenu:with:					'Menu')		(doGrab:with:					'Pick up')		(editDrawing					'Repaint')		(maybeDoDup:with:				'Duplicate')		(makeNascentScript				'Make a scratch script')		(makeNewDrawingWithin		'Paint new object')		(mouseDownInDimissHandle:with:	'Move to trash')		(mouseDownOnHelpHandle:		'Help')		(openViewerForArgument		'Open a Viewer for me')		(paintBackground				'Paint background')		(startDrag:with:					'Move')		(startGrow:with:					'Change size') 		(startRot:with:					'Rotate')		(startScale:with:					'Change scale') 		(tearOffTile						'Make a tile representing this object')		(trackCenterOfRotation:with:		'Set center of rotation')) 	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'drawing' stamp: 'sw 10/10/1999 23:25'!refreshWorld	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld displayWorldSafely]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 10/20/1999 15:20'!stepAt: millisecondClockValue	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message.	The millisecondClockValue parameter gives the value of the millisecond clock at the moment of dispatch.	Default is to dispatch to the parameterless step method for the morph, but this protocol makes it possible for some morphs to do differing things depending on the clock value"		self step! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 10/19/1999 08:31'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self isPartsDonor ifTrue: [^ false].	self player wantsSteps ifTrue: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/19/1999 16:13'!categoryChoice: aCategory	"Temporarily switch-hits in support of two competing ui designs for the list"	| bin actualPane |	((actualPane _ namePane renderedMorph) isKindOf: StringMorph)		ifTrue:			[namePane contents: aCategory; color: Color black]		ifFalse:			[(actualPane isKindOf: RectangleMorph)				ifTrue:	[actualPane firstSubmorph contents: aCategory; color: Color black.						actualPane extent: actualPane firstSubmorph extent]				ifFalse:					[actualPane selection: (scriptedPlayer categories indexOf: aCategory)]].	bin _ PhraseWrapperMorph new borderWidth: 0; orientation: #vertical.	bin addAllMorphs:		((scriptedPlayer tilePhrasesForCategory: aCategory inViewer: self) collect:			[:aViewerRow | self viewerEntryFor: aViewerRow]).	bin enforceTileColorPolicy.	submorphs size < 2		ifTrue:			[self addMorphBack: bin]		ifFalse:			[self replaceSubmorph: self listPane by: bin].	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 10/19/1999 16:14'!addHeaderMorph	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	header addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Delete this Viewer'.	header addTransparentSpacerOfSize: 5@5.	Preferences useCategoryListsInViewers		ifFalse:			[header addUpDownArrowsFor: self.			(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.				wrpr submorphs first  setBalloonText: 'next category'].	header beSticky.	self addMorph: header.	namePane _ RectangleMorph newSticky color: Color brown veryMuchLighter.	namePane borderWidth: 0.	aButton _ (StringButtonMorph contents: '-----' "font: ScriptingSystem fontForScriptorButtons") color: Color black.	aButton target: self; arguments: Array new; actionSelector: #chooseCategory.	aButton actWhen: #buttonDown.	namePane addMorph: aButton.	aButton position: namePane position.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category (click here to choose a different one)'.	header addMorphBack: namePane.	(namePane isKindOf: RectangleMorph) ifTrue:		[namePane addDropShadow.		namePane owner color: Color gray].	self categoryChoice: 'basic'! !!PasteUpMorph methodsFor: 'stepping' stamp: 'sw 10/20/1999 15:50'!runStepMethods	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	self stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < self lastStepTime) or: [(now - self lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[self stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == self			ifTrue:				[wakeupTime <= now					ifTrue:						[morphToStep stepAt: now.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]]] 	ifError: [:err :rcvr |		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	self lastStepTime: now.! !!Player methodsFor: 'scripts-execution' stamp: 'sw 10/19/1999 08:30'!wantsSteps	"UnscriptedPlayer, with no scripts, overrides to false"	^ true! !!PluggableListMorph methodsFor: 'updating' stamp: 'sw 10/19/1999 14:42'!verifyContents	| newList existingSelection anIndex |	"Called periodically, or at least on window reactivation to react to possible structural changes.  Update contents if necessary."	newList _ self getList.	((list == newList) "fastest" or: [list = newList]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection _ selection.	self list: newList.	(anIndex _ newList indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[self selectionIndex: anIndex]		ifNil:			[self changeModelSelection: 0]! !!PluggableListMorph methodsFor: 'object fileIn' stamp: 'sw 10/19/1999 15:38'!convertbosfcebbmsopssrsggslssggskafll0: varDict bosfcebbmsopssrsggslssggskafllvs0: smartRefStrm	"These variables are automatically stored into the new instance ('list' 'selectedMorph' 'selection' 'getListSelector' 'getIndexSelector' 'setIndexSelector' 'keystrokeActionSelector' 'autoDeselect' 'font' 'lastKeystrokeTime' 'lastKeystrokes' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('verifyContinuously' 'stepInterval' )  If a non-nil value is needed, please assign it."! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/18/1999 11:59'!getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special '-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector == nil ifTrue: ["should not happen!!" priorRawList _ nil.  ^ #()].	model classListIndex = 0 ifTrue: [^ priorRawList _ Array new].	priorRawList _ model perform: getRawListSelector.	^ (Array with: ClassOrganizer allCategory), priorRawList! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/16/1999 22:32'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel.	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	getRawListSelector _ getRawSel.	self list: self getList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 23:12'!verifyContents		| newList existingSelection anIndex newRawList |	model classListIndex = 0 ifTrue: [^ self].	newRawList _ model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList _ newRawList.	newList _ (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	self flash.  "could get annoying, but hell"	existingSelection _ selection.	self list: newList.	(anIndex _ newList indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[self changeModelSelection: anIndex]		ifNil:			[self changeModelSelection: 0]! !!PluggableMessageCategoryListMorph class methodsFor: 'as yet unclassified' stamp: 'sw 10/16/1999 22:39'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel.	^ self new on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'sw 10/10/1999 23:01'!initialize	super initialize.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 10/14/1999 07:42'!accept	"Inform the model of text to be accepted, and return true if OK."	| textToAccept ok |	self canDiscardEdits ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method has been changed elsewheresince you started editing it here.  Accept anyway?') ifFalse: [^ self flash]].	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!PluggableTextMorph methodsFor: 'updating' stamp: 'sw 10/10/1999 23:30'!update: aSymbol	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self refreshWorld].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self refreshWorld].	aSymbol == #codeChangedElsewhere ifTrue:			[self hasEditingConflicts: true.			^ self changed]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'sw 10/10/1999 23:26'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	super drawOn: aCanvas. 	self hasEditingConflicts		ifTrue:			[aCanvas frameRectangle: self innerBounds width: 3 color: Color red] 		ifFalse:			[self hasUnacceptedEdits ifTrue:				[aCanvas frameRectangle: self innerBounds width: 1 color: Color red]]! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 23:06'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse:		[hasUnacceptedEdits _ aBoolean.		self changed].	aBoolean ifFalse: [hasEditingConflicts _ false]! !!PluggableTextMorph methodsFor: 'object fileIn' stamp: 'sw 10/19/1999 15:38'!convertbosfcebbmsopssrsggstgsghas0: varDict bosfcebbmsopssrsggstgsghash0: smartRefStrm	"These variables are automatically stored into the new instance ('textMorph' 'getTextSelector' 'setTextSelector' 'getSelectionSelector' 'hasUnacceptedEdits' 'askBeforeDiscardingEdits' 'selectionInterval' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('hasEditingConflicts' )  If a non-nil value is needed, please assign it."! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 10/20/1999 12:21'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld addGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue:		[World ifNotNil: [World fullRepaintNeeded]].	prefSymbol == #optionalMorphicButtons ifTrue:		[Utilities replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent].	(prefSymbol == #optionalMorphicButtons  or: [prefSymbol == #useAnnotationPanes]) ifTrue:		[Utilities replaceBrowserInToolsFlap].	(prefSymbol == #smartUpdating) ifTrue:		[SystemWindow allSubInstancesDo:			[:aWindow | aWindow amendSteppingStatus]]! !!Preferences class methodsFor: 'help' stamp: 'sw 10/20/1999 12:20'!initHelpMsgsC	"Automatically called whenever you call   	Preferences initializeHelpMessages		or	Preferences callHelpMessageInitializersby virtue of its being in the 'help' category of Preferences class"	#(	(allowMVCprojects			'If true, the open... menu will offer you the chance to open an mvc project.')		(autoAccessors			'If true, an attempt to call a message which is not understood by an object but whose selector is the same as an inst var of the object will result in automatic compilation of an accessor method for that object''s class')		(caseSensitiveFinds			'If true, then the "find" command in text will always make its searches in a case-sensitive fashion')		(compressFlashImages			'If true, flash images will automatically be reduced to 8-bit color depth upon being read')		(conversionMethodsAtFileOut			'Governs whether at fileout time you should be prompted to define conversion methods where deemed appropriate.')		(extractFlashInHighQuality			'Whether flash graphics should be extracted in high quality.')		(extractFlashInHighestQuality			'Whether flash graphics should be extracted in highest possible quality.')		(preserveTrash			'Whether morphs dismissed via halo or dragged into the Trash should be preserved in the TrashCan for possible future retrieval.  If false, they are not preserved.')		(smartUpdating			'If true, then morphic tools such as browsers and inspectors will keep their contents up to date automatically, so that if something changes anywhere, the change will be reflected everywhere.')			) do:		[:pair | HelpDictionary at: pair first put: 			(pair first, ':', pair last)]! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/20/1999 12:22'!smartUpdating	^ self valueOfFlag: #smartUpdating! !!Preferences class methodsFor: 'initial values' stamp: 'sw 10/20/1999 12:20'!initialValuesA	"Another lot of initial values for prefs.  Simply placing methods of this sort here will assure that the initial values provided are ascribed to the preference when prefs are initialized"	^#(	(conversionMethodsAtFileOut			false)		(menuColorFromWorld				false)		(viewersInFlaps						true)		(oneViewerFlapAtATime				true)		(optionalMorphicButtons				false)		(preserveTrash						true)		(caseSensitiveFinds					false)		(smartUpdating						true))! !!RecentMessageSet methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 17:33'!contents: c notifying: n	| result |	result _ super contents: c notifying: n.	result == true ifTrue:		[self reformulateList].	^ result! !!RecentMessageSet methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 17:33'!reformulateList	self initializeMessageList: Utilities recentlySubmittedMessages.	self messageListIndex: (messageList size min: 1).	"0 or 1"	self changed: #messageList.	self changed: #messageListIndex! !!RecentMessageSet methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 22:32'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifFalse: [^ self].	Utilities mostRecentlySubmittedMessage = messageList first		ifFalse:			[self reformulateList]		ifTrue:			[self updateCodePaneIfNeeded]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 10/20/1999 09:52'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view isCollapsed ifFalse: [model modelWakeUpIn: view]! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 10/20/1999 09:46'!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUpIn: self]! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/20/1999 12:26'!updatablePanes	"Answer the list of panes, in order, which might be sent the #verifyContents message, at least upon window activation or expansion."	self flag: #deferred.	"To bring a level of automatic list updating to mvc windows, we can add an updatablePanes instance var to StandardSystemView, and set the panes as part of browser/inspector creation, and return those panes here, and in PluggableListView put code comparable to that in PluggableListMorph to get things updated"	^ #()! !!SystemWindow methodsFor: 'initialization' stamp: 'sw 10/19/1999 09:53'!initialize	| aFont |	super initialize.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: (TextStyle default fontAt: 2) emphasis: 1).	self setLabelWidgetAllowance.	self addCloseBox.	self addMenuControl.	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	Preferences noviceMode ifTrue:		[closeBox ifNotNil: [closeBox setBalloonText: 'close window'].		menuBox ifNotNil: [menuBox setBalloonText: 'window menu'].		collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].	self on: #mouseEnter send: #spawnReframeHandle: to: self.	self on: #mouseLeave send: #spawnReframeHandle: to: self.	label on: #mouseDown send: #relabelEvent: to: self.	self extent: 300@200.	mustNotClose _ false.	updatablePanes _ Array new.! !!SystemWindow methodsFor: 'top window' stamp: 'sw 10/16/1999 22:48'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph sketchEditor pal |	outerMorph _ self topRendererOrSelf.	outerMorph owner ifNil: [^ self "avoid spurious activate when drop in trash"].	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self isCollapsed ifFalse:		[model modelWakeUpIn: self.		self positionSubmorphs].	(sketchEditor _ self extantSketchEditor) ifNotNil:		[sketchEditor comeToFront.		(pal _ self world findA: PaintBoxMorph) ifNotNil:			[pal comeToFront]]! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:44'!paneMorphSatisfying: aBlock	^ paneMorphs detect: [:aPane | aBlock value: aPane] ifNone: [nil]! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:50'!setUpdatablePanesFrom: getSelectors	| aList aPane |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList _ OrderedCollection new.	getSelectors do:		[:sel | aPane _ self paneMorphSatisfying:				[:pane | (pane isKindOf: PluggableListMorph) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: pane ', sel, ' not found.']].	updatablePanes _ aList asArray! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:53'!updatablePanes	"Answer the list of panes, in order, which should be sent the #verifyContents message"	^ updatablePanes ifNil: [updatablePanes _ #()]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 09:30'!amendSteppingStatus	"Circumstances having changed, find out whether stepping is wanted and assure that the new policy is carried out"	self wantsSteps		ifTrue:			[self arrangeToStartStepping]		ifFalse:			[self stopStepping]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 08:16'!step	model ifNotNil: [model stepIn: self]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/20/1999 15:48'!stepAt: millisecondClockValue	model ifNotNil: [model stepAt: millisecondClockValue in: self]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 08:22'!stepTime	^ model		ifNotNil:			[model stepTimeIn: self]		ifNil:			[200] "milliseconds"! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 09:33'!wantsSteps	"Return true if the model wants its view to be stepped."	self isPartsDonor ifTrue: [^ false].	self player wantsSteps ifTrue: [^ true].	^ model wantsStepsIn: self! !!SystemWindow methodsFor: 'object fileIn' stamp: 'sw 10/19/1999 15:38'!convertbosfcebbmsolslccappcfimml0: varDict bosfcebbmsolslccappcfimmlu0: smartRefStrm	"These variables are automatically stored into the new instance ('labelString' 'stripes' 'label' 'closeBox' 'collapseBox' 'activeOnlyOnTop' 'paneMorphs' 'paneRects' 'collapsedFrame' 'fullFrame' 'isCollapsed' 'menuBox' 'mustNotClose' 'labelWidgetAllowance' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: ('updatablePanes' )  If a non-nil value is needed, please assign it."! !!UnscriptedPlayer methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 08:30'!wantsSteps	"Has no scripts"	^ false! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 10/20/1999 13:48'!setClassAndSelectorFrom: messageIDString in: csBlock	"Decode strings of the form <className> [class] <selectorName>.   If <className> does not exist as a class, use nil for the class in the block"	| aStream aClass maybeClass sel |	aStream _ ReadStream on: messageIDString.	aClass _ Smalltalk at: (aStream upTo: $ ) asSymbol ifAbsent: [nil].	maybeClass _ aStream upTo: $ .	sel _ aStream upTo: $ .	((maybeClass = 'class') & (sel size ~= 0))		ifTrue:			[aClass				ifNil:					[csBlock value: nil value: sel asSymbol]				ifNotNil:					[csBlock value: aClass class value: sel asSymbol]]		ifFalse:			[csBlock value: aClass value: maybeClass asSymbol]"Utilities setClassAndSelectorFrom: 'Utilities class oppositeModeTo:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString].Utilities setClassAndSelectorFrom: 'MessageSet setClassAndSelectorIn:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString]."! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 10/19/1999 17:52'!mostRecentlySubmittedMessage	^ RecentSubmissions last! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 10/20/1999 14:03'!purgeRecentSubmissionsOfMissingMethods	"Utilities purgeRecentSubmissionsOfMissingMethods"	| result |	RecentSubmissions _ RecentSubmissions select:		[:aSubmission |			Utilities setClassAndSelectorFrom: aSubmission in: 				[:aClass :aSelector |					result _ aClass notNil and: [(aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil]].			result]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 10/20/1999 14:01'!noteMethodSubmission: selectorName forClass: className	| aSubmission |	self purgeRecentSubmissionsOfMissingMethods.	aSubmission _ className asString, ' ', selectorName.	(self recentMethodSubmissions includes: aSubmission)		ifTrue:			[RecentSubmissions remove: aSubmission]		ifFalse:			[(RecentSubmissions size >= self numberOfRecentSubmissionsToStore) 				ifTrue: [RecentSubmissions removeFirst]].	RecentSubmissions addLast: aSubmission! !!WorldState methodsFor: 'stepping' stamp: 'sw 10/20/1999 14:50'!runStepMethodsIn: aWorld	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == aWorld			ifTrue:				[wakeupTime <= now					ifTrue:						[morphToStep stepAt: now.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]]]	 ifError: [:err :rcvr |		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now! !CodeHolder removeSelector: #addModelItemsToWindowMenu:!Inspector removeSelector: #step!PluggableListMorph removeSelector: #initialize!PluggableListMorph removeSelector: #step!PluggableListMorph removeSelector: #stepTime!PluggableListMorph removeSelector: #wantsSteps!RecentMessageSet removeSelector: #initializeMessageList:!RecentMessageSet removeSelector: #getNewMessageList!"Postscript:"Preferences initializeAddedPreferences.Preferences callHelpMessageInitializers. Utilities replaceBrowserInToolsFlap.!