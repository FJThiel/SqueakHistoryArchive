'From Squeak2.9alpha of 26 July 2000 [latest update: #2487] on 15 August 2000 at 12:39:21 pm'!"Change Set:		etoyChgsTwo-swDate:			15 August 2000Author:			Scott Wallace(1)  Fixes the long-standing problem that multiple not-explicitly-named morphs of the same class would show the same 'innocuousName' in halos, giving the startling illusion that many guys have the same name; the fix is to assign an explicit name to any unnamed morph at the time a halo is requested for it.  (fixes problem seen by bj/alan/kim on 9 Aug).(2)  Rewords the balloon help for the tan 'dismiss' buttons in viewers so that they do not use the word 'delete' (As per Kim/BJ request).(3)  Allows individual classes to suppress the 'recompiling...' progress bar, to permit, for example, such notification to be avoided when constructing a tile script.(4)  When the 'eToyFriendly' preference is toggled, a variety of other preference settings and (in time) other configuration info are changed wholesale.(5)  Changes wording of the menu item allowing for spawning a fresh instance of the same uniclass -- it now reads 'make a sibling instance' (per ack conversation in Cannes.)(6)  Several fixes involving the dismissal of script editors for morphs that themselves are no longer on the screen."!!ClassBuilder methodsFor: 'private' stamp: 'sw 7/31/2000 12:57'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	currentClassIndex _ currentClassIndex + 1.	(aClass hasMethods and: [aClass wantsRecompilationProgressReported]) ifTrue:		[progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')]! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 7/31/2000 12:55'!wantsRecompilationProgressReported	"Answer whether the receiver would like progress of its recompilation reported interactively to the user."	^ true! !!Metaclass methodsFor: 'compiling' stamp: 'sw 7/31/2000 14:29'!wantsRecompilationProgressReported	"The metaclass follows the rule of the class itself."	^ thisClass wantsRecompilationProgressReported! !!Morph methodsFor: 'menus' stamp: 'sw 7/31/2000 17:43'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' action: #makeNewPlayerInstance.		aMenu balloonTextForLastItem: 'makes another morph whose player is of the same class as this one'].	aMenu addLine.	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	"Add the fill style items"	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'player' stamp: 'sw 8/10/2000 00:06'!assureExternalName	| aName |	^ (aName _ self knownName) ifNil:		[self setNameTo: (aName _ self externalName).		^ aName]! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 8/10/2000 00:15'!addHeaderMorph	| header aFont aButton wrpr |	header _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ Preferences standardButtonFont.	header addMorph: (aButton _ SimpleButtonMorph new label: 'O' font: aFont).	aButton target: self;			color:  Color tan;			actionSelector: #delete;			setBalloonText: 'remove this pane from the screendon''t worry -- nothing will be lost!!.'.	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	(wrpr _ header submorphs last) submorphs second setBalloonText: 'previous category'.		wrpr submorphs first  setBalloonText: 'next category'.	header beSticky.	self addMorph: header.	namePane _ RectangleMorph newSticky color: Color brown veryMuchLighter.	namePane borderWidth: 0.	aButton _ (StringButtonMorph contents: '-----' font: (StrikeFont familyName: #NewYork size: 12)) color: Color black.	aButton target: self; arguments: Array new; actionSelector: #chooseCategory.	aButton actWhen: #buttonDown.	namePane addMorph: aButton.	aButton position: namePane position.	namePane align: namePane topLeft with: (bounds topLeft + (50 @ 0)).	namePane setBalloonText: 'category (click here to choose a different one)'.	header addMorphBack: namePane.	(namePane isKindOf: RectangleMorph) ifTrue:		[namePane addDropShadow.		namePane owner color: Color gray].	self categoryChoice: 'basic'! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/10/2000 00:12'!addHandlesForWorldHalos	| box |	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ self world bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget assureExternalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/10/2000 00:07'!addName	self addNameBeneath: self basicBox string: target assureExternalName! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/15/2000 11:58'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating"	| aMenu selector reply elementType |	elementType _ self elementTypeFor: anElement.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].		self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu _ MVCMenuMorph new.	(elementType == #userScript)		ifTrue: 			[aMenu add: 'destroy "', anElement, '"' action: #removeScript.			aMenu add: 'rename  "', anElement, '"' action: #renameScript.			"aMenu add: 'pacify "', anElement, '"' action: #pacifyScript"].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString, ' (', elementType, ')'.	selector _ anElement asSymbol.	reply _  aMenu invokeAt: aViewer primaryHand position in: aViewer world.	reply == nil ifTrue: [^ self].	reply == #removeScript ifTrue: [^ self removeScript: selector fromWorld: aViewer world].	reply == #renameScript ifTrue: [^ self renameScript:  selector].	reply == #pacifyScript ifTrue: [^ self pacifyScript: selector]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/15/2000 11:56'!removeScript: aSymbol fromWorld: aWorld	self removeScriptWithoutUpdatingViewers: aSymbol fromWorld: aWorld.	self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/15/2000 11:57'!removeScriptWithoutUpdatingViewers: aSymbol fromWorld: aWorld	self pacifyScript: aSymbol.	self class removeScriptNamed: aSymbol.	(self scriptorsForSelector: aSymbol inWorld: aWorld) do:		[:s | s privateDelete].! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/15/2000 11:53'!scriptorsForSelector: aSelector inWorld: aWorld	| scriptors |	aWorld ifNil: [^ OrderedCollection new].	scriptors _ (aWorld allMorphs select:		[:m | (((m isKindOf: ScriptEditorMorph) and: [m playerScripted == self]) and: [m scriptName == aSelector])] thenCollect: [:m | m topEditor]) asSet.	^ scriptors asArray! !!Player class methodsFor: 'other' stamp: 'sw 7/31/2000 12:57'!wantsRecompilationProgressReported	"Report progress for Player itself, but not for automatically-created subclasses like Player1, Player2"	^ self == Player or:		[(self class name beginsWith: 'Player') not]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 8/12/2000 01:26'!enableOrDisable: preferenceNameSymbol asPer: aBoolean	"either enable or disable the given Preference, depending on the value of aBoolean"	aBoolean ifTrue: [self enable: preferenceNameSymbol] ifFalse: [self disable: preferenceNameSymbol]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 8/12/2000 00:52'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action"	| keep |	prefSymbol == #useGlobalFlaps ifTrue:		[aBoolean			ifFalse:		"Turning off use of flaps"				[keep _ self confirm:'Do you want to preserve the existingglobal flaps for future use?'.				Utilities globalFlapTabsIfAny do:					[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: keep.					aFlapTab isInWorld ifTrue: [self error: 'Flap problem']].				keep ifFalse: [Utilities clobberFlapTabList]]			ifTrue:		"Turning on use of flaps"				[Smalltalk isMorphic ifTrue:					[self currentWorld addGlobalFlaps]]].	prefSymbol == #roundedWindowCorners ifTrue: [Display repaintMorphicDisplay].	prefSymbol == #optionalButtons ifTrue:		[Utilities replacePartSatisfying: [:el | (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented model isKindOf: FileList]]]inGlobalFlapSatisfying: [:f1 | f1 wording = 'Tools'] with:  FileList openAsMorph applyModelExtent].	(prefSymbol == #optionalButtons  or: [prefSymbol == #annotationPanes]) ifTrue:		[Utilities replaceBrowserInToolsFlap].	(prefSymbol == #smartUpdating) ifTrue:		[SystemWindow allSubInstancesDo:			[:aWindow | aWindow amendSteppingStatus]].	(prefSymbol == #eToyFriendly) ifTrue:		[ScriptingSystem customizeForEToyUsers: aBoolean]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 8/15/2000 11:58'!destroyScript	| aMenu reply |	(self confirm: 'Caution -- this destroys this scriptpermanently; are you sure you want to do this?') ifFalse: [^ self].	true ifTrue: [^ playerScripted removeScript: scriptName fromWorld: self world].	self flag: #deferred.  "revisit"	(playerScripted okayToDestroyScriptNamed: scriptName)		ifFalse:			[^ self inform: 'Sorry, this script is being calledfrom another script.'].	(self isAnonymous not and: [submorphs size > 1]) ifTrue:		[aMenu _ SelectionMenu selections: #('destroy it' 'oops, no, don''t destroy').		reply _ aMenu startUpWithCaption: 'Do you really want todestroy this script?'.		(reply = 'destroy it') ifFalse: [^ self]].	self actuallyDestroyScript! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 8/15/2000 11:58'!dismiss	| aMenu reply |	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	self isAnonymous		ifTrue:			[((submorphs size > 3) or: [self scriptInstantiation status ~~ #normal]) ifTrue:				[aMenu _ SelectionMenu selections: #('yes, name it' 'no, discard it' 'cancel').				reply _ aMenu startUpWithCaption: 'Do you want to give thisscript a name and save it? '.				(reply isEmptyOrNil or: [reply = 'cancel']) ifTrue: [^ self].				(reply = 'yes, name it') ifTrue: [^ self renameScript]].		self actuallyDestroyScript].	(playerScripted isExpendableScript: scriptName) ifTrue: [playerScripted removeScript: scriptName  fromWorld: self world].	self delete! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/12/2000 01:24'!customizeForEToyUsers: aBoolean	"If aBoolean is true, set things up for etoy users.  If it's false, unset some of those things.  Some things are set when switching into etoy mode but not reversed when switching out of etoy mode" 	#(			(balloonHelpEnabled			yes		dontReverse)		(debugHaloHandle			no		reverse)		(modalColorPickers			yes		dontReverse)		(noviceMode					yes		reverse)		(roundCornersWherePossible	yes		dontReverse)		(useUndo					yes		dontReverse)		(warnIfNoChangesFile		no		reverse)		(warnIfNoSourcesFile		no		reverse)) do:			[:trip |				(aBoolean or: [trip third == #reverse]) ifTrue:					[Preferences enableOrDisable: trip first asPer:						((trip second == #yes) & aBoolean) | ((trip second == #no) & aBoolean not)]]! !!StandardViewer methodsFor: 'as yet unclassified' stamp: 'sw 8/10/2000 00:16'!addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean	| header aFont aButton aTextMorph nail wrpr costs headWrapper inner |	header _ AlignmentMorph newRow color: self color muchLighter; centering: #center.	aFont _ Preferences standardButtonFont.	aBoolean ifTrue:		[header addMorph: (aButton _ SimpleButtonMorph new label: 'O' font: aFont).		aButton target: self;				color:  Color tan;				actionSelector: #dismiss;				setBalloonText: 'remove this entire Viewer from the screendon''t worry -- nothing will be lost!!.'.		header addTransparentSpacerOfSize: 4@1].	aButton _ IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: #AddCategoryViewer); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother category pane';			shedSelvedge.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 4@1.	costs _ scriptedPlayer costumes.	costs ifNotNil:	[(costs size > 1 or: [costs size = 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr _ header submorphs last) submorphs second setBalloonText: 'switch to previous costume'.			wrpr submorphs first  setBalloonText: 'switch to next costume']].		(self hasProperty: #noInteriorThumbnail)		ifFalse:			[nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume]		ifTrue:			[inner _ ImageMorph new image: (ScriptingSystem formAtKey: 'Menu').			nail _ RectangleMorph new beTransparent extent: inner extent.			nail addMorph: inner lock].	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuthat will allow you toadd an instance variable,,tear off a tile, etc..'.	(self hasProperty: #noInteriorThumbnail)		ifFalse:			[nail borderWidth: 3; borderColor: #raised].	header addTransparentSpacerOfSize: 5@5."	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	scriptedPlayer costume assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s name.'.		header beSticky.	anInteger > 0		ifTrue:			[headWrapper _ AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: (0 @ anInteger).			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse:			[self addMorph: header]! !