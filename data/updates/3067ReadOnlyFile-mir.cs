'From Squeak2.9alpha of 13 June 2000 [latest update: #2988] on 26 November 2000 at 10:09:22 am'!"Change Set:		255ReadOnlyFile-mirDate:			4 September 2000Author:			Mike RutenbergFiles are usually opened using oldFileNamed: (which allows writing) when in fact they will only be read.  This causes two problems: (1) file opening primitve will fail (to open the file for writing!!) if the file is marked by the OS as readonly (including all files on readonly CDROMs) and (2) the underlying OS will believe the file needs to be locked to facilitate the writing until it is explicitly closed (rarely done!!) or garbage collected.This is a conservative conversion of many uses of oldFileNamed: to readOnlyFileNamed: where it is clear the file is not written.  No other modifications of the methods were done."!!CelesteComposition methodsFor: 'interface' stamp: 'mdr 8/31/2000 18:37'!addAttachment	| file fileResult fileName |	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	"transform into multipart if needed"	self hasAttachments ifFalse: [self transformToMultipart].	"then simply append another attachment section"	(fileResult _ StandardFileMenu oldFile)		ifNotNil: 			[fileName _ fileResult directory fullNameFor: fileResult name.			file _ FileStream readOnlyFileNamed: fileName.			file ifNotNil: [self messageText: ((MailMessage from: self messageText)						asTextEncodingNewPart: file named: fileResult name)]] ! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'mdr 8/31/2000 18:43'!testExamplesFromDisk	"verify messages from file on disk"	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm testExamplesFromDisk"	| msg  sig file publicKey |	file _ FileStream readOnlyFileNamed: 'dsa.test.out'.	[		[file atEnd] whileFalse: [			sig _ file nextChunk.			msg _ file nextChunk.			publicKey _ Compiler evaluate: file nextChunk.			(self verify: sig isSignatureOf: msg publicKey: publicKey) ifTrue: [				Transcript show: 'SUCCESS: ',msg; cr.			] ifFalse: [				self error: 'ERROR!! Signature verification failed'			].		].	] ensure: [file close]! !!DisplayObject class methodsFor: 'fileIn/Out' stamp: 'mdr 8/31/2000 19:11'!collectionFromFileNamed: fileName 	"Answer a collection of Forms read from the external file 	named fileName. The file format is: fileCode, {depth, extent, offset, bits}."	| formList f fileCode |	formList _ OrderedCollection new.	f _ (FileStream readOnlyFileNamed: fileName) binary.	fileCode _ f next.	fileCode = 1		ifTrue: [			[f atEnd] whileFalse: [formList add: (self new readFromOldFormat: f)]]		ifFalse: [			fileCode = 2 ifFalse: [self error: 'unknown Form file format'. ^ formList].			[f atEnd] whileFalse: [formList add: (self new readFrom: f)]].	f close.	^ formList! !!DocLibrary methodsFor: 'doc pane' stamp: 'mdr 8/31/2000 18:48'!docObjectAt: classAndMethod	"Return a morphic object that is the documentation pane for this method.  nil if none can be found.  Look on both the network and the disk."	| fileNames server aUrl strm local obj |	methodVersions size = 0 ifTrue: [self updateMethodVersions].	"first time"	fileNames _ self docNamesAt: classAndMethod.	self assureCacheFolder.	self haveNetwork ifTrue: [		"server _ (ServerDirectory groupNamed: group) clone."  "Note: directory ends with '/updates' which needs to be '/docpane', but altUrl end one level up"		server _ ServerDirectory groupNamed: group.			"later try multiple servers"		aUrl _ server altUrl, 'docpane/'.		fileNames do: [:aVersion | 			strm _ HTTPSocket httpGetNoError: aUrl,aVersion 				args: nil accept: 'application/octet-stream'.			strm class == RWBinaryOrTextStream ifTrue: [				self cache: strm as: aVersion.				strm reset.				obj _ strm fileInObjectAndCode asMorph.				(obj valueOfProperty: #classAndMethod) = classAndMethod ifFalse: [					self inform: 'suspicious object'.					obj setProperty: #classAndMethod toValue: classAndMethod].				^ obj].	"The pasteUpMorph itself"			"If file not there, error 404, just keep going"]].	local _ ServerDirectory new fullPath: DocsCachePath.	"check that it is really there -- let user respecify"	fileNames do: [:aVersion | 		(local includesKey: aVersion) ifTrue: [			strm _ local readOnlyFileNamed: aVersion.			obj _ strm fileInObjectAndCode asMorph.			(obj valueOfProperty: #classAndMethod) = classAndMethod ifFalse: [				self inform: 'suspicious object'.				obj setProperty: #classAndMethod toValue: classAndMethod].			Transcript cr; show: 'local cache: ', aVersion.			^ obj].	"The pasteUpMorph itself"		"If file not there, just keep looking"].	"Never been documented"	^ nil! !!FileList methodsFor: 'file list menu' stamp: 'mdr 8/31/2000 18:50'!browseChanges	"Browse the selected file in fileIn format."	fileName		ifNotNil:			[ChangeList browseStream: (directory readOnlyFileNamed: fileName)]		ifNil:			[self beep].! !!FileList methodsFor: 'file list menu' stamp: 'mdr 8/31/2000 18:58'!openBookFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world"	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory readOnlyFileNamed: self fullName.	book _ BookMorph new.	book setProperty: #url toValue: aFileStream url.	book fromRemoteStream: aFileStream.	aFileStream close.	Smalltalk isMorphic 		ifTrue: [Display getCurrentMorphicWorld addMorphsAndModel: book]		ifFalse:			[book isMorph ifFalse: [^ self errorMustBeMorph].			book openInWorld].	book goToPage: 1! !!FileList methodsFor: 'file list menu' stamp: 'mdr 8/31/2000 18:59'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory readOnlyFileNamed: self fullName.	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [Display getCurrentMorphicWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [^ self errorMustBeMorph].			morphOrList openInWorld]! !!FileList methodsFor: 'file list menu' stamp: 'mdr 8/31/2000 18:52'!playMidiFile	"Play a MIDI file." 	| f score |	Smalltalk at: #MIDIFileReader ifPresent: [:midiReader |		Smalltalk at: #ScorePlayerMorph ifPresent: [:scorePlayer |			f _ (directory readOnlyFileNamed: self fullName) binary.			score _ (midiReader new readMIDIFrom: f) asScore.			f close.			scorePlayer openOn: score title: fileName]].! !!FontSet class methodsFor: 'private' stamp: 'mdr 8/31/2000 19:18'!compileFont: strikeFont 	| tempName literalString header |	tempName _ 'FontTemp.sf2'.	strikeFont writeAsStrike2named: tempName.	literalString _ (FileStream readOnlyFileNamed: tempName) contentsOfEntireFile printString.	header _ 'sizeNNN	^ self fontNamed: ''NNN'' fromLiteral:' copyReplaceAll: 'NNN' with: strikeFont name.	self class		compile: header , literalString		classified: 'fonts'		notifying: nil.	FileDirectory default deleteFileNamed: tempName!]style[(13 10 4 30 4 8 3 14 3 10 22 8 3 13 4 10 20 8 37 6 3 50 17 5 7 10 8 4 18 6 3 13 15 7 14 3 3 13 26 8)f1b,f1cblack;b,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;,f1,f1cblue;,f1,f1cblack;,f1,f1cblack;,f1,f1cblack;! !!Form class methodsFor: 'BMP file reading' stamp: 'mdr 8/31/2000 19:01'!fromBMPFileNamed: fileName	"Form fromBMPFileNamed: 'FulS.bmp'"	| fileStream result |	fileStream _ (FileStream readOnlyFileNamed: fileName) binary.	result _ self fromBMPFile: fileStream.	fileStream close.	^ result! !!ImageSegment methodsFor: 'read/write segment' stamp: 'mdr 8/31/2000 19:01'!readFromFile	"Read in a simple segment.  Use folder of this image, even if remembered as previous location of this image"	| ff realName |	realName _ self class folder, FileDirectory slash, self localName.	ff _ FileStream readOnlyFileNamed: realName.	segment _ ff nextWordsInto: (WordArrayForSegment new: ff size//4).	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	ff close.	state _ #active! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'mdr 9/4/2000 10:43'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes |	"open image file and read the header"	f _ FileStream readOnlyFileNamed: fileName.	imageName _ f fullName.	f binary.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	(self readableFormat: version)		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'mdr 9/4/2000 10:45'!primitiveFileOpen	| namePointer writeFlag fileName f |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [(FileStream fileNamed: fileName) binary]			ifFalse: [(StandardFileStream isAFileNamed: fileName)				ifTrue: [f _ (FileStream readOnlyFileNamed: fileName).						f ifNil:[^self primitiveFail] ifNotNil:[f binary]]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]! !!Morph methodsFor: 'fileIn/out' stamp: 'mdr 9/4/2000 10:46'!updateFromResource	| pathName newMorph f |	(pathName _ self valueOfProperty: #resourceFilePath) ifNil: [^ self].	(pathName asLowercase endsWith: '.morph')		ifTrue:			[newMorph _ (FileStream readOnlyFileNamed: pathName) fileInObjectAndCode.			(newMorph isKindOf: Morph) ifFalse: [^ self error: 'Resource not a single morph']]		ifFalse:			[f _ Form fromFileNamed: pathName.			f ifNil: [^ self error: 'unrecognized image file format'].			newMorph _ SketchMorph withForm: f].	newMorph setProperty: #resourceFilePath toValue: pathName.	self owner replaceSubmorph: self by: newMorph! !!CrosticPanel methodsFor: 'menu' stamp: 'mdr 8/31/2000 18:43'!openFile	| stdFileMenuResult crostic file |	stdFileMenuResult _ ((StandardFileMenu new) pattern: '*.crostic'; 		oldFileFrom: FileDirectory default ) 			startUpWithCaption: 'Select a Crostic File...'.	stdFileMenuResult ifNil: [^ nil].	file _ stdFileMenuResult directory readOnlyFileNamed: stdFileMenuResult name.	crostic _ CrosticPanel newFromFile: file.  file close.	(self isClean or: [self confirm: 'Is it OK to discard this crostic?'])		ifTrue: [self world addMorphFront: (crostic position: self position).				self delete]		ifFalse: [self world addMorphFront: crostic].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:00'!readTape: fileName 	| file |	self writeCheck.	(FileStream isAFileNamed: fileName) ifFalse: [^ nil].	file _ FileStream oldFileNamed: fileName.	tape _ self readFrom: file.	file close.	saved _ true  "Still exists on file"! !!EventRecorderMorph class methodsFor: 'instance creation' stamp: 'mdr 8/31/2000 18:48'!fromFileNamed: aFileName	| file answer |	file _ FileStream readOnlyFileNamed: aFileName.	answer _ self readFrom: file.	file close.	^ answer! !!Password methodsFor: 'as yet unclassified' stamp: 'mdr 9/4/2000 10:47'!serverPasswords	"Get the server passwords off the disk and decode them. The file 'sqk.info' must be in the same folder as the Squeak application (VM) that is running this image. (Note: This code works even if you are running with no system sources file.)"	| dir encodedPasswords |	dir _ FileDirectory on: Smalltalk vmPath.	(dir fileExists: 'sqk.info') ifFalse: [^ nil].	"Caller will ask user for password"	encodedPasswords _ (dir readOnlyFileNamed: 'sqk.info') contentsOfEntireFile.		"If you don't have this file, and you really do want to release 		an update, contact Ted Kaehler."	^ (self decode: encodedPasswords) findTokens: String cr! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'mdr 9/4/2000 10:47'!readPhonemes	"Read a previously saved phoneme set from a file."	| fname s newPhonemes |	fname _ Utilities		chooseFileWithSuffixFromList: #('.pho' '.phonemes')		withCaption: 'Phoneme file?'.	fname == nil ifTrue: [^ self].	fname ifNil: [^ self].	s _ FileStream readOnlyFileNamed: fname.	newPhonemes _ s fileInObjectAndCode.	s close.	phonemeRecords _ newPhonemes.! !!ServerAction methodsFor: 'URL processing' stamp: 'mdr 9/4/2000 10:52'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1),		(ServerAction pathSeparator), (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName)		ifTrue: ["maybe send out content-length?"			request reply: (PWS success),(PWS content: imageGif), PWS crlf.			request reply: (FileStream readOnlyFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !!StrikeFont methodsFor: 'file in/out' stamp: 'mdr 9/4/2000 10:56'!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream readOnlyFileNamed: name, '.strike.'.	strike binary.	"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord.	maxAscii		_		strike nextWord.	maxWidth		_		strike nextWord.	strikeLength	_		strike nextWord.	ascent			_		strike nextWord.	descent			_		strike nextWord.	"xOffset			_"		strike nextWord. 		raster16			_		strike nextWord.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	characterToGlyphMap _ nil.! !!SwikiAction methodsFor: 'save and restore' stamp: 'mdr 9/4/2000 10:56'!convert	"Make all my pages obey the new format -- all versions in one file, file name is just a single number."	| old new nn |	urlmap pages do: [:page |		old _ page file.   nn _ old size.		(old at: nn) isDigit & ((old at: nn-1) == $.)			ifFalse: [self error: 'May not be an old style page']			ifTrue: [new _ old copyFrom: 1 to: nn-2.	"knock off .4"				page file: new.				page text: (FileStream readOnlyFileNamed: old) contentsOfEntireFile]].	! !!SwikiAction methodsFor: 'URL processing' stamp: 'mdr 9/4/2000 10:57'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1), 		(ServerAction pathSeparator), (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName) 		ifTrue: ["maybe send out content-length?"			request reply: (PWS success),(PWS content: imageGif), PWS crlf.			request reply: (FileStream readOnlyFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'mdr 8/31/2000 18:41'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| fName |	super restore: nameOfSwiki.	fName _ ServerAction serverDirectory, name, (ServerAction pathSeparator), 				'authorizer'.	(FileDirectory new fileExists: fName) ifTrue: [		authorizer _ (FileStream readOnlyFileNamed: fName) fileInObjectAndCode].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'mdr 9/4/2000 11:03'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream readOnlyFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream readOnlyFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'mdr 9/4/2000 11:04'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	StartupStamp _ '----STARTUP----', Time dateAndTimeNow printString, ' as ', Smalltalk imageName.	self processUpdates.	(Preferences valueOfFlag: #readDocumentAtStartup) ifFalse: [^ self].	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream readOnlyFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [ScriptingSystem openImagineeringStudio]]! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'mdr 9/4/2000 11:05'!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName _ Utilities chooseFileWithSuffixFromList:(#('.morph'), Utilities graphicsFileSuffixes) withCaption: 'Choose a fileto load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)'].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff _ FileStream readOnlyFileNamed: aName.			morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			myWorld addMorphsAndModel: morphOrList]		ifFalse:			[f _ Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format'].			m _ myWorld drawingClass new form: f.			myHand attachMorph: m]! !!TileMorph class methodsFor: 'class initialization' stamp: 'mdr 9/4/2000 11:06'!readInArrowGraphics	"TileMorph readInArrowGraphics"	| obj |	obj _ (FileStream readOnlyFileNamed: 'tile inc arrow.morph') fileInObjectAndCode.	UpPicture _ obj form.	obj _ (FileStream readOnlyFileNamed: 'tile dec arrow.morph') fileInObjectAndCode.	DownPicture _ obj form.	obj _ (FileStream readOnlyFileNamed: 'tile suffix arrow.morph')fileInObjectAndCode.	SuffixPicture _ obj form.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'mdr 8/31/2000 18:54'!convertCRtoLF: fileName	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"	| in out c justPutCR |	in _ (FileStream readOnlyFileNamed: fileName) binary.	out _  (FileStream newFileNamed: fileName, '.lf') binary.	justPutCR _ false.	[in atEnd] whileFalse: [		c _ in next.		c = 10			ifTrue: [				out nextPut: 13.				justPutCR _ true]			ifFalse: [				(justPutCR and: [c = 10]) ifFalse: [out nextPut: c].				justPutCR _ false]].	in close.	out close.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'mdr 9/4/2000 11:07'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: [nil].			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !