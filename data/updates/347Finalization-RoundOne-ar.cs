'From Squeak 2.2 of Sept 23, 1998 on 8 October 1998 at 11:09:49 am'!"Change Set:		Finalization-RoundOneDate:			7 October 1998Author:			Andreas RaabThis is the first round of Finalization updates.It introduces weak classes having a special class format (=4) and all the associated changes in ObjectMemory/Interpreter/DynamicInterpreter. For a comment see ObjectMemory>>aFinalizationComment. In addition,a finalization semaphore is added to the special objects array.Weak classes have both fixed and variable fields of which *only* thevariable fields are weak. Thus, you can mix weak and non-weak fieldin a weak class."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FreeSizeMask GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!ObjectMemory subclass: #DynamicInterpreterState	instanceVariableNames: 'localCP pseudoReceiver newReceiver theTemporaryPointer localIP localSP messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache mcProbe nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex BlockArgumentCountIndex CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheClassCol MethodCacheColumns MethodCacheDelayCol MethodCacheEntries MethodCacheMask MethodCacheMethodCol MethodCachePrimIndexCol MethodCacheSelectorCol MethodCacheSize MethodCacheTMethodCol MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart TranslatedMethodIndex ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Jitter'!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache reclaimableContextCount mcProbe nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals '	classVariableNames: 'ActiveProcessIndex BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex DirBadPath DirEntryFound DirNoMoreEntries ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageSelectorIndex MessageSize MethodArrayIndex MethodCacheEntries MethodCacheMask MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!ObjectMemory methodsFor: 'interpreter access' stamp: 'ar 3/21/98 02:38'!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: (hash << 17 bitAnd: 16r1FFE0000).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"	byteSize _ (header1 bitAnd: 16rFC) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format <= 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'header access' stamp: 'ar 3/21/98 00:30'!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)        4      both fixed and indexable weak fields (possibly containing pointers).        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF! !!ObjectMemory methodsFor: 'header access' stamp: 'ar 3/21/98 02:38'!isWeak: oop	"Answer true if the argument has only weak fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) = 4! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'ar 3/21/98 02:38'!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader |	self inline: true.	fmt _ self formatOf: objectPointer.	fmt <= 4 ifTrue: [		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"	].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 3/23/98 22:46'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		"<-- Finalization support: Do not trace the object's indexed fields if it's a weak class -->"		(self isWeak: oop) ifTrue:[			"Set lastFieldOffset before the weak fields in the receiver"			lastFieldOffset := (self nonWeakFieldsOf: oop) << 2.		] ifFalse:[			"Do it the usual way"			lastFieldOffset _ self lastPointerOf: oop.		].		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ar 10/7/1998 13:52'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: 16rFC.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: 16rFC.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: FreeSizeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: ["object is not marked; free it"			"<-- Finalization support: We need to mark each oop chunk as free -->"			self longAt: oop - hdrBytes put: HeaderTypeFree.			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			"<-- Finalization support: Check if we're running about a weak class -->"			(self isWeak: oop) ifTrue:[				self finalizeReference: oop.			].			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'ar 3/21/98 02:38'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]			ifFalse: [ size _ header bitAnd: 16rFC ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/21/98 23:14'!aFinalizationComment	"This finalization scheme assumes to have weak classes in which the fields are not traced during the mark phase of a GC. This means, if an object is referenced only by any instances of weak classes it can be collected. In turn, we need to find out if an object referenced by a weak class is actually being collected because we have to invalidate the weak object pointer and to signal that the object has gone.	How do we know that an object referenced by a weak class is being collected? Well,  this is based on two observations. First, objects will not change their relative locations in memory, meaning that if object A is created BEFORE object B it will always have a physical memory address which is LESS than B. Secondly, GC always works from a given starting address (youngStart during incremental GC; startOfMemory during fullGC) up to end of memory. If we can somehow garantuee that the weak reference is created after the object it points to we can easily implement the following simple scheme:	1) Mark phase		Do not trace the fields of any instances of weak classes.	2) Sweep phase:		a) Explicitly mark all free objects.		b) 	If a weak reference is encountered check the the object it points to. 			If the object is marked as free than we know that this weak reference's object is gone.			Signal that it is gone.	There is, however, one small problem with this approach. We cannot always garantuee that WeakReferences point backwards such as in the following piece of code:		| o1 o2 w1 w2 |		o1 _ Object new.		w1 _ WeakReference on: o1.		o2 _ Object new.		w2 _ WeakReference on: o2.		o1 become: o2.The become: operation makes w1 point to o2 and because o2 has been created AFTER w1 the object reference in w1 points forward. Why might this be a problem? Well, if the GC would start after the weak reference AND free the object then the weak reference would simply point to an invalid memory location (since we've not been checking the weak reference during sweep phase).	Fortunately, this can not happen in the current ObjectMemory implementation. Why? Well, the only GC not starting at the beginning of the memory is incremental GC. Incremental GC however is only executed in so-called youngSpace. If both, the weak reference AND the object it points to reside in youngSpace then we can still check the weak reference. If however, the weak reference is not in youngSpace but the object is, then the object is itself a root in young space and will be marked by the GC even if it is only referenced by the WeakReference.	In the end, we just need a little adjustment in step 2b) of the above procedure which looks as follows:		If the weak reference points 			* backwards: check if the object header is marked free			* forwards: check if the object has been marked in markPhase.	Note that a number of finalizations will only be executed during a fullGC. This happens if either the WeakReference or the object reside outside youngSpace. So, if you must garantuee that some object has been finalized you definitely need to do a fullGC.ar 3/20/98 17:20"	self error:'Comment only'.! !!ObjectMemory methodsFor: 'finalization' stamp: 'ar 3/23/98 22:39'!finalizeReference: oop	"During sweep phase we have encountered a weak reference. Check if	its object has gone away (or is about to) and if so, signal a semaphore."	| weakOop oopGone chunk firstField lastField |	"Do *not* inline this in sweepPhase - it is quite an unlikely case to run into a weak reference"	self inline: false.	firstField := BaseHeaderSize + ((self nonWeakFieldsOf: oop) << 2).	lastField := self lastPointerOf: oop.	firstField to: lastField by: 4 do:[:i|		weakOop := self longAt: oop+i.		((weakOop == nilObj) or:[(self isIntegerObject: weakOop)]) ifFalse:[			"Check if the object is being collected.			If the weak reference points 				* backward: check if the weakOops chunk is free				* forward: check if the weakOoop has been marked by GC"			weakOop < oop 				ifTrue:[	chunk _ self chunkFromOop: weakOop.						oopGone _ ((self longAt: chunk) bitAnd: TypeMask) = HeaderTypeFree]				ifFalse:[oopGone _ ((self baseHeader: weakOop) bitAnd: MarkBit) = 0].			oopGone ifTrue:[					"Store nil in the pointer and signal the interpreter"					self longAt: oop+i put: nilObj.					self signalFinalization: oop].		].	].! !!DynamicInterpreter methodsFor: 'initialization' stamp: 'ar 10/7/1998 13:59'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self inline: false.	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	messageSelector			_ nilObj.	newReceiver			_ nilObj.	newMethod				_ nilObj.	newTranslatedMethod	_ nilObj.	pseudoReceiver			_ 0.	self initializeTranslator.	self initMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!DynamicInterpreter methodsFor: 'object format' stamp: 'ar 3/21/98 02:32'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 4) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!DynamicInterpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:33'!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:33'!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ar 10/7/1998 14:02'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		semaClass _ self splObj: ClassSemaphore.		(self fetchClassOf: sema) = semaClass 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ar 3/21/98 13:58'!signalFinalization: weakReferenceOop	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	interruptCheckCounter _ 0.	pendingFinalizationSignals _ pendingFinalizationSignals + 1.! !!DynamicInterpreter methodsFor: 'debug support' stamp: 'ar 3/21/98 02:37'!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!Interpreter methodsFor: 'initialization' stamp: 'ar 10/7/1998 13:59'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.	deferDisplayUpdates _ false.	pendingFinalizationSignals _ 0.! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/21/98 02:37'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 4) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'object format' stamp: 'ar 3/23/98 22:52'!nonWeakFieldsOf: oop	"Return the number of non-weak fields in oop (i.e. the number of fixed fields).	Note: The following is copied from fixedFieldsOf:format:length: since we do know	the format of the oop (e.g. format = 4) and thus don't need the length."	| class classFormat |	self inline: false. "No need to inline - we won't call this often"	(self isWeak: oop) ifFalse:[self error:'Called fixedFieldsOfWeak: with a non-weak oop'].	"fmt = 3 or 4: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:37'!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ar 3/21/98 02:38'!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt <= 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!Interpreter methodsFor: 'processes' stamp: 'ar 10/7/1998 14:01'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal any pending finalizations"	pendingFinalizationSignals > 0 ifTrue:[		sema _ self splObj: TheFinalizationSemaphore.		semaClass _ self splObj: ClassSemaphore.		(self fetchClassOf: sema) = semaClass 			ifTrue:[self synchronousSignal: sema].		pendingFinalizationSignals _ 0.	].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes' stamp: 'ar 3/21/98 18:39'!signalFinalization: weakReferenceOop	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	interruptCheckCounter _ 0.	pendingFinalizationSignals _ pendingFinalizationSignals + 1.! !!Interpreter methodsFor: 'debug support' stamp: 'ar 3/21/98 02:37'!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!ObjectMemory class methodsFor: 'initialization' stamp: 'ar 10/7/1998 14:03'!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	SmallMethodContext _ 34.	SmallBlockContext _ 36.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.	TheFinalizationSemaphore _ 41.! !!SystemDictionary methodsFor: 'special objects' stamp: 'ar 3/21/98 15:30'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray smallFrameSize largeFrameSize |	newArray _ Array new: 42.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: 0 nLits: 0 primitive: 0) frameSize.	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.	newArray at: 35 put: (MethodContext new: smallFrameSize).	newArray at: 36 put: (MethodContext new: largeFrameSize).	newArray at: 37 put: (BlockContext new: smallFrameSize).	newArray at: 38 put: (BlockContext new: largeFrameSize).	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	newArray at: 42 put: Semaphore new. "finalization Semaphore"	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemTracer methodsFor: 'private' stamp: 'ar 3/21/98 00:31'!formatOf: obj	"Make the code that tells the format of this object.	It is like the class's instSpec, but with added low bits for byte size""       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields        4=      both fixed and indexable weak fields        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	| class spec |	class _ obj class.	spec _ class instSpec.    "just use what's there"	spec < 8 ifTrue: [^ spec]			ifFalse: ["For byte objects, size = wordSize - spec.lowBits"					^ spec + (3 - (obj size+3 bitAnd: 3))]! !