'From Squeak2.9alpha of 13 June 2000 [latest update: #3343] on 31 January 2001 at 2:18:20 pm'!"Change Set:		Stepping-arDate:			31 January 2001Author:			Andreas RaabThis change set* unifies the #addMorph: variants into a single method (#privateAddMorph:atIndex:)* introduces the #intoWorld:/#outOfWorld: protocol for morphs* makes morph start stepping automatically whenever they enter a new world.IMPORTANT:The old #startSteppingSubmorphsOf: and related variants are now OBSOLETE. Morphs will start automatically when entering a world so unless there is a very good reason to stop and restart stepping of morphs inbetween THERE IS NO POINT WHATSOEVER in calling any of those methods. Remove them as you find them."!!Morph methodsFor: 'initialization' stamp: 'ar 1/31/2001 13:57'!intoWorld: aWorld	"The receiver has just appeared in a new world. Note:		* aWorld can be nil (due to optimizations in other places)		* owner is already set		* owner's submorphs may not include receiver yet.	Important: Keep this method fast - it is run whenever morphs are added."	aWorld ifNil:[^self].	self wantsSteps ifTrue:[aWorld startStepping: self].	self submorphsDo:[:m| m intoWorld: aWorld].! !!Morph methodsFor: 'initialization' stamp: 'ar 1/31/2001 13:58'!outOfWorld: aWorld	"The receiver has just appeared in a new world. Notes:		* aWorld can be nil (due to optimizations in other places)		* owner is still valid	Important: Keep this method fast - it is run whenever morphs are removed."	aWorld ifNil:[^self].	"ar 1/31/2001: We could explicitly stop stepping the receiver here but for the sake of speed I'm for now relying on the lazy machinery in the world itself."	"aWorld stopStepping: self."	self submorphsDo:[:m| m outOfWorld: aWorld].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 13:15'!addAllMorphs: aCollection	| any box invalidate myWorld itsWorld |	myWorld _ self world.	invalidate _ myWorld notNil.	box _ nil.	aCollection do: [:m |		any _ m.		m owner ifNotNil: [			itsWorld _ m world.			itsWorld == myWorld ifFalse:[m outOfWorld: itsWorld].			m owner privateRemoveMorph: m].		invalidate ifTrue:[			box ifNil:[box _ m fullBounds copy] 				ifNotNil:[box _ box quickMerge: m fullBounds]].		m privateOwner: self.		itsWorld == myWorld ifFalse:[m intoWorld: myWorld].	].	submorphs _ submorphs, aCollection.	self layoutChanged.	box ifNotNil:[self invalidRect: box from: any].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 13:18'!addAllMorphs: aCollection after: anotherMorph	| index box any invalidate myWorld itsWorld |	myWorld _ self world.	invalidate _ myWorld notNil.	box _ nil.	index _ submorphs indexOf: anotherMorph ifAbsent: [submorphs size].	aCollection do: [:m |		any _ m.		m owner ifNotNil: [			itsWorld _ m world.			itsWorld == myWorld ifFalse:[m outOfWorld: itsWorld].			m owner privateRemoveMorph: m].		invalidate ifTrue:[			box ifNil:[box _ m fullBounds copy] 				ifNotNil:[box _ box quickMerge: m fullBounds]].		m privateOwner: self.		itsWorld == myWorld ifFalse:[m intoWorld: myWorld].	].	submorphs _ (submorphs copyFrom: 1 to: index), aCollection,			(submorphs copyFrom: index+1 to: submorphs size).	self layoutChanged.	box ifNotNil:[self invalidRect: box from: any].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:54'!addMorph: newMorph after: aMorph	"Add the given morph as one of my submorphs, inserting it after anotherMorph"	^self privateAddMorph: newMorph atIndex: (submorphs indexOf: aMorph)+1! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:44'!addMorph: newMorph behind: aMorph	"Add a morph to the list of submorphs behind the specified morph"	^self privateAddMorph: newMorph atIndex: (submorphs indexOf: aMorph) + 1.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:45'!addMorph: newMorph inFrontOf: aMorph	"Add a morph to the list of submorphs in front of the specified morph"	^self privateAddMorph: newMorph atIndex: ((submorphs indexOf: aMorph) max: 1).! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:55'!addMorphBack: aMorph	^self privateAddMorph: aMorph atIndex: submorphs size+1! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:54'!addMorphFront: aMorph	^self privateAddMorph: aMorph atIndex: 1! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 13:19'!removeAllMorphs	| myWorld |	myWorld _ self world.	(fullBounds notNil or:[self isInWorld]) ifTrue:[self invalidRect: self fullBounds].	submorphs do: [:m | m outOfWorld: myWorld; privateOwner: nil].	submorphs _ EmptyArray.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 13:19'!removeAllMorphsIn: aCollection	"greatly speeds up the removal of *lots* of submorphs"	| set myWorld |	myWorld _ self world.	(fullBounds notNil or:[myWorld notNil]) ifTrue:[self invalidRect: self fullBounds].	aCollection do: [:m | m outOfWorld: myWorld; privateOwner: nil].	set _ IdentitySet new: aCollection size * 4 // 3.	aCollection do: [:each | set add: each].	submorphs _ submorphs reject: [ :each | set includes: each].	self layoutChanged.! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 1/31/2001 13:07'!startStepping	"Start getting sent the 'step' message."	self startStepping: #stepAt: at: Time millisecondClockValue arguments: nil stepTime: nil.! !!Morph methodsFor: 'private' stamp: 'ar 1/31/2001 13:18'!privateAddMorph: aMorph atIndex: index	| oldIndex myWorld itsWorld |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	myWorld _ self world.	aMorph owner == self ifTrue:[		"aMorph's position changes within in the submorph chain"		oldIndex _ submorphs indexOf: aMorph.		oldIndex < index ifTrue:[			"moving aMorph to back"			submorphs replaceFrom: oldIndex to: index with: submorphs startingAt: oldIndex.			submorphs at: index-1 put: aMorph.		] ifFalse:[			"moving aMorph to front"			oldIndex-1 to: index by: -1 do:[:i|				submorphs at: i+1 put: (submorphs at: i)].			submorphs at: index put: aMorph.		].	] ifFalse:[		"adding a new morph"		aMorph owner ifNotNil:[			itsWorld _ aMorph world.			itsWorld == myWorld ifFalse:[aMorph outOfWorld: itsWorld].			aMorph owner privateRemoveMorph: aMorph].		aMorph privateOwner: self.		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).		itsWorld == myWorld ifFalse:[aMorph intoWorld: myWorld].	].	self layoutChanged.	myWorld ifNotNil:[self invalidRect: aMorph fullBounds from: aMorph].! !