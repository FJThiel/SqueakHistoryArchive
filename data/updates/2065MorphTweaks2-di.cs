'From Squeak2.8alpha of 12 January 2000 [latest update: #2064] on 4 May 2000 at 9:36:11 pm'!"Change Set:		MorphTweaks2Date:			4 May 2000Author:			Dan IngallsA few more tweaks...Now shift-cmd will allow cycling through all levels of a dropShadow construction.Adds a fix for MagnifierMorph creation.One problem remains:  if a drop-shadow is translucent, the hand does not make a shadow for it when dragging, regardless of its alpha."!!HaloMorph methodsFor: 'accessing' stamp: 'di 5/4/2000 20:36'!setTargetBasic: aMorph	"Private!! Set the target without fancy interpretation."	(target == aMorph and: [innerTarget == aMorph])		ifTrue: [^ self].  "No change"	target _  innerTarget _ aMorph.	self addHandles! !!HaloMorph methodsFor: 'private' stamp: 'di 5/4/2000 21:13'!addName	self addNameBeneath: self basicBox string: innerTarget externalName! !!HandMorph methodsFor: 'halos' stamp: 'di 5/4/2000 21:15'!popUpHaloFromClick: evt	"Pop up a halo on a suitable morph below the hand.	If there are multiple possible targets, and one of them already has a halo, then	choose the next inner target.  That is, unless we are already at the bottom, in which case	go topmost again."	| oldTargets targets anIndex |	oldTargets _ OrderedCollection new.	self world haloMorphs do:		[:h | oldTargets addLast: h target. h delete].	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ owner "the world" addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument wantsHaloFromClick ifTrue: [argument addHalo: evt "sole target"]].	"Multiple possible targets, choose the outermost suitable one first, but if one already		has a halo, then choose the next farther in."	targets _ argument unlockedMorphsAt: targetOffset.	targets _ targets reversed select: [:aMorph | aMorph wantsHaloFromClick].	targets size = 0 ifTrue: [^ argument wantsHaloFromClick			ifTrue: [argument addHalo: evt "sole target"]			ifFalse: ["no halo recipient"]].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	anIndex _ targets findFirst: [:t | oldTargets includes: t].	anIndex = 0 ifTrue:		[^ self popUpNewHaloFromClick: evt targets: targets].	^ (targets atWrap: anIndex + 1) addHalo: evt from: (targets at: anIndex) "next inner target"! !!HandMorph methodsFor: 'halos' stamp: 'di 5/4/2000 20:47'!popUpHaloFromShiftClick: evt	| oldTargets targets anIndex halos |	"Given that the shift key is down, pop up a halo on an appropriate morph.  Go to the deepest morph (locked or not), unless there is an existing halo, in which case go out one level"	oldTargets _ OrderedCollection new.	self world haloMorphs do:		[:h | oldTargets addLast: h target. h delete].	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ owner "the world" addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument addHalo: evt "sole target"].	"Multiple possible targets, choose the deepest first, but	if one already has a halo, then choose the next farther out."	targets _ argument morphsAt: targetOffset.	targets size = 0 ifTrue: [^ argument addHalo: evt "sole target"].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	anIndex _ targets findFirst: [:t | oldTargets includes: t].	anIndex = 0 ifTrue: [^ targets first addHalo: evt "deepest target"].	(targets atWrap: anIndex + 1) addHalo: evt from: (targets at: anIndex). "next outer target"	(halos _ self world haloMorphs) size >= 1 ifTrue:		[halos first setTargetBasic: (targets atWrap: anIndex + 1)]! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'di 5/4/2000 15:59'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^ (trackPointer not or: [owner notNil and: [owner isHandMorph]])		ifTrue: [self center]		ifFalse: [self currentHand lastEvent cursorPoint]! !