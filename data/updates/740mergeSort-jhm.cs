'From Squeak 2.3 beta of Nov 25, 1998 on 15 March 1999 at 10:14:04 pm'!"Change Set:		mergeSort-jhmDate:			15 March 1999Author:			John MaloneyVarious tweaks and fixes, including:  1. makes the initial Random seed be more random when new generators are    created in back-to-back calls (use the object hash, as well as the millisecond clock)  2. make socket more robust when handle is nil  3. adds mergesort algorithm, a fast, stable sorter for Arrays"!!Object methodsFor: 'macpal' stamp: 'jm 2/24/1999 12:40'!scriptPerformer	^ self! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 3/1/1999 11:02'!playLoudness: aNumber	"Play the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd _ SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd _ SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd _ MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	(snd setLoudness: aNumber) play.! !!Random methodsFor: 'all' stamp: 'jm 3/10/1999 21:40'!initialize	" Set a reasonable Park-Miller starting seed "	seed := Time millisecondClockValue * self hash.	a := 16r000041A7 asFloat.    " magic constant =      16807 "	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 "	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.! !!SequenceableCollection methodsFor: 'converting' stamp: 'jm 4/27/98 04:09'!reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| n result src |	n _ self size.	result _ self species new: n.	src _ n + 1.	1 to: n do: [:i | result at: i put: (self at: (src _ src - 1))].	^ result! !!ArrayedCollection methodsFor: 'sorting' stamp: 'jm 4/27/98 05:40'!isSorted	| lastEl el |	lastEl _ self first.	2 to: self size do: [:i |		el _ self at: i.		el >= lastEl ifFalse: [^ false].		lastEl _ el].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'jm 4/27/98 05:30'!mergeFirst: first middle: middle last: last into: dst by: aBlock	"Private!! Merge the sorted ranges [first..middle] and [middle+1..last] of the receiver into the range [first..last] of dst."	| i1 i2 val1 val2 out |	i1 _ first.	i2 _ middle + 1.	val1 _ self at: i1.	val2 _ self at: i2.	out _ first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue: [		(aBlock value: val1 value: val2)			ifTrue: [				dst at: (out _ out + 1) put: val1.				val1 _ self at: (i1 _ i1 + 1)]			ifFalse: [				dst at: (out _ out + 1) put: val2.				i2 _ i2 + 1.				i2 <= last ifTrue: [val2 _ self at: i2]]].	"copy the remaining elements (one of this loops will do nothing)"	i1 to: middle do: [:j |		dst at: (out _ out + 1) put: (self at: j)].	i2 to: last do: [:j |		dst at: (out _ out + 1) put: (self at: j)].! !!ArrayedCollection methodsFor: 'sorting' stamp: 'jm 4/27/98 05:33'!mergeSortFrom: startIndex to: stopIndex by: aBlock	"Sort the given range of indices using the mergesort algorithm. Mergesort is a worst-case O(N log N) sorting algorithm that usually does only half as many comparisons as heapsort or quicksort."	"Details: recursively split the range to be sorted into two halves, mergesort each half, then merge the two halves together. An extra copy of the data is used as temporary storage and successive merge phases copy data back and forth between the receiver and this copy. The recursion is set up so that the final merge is performed into the receiver, resulting in the receiver being completely sorted."	| temp |	self size <= 1 ifTrue: [^ self].  "nothing to do"	startIndex = stopIndex ifTrue: [^ self].	(startIndex >= 1 and: [startIndex < stopIndex])		ifFalse: [self error: 'bad start index'].	stopIndex <= self size		ifFalse: [self error: 'bad stop index'].	temp _ self clone.	self mergeSortFrom: startIndex to: stopIndex src: temp dst: self by: aBlock.! !!ArrayedCollection methodsFor: 'sorting' stamp: 'jm 4/27/98 04:54'!mergeSortFrom: first to: last src: src dst: dst by: aBlock	"Private!! Split the range to be sorted in half, sort each half, and merge the two half-ranges into dst."	| middle |	first = last ifTrue: [^ self].	middle _ (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock.! !!ArrayedCollection methodsFor: 'sorting' stamp: 'jm 4/27/98 05:48'!sort	"Sort this array into ascending order using the '<' operator."	self mergeSortFrom: 1 to: self size by: [:el1 :el2 | el1 < el2].! !!ArrayedCollection methodsFor: 'sorting' stamp: 'jm 4/27/98 04:52'!sort: aBlock	"Sort this array using the given comparision block. The block should take two arguments and return true if the first element should precede the second in the sorted result."	self mergeSortFrom: 1 to: self size by: aBlock.! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:52'!dataAvailable	"Return true if this socket has unread received data."	socketHandle == nil ifTrue: [^ false].	^ self primSocketReceiveDataAvailable: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:52'!isConnected	"Return true if this socket is connected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnected	"Return true if this socket's state is Unconnected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Unconnected! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status _ self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:51'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status _ self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isWaitingForConnection	"Return true if this socket is waiting for a connection."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!sendDone	"Return true if the most recent send operation on this socket has completed."	socketHandle == nil ifTrue: [^ false].	^ self primSocketSendDone: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:56'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status _ self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !