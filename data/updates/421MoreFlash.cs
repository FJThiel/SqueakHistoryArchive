'From Squeak 2.2 of Sept 23, 1998 on 17 November 1998 at 7:47:14 pm'!FlashCharacterMorph subclass: #FlashButtonMorph	instanceVariableNames: 'menuFlag events sounds '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashFileReader subclass: #FlashMorphReader	instanceVariableNames: 'location fillStyles lineStyles shapes fonts forms sounds buttons lineSequence currentShape player spriteOwners stepTime frame activeMorphs passiveMorphs activeFont textOffset textPosition textHeight textMorph canCompressPoints pointList compressionBounds fillIndex0 fillIndex1 lineStyleIndex leftFillList rightFillList lineStyleList '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Model subclass: #FlashPlayerModel	instanceVariableNames: 'player '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!SystemWindow subclass: #FlashPlayerWindow	instanceVariableNames: 'startButton stopButton '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashSpriteMorph	instanceVariableNames: 'frames frameNumber stepTime damageRecorder sounds actions labels '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashCharacterMorph subclass: #FlashTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/17/1998 18:41'!fullDamageRect	invalidRects isEmpty ifTrue:[^0@0 corner: 0@0].	^fullDamageRect! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/17/1998 00:35'!processShapeRecordFrom: data	| flags pt lineInfo fillInfo0 fillInfo1 |	data nextBitFlag ifTrue:["Boundary edge record"		data nextBitFlag			ifTrue:[self processLineRecordFrom: data]			ifFalse:[self processCurveRecordFrom: data].		^true].	flags _ data nextBits: 5.	flags = 0 ifTrue:[^false]. "At end of shape"	(flags anyMask: 1) ifTrue:["move to"		pt _ data nextPoint.		self recordMoveTo: pt.		log ifNotNil:[log crtab; nextPutAll:'MoveTo '; print: pt]].	(flags anyMask: 2) ifTrue:["fill info 0"		fillInfo0 _ data nextBits: nFillBits.		self recordFillStyle0: fillInfo0.		log ifNotNil:[log crtab; nextPutAll:'FillInfo0 '; print: fillInfo0]].	(flags anyMask: 4) ifTrue:["fill info 1"		fillInfo1 _ data nextBits: nFillBits.		self recordFillStyle1: fillInfo1.		log ifNotNil:[log crtab; nextPutAll:'FillInfo1 '; print: fillInfo1]].	(flags anyMask: 8) ifTrue:["line info"		lineInfo _ data nextBits: nLineBits.		self recordLineStyle: lineInfo.		log ifNotNil:[log crtab; nextPutAll:'LineInfo '; print: lineInfo]].	(flags anyMask: 16) ifTrue:["new styles"		self recordEndSubshape.		log ifNotNil:[log crtab; nextPutAll:'New Set of styles '].		self processShapeStylesFrom: data.		"And reset info"		data initBits.		nFillBits _ data nextBits: 4.		nLineBits _ data nextBits: 4].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/17/1998 00:37'!processShapesFrom: data	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 11/16/1998 15:30'!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	"Experimental:It is an error in the spec. There can be up to 255 characters in run. Thehigh bit does not mean anything. The text record type 0 and type 1 is poorlydescribed. The real format is that all of the info in a 'text record type 1'is always followed by the info in a 'text record type 2'. Note the high bitof 'text record type 1' is reserved and should always be zero."	self processGlyphStateChange: flags from: data.	flags _ data nextByte.	flags = 0 ifTrue:[^false].	self processGlyphEntries: flags from: data.	"Old stuff - which is according to the f**cking spec"	"(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	]."	^true! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 11/16/1998 15:33'!processButtonRecords: id from: data cxForm: haveCxForm	| flags state characterId layer matrix cxForm |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		haveCxForm ifTrue:[cxForm _ data nextColorMatrix].		self recordButton: id character: characterId state: state layer: layer matrix: matrix].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/17/1998 13:38'!processActionGotoLabel: data	| length label |	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 11/17/1998 13:37'!processActionSetTarget: data	| length target |	length _ data nextWord.	target _ data nextString.	log ifNotNil:[log nextPutAll:' target = '; print: target].	^Message selector: #actionTarget: argument: target.! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 11/17/1998 16:49'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| data buffers nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask sound k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) contents samplingRate: samplingRate.		sound setLoudness: 1.0.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02'!processDefineBitsJPEG2: data	| id image decoder |	id _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02'!processDefineBitsJPEG3: data	| id image decoder alphaOffset dataOffset |	id _ data nextWord.	"F**cking spec"	alphaOffset _ data nextWord.	dataOffset _ data nextWord.	decoder _ FlashJPEGDecoder new.	decoder decodeJPEGTables: data.	image _ decoder decodeNextImageFrom: data.	"Note: We must read the zlib compressed alpha values here."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02'!processDefineBitsLossless2: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:02'!processDefineBitsLossless: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 21:11'!processDefineButton2: data	| id flags actions condition actionOffset |	data hasAlpha: true.	id _ data nextWord.	self recordDefineButton: id.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	actionOffset _ data nextWord. "F**cking spec"	self processButtonRecords: id from: data cxForm: true.	[actionOffset = 0] whileFalse:[		actionOffset _ data nextWord.		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 20:47'!processDefineButton: data	| id actions |	id _ data nextWord.	self recordDefineButton: id.	self processButtonRecords: id from: data cxForm: false.	actions _ self processActionRecordsFrom: data.	self recordButton: id actions: actions.	self recordEndButton: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 19:46'!processDefineMorphShape: data	"self halt."	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/16/1998 17:18'!processDefineSprite: data	| id frameCount |	id _ data nextWord.	frameCount _ data nextWord. "F**cking spec"	self recordBeginSprite: id frames: frameCount.	[self processTagFrom: data] whileTrue.	self recordEndSprite: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 13:35'!processFrameLabel: data	| label |	label _ data nextString.	self recordFrameLabel: label.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 19:10'!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move 		ifTrue:[self recordMoveObject: id depth: depth matrix: matrix colorMatrix: cxForm]		ifFalse:[self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: cxForm].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/17/1998 16:11'!processSoundStreamBlock: data	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 11/17/1998 00:36'!recordEndSubshape	"A new subshape begins with a full set of line and fill styles"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordDefineButton: id	"Record the definition of a new button with the given id"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:47'!recordEndButton: id	"Record the end of a button definition with the given id"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 16:54'!recordBeginSprite: id frames: frameCount! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 16:55'!recordEndSprite: id! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/17/1998 13:36'!recordFrameLabel: label	"Name the current frame with the given label"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 11/16/1998 13:13'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/16/1998 15:44'!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits).		transform gMul: (self nextSignedBits: nBits).		transform bMul: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits)]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits).		transform gAdd: (self nextSignedBits: nBits).		transform bAdd: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits)]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/17/1998 18:19'!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a12: (self nextSignedBits: nBits) / 65536.0.		transform a21: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 11/17/1998 13:51'!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	image _ Cursor wait showWhile:[self nextImage].	"(stream position + 2 < stream size) ifTrue:[self halt]."	^image! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:28'!loadInitialFrame	self computeBounds.! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:41'!activationKeys	^#()! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:13'!delete	| player |	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	^super delete! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:00'!depth	^(self valueOfProperty: #depth) ifNil:[0]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 21:00'!depth: d	d = 0		ifTrue:[self removeProperty: #depth]		ifFalse:[self setProperty: #depth toValue: d]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 11:40'!id	^-1! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 23:47'!isFlashButton	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 17:03'!isFlashSprite	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 19:04'!debugDraw	| vis canvas m |	vis _ self visible.	self visible: true.	canvas _ BalloonCanvas on:Display.	m _ MatrixTransform2x3 withScale: 0.05.	m offset: (self fullBounds origin // 20) negated.	canvas transformBy: m.	self fullDrawOn: canvas.	self visible: vis.! !!FlashMorph methodsFor: 'printing' stamp: 'ar 11/16/1998 11:40'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$[;		print: self depth;		space.	self visible 		ifTrue:[aStream nextPutAll:'visible']		ifFalse:[aStream nextPutAll:'invisible'].	aStream		nextPutAll:' id = ';		print: self id;		nextPut:$];		cr.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 19:25'!loadInitialFrame	"Force the transformations taking place in the first frame."	super loadInitialFrame.	self stepToFrame: 1.! !!FlashCharacterMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 17:52'!fullDrawOn: canvas	renderTime _ Time millisecondsToRun:[super fullDrawOn: canvas].! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33'!stepToFrame: frameNumber	| m wasVisible isVisible noTransform |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		noTransform _ m = transform.		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:04'!defaultLook: aMorph	"Assign the default look"	aMorph setProperty: #defaultLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:26'!loadInitialFrame	"Resort our children"	super loadInitialFrame.	submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth].	self lookEnable: #(defaultLook) disable:#(sensitive overLook pressLook)! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:25'!overLook: aMorph	"Assign the look if the mouse if over"	aMorph setProperty: #overLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:25'!pressLook: aMorph	"Assign the look if the mouse is pressed"	aMorph setProperty: #pressLook toValue: true.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 21:04'!sensitiveLook: aMorph	"Assign the look for the sensitive area."	aMorph setProperty: #sensitive toValue: true.	self addMorph: aMorph! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:25'!handlesMouseDown: evt	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:25'!handlesMouseOver: evt	^self visible! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:24'!handlesMouseOverDragging: evt	^false! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/17/1998 17:23'!mouseDown: evt	| rcvr msg arg |	self lookEnable: #(pressLook) disable:#().	events ifNil:[^self].	(events at: #mouseDown ifAbsent:[^self]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/17/1998 18:24'!mouseEnter: evt	| rcvr msg arg |	self lookEnable: #(overLook defaultLook) disable:#(pressLook).	events ifNil:[^self].	(events at: #mouseEnter ifAbsent:[^self]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 23:49'!mouseLeave: evt	self lookEnable: #(defaultLook) disable:#(pressLook overLook).! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/17/1998 17:23'!mouseUp: evt	| rcvr msg arg |	self lookEnable:#(defaultLook overLook) disable:#(pressLook).	events ifNil:[^self].	(events at: #mouseUp ifAbsent:[^self]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 21:46'!containsPoint: aPoint	| localPt |	(self bounds containsPoint: aPoint) ifFalse:[^false].	localPt _ self transform globalPointToLocal: aPoint.	submorphs do:[:m| 		((m valueOfProperty: #sensitive) ifNil:[false]) ifTrue:[			(m bounds containsPoint: localPt) ifTrue:[^true].		].	].	^false! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 21:09'!lookEnable: list1 disable: list2	self changed.	submorphs do:[:m|		list2 do:[:sym|			((m valueOfProperty: sym) ifNil:[false]) ifTrue:[m visible: false].		].		list1 do:[:sym|			((m valueOfProperty: sym) ifNil:[false]) ifTrue:[m visible: true].		].	].	self computeBounds.	self changed.! !!FlashButtonMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 23:47'!isFlashButton	^true! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:37'!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	spriteOwners _ IdentityDictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/17/1998 18:06'!processFile: aMorph	super processFile.	player loadInitialFrame.	"player stepForward.	player stepBackward."	aMorph ifNil:[		player play.		^player openInMVC].	aMorph isWorldMorph ifTrue:[		"aMorph world activeHand attachMorph: player."		player openInWorld.	] ifFalse:[		aMorph addMorph: player.	].	^player! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/17/1998 19:22'!recordTextStart: id bounds: bounds matrix: matrix	textPosition _ textOffset _ bounds origin.	textMorph _ FlashTextMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.	"matrix ifNotNil:[textMorph transform: matrix]."! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/17/1998 00:36'!recordEndSubshape	"A new subshape begins with a full set of line and fill styles"	self endShape.	self beginShape.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/16/1998 13:02'!computeLineStyleLists	"Compute the line style index lists.	Each line style will be splitted into two parts, the width and the fill.	Then, the fills will be added to the fillStyles and the indexes will be adjusted.	Finally, we compute two arrays containing the width of each line and the	fill style of each line"	| widthList fillList indexMap oldIndex newIndex allFillStyles style |	allFillStyles _ Dictionary new.	fillStyles associationsDo:[:assoc| 		allFillStyles at: assoc key put: assoc value].	indexMap _ Dictionary new.	lineStyles associationsDo:[:assoc|		oldIndex _ assoc key.		style _ assoc value.		allFillStyles at: allFillStyles size+1 put: (SolidFillStyle color: style color).		newIndex _ allFillStyles size.		indexMap at: oldIndex put: newIndex.	].	widthList _ OrderedCollection new: lineStyles size.	fillList _ OrderedCollection new: lineStyles size.	lineStyleList contents do:[:index|		index = 0 ifTrue:[			widthList add: 0.			fillList add: 0.		] ifFalse:[			style _ lineStyles at: index ifAbsent:[FlashLineStyle color: Color black width: 20].			widthList add: style width.			fillList add: (indexMap at: index ifAbsent:[1]).		].	].	widthList _ widthList as: ShortRunArray.	fillList _ fillList as: ShortRunArray.	^Array with: allFillStyles with: fillList with: widthList! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 17:42'!recordBeginSprite: id frames: frameCount	| sprite |	sprite _ FlashSpriteMorph new.	sprite frames: frameCount.	sprite stepTime: stepTime.	spriteOwners at: sprite put: (		Array with: player 			with: frame			with: activeMorphs			with: passiveMorphs).	player _ sprite.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 18:36'!recordEndSprite: id	| shape sprite |	sprite _ player.	player _ (spriteOwners at: sprite) at: 1.	frame _ (spriteOwners at: sprite) at: 2.	activeMorphs _ (spriteOwners at: sprite) at: 3.	passiveMorphs _ (spriteOwners at: sprite) at: 4.	spriteOwners removeKey: sprite.	sprite loadInitialFrame.	shape _ FlashCharacterMorph withAll: (Array with: sprite).	shape id: id.	shape stepTime: stepTime.	shapes at: id put: shape.	shape lockChildren.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 22:53'!recordFrameActions: actionList	player addActions: actionList atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 13:36'!recordFrameLabel: label	"Name the current frame with the given label"	player addLabel: label atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 18:10'!recordMoveObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| index oldObj mat |	index _ nil.	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth])					ifTrue:[index _ morph id]]].	oldObj _ self recordRemoveObject: index depth: depth.	oldObj isNil ifTrue:[^self].	objectIndex isNil ifFalse:[index _ objectIndex].	matrix isNil 		ifTrue:[mat _ oldObj matrixAtFrame: frame]		ifFalse:[mat _ matrix].	self recordPlaceObject: index depth: depth matrix: mat colorMatrix: colorMatrix.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 22:54'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorMatrix: colorMatrix atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 21:54'!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[#()]) do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph visibleAtFrame: frame-1) and:[				(morph depthAtFrame: frame-1) = depth]) 					ifTrue:[^self removeActiveMorph: morph]]].	Transcript cr; nextPutAll:'Shape (id = '; print: id; nextPutAll:' depth = '; print: depth; nextPutAll:') not removed in frame '; print: frame; endEntry.	^nil! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/17/1998 18:06'!recordShowFrame	player frames: frame.	frame _ frame + 1.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 19:39'!myActiveMorphs	| out |	out _ WriteStream on: (Array new: 10).	activeMorphs do:[:array| out nextPutAll: array].	^out contents! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 19:26'!myFlush		Transcript endEntry.		Sensor leftShiftDown ifTrue:[self halt].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 17:45'!newMorphFromShape: objectIndex	"Return a new character morph from the given object index.	If the character morph at objectIndex is already used, then create and return a full copy of it"	| prototype |	prototype _ self oldMorphFromShape: objectIndex.	prototype isNil ifTrue:[^nil].	^(prototype owner notNil) 		ifTrue:[prototype fullCopy]		ifFalse:[prototype].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 20:24'!oldMorphFromShape: objectIndex	"Return an existing character morph from the given object index."	| prototype |	prototype _ shapes at: objectIndex ifAbsent:[nil].	"prototype ifNil:[prototype _ buttons at: objectIndex ifAbsent:[nil]]."	prototype ifNil:[Transcript cr; nextPutAll:'No shape for '; print: objectIndex; nextPutAll:' in frame '; print: frame; endEntry].	^prototype! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/16/1998 21:55'!removeActiveMorph: aMorph	| newActive newPassive |	aMorph visible: false atFrame: frame.	newActive _ (activeMorphs at: aMorph id) copyWithout: aMorph.	newPassive _ (passiveMorphs at: aMorph id ifAbsent:[#()]) copyWith: aMorph.	activeMorphs at: aMorph id put: newActive.	passiveMorphs at: aMorph id put: newPassive.	^aMorph! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:37'!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self halt].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter send: #executeActions: to: player withValue: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 21:01'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix	| button children shape |	button _ buttons at: buttonId ifAbsent:[^self halt].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[^nil].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape depth: layer.	shape transform: matrix.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self halt].	theSound _ self createSound: id info: soundInfo.	theSound ifNil:[^self].	self halt.	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:51'!recordButton: id trackAsMenu: aBoolean	| button |	button _ buttons at: id ifAbsent:[^self halt].	button trackAsMenu: aBoolean.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 20:36'!recordDefineButton: id	"Record the definition of a new button with the given id"	| button |	button _ buttons at: id put: FlashButtonMorph new.	button id: id.	shapes at: id put: button.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 21:11'!recordEndButton: id	"Record the end of a button definition with the given id"! !!FlashPlayerModel reorganize!('all' initialExtent play player: stop)!!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 14:47'!initialExtent	^player bounds extent! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 15:12'!play	player play! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 14:45'!player: flashPlayer	player _ flashPlayer! !!FlashPlayerModel methodsFor: 'all' stamp: 'ar 11/17/1998 15:12'!stop	player stop! !!FlashPlayerModel class methodsFor: 'instance creation' stamp: 'ar 11/17/1998 14:45'!player: flashPlayer	^self new player: flashPlayer! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 19:21'!initialize	super initialize.	color _ Color white.	borderColor _ Color black.	borderWidth _ 2.	frameNumber _ 1.	frames _ 100.	sounds _ Dictionary new.	actions _ Dictionary new.	self loopFrames: true.	stepTime _ 1.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 16:42'!loadInitialFrame	super loadInitialFrame.	activationKeys _ self collectActivationKeys.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 15:39'!openInMVC	| window extent |	self localBounds: localBounds.	extent _ bounds extent.	window _ FlashPlayerWindow labelled:'Flash Player'.	window model: (FlashPlayerModel player: self).	window addMorph: self frame:(0@0 corner: 1@1).	window openInMVCExtent: extent! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/17/1998 15:24'!openInWorld	| window extent |	self localBounds: localBounds.	extent _ bounds extent.	window _ FlashPlayerWindow labelled:'Flash Player'.	window model: (FlashPlayerModel player: self).	window addMorph: self frame:(0@0 corner: 1@1).	window openInWorldExtent: extent! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 22:53'!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 20:30'!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame+1.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 23:48'!addMorph: aMorph	aMorph isFlashMorph ifFalse:[^super addMorph: aMorph].	aMorph isFlashButton		ifTrue:[self addMorphFront: aMorph]		ifFalse:[self addMorphBack: aMorph].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 20:31'!addSound: aSound at: frame	| oldSound newSound |	oldSound _ sounds at: frame+1 ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frame+1 put: newSound.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/17/1998 15:21'!borderWidth	^borderWidth! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/17/1998 15:21'!borderWidth: bw	borderWidth _ bw.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/17/1998 15:00'!localBounds: newBounds	localBounds _ newBounds.	bounds _ (newBounds origin // 20 corner: newBounds corner // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 02:38'!debugDraw	self fullDrawOn: (FormCanvas on: Display)! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/17/1998 19:08'!fullDrawOn: aCanvas	"Overridden to only the draw the currently active morphs"	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	activeMorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  	"aCanvas frameRectangle: aCanvas clipRect color: Color white."! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 15:32'!boundsChangedFrom: oldBounds to: newBounds	transform _ MatrixTransform2x3					transformFromLocal: localBounds					toGlobal: newBounds.! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 17:20'!fullContainsPoint: pt	(bounds containsPoint: pt) ifFalse:[^false].	^super fullContainsPoint: pt! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/17/1998 17:21'!unlockedMorphsAt: pt addTo: mList	(bounds containsPoint: pt) ifFalse:[^mList].	^super unlockedMorphsAt: pt addTo: mList! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33'!frameNumber: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame > frameNumber ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 16:20'!stepForward	frameNumber < frames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[(self valueOfProperty:#loopFrames) == true 			ifTrue:[self frameNumber: 1]			ifFalse:[self stop]].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 18:33'!stepToFrameForward: frame	| activeRemoved resortNeeded morph |	frameNumber+1 to: frame do:[:f|		activeRemoved _ false.		resortNeeded _ false.		1 to: activeMorphs size do:[:i|			morph _ activeMorphs at: i.			morph stepToFrame: f.			morph visible ifFalse:[activeRemoved _ true].			(i > 1 and:[(activeMorphs at: i-1) depth < morph depth])				ifTrue:[resortNeeded _ true].		].		activeRemoved ifTrue:[			activeMorphs _ activeMorphs select:[:m| m visible].			resortNeeded _ false.		].		resortNeeded ifTrue:[activeMorphs reSort].		(activationKeys at: f) do:[:m|			m stepToFrame: f.			m visible ifTrue:[activeMorphs add: m].		].	].! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 13:57'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print:'actionTarget = '; target; endEntry.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 16:01'!gotoFrame: frame	"Jump to the given frame"	self frameNumber: frame+1.	self stop.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 18:06'!play	"Start playing from the current frame"	frameNumber >= frames ifTrue:[self frameNumber: 1].	self startStepping.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/17/1998 17:57'!stop	"Stop playing at the current frame."	self stopStepping.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:25'!addMorph: aMorph frame: relFrame	"Do not change the color"	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!adjustBookControls	| inner |	startButton ifNil: [^ self].	startButton align: startButton topLeft with: (inner _ self innerBounds) topLeft + (20@-4).	stopButton align: stopButton topRight with: inner topRight - (16@4).! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:50'!initialize	| aFont |	super initialize.	aFont _ Preferences fontForScriptorButtons.	self addMorph: (startButton _ SimpleButtonMorph new borderWidth: 0;			label: 'play' font: aFont; color: Color transparent;			actionSelector: #play; target: self).	startButton setBalloonText: 'continue playing'.	self addMorph: (stopButton _ SimpleButtonMorph new borderWidth: 0;			label: 'stop' font: aFont; color: Color transparent;			actionSelector: #stop; target: self).	stopButton setBalloonText: 'stop playing'.	startButton submorphs first color: Color blue.	stopButton submorphs first color: Color red.	self adjustBookControls! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:39'!openInMVCExtent: extent	Smalltalk isMorphic ifTrue:[^self openInWorldExtent: extent].	super openInMVCExtent: (extent + borderWidth + (0@self labelHeight))! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:39'!openInWorldExtent: extent	Smalltalk isMorphic ifFalse:[^self openInMVCExtent: extent].	super openInWorldExtent: (extent + borderWidth + (0@self labelHeight))! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:12'!play	model play! !!FlashPlayerWindow methodsFor: 'all' stamp: 'ar 11/17/1998 15:09'!stop	model stop! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 11:39'!id	^-1! !!FlashSpriteMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 17:07'!initialize	super initialize.	sounds _ Dictionary new.	actions _ Dictionary new.	labels _ Dictionary new.	stepTime _ 1.	frameNumber _ 0.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:48'!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:48'!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:49'!addSound: aSound at: frameNr	| oldSound newSound |	oldSound _ sounds at: frameNr ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frameNr put: newSound.! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:28'!frameNumber	^frameNumber! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 16:28'!frameNumber: frame	^self stepToFrame: frame! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 17:06'!frames	^frames! !!FlashSpriteMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 17:06'!frames: aNumber	frames _ aNumber! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 17:05'!step	self visible ifFalse:[frameNumber _ 0. ^self].	self frameNumber: self frameNumber + 1! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 16:27'!stepTime	^stepTime! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 17:07'!stepTime: time	stepTime _ time.! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/17/1998 19:02'!stepToFrame: frame	"Step to the given frame"	| fullRect postDamage lastVisible resortNeeded |	frame = frameNumber ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	lastVisible _ nil.	resortNeeded _ false.	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m stepToFrame: frame.			m visible ifTrue:[				(lastVisible notNil and:[lastVisible depth < m depth])					ifTrue:[resortNeeded _ true].				lastVisible _ m.				(bounds containsRect: m bounds) ifFalse:[bounds _ bounds merge: m bounds].			].		].	].	resortNeeded ifTrue:[submorphs _ submorphs sortBy:[:m1 :m2| m1 depth > m2 depth]].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			"fullRect _ damageRecorder fullDamageRect.			fullRect _ (self transform localBoundsToGlobal: fullRect)."			fullRect _ bounds.			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[		damageRecorder _ nil].! !!FlashSpriteMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 16:27'!wantsSteps	^true! !!FlashSpriteMorph methodsFor: 'classification' stamp: 'ar 11/16/1998 17:03'!isFlashSprite	^true! !!FlashSpriteMorph methodsFor: 'change reporting' stamp: 'ar 11/16/1998 16:49'!invalidRect: rect	damageRecorder isNil ifTrue:[		super invalidRect: rect.	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/17/1998 19:47'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	Transcript cr; print:'actionTarget = '; target; endEntry.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!executeActions: actionList	actionList do:[:msg| msg sentTo: self].! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!gotoFrame: frame	"Jump to the given frame"		self frameNumber: frame.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:50'!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet.	Ignored for the moment."! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!play	"Start playing from the current frame"	self startStepping.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!stop	"Stop playing at the current frame."	self stopStepping.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!stopSounds	"Stop all sounds"	SoundPlayer shutDown.! !!FlashSpriteMorph methodsFor: 'animating' stamp: 'ar 11/16/1998 16:51'!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/16/1998 23:46'!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x _ aPoint x asFloat - (self a13).	y _ aPoint y asFloat - (self a23).	a11 _ self a11.	a12 _ self a12.	a21 _ self a21.	a22 _ self a22.	det _ (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det _ 1.0 / det.	detX _ (x * a22) - (a12 * y).	detY _ (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!SolidFillStyle methodsFor: 'printing' stamp: 'ar 11/17/1998 00:29'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; print: color; nextPut:$).! !!TranslucentColor methodsFor: 'testing' stamp: 'ar 11/17/1998 17:07'!isTransparent	^alpha = 0! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 11/17/1998 17:08'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	alpha = 0 ifTrue:[^0].	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !FlashFileReader removeSelector: #recordResetSubshape!FlashFileReader removeSelector: #processButtonRecords:from:!FlashFileReader removeSelector: #processDefineBits2:!FlashFileReader removeSelector: #processDefineBits3:!FlashButtonMorph removeSelector: #layoutChanged!FlashMorphReader removeSelector: #recordResetSubshape!