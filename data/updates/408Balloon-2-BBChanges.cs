'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:03:36 am'!"Change Set:		Balloon-2-BBChangesDate:			2 November 1998Author:			Andreas RaabAdds a new combination rule (34: alphaBlendScaled:with:) to BitBlt and a specialized inner loop for optimized execution from the graphics engine. Also fixes the check for OpTableSize in BBSim>>loadBitBltFrom:"!!BitBlt commentStamp: '<historical>' prior: 0!I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBltSimulation commentStamp: '<historical>' prior: 0!This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWord	34	alphaBlendScaled: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.To add a new rule to BitBlt...	1.  add the new rule method or methods in the category 'combination rules' of BBSim	2.  describe it in the class comment  of BBSim and in the class comment for BitBlt	3.  add refs to initializeRuleTable in proper positions	4.  add refs to initBBOpTable, following the pattern!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 10/31/1998 22:05'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > (OpTableSize - 2)]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 10/31/1998 20:50'!copyBits	| done |	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	"Try a shortcut for stuff that should be run as quickly as possible" 	done _ self tryCopyingBitsQuickly.	done ifTrue:[^nil].	self destMaskAndPointerInit.	bitCount _ 0.	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 11/11/1998 22:29'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	destX _ startX.	destY _ yValue.	sourceX _ startX.	width _ (stopX - startX).	self copyBits.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 11/14/1998 00:44'!tryCopyingBitsQuickly	"Shortcut for stuff that's being run from the balloon engine.	Since we do this at each scan line we should avoid the expensive 	setup for source and destination."	self inline: true.	"We need a source."	noSource ifTrue:[^false].	"We handle only combinationRule 34"	(combinationRule = 34) ifFalse:[^false].	"We handle only sourcePixSize 32"	(sourcePixSize = 32) ifFalse:[^false].	"We don't handle overlaps"	(sourceForm = destForm) ifTrue:[^false].	"We need at least 8bit deep dest forms"	(destPixSize < 8) ifTrue:[^false].	"If 8bit, then we want a color map"	(destPixSize = 8 and:[colorMap = interpreterProxy nilObject]) ifTrue:[^false].	destPixSize = 32 		ifTrue:[self alphaSourceBlendBits32].	destPixSize = 16		ifTrue:[self alphaSourceBlendBits16].	destPixSize = 8		ifTrue:[self alphaSourceBlendBits8].	affectedL _ dx.	affectedR _ dx + bbW.	affectedT _ dy.	affectedB _ dy + bbH.	^true! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/15/1998 02:37'!alphaSourceBlendBits16	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 16		sourceForm ~= destForm.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust |	self inline: false. "This particular method should be optimized in itself"	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	(dx bitAnd: 1) = 0 		ifTrue:[	mask1 _ 16r0000FFFF.				srcShift _ 16.				adjust _ 0]		ifFalse:[mask1 _ 16rFFFF0000.				srcShift _ 0.				adjust _ 16r0F0F0F0F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r0F0F0F0F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r0F0F0F0F.		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 2)) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		dstMask _ mask1.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((interpreterProxy longAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			"Treat srcAlpha >= 240 as opaque"			srcAlpha = 240 ifTrue:[				sourceWord _ self rgbMap: sourceWord from: 8 to: 5.				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha <= 15 ifTrue:[					"Treat srcAlpha <= 15 as transparent"				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ self rgbMap: destWord from: 5 to: 8.					destWord _ destWord bitOr: 16rFF000000.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.										sourceWord _ self rgbMap: sourceWord from: 8 to: 5.					sourceWord _ sourceWord << srcShift.					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask.					interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).				].			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[dstIndex _ dstIndex + 4].			srcShift _ srcShift bitXor: 16. "Toggle between 0 and 16"			dstMask _ dstMask bitInvert32. "Mask other half word"			adjust _ adjust bitXor: 16r0F0F0F0F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/2/1998 02:20'!alphaSourceBlendBits32	"This version assumes 		combinationRule = 34		sourcePixSize = destPixSize = 32		sourceForm ~= destForm.	Note: The inner loop has been optimized for dealing		with the special cases of srcAlpha = 0.0 and srcAlpha = 1.0 	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY srcY dstY |	self inline: false. "This particular method should be optimized in itself"	"Give the compile a couple of hints"	self var: #sourceWord declareC:'register int sourceWord'.	self var: #deltaX declareC:'register int deltaX'.	"The following should be declared as pointers so the compiler will	notice that they're used for accessing memory locations 	(good to know on an Intel architecture) but then the increments	would be different between ST code and C code so must hope the	compiler notices what happens (MS Visual C does)"	self var: #srcIndex declareC:'register int srcIndex'.	self var: #dstIndex declareC:'register int dstIndex'.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + dx) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ interpreterProxy longAt: srcIndex.			srcAlpha _ sourceWord >> 24.			srcAlpha = 255 ifTrue:[				interpreterProxy longAt: dstIndex put: sourceWord.				srcIndex _ srcIndex + 4.				dstIndex _ dstIndex + 4.				"Now copy as many words as possible with alpha = 255"				[(deltaX _ deltaX - 1) ~= 0 and:[					(sourceWord _ interpreterProxy longAt: srcIndex) >> 24 = 255]]						whileTrue:[							interpreterProxy longAt: dstIndex put: sourceWord.							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].				"Adjust deltaX"				deltaX _ deltaX + 1.			] ifFalse:[ "srcAlpha ~= 255"				srcAlpha = 0 ifTrue:[					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.					"Now skip as many words as possible,"					[(deltaX _ deltaX - 1) ~= 0 and:[						(sourceWord _ interpreterProxy longAt: srcIndex) >> 24 = 0]]						whileTrue:[							srcIndex _ srcIndex + 4.							dstIndex _ dstIndex + 4.						].					"Adjust deltaX"					deltaX _ deltaX + 1.				] ifFalse:[ "0 < srcAlpha < 255"					"If we have to mix colors then just copy a single word"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ self alphaBlendScaled: sourceWord with: destWord.					interpreterProxy longAt: dstIndex put: destWord.					srcIndex _ srcIndex + 4.					dstIndex _ dstIndex + 4.				].			].		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 11/15/1998 02:56'!alphaSourceBlendBits8	"This version assumes 		combinationRule = 34		sourcePixSize = 32		destPixSize = 8		sourceForm ~= destForm.	Note: This is not real blending since we don't have the source colors available.	"	| srcIndex dstIndex sourceWord srcAlpha destWord deltaX deltaY 	srcY dstY dstMask srcShift adjust mappingTable |	self inline: false. "This particular method should be optimized in itself"	self var: #mappingTable declareC:'unsigned int *mappingTable'.	mappingTable _ self default8To32Table.	deltaY _ bbH + 1. "So we can pre-decrement"	srcY _ sy.	dstY _ dy.	mask1 _ 24 - ((dx bitAnd: 3) * 8).	mask2 _ AllOnes bitXor:(16rFF << mask1).	(dx bitAnd: 1) = 0 		ifTrue:[adjust _ 0]		ifFalse:[adjust _ 16r1F1F1F1F].	(dy bitAnd: 1) = 0		ifTrue:[adjust _ adjust bitXor: 16r1F1F1F1F].	"This is the outer loop"	[(deltaY _ deltaY - 1) ~= 0] whileTrue:[		adjust _ adjust bitXor: 16r1F1F1F1F.		srcIndex _ (sourceBits + 4) + ((srcY * sourceRaster + sx) * 4).		dstIndex _ (destBits + 4) + ((dstY * destRaster + (dx // 4)) * 4).		deltaX _ bbW + 1. "So we can pre-decrement"		srcShift _ mask1.		dstMask _ mask2.		"This is the inner loop"		[(deltaX _ deltaX - 1) ~= 0] whileTrue:[			sourceWord _ ((interpreterProxy longAt: srcIndex) bitAnd: (adjust bitInvert32)) + adjust.			srcAlpha _ sourceWord >> 24.			srcAlpha > 31 ifTrue:["Everything below 31 is transparent"				srcAlpha < 224 ifTrue:["Everything above 224 is opaque"					destWord _ interpreterProxy longAt: dstIndex.					destWord _ destWord bitAnd: dstMask bitInvert32.					destWord _ destWord >> srcShift.					destWord _ mappingTable at: destWord.					sourceWord _ self alphaBlendScaled: sourceWord with: destWord.				].				sourceWord _ self rgbMap: sourceWord from: 8 to: cmBitsPerColor.				sourceWord _ interpreterProxy fetchWord: sourceWord ofObject: colorMap.				sourceWord _ sourceWord << srcShift.				destWord _ interpreterProxy longAt: dstIndex.				destWord _ destWord bitAnd: dstMask.				interpreterProxy longAt: dstIndex put: (sourceWord bitOr: destWord).			].			srcIndex _ srcIndex + 4.			srcShift = 0 ifTrue:[				dstIndex _ dstIndex + 4.				srcShift _ 24.				dstMask _ 16r00FFFFFF.			] ifFalse:[				srcShift _ srcShift - 8.				dstMask _ (dstMask >> 8) bitOr: 16rFF000000.			].			adjust _ adjust bitXor: 16r1F1F1F1F.		].		srcY _ srcY + 1.		dstY _ dstY + 1.	].! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 11/11/1998 22:33'!alphaBlendScaled: sourceWord with: destinationWord	"Blend sourceWord with destinationWord using the alpha value from sourceWord.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	In contrast to alphaBlend:with: the color produced is		srcColor + (1-srcAlpha) * dstColor	e.g., it is assumed that the source color is already scaled."	| unAlpha dstMask srcMask b g r a |	self inline: false.	"Do NOT inline this into optimized loops"	unAlpha _ 255 - (sourceWord >> 24).  "High 8 bits of source pixel"	dstMask _ destinationWord.	srcMask _ sourceWord.	b _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	g _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	r _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	dstMask _ dstMask >> 8.	srcMask _ srcMask >> 8.	a _ (dstMask bitAnd: 255) * unAlpha >> 8 + (srcMask bitAnd: 255).	^(((((a << 8) + r) << 8) + g) << 8) + b! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 11/16/1998 00:23'!default8To32Table	"Return the default translation table from 1..8 bit indexed colors to 32bit"	"The table has been generated by the following statements"	"| pvs hex |	String streamContents:[:s|		s nextPutAll:'static unsigned int theTable[256] = { '.		pvs _ (Color colorMapIfNeededFrom: 8 to: 32) asArray.		1 to: pvs size do:[:i|			i > 1 ifTrue:[s nextPutAll:', '].			(i-1 \\ 8) = 0 ifTrue:[s cr].			s nextPutAll:'0x'.			hex _ (pvs at: i) printStringBase: 16.			s nextPutAll: (hex copyFrom: 4 to: hex size).		].		s nextPutAll:'};'.	]."	| theTable |	self returnTypeC:'unsigned int *'.	self var: #theTable declareC:'static unsigned int theTable[256] = { 0x0, 0xFF000001, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000001, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF};'.	^theTable! !!BitBltSimulation methodsFor: 'translation support' stamp: 'ar 10/12/1998 17:43'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[34+1] = (int)alphaBlendScaledwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'ar 10/12/1998 17:42'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:		"34" alphaBlendScaled:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !