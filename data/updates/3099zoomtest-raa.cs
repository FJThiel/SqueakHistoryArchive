'From Squeak2.9alpha of 17 July 2000 [latest update: #3154] on 10 December 2000 at 10:37:35 am'!"Change Set:		zoomtestDate:			10 December 2000Author:			Bob Arning- provide smoother scrolling and zooming of StoryboardBookMorph"!!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 12/8/2000 12:24'!drawSubmorphsOn: aCanvas	| r1 fullG r2 actualCanvas newClip where deferredMorphs case |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	useRegularWarpBlt == true ifTrue: [		^aCanvas 			transformBy: transform			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) rounded			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	r1 _ self innerBounds intersect: aCanvas clipRect.	r1 area = 0 ifTrue: [^self].	fullG _ (transform localBoundsToGlobal: self firstSubmorph fullBounds) rounded.	r2 _ r1 intersect: fullG.	r2 area = 0 ifTrue: [^self].	newClip _ (r2 expandBy: 1) rounded intersect: self innerBounds rounded.	deferredMorphs _ #().	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: newClip		during: [:myCanvas |			self scale > 1.0 ifTrue: [				actualCanvas _ myCanvas as: MultiResolutionCanvas.				actualCanvas deferredMorphs: (deferredMorphs _ OrderedCollection new).			] ifFalse: [				actualCanvas _ myCanvas.			].			submorphs reverseDo:[:m | actualCanvas fullDrawMorph: m].		]		smoothing: smoothing.	deferredMorphs do: [ :each |		where _ each bounds: each fullBounds in: self.		case _ 2.		case = 1 ifTrue: [where _ where origin rounded extent: where extent rounded].		case = 2 ifTrue: [where _ where rounded].		each drawHighResolutionOn: aCanvas in: where.	].! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/8/2000 12:28'!doProgrammedMoves	| thisMove startPoint endPoint startZoom endZoom newScale newPoint fractionLeft |	programmedMoves isEmptyOrNil ifTrue: [^programmedMoves _ nil].	thisMove _ programmedMoves first.	fractionLeft _ self fractionLeftInMove: thisMove.	fractionLeft ifNil: [^programmedMoves _ programmedMoves allButFirst].	startPoint _ thisMove at: #startPoint ifAbsentPut: [self cameraPoint].	endPoint _ thisMove at: #endPoint ifAbsentPut: [self cameraPoint].	startZoom _ thisMove at: #startZoom ifAbsentPut: [self cameraScale].	endZoom _ thisMove at: #endZoom ifAbsentPut: [self cameraScale].	newScale _ endZoom - (endZoom - startZoom * fractionLeft).	newPoint _ (endPoint - (endPoint - startPoint * fractionLeft)) "rounded".	target changeScaleTo: newScale.	target cameraPoint: newPoint.	fractionLeft <= 0 ifTrue: [^programmedMoves _ programmedMoves allButFirst].! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/8/2000 12:27'!changeOffsetBy: aPoint	| transform rounder roundPt |	"improve behavior at high magnification by rounding change to whole source pixels"	transform _ self myTransformMorph.	rounder _ [ :val |		"(val abs + (transform scale * 0.99) roundTo: transform scale) * val sign"		"looks like rounding wasn't a good solution"		val	].	roundPt _ (rounder value: aPoint x) @ (rounder value: aPoint y).	self changeOffsetTo: transform offset + roundPt.! !