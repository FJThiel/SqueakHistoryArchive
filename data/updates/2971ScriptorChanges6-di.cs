'From Squeak2.9alpha of 12 June 2000 [latest update: #3019] on 16 November 2000 at 11:59:53 am'!"Change Set:		ScriptorChanges6Date:			15 November 2000Author:			Dan IngallsTweaks the blue block margin.Eliminates the block margin on the method as a whole.Adds a fine brown line between method header and body.Tiles dropped in world stay bevelled, and grab as a unit.Makes the statement insertion caret into a real arrow.Makes insertion arrows only show in the nearest block.Fixes paste into a block (used to leave a blank line)."!!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/15/2000 22:54'!mouseDown: evt 	| dup unit |	evt yellowButtonPressed ifTrue: [^ self showMenu: evt].	self root ifNotNil:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == outerMorph or: [self hasOwner: outerMorph]])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"Out in the world -- treat as a unit"	(self nodeClassIs: MethodNode) ifTrue:		[^ self]. "whole method not draggable"	unit _ (self outermostMorphThat: [:m | m isSyntaxMorph]) ifNil: [self].	unit isPartsDonor 		ifTrue: [dup _ unit duplicate.				dup setProperty: #beScript toValue: true]		ifFalse: [dup _ unit].	evt hand attachMorph: dup.	^ dup align: dup topLeft with: evt hand position + self cursorBaseOffset.! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/16/2000 10:02'!mouseEnterDragging: evt	"Highlight this level as a potential drop target""Transcript cr; print: self; show: ' enterDragging'."	self unhighlightOwner.	self highlightForDrop: evt.	(self nodeClassIs: BlockNode) ifTrue:		[(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m nodeClassIs: BlockNode]])			ifNotNilDo: [:m | "Suspend outer block."						m stopStepping; hideCaret].		self startStepping]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/16/2000 10:02'!mouseLeaveDragging: evt"Transcript cr; print: self; show: ' leaveDragging'."	(self nodeClassIs: BlockNode) ifTrue:		[self stopStepping; hideCaret.		(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m nodeClassIs: BlockNode]])			ifNotNilDo: [:m | "Activate outer block."						m startStepping]].	"Move drop highlight back out a level"	self unhighlight.	(owner ~~ nil and: [owner isSyntaxMorph])		ifTrue: [owner highlightForDrop: evt].! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 11/16/2000 11:18'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m nodeClassIs: BlockNode])			ifTrue: [m stopStepping; hideCaret]].	(self nodeClassIs: BlockNode) & itNoun		ifTrue:			[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse:					["if already declared, start new line of code with it"					self addToBlock: aMorph event: evt]]			ifFalse:			[^ self addToBlock: aMorph event: evt]].	"If I am a BlockNode and it is a noun add it as a new line"	(self nodeClassIs: BlockNode) ifTrue: [		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[((aMorph nodeClassIs: TempVariableNode)				or: [aMorph nodeClassIs: VariableNode])  ifFalse: [ ^ self]]]].	(old _ owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	old cleanupAfterItDroppedOnMe.	"now owned by no one"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 11/16/2000 11:29'!cleanupAfterItDroppedOnMe	"A tile just dropped into me.  Clean up"	self layoutChanged.	(self ownerThatIsA: ScriptEditorMorph) ifNotNil:		["Auto-accept on drop if in a scriptor"		self root ifNotNilDo: [:m | m accept]].! !!SyntaxMorph methodsFor: 'drawing' stamp: 'di 11/15/2000 22:29'!drawOn: aCanvas	super drawOn: aCanvas.	(self nodeClassIs: BlockNode) ifTrue:		[(owner nodeClassIs: MethodNode)		ifTrue:			[aCanvas fillRectangle: (self topLeft + (0@-1) extent: self width@1) color: Color brown]		ifFalse:			[aCanvas fillRectangle: (self topLeft + (1@1) extent: 2@(self height-2)) color: Color blue.			aCanvas fillRectangle: (self topLeft + (1@1) extent: 4@1) color: Color blue.			aCanvas fillRectangle: (self bottomLeft + (1@-1) extent: 4@1) color: Color blue].		]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'di 11/15/2000 22:47'!unhighlight	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		(self == outerMorph or: [owner notNil and: [owner isSyntaxMorph not]])			ifTrue: [self borderColor: #raised]			ifFalse: [self borderColor: self stdBorderColor]]! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 11/16/2000 08:05'!addCaretFront: aMorph	"Add a caret morph without triggering re-layout.	This is just a copy of addMorphFront: without layoutChanged"	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	self isInWorld ifTrue: [self invalidRect: aMorph fullBounds from: aMorph].! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 11/16/2000 08:43'!insertionIndexForCaret: aPoint	"Like insertionIndexFor:, but only looks at SyntaxMorphs"	| last |	last _ 0.	submorphs withIndexDo:		[:m :i | m isSyntaxMorph ifTrue:			[m bottom > aPoint y ifTrue: [^ i].			last _ i]].	^ last! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 11/16/2000 08:05'!removeCaret: aMorph	"Remove the caret morph without triggering layout.	This is a copy of privateRemoveMorph: without layoutChanged."	self isInWorld ifTrue: [self invalidRect: aMorph fullBounds from: aMorph].	submorphs _ submorphs copyWithout: aMorph.! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 11/16/2000 08:37'!showCaretAt: location	| newArrow |	self valueOfProperty: #caretMorph ifPresentDo:		[:arrow | ^ arrow align: arrow bounds leftCenter with: location].	newArrow _ (PolygonMorph vertices: {0@0. 12@-9. 12@-5. 20@-5. 20@5. 12@5. 12@9}			color: Color yellow borderWidth: 1 borderColor: Color yellow darker)			on: #mouseEnterDragging send: #mouseEnterDragging:inCaret: to: self;			on: #mouseLeaveDragging send: #mouseLeaveDragging:inCaret: to: self.	self addCaretFront: newArrow.	self setProperty: #caretMorph toValue: newArrow.	newArrow align: newArrow bounds leftCenter with: location! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'di 11/16/2000 10:03'!trackCaret	| hand i pt localPt sub |	hand _ self primaryHand.	(hand lastEvent redButtonPressed and: [(self hasOwner: hand) not]) ifTrue:		[localPt _ self globalPointToLocal: hand position.		(i _ self insertionIndexForCaret: localPt) = 0 ifFalse: [			sub _ submorphs at: i.			pt _ localPt y < sub center y				ifTrue: [sub topLeft + (i=2 ifTrue: [-3@2] ifFalse: [-3@-2])]				ifFalse: [sub bottomLeft + (-3@-2)].			^ self showCaretAt: pt]].! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/16/2000 11:35'!addBlockArg: aMorph	| tempHolder tt var nn row |	"Add a temporary to a block or the method.  Return true if succeed"	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	owner parseNode class == MethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not insided the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph class == SyntaxMorph 				ifTrue: [tt parseNode class == BlockArgsNode 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ (aMorph allMorphs detect: [:rr | rr class == StringMorph]) contents.	"name"	tempHolder ifNil: ["make whole row"		row _ self addRow: #blockarg1 on: (BlockArgsNode new).		self addMorphFront: row.		aMorph parseNode name: nn key: nn code: nil.		var _ row addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		self cleanupAfterItDroppedOnMe.		^ true].	tempHolder ifNotNil: [		"If this variable is not present, add it"		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].				"is present. caller adds the temp as a new line of code to be extended"		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		var cleanupAfterItDroppedOnMe.		^ true].! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/16/2000 11:42'!addTempVar: aMorph 	"know we are a block inside a MethodNode" 	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	| tempHolder ii tt var nn tempMorph |	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.						(tt isSyntaxMorph and: [tt parseNode class == MethodTempsNode])					 		ifTrue: [tt] ifFalse: [nil]]				ifTrue: [nil].	nn _ parseNode key.	"name"	tempHolder ifNil: [		tempMorph _ owner addRow: #tempVariable on: MethodTempsNode new.		owner addMorph: tempMorph inFrontOf: self.		tempMorph color: tempMorph color darker.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempMorph.		tempMorph cleanupAfterItDroppedOnMe.		^ true].	tempHolder ifNotNil: [		tempHolder submorphsDo:			[:m | m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		var cleanupAfterItDroppedOnMe.		^ true]! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/16/2000 11:21'!addToBlock: aMorph event: evt	"Insert a new line of code"	| whereDropped dropBefore |	whereDropped _ "self pointFromWorld:" evt cursorPoint.	dropBefore _ self submorphs 		detect: [:each | each isSyntaxMorph and: [whereDropped y < each center y]] 		ifNone: [nil].	(aMorph nodeClassIs: ReturnNode) ifTrue: [dropBefore _ nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [self addMorph: aMorph inFrontOf: dropBefore].	self cleanupAfterItDroppedOnMe.! !!SyntaxMorph methodsFor: 'printing' stamp: 'di 11/16/2000 11:27'!printOn: strm indent: level 	| lev nodeClass first |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner parseNode class == MethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $( ]].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	first _ true.	submorphs do: [:sub |		sub isSyntaxMorph ifTrue: [			nodeClass == CascadeNode & first not ifTrue: [				color = (SyntaxMorph translateColor: #cascade2) ifTrue: [strm nextPut: $;; space ]].			nodeClass == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not	& 				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not					ifTrue: [strm crtab: lev]				ifFalse: [nodeClass == MethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			first _ false].		sub class == StringMorph ifTrue: [strm nextPutAll: sub contents].		"return indent for ifTrue: ifFalse:"].	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $) ]].	nodeClass  == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner parseNode class == MethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].	"erase last period"! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/15/2000 22:19'!testAllMethodsOver: methodSize  "MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 600]" 	"Add up the total layout area for syntax morphs representing all methods	over the given size.  This is a stress-test for SyntaxMorph layout.	A small value for the total area is also a figure of merit in the presentation	of Squeak source code in general.""Results:	#(69 600 180820874 103700)  11/4	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoffFolded wide receivers, don't center keywords any more.	#(68 600 160033784 127727)  11/9	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoffFolded more messages, dropped extra vertical spacing in blocks.	#(68 600 109141704 137308)  11/10	79% build morphs, 6% get source, 8% layout, 7% parseFolded more messages, dropped extra horizontal spacing.	#(68 600 106912968 132171)  11/10	80% build morphs, ??% get source, 11% layout, 7% parseUnfolded keyword messages that will fit on one line.	#(68 600 96497372 132153)  11/10	81% build morphs, ??% get source, 8% layout, 8% parseAfter alignment rewrite...	#(74 600 101082316 244799)  11/12	76% build morphs, 4% get source, 15% layout, 5% parseAfter alignment rewrite...	#(74 600 101250620 204972)  11/15	74% build morphs, 6% get source, 13% layout, 7% parse"	| tree source biggies morph stats time area |	biggies _ Smalltalk allSelect: [:cm | cm size > methodSize].	stats _ OrderedCollection new.'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'	displayProgressAt: Sensor cursorPoint	from: 1 to: biggies size	during:		[:bar |		biggies withIndexDo:			[:methodRef :i | bar value: i.			Utilities setClassAndSelectorFrom: methodRef in: 				[:aClass :aSelector |				source _ (aClass compiledMethodAt: aSelector) getSourceFromFile.				time _ Time millisecondsToRun:					[tree _ Compiler new 						parse: source 						in: aClass 						notifying: nil.					morph _ tree asMorphicSyntaxUsing: SyntaxMorph.					area _ morph fullBounds area]].			stats add: {methodRef. area. time}]		].	^ {{biggies size.  methodSize. stats detectSum: [:a | a second]. stats detectSum: [:a | a third]}.		(stats asSortedCollection: [:x :y | x third >= y third]) asArray}! !Morph removeSelector: #ownerThat:!