'From Squeak 2.3 of January 14, 1999 on 2 February 1999 at 4:26:39 pm'!"Change Set:		SoundCodecs-jhmDate:			2 February 1999Author:			John MaloneyIntroduces an architecture for sound compression/decompressionalgorithms (called "codecs") and supplies a mu-law codec as a simpleexample."!Object subclass: #CompressedSoundData	instanceVariableNames: 'channels soundClassName codecName loopEnd loopLength perceivedPitch samplingRate gain firstSample '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!Object subclass: #SoundCodec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!SoundCodec subclass: #MuLawCodec	instanceVariableNames: ''	classVariableNames: 'DecodingTable '	poolDictionaries: ''	category: 'Music-Synthesis'!!AbstractSound methodsFor: 'composition' stamp: 'jm 2/2/1999 15:53'!asSound	^ self! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:10'!channels	"Answer an array of ByteArrays containing the compressed sound data for each channel."	^ channels! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!channels: anArray	channels _ anArray.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!codecName	"Answer the name of the sound codec used to compress this sound. Typically, this is the name of a class that can be used to decode the sound, but it is possible that the codec has not yet been implemented or is not filed into this image."	^ codecName! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:45'!codecName: aStringOrSymbol	codecName _ aStringOrSymbol asSymbol.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!firstSample	"Answer the firstSample of the original sound."	^ firstSample! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!firstSample: anInteger	firstSample _ anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:55'!gain	"Answer the gain of the original sound."	^ gain! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!gain: aNumber	gain _ aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!loopEnd	"Answer index of the last sample of the loop, or nil if the original sound was not looped."	^ loopEnd! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:35'!loopEnd: anInteger	loopEnd _ anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!loopLength	"Answer length of the loop, or nil if the original sound was not looped."	^ loopLength! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:35'!loopLength: anInteger	loopLength _ anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!perceivedPitch	"Answer the perceived pitch of the original sound. By convention, unpitched sounds (like drum hits) are given an arbitrary pitch of 100.0."	^ perceivedPitch! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!perceivedPitch: aNumber	perceivedPitch _ aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:13'!samplingRate	"Answer the samplingRate of the original sound."	^ samplingRate! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:36'!samplingRate: aNumber	samplingRate _ aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!soundClassName	"Answer the class name of the uncompressed sound."	^ soundClassName! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!soundClassName: aStringOrSymbol	soundClassName _ aStringOrSymbol asSymbol.! !!CompressedSoundData methodsFor: 'converting' stamp: 'jm 2/2/1999 16:01'!asSound	"Answer the result of decompressing the receiver."	| codecClass |	codecClass _ Smalltalk at: codecName		ifAbsent: [^ self error: 'The codec for decompressing this sound is not available'].	^ (codecClass new decompressSound: self)! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 2/2/1999 14:14'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	super initialize.	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 2/2/1999 14:14'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	super initialize.	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:54'!perceivedPitch	^ perceivedPitch! !!MuLawCodec class methodsFor: 'class initialization' stamp: 'jm 2/2/1999 08:46'!initialize	"Build the 256 entry table to be used to decode 8-bit uLaw-encoded samples."	"MuLawCodec initialize"	| encoded codec lastEncodedPos lastEncodedNeg |	DecodingTable _ Array new: 256.	codec _ self new.	lastEncodedPos _ nil.	lastEncodedNeg _ nil.	4095 to: 0 by: -1 do: [:s |		encoded _ codec uLawEncodeSample: s.		lastEncodedPos = encoded			ifFalse: [				DecodingTable at: (encoded + 1) put: (s bitShift: 3).				lastEncodedPos _ encoded].		encoded _ encoded bitOr: 16r80.		lastEncodedNeg = encoded			ifFalse: [				DecodingTable at: (encoded + 1) put: (s bitShift: 3) negated.				lastEncodedNeg _ encoded]].! !!SoundCodec commentStamp: 'jm 2/2/1999 15:37' prior: 0!I am an abstract class that describes the protocol for sound codecs. Each codec (the name stems from "COder/DECoder") describes a particular algorithm for compressing and decompressing sound data. Most sound codecs are called 'lossy' because they lose information; the decompressed sound data is not exactly the same as the original data.!!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!compressAndDecompress: aSound	"Compress and decompress the given sound. Useful for testing."	"(MuLawCodec new compressAndDecompress: (SampledSound soundNamed: 'camera')) play"	^ (self compressSound: aSound) asSound! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!compressSound: aSound	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels |	compressed _ CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		channels _ Array new: 1.		channels at: 1 put: (self encodeSoundBuffer: aSound samples).		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: 1;			loopEnd: aSound samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels _ Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels _ Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:00'!decompressSound: aCompressedSound	"Decompress the entirety of the given compressed sound with this codec and answer the resulting sound."	| channels sound |	channels _ aCompressedSound channels		collect: [:compressed | self decodeCompressedData: compressed].	'SampledSound' = aCompressedSound soundClassName ifTrue: [		sound _ SampledSound			samples: channels first			samplingRate: (aCompressedSound samplingRate).		sound setLoudness: aCompressedSound gain.		^ sound].	'LoopedSampledSound' = aCompressedSound soundClassName ifTrue: [		aCompressedSound loopLength = 0			ifTrue: [				sound _ LoopedSampledSound					unloopedSamples: channels first					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate]			ifFalse: [				sound _ LoopedSampledSound					samples: channels first					loopEnd: aCompressedSound loopEnd					loopLength: aCompressedSound loopLength					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate].		channels size > 1 ifTrue: [sound rightSamples: channels last].		sound			firstSample: aCompressedSound firstSample;			gain: aCompressedSound gain.		sound			setPitch: 100.0			dur: (channels first size / aCompressedSound samplingRate)			loudness: 1.0.		^ sound].	self error: 'unknown sound class'.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:38'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:41'!decodeSoundbytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:39'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:45'!samplesPerFrame	"Answer the number of sound samples per compression frame."	self subclassResponsibility.! !!SoundCodec methodsFor: 'private' stamp: 'jm 2/2/1999 15:40'!decodeCompressedData: aByteArray	"Decode the entirety of the given encoded data buffer with this codec. Answer a monophonic SoundBuffer containing the uncompressed samples."	| codeFrameSize frameCount result increments |	codeFrameSize _ self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue: [self error: 'variable frame size codecs are not yet handled'].	(aByteArray size \\ codeFrameSize) = 0 ifFalse: [		self error: 'encoded buffer is not an even multiple of the encoded frame size'].	frameCount _ aByteArray size // codeFrameSize.	result _ SoundBuffer newMonoSampleCount: frameCount * self samplesPerFrame.	increments _ self decodeFrames: frameCount from: aByteArray at: 1 into: result at: 1.	((increments first = aByteArray size) and: [increments last = result size]) ifFalse: [		self error: 'implementation problem; increment sizes should match buffer sizes'].	^ result! !!SoundCodec methodsFor: 'private' stamp: 'jm 2/2/1999 15:44'!encodeSoundBuffer: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i |	codeFrameSize _ self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue: [self error: 'variable frame size codecs are not yet handled'].	frameSize _ self samplesPerFrame.	fullFrameCount _ aSoundBuffer monoSampleCount // frameSize.	lastFrameSamples _ aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).	lastFrameSamples > 0		ifTrue: [result _ ByteArray new: (fullFrameCount + 1) * self bytesPerEncodedFrame]		ifFalse: [result _ ByteArray new: fullFrameCount * self bytesPerEncodedFrame].	increments _ self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.	lastFrameSamples > 0 ifTrue: [		finalFrame _ SoundBuffer newMonoSampleCount: frameSize.		i _ fullFrameCount * frameSize.		1 to: lastFrameSamples do: [:j |			finalFrame at: j put: (aSoundBuffer at: (i _ i + 1))].		self encodeFrames: 1 from: finalFrame at: 1 into: result at: (1 + increments at: 2)].	^ result! !!MuLawCodec commentStamp: 'jm 2/2/1999 15:52' prior: 0!I represent a mu-law (u-law) codec. I compress sound data by a factor of 2:1 by encoding the most significant 12 bits of each 16-bit sample as a signed, exponentially encoded byte. The idea is to use more resolution for smaller lower sample values. This encoding was developed for the North American phone system and a variant of it, a-law, is a European phone standard. It is a popular sound encoding on Unix platforms (.au files).!!MuLawCodec methodsFor: 'all' stamp: 'jm 2/2/1999 09:15'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	^ 1! !!MuLawCodec methodsFor: 'all' stamp: 'jm 2/2/1999 14:10'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| dst |	dst _ dstIndex.	srcIndex to: srcIndex + frameCount - 1 do: [:src |		dstSoundBuffer at: dst put: (DecodingTable at: (srcByteArray at: src) + 1).		dst _ dst + 1].	^ Array with: frameCount with: frameCount! !!MuLawCodec methodsFor: 'all' stamp: 'jm 2/2/1999 13:53'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| s |	srcIndex to: srcIndex + frameCount - 1 do: [:i |		s _ srcSoundBuffer at: i.		s _ s bitShift: -3.  "drop 4 least significant bits"		s < 0			ifTrue: [s _ (self uLawEncodeSample: s negated) bitOr: 16r80]			ifFalse: [s _ (self uLawEncodeSample: s)].		dstByteArray at: i put: s].	^ Array with: frameCount with: frameCount! !!MuLawCodec methodsFor: 'all' stamp: 'jm 2/2/1999 09:11'!samplesPerFrame	"Answer the number of sound samples per compression frame."	^ 1! !!MuLawCodec methodsFor: 'all' stamp: 'jm 2/2/1999 08:24'!uLawEncodeSample: s	"Encode the given 16-bit signed sample using the uLaw 8-bit encoding."	s < 496 ifTrue: [		s < 112 ifTrue: [			s < 48 ifTrue: [				s < 16					ifTrue: [^ 16r70 bitOr: (15 - s)]					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].		s < 240			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].	s < 2032 ifTrue: [		s < 1008			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].	s < 4080		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]		ifFalse: [^ 0].! !MuLawCodec initialize!