'From Squeak2.9alpha of 17 July 2000 [latest update: #2466] on 3 August 2000 at 7:52:31 am'!"Change Set:		multiProjects9Date:			17 July 2000Author:			Bob Arninglast changes before first demo- added several rollover indicators for the fridge:--- blue for mouse enter--- magenta if dragging a sender badge--- green if dragging any other morph- made gate keeper default to all messages allowed (change before release)- sender badge always scale picture- debugging method (EToySenderMorph instanceReport)- added 'GOT IT!!' indicator to signal drop acceptance- do not try to copy NewHandleMorph instances if they are dropped on you- added 'YUM' sound when morphs ddropped and accepted for transmission (if yum.aif in squeak directory)- added visual overlay to project being saved to avoid confusion- fixed (mostly) progress morph appearing in front of dialog that appears while it is running- added a rename (in postscript) for ServerDirectory DaniOnJumbo- added balloon help with full url for directories in file pickers (FileList2)- added Morph>>boundsForBalloon which allows morphs to provide a better bounds rectangle for balloon help (useful for morphs in a list which have bounds that are too wide)- updated file picker for projects to include .project files- fixes a walkback when trying to enter an MVC project by clicking on a ProjectViewmorph- when dropping a morph into a ProjectViewMorph, update the PVM with a scaled representation of the dropee- reduced flashing of ui when complex progress is running- cleaned up file selection stuff in preparation for new options- new file picker from Find button in ProjectNavigatorMorph (hold the mouse down for menu)- enabled opening a morphic project from an MVC file list- enabled Project fromUrl: from an MVC project- added startup and shutdown logic to EToyListenerMorph to avoid bad socket problems- add project name display inside ProjectViewMorph- fixed FileList to correctly parse directory and local name when filing in from server with different path delimiter from local file system- added blue border to all plain white progress indicators- removed (useless?) one-pixel border from World when saving- beginnings of text outliner - (EToyHierarchicalTextGizmo example)- changed HandMorph>>dropMorphsEvent: to round dropped morph bounds to help avoid some funky off-by-one drawing errors"!Model subclass: #AbstractHierarchicalList	instanceVariableNames: 'currentSelection myBrowser '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!AbstractHierarchicalList subclass: #EToyHierarchicalTextGizmo	instanceVariableNames: 'topNode '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Outliner'!!EToyHierarchicalTextGizmo commentStamp: '<historical>' prior: 0!EToyHierarchicalTextGizmo example!Object subclass: #EToyIncomingMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!ListItemWrapper subclass: #EToyTextNodeWrapper	instanceVariableNames: 'parentWrapper '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Outliner'!ListItemWrapper subclass: #FileDirectoryWrapper	instanceVariableNames: 'itemName balloonText '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!BorderedMorph subclass: #DoCommandOnceMorph	instanceVariableNames: 'target command actionBlock innerArea '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!EToyCommunicatorMorph commentStamp: '<historical>' prior: 0!====== find and report all instances =====	EToySenderMorph instanceReport====== zap a bunch of ipAddresses =====	EToySenderMorph allInstances do: [ :each | 		each ipAddress = '11.11.11.11' ifTrue: [each ipAddress: 'whizzbang']	].==================== now change one of the whizzbang's back to the right address=========== delete the whizzbangs ======	EToySenderMorph allInstances do: [ :each | 		each ipAddress = 'whizzbang' ifTrue: [each stopStepping; delete]	].!]style[(44 32 41 64 13 42 1 85 37 115 1)f1,f1cblue;,f1,f1cblue;,f1cred;,f1cblue;,f1,f1cred;,f1,f1cblue;,f1!EToyCommunicatorMorph subclass: #EToyListenerMorph	instanceVariableNames: 'listener updateCounter '	classVariableNames: 'GlobalIncomingQueue GlobalListener QueueSemaphore UpdateCounter WasListeningAtShutdown '	poolDictionaries: ''	category: 'Morphic-Experimental'!IndentingListItemMorph subclass: #IndentingListParagraphMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Outliner'!SimpleHierarchicalListMorph subclass: #EToyHierarchicalTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Outliner'!TextContainer subclass: #SimplerTextContainer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Outliner'!TextMorph subclass: #EToyTextNode	instanceVariableNames: 'children firstDisplay '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Outliner'!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime '	classVariableNames: 'DeferredUIMessages DisableDeferredUpdates LastCycleTime MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Worlds'!!AbstractHierarchicalList methodsFor: 'object fileIn' stamp: 'RAA 7/30/2000 19:51'!convertcm0: varDict dcm0: smartRefStrm	"These variables are automatically stored into the new instance #('currentSelection' 'myBrowser').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('dependents')  If a non-nil value is needed, please assign it."! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 17:29'!forkProgressWatcher	| killTarget |	[		[stageCompleted < 999 and: 				[formerProject == Project current and: 				[formerWorld == World and: 				[translucentMorph world notNil and:				[formerProcess suspendedContext notNil and: 				[Project uiProcess == formerProcess]]]]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			translucentMorph owner addMorphInLayer: translucentMorph.			(Time millisecondClockValue - WorldState lastCycleTime) abs > 500 ifTrue: [				self backgroundWorldDisplay			].			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		killTarget _ targetMorph ifNotNil: [			targetMorph valueOfProperty: #deleteOnProgressCompletion		].		formerWorld == World ifTrue: [			translucentMorph delete.			killTarget ifNotNil: [killTarget delete].		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.			killTarget ifNotNil: [killTarget privateDeleteWithAbsolutelyNoSideEffects].		].	] forkAt: 6.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 11:36'!withProgressDo: aBlock	| safetyFactor totals trialRect delta stageCompletedString |	Smalltalk isMorphic ifFalse: [^aBlock value].	formerProject _ Project current.	formerWorld _ World.	formerProcess _ Processor activeProcess.	targetMorph ifNil: [targetMorph _ ProgressTargetRequestNotification signal].	targetMorph ifNil: [		trialRect _ Rectangle center: Sensor cursorPoint extent: 80@80.		delta _ trialRect amountToTranslateWithin: formerWorld bounds.		trialRect _ trialRect translateBy: delta.		translucentMorph _ TranslucentProgessMorph new			opaqueBackgroundColor: Color white;			bounds: trialRect;			openInWorld: formerWorld.	] ifNotNil: [		translucentMorph _ TranslucentProgessMorph new			setProperty: #morphicLayerNumber toValue: targetMorph morphicLayerNumber - 0.1;			bounds: targetMorph bounds;			openInWorld: targetMorph world.	].	stageCompleted _ 0.	safetyFactor _ 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	totals _ self loadingHistoryDataForKey: 'total'.	newRatio _ 1.0.	estimate _ totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	start _ Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note |		stageCompletedString _ (note messageText findTokens: ' ') first.		stageCompleted _ (stageCompletedString copyUpTo: $:) asNumber.		cumulativeStageTime _ Time millisecondClockValue - start max: 1.		prevData _ self loadingHistoryDataForKey: stageCompletedString.		prevData isEmpty ifFalse: [			newRatio _ (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self 			loadingHistoryAt: stageCompletedString 			add: cumulativeStageTime.		translucentMorph 			setProperty: #progressStageNumber 			toValue: stageCompleted + 1.		note resume.	].	stageCompleted _ 999.	"we may or may not get here"! !!ComplexProgressIndicator class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 11:40'!historyReport"ComplexProgressIndicator historyReport"	| answer data |	History ifNil: [^1 beep].	answer _ String streamContents: [ :strm |		(History keys asSortedCollection: [ :a :b | a asString <= b asString]) do: [ :k |			strm nextPutAll: k printString; cr.			data _ History at: k.			(data keys asSortedCollection: [ :a :b | a asString <= b asString]) do: [ :dataKey |				strm tab; nextPutAll: dataKey printString,'  ',					(data at: dataKey) asArray printString; cr.			].			strm cr.		].	].	StringHolder new		contents: answer contents;		openLabel: 'Progress History'! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:53'!addChild	self addNewChildAfter: nil.! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:52'!addNewChildAfter: aNodeOrNil	currentSelection addNewChildAfter: aNodeOrNil.	self changed: #getList.! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:41'!addSibling	currentSelection addSibling.	self changed: #getList.! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:29'!deleteSelectedItem	currentSelection delete.	self changed: #getList.! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:57'!expandAllBelow	currentSelection withoutListWrapper withAllChildrenDo: [ :each |		each setProperty: #showInOpenedState toValue: true	].	self changed: #getList.! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:57'!genericMenu: aMenu	| menu |	currentSelection ifNil: [		aMenu add: '*nothing selected*' target: self selector: #yourself.		^aMenu	].	menu _ DumberMenuMorph new defaultTarget: self.	menu 		add: 'expand all below me' target: self selector: #expandAllBelow;		add: 'addChild' target: self selector: #addChild;		add: 'delete' target: self  selector: #deleteSelectedItem.	^ menu! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:50'!getList	^Array with: (EToyTextNodeWrapper with: topNode model: self parent: nil)! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 10:36'!inAWindow	| window  |	window _ (SystemWindow labelled: 'HText') model: self.	window 		addMorph: self notInAWindow		frame: (0@0 corner: 1@1).     ^ window! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:43'!notInAWindow	| listMorph |	(listMorph _ EToyHierarchicalTextMorph 		on: self		list: #getList		selected: #getCurrentSelection		changeSelected: #noteNewSelection:		menu: #genericMenu:		keystroke: nil).	listMorph autoDeselect: false.     ^ listMorph! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 00:40'!topNode: aTextNode	topNode _ aTextNode! !!EToyHierarchicalTextGizmo methodsFor: 'object fileIn' stamp: 'RAA 7/30/2000 19:51'!convertcmt0: varDict dcmt0: smartRefStrm	"These variables are automatically stored into the new instance #('currentSelection' 'myBrowser' 'topNode').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('dependents')  If a non-nil value is needed, please assign it."! !!EToyHierarchicalTextGizmo class methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:06'!example"EToyHierarchicalTextGizmo example"	| window |	window _ EToyHierarchicalTextGizmo new 		topNode: EToyTextNode newNode;		notInAWindow.	window 		color: Color white;		useRoundedCorners;		openInWorld! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:11'!handleNewChatFrom: dataStream sentBy: senderName ipAddress: ipAddressString	^ EToyChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: (self newObjectFromStream: dataStream).	! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:59'!handleNewFridgeMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject |	newObject _ self newObjectFromStream: dataStream.	newObject		setProperty: #fridgeSender toValue: senderName;		setProperty: #fridgeIPAddress toValue: ipAddressString;		setProperty: #fridgeDate toValue: Time dateAndTimeNow.	WorldState addDeferredUIMessage: [EToyFridgeMorph newItem: newObject] fixTemps.	! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:00'!handleNewMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject thumbForm targetWorld |	newObject _ self newObjectFromStream: dataStream.	SampledSound playSoundNamed: 'chirp'.	targetWorld _ self currentWorld.	(EToyMorphsWelcomeMorph morphsWelcomeInWorld: targetWorld) ifTrue: [		newObject position: (			newObject 				valueOfProperty: #positionInOriginatingWorld 				ifAbsent: [(targetWorld randomBoundsFor: newObject) topLeft]		).		WorldState addDeferredUIMessage: [			newObject openInWorld: targetWorld.		] fixTemps.		^self	].	thumbForm _ newObject imageForm scaledToSize: 50@50.	EToyListenerMorph addToGlobalIncomingQueue: {		thumbForm. newObject. senderName. ipAddressString	}.	WorldState addDeferredUIMessage: [		EToyListenerMorph ensureListenerInCurrentWorld	] fixTemps.! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:22'!handleNewSeeDesktopFrom: dataStream sentBy: senderName ipAddress: ipAddressString	"more later"	^ EToyChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: ipAddressString,' would like to see your desktop'.	! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:15'!handleNewStatusReplyFrom: dataStream sentBy: senderName ipAddress: ipAddressString	(EToyGateKeeperMorph entryForIPAddress: ipAddressString) statusReplyReceived: (		self newObjectFromStream: dataStream	)! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:18'!handleNewStatusRequestFrom: dataStream sentBy: senderName ipAddress: ipAddressString	"more later"	^ EToyChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: ipAddressString,' would like to know if you are available'.	! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:15'!incomingMessgage: dataStream fromIPAddress: ipAddress	| nullChar messageType senderName  sel |	nullChar _ 0 asCharacter.	messageType _ dataStream upTo: nullChar.	senderName _ dataStream upTo: nullChar.	(EToyGateKeeperMorph acceptRequest: messageType from: senderName at: ipAddress) ifFalse: [		^self	].	sel _ (self methodForMessageType: messageType) ifNil: [^self].	^self perform: sel withArguments: {dataStream. senderName. ipAddress}! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:21'!methodForMessageType: messageType	messageType = 'morph' ifTrue: [		^#handleNewMorphFrom:sentBy:ipAddress:	].	messageType = 'fridge' ifTrue: [		^#handleNewFridgeMorphFrom:sentBy:ipAddress:	].	messageType = 'chat' ifTrue: [		^#handleNewChatFrom:sentBy:ipAddress:	].	messageType = 'statusrequest' ifTrue: [		^#handleNewStatusRequestFrom:sentBy:ipAddress:	].	messageType = 'statusreply' ifTrue: [		^#handleNewStatusReplyFrom:sentBy:ipAddress:	].	messageType = 'seedesktop' ifTrue: [		^#handleNewSeeDesktopFrom:sentBy:ipAddress:	].	^nil! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:01'!newObjectFromStream: dataStream	| newObject |	[newObject _ SmartRefStream objectFromStreamedRepresentation: dataStream upToEnd.]		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				"self flashIndicator: #working."			].		].	"self resetIndicator: #working."	^newObject! !!FileDirectory methodsFor: 'file directory' stamp: 'RAA 7/28/2000 13:47'!localNameFor: fullName	"Return the local part the given name."	^self class localNameFor: fullName! !!FileList methodsFor: 'file list menu' stamp: 'RAA 7/28/2000 13:49'!fileIntoNewChangeSet	"File in all of the contents of the currently selected file,	if any, into a new change set." 	| fn ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: (fn _ self uncompressedFileName).	((self getSuffix: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].	ChangeSorter newChangesFromStream: ff named: (directory localNameFor: fn)! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:02'!initialDirectoryList	| dir nameToShow |	^ 	((FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self	]),	(		ServerDirectory serverNames collect: [ :n | 			dir _ ServerDirectory serverNamed: n.			nameToShow _ n.			(FileDirectoryWrapper with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	)! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:40'!projectOnlySelectionBlock	^[ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			#('*.pr' '*.pr.gz' '*.project') anySatisfy: [ :each | each match: entry name]		]	] fixTemps! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 19:13'!selectionBlockForSuffixes: anArray	^[ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			anArray anySatisfy: [ :each | each match: entry name]		]	] fixTemps! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/24/2000 18:01'!blueButtonText: aString textColor: textColor inWindow: window	^(window fancyText: aString ofSize: 15 color: textColor)		hResizing: #rigid;		extent: 100@20;		inset: 4;		borderWidth: 0;		useRoundedCorners! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/23/2000 16:36'!blueRamp1	^{		0.0->(Color r: 0.516 g: 0.645 b: 1.0).		1.0->(Color r: 0.742 g: 0.871 b: 1.0)	}! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/23/2000 16:38'!blueRamp2	^{		0.0->(Color r: 0.516 g: 0.645 b: 1.0).		1.0->(TranslucentColor r: 0.645 g: 0.968 b: 1.0 alpha: 0.56078431372549)	}! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/23/2000 16:37'!blueRamp3	^{		0.0->(Color r: 0.742 g: 0.871 b: 1.0).		1.0->(Color r: 0.516 g: 0.645 b: 1.0).	}! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/24/2000 19:08'!endingSpecs	^#(		('Art' ('bmp' 'gif' 'jpg' 'form' 'png')			(('open image in a window' openImageInWindow 'View')			('read image into ImageImports' importImage 'Import')			('open image as background' openAsBackground 'World'))		)		('Morphs' ('morph' 'morphs' 'sp')			(('load as morph' openMorphFromFile 'Morph')			('load as project' openProjectFromFile 'Project'))		)		('Projects' ('extseg' 'project' 'pr') (('load as project' openProjectFromFile 'Load')))		('Books' ('bo') (('load as book' openBookFromFile 'Open')))		('Music' ('mid') (('play midi file' playMidiFile 'Play')))		('Movies' ('movie') (('open as movie' openAsMovie 'Open')))		"('Code' ('st' 'cs')			(('fileIn' fileInSelection)			('file into new change set' fileIntoNewChangeSet)			('browse changes' browseChanges)			('browse code' browseFile)			('remove line feeds' removeLinefeeds)			('broadcast as update' putUpdate))		)"		('Flash' ('swf') (('open as Flash' openAsFlash 'Open')))		('TrueType' ('ttf') (('open true type font' openAsTTF 'Open')))		('3ds' ('3ds') (('Open 3DS file' open3DSFile' Open')))		('Tape' ('tape') (('open for playback' openTapeFromFile 'Open')))		('Wonderland' ('wrl') (('open in Wonderland' openVRMLFile 'Open')))		('HTML' ('htm' 'html') (('open in browser' openInBrowser 'Open')))	)! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/24/2000 19:33'!morphicViewGeneralLoaderInWorld: aWorld"FileList2 morphicViewGeneralLoaderInWorld: self currentWorld"	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b fileTypeInfo fileTypeButtons fileTypeRow text actionRow |	fileTypeInfo _ self endingSpecs.	window _ AlignmentMorphBob1 newColumn.	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	aFileList _ self new directory: FileDirectory default.	aFileList 		fileSelectionBlock: self projectOnlySelectionBlock;		modalView: window.	window		setProperty: #FileList toValue: aFileList;		centering: #center;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	fileTypeButtons _ fileTypeInfo collect: [ :each |		(self blueButtonText: each first textColor: Color gray inWindow: window)			hResizing: #shrinkWrap	].	buttons _ #('OK' 'Cancel') collect: [ :each |		self blueButtonText: each textColor: textColor1 inWindow: window	].	treePane _ aFileList morphicDirectoryTreePane 		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane _ aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window addARow: {window fancyText: 'Find...' ofSize: 21 color: textColor1}.	fileTypeRow _ window addARowCentered: fileTypeButtons.	actionRow _ window addARowCentered: {		buttons first. 		(Morph new extent: 30@5) color: Color transparent. 		buttons second	}.	window		addARow: {			(window inAColumn: {(pane2a _ window inARow: {window inAColumn: {treePane}}) 				useRoundedCorners; inset: 6}) inset: 10.			(window inAColumn: {(pane2b _ window inARow: {window inAColumn: {fileListPane}}) 				useRoundedCorners; inset: 6}) inset: 10.		}.	window fullBounds.	window fillWithRamp: self blueRamp1 oriented: 0.65.	pane2a fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	pane2b fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	fileTypeButtons do: [ :each | 		each 			on: #mouseUp 			send: #value:value: 			to: [ :evt :morph | 				fileTypeRow submorphsDo: [ :sub |					sub color: (sub == each ifTrue: [Color white] ifFalse: [Color transparent]).				].				text _ morph firstSubmorph firstSubmorph.				self update: actionRow in: window toReflect: text contents asString.			] fixTemps	].	buttons first on: #mouseUp send: #okHit to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	self update: actionRow in: window toReflect: fileTypeInfo first first.	fileTypeRow firstSubmorph color: Color white.	^ window openInWorld: aWorld.! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/24/2000 18:02'!morphicViewProjectLoader2InWorld: aWorld reallyLoad: aBoolean	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b |	window _ AlignmentMorphBob1 newColumn.	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	aFileList _ self new directory: FileDirectory default.	aFileList 		optionalButtonSpecs: self specsForProjectLoader;		fileSelectionBlock: self projectOnlySelectionBlock;		modalView: window.	window		setProperty: #FileList toValue: aFileList;		centering: #center;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	buttons _ #('OK' 'Cancel') collect: [ :each |		self blueButtonText: each textColor: textColor1 inWindow: window	].	treePane _ aFileList morphicDirectoryTreePane 		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane _ aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window		addARow: {			window fancyText: 'Load A Project' ofSize: 21 color: textColor1		};		addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second		};		addARow: {			window fancyText: 'Please select a project' ofSize: 21 color: Color blue		};		addARow: {			(window inAColumn: {(pane2a _ window inARow: {window inAColumn: {treePane}}) 				useRoundedCorners; inset: 6}) inset: 10.			(window inAColumn: {(pane2b _ window inARow: {window inAColumn: {fileListPane}}) 				useRoundedCorners; inset: 6}) inset: 10.		}.	window fullBounds.	window fillWithRamp: self blueRamp1 oriented: 0.65.	pane2a fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	pane2b fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	buttons first 		on: #mouseUp 		send: (aBoolean ifTrue: [#okHitForProjectLoader] ifFalse: [#okHit])		to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	^ window openInWorld: aWorld.! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/24/2000 18:03'!morphicViewProjectSaverFor: aProject"(FileList2 morphicViewProjectSaverFor: Project current) openInWorld"	| window aFileList buttons treePane pane2 textColor1 |	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	aFileList _ self new directory: FileDirectory default.	window _ AlignmentMorphBob1 newColumn.	aFileList modalView: window.	window		setProperty: #FileList toValue: aFileList;		centering: #center;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	buttons _ #( ('OK' okHit) ('Cancel' cancelHit) ) collect: [ :each |		(self blueButtonText: each first textColor: textColor1 inWindow: window)			on: #mouseUp send: each second to: aFileList	].	treePane _ aFileList morphicDirectoryTreePane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window		addARowCentered: {			window fancyText: 'Publish This Project' ofSize: 21 color: textColor1		};		addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second		};		addARowCentered: { (window inAColumn: {(ProjectViewMorph on: aProject) lock}) inset: 4};		addARowCentered: {			window fancyText: 'Please select a folder' ofSize: 21 color: Color blue		};		addARow: {			(				window inAColumn: {					(pane2 _ window inARow: {window inAColumn: {treePane}}) 						useRoundedCorners; inset: 6				}			) inset: 10		}.	window fullBounds.	window fillWithRamp: self blueRamp1 oriented: 0.65.	pane2 fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	window setProperty: #morphicLayerNumber toValue: 11.	^ window ! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/24/2000 19:16'!update: actionRow in: window toReflect: fileTypeString	| fileTypeInfo info2 buttons textColor1 fileSuffixes fileActions aFileList |	aFileList _ window valueOfProperty: #FileList.	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	actionRow removeAllMorphs.	fileTypeInfo _ self endingSpecs.	info2 _ fileTypeInfo detect: [ :each | each first = fileTypeString] ifNone: [self halt].	fileSuffixes _ info2 second.	fileActions _ info2 third.	buttons _ fileActions, #(('Cancel this search' cancelHit 'Cancel')) collect: [ :each |		(self blueButtonText: each third textColor: textColor1 inWindow: window)			setBalloonText: each first;			on: #mouseUp send: each second to: aFileList.	].	buttons do: [ :each | actionRow addMorphBack: each].	window fullBounds.	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	aFileList fileSelectionBlock: (		self selectionBlockForSuffixes: (fileSuffixes collect: [ :each | '*.',each])	).	aFileList updateFileList.! !!FileList2 class methodsFor: 'utility' stamp: 'RAA 6/23/2000 16:41'!textRow: aString 	^AlignmentMorph newRow 		centering: #center;		inset: 0;		addMorph: (			AlignmentMorph newColumn			centering: #center;			color: Color transparent;			vResizing: #shrinkWrap;			inset: 0;			addMorph: (				AlignmentMorph newRow				centering: #center;				color: Color transparent;				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				inset: 0;				addMorph: ((StringMorph contents: aString) color: Color blue; lock)			)		)! !!FileList2 class methodsFor: 'morphic ui' stamp: 'RAA 7/21/2000 11:37'!morphicViewProjectLoader	| dir aFileList window fileListTop midLine |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	aFileList optionalButtonSpecs: self specsForProjectLoader.	aFileList fileSelectionBlock: self projectOnlySelectionBlock.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	fileListTop _ 0.08.	midLine _ 0.4.	self addPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ fileListTop}.		{aFileList morphicDirectoryTreePane. 0@fileListTop corner: midLine@1}.		{aFileList morphicFileListPane. midLine @ fileListTop corner: 1@1}.	}.	aFileList postOpen.	^ window ! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 7/31/2000 11:30'!writeForExportWithSources: fName inDirectory: aDirectory	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	"this is the old version which I restored until I solve the gzip problem"	| fileStream temp classes tempFileName zipper |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' at the end of the file name'.].	temp _ endMarker.	endMarker _ nil.	tempFileName _ aDirectory nextNameFor: 'SqProject' extension: 'temp'.	zipper _ [		ProgressNotification signal: '3:uncompressedSaveComplete'.		(aDirectory oldFileNamed: tempFileName) compressFile.	"makes xxx.gz"		aDirectory 			rename: (tempFileName, FileDirectory dot, 'gz')			toBe: fName.		aDirectory			deleteFileNamed: tempFileName			ifAbsent: []	].	fileStream _ aDirectory newFileNamed: tempFileName.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker _ temp.	"append sources"	classes _ arrayOfRoots select: [:cls | 		(cls isKindOf: Behavior) and: [cls theNonMetaClass isSystemDefined]].	classes size = 0 ifTrue: [zipper value. ^ self].	fileStream reopen; setToEnd.	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	classes do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream close.	zipper value.! !!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 10:59'!balloonText	^nil! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 17:25'!addNewChildAfter: anotherOrNil	item addNewChildAfter: anotherOrNil.! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:50'!addSibling	parentWrapper ifNil: [^1 beep].	parentWrapper addNewChildAfter: item.! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 00:56'!asString	^item contents! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 17:08'!contents	^item children collect: [ :each | 		EToyTextNodeWrapper with: each model: model parent: self	].! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:42'!delete	parentWrapper ifNil: [^1 beep].	parentWrapper withoutListWrapper removeChild: item withoutListWrapper.! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 00:43'!hasContents	^true! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:51'!parentWrapper: anotherWrapper	parentWrapper _ anotherWrapper! !!EToyTextNodeWrapper methodsFor: 'object fileIn' stamp: 'RAA 7/30/2000 14:15'!convertim0: varDict imp0: smartRefStrm	"These variables are automatically stored into the new instance #('item' 'model').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('parentWrapper')  If a non-nil value is needed, please assign it."! !!EToyTextNodeWrapper class methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:52'!with: anObject model: aModel parent: anotherWrapper	^self new		setItem: anObject model: aModel;		parentWrapper: anotherWrapper! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:00'!balloonText	^balloonText! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:01'!balloonText: aStringOrNil	balloonText _ aStringOrNil! !!Morph methodsFor: 'halos and balloon help' stamp: 'RAA 7/21/2000 11:10'!boundsForBalloon	"some morphs have bounds that are way too big"	^self boundsInWorld! !!Morph methodsFor: 'visual properties' stamp: 'RAA 7/23/2000 17:49'!fillWithRamp: rampSpecs oriented: aRatio	| fill |	fill _ GradientFillStyle ramp: rampSpecs.	fill origin: self bounds topLeft.	fill direction: (self bounds extent * aRatio) truncated.	fill radial: false.	self fillStyle: fill.! !!Morph methodsFor: 'WiW support' stamp: 'RAA 7/18/2000 11:23'!eToyRejectDropMorph: morphToDrop event: evt	| tm am |	tm _ TextMorph new 		beAllFont: ((TextStyle named: #ComicBold) fontOfSize: 24);		contents: 'GOT IT!!'.	(am _ AlignmentMorph new)		color: Color yellow;		inset: 10;		useRoundedCorners;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		addMorph: tm;		fullBounds;		position: (self bounds center - (am extent // 2));		openInWorld: self world.	(SampledSound soundNames includes: 'yum') ifFalse: [		(FileDirectory default fileExists: '') ifTrue: [			SampledSound addLibrarySoundNamed: 'yum' fromAIFFfileNamed: 'yum.aif'		].	].	(SampledSound soundNames includes: 'yum') ifTrue: [		SampledSound playSoundNamed: 'yum'	].	evt hand rejectDropMorph: morphToDrop event: evt.		"send it back where it came from"	am delete! !!Morph methodsFor: 'WiW support' stamp: 'RAA 7/19/2000 20:44'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^(owner isNil or: [owner isWorldMorph]) ifTrue: [		self valueOfProperty: #morphicLayerNumber ifAbsent: [100]	] ifFalse: [		owner morphicLayerNumber	].	"leave lots of room for special things"! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:42'!addAColumn: aCollectionOfMorphs	| col |	col _ self inAColumn: aCollectionOfMorphs.	self addMorphBack: col.	^col! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:42'!addARow: aCollectionOfMorphs	| row |	row _ self inARow: aCollectionOfMorphs.	self addMorphBack: row.	^row! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:51'!addARowCentered: aCollectionOfMorphs	^(self addARow: aCollectionOfMorphs)		hResizing: #shrinkWrap;		centering: #center! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 17:37'!fancyText: aString ofSize: pointSize color: aColor	| answer tm |	answer _ self inAColumn: {		tm _ TextMorph new 			beAllFont: ((TextStyle default fontOfSize: pointSize) emphasized: 1);			color: aColor;			contents: aString	}.	tm addDropShadow.	tm owner shadowPoint: (5@5) + tm owner bounds center.	tm lock.	^answer! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:41'!inAColumn: aCollectionOfMorphs	| col |	col _ AlignmentMorph newColumn		color: Color transparent;		vResizing: #shrinkWrap;		inset: 1;		centering: #center.	aCollectionOfMorphs do: [ :each | col addMorphBack: each].	^col! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:42'!inARow: aCollectionOfMorphs	| row |	row _ AlignmentMorph newRow		color: Color transparent;		vResizing: #shrinkWrap;		inset: 1;		centering: #center.	aCollectionOfMorphs do: [ :each | row addMorphBack: each].	^row! !!BalloonMorph class methodsFor: 'private' stamp: 'RAA 7/21/2000 11:11'!getBestLocation: vertices for: morph corner: cornerName	"Try four rel locations of the balloon for greatest unclipped area.   12/99 sma"	| rect maxArea verts rectCorner morphPoint mbc a mp dir bestVerts result usableArea |	rect _ vertices first rect: (vertices at: 5).	maxArea _ -1.	verts _ vertices.	usableArea _ morph world viewBox.	1 to: 4 do: [:i |		dir _ #(vertical horizontal) atWrap: i.		verts _ verts collect: [:p | p flipBy: dir centerAt: rect center].		rectCorner _ #(bottomLeft bottomRight topRight topLeft) at: i.		morphPoint _ #(topCenter topCenter bottomCenter bottomCenter) at: i.		a _ ((rect			align: (rect perform: rectCorner)			with: (mbc _ morph boundsForBalloon perform: morphPoint))				intersect: usableArea) area.		(a > maxArea or: [a = rect area and: [rectCorner = cornerName]]) ifTrue:			[maxArea _ a.			bestVerts _ verts.			mp _ mbc]].	result _ bestVerts collect: [:p | p + (mp - bestVerts first)] "Inlined align:with:".	^ result! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 17:30'!addText: aString	| t |	t _ TextMorph new 		beAllFont: (TextStyle default fontOfSize: 26);		contents: aString.	self extent: t extent * 3.	innerArea _ Morph new 		color: Color white; 		extent: self extent - (16@16);		position: self position + (8@8);		lock.	self addMorph: innerArea. 	self addMorph: (t position: self position + t extent; lock).! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 17:35'!initialize	super initialize.	borderColor _ Color blue.	borderWidth _ 8.	self useRoundedCorners.! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 17:30'!step	| goForIt |	actionBlock ifNil: [^self stopStepping].	goForIt _ actionBlock.	actionBlock _ nil.	[		goForIt value.	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: innerArea].		"in case a save/load progress display needs a home"! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:09'!addGateKeeperMorphs	| list currentTime choices age row |	self setProperty: #gateKeeperCounterValue toValue: EToyGateKeeperMorph updateCounter.	choices _ #(		(60 'm' 'in the last minute')		(3600 'h' 'in the last hour')		(86400 'd' 'in the last day')	).	currentTime _ Time totalSeconds.	list _ EToyGateKeeperMorph knownIPAddresses.	list do: [ :each |		age _ each timeBetweenLastAccessAnd: currentTime.		age _ choices			detect: [ :x | age <= x first]			ifNone: [{0. '-'. (age // 86400) printString,'days ago'}].		row _ self addARow:		(EToyGateKeeperMorph messageTypes collect: [ :type |				self toggleButtonFor: each attribute: type]		),		{			(self inAColumn: {				(StringMorph contents: age second) lock.			}) inset: 2; hResizing: #shrinkWrap; setBalloonText: 'Last attempt was ',age third.			(self inAColumn: {				(StringMorph contents: each ipAddress) lock.			}) inset: 2; hResizing: #shrinkWrap.			(self inAColumn: {				(StringMorph contents: each latestUserName) lock.			}) inset: 2.		}.		row			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			"on: #mouseUp send: #mouseUp:in: to: self;"			setBalloonText: each fullInfoString	].! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:05'!flashIndicator: aSymbol	| now |	now _ Time millisecondClockValue.	(LastFlashTime notNil and: [(Time millisecondClockValue - now) abs < 500]) ifTrue: [^self].	LastFlashTime _ now.	self trulyFlashIndicator: aSymbol! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:05'!trulyFlashIndicator: aSymbol	| indicator firstColor |	indicator _ fields at: aSymbol ifAbsent: [^self].	firstColor _ indicator 		valueOfProperty: #firstColor		ifAbsent: [			indicator setProperty: #firstColor toValue: indicator color.			indicator color		].	indicator color: (indicator color = firstColor ifTrue: [Color white] ifFalse: [firstColor]).	self world displayWorldSafely.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:43'!initialize	super initialize.	orientation _ #vertical.	color _ Color paleYellow.	inset _ 0.	borderColor _ Color darkGray.	borderWidth _ 8.	hResizing _ vResizing _ #rigid.	minWidth _ minHeight _ 200.	bounds _ 400@100 extent:  200@150.	self rebuild.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:40'!openIn: aWorld	"open an a chat window"	aWorld ifNil: [^self].	self 		position: 400@100;		extent:  200@150;		openInWorld: aWorld.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:39'!rebuild	| r1 r2 |	r1 _ self addARow: {		self inAColumn: {StringMorph new contents: 'Your message to:'; lock}.		self textEntryFieldNamed: #ipAddress with: ''					help: 'IP address for chat partner'.	}.	recipientForm ifNotNil: [		r1 addMorphBack: recipientForm asMorph lock	].	self		addMorphBack: (			PluggableTextMorph				on: self				text: nil				accept: #acceptTo:forMorph:		).	r2 _ self addARow: {self inAColumn: {StringMorph new contents: 'Replies'; lock}}.	self		addMorphBack: (			receivingPane _ PluggableTextMorph				on: self				text: nil				accept: nil		).	{r1. r2} do: [ :each |		each			vResizing: #spaceFill;			color: Color veryLightGray.	].	heights _ #(18 0.25 18 9999999).! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 16:19'!allForIPAddress: ipString	"for cleaning up Alan's demo""EToySenderMorph allForIPAddress: '1.2.3.4'"	Smalltalk garbageCollect.	(self allInstances select: [ :each | each ipAddress = ipString]) explore! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:48'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ self ~~ EToyCommunicatorMorph! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 16:13'!instanceReport	"for cleaning up Alan's demo""EToySenderMorph instanceReport"	| answer resp |	Smalltalk garbageCollect.	answer _ self allInstances collect: [ :each |		{			each.			[each ipAddress] on: Error do: [ 'no ipAddress'].			each owner 					ifNil: ['* no owner *'] 					ifNotNil: [each owner innocuousName,' ',each owner printString].			each world ifNil: ['-----no project-----'] ifNotNil: [each world project name].		}	].	resp _ (PopUpMenu labels: 'IP Address\Project\Owner' withCRs) startUpWithCaption: 					'Sorted by'.	resp = 1 ifTrue: [		^(answer asSortedCollection: [ :a :b | a second <= b second]) asArray explore	].	resp = 2 ifTrue: [		^(answer asSortedCollection: [ :a :b | a fourth <= b fourth]) asArray explore	].	resp = 3 ifTrue: [		^(answer asSortedCollection: [ :a :b | a third <= b third]) asArray explore	].	answer explore! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 17:09'!otherCleanup">>>	EToySenderMorph allInstances do: [ :each | 		each ipAddress = '11.11.11.11' ifTrue: [each ipAddress: 'whizzbang']	].<<<"	"==================== now change one of the whizzbang's back to the right address====="">>>	EToySenderMorph allInstances do: [ :each | 		each ipAddress = 'whizzbang' ifTrue: [each delete]	].<<<"! !!EToyChatOrBadgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:51'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ self ~~ EToyChatOrBadgeMorph! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/18/2000 10:26'!acceptDroppingMorph: morphToDrop event: evt	| outData |	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [		"don't send these"		^evt hand rejectDropMorph: morphToDrop event: evt	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we will keep a copy"	(morphToDrop isKindOf: EToySenderMorph) ifTrue: [		self class addRecipient: morphToDrop.		^self rebuild	].	self stopFlashing.	outData _ morphToDrop veryDeepCopy eToyStreamedRepresentationNotifying: self.	self resetIndicator: #working.	self class fridgeRecipients do: [ :each |		self transmitStreamedObject: outData to: each ipAddress	].! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:47'!handlesMouseOver: globalEvt	^true! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:51'!handlesMouseOverDragging: globalEvt	^true! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:55'!mouseDown: localEvt	self addMouseActionIndicatorsWidth: 15 color: (Color blue alpha: 0.7).! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:51'!mouseEnter: evt	^self mouseEnterEither: evt! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:51'!mouseEnterDragging: evt	^self mouseEnterEither: evt! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:51'!mouseEnterEither: evt	evt hand hasSubmorphs ifFalse: [		^self addMouseActionIndicatorsWidth: 10 color: (Color blue alpha: 0.3).	].	(evt hand firstSubmorph isKindOf: EToySenderMorph) ifTrue: [		^self addMouseActionIndicatorsWidth: 10 color: (Color magenta alpha: 0.3).	].	self addMouseActionIndicatorsWidth: 10 color: (Color green alpha: 0.3).! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:53'!mouseLeave: evt	^self mouseLeaveEither: evt! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:54'!mouseLeaveDragging: evt	^self mouseLeaveEither: evt! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:53'!mouseLeaveEither: evt	self deleteAnyMouseActionIndicators.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:55'!mouseUp: localEvt	(self containsPoint: localEvt cursorPoint) ifFalse: [^self].	Project enterIfThereOrFind: 'Fridge'! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:16'!trulyFlashIndicator: aSymbol	| state |	state _ (self 		valueOfProperty: #fridgeFlashingState		ifAbsent: [false]) not.	self setProperty: #fridgeFlashingState toValue: state.	self 		addMouseActionIndicatorsWidth: 15 		color: (Color green alpha: (state ifTrue: [0.3] ifFalse: [0.7])). 1 beep.	"self world displayWorldSafely."! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:42'!acceptableTypes	^acceptableTypes! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:11'!dateAndTimeStringFrom: totalSeconds	| dateAndTime |	dateAndTime _ Time dateAndTimeFromSeconds: totalSeconds.	^dateAndTime first printString,' ',dateAndTime second printString! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:51'!fullInfoString	^self latestUserName,		' at ',		ipAddress ,		' attempts: ',		accessAttempts printString,		'/',		attempsDenied printString,		' last: ',		(self lastIncomingMessageTimeString)	 "acceptableTypes" ! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:21'!initialize	self flag: #bob.		"need to decide better initial types"	super initialize.	ipAddress _ '???'.	accessAttempts _ attempsDenied _ 0.	lastRequests _ OrderedCollection new.	acceptableTypes _ Set withAll: EToyGateKeeperMorph messageTypes. ! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:37'!lastIncomingMessageTimeString	lastRequests isEmpty ifTrue: [^'never'].	^self dateAndTimeStringFrom: lastRequests first first! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:56'!lastTimeChecked	^self valueOfProperty: #lastTimeChecked! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:57'!lastTimeChecked: aDateAndTimeInSeconds	self setProperty: #lastTimeChecked toValue: aDateAndTimeInSeconds! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:22'!lastTimeCheckedString	| statusTime |	statusTime _ self valueOfProperty: #lastTimeChecked ifAbsent: [^'none'].	^(self dateAndTimeStringFrom: statusTime)! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:09'!requestAccessOfType: aString	| ok |	accessAttempts _ accessAttempts + 1.	lastRequests addFirst: {Time totalSeconds. aString}.	lastRequests size > 10 ifTrue: [		lastRequests _ lastRequests copyFrom: 1 to: 10.	].	ok _ (acceptableTypes includes: aString) or: [acceptableTypes includes: 'all'].	ok ifFalse: [attempsDenied _ attempsDenied + 1].	^ok! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:10'!statusReplyReceived: anArray	self setProperty: #lastStatusReplyTime toValue: Time totalSeconds.	self setProperty: #lastStatusReply toValue: anArray.! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 14:16'!statusReplyReceivedString	| statusTime |	statusTime _ self valueOfProperty: #lastStatusReplyTime ifAbsent: [^'none'].	^(self dateAndTimeStringFrom: statusTime),' accepts:', (self valueOfProperty: #lastStatusReply) asArray printString! !!EToyGateKeeperEntry class methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:48'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:39'!acceptRequest: requestType from: senderName at: ipAddressString	| entry |	UpdateCounter _ self updateCounter + 1.	entry _ self entryForIPAddress: ipAddressString.	entry latestUserName: senderName.	^entry requestAccessOfType: requestType! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:43'!acceptableTypesFor: ipAddressString	^(self knownIPAddresses at: ipAddressString ifAbsent: [^#()]) acceptableTypes! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:13'!entryForIPAddress: ipAddressString	| known entry |	UpdateCounter _ self updateCounter + 1.	known _ self knownIPAddresses.	entry _ known at: ipAddressString ifAbsentPut: [		entry _ EToyGateKeeperEntry new.		entry ipAddress: ipAddressString.		entry	].	^entry! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:48'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:20'!messageTypes	^#('chat' 'morph' 'fridge' 'statusrequest' 'statusreply' 'seedesktop')! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:36'!initialize	super initialize.	orientation _ #vertical.	color _ Color lightBlue.	inset _ 4.	borderColor _ Color blue.	borderWidth _ 4.	self rebuild.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:48'!mouseDownEvent: event for: aMorph	| menu selection depictedObject |	depictedObject _ aMorph firstSubmorph valueOfProperty: #depictedObject.	menu _ CustomMenu new.	menu 		add: 'Grab' 		action: [			event hand attachMorph: depictedObject veryDeepCopy		];		add: 'Delete' 		action: [			self class removeFromGlobalIncomingQueue: depictedObject.			self rebuild.		].	selection _ menu build startUpCenteredWithCaption: 'Morph from ',					(aMorph submorphs at: 2) firstSubmorph contents.	selection ifNil: [^self].	selection value.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:49'!rebuild	| earMorph |	updateCounter _ UpdateCounter.	self removeAllMorphs.	self addGateKeeperMorphs.	GlobalListener ifNil: [		earMorph _ (self class makeListeningToggle: false) asMorph.		earMorph setBalloonText: 'Click to START listening for messages'.		earMorph on: #mouseUp send: #startListening to: self.	] ifNotNil: [		earMorph _ (self class makeListeningToggle: true) asMorph.		earMorph setBalloonText: 'Click to STOP listening for messages'.		earMorph on: #mouseUp send: #stopListening to: self.	].	self addARow: {self inAColumn: {earMorph}}.	self		addARow: {			self inAColumn: {(StringMorph contents: 'Incoming communications') lock}.			self indicatorFieldNamed: #working color: Color blue help: 'working'.			self indicatorFieldNamed: #communicating color: Color green help: 'receiving'.		}.	"{thumbForm. newObject. senderName. ipAddressString}"	self class globalIncomingQueueCopy do: [ :each |		self			addNewObject: each second 			thumbForm: each first 			sentBy: each third 			ipAddress: each fourth.	].! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:49'!step	| needRebuild |	super step.	needRebuild _ false.	(self valueOfProperty: #gateKeeperCounterValue) = 			EToyGateKeeperMorph updateCounter ifFalse: [needRebuild _ true].	updateCounter = UpdateCounter ifFalse: [		needRebuild _ true.	].	needRebuild ifTrue: [self rebuild].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 12:58'!commResult: anArrayOfAssociations	| m ipAddress aDictionary |	aDictionary _ Dictionary new.	anArrayOfAssociations do: [ :each | aDictionary add: each].		aDictionary at: #commFlash ifPresent: [ :ignore | ^self].	m _ aDictionary at: #message ifAbsent: [^self].	m = 'OK' ifFalse: [^self].	ipAddress _ NetNameResolver stringFromAddress: (aDictionary at: #ipAddress).	EToyIncomingMessage new 		incomingMessgage: (ReadStream on: (aDictionary at: #data)) 		fromIPAddress: ipAddress	! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 16:28'!initialize"EToyListenerMorph initialize"		Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/19/2000 18:59'!makeListeningToggle: withEars	| background c capExtent bgExtent earExtent earDeltaX earDeltaY botCent factor parts |	factor _ 2.	bgExtent _ (50@25) * factor.	capExtent _ (30@30) * factor.	earExtent _ (15@15) * factor.	earDeltaX _ capExtent x // 2.	earDeltaY _ capExtent y // 2.	background _ Form extent: bgExtent depth: 8.	botCent _ background boundingBox bottomCenter.	c _ background getCanvas.	"c fillColor: Color white."	parts _ {		(botCent - (capExtent // 2)) extent: capExtent.	}.	withEars ifTrue: [		parts _ parts , {			(botCent - (earDeltaX @ earDeltaY) - (earExtent // 2)) extent: earExtent.			(botCent - (earDeltaX negated @ earDeltaY) - (earExtent // 2)) extent: earExtent.		} 	].	parts do: [ :each |		c			fillOval: each			color: Color black 			borderWidth: 0 			borderColor: Color black.	].	^background"=====	f2 _ Form extent: 30@15 depth: 8.	background displayInterpolatedOn: f2.	f2 replaceColor: Color white withColor: Color transparent.	^f2====="	! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 16:26'!shutDown: quitting	WasListeningAtShutdown _ GlobalListener notNil.	self stopListening.! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 16:27'!startUp: resuming	WasListeningAtShutdown == true ifTrue: [		self startListening.	].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/18/2000 10:26'!acceptDroppingMorph: morphToDrop event: evt	| myCopy outData |	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [			"don't send these"		^evt hand rejectDropMorph: morphToDrop event: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we don't really want it"	myCopy _ morphToDrop veryDeepCopy.	"gradient fills require doing this second"	myCopy setProperty: #positionInOriginatingWorld toValue: morphToDrop position.	self stopFlashing.	outData _ myCopy eToyStreamedRepresentationNotifying: self.	self resetIndicator: #working.	self transmitStreamedObject: outData.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 14:15'!checkOnAFriend	| gateKeeperEntry caption choices resp |	gateKeeperEntry _ EToyGateKeeperMorph entryForIPAddress: self ipAddress.	caption _ 'Last name: ',gateKeeperEntry latestUserName,'\Last message in: ',gateKeeperEntry lastIncomingMessageTimeString,'\Last status check at: ',gateKeeperEntry lastTimeCheckedString,'\Last status in: ',gateKeeperEntry statusReplyReceivedString.	choices _ 'Get his status now\Send my status now' .	resp _ (PopUpMenu labels: choices withCRs) startUpWithCaption: caption withCRs.	resp = 1 ifTrue: [		gateKeeperEntry lastTimeChecked: Time totalSeconds.		self sendStatusCheck.	].	resp = 2 ifTrue: [		self sendStatusReply.	].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:31'!currentBadgeVersion	"enables on-the-fly updating of older morphs"	^6! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:35'!installModelIn: myWorld	"if we get this far and nothing exists, make it up"	userPicture ifNotNil: [^self].	self		userName: 'Bob Arning' 		userPicture: nil 		userEmail: 'arning@charm.net' 		userIPAddress: '1.2.3.4'! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 16:20'!ipAddress: aString	^(fields at: #ipAddress) contents: aString! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 14:36'!sendStatusCheck	| null |	null _ String with: 0 asCharacter.	EToyPeerToPeer new 		sendSomeData: {			'statusrequest',null. 			Preferences defaultAuthorName,null.		}		to: self ipAddress		for: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/1/2000 14:14'!sendStatusReply	| null |	null _ String with: 0 asCharacter.	EToyPeerToPeer new 		sendSomeData: {			'statusreply',null. 			Preferences defaultAuthorName,null.			((EToyGateKeeperMorph acceptableTypesFor: self ipAddress) 				eToyStreamedRepresentationNotifying: self).		}		to: self ipAddress		for: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/2000 07:43'!startChat: toggleMode	| chat r |	(self valueOfProperty: #embeddedChatHolder) ifNotNil: [		toggleMode ifFalse: [^self].		^self killExistingChat	].	(EToyChatMorph doChatsInternalToBadge and: 				[(self ownerThatIsA: EToyFridgeMorph) isNil]) ifTrue: [		chat _ EToyChatMorph basicNew			recipientForm: userPicture; 			initialize;			setIPAddress: self ipAddress.		chat			vResizing: #spaceFill;			hResizing: #spaceFill;			borderWidth: 2;			insetTheScrollbars.		r _ (self addARow: {chat}) vResizing: #spaceFill.		self setProperty: #embeddedChatHolder toValue: r.		self hResizing: #spaceFill; vResizing: #spaceFill.	] ifFalse: [		chat _ EToyChatMorph 			chatWindowForIP: self ipAddress			name: self userName 			picture: userPicture 			inWorld: self world.		chat owner addMorphFront: chat.	]! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 13:29'!userName: aString userPicture: aFormOrNil userEmail: emailString userIPAddress: ipString	| dropZoneRow |	self setProperty: #currentBadgeVersion toValue: self currentBadgeVersion.	userPicture _ aFormOrNil ifNil: [		(TextStyle default fontOfSize: 26) emphasized: 1; characterFormAt: $?	].	userPicture _ userPicture scaledToSize: 61@53.	self killExistingChat.	self removeAllMorphs.	self useRoundedCorners.	self 		addARow: {			self inAColumn: {(StringMorph contents: aString) lock}		}.	dropZoneRow _ self		addARow: {			self inAColumn: {userPicture asMorph lock}		}.	self establishDropZone: dropZoneRow.	self		addARow: {			self textEntryFieldNamed: #emailAddress with: emailString					help: 'Email address for this person'		};		addARow: {			self textEntryFieldNamed: #ipAddress with: ipString					help: 'IP address for this person'		};		addARow: {			self indicatorFieldNamed: #working color: Color blue help: 'working'.			self indicatorFieldNamed: #communicating color: Color green help: 'sending'.			self buttonNamed: 'C' action: #startChat color: Color paleBlue 								help: 'Open a chat with this person'.			self buttonNamed: 'T' action: #startTelemorphic color: Color paleYellow 								help: 'Start telemorphic with this person'.			self buttonNamed: '!!' action: #tellAFriend color: Color paleGreen 								help: 'Tell this person about the current project'.			self buttonNamed: '?' action: #checkOnAFriend color: Color lightBrown 								help: 'See if this person is available'.		}.	! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'RAA 7/19/2000 20:40'!morphicLayerNumber	^10.6! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 8/2/2000 15:20'!dropMorphsEvent: evt 	"Drop all the morphs this hand is currently holding in response to the 	given event."	"Details: All submorphs of the front-most composite morph under the 	hand are given an opportunity to accept the dropping morph. If none 	of these accepts it, or if there is no morph under the hand, then the 	morph drops into the world."	| newOwner morphToDrop localPt grabbedMorph pos worldUnderCursor |	worldUnderCursor _ self worldUnderCursor.	worldUnderCursor		ifNil: [^ self].	self changed.	self		submorphsReverseDo: [:m | 			"drop in reverse order to maintain back-to-front ordering"			addedFlexAtGrab == true				ifTrue: [pos _ m firstSubmorph position.					grabbedMorph _ m removeFlexShell.					self privateRemoveMorph: grabbedMorph.					grabbedMorph position: pos					"undo offset from removeFlexShell"]				ifFalse: [grabbedMorph _ m].			newOwner _ self dropTargetFor: grabbedMorph event: evt.			newOwner				ifNil: ["Drop not allowed"					self rejectDropMorph: grabbedMorph event: evt.					addedFlexAtGrab == true						ifTrue: [self privateRemoveMorph: m.							addedFlexAtGrab _ false].					^ self].			"Transcript show: newOwner printString; cr."			morphToDrop _ newOwner morphToDropFrom: grabbedMorph.			morphToDrop == grabbedMorph				ifFalse: [submorphs size == 1						ifTrue: [self privateRemoveMorph: m.							m privateOwner: nil.							addedFlexAtGrab _ false]].			"the above says: the thing to drop is not what I was carrying; 			silently vaporize what I was carrying lest it cause trouble 			later; keep the owner/submorph relationship invariant, but 			don't go through the standard delete protocol"			localPt _ newOwner globalPointToLocal: self position.			addedFlexAtGrab == true				ifTrue: [morphToDrop position: (localPt + (morphToDrop position								- (m transform globalPointToLocal: self position))) rounded.					self privateRemoveMorph: m.					addedFlexAtGrab _ false]				ifFalse: [morphToDrop						position: (newOwner globalPointToLocal: morphToDrop position) rounded].			newOwner acceptDroppingMorph: morphToDrop event: evt.			morphToDrop justDroppedInto: newOwner event: evt.			morphToDrop owner = self				ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!IndentingListItemMorph methodsFor: 'initialization' stamp: 'RAA 7/30/2000 19:13'!initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel	container _ hostList.	complexContents _ anObject.	self initWithContents: anObject asString font: nil emphasis: nil.	indentLevel _ 0.	isExpanded _ false. 	nextSibling _ firstChild _ nil.	priorMorph ifNotNil: [		priorMorph nextSibling: self.	].	indentLevel _ newLevel.! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:49'!addChildrenForList: hostList addingTo: morphList withExpandedItems: expandedItems	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode | aNode delete].	].	firstChild _ nil.	complexContents hasContents ifFalse: [^self].	firstChild _ hostList 		addMorphsTo: morphList		from: complexContents contents 		allowSorting: true		withExpandedItems: expandedItems		atLevel: indentLevel + 1.	! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:00'!balloonText	^complexContents balloonText ifNil: [super balloonText]! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:13'!boundsForBalloon	"some morphs have bounds that are way too big"	container ifNil: [^super boundsForBalloon].	^self boundsInWorld intersect: container boundsInWorld! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:15'!indentLevel	^indentLevel! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 18:53'!recomputeAllForList: hostList addingTo: aCollection withExpandedItems: expandedItems	self halt.	"not used"	"self withSiblingsDo: [ :aNode |		aNode 			recomputeForList: hostList 			addingTo: aCollection 			withExpandedItems: expandedItems.	]."! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:05'!recomputeForList: hostList addingTo: aCollection withExpandedItems: expandedItems	self halt.	"no longer used"		"self contents: complexContents asString.	aCollection add: self."	"isExpanded ifTrue: [		self 			addChildrenForList: hostList 			addingTo: aCollection 			withExpandedItems: expandedItems]."! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:17'!toggleExpandedState 	| newChildren toDelete c |	isExpanded _ isExpanded not.	toDelete _ OrderedCollection new.	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode | aNode recursiveAddTo: toDelete].	].	container noteRemovalOfAll: toDelete.	(isExpanded and: [complexContents hasContents]) ifFalse: [		^self changed	].	(c _ complexContents contents) isEmpty ifTrue: [^self changed].	newChildren _ container 		addSubmorphsAfter: self 		fromCollection: c 		allowSorting: true.	firstChild _ newChildren first.! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 22:06'!toggleRectangle	| h |	h _ bounds height.	^(bounds left + (12 * indentLevel)) @ bounds top extent: 12@h! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:10'!desiredHeight	submorphs isEmpty ifTrue: [^self height].	"isExpanded ifFalse: [^self height]."	^complexContents withoutListWrapper height "max: self height"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 12:53'!drawOn: aCanvas	self drawToggleOn: aCanvas in: self toggleRectangle.! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:52'!initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel	super initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel.	self width: hostList width.	complexContents withoutListWrapper firstDisplay ifTrue: [		complexContents withoutListWrapper firstDisplayedOnLevel: indentLevel.		isExpanded _ true.	].	complexContents withoutListWrapper showInOpenedState ifTrue: [		isExpanded _ true.	].	self addMorph: self repositionText.! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 14:47'!isExpanded: aBoolean	| tm |	super isExpanded: aBoolean.	tm _ self repositionText.	isExpanded ifFalse: [		self height: tm height.	].	self addMorph: tm.	"tm clipToOwner: isExpanded not."		"not really working right yet"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:04'!keyStroke: evt	| char |	char _ evt keyCharacter.	evt controlKeyPressed ifTrue: [		char = Character cr ifTrue: [			container model addSibling.			^true	"we did handle it"		].		char = Character tab ifTrue: [			container model addNewChildAfter: 0.			^true	"we did handle it"		].	].	^false	"we did not handle it"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 12:54'!layoutChanged	super layoutChanged.	submorphs isEmpty ifTrue: [^self].	self desiredHeight = self height ifTrue: [^self].	self height: self desiredHeight.	container adjustSubmorphPositions.! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:06'!position: p andWidth: w	| widthChanged |	widthChanged _ self width ~= w.	self position: p.	self width: w.	submorphs isEmpty ifTrue: [^self height].	widthChanged ifTrue: [		self repositionText.	].	self height: self desiredHeight.	^self desiredHeight! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 12:14'!privateBounds: boundsRect	"Private!! Use position: and/or extent: instead."		^super privateBounds: boundsRect! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:19'!repositionText	| sRect tm |	sRect _ self textMorphBounds.	(tm _ complexContents withoutListWrapper)		"clipToOwner: isExpanded not;"		position: sRect origin;		width: sRect width.	isExpanded ifTrue: [		tm extent: sRect width@10.		tm contents: tm contents wrappedTo: sRect width.		tm extent: sRect width@10.	] ifFalse: [		tm contentsAsIs: tm contents.		tm extent: tm extent.		"force bounds recompute"	].	tm lock: isExpanded not."{tm. tm bounds. sRect} explore."	^tm! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 10:21'!takeFocus	container setSelectedMorph: self! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 15:36'!textMorphBounds	^(bounds withRight: self right - 4)		 withLeft: self textMorphLeft.! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 14:45'!textMorphLeft		^self toggleRectangle right + 3! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 12:29'!toggleExpandedState	super toggleExpandedState.	self isExpanded: isExpanded.! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:52'!handlesMouseOverDragging: evt	^true! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 09:52'!mouseEnterDragging: evt	self deleteWithSiblings! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/29/2000 16:55'!armsLengthCommand: aCommand withDescription: aString	| pvm tempProject foolingForm tempCanvas bbox crossHatchColor stride |	"Set things up so that this aCommand is sent to self as a messageafter jumping to the parentProject.  For things that can't be executedwhile in this project, such as saveAs, loadFromServer, storeOnServer.  SeeProjectViewMorph step."	self isMorphic ifTrue: [		world borderWidth: 0.	"get rid of the silly default border"		tempProject _ Project newMorphic.		foolingForm _ world imageForm.		"make them think they never left"		tempCanvas _ foolingForm getCanvas.		bbox _ foolingForm boundingBox.		crossHatchColor _ Color yellow alpha: 0.3.		stride _ 20.		10 to: bbox width by: stride do: [ :x |			tempCanvas fillRectangle: (x@0 extent: 1@bbox height) fillStyle: crossHatchColor.		].		10 to: bbox height by: stride do: [ :y |			tempCanvas fillRectangle: (0@y extent: bbox width@1) fillStyle: crossHatchColor.		].		tempProject world color: (InfiniteForm with: foolingForm).		tempProject projectParameters 			at: #armsLengthCmd 			put: (				DoCommandOnceMorph new					addText: aString;					actionBlock: [						self doArmsLengthCommand: aCommand.					] fixTemps			).		tempProject enter.	] ifFalse: [		parentProject ifNil: [^ self inform: 'The top project can''t do that'].		pvm _ parentProject findProjectView: self.		pvm armsLengthCommand: {self. aCommand}.		self exit.	].! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/31/2000 11:28'!installRemoteFrom: strm named: otherProjectName	| projViewer is proj |	"Find the current ProjectViewMorph, fetch the project, install in ProjectViewMorph without changing size, and jump into new project."	ProgressNotification signal: '2:fileSizeDetermined ',strm size printString.	projViewer _ self findProjectView: otherProjectName.	projViewer ifNil: [		"(SelectionMenu confirm: 'No old thumbnail found. Debug?') ifTrue: [self halt]."		ProjectViewMorph openFromFile: strm.		"Later check rest of servers if fails.  Still have list here"		^self	].	is _ strm asUnZippedStream.	ProgressNotification  signal: '3:unzipped'.	is _ is fileInObjectAndCode.	ProgressNotification  signal: '4:filedIn'.	(is isKindOf: ImageSegment) ifTrue: [		proj _ is arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		proj ifNotNil: [			proj versionFrom: strm.			(projViewer project isKindOf: DiskProxy) ifFalse: [				projViewer project changeSet name: ChangeSet defaultName].			proj changeSet name: otherProjectName.			CurrentProjectRefactoring currentBeParentTo: proj.			(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].			projViewer project: proj.			"stop background drawing NOW"			ProgressNotification  signal: '9999 about to enter project'.				^ ProjectEntryNotification signal: proj		]	].	ProjectViewMorph openFromFile: strm.	"Later check rest of servers if fails.  Still have list here"! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/31/2000 11:28'!installRemoteNamed: remoteFileName from: aServer named: otherProjectName	ProgressNotification signal: '1:foundMostRecent'.	self 		installRemoteFrom: (aServer oldFileNamed: remoteFileName) 		named: otherProjectName.! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/31/2000 11:29'!storeOnServerInnards	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	| servers resp newName local primaryServerDirectory serverVersionPair localDirectory localVersionPair myVersionNumber warning maxNumber |	"NebraskaDebug at: #savingproject add: {'beginning'}."	"Find out what version"	(servers _ self serverList) isEmpty ifTrue: [		(primaryServerDirectory _ self findAFolderToStoreProjectIn) ifNotNil: [			servers _ Array with: primaryServerDirectory.			urlList _ Array with: primaryServerDirectory realUrl, '/'.		].	] ifFalse: [		primaryServerDirectory _ servers first.	].	localDirectory _ self squeakletDirectory.	serverVersionPair _ self class mostRecent: self name onServer: primaryServerDirectory.	localVersionPair _ self class mostRecent: self name onServer: localDirectory.	maxNumber _ myVersionNumber _ self currentVersionNumber.	ProgressNotification signal: '2:versionsDetected'.	"NebraskaDebug at: #savingproject add: {'versions detected'}."	warning _ ''.	myVersionNumber < serverVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) on the server'.		maxNumber _ maxNumber max: serverVersionPair second.	].	myVersionNumber < localVersionPair second ifTrue: [		warning _ warning,'\There are newer version(s) in the local directory'.		maxNumber _ maxNumber max: localVersionPair second.	].	warning isEmpty ifFalse: [		myVersionNumber = 0 ifTrue: [			warning _ warning,'\THIS PROJECT HAS NEVER BEEN SAVED'		].		warning _ 'WARNING', '\Project: ',self name,warning.		resp _ (PopUpMenu labels: 'Store anyway\Cancel' withCRs) startUpWithCaption: 			(warning, '\Please cancel, rename this project, and see what is there.') withCRs.			resp ~= 1 ifTrue: [^ nil]	].	version _ self bumpVersion: maxNumber.	"write locally - now zipped automatically"	newName _ self versionedFileName.	self exportSegmentFileName: newName directory: localDirectory.			"NebraskaDebug at: #savingproject add: {'local save complete'}."	ProgressNotification signal: '4:localSaveComplete'.	"3 is deep in export logic"	primaryServerDirectory ifNotNil: [		local _ localDirectory oldFileNamed: newName.		resp _ primaryServerDirectory putFile: local named: newName retry: false.		local close.		resp == true ifFalse: [			self inform: 'the primary server of this project seems to be down (',								resp printString,')'. 			^ self		].	].	"NebraskaDebug at: #savingproject add: {'remote save complete'}."	ProgressNotification signal: '9999 save complete'.	"Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."	"2 to: servers size do: [:aServer | aServer putFile: local named: newName]."! !!Project class methodsFor: 'utilities' stamp: 'RAA 7/25/2000 10:02'!canWeLoadAProjectNow	Smalltalk verifyMorphicAvailability ifFalse: [^ false].	"starting to see about eliminating the below"	"Smalltalk isMorphic ifFalse: [		self inform: 'Later, allow jumping from MVC to Morphic Projects.'.		^false	]."	^true! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 7/25/2000 10:46'!fromUrl: urlString	| serverFile pair projName proj num triple |	"Load the project, and make a thumbnail to it in the current project.  Replace the old one if necessary.Project fromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/Squeak_Easy.pr.gz'."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	"---no longer seems necessary---		Smalltalk isMorphic ifFalse: [^ self inform: 			'Later, allow jumping from MVC to Morphic Projects.'].	-----"	serverFile _ ServerFile new fullPath: urlString.	projName _ (serverFile fileName unescapePercents findTokens: '|.') first.	(proj _ Project named: projName) ifNotNil: ["it appeared" ^ ProjectEntryNotification signal: proj].	serverFile isTypeHTTP		ifTrue: [num _ (triple _ serverFile fileName findTokens: '|.') size >= 3 				ifTrue: [Base64MimeConverter decodeInteger: triple second unescapePercents]				ifFalse: [0].			pair _ Array with: serverFile fileName with: num]		ifFalse: [pair _ self mostRecent: serverFile localName onServer: serverFile].	"Pair first is name exactly as it is on the server"	pair first ifNil: ["If none, open a blank project"		^self openBlankProjectNamed: projName	].	CurrentProject installRemoteNamed: pair first from: serverFile named: projName.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 19:32'!currentNavigatorVersion	^8		"since these guys get saved, we fix them up if they are older versions"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 19:32'!doFindButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'find a project' action: [self findAProject];		add: 'find any file' action: [self findAnything].	selection _ menu build startUpCenteredWithCaption: 'Find options'.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 19:32'!findAnything	FileList2 morphicViewGeneralLoaderInWorld: self world! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 19:32'!showMenuFor: aSymbol event: evt	aSymbol == #publishProject ifTrue: [		self doPublishButtonMenuEvent: evt.		^true		"we did show the menu"	].	aSymbol == #findAProject ifTrue: [		self doFindButtonMenuEvent: evt.		^true		"we did show the menu"	].	^false! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 10:35'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on 	the display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView world: nil).	ScheduledControllers schedulePassive: topView controller.	aProject		enter: false		revert: false		saveForRevert: false! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 7/26/2000 11:10'!drawOn: aCanvas	| projectName nameForm rectForName |	self ensureImageReady.	super drawOn: aCanvas.	projectName _ self safeProjectName.	nameForm _ (StringMorph contents: projectName) imageForm.	nameForm _ nameForm scaledToSize: (self extent - (4@2) min: nameForm extent).	rectForName _ self bottomLeft + 			(self width - nameForm width // 2 @ (nameForm height + 2) negated)				extent: nameForm extent.	aCanvas		fillRectangle: (rectForName expandBy: 1)		fillStyle: (Color white alpha: 0.6).	aCanvas		paintImage: nameForm		at: rectForName topLeft.	! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 7/26/2000 10:49'!ensureImageReady	project ifNil: [^ self].	project isInMemory ifFalse: [^self].	project class == DiskProxy ifTrue: [^self].	project thumbnail ifNil: [		image fill: image boundingBox rule: Form over 			fillColor: project defaultBackgroundColor.		^self	].	project thumbnail ~~ lastProjectThumbnail ifTrue: ["scale thumbnail to fit my bounds"		(WarpBlt current toForm: image)			sourceForm: project thumbnail;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (project thumbnail boundingBox) innerCorners			toRect: image boundingBox.		lastProjectThumbnail _ project thumbnail.		image borderWidth: 1	].! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 7/26/2000 11:10'!safeProjectName	| projectName |	projectName _ self valueOfProperty: #SafeProjectName ifAbsent: ['???'].	project ifNil: [^ projectName].	project isInMemory ifFalse: [^ projectName].	project class == DiskProxy ifTrue: [^ projectName].	self setProperty: #SafeProjectName toValue: project name.	^project name! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/21/2000 17:06'!acceptDroppingMorph: morphToDrop event: evt	| myCopy smallR |	(project isNil or: [project isInMemory not or: [project class == DiskProxy]]) ifTrue: [		^evt hand rejectDropMorph: morphToDrop event: evt.		"can't handle it right now"	].	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [	"don't send these"		^evt hand rejectDropMorph: morphToDrop event: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we will send a copy"	myCopy _ morphToDrop veryDeepCopy.	"gradient fills require doing this second"	smallR _ (morphToDrop bounds scaleBy: image height / Display height) rounded.	smallR _ smallR squishedWithin: image boundingBox.	image getCanvas		paintImage: (morphToDrop imageForm scaledToSize: smallR extent)		at: smallR topLeft.	myCopy openInWorld: project world! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/21/2000 12:33'!enter	"Enter my project."	self world == self outermostWorldMorph ifFalse: [^1 beep]. "can't do this at the moment"	project class == DiskProxy ifFalse: [		(project world notNil and: [project world isMorph and:				[project world outermostWorldMorph == self outermostWorldMorph]]) ifTrue: [			^1 beep		"project is open in a window already"		].	].	project class == DiskProxy ifTrue: ["When target is not in yet"		self enterWhenNotPresent.	"will bring it in"		project class == DiskProxy ifTrue: [^self inform: 'Project not found']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project enter: false revert: false saveForRevert: false.! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'RAA 7/31/2000 11:30'!openFromFile: preStream fromDirectory: aDirectoryOrNil	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList window proj |	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	morphOrList _ preStream asUnZippedStream.	ProgressNotification  signal: '3:unzipped'.	morphOrList _ morphOrList fileInObjectAndCode.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		(morphOrList arrayOfRoots count: [:mm | mm class == Project]) > 1 ifTrue: [			self error: 'which project is main?']. 	"debug"		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [			proj versionFrom: preStream.			proj lastDirectory: aDirectoryOrNil.			CurrentProjectRefactoring currentBeParentTo: proj.			Smalltalk isMorphic ifTrue: [				ProjectViewOpenNotification signal ifTrue: [					window _ (SystemWindow labelled: proj name) model: proj.					window						addMorph: (self on: proj)						frame: (0@0 corner: 1.0@1.0).					window openInWorld				].			] ifFalse: [				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].			^ ProjectEntryNotification signal: proj		]	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	window _ self newMorphicProjectOn: morphOrList.	ProjectViewOpenNotification signal ifTrue: [window openInWorld].	window model enter! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/28/2000 13:46'!localNameFor: fullName	"Return the local part the given name."	self		splitName: fullName		to: [:dirPath :localName | ^ localName]! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/28/2000 13:46'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. FileName must be of the form: <dirPath><delimiter><localName>, where <dirPath><delimiter> is optional. The <dirPath> part may contain delimiters."	| delimiter i dirName localName |	delimiter _ self pathNameDelimiter.	(i _ fullName findLast: [:c | c = delimiter]) = 0		ifTrue:			[dirName _ String new.			localName _ fullName]		ifFalse:			[dirName _ fullName copyFrom: 1 to: (i - 1 max: 1).			localName _ fullName copyFrom: i + 1 to: fullName size].	^ pathAndNameBlock value: dirName value: localName! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'RAA 7/30/2000 19:46'!list: aCollection	| wereExpanded morphList |	wereExpanded _ self currentlyExpanded.	scroller removeAllMorphs.	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^ self selectedMorph: nil].	morphList _ OrderedCollection new.	self 		addMorphsTo: morphList		from: aCollection 		allowSorting: false		withExpandedItems: wereExpanded		atLevel: 0.	self insertNewMorphs: morphList.	self installEventHandlerOn: morphList! !!SimpleHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:49'!addMorphsTo: morphList from: aCollection allowSorting: sortBoolean withExpandedItems: expandedItems atLevel: newIndent	| priorMorph newCollection firstAddition |	priorMorph _ nil.	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [		(aCollection asSortedCollection: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]) asOrderedCollection	] ifFalse: [		aCollection	].	firstAddition _ nil.	newCollection do: [:item | 		priorMorph _ self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: newIndent.		firstAddition ifNil: [firstAddition _ priorMorph].		morphList add: priorMorph.		((item hasEquivalentIn: expandedItems) or: [priorMorph isExpanded]) ifTrue: [			priorMorph isExpanded: true.			priorMorph 				addChildrenForList: self 				addingTo: morphList				withExpandedItems: expandedItems.		].	].	^firstAddition	! !!SimpleHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:15'!addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean	| priorMorph morphList newCollection |	priorMorph _ nil.	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [		(aCollection asSortedCollection: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]) asOrderedCollection	] ifFalse: [		aCollection	].	morphList _ OrderedCollection new.	newCollection do: [:item | 		priorMorph _ self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: parentMorph indentLevel + 1.		morphList add: priorMorph.	].	scroller addAllMorphs: morphList after: parentMorph.	^morphList	! !!SimpleHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 22:15'!indentingItemClass		^IndentingListItemMorph! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 02:08'!adjustSubmorphPositions	| p h w |	p _ 0@0.	w _ self width.	scroller submorphsDo: [ :each |		h _ each position: p andWidth: w.		p _ p + (0@h)	].	self 		changed;		layoutChanged;		setScrollDeltas.! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 01:50'!extent: aPoint	| wasDifferent |	wasDifferent _ self extent ~= aPoint.	super extent: aPoint.	wasDifferent ifTrue: [self adjustSubmorphPositions].! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 22:20'!indentingItemClass	^IndentingListParagraphMorph! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 15:05'!keyStroke: evt	selectedMorph ifNil: [^self].	selectedMorph keyStroke: evt! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 10:05'!selectedMorph: aMorph	selectedMorph == aMorph ifTrue: [^self].	self unhighlightSelection.	selectedMorph _ aMorph.	self highlightSelection! !!SimplerTextContainer methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 13:09'!bottom	^textMorph owner bottom! !!SimplerTextContainer methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 14:45'!left 	^ textMorph owner textMorphLeft! !!SimplerTextContainer methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 14:46'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| rects |	lineY > textMorph owner bottom ifTrue: [^#()].	rects _ Array with: (self left@lineY extent: textMorph width@lineHeight).	"rects _ rects collect: [:r | r insetBy: OuterMargin@0]."	^ rects! !!SimplerTextContainer methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 13:09'!top	^textMorph owner top! !!TextMorph methodsFor: 'drawing' stamp: 'RAA 7/30/2000 12:59'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 01:12'!addChild: aTextNode	children add: aTextNode.! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:05'!addNewChildAfter: anotherOrNilOrZero	| where newNode |	anotherOrNilOrZero == 0 ifTrue: [		newNode _ EToyTextNode newNode.		children _ {newNode} asOrderedCollection,children.		^newNode	].	where _ children indexOf: anotherOrNilOrZero ifAbsent: [children size].	children add: (newNode _ EToyTextNode newNode) afterIndex: where.	^newNode! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 01:13'!children	^children! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 13:09'!clipToOwner: aBoolean	aBoolean ifFalse: [^self setContainer: nil].	self setContainer: (SimplerTextContainer new for: self minWidth: textStyle lineGrid*2)! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:52'!firstDisplay	^firstDisplay ifNil: [false]! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:33'!firstDisplayedOnLevel: level	firstDisplay _ false.	text addAttribute: (TextFontChange fontNumber: ((5 - level) max: 1)).! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 17:09'!initialize	| newStyle |	super initialize.	firstDisplay _ true.	children _ OrderedCollection new.	(newStyle _ TextStyle named: #Palatino) ifNotNil: [		textStyle _ newStyle copy defaultFontIndex: 2	].! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 15:08'!keyStroke: evt	(owner notNil and: [owner keyStroke: evt]) ifTrue: [^self].	^super keyStroke: evt.! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 10:07'!keyboardFocusChange: aBoolean	super keyboardFocusChange: aBoolean.	aBoolean ifTrue: [owner takeFocus].! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:43'!removeChild: aTextNode	children remove: aTextNode ifAbsent: [].! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:53'!showInOpenedState	| answer |	answer _ self valueOfProperty: #showInOpenedState ifAbsent: [false].	self removeProperty: #showInOpenedState.	^answer! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:55'!withAllChildrenDo: aBlock	aBlock value: self.	children do: [ :each | each withAllChildrenDo: aBlock].! !!EToyTextNode methodsFor: 'object fileIn' stamp: 'RAA 7/30/2000 19:51'!convertbosfcettwpecpsc0: varDict bosfcettwpecpscf0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'textStyle' 'text' 'wrapFlag' 'paragraph' 'editor' 'container' 'predecessor' 'successor' 'children').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('firstDisplay')  If a non-nil value is needed, please assign it."! !!EToyTextNode class methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:11'!newNode	^self new contents: (		Text			string: 'new item'			attribute: (TextFontChange fontNumber: 2)	)! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 17:22'!drawOn: aCanvas	| revealPercentage revealingStyle revealingColor revealingBounds revealToggle x baseColor revealTimes secondsRemaining scanner stringToDraw where fontToUse innerBounds |		innerBounds _ bounds.	opaqueBackgroundColor ifNotNil: [		aCanvas 			frameAndFillRectangle: bounds			fillColor: opaqueBackgroundColor			borderWidth: 8			borderColor: Color blue.		innerBounds _ innerBounds insetBy: 8.	].	revealTimes _ (self valueOfProperty: #revealTimes) ifNil: [^self].	revealPercentage _ (revealTimes first / revealTimes second) asFloat.	revealingStyle _ self revealingStyle.	x _ self valueOfProperty: #progressStageNumber ifAbsent: [1].	baseColor _ Color perform: (#(red blue green magenta cyan yellow) atPin: x).	revealingColor _ baseColor alpha: 0.2.	revealingStyle = 3 ifTrue: [	"wrap and change color"		revealPercentage > 1.0 ifTrue: [			revealingColor _ baseColor alpha: (0.2 + (revealingStyle / 10) min: 0.5).		].		revealPercentage _ revealPercentage fractionPart.	].	revealingStyle = 2 ifTrue: [	"peg at 75 and blink"		revealPercentage > 0.75 ifTrue: [			revealToggle _ self valueOfProperty: #revealToggle ifAbsent: [true].			self setProperty: #revealToggle toValue: revealToggle not.			revealToggle ifTrue: [revealingColor _ baseColor alpha: 0.8.].		].		revealPercentage _ revealPercentage min: 0.75.	].	revealingBounds _ innerBounds withLeft: innerBounds left + (innerBounds width * revealPercentage) truncated.	aCanvas 		fillRectangle: revealingBounds		color: revealingColor.	secondsRemaining _ (revealTimes second - revealTimes first / 1000) rounded.	secondsRemaining > 0 ifTrue: [		fontToUse _ StrikeFont familyName: 'ComicBold' size: 24.		scanner _ DisplayScanner			quickPrintOn: aCanvas form 			box: innerBounds 			font: fontToUse 			color: Color black.		stringToDraw _ secondsRemaining printString.		where _ innerBounds corner - ((scanner stringWidth: stringToDraw) @ scanner lineHeight).		scanner 			drawString: stringToDraw 			at: where.		scanner _ DisplayScanner			quickPrintOn: aCanvas form 			box: innerBounds 			font: fontToUse 			color: Color white.		scanner 			drawString: stringToDraw 			at: where - (1@1).	]. ! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/19/2000 18:52'!morphicLayerNumber	"helpful for insuring some morphs always appear in front of or behind others.	smaller numbers are in front"	^self valueOfProperty: #morphicLayerNumber ifAbsent: [12].	"progress morphs are behind menus and balloons, but in front of most other stuff"! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 7/23/2000 17:27'!doOneCycleNowFor: aWorld	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	self flag: #bob.		"need to consider remote hands in lower worlds"	"process user input events"	LastCycleTime _ Time millisecondClockValue.	self handsDo: [:h |		activeHand _ h.		h processEvents.		activeHand _ nil	].	aWorld runStepMethods.		"there are currently some variations here"	self displayWorldSafely: aWorld.! !!WorldState class methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 17:28'!lastCycleTime	^LastCycleTime! !SimpleHierarchicalListMorph removeSelector: #morphsFromCollection:allowSorting:withExpandedItems:!IndentingListItemMorph removeSelector: #indentLevel:!IndentingListItemMorph removeSelector: #initWithContents:prior:forList:!EToyListenerMorph class removeSelector: #handleNewFridgeMorphFrom:sentBy:ipAddress:!EToyListenerMorph class removeSelector: #handleNewMorphFrom:sentBy:ipAddress:!EToyListenerMorph initialize!EToyListenerMorph class removeSelector: #newObjectFromStream:!EToyListenerMorph class removeSelector: #usingGlobalListener!EToyListenerMorph removeSelector: #handleNewFridgeMorphFrom:sentBy:ipAddress:!EToyListenerMorph removeSelector: #handleNewMorphFrom:sentBy:ipAddress:!EToyListenerMorph removeSelector: #handleResult:!EToyListenerMorph removeSelector: #newObjectFromStream:!EToyListenerMorph removeSelector: #open!EToyCommunicatorMorph removeSelector: #addAColumn:!EToyCommunicatorMorph removeSelector: #addARow:!EToyCommunicatorMorph removeSelector: #inAColumn:!EToyCommunicatorMorph removeSelector: #inARow:!FileList2 class removeSelector: #fancyText:ofSize:color:!FileList2 class removeSelector: #fill:with:oriented:!FileList2 class removeSelector: #inAColumn:!FileList2 class removeSelector: #inARow:!!FileList2 class reorganize!('as yet unclassified' new projectOnlySelectionBlock selectionBlockForSuffixes:)('blue ui' blueButtonText:textColor:inWindow: blueRamp1 blueRamp2 blueRamp3 endingSpecs morphicViewGeneralLoaderInWorld: morphicViewProjectLoader2InWorld: morphicViewProjectLoader2InWorld:reallyLoad: morphicViewProjectSaverFor: update:in:toReflect:)('button specs' specsForFolderSelector specsForImageViewer specsForProjectLoader)('modal dialogs' modalFolderSelector modalFolderSelectorForProject: modalFolderSelectorForProjectLoad)('utility' addPanesTo:from: textRow:)('morphic ui' morphicView morphicViewFolderSelector morphicViewImageViewer morphicViewNoFile morphicViewProjectLoader)!"Postscript:Provide a better name for one of the built-in ServerDirectory servers"((ServerDirectory serverNames includes: 'DaniOnJumbo') and:		[(ServerDirectory serverNames includes: 'SqueakletsOnDani') not]) ifTrue: [	ServerDirectory		addServer: (ServerDirectory serverNamed: 'DaniOnJumbo')		named: 'SqueakletsOnDani'.	ServerDirectory removeServerNamed: 'DaniOnJumbo'.].EToyListenerMorph initialize.!