'From Squeak3.6beta of ''4 July 2003'' [latest update: #5331] on 8 July 2003 at 2:11:28 pm'!"Change Set:		QuitFixDate:			4 January 2003Author:			Torge HusfeldtFixes SystemDictionary>snapshot:andQuit:embedded:so that it complies with it's comment.The change needed was to assure that a quit log is always written to the changes file (when accessable) in contrast to writing logging only on save.This should help greatly in determining wheather an images resumes from a crash or from a regular exit.v2 (Ned Konz):- added new 'QUIT/NOSAVE' stamp in addition to previously existing  'QUIT' (with save) and 'SNAPSHOT' stamps- ensured write in all cases- made changes browser aware of new stamps."!!ChangeList class methodsFor: 'public access' stamp: 'nk 7/8/2003 13:56'!browseRecentLogOn: origChangesFile 	"figure out where the last snapshot or quit was, then browse the recent entries."	| end done block pos chunk changesFile positions prevBlock |	changesFile _ origChangesFile readOnlyCopy.	positions _ SortedCollection new.	end _ changesFile size.	prevBlock _ end.	block _ end - 1024 max: 0.	done _ false.	[done		or: [positions size > 0]]		whileFalse: [changesFile position: block.			"ignore first fragment"			changesFile nextChunk.			[changesFile position < prevBlock]				whileTrue: [pos _ changesFile position.					chunk _ changesFile nextChunk.					((chunk indexOfSubCollection: '----' startingAt: 1) = 1) ifTrue: [						({ '----QUIT'. '----SNAPSHOT' } anySatisfy: [ :str |							chunk beginsWith: str ])								ifTrue: [positions add: pos]]].			block = 0				ifTrue: [done _ true]				ifFalse: [prevBlock _ block.					block _ block - 1024 max: 0]].	changesFile close.	positions isEmpty		ifTrue: [self inform: 'File ' , changesFile name , ' does not appear to be a changes file']		ifFalse: [self browseRecentLogOn: origChangesFile startingFrom: positions last]! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'nk 7/8/2003 14:10'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg _ String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	self processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming _ embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming _ false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming == true ifTrue: [self clearExternalObjects].	self processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self readDocumentFile].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !