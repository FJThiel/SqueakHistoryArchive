'From Squeak 2.0 of May 22, 1998 on 20 June 1998 at 2:52:39 pm'!"Change Set:		SundryFixes6-20-diDate:			20 June 1998Author:			Dan IngallsIn keeping with other browsers, ChangeSorters now support	'method inheritance'	'revert to previous version'	'revert and forget'.revertToPreviousVersion has been fixed to work in Morphic.Form hibernate now requires only half as much temporary storage.The flash of Morphic text panes is now properly transformed (ie, not at 0@0).Low-space interrupts now work in Morphic.MVC projects and links to them can now be created and used in Morphic.Fixed a recent bug in ChangeSorter 'show'Added SystemDictionary printSpaceDifferences for differential results (very useful).Fixed a bug that cause MNU doOneCycle when returning to MVC after morphic error.Fixed a bug that caused a crash if interrupt an expression evaluated in the debugger."!!Bitmap methodsFor: 'filing' stamp: 'di 6/17/1998 12:20'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 7936 or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 7936 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 + (S//7936*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 5 + (self size//7936*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!ControlManager methodsFor: 'scheduling' stamp: 'di 6/20/1998 12:59'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess.				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!Debugger class methodsFor: 'instance creation' stamp: 'di 6/17/1998 14:39'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!Debugger class methodsFor: 'opening' stamp: 'di 5/4/1998 15:43'!openContext: aContext label: aString contents: contentsString	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	ErrorRecursion _ true.	(Debugger context: aContext)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'di 6/17/1998 14:36'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.	^ debugger		openNotifierContents: debugger interruptedContext shortStack		label: aString! !!Form methodsFor: 'fileIn/Out' stamp: 'di 6/17/1998 12:38'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: ByteArray) ifTrue: [^ self  "already compacted"].	compactBits _ ByteArray new: (bits size*4) + 5 + (bits size//7936*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Morph methodsFor: 'other' stamp: 'di 6/17/1998 12:44'!flash	| w |	w _ self world.	w ifNotNil:		[Display flash: (((self transformFrom: w) invertRect: bounds)								translateBy: w viewBox origin)].! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 15:42'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag ifFalse: [		"record link to previous project unless we're returning via that link"		previousProject _ CurrentProject].	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: [Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+200000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				vanishingPoint _ Sensor cursorPoint.				(entering ifTrue: [self] ifFalse: [previousProject]) dependents do:					[:v | (v isKindOf: StandardSystemView)						ifTrue: [vanishingPoint _ v windowBox center]].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0]].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'di 6/20/1998 10:25'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	parentProject enter: false.! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 14:14'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project methodsFor: 'menu messages' stamp: 'di 6/20/1998 10:28'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	world isMorph		ifTrue: [world _ World.				self dependents do:					[:d | (d isKindOf: SystemWindow)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]]]		ifFalse: [world _ ScheduledControllers.				ScheduledControllers unCacheWindows.				self dependents do:					[:d | (d isKindOf: StandardSystemView)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]]].	transcript _ Transcript.	displayDepth _ Display depth.	activeProcess _ nil! !!Project methodsFor: 'release' stamp: 'di 6/17/1998 14:25'!okToChange	| ok hasSubProjects |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	^ true! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:14'!activeProcess	^ activeProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:20'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ Project current activeProcess.	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project methodsFor: 'active process' stamp: 'di 6/17/1998 13:08'!maybeForkInterrupt	Smalltalk isMorphic		ifTrue: [self cmdDotEnabled ifTrue:					[[self interruptName: 'User Interrupt'] fork]]		ifFalse: [ScheduledControllers cmdDotEnabled ifTrue:					[[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 14:07'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	activeProcess _ aProcess.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:21'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:22'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'class initialization' stamp: 'di 6/20/1998 10:31'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		CurrentProject spawnNewProcessAndTerminateOld: true].	NavList _ OrderedCollection with: CurrentProject.	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'di 6/20/1998 13:14'!activeProcess	^ CurrentProject activeProcess! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:58'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 11:44'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self revertToPreviousVersion.	self removeFromCurrentChanges.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:57'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self changed: #contents! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/17/1998 17:57'!chooseCngSet	"Put up a list of them"	| index |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	index _ (PopUpMenu labels: 		(AllChangeSets reversed collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (AllChangeSets at: (AllChangeSets size - index + 1))].! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:54'!messageMenu: aMenu shifted: shifted	"Could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	parent ifNotNil: [		^ aMenu labels: 'copy method to other sidedelete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(1 3 6 10 )		selections: #(copyMethodToOtherforget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]	ifNil: [^ aMenu labels: 'delete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 5 9 )		selections: #( forget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:49'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:44'!shiftedMessageMenu: aMenu	^ aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionrevert and forgetmore...' 	lines: #(5 7 9)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion revertAndForget		unshiftedYellowButtonActivity)! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 13:04'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, msgString]		ifFalse: [msg _ msgString].	World ifNotNil:		[self buildMorphicNotifierLabelled: label message: msg.		^ Project current spawnNewProcess].	Display fullScreen.	Cursor normal show.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 14:46'!release	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"	super release.! !!Debugger methodsFor: 'private' stamp: 'di 6/20/1998 14:48'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:33'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ Smalltalk printSpaceAnalysis: 0 on: 'STspace.text'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x size*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 12 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalPercent printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:37'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream oldFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream oldFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 6/17/1998 13:16'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	Project current interruptName: 'Space is low'.! !!SystemWindow methodsFor: 'open/close' stamp: 'di 6/17/1998 13:41'!delete	| thisWorld |	model okToChange ifFalse: [^self].	thisWorld _ self world.	model release.	model _ nil.	super delete.	SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'top window' stamp: 'di 6/20/1998 11:37'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	owner firstSubmorph == self ifFalse: [owner addMorphFront: self].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse: [model modelWakeUp].self world displayWorld.  "paint all changes in this window"! !ControlManager removeSelector: #maybeForkInterrupt!Project initialize!Browser removeSelector: #revertToPreviousVersion!Browser removeSelector: #removeFromCurrentChanges!Browser removeSelector: #revertAndForget!ChangeSorter removeSelector: #revertToPreviousVersion!ChangeSorter removeSelector: #revertAndForget!SystemDictionary removeSelector: #printSpaceAnalysis:!