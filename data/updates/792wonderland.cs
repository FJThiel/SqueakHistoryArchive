'From Squeak 2.3 of January 14, 1999 on 5 April 1999 at 10:57:12 am'!"Change Set:		wonderlandDate:			2 April 1999Author:			Jeff PierceThe assembled Wonderland classes to date"!Object subclass: #AbstractAnimation	instanceVariableNames: 'startTime endTime duration state direction loopCount undoable myScheduler myWonderland pausedInterval animatedObject '	classVariableNames: 'Finished Forward Infinity Paused Reverse Running Stopped Waiting '	poolDictionaries: ''	category: 'Wonderland-Time'!Object subclass: #Action	instanceVariableNames: 'actionTask paused affectedObject lifetime stopCondition myScheduler '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!Object subclass: #Alarm	instanceVariableNames: 'alarmTask alarmTime myScheduler '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!AbstractAnimation subclass: #Animation	instanceVariableNames: 'startState endState proportionDone getStartStateFunction getEndStateFunction updateFunction styleFunction '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!Animation subclass: #AbsoluteAnimation	instanceVariableNames: 'lastStartState '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!AbstractAnimation subclass: #CompositeAnimation	instanceVariableNames: 'children childLoopCounts '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!Object subclass: #Hierarchical	instanceVariableNames: 'myParent myChildren '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Objects'!Object subclass: #Interpolateable	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Misc'!Interpolateable class	instanceVariableNames: 'value '!CompositeAnimation subclass: #ParallelAnimation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!Animation subclass: #RelativeAnimation	instanceVariableNames: 'getReverseStateFunction '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!Object subclass: #Scheduler	instanceVariableNames: 'currentTime elapsedTime speed alarmList actionList animationList lastSystemTime isRunning schedulerProcess '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!CompositeAnimation subclass: #SequentialAnimation	instanceVariableNames: 'index '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Time'!Object subclass: #UndoAction	instanceVariableNames: 'wrappedAction '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoAnimation	instanceVariableNames: 'wrappedAnimation '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoByStopping	instanceVariableNames: 'stoppableItem myUndoStack '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoColorChange	instanceVariableNames: 'theActor originalColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoPOVChange	instanceVariableNames: 'theActor originalPOV '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoPositionChange	instanceVariableNames: 'theActor originalPosition '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoRotationChange	instanceVariableNames: 'theActor originalRotation '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoShowHide	instanceVariableNames: 'theActor undoingHide '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoSizeChange	instanceVariableNames: 'theActor originalSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoTextureChange	instanceVariableNames: 'theActor originalTexture '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #UndoVisibilityChange	instanceVariableNames: 'theActor originalVisibility '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Undo'!Object subclass: #Wonderland	instanceVariableNames: 'myScheduler myNamespace sharedMeshDict sharedTextureDict myUndoStack defaultCamera cameraList lightList sceneObject scriptEditor '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Core'!Hierarchical subclass: #WonderlandActor	instanceVariableNames: 'myName myWonderland myMesh myTexture myMaterial myColor composite scaleMatrix hidden firstClass '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Objects'!StringHolder subclass: #WonderlandActorBrowser	instanceVariableNames: 'myWonderland myListMorph actorListIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Morphs'!WonderlandActor subclass: #WonderlandCamera	instanceVariableNames: 'perspective viewMatrix myMorph drawSceneBackground '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Objects'!ImageMorph subclass: #WonderlandCameraControls	instanceVariableNames: 'myCamera myScheduler myUndoStack moveAction '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Morphs'!Morph subclass: #WonderlandCameraMorph	instanceVariableNames: 'myCamera myWonderland myControls '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Morphs'!TabbedPalette subclass: #WonderlandEditor	instanceVariableNames: 'myWonderland myScriptEditor myActorBrowser '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Morphs'!B3DIndexedTriangleMesh subclass: #WonderlandMesh	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Mesh'!Morph subclass: #WonderlandMorph	instanceVariableNames: 'myWonderland myScheduler '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Morphs'!Hierarchical subclass: #WonderlandScene	instanceVariableNames: 'myWonderland myColor '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Objects'!Workspace subclass: #WonderlandScriptEditor	instanceVariableNames: 'myTextEditor '	classVariableNames: ''	poolDictionaries: ''	category: 'Wonderland-Morphs'!Object subclass: #WonderlandStyle	instanceVariableNames: 'instVarName1 instVarName2 '	classVariableNames: 'ClassVarName1 ClassVarName2 '	poolDictionaries: ''	category: 'Wonderland-Misc'!Object subclass: #WonderlandUndoStack	instanceVariableNames: 'theStack stackIsOpen maxStackDepth '	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Undo'!Object subclass: #WonderlandVerifier	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'WonderlandConstants '	category: 'Wonderland-Misc'!!AbstractAnimation commentStamp: '<historical>' prior: 0!This class implements the basic functionality of Animations for Wonderlands.!!AbstractAnimation reorganize!('accessing' getAnimatedObject getLoopCount getState isDone isLooping setLoopCount: setUndoable:)('management' copy epilogue: getDuration loop loop: looped looped: pause prologue: resume start stop stopLooping update:)('reversing' reverseDirection)('private' scaleDuration: setDirection:)!!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 3/9/1999 15:45'!getAnimatedObject	"Return the object that this animation affects"	^ animatedObject.! !!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 2/26/1999 12:41'!getLoopCount	"Returns the animation's current loop count"	^ loopCount.! !!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 2/4/1999 10:22'!getState	"Returns the current state of the animation."	^ state.! !!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 2/3/1999 14:23'!isDone	"Returns true if the animation is running"	^ (state = Stopped).! !!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 2/26/1999 12:01'!isLooping	"Returns true if the animation is looping"	^ ( loopCount > 1) or: [ loopCount = Infinity ].! !!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 2/26/1999 12:42'!setLoopCount: count	"Sets the animation's current loop count"	loopCount _ count.! !!AbstractAnimation methodsFor: 'accessing' stamp: 'jsp 2/26/1999 12:23'!setUndoable: aBoolean	"Sets the animation's undoable property"	undoable _ aBoolean.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 3/3/1999 12:38'!copy	self subclassResponsibility.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 3/3/1999 12:06'!epilogue: currentTime	"This method does any work that needs to be done after an interation of the animation finishes."	(loopCount = Infinity) ifTrue:				[state _ Waiting]	ifFalse:				[					loopCount _ loopCount - 1.					(loopCount > 0) ifTrue: [ state _ Waiting ]									ifFalse: [state _ Stopped.											 loopCount _ 1 ].				].! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 14:47'!getDuration	"This method returns the duration of the animation."	^ duration.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 3/24/1999 15:48'!loop	"This method causes an animation to loop forever."	loopCount _ Infinity.	(state = Stopped) ifTrue: [ state _ Waiting.							  myScheduler addAnimation: self. ].! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 15:10'!loop: numberOfTimes	"This method causes an animation to loop for the specified number of times."	loopCount _ numberOfTimes.	(state = Stopped) ifTrue: [ state _ Waiting.							  myScheduler addAnimation: self. ].! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 3/3/1999 12:37'!looped	"This method creates a copy of an animation and loops it forever."	| anim |	anim _ self copy.	anim setLoopCount: Infinity.	^ anim.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 3/3/1999 12:36'!looped: numberOfTimes	"This method creates a copy of an animation and loops it for the specified number of times."	| anim |	anim _ self copy.	anim setLoopCount: numberOfTimes.	^ anim.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 14:43'!pause	"This method pauses an active Animation."	(state = Running) ifTrue: [ state _ Paused. 							    pausedInterval _ (myScheduler getTime) - startTime.].! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 14:56'!prologue: currentTime	"This method does any work that needs to be done before the animation starts, including possibly adding the current state to the undo stack."	"Undo stack stuff here"	undoable ifTrue: [].	startTime _ currentTime.	endTime _ startTime + duration.	state _ Running.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/26/1999 15:21'!resume	"This method resumes a paused animation"	(state = Paused) ifTrue:		[			state _ Running.			startTime _ (myScheduler getTime) - pausedInterval.			endTime _ startTime + duration.		]	ifFalse: [(state = Stopped) ifTrue:				[					state _ Waiting.					myScheduler addAnimation: self.				].			]! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 15:00'!start	"This method starts an existing animation"	state _ Waiting.	loopCount _ 1.	myScheduler addAnimation: self.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 14:25'!stop	"This method changes the state of an animation to stopped.  If it is currently active, the Scheduler will remove it from the list of active animations."	state _ Stopped.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 14:50'!stopLooping	"This method causes the animation to stop looping; the current interation of the animation completes before the animation stops."	loopCount _ 1.! !!AbstractAnimation methodsFor: 'management' stamp: 'jsp 2/3/1999 14:53'!update: currentTime	"Updates the animation using the current Wonderland time"	(state = Waiting) ifTrue: [self prologue: currentTime].	(state = Running) ifTrue: [].	(state = Finished) ifTrue: [self epilogue: currentTime].! !!AbstractAnimation methodsFor: 'reversing' stamp: 'jsp 2/15/1999 10:28'!reverseDirection	"Changes the direction an animation runs in (forward or in reverse)"	(direction = Forward) ifTrue: [ direction _ Reverse ]						 ifFalse: [ direction _ Forward ].! !!AbstractAnimation methodsFor: 'private' stamp: 'jsp 2/26/1999 14:21'!scaleDuration: scaleAmount	"Scales the animation's duration by the specified amount"	duration _ duration * scaleAmount.! !!AbstractAnimation methodsFor: 'private' stamp: 'jsp 2/26/1999 14:17'!setDirection: aDirection	"Sets the animation's direction variable"	direction _ aDirection.! !!AbstractAnimation class methodsFor: 'class initialization' stamp: 'jsp 3/24/1999 11:01'!initialize	"Initialize the class variables"	Waiting _ 1.	Running _ 2.	Paused _ 3.	Finished _ 4.	Stopped _ 5.	Forward _ 0.	Reverse _ 1.	Infinity _ -1.! !!Action commentStamp: '<historical>' prior: 0!This class implements Actions for Wonderlands. An Action is some task that should be executed every frame either forever, until a specified amount of time has elapsed, or until a specified condition holds true.!!Action reorganize!('accessing' getAffectedObject isDone isPaused pause resume)('management' execute setAffectedObject: setLifetime:andCondition: setScheduler: setTask: stop)!!Action methodsFor: 'accessing' stamp: 'jsp 3/9/1999 16:08'!getAffectedObject	"Returns the object affected by the action"	^ affectedObject.! !!Action methodsFor: 'accessing' stamp: 'jsp 2/1/1999 15:13'!isDone	"Returns true if the Action is done executing either because it's lifetime has expired or because the specified condition is true"	(lifetime > 0) ifTrue: [^ (lifetime < (myScheduler getTime))]				ifFalse: [^ (stopCondition value)].	! !!Action methodsFor: 'accessing' stamp: 'jsp 3/9/1999 16:22'!isPaused	"Returns true if the action is paused"	^ paused.! !!Action methodsFor: 'accessing' stamp: 'jsp 3/9/1999 16:21'!pause	"Pause the action"	paused _ true.! !!Action methodsFor: 'accessing' stamp: 'jsp 3/9/1999 16:21'!resume	"resume the action"	paused _ false.! !!Action methodsFor: 'management' stamp: 'jsp 3/9/1999 16:20'!execute	"Execute the Action's task"	paused ifFalse: [ actionTask value ].! !!Action methodsFor: 'management' stamp: 'jsp 3/9/1999 16:08'!setAffectedObject: anObject	"Sets the object affected by the action"	affectedObject _ anObject.! !!Action methodsFor: 'management' stamp: 'jsp 2/1/1999 11:44'!setLifetime: howlong andCondition: condition	"Sets how long the action should run, or the condition under which it should stop"	lifetime _ howlong.	stopCondition _ condition.! !!Action methodsFor: 'management' stamp: 'jsp 2/1/1999 16:20'!setScheduler: scheduler	"Sets the scheduler the Action is active in"	myScheduler _ scheduler.! !!Action methodsFor: 'management' stamp: 'jsp 3/9/1999 16:20'!setTask: task	"Sets the task the Action should perform each frame"	actionTask _ task.	paused _ false.! !!Action methodsFor: 'management' stamp: 'jsp 3/30/1999 11:50'!stop	"This method removes the Action from myScheduler's list of active actions"	stopCondition _ [ true ].	myScheduler removeAction: self.! !!Action class methodsFor: 'initialize-release' stamp: 'jsp 3/9/1999 16:09'!do: task eachframefor: time toObject: anObject inScheduler: scheduler	"Creates a new Action that performs the specified task each frame for (time) seconds"	| newAction |	newAction _ Action new.	newAction setTask: task.	newAction setLifetime: (time + (scheduler getTime)) andCondition: [false].	newAction setAffectedObject: anObject.	newAction setScheduler: scheduler.	scheduler addAction: newAction.	^ newAction.! !!Action class methodsFor: 'initialize-release' stamp: 'jsp 3/9/1999 16:09'!do: task eachframeuntil: condition toObject: anObject inScheduler: scheduler	"Creates a new Action that performs the specified task each frame until the specified condition holds true"	| newAction |	newAction _ Action new.	newAction setTask: task.	newAction setLifetime: -1 andCondition: condition.	newAction setAffectedObject: anObject.	newAction setScheduler: scheduler.	scheduler addAction: newAction.	^ newAction.! !!Action class methodsFor: 'initialize-release' stamp: 'jsp 3/9/1999 16:10'!do: task toObject: anObject inScheduler: scheduler	"Creates a new Action that executes the specified task each frame"	| newAction |	newAction _ Action new.	newAction setTask: task.	newAction setLifetime: -1 andCondition: [false].	newAction setAffectedObject: anObject.	newAction setScheduler: scheduler.	scheduler addAction: newAction.	^ newAction.! !!Alarm commentStamp: '<historical>' prior: 0!This class implements the alarms for Wonderlands. The user specifies the time the alarm should go off (either in a certain amount of time or at a specific moment) and the task the system should execute when the alarm goes off.!!Alarm methodsFor: 'accessing' stamp: 'jsp 2/1/1999 14:50'!checkTime	"Returns the time the alarm is set to go off at"	^ alarmTime.! !!Alarm methodsFor: 'management' stamp: 'jsp 1/29/1999 14:49'!execute	"Execute the appointed task because it's the appointed hour"	alarmTask value.! !!Alarm methodsFor: 'management' stamp: 'jsp 2/1/1999 12:12'!setScheduler: scheduler	"Set the Scheduler that manages this Alarm"	myScheduler _ scheduler.! !!Alarm methodsFor: 'management' stamp: 'jsp 2/1/1999 10:58'!setTask: task	"Specifies the task the alarm executes when it goes off"	alarmTask _ task.! !!Alarm methodsFor: 'management' stamp: 'jsp 2/1/1999 10:59'!setTime: time	"Specifies the time the alarm goes off"	alarmTime _ time.! !!Alarm methodsFor: 'management' stamp: 'jsp 2/1/1999 16:33'!stop	"This method removes the Alarm from myScheduler's list of active Alarms"	myScheduler removeAlarm: self.! !!Alarm class methodsFor: 'intialize-release' stamp: 'jsp 2/8/1999 16:07'!do: task at: executeTime inScheduler: scheduler	"Creates an alarm that does the specified task at the specified time"	| newAlarm |	newAlarm _ Alarm new.	newAlarm setTime: executeTime.	newAlarm setTask: task.	newAlarm setScheduler: scheduler.	scheduler addAlarm: newAlarm.	^ newAlarm.! !!Alarm class methodsFor: 'intialize-release' stamp: 'jsp 2/8/1999 16:06'!do: task in: waitTime inScheduler: scheduler	"This sets an alarm that will expire in waitTime seconds and execute the specified task"	| newAlarm |	newAlarm _ Alarm new.	newAlarm setTask: task.	newAlarm setTime: waitTime + (scheduler getTime).	newAlarm setScheduler: scheduler.	scheduler addAlarm: newAlarm.	^ newAlarm.! !!Animation commentStamp: '<historical>' prior: 0!This class implements the basic animation for Wonderlands. An animation is essentially a start point, and end point, an interpolation function between those points, and a method of updating the state to reflect the current position between the points.!!Animation methodsFor: 'initialization' stamp: 'jsp 3/9/1999 15:48'!object: anObject update: func getStartState: startFunc getEndState: endFunc style: styleFunc duration: time undoable: canUndo inWonderland: aWonderland	"This method initializes the Animation with all the information that it needs run."	animatedObject _ anObject.	updateFunction _ func.	styleFunction _ styleFunc.	getStartStateFunction _ startFunc.	getEndStateFunction _ endFunc.	duration _ time.	undoable _ canUndo.	myScheduler _ aWonderland getScheduler.	myWonderland _ aWonderland.	loopCount _ 1.	direction _ Forward.	state _ Waiting.	myScheduler addAnimation: self.! !!Animation methodsFor: 'management' stamp: 'jsp 3/3/1999 12:02'!update: currentTime	"Updates the animation using the current Wonderland time"	| newState |	(state = Waiting) ifTrue: [self prologue: currentTime].	(state = Running) ifTrue: [				proportionDone _ styleFunction value: (currentTime - startTime) value: duration.				newState _ startState interpolateTo: endState at: proportionDone.				updateFunction value: newState.				(currentTime >= endTime) ifTrue: [ state _ Finished. ].							  ].	(state = Finished) ifTrue: [self epilogue: currentTime].! !!AbsoluteAnimation methodsFor: 'management' stamp: 'jsp 2/16/1999 16:36'!prologue: currentTime	"Extends the AbstractAnimation prologue by saving the start state of the animation."	undoable ifTrue: [						(myWonderland getUndoStack)								push: (UndoAnimation new: (self makeUndoVersion)).					].	(direction = Forward) ifTrue: [									startState _ getStartStateFunction value.									lastStartState _ startState.									endState _ getEndStateFunction value.								]						ifFalse: [									startState _ getStartStateFunction value.									endState _ lastStartState.								].	super prologue: currentTime.! !!AbsoluteAnimation methodsFor: 'initialization' stamp: 'jsp 3/9/1999 15:49'!object: anObject update: func getStartState: startFunc getEndState: endFunc style: styleFunc duration: time undoable: canUndo inWonderland: aWonderland	"This method initializes the Animation with all the information that it needs to run."	lastStartState _ startFunc value.	super object: anObject update: func getStartState: startFunc getEndState: endFunc style: styleFunc duration: time undoable: canUndo inWonderland: aWonderland.! !!AbsoluteAnimation methodsFor: 'copying' stamp: 'jsp 3/9/1999 15:49'!copy	"Creates a copy of the animation"	| anim |	anim _ AbsoluteAnimation new.	anim object: animatedObject		update: updateFunction		getStartState: getStartStateFunction		getEndState: getEndStateFunction		style: styleFunction		duration: duration		undoable: undoable		inWonderland: myWonderland.	(direction = Forward) ifFalse: [ anim reverseDirection ].	^ anim.! !!AbsoluteAnimation methodsFor: 'copying' stamp: 'jsp 3/9/1999 15:49'!makeUndoVersion	"Creates the undo version of an animation"	| anim |	anim _ AbsoluteAnimation new.	anim object: animatedObject		update: updateFunction		getStartState: getStartStateFunction		getEndState: getEndStateFunction		style: styleFunction		duration: 0.5		undoable: false		inWonderland: myWonderland.	anim stop.	(direction = Forward) ifTrue: [ anim reverseDirection ].	^ anim.! !!CompositeAnimation commentStamp: '<historical>' prior: 0!This class extends the basic Animation class for composite animations (animations built of other animations). It adds an instance variable for the component child animations, and a method for adding them to this collection.!!CompositeAnimation methodsFor: 'initialization' stamp: 'jsp 2/26/1999 13:53'!append: child	"Adds a child animation to the composite animation."	child stop.	children addLast: child.	childLoopCounts addLast: (child getLoopCount).! !!CompositeAnimation methodsFor: 'initialization' stamp: 'jsp 2/26/1999 12:39'!initialize	"Creates an empty OrderedCollection for the child animations."	children _ OrderedCollection new.	childLoopCounts _ OrderedCollection new.! !!CompositeAnimation methodsFor: 'management' stamp: 'jsp 2/26/1999 13:55'!prologue: currentTime	"comment stating purpose of message"	| index |	super prologue: currentTime.	index _ 1.	children do: [:child | child setLoopCount: (childLoopCounts at: index).						 index _ index + 1. ].! !!CompositeAnimation methodsFor: 'private' stamp: 'jsp 2/26/1999 14:35'!getComponents	"Return the component animations of the sequential animation"	^ children.! !!CompositeAnimation methodsFor: 'private' stamp: 'jsp 2/26/1999 14:28'!scaleDuration: scaleAmount	"Scales the animation's duration by the specified amount"	| i |	super scaleDuration: scaleAmount.	i _ 1.	children do: [:child | child scaleDuration: (scaleAmount / (childLoopCounts at: i)).						 i _ i + 1 ].! !!CompositeAnimation methodsFor: 'reversing' stamp: 'jsp 2/26/1999 14:41'!reverseDirection	"Changes the direction an animation runs in (forward or in reverse)"	super reverseDirection.	children do: [:child | child reverseDirection ].! !!CompositeAnimation class methodsFor: 'initialization' stamp: 'jsp 2/11/1999 14:52'!new	"Creates a new Composite animation and makes sure it gets initialized."	^ super new initialize.! !!Hierarchical methodsFor: 'initialization' stamp: 'jsp 2/22/1999 12:08'!initialize	"Initialize this instance"	myChildren _ OrderedCollection new.! !!Hierarchical methodsFor: 'private' stamp: 'jsp 2/23/1999 16:31'!addChild: aChild	"Add an object to this instance's list of children"	((myChildren identityIndexOf: aChild) = 0) ifTrue: [ myChildren addLast: aChild ].! !!Hierarchical methodsFor: 'private' stamp: 'jsp 2/22/1999 12:10'!removeChild: aChild	"Remove an object from this instance's list of children"	myChildren remove: aChild ifAbsent: [].! !!Hierarchical methodsFor: 'parent-child' stamp: 'jsp 4/1/1999 17:53'!appendChildrenNamesTo: prefix	"Return the object's children's names, each appended to the prefix."	| nameList |	nameList _ OrderedCollection new.	myChildren do: [:child | nameList addLast: (prefix , (child getName)).							nameList _ nameList , (child appendChildrenNamesTo: (prefix , '    '))].	^ nameList.! !!Hierarchical methodsFor: 'parent-child' stamp: 'jsp 2/22/1999 13:54'!getChildren	"Return the object's children."	^ (myChildren copy).! !!Hierarchical methodsFor: 'parent-child' stamp: 'jsp 4/1/1999 17:13'!getChildrenNames	"Return the object's children."	^ myChildren collect: [: child | child asString ].! !!Hierarchical methodsFor: 'parent-child' stamp: 'jsp 2/22/1999 12:08'!getParent	"Return the object's parent."	^ myParent.! !!Hierarchical methodsFor: 'parent-child' stamp: 'jsp 2/22/1999 12:10'!setParent: anObject	"Set this instance's parent"	myParent _ anObject.! !!Hierarchical class methodsFor: 'instance creation' stamp: 'jsp 2/22/1999 12:06'!new	"Create and initialize a new instance."	^ super new initialize.! !!Interpolateable methodsFor: 'accessing' stamp: 'jsp 2/9/1999 16:21'!setValue: aValue	"Set the base interpolateable value."	value _ aValue.! !!Interpolateable methodsFor: 'interpolating' stamp: 'jsp 2/9/1999 16:18'!interpolateTo: end at: amountDone	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."	^ value + ((end - value) * amountDone).! !!Interpolateable class methodsFor: 'instance creation' stamp: 'jsp 2/9/1999 16:20'!value: aValue	"Create and initialize a new interpolateable value."	| newInterp |	newInterp _ Interpolateable new.	newInterp setValue: aValue.	^ newInterp.! !!ParallelAnimation commentStamp: '<historical>' prior: 0!This class extends CompositeAnimations for composite animations (an animation built of 2 or more animations) that all run in parallel.!!ParallelAnimation reorganize!('initialization' children:undoable:inWonderland:)('management' prologue: update:)('copying' copy makeUndoVersion)!!ParallelAnimation methodsFor: 'initialization' stamp: 'jsp 2/26/1999 15:36'!children: childCollection undoable: canUndo inWonderland: aWonderland	"This method initializes the Animation with all the information that it needs to run."	| childDuration |	undoable _ canUndo.	myWonderland _ aWonderland.	myScheduler _ aWonderland getScheduler.	loopCount _ 1.	direction _ Forward.	super initialize.	"Add children"	childCollection do: [:child | self append: child. child setUndoable: false ].	"Calculate duration"	duration _ 0.	children do: [:child | childDuration _ ((child getDuration) * (child getLoopCount)).							(childDuration > duration) ifTrue: [ duration _ childDuration. ]. ].	state _ Waiting.	myScheduler addAnimation: self.! !!ParallelAnimation methodsFor: 'management' stamp: 'jsp 2/26/1999 15:28'!prologue: currentTime	"This method performs any actions that need to be done before the parallel animation starts."	super prologue: currentTime.	undoable ifTrue: [						(myWonderland getUndoStack)								push: (UndoAnimation new: (self makeUndoVersion)).					].	children do: [:child | child prologue: currentTime. ].	(direction = Reverse) ifTrue: [ children do: [:child | child pause ] ].! !!ParallelAnimation methodsFor: 'management' stamp: 'jsp 2/26/1999 15:33'!update: currentTime	"This method updates the parallel animation based on the current time, which mainly consists of updating all the component animations."	| index |	(state = Waiting) ifTrue: [self prologue: currentTime].	(state = Running) ifTrue: [			state _ Finished.			"Update every child.  If any one of them is not Stopped set our state back to Running"			index _ 1.			children do: [: child |  ((child getState) = Running) ifTrue: [child update: currentTime].					((child getState) = Finished) ifTrue: [child epilogue: currentTime].					((child getState) = Waiting) ifTrue: [child prologue: currentTime].					((child getState) = Stopped) ifFalse: [state _ Running].					((direction = Reverse) and: [ ((child getState) = Paused) ]) ifTrue: [						((currentTime - startTime) >								(duration - ((child getDuration) * (childLoopCounts at: index))))									ifTrue: [ child resume ] ].					index _ index + 1.						].							  ].	(state = Finished) ifTrue: [self epilogue: currentTime].! !!ParallelAnimation methodsFor: 'copying' stamp: 'jsp 3/3/1999 12:31'!copy	"Creates the undo version of an animation"	| anim copyOfChildren copyOfChild i |	anim _ ParallelAnimation new.	i _ 1.	copyOfChildren _ OrderedCollection new.	children do: [:child | copyOfChild _ child copy.						 copyOfChild setLoopCount: (childLoopCounts at: i).						 copyOfChildren addLast: copyOfChild.						 i _ i + 1 ].	anim children: copyOfChildren		undoable: false		inWonderland: myWonderland.	(direction = Reverse) ifTrue: [ anim setDirection: Reverse ].	^ anim.! !!ParallelAnimation methodsFor: 'copying' stamp: 'jsp 2/26/1999 14:57'!makeUndoVersion	"Creates the undo version of an animation"	| anim copyOfChildren copyOfChild i |	anim _ ParallelAnimation new.	i _ 1.	copyOfChildren _ OrderedCollection new.	children do: [:child | copyOfChild _ child copy.						 copyOfChild setLoopCount: (childLoopCounts at: i).						 copyOfChildren addLast: copyOfChild.						 i _ i + 1 ].	anim children: copyOfChildren		undoable: false		inWonderland: myWonderland.	(direction = Reverse) ifTrue: [ anim setDirection: Reverse ].	anim reverseDirection.	"Undoing a parallel animation takes 1 second"		anim scaleDuration: (1 / duration).	anim stop.	^ anim.! !!RelativeAnimation methodsFor: 'management' stamp: 'jsp 2/16/1999 16:36'!prologue: currentTime	"Extends the AbstractAnimation prologue by saving the start state of the animation."	undoable ifTrue: [						(myWonderland getUndoStack)								push: (UndoAnimation new: (self makeUndoVersion)).					].	(direction = Forward) ifTrue: [									startState _ getStartStateFunction value.									endState _ getEndStateFunction value.								]						ifFalse: [									startState _ getStartStateFunction value.									endState _ getReverseStateFunction value.								].	super prologue: currentTime.! !!RelativeAnimation methodsFor: 'initialization' stamp: 'jsp 3/9/1999 15:50'!object: anObject update: func getStartState: startFunc getEndState: endFunc getReverseState: reverseFunc style: styleFunc duration: time undoable: canUndo inWonderland: aWonderland	"This method initializes the Animation with all the information that it needs to run."	getReverseStateFunction _ reverseFunc.	super object: anObject update: func getStartState: startFunc getEndState: endFunc style: styleFunc duration: time undoable: canUndo inWonderland: aWonderland.! !!RelativeAnimation methodsFor: 'copying' stamp: 'jsp 3/9/1999 15:54'!copy	"Creates a copy of the animation"	| anim |	anim _ RelativeAnimation new.	anim object: animatedObject		update: updateFunction		getStartState: getStartStateFunction		getEndState: getEndStateFunction		getReverseState: getReverseStateFunction 		style: styleFunction		duration: duration		undoable: undoable		inWonderland: myWonderland.	(direction = Forward) ifFalse: [ anim reverseDirection ].	^ anim.! !!RelativeAnimation methodsFor: 'copying' stamp: 'jsp 3/9/1999 15:54'!makeUndoVersion	"Creates the undo version of an animation"	| anim |	anim _ RelativeAnimation new.	anim object: animatedObject		update: updateFunction		getStartState: getStartStateFunction		getEndState: getEndStateFunction		getReverseState: getReverseStateFunction 		style: styleFunction		duration: 0.5		undoable: false		inWonderland: myWonderland.	anim stop.	(direction = Forward) ifTrue: [ anim reverseDirection ].	^ anim.! !!Scheduler commentStamp: '<historical>' prior: 0!The Scheduler manages time for a Wonderland. As part of this responsibility, it manages active alarms, actions, and animations in the Wonderland.!!Scheduler methodsFor: 'initialize-release' stamp: 'jsp 3/23/1999 15:08'!initialize	"Initializes the scheduler: sets Wonderland time to 0, creates empty lists for actions, alarms, and animations"	currentTime _ 0.	speed _ 1.	isRunning _ true.	alarmList _ OrderedCollection new.	actionList _ OrderedCollection new.	animationList _ OrderedCollection new.	lastSystemTime _ Time millisecondClockValue / 1000.0.	! !!Scheduler methodsFor: 'initialize-release' stamp: 'jsp 3/30/1999 15:43'!reset	"Clears the animation, action, and alarm lists and resets the Wonderland time to 0"	currentTime _ 0.	speed _ 1.	isRunning _ true.	lastSystemTime _ (Time millisecondClockValue) / 1000.0.	alarmList _ OrderedCollection new.	actionList _ OrderedCollection new.	animationList _ OrderedCollection new.! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 3/8/1999 11:47'!getElapsedTime	"Returns the time that elapsed in the last Scheduler tick"	^ elapsedTime.! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 3/10/1999 15:35'!getFPS	"Returns the instantaneous frames per second (1 / elapsedTime)"	^ (1.0 / elapsedTime).! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/1/1999 14:18'!getTime	"Returns the current scheduler time"	^ currentTime.! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/1/1999 14:25'!incrementBy: amount	"This method allows animations to be stepped through; the user pauses the Scheduler and then repeatedly issues incrementBy messages with the desired increment"	currentTime _ currentTime + amount.	lastSystemTime _ lastSystemTime + amount.		self processActions.	self processAlarms.	self processAnimations.! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/8/1999 16:38'!pause	"Pause the scheduler. All alarms, actions, and animations pause and time stops passing in the Wonderland, but any active cameras continue to render."	isRunning _ false.! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/1/1999 16:33'!processActions	"This method executes every active action and removes any that done"	actionList do: [:action | action execute.							(action isDone) ifTrue: [self removeAction: action]				].! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/1/1999 16:33'!processAlarms	"This method checks all the alarms and processes any that have gone off"	alarmList do: [:alarm | ((alarm checkTime) < currentTime)			ifTrue:	[ alarm execute.					  self removeAlarm: alarm]				].! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/3/1999 14:23'!processAnimations	"This method processes any active Animations and removes any that are completed."	animationList do: [:anim | anim update: currentTime.							(anim isDone) ifTrue: [self removeAnimation: anim]				].! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/8/1999 16:38'!resume	"If the scheduler was paused, resume it."	isRunning ifFalse: 	[ isRunning _ true.						  lastSystemTime _ (Time millisecondClockValue) / 1000.0.						].! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 2/1/1999 14:34'!setSpeed: newSpeed	"This method sets the speed for the Scheduler. 1 is a 1:1 mapping with clock time, 2 is a 2:1 mapping, etc."	(speed > 0) ifTrue: [speed _ newSpeed] ifFalse: [self error: 'Scheduler speed must be greater than 0.'].! !!Scheduler methodsFor: 'ticking' stamp: 'jsp 3/24/1999 15:25'!tick	"Figure out how much time has elapsed since the last Scheduler tick and update all our actions, alarms, and animations"	isRunning ifTrue: [			elapsedTime _ ((Time millisecondClockValue / 1000.0) - lastSystemTime) * speed.			"if elapsedTime is negative the clock rolled over; deal with it"			(elapsedTime < 0) ifTrue: [lastSystemTime _ 0. elapsedTime _										(Time millisecondClockValue) / 1000.0].			currentTime _ currentTime + elapsedTime.			lastSystemTime _ lastSystemTime + elapsedTime.				self processAlarms.			self processAnimations.			self processActions.						].! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:16'!addAction: anAction	"Add an action to the Scheduler's list of actions"	actionList addLast: anAction.! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:16'!addAlarm: anAlarm	"Add an alarm to the Scheduler's list of alarms"	alarmList addLast: anAlarm.! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:16'!addAnimation: anAnimation	"Add an animation to the Scheduler's list of animations"	animationList addLast: anAnimation.! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:24'!getActions	"Returns a copy of the Scheduler's list of actions"	^ actionList copy.! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:24'!getAlarms	"Returns a copy of the Scheduler's list of alarms"	^ alarmList copy.! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:25'!getAnimations	"Returns a copy of the Scheduler's list of animations"	^ animationList copy.! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:19'!removeAction: anAction	"Remove an action from the Scheduler's list of actions"	actionList remove: anAction ifAbsent: [].! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:18'!removeAlarm: anAlarm	"Remove an alarm from the Scheduler's list of alarms"	alarmList remove: anAlarm ifAbsent: [].! !!Scheduler methodsFor: 'lists maintenance' stamp: 'jsp 1/29/1999 14:20'!removeAnimation: anAnimation	"Remove an animation from the Scheduler's list of animations"	animationList remove: anAnimation ifAbsent: [].! !!Scheduler methodsFor: 'animated object' stamp: 'jsp 3/9/1999 16:07'!getActionsFor: anObject	"Return the animations that list anObject as the object they're affecting"	| aList |	aList _ OrderedCollection new.	actionList do: [:action | ((action getAffectedObject) = anObject)								ifTrue: [ aList addLast: action ] ].	^ aList.! !!Scheduler methodsFor: 'animated object' stamp: 'jsp 3/9/1999 16:05'!getAnimationsFor: anObject	"Return the animations that list anObject as the object they're affecting"	| animList |	animList _ OrderedCollection new.	animationList do: [:anim | ((anim getAnimatedObject) = anObject)								ifTrue: [ animList addLast: anim ] ].	^ animList.! !!Scheduler class methodsFor: 'initialize' stamp: 'jsp 2/3/1999 17:31'!new	"Creates a new Scheduler and make sure it gets initialized."	| newScheduler |	newScheduler _ super new.	newScheduler initialize.	^ newScheduler.! !!SequentialAnimation commentStamp: '<historical>' prior: 0!This class extends CompositeAnimation for composite animations (an animation built of 2 or more animations) that run one after another in sequence.!!SequentialAnimation reorganize!('management' prologue: update:)('initialization' children:undoable:inWonderland:)('reversing' reverseDirection)('copying' copy makeUndoVersion)!!SequentialAnimation methodsFor: 'management' stamp: 'jsp 2/26/1999 12:27'!prologue: currentTime	"Overrides the Animation prologue: message to set the index of the current animation to 1"	super prologue: currentTime.	undoable ifTrue: [						(myWonderland getUndoStack)								push: (UndoAnimation new: (self makeUndoVersion)).					].	index _ 1.	((children size) > 0) ifTrue: [(children at: index) prologue: currentTime.]						ifFalse: [ state _ Finished. ].! !!SequentialAnimation methodsFor: 'management' stamp: 'jsp 2/14/1999 18:00'!update: currentTime	"This method updates the sequential animation based on the current time."	| child notDone |	"Do the prologue to this animation"	(state = Waiting) ifTrue: [self prologue: currentTime].	"Finish right away if there are no component animations"	((children size) = 0) ifTrue: [ state _ Finished].	"Update the current animation segment.  When it finishes, move on to the next non-zero duration animation. If there aren't any more, then the sequential animation is done."	(state = Running) ifTrue: [				child _ children at: index.				child update: currentTime.				notDone _ (child getState) = Stopped.				[ notDone ] whileTrue: [						index _ index + 1.						(index <= (children size)) ifTrue: [ child _ children at: index.														  child prologue: currentTime.														  child update: currentTime.														  notDone _ (child getState) = Stopped.														]												ifFalse: [ state _ Finished.														  notDone _ false.														].											]							  ].	"After the animation finishes run the epilogue."	(state = Finished) ifTrue: [self epilogue: currentTime].! !!SequentialAnimation methodsFor: 'initialization' stamp: 'jsp 2/26/1999 14:27'!children: childCollection undoable: canUndo inWonderland: aWonderland	"This method initializes the Animation with all the information that it needs run."	undoable _ canUndo.	myWonderland _ aWonderland.	myScheduler _ aWonderland getScheduler.	loopCount _ 1.	direction _ Forward.	super initialize.	"Add children"	childCollection do: [:child | self append: child. child setUndoable: false ].	"Calculate duration"	duration _ 0.	children do: [:child | duration _ duration + ((child getDuration) * (child getLoopCount)) ].	state _ Waiting.	myScheduler addAnimation: self.! !!SequentialAnimation methodsFor: 'reversing' stamp: 'jsp 3/12/1999 15:09'!reverseDirection	"Changes the direction an animation runs in (forward or in reverse)"	super reverseDirection.	children _ children reversed.	childLoopCounts _ childLoopCounts reversed.! !!SequentialAnimation methodsFor: 'copying' stamp: 'jsp 3/3/1999 12:30'!copy	"Creates a copy of the animation"	| anim copyOfChildren copyOfChild i |	anim _ SequentialAnimation new.	i _ 1.	copyOfChildren _ OrderedCollection new.	children do: [:child | copyOfChild _ child copy.						 copyOfChild setLoopCount: (childLoopCounts at: i).						 copyOfChildren addLast: copyOfChild.						 i _ i + 1 ].	anim children: copyOfChildren		undoable: false		inWonderland: myWonderland.	(direction = Reverse) ifTrue: [ anim setDirection: Reverse ].	^ anim.! !!SequentialAnimation methodsFor: 'copying' stamp: 'jsp 2/26/1999 14:30'!makeUndoVersion	"Creates the undo version of an animation"	| anim copyOfChildren copyOfChild i |	anim _ SequentialAnimation new.	i _ 1.	copyOfChildren _ OrderedCollection new.	children do: [:child | copyOfChild _ child copy.						 copyOfChild setLoopCount: (childLoopCounts at: i).						 copyOfChildren addLast: copyOfChild.						 i _ i + 1 ].	anim children: copyOfChildren		undoable: false		inWonderland: myWonderland.	(direction = Reverse) ifTrue: [ anim setDirection: Reverse ].	anim reverseDirection.	"Undoing a sequential animation takes 2 seconds"		anim scaleDuration: (2 / duration).	anim stop.	^ anim.! !!UndoAction methodsFor: 'undoing' stamp: 'jsp 2/23/1999 14:21'!undoIt	"Undo the wrapped action"	wrappedAction value.! !!UndoAction methodsFor: 'accessing' stamp: 'jsp 2/23/1999 14:23'!setAction: anAction	"Specify the undo action to wrap."	wrappedAction _ anAction.! !!UndoAction class methodsFor: 'instance creation' stamp: 'jsp 2/23/1999 14:33'!new: anAction	"Create a wrapper for undoing an animation"	| newUndo |	newUndo _ UndoAction new.	newUndo setAction: anAction.	^ newUndo.! !!UndoAnimation reorganize!('accessing' setAnimation:)('undoing' undoIt)!!UndoAnimation methodsFor: 'accessing' stamp: 'jsp 2/16/1999 12:45'!setAnimation: anAnimation	"Set wrapped animation."	wrappedAnimation _ anAnimation.! !!UndoAnimation methodsFor: 'undoing' stamp: 'jsp 2/16/1999 12:45'!undoIt	"Undo by running the wrapped animation."	wrappedAnimation start.! !!UndoAnimation class methodsFor: 'instance creation' stamp: 'jsp 2/16/1999 12:46'!new: anAnimation	"Create a wrapper for undoing an animation"	| newUndo |	newUndo _ UndoAnimation new.	newUndo setAnimation: anAnimation.	^ newUndo.! !!UndoByStopping methodsFor: 'initialization' stamp: 'jsp 3/30/1999 11:40'!initializeWith: anActionorAnimation in: aStack	"Initialize this instance"	stoppableItem _ anActionorAnimation.	myUndoStack _ aStack.! !!UndoByStopping methodsFor: 'undoing' stamp: 'jsp 3/30/1999 11:40'!undoIt	"Undo by stopping the stoppable item"	(stoppableItem isDone) ifTrue: [ myUndoStack popAndUndo ]						   ifFalse: [ stoppableItem stop ].! !!UndoByStopping class methodsFor: 'instance creation' stamp: 'jsp 3/30/1999 11:37'!new: stopable in: aStack	"Create a new instance and initialize it"	^ self new initializeWith: stopable in: aStack.! !!UndoColorChange methodsFor: 'accessing' stamp: 'jsp 3/8/1999 16:31'!setActor: anActor andOriginalColor: aColor	"Set the original color to undo back to"	theActor _ anActor.	originalColor _ aColor.! !!UndoColorChange methodsFor: 'undoing' stamp: 'jsp 3/8/1999 16:31'!undoIt	"Set the object's color back to its original value"	| anim |	anim _ theActor setColor: originalColor duration: 0.5.	anim setUndoable: false.! !!UndoColorChange class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 16:00'!for: anActor from: aColor	"Create a new UndoColorChange instance using aColor as the original color"	^ self new setActor: anActor andOriginalColor: aColor.! !!UndoPOVChange methodsFor: 'accessing' stamp: 'jsp 3/8/1999 14:24'!setActor: anActor andOriginalPOV: pov	"Set the original POV to undo back to"	theActor _ anActor.	originalPOV _ pov.! !!UndoPOVChange methodsFor: 'undoing' stamp: 'jsp 3/8/1999 14:25'!undoIt	"Set the object's POV back to its original value"	| anim |	anim _ theActor setPointOfView: originalPOV duration: 0.5.	anim setUndoable: false.! !!UndoPOVChange class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 16:00'!for: anActor from: pov	"Create a new UndoPOVChange instance using pov as the original point of view"	^ self new setActor: anActor andOriginalPOV: pov.! !!UndoPositionChange methodsFor: 'accessing' stamp: 'jsp 3/8/1999 11:19'!setActor: anActor andOriginalPosition: position	"Set the original position to undo back to"	theActor _ anActor.	originalPosition _ position.! !!UndoPositionChange methodsFor: 'undoing' stamp: 'jsp 3/8/1999 11:21'!undoIt	"Move the object back to its original position"	| anim |	anim _ theActor moveTo: originalPosition duration: 0.5.	anim setUndoable: false.! !!UndoPositionChange class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 16:00'!for: anActor from: position	"Create a new UndoPositionChange instance using position as the original position"	^ self new setActor: anActor andOriginalPosition: position.! !!UndoRotationChange methodsFor: 'accessing' stamp: 'jsp 3/8/1999 11:23'!setActor: anActor andOriginalRotation: rotation	"Set the original rotation to undo back to"	theActor _ anActor.	originalRotation _ rotation.! !!UndoRotationChange methodsFor: 'undoing' stamp: 'jsp 3/8/1999 11:24'!undoIt	"Move the object back to its original position"	| anim |	anim _ theActor turnTo: originalRotation duration: 0.5.	anim setUndoable: false.! !!UndoRotationChange class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 15:59'!for: anActor from: rotation	"Create a new UndoRotationChange instance using rotation as the original rotation"	^ self new setActor: anActor andOriginalRotation: rotation.! !!UndoShowHide methodsFor: 'accessing' stamp: 'jsp 3/19/1999 13:58'!setActorForHide: anActor	"Set this undo event to undo a hide (show the actor)."	theActor _ anActor.	undoingHide _ true.! !!UndoShowHide methodsFor: 'accessing' stamp: 'jsp 3/19/1999 13:58'!setActorForShow: anActor	"Set this undo event to undo a show (hide the actor)."	theActor _ anActor.	undoingHide _ false.! !!UndoShowHide methodsFor: 'undoing' stamp: 'jsp 3/19/1999 13:56'!undoIt	"Undo the show or hide event"	(undoingHide) 	ifTrue: [ theActor setHidden: false ]					ifFalse: [ theActor setHidden: true ].! !!UndoShowHide class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 15:59'!undoHideFor: anActor	"Create an undo event that will show the actor"	^ (self new) setActorForHide: anActor.! !!UndoShowHide class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 15:59'!undoShowFor: anActor	"Create an undo event that will show the actor"	^ (self new) setActorForShow: anActor.! !!UndoSizeChange reorganize!('accessing' setActor:andOriginalSize:)('undoing' undoIt)!!UndoSizeChange methodsFor: 'accessing' stamp: 'jsp 3/8/1999 16:48'!setActor: anActor andOriginalSize: size	"Set the original rotation to undo back to"	theActor _ anActor.	originalSize _ size.! !!UndoSizeChange methodsFor: 'undoing' stamp: 'jsp 3/8/1999 16:49'!undoIt	"Move the object back to its original position"	| anim |	anim _ theActor setSize: originalSize duration: 0.5.	anim setUndoable: false.! !!UndoSizeChange class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 15:59'!for: anActor from: size	"Create a new UndoSizeChange instance using size as the original size"	^ self new setActor: anActor andOriginalSize: size.! !!UndoTextureChange reorganize!('accessing' setActor:andTexture:)('undoing' undoIt)!!UndoTextureChange methodsFor: 'accessing' stamp: 'jsp 3/19/1999 15:57'!setActor: anActor andTexture: aTexture	"Store the old texture and the actor to restore it to"	theActor _ anActor.	originalTexture _ aTexture.! !!UndoTextureChange methodsFor: 'undoing' stamp: 'jsp 3/19/1999 16:14'!undoIt	"Restore the object's old texture"	theActor setTexturePointer: originalTexture.! !!UndoTextureChange class methodsFor: 'instance creation' stamp: 'jsp 3/19/1999 15:59'!for: anActor from: oldTexture	"Wrap an actor and its old texture so that we can undo the texture change"	^ (self new) setActor: anActor andTexture: oldTexture.! !!UndoVisibilityChange methodsFor: 'accessing' stamp: 'jsp 3/8/1999 16:36'!setActor: anActor andOriginalVisibility: aVisibility	"Set the original visibility to undo back to"	theActor _ anActor.	originalVisibility _ aVisibility.! !!UndoVisibilityChange methodsFor: 'undoing' stamp: 'jsp 3/8/1999 16:37'!undoIt	"Set the object's visibility back to its original value"	| anim |	anim _ theActor setVisibility: originalVisibility duration: 0.5.	anim setUndoable: false.! !!UndoVisibilityChange class methodsFor: 'instance creation' stamp: 'jsp 3/8/1999 16:38'!for: anActor from: aVisibility	"Create a new UndoVisibilityChange instance using aVisibility as the original visibility"	^ super new setActor: anActor andOriginalVisibility: aVisibility.! !!Wonderland reorganize!('initialize-reset-release' initialize release reset)('composite animations' doInOrder: doTogether:)('accessing' getDefaultCamera getEditor getLights getNamespace getScene getScheduler getSharedMeshDict getSharedTextureDict getUndoStack)('drawing' renderWonderland:)('undo' undo)('creating' makeActor makeActorFrom: makeCamera makeScriptEditor)('error handling' reportErrorToUser:)!!Wonderland methodsFor: 'initialize-reset-release' stamp: 'jsp 4/1/1999 17:27'!initialize	"This method initializes the Wonderland."	| ground |	"Initialize the shared mesh and texture directories"	sharedMeshDict _ Dictionary new.	sharedTextureDict _ Dictionary new.	"Initialize this Wonderland's shared namespace"	myNamespace _ WonderlandConstants copy.	"Create the Wonderland's scheduler"	myScheduler _ Scheduler new.	myNamespace at: 'scheduler' put: myScheduler.	"Create the undo stack for this Wonderland."	myUndoStack _ WonderlandUndoStack new.	"The scene object is the root of the object tree - all objects in the Wonderland are children (directly or indirectly) of the scene. "	sceneObject _ WonderlandScene newFor: self.	myNamespace at: 'scene' put: sceneObject.	"Create some default objects"	ground _ self makeActor.	ground setMesh: (WonderlandConstants at: 'groundMesh').	ground setTexturePointer: (WonderlandConstants at: 'groundTexture').	ground becomePart.	ground setName: 'ground'.	myNamespace at: 'ground' put: ground.	myUndoStack closeStack.	"Initialize the light list and create a default light"	lightList _ OrderedCollection new.	lightList addLast: (B3DAmbientLight color: Color white).		"Create the default camera"	cameraList _ OrderedCollection new.	defaultCamera _ WonderlandCamera createFor: self.	cameraList addLast: defaultCamera.	myNamespace at: 'camera' put: defaultCamera.	myNamespace at: 'cameraWindow' put: (defaultCamera getMorph).	defaultCamera setName: 'camera'.	myUndoStack openStack.	"Throw this Wonderland into the shared namespace"	myNamespace at: 'w' put: self.	"Create a WonderlandMorph for this Wonderland"	(WonderlandMorph newFor: self) openInWorld.	"Create a script editor for this Wonderland"	self makeScriptEditor.! !!Wonderland methodsFor: 'initialize-reset-release' stamp: 'jsp 4/1/1999 16:22'!release	"This method cleans up the Wonderland."	cameraList do: [:camera | camera release].	scriptEditor delete.! !!Wonderland methodsFor: 'initialize-reset-release' stamp: 'jsp 4/1/1999 16:20'!reset	"Reset this Wonderland"	| ground |	"Reset the scheduler"	myScheduler reset.	"Reset the undo stack"	myUndoStack reset.	"Reset the shared mesh and texture directories"	sharedMeshDict _ Dictionary new.	sharedTextureDict _ Dictionary new.	"Initialize this Wonderland's shared namespace"	myNamespace _ WonderlandConstants copy.	"Rebuild the namespace"	myNamespace at: 'scheduler' put: myScheduler.	myNamespace at: 'w' put: self.	"Create a new scene"	sceneObject _ WonderlandScene newFor: self.	myNamespace at: 'scene' put: sceneObject.	"Recreate the default objects"	ground _ self makeActor.	ground setMesh: (WonderlandConstants at: 'groundMesh').	ground setTexturePointer: (WonderlandConstants at: 'groundTexture').	ground becomePart.	ground setName: 'Ground'.	myNamespace at: 'ground' put: ground.	myUndoStack closeStack.	"Re-initialize the light list and create a default light"	lightList _ OrderedCollection new.	lightList addLast: (B3DAmbientLight color: Color white).	"Wipe out the existing cameras"	cameraList do: [:camera | camera release].		"Recreate the default camera"	cameraList _ OrderedCollection new.	defaultCamera _ WonderlandCamera createFor: self.	cameraList addLast: defaultCamera.	myNamespace at: 'camera' put: defaultCamera.	myNamespace at: 'cameraWindow' put: (defaultCamera getMorph).	defaultCamera setName: 'Camera'.	"Reset the script editor's namespace"	scriptEditor resetNamespace.	myUndoStack openStack.! !!Wonderland methodsFor: 'composite animations' stamp: 'jsp 2/14/1999 18:14'!doInOrder: animations	"Create a new SequentialAnimation instance and pass it the child animations that make it up."	| newSA |	newSA _ SequentialAnimation new.	newSA children: animations undoable: true inWonderland: self.	^ newSA.! !!Wonderland methodsFor: 'composite animations' stamp: 'jsp 2/14/1999 18:14'!doTogether: animations	"Create a new ParallelAnimation instance and pass it the child animations that make it up."	| newPA |	newPA _ ParallelAnimation new.	newPA children: animations undoable: true inWonderland: self.	^ newPA.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 2/5/1999 16:30'!getDefaultCamera	"Returns a handle on the Wonderland's default camera."	^ defaultCamera.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 4/1/1999 17:36'!getEditor	"Return the editor for this wonderland"	^ scriptEditor.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 3/10/1999 16:41'!getLights	"Return the list of lights in the Wonderland"	^ lightList.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 4/1/1999 16:17'!getNamespace	"Return the dictionary that comprises this Wonderland's namespace"	^ myNamespace.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 2/8/1999 17:04'!getScene	"Returns the current scene object."	^ sceneObject.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 2/4/1999 17:18'!getScheduler	"Returns the Wonderland's scheduler."	^ myScheduler.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 3/10/1999 15:54'!getSharedMeshDict	"Return the shared mesh dictionary"	^ sharedMeshDict.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 3/10/1999 15:54'!getSharedTextureDict	"Return the shared texture dictionary"	^ sharedTextureDict.! !!Wonderland methodsFor: 'accessing' stamp: 'jsp 2/15/1999 10:23'!getUndoStack	"Returns the Wonderland's undo stack."	^ myUndoStack.! !!Wonderland methodsFor: 'drawing' stamp: 'jsp 2/8/1999 15:40'!renderWonderland: aRenderer	"Tell all the objects in the Wonderland to render themselves."	sceneObject renderOn: aRenderer.! !!Wonderland methodsFor: 'undo' stamp: 'jsp 2/14/1999 18:43'!undo	"Undo the last action the user performed in the Wonderland.  This pulls a block context off the animation stack and executes it."	myUndoStack popAndUndo.	! !!Wonderland methodsFor: 'creating' stamp: 'jsp 3/12/1999 09:50'!makeActor	"Creates a new actor without any geometry"	^ (WonderlandActor createFor: self).! !!Wonderland methodsFor: 'creating' stamp: 'jsp 4/1/1999 17:52'!makeActorFrom: filename	"Creates a new actor using the specification from the given file"	| aFile words line startSubstr index parent name texture meshFile matrix baseActor newActor |	myUndoStack closeStack.	words _ (filename findTokens: #.).	((words last) = 'mdl') ifTrue: [			aFile _ (CrLfFileStream readOnlyFileNamed: filename) ascii.			newActor _ OrderedCollection new.			[(aFile upTo: $() = ''] whileFalse: [					line _ aFile upTo: (Character cr).					"See if we're creating a new object"					(line beginsWith: 'MakeObject') ifTrue: [						words _ line findTokens: #,.						parent _ (words at: 2) withBlanksTrimmed.						name _ (((words at: 3) withBlanksTrimmed) findBetweenSubStrs: '"') at: 1.						"Now pull in the texture to use"						startSubstr _ name , '.SetTexture'.						[(line _ aFile upTo: (Character cr)) beginsWith: startSubstr] whileFalse: [].						texture _ (line findBetweenSubStrs: '"') at: 2.						texture _ (aFile directory pathName), '\', texture.						"Read the composite matrix to use"						startSubstr _ name , '._SetLocalTransformation'.						[(line _ aFile upTo: (Character cr)) beginsWith: startSubstr] whileFalse: [].						matrix _ B3DMatrix4x4 new.						words _ line findBetweenSubStrs: ',()'.						words removeAllSuchThat: [:str | str = ' '].						index _ words size.						4 to: 1 by: -1 do: [:i | 							4 to: 1 by: -1 do: [:j | matrix at: i at: j put: 										((words at: index) withBlanksTrimmed) asNumber.										   		index _ index - 1. ]. ].						1 to: 4 do: [:i | index _ matrix at: i at: 4.									   matrix at: i at: 4 put: (matrix at: 4 at: i).									   matrix at: 4 at: i put: index. ].						matrix a14: (matrix a14 negated).						"Read the mesh file to use"						startSubstr _ 'LoadGeometry'.						[(line _ aFile upTo: (Character cr)) beginsWith: startSubstr] whileFalse: [].						meshFile _ (line findBetweenSubStrs: '"') at: 2.						meshFile _ (aFile directory pathName), '\', meshFile.						"Now put together the name without periods"						words _ name findTokens: '.'.						name _ ''.						words do: [:part | name _ name , part ].						name at: 1 put: ((name at: 1) asLowercase).						words _ parent findTokens: '.'.						parent _ ''.						words do: [:part | parent _ parent , part ].						parent at: 1 put: ((parent at: 1) asLowercase).						"Now create the object"						(parent = 'none') ifTrue: [								baseActor _ WonderlandActor createFor: self.								baseActor setName: name.								baseActor setTexture: texture.								baseActor loadMeshFromFile: meshFile.								baseActor setComposite: matrix.								myNamespace at: name put: baseActor.												]  "end base actor creation"										ifFalse: [								newActor _ WonderlandActor createFor: self.								newActor setName: name.								newActor reparentTo: (baseActor getChildNamed: parent).								newActor becomePart.								newActor setTexture: texture.								newActor loadMeshFromFile: meshFile.								newActor setComposite: matrix.								myNamespace at: name put: newActor.												]. "end new actor with parent"															]. "end MakeObject parsing"											]. "end file parsing"			aFile close.			myUndoStack openStack.			^ baseActor.								]. " end mdl file parsing"! !!Wonderland methodsFor: 'creating' stamp: 'jsp 4/5/1999 10:53'!makeCamera	"Add a new camera to the Wonderland"	| newCamera |	newCamera _ WonderlandCamera createFor: self.	newCamera setName: 'Camera'.	cameraList addLast: newCamera.	^ newCamera.! !!Wonderland methodsFor: 'creating' stamp: 'jsp 4/1/1999 16:21'!makeScriptEditor	"Create a new script editor for this Wonderland"	scriptEditor _ WonderlandEditor newFor: self.! !!Wonderland methodsFor: 'error handling' stamp: 'jsp 3/24/1999 10:15'!reportErrorToUser: errorString	"When any object in a Wonderland discovers an error it creates an error report and then calls this method to display the error to the user."	| errWin tm |	errWin _ SystemWindowWithButton labelled: 'Ooops'.	errWin openInWorldExtent: 400@100.	errWin color: (Color white).	tm _ TextMorph new.	tm initialize.	errWin addMorph: tm.	tm color: (Color red).	tm contents: errorString wrappedTo: 380.	tm position: ((errWin position) + (10@20)).	tm lock.	errWin height: (tm height) + 30.	errorSound play.! !!Wonderland class methodsFor: 'instance creation' stamp: 'jsp 2/5/1999 16:33'!new	"Create and initialize a new Wonderland."	^ super new initialize.! !!WonderlandActor reorganize!('initialize' initializeFor:)('drawing' drawMesh: renderOn:)('accessing' asString becomeFirstClass becomePart distanceTo: getBoundingBox getBoundingBox: getChildNamed: getFaceCount getWonderland isFirstClass isPart)('parent-child' becomeChildOf:)('playing sound' playSound:)('primitive behaviors' alignWith: alignWith:duration: alignWith:duration:style: move: move:asSeenBy: move:distance: move:distance:asSeenBy: move:distance:duration: move:distance:duration:asSeenBy: move:distance:duration:asSeenBy:style: move:distance:duration:style: move:distance:speed: move:distance:speed:asSeenBy: move:speed: move:speed:asSeenBy: move:speed:asSeenBy:for: move:speed:asSeenBy:until: move:speed:for: move:speed:until: moveTo: moveTo:asSeenBy: moveTo:asSeenBy:eachFrameFor: moveTo:asSeenBy:eachFrameUntil: moveTo:duration: moveTo:duration:asSeenBy: moveTo:duration:asSeenBy:style: moveTo:duration:style: moveTo:eachFrameFor: moveTo:eachFrameUntil: moveTo:speed: moveTo:speed:asSeenBy: nudge: nudge:distance: nudge:distance:duration: nudge:distance:duration:style: place:object: place:object:duration: place:object:duration:style: place:object:eachFrameFor: place:object:eachFrameUntil: pointAt: pointAt:duration: pointAt:duration:style: pointAt:eachFrameFor: pointAt:eachFrameUntil: resize: resize:duration: resize:duration:style: resize:eachFrameFor: resize:eachFrameUntil: resizeLikeRubber:dimension: resizeLikeRubber:dimension:duration: resizeLikeRubber:dimension:duration:style: resizeTopToBottom:leftToRight:frontToBack: resizeTopToBottom:leftToRight:frontToBack:duration: resizeTopToBottom:leftToRight:frontToBack:duration:style: resizeTopToBottom:leftToRight:frontToBack:eachFrameFor: resizeTopToBottom:leftToRight:frontToBack:eachFrameUntil: roll: roll:asSeenBy: roll:speed: roll:speed:asSeenBy: roll:speed:asSeenBy:for: roll:speed:asSeenBy:until: roll:speed:for: roll:speed:until: roll:turns: roll:turns:asSeenBy: roll:turns:duration: roll:turns:duration:asSeenBy: roll:turns:duration:asSeenBy:style: roll:turns:duration:style: roll:turns:speed: roll:turns:speed:asSeenBy: standUp standUpWithDuration: standUpWithDuration:style: turn: turn:asSeenBy: turn:speed: turn:speed:asSeenBy: turn:speed:asSeenBy:for: turn:speed:asSeenBy:until: turn:speed:for: turn:speed:until: turn:turns: turn:turns:asSeenBy: turn:turns:duration: turn:turns:duration:asSeenBy: turn:turns:duration:asSeenBy:style: turn:turns:duration:style: turn:turns:speed: turn:turns:speed:asSeenBy: turnTo: turnTo:AsSeenBy:eachFrameFor: turnTo:AsSeenBy:eachFrameUntil: turnTo:asSeenBy: turnTo:duration: turnTo:duration:asSeenBy: turnTo:duration:asSeenBy:style: turnTo:duration:style: turnTo:eachFrameFor: turnTo:eachFrameUntil: wait wait:)('get property' getAngles getAngles: getColor getName getPointOfView getPointOfView: getPosition getPosition: getPositionInPicturePlane getPositionInPixels getSize getVisibility isHidden)('set property' hide setColor: setColor:duration: setColor:duration:style: setMesh: setName: setPointOfView: setPointOfView:asSeenBy: setPointOfView:asSeenBy:eachFrameFor: setPointOfView:asSeenBy:eachFrameUntil: setPointOfView:duration: setPointOfView:duration:asSeenBy: setPointOfView:duration:asSeenBy:style: setPointOfView:duration:style: setPointOfView:eachFrameFor: setPointOfView:eachFrameUntil: setSize: setSize:duration: setSize:duration:style: setTexture: setVisibility: setVisibility:duration: setVisibility:duration:style: show)('private' getColorVector getComposite getMatrixFromRoot getMatrixToRoot getPointAtMatrix: getPositionVector getRotationVector getSizeVector loadMeshFromFile: makeVectorFromDistance:andDirection: moveRightNow:distance:asSeenBy:undoable: moveRightNow:distance:undoable: moveToRightNow:asSeenBy:undoable: moveToRightNow:undoable: placeRightNow:object:undoable: pointAtRightNow:undoable: reparentTo: resizeRightNow:undoable: rollRightNow:numberOfTurns:asSeenBy:undoable: rollRightNow:numberOfTurns:undoable: rotateByMatrix: scaleByMatrix: scaleByVector: setColorRightNow:undoable: setColorVector: setComposite: setHidden: setPositionVector: setRotationMatrix: setRotationVector: setSizeRightNow:undoable: setTexturePointer: setVisibilityRightNow:undoable: turnRightNow:numberOfTurns:asSeenBy:undoable: turnRightNow:numberOfTurns:undoable: turnToRightNow:asSeenBy:undoable: turnToRightNow:undoable:)('do-ing' do: doEachFrame: doEachFrame:for: doEachFrame:until:)('animated state' getActions getAnimations pause resume stop)!!WonderlandActor methodsFor: 'initialize' stamp: 'jsp 3/12/1999 15:21'!initializeFor: aWonderland	"Initialize the instance variables for the WonderlandActor"	super initialize.	myName _ 'Unnamed'.	myWonderland _ aWonderland.	myParent _ aWonderland getScene.	myParent addChild: self.	"Initialize our material"	myMaterial _ B3DMaterial new.	myMaterial ambientPart: Color white.	myMaterial diffusePart: Color white.	"Set up our default properties"	myColor _ B3DColor4 r: 1.0 g: 1.0 b: 1.0 a: 1.0.	composite _ B3DMatrix4x4 identity.	scaleMatrix _ B3DMatrix4x4 identity.	hidden _ false.	firstClass _ true.! !!WonderlandActor methodsFor: 'drawing' stamp: 'jsp 3/12/1999 14:03'!drawMesh: aRenderer	"Draw the mesh for this actor."	myMaterial ifNotNil: [			aRenderer pushMaterial.			aRenderer material: myMaterial.						].	myTexture ifNotNil: [			aRenderer pushTexture.			aRenderer texture: myTexture.						].	myMesh ifNotNil: [ myMesh renderOn: aRenderer ].	myTexture ifNotNil: [ aRenderer popTexture ].	myMaterial ifNotNil: [ aRenderer popMaterial ].! !!WonderlandActor methodsFor: 'drawing' stamp: 'jsp 3/19/1999 11:51'!renderOn: aRenderer	"Draw the actor."	"Save the old transformation matrix"	aRenderer pushMatrix.	"Modify the matrix using our composite matrix for position and orientation"	aRenderer transformBy: composite.	"Save the new transformation matrix"	aRenderer pushMatrix.	"Modify the matrix using our scale matrix - we do this seperately to avoid scaling space"	aRenderer transformBy: scaleMatrix.	"Draw our mesh if the object is not hidden"	(hidden) ifFalse: [ self drawMesh: aRenderer ].	"Remove the scaling matrix"	aRenderer popMatrix.	"Draw our children"	myChildren do: [:child | child renderOn: aRenderer].	"Restore the old matrix"	aRenderer popMatrix.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/17/1999 10:44'!asString	"Returns the name of the object."	^ myName.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/4/1999 15:35'!becomeFirstClass	"Make the actor a first class object."	firstClass _ true.	(myWonderland getUndoStack) push: (UndoAction new: [ firstClass _ false ]).! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/4/1999 15:35'!becomePart	"Make the actor a part."	firstClass _ false.	(myWonderland getUndoStack) push: (UndoAction new: [ firstClass _ true ]).! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/18/1999 16:43'!distanceTo: aVector	"Returns the distance from the object to the specified point in the parent's coordinate system"	| pos |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can only calculate the distance from ' , myName , ' to an actor or 3D point.'.			^ nil ].	(aVector isKindOf: WonderlandActor)		ifTrue: [ pos _ aVector getPosition: self.				 ^ ((pos at: 1) squared + (pos at: 2) squared + (pos at: 3) squared) sqrt ]		ifFalse: [ pos _ self getPositionVector.				  ((aVector at: 1) = asIs) ifTrue: [ aVector at: 1 put: (pos x) ].				  ((aVector at: 2) = asIs) ifTrue: [ aVector at: 2 put: (pos y) ].				  ((aVector at: 3) = asIs) ifTrue: [ aVector at: 3 put: (pos z) ].				  ^ ((self getPositionVector) - aVector) length ].! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/19/1999 14:33'!getBoundingBox	"Returns the actor's bounding box"	| size x y z nOrigin nCorner childBBox cOrigin cCorner meshBBox mOrigin mCorner |	(myMesh notNil)		ifTrue: [ meshBBox _ myMesh boundingBox.				 size _ self getSizeVector.				 mOrigin _ meshBBox origin.				 mCorner _ meshBBox corner.				 x _ (mOrigin x) * (size x).				 y _ (mOrigin y) * (size y).				 z _ (mOrigin z) * (size z).				 nOrigin _ B3DVector3 x: x y: y z: z.				 x _ (mCorner x) * (size x).				 y _ (mCorner y) * (size y).				 z _ (mCorner z) * (size z).				 nCorner _ B3DVector3 x: x y: y z: z.				]		ifFalse: [ nOrigin _ (B3DVector3 x:0 y:0 z:0).				  nCorner _ (B3DVector3 x:0 y:0 z:0) ].	myChildren do: [:child | 			(child isPart) ifTrue: [									childBBox _ child getBoundingBox: self.				 					cOrigin _ childBBox origin.				 					cCorner _ childBBox corner.									nOrigin _ nOrigin min: cOrigin.									nCorner _ nCorner max: cCorner.								 ].					].	^ Rectangle origin: nOrigin corner: nCorner.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/19/1999 14:41'!getBoundingBox: reference	"Returns the actor's bounding box"	| RUF LDB min max cMatrix tMatrix tVector meshBBox |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the bounding box of ' , myName , ' relative to ', (reference asString) , ' because ', msg.			^ nil ].	meshBBox _ self getBoundingBox.	LDB _ meshBBox origin.	RUF _ meshBBox corner.	cMatrix _ (reference getMatrixToRoot) composeWith: (self getMatrixFromRoot).	tMatrix _ B3DMatrix4x4 identity.	tMatrix _ cMatrix composeWith: (tMatrix translation: RUF).	min _ tMatrix translation.	max _ tMatrix translation.					tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: LDB)) translation.		min _ min min: tVector.	max _ max max: tVector.	"Right up behind"	tVector _ B3DVector3 x: (RUF x) y: (RUF y) z: (LDB z).	tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: tVector)) translation.		min _ min min: tVector.	max _ max max: tVector.		"Left up behind"	tVector _ B3DVector3 x: (LDB x) y: (RUF y) z: (LDB z).	tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: tVector)) translation.		min _ min min: tVector.	max _ max max: tVector.	"Left up front"	tVector _ B3DVector3 x: (LDB x) y: (RUF y) z: (RUF z).	tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: tVector)) translation.		min _ min min: tVector.	max _ max max: tVector.	"Right down behind"	tVector _ B3DVector3 x: (RUF x) y: (LDB y) z: (LDB z).	tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: tVector)) translation.		min _ min min: tVector.	max _ max max: tVector.	"Right down front"	tVector _ B3DVector3 x: (RUF x) y: (LDB y) z: (RUF z).	tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: tVector)) translation.		min _ min min: tVector.	max _ max max: tVector.	"Left down front"	tVector _ B3DVector3 x: (LDB x) y: (LDB y) z: (RUF z).	tMatrix setIdentity.	tVector _ (cMatrix composeWith: (tMatrix translation: tVector)) translation.		min _ min min: tVector.	max _ max max: tVector.	^ Rectangle origin: min corner: max.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/12/1999 15:48'!getChildNamed: childName	"Returns the child with the specified name if it is a child of this object"	| theChild |	"First see if they're looking for me"	(myName = childName) ifTrue: [ ^ self ].	"If that didn't work, try a recursive search through our children"	myChildren do: [:child | theChild _ (child getChildNamed: childName).						 theChild ifNotNil: [ ^ theChild ].				].	^ nil.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/19/1999 16:28'!getFaceCount	"Return the number of faces in this actor and its parts"	| count |	(myMesh notNil) ifTrue: [ count _ myMesh faces size ]					 ifFalse: [ count _ 0 ].	myChildren do: [:child | (child isPart) ifTrue: [ count _ count + (child getFaceCount) ] ].	^ count.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 3/22/1999 14:14'!getWonderland	"Return the wonderland this actor is a part of"	^ myWonderland.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 2/9/1999 10:09'!isFirstClass	"Returns true if the object is a First Class object"	^ firstClass.! !!WonderlandActor methodsFor: 'accessing' stamp: 'jsp 2/9/1999 10:10'!isPart	"Returns true if the object is a Part."	^ (firstClass not).! !!WonderlandActor methodsFor: 'parent-child' stamp: 'jsp 3/19/1999 12:09'!becomeChildOf: anObject	"Update the undo stack and make this actor a child of the specified object."	| oldParent |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyReferenceFrame: anObject ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can only make ' , myName , ' a child of other actors or the scene, and ', msg.			^ nil ].	(self = anObject) ifTrue: [		myWonderland reportErrorToUser: 'Squeak can not make ' , myName , ' a child of itself.'.		^ nil ].			oldParent _ myParent.	(myWonderland getUndoStack) push: (UndoAction new: [self reparentTo: oldParent]).	self reparentTo: anObject.! !!WonderlandActor methodsFor: 'playing sound' stamp: 'jsp 3/19/1999 10:34'!playSound: soundFile	"Create an animation that plays the sound and lasts the duration of the sound"	| aSound |	 [ aSound _ SampledSound fromWaveFileNamed: soundFile ]			ifError: [ :msg : rcvr | myWonderland reportErrorToUser:										(soundFile asString) , ' is not a valid WAV file.'.					^ nil ].	^ myWonderland doTogether: {				self do: [ aSound play ].				self wait: (aSound duration)								}.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/4/1999 11:53'!alignWith: anObject	"This method sets the orientation of this instance to be the same as that of the specified object."	^ self turnTo: anObject duration: 1.0 style: gently.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/8/1999 17:02'!alignWith: anObject duration: aDuration	"This method sets the orientation of this instance to be the same as that of the specified object."	^ self turnTo: anObject duration: aDuration.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/4/1999 11:52'!alignWith: anObject duration: aDuration style: aStyle	"This method sets the orientation of this instance to be the same as that of the specified object."	^ self turnTo: anObject duration: aDuration style: aStyle.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:09'!move: aDirection	"Move the actor one meter in the specified direction, taking 1 second and using the Gently animation style."	^ (self move: aDirection distance: 1.0 duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:09'!move: aDirection asSeenBy: reference	"Move the actor one meter in the specified direction, taking 1 second and using the Gently animation style."	^ (self move: aDirection distance: 1.0 duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:10'!move: aDirection distance: aDistance 	"Move the actor the specified distance in the specified direction, taking 1 second and using the Gently animation style."	^ (self move: aDirection distance: aDistance duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:07'!move: aDirection distance: aDistance asSeenBy: reference	"Move the actor the specified distance in the specified direction, taking 1 second and using the Gently animation style."	^ (self move: aDirection distance: aDistance duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:24'!move: aDirection distance: aDistance duration: aDuration	"Move the actor the specified distance in the specified direction, taking the specified duration and using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyDirection: aDirection ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: aDistance ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the distance to move ' , myName , ' because ', msg.				^ nil ].		self moveRightNow: aDirection distance: aDistance undoable: true.		^ self. ].	^ (self move: aDirection distance: aDistance duration: aDuration style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:25'!move: aDirection distance: aDistance duration: aDuration asSeenBy: reference	"Move the actor the specified distance in the specified direction, taking the specified duration and using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyDirection: aDirection ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: aDistance ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the distance to move ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].		self moveRightNow: aDirection distance: aDistance asSeenBy: reference undoable: true.		^ self. ].	^ (self move: aDirection distance: aDistance duration: aDuration asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:17'!move: aDirection distance: aDistance duration: aDuration asSeenBy: reference style: aStyle	"Move the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim a3DVector tmpVector tMatrix newComposite |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: aDistance ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the distance to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to move ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ RelativeAnimation new.	tmpVector _ (B3DVector3 x:0 y:0 z:0).	tMatrix _ B3DMatrix4x4 identity.	[ a3DVector _ self makeVectorFromDistance: aDistance andDirection: aDirection. ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak does not know how to move ' , myName , ' in that direction.'.			^ nil ].	anim object: self			update: [:tPos | newComposite _ (reference getMatrixToRoot)										composeWith: (self getMatrixFromRoot).						 composite _ (((myParent getMatrixToRoot)										composeWith: (reference getMatrixFromRoot))										composeWith:										(tMatrix translation: (tPos - tmpVector)))										composeWith: newComposite.						 tmpVector _ tPos]			getStartState: [tmpVector x:0; y:0; z:0.								(B3DVector3 x:0 y:0 z:0) ]			getEndState: [ a3DVector ]			getReverseState: [ a3DVector negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:18'!move: aDirection distance: aDistance duration: aDuration style: aStyle	"Move the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim a3DVector tmpVector tMatrix |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: aDistance ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the distance to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to move ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ RelativeAnimation new.	tmpVector _ (B3DVector3 x:0 y:0 z:0).	tMatrix _ B3DMatrix4x4 identity.	[ a3DVector _ self makeVectorFromDistance: aDistance andDirection: aDirection. ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak does not know how to move ' , myName , ' in that direction.'.			^ nil ].	anim object: self			update: [:tPos | composite _ composite composeWith:												(tMatrix translation: (tPos - tmpVector)).							tmpVector _ tPos]			getStartState: [tmpVector x:0; y:0; z:0.								(B3DVector3 x:0 y:0 z:0) ]			getEndState: [ a3DVector ]			getReverseState: [ a3DVector negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:18'!move: aDirection distance: aDistance speed: aSpeed	"Move the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim a3DVector tmpVector tMatrix aDuration |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: aDistance ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the distance to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	"The parameters check out, so build the animation"	anim _ RelativeAnimation new.	tmpVector _ (B3DVector3 x:0 y:0 z:0).	tMatrix _ B3DMatrix4x4 identity.	aDuration _ (aDistance / aSpeed) abs.	[ a3DVector _ self makeVectorFromDistance: aDistance andDirection: aDirection. ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak does not know how to move ' , myName , ' in that direction.'.			^ nil ].	anim object: self			update: [:tPos | composite _ composite composeWith:												(tMatrix translation: (tPos - tmpVector)).							tmpVector _ tPos]			getStartState: [tmpVector x:0; y:0; z:0.								(B3DVector3 x:0 y:0 z:0) ]			getEndState: [ a3DVector ]			getReverseState: [ a3DVector negated ]			style: abruptly			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:16'!move: aDirection distance: aDistance speed: aSpeed asSeenBy: reference	"Move the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim a3DVector aDuration tmpVector tMatrix newComposite |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: aDistance ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the distance to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	"The parameters check out, so build the animation"	anim _ RelativeAnimation new.	tmpVector _ (B3DVector3 x:0 y:0 z:0).	tMatrix _ B3DMatrix4x4 identity.	[ a3DVector _ self makeVectorFromDistance: aDistance andDirection: aDirection. ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak does not know how to move ' , myName , ' in that direction.'.			^ nil ].	aDuration _ (aDistance / aSpeed) abs.	anim object: self			update: [:tPos | newComposite _ (reference getMatrixToRoot)										composeWith: (self getMatrixFromRoot).						 composite _ (((myParent getMatrixToRoot)										composeWith: (reference getMatrixFromRoot))										composeWith:										(tMatrix translation: (tPos - tmpVector)))										composeWith: newComposite.						 tmpVector _ tPos]			getStartState: [tmpVector x:0; y:0; z:0.								(B3DVector3 x:0 y:0 z:0) ]			getEndState: [ a3DVector ]			getReverseState: [ a3DVector negated ]			style: abruptly			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:18'!move: aDirection speed: aSpeed	"Creates and returns an action that moves the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	"The parameters check out, so go ahead and start the action"	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveRightNow: aDirection							distance: ((myWonderland getScheduler getElapsedTime) * aSpeed)							undoable: false ].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:20'!move: aDirection speed: aSpeed asSeenBy: reference	"Creates and returns an action that moves the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	"The parameters check out, so build the action"	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveRightNow: aDirection							distance: ((myWonderland getScheduler getElapsedTime) * aSpeed)							asSeenBy: reference							undoable: false ].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:28'!move: aDirection speed: aSpeed asSeenBy: reference for: aLifetime	"Creates and returns an action that moves the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should move because ', msg.			^ nil ].	"The parameters check out, so start the action"	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveRightNow: aDirection							distance: ((myWonderland getScheduler getElapsedTime) * aSpeed)							asSeenBy: reference							undoable: false ]		   for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:31'!move: aDirection speed: aSpeed asSeenBy: reference until: aCondition	"Creates and returns an action that moves the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should move because ', msg.			^ nil ].	"The parameters check out, so start the action"	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveRightNow: aDirection							distance: ((myWonderland getScheduler getElapsedTime) * aSpeed)							asSeenBy: reference							undoable: false ]		   until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:29'!move: aDirection speed: aSpeed for: aLifetime	"Creates and returns an action that moves the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should move because ', msg.			^ nil ].	"The parameters check out, so start the action"	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveRightNow: aDirection							distance: ((myWonderland getScheduler getElapsedTime) * aSpeed)							undoable: false ]		   for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:33'!move: aDirection speed: aSpeed until: aCondition	"Creates and returns an action that moves the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to move ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should move because ', msg.			^ nil ].	"The parameters check out, so start the action"	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveRightNow: aDirection							distance: ((myWonderland getScheduler getElapsedTime) * aSpeed)							undoable: false ]		   until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:10'!moveTo: aVector	"Moves the object to the specified position in its parent's coordinate system over 1 second using the Gently animation style."	^ (self moveTo: aVector duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:10'!moveTo: aVector asSeenBy: reference	"Moves the object to the specified position in its parent's coordinate system over 1 second using the Gently animation style."	^ (self moveTo: aVector duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:56'!moveTo: aVector asSeenBy: reference eachFrameFor: aLifetime	"Move the actor to a specified point each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should move to this position because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveToRightNow: aVector asSeenBy: reference undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:57'!moveTo: aVector asSeenBy: reference eachFrameUntil: aCondition	"Move the actor to a specified point each frame until the condition returns true."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long ' , myName , ' should move to this position because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveToRightNow: aVector asSeenBy: reference undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 09:47'!moveTo: aVector duration: aDuration	"Moves the object to the specified position in its parent's coordinate system over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.				^ nil ].		[ WonderlandVerifier VerifyDuration: aDuration ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.				^ nil ].		self moveToRightNow: aVector undoable: true.		^ self. ].	(aDuration = eachFrame) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.				^ nil ].		[ WonderlandVerifier VerifyDuration: aDuration ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).		^ self doEachFrame: [ self moveToRightNow: aVector	undoable: false ].									].	^ (self moveTo: aVector duration: aDuration			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 09:47'!moveTo: aVector duration: aDuration asSeenBy: reference	"Moves the object to the specified position in its parent's coordinate system over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.				^ nil ].		[ WonderlandVerifier VerifyDuration: aDuration ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].		self moveToRightNow: aVector asSeenBy: reference undoable: true.		^ self ].	(aDuration = eachFrame) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.				^ nil ].		[ WonderlandVerifier VerifyDuration: aDuration ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).		^ self doEachFrame: [ self moveToRightNow: aVector	asSeenBy: reference undoable: false ].									].	^ (self moveTo: aVector duration: aDuration asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:53'!moveTo: aVector duration: aDuration asSeenBy: reference style: aStyle	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	| anim endStateFunc pos newComposite vectorMatrix |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not move ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to move ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	endStateFunc _ [		vectorMatrix _ B3DMatrix4x4 identity.		pos _ self getPosition: reference.		((aVector at: 1) = asIs) ifFalse: [ pos at: 1 put: (aVector at: 1) ].		((aVector at: 2) = asIs) ifFalse: [ pos at: 2 put: (aVector at: 2) ].		((aVector at: 3) = asIs) ifFalse: [ pos at: 3 put: (aVector at: 3) ].		vectorMatrix translation: (B3DVector3 x: (pos at: 1) y: (pos at: 2) z: (pos at: 3)).		newComposite _ (myParent getMatrixToRoot) composeWith: (reference getMatrixFromRoot).		newComposite _ newComposite composeWith: vectorMatrix.		newComposite translation.					].	anim object: self			update: [:tPos | self setPositionVector: tPos]			getStartState: [self getPositionVector]			getEndState: endStateFunc			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:48'!moveTo: aVector duration: aDuration style: aStyle	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	| anim pos endStateFunc |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for moving ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to move ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	(aVector isKindOf: WonderlandActor)		ifTrue: [ endStateFunc _ [ pos _ aVector getPosition: myParent.				 				   B3DVector3 x: (pos at: 1) y: (pos at: 2) z: (pos at: 3). ]				]		ifFalse: [ endStateFunc _ [						pos _ self getPositionVector.				  		((aVector at: 1) = asIs) ifFalse: [pos x: (aVector at: 1) ].				  		((aVector at: 2) = asIs) ifFalse: [pos y: (aVector at: 2) ].				  		((aVector at: 3) = asIs) ifFalse: [pos z: (aVector at: 3) ].				  		pos.								]				].	anim object: self			update: [:tPos | self setPositionVector: tPos]			getStartState: [self getPositionVector]			getEndState: endStateFunc			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:56'!moveTo: aVector eachFrameFor: aLifetime	"Move the actor to a specified point each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should move to this position because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveToRightNow: aVector undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:57'!moveTo: aVector eachFrameUntil: aCondition	"Move the actor to a specified point each frame until the condition returns true."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long ' , myName , ' should move to this position because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self moveToRightNow: aVector undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:07'!moveTo: aVector speed: aSpeed 	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	^ self moveTo: aVector duration: (((self distanceTo: aVector) / aSpeed) abs) style: abruptly.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 16:07'!moveTo: aVector speed: aSpeed asSeenBy: reference	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	^ self moveTo: aVector duration: (((self distanceTo: aVector) / aSpeed) abs)			asSeenBy: reference style: abruptly.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/4/1999 15:45'!nudge: aDirection	"Nudge the actor one length in the specified direction, taking 1 second and using the Gently animation style."	^ (self nudge: aDirection distance: 1.0 duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/4/1999 15:50'!nudge: aDirection distance: aDistance	"Nudge the actor the specified object lengths in the specified direction, taking one second and using the Gently animation style."	^ self nudge: aDirection distance: aDistance duration: 1.0 style: gently.	! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 17:00'!nudge: aDirection distance: aDistance duration: aDuration 	"Nudge the actor the specified object lengths in the specified direction, taking the specified duration and using the Gently animation style."	|  size newDistance |		(aDuration = rightNow) ifTrue: [			size _ self getSize.			((aDirection = #left) or: [ aDirection = #right ])				ifTrue: [ newDistance _ aDistance * (size at: 1) ]				ifFalse: [			((aDirection = #up) or: [ aDirection = #down ])				ifTrue: [ newDistance _ aDistance * (size at: 2) ]				ifFalse: [			((aDirection = #forward) or: [ (aDirection = #back) or: [aDirection = #backward]])				ifTrue: [ newDistance _ aDistance * (size at: 3) ]				ifFalse: [ 	myWonderland reportErrorToUser: 'Squeak could not determine which direction to nudge the object because ' , (aDirection asString) , 'is not a valid direction.'.							^ nil.]]].			^ self moveRightNow: aDirection distance: newDistance undoable: true ].	^ self nudge: aDirection distance: aDistance duration: aDuration style: gently.	! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 17:01'!nudge: aDirection distance: aDistance duration: aDuration style: aStyle	"Nudge the actor the specified object lengths in the specified direction, taking the specified duration and using the specified animation style."	|  size newDistance |		size _ self getSize.	((aDirection = #left) or: [ aDirection = #right ])		ifTrue: [ newDistance _ aDistance * (size at: 1) ]		ifFalse: [	((aDirection = #up) or: [ aDirection = #down ])		ifTrue: [ newDistance _ aDistance * (size at: 2) ]		ifFalse: [	((aDirection = #forward) or: [ (aDirection = #back) or: [aDirection = #backward]])		ifTrue: [ newDistance _ aDistance * (size at: 3) ]		ifFalse: [ 	myWonderland reportErrorToUser: 'Squeak could not determine which direction to nudge ' , myName, ' because ' , (aDirection asString) , ' is not a valid direction.'.					^ nil.]]].	^ self move: aDirection distance: newDistance duration: aDuration style: aStyle.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/4/1999 10:57'!place: aLocation object: aTarget	"Moves this object to one of several pre-determined locations relative to the target object."	 ^ self place: aLocation object: aTarget duration: 1.0 style: gently.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 09:48'!place: aLocation object: aTarget duration: aDuration 	"Moves this object to one of several pre-determined locations relative to the target object."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyLocation: aLocation ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyActor: aTarget ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.				^ nil ].		self placeRightNow: aLocation object: aTarget undoable: true.		^ self. ].	(aDuration = eachFrame) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyLocation: aLocation ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyActor: aTarget ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).		^ self doEachFrame: [ self placeRightNow: aLocation object: aTarget undoable: false ].									].	 ^ self place: aLocation object: aTarget duration: aDuration style: gently.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 17:27'!place: aLocation object: aTarget duration: aDuration style: aStyle	"Moves this object to one of several pre-determined locations relative to the target object."	 | anim selfPos selfBBox selfLBB selfRUF objBBox objLBB objRUF pos |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyLocation: aLocation ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyActor: aTarget ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for placing ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to place ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so build the animation"	selfBBox _ self getBoundingBox: aTarget.	selfLBB _ selfBBox origin.	selfRUF _ selfBBox corner.	objBBox _ aTarget getBoundingBox.	objLBB _ objBBox origin.	objRUF _ objBBox corner.	selfPos _ self getPosition: aTarget.	((aLocation = onTopOf) or: [ aLocation = above])	ifTrue: [				pos _ { 0. (objRUF y) + ((selfPos at: 2) - (selfLBB y)). 0}			] 	ifFalse: [	((aLocation = onBottomOf) or: [ (aLocation = beneath) or: [ aLocation = below ] ])	ifTrue: [				pos _ { 0. (objLBB y) - ((selfRUF y) - (selfPos at: 2)). 0}			]	ifFalse: [	(aLocation = toLeftOf)	ifTrue: [				pos _ { (objLBB x) - ((selfRUF x) - (selfPos at: 1)). 0. 0 }			]	ifFalse: [	(aLocation = toRightOf)	ifTrue: [				pos _ { (objRUF x) + ((selfPos at: 1) - (selfLBB x)). 0. 0 }			]	ifFalse: [	(aLocation = inFrontOf)	ifTrue: [				pos _ { 0. 0. (objRUF z) + ((selfPos at: 3) - (selfLBB z)) }			]	ifFalse: [	((aLocation = inBackOf) or: [ aLocation = behind])	ifTrue: [				pos _ { 0. 0. (objLBB z) - ((selfRUF z) - (selfPos at:3)) }			]	ifFalse: [	(aLocation = onCeilingOf)	ifTrue: [				pos _ { 0. (objRUF y) - ((selfRUF y) - (selfPos at:2)). 0}			]	ifFalse: [	(aLocation = onFloorOf)	ifTrue: [				pos _ { 0. (objLBB y) + ((selfPos at: 2) - (selfLBB y)). 0}			]	ifFalse: [ self error: 'Unrecognized target surface' ]]]]]]]].	anim _	self moveTo: pos duration: aDuration asSeenBy: aTarget style: aStyle.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 17:30'!place: aLocation object: aTarget eachFrameFor: aLifetime 	"Moves this object to one of several pre-determined locations relative to the target object each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyLocation: aLocation ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyActor: aTarget ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long it should place ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self placeRightNow: aLocation object: aTarget undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/17/1999 17:30'!place: aLocation object: aTarget eachFrameUntil: aCondition	"Moves this object to one of several pre-determined locations relative to the target object each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyLocation: aLocation ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyActor: aTarget ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to place ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long it should place ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self placeRightNow: aLocation object: aTarget undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:10'!pointAt: target	"Turns the object to point at the specified target over the specified duration using the Gently animation style."	^ (self pointAt: target duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/29/1999 14:39'!pointAt: target duration: aDuration	"Turns the object to point at the specified target over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check the target to make sure it's valid"		[ WonderlandVerifier VerifyTargetOrPixel: target ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what to point ' , myName , ' at because ', msg.				^ nil ].		self pointAtRightNow: target undoable: true.		^ self. ].	(aDuration = eachFrame) ifTrue: [		"Check the target to make sure it's valid"		[ WonderlandVerifier VerifyTargetOrPixel: target ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what to point ' , myName , ' at because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).		^ self doEachFrame: [ self pointAtRightNow: target undoable: false ].									].	^ (self pointAt: target duration: aDuration style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/29/1999 14:39'!pointAt: target duration: aDuration style: aStyle	"Turns the object to point at the specified target using the specified style over the specified duration."	| anim |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTargetOrPixel: target ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what to point ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for pointing ' , myName , ' at ' , (target asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to point ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	anim object: self			update: [:tQuat | self setRotationMatrix: (tQuat asMatrix4x4) ]			getStartState: [ composite asQuaternion ]			getEndState: [ (self getPointAtMatrix: target) asQuaternion ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/29/1999 14:39'!pointAt: target eachFrameFor: aLifetime	"Turns the object to point at the specified target each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTargetOrPixel: target ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what to point ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should point ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self pointAtRightNow: target undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/29/1999 14:39'!pointAt: target eachFrameUntil: aCondition	"Turns the object to point at the specified target each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTargetOrPixel: target ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what to point ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should point ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self pointAtRightNow: target undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/24/1999 16:46'!resize: amount	"Resize the object by the specified amount over 1 second using the Gently animation style."	"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyNumberOrTriple: amount ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.				^ nil ].	(amount isNumber)		ifTrue: [ ^ (self resizeTopToBottom: amount leftToRight: amount frontToBack: amount						duration: 1.0						style: gently). ]		ifFalse: [  ^ (self resizeTopToBottom: (amount at: 2)						leftToRight: (amount at: 1)						frontToBack: (amount at: 3)						duration: 1.0						style: gently). ].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/24/1999 16:51'!resize: amount duration: aDuration	"Resize the object by the specified amount over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyNumberOrTriple: amount ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.				^ nil ].		(amount isNumber)			ifTrue: [ self resizeRightNow: (B3DVector3 x: amount y: amount z: amount)							undoable: true. ]			ifFalse: [ self resizeRightNow: (B3DVector3 x: (amount at: 1) y: (amount at: 2)							z: (amount at: 3)) undoable: true. ].		^ self.									].	(aDuration = eachFrame) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyNumberOrTriple: amount ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).		(amount isNumber)			ifTrue: [ ^ self doEachFrame: [ self resizeRightNow: (B3DVector3 x: amount y:												amount z: amount) undoable: false ] ]			ifFalse: [ ^ self doEachFrame: [ self resizeRightNow: (B3DVector3 x: (amount at: 1)												y: (amount at: 2) z: (amount at: 3))												undoable: true. ] ].									].	(amount isNumber)		ifTrue: [ ^ (self resizeTopToBottom: amount leftToRight: amount frontToBack: amount						duration: 1.0						style: gently). ]		ifFalse: [  ^ (self resizeTopToBottom: (amount at: 2)						leftToRight: (amount at: 1)						frontToBack: (amount at: 3)						duration: 1.0						style: gently). ].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/24/1999 16:47'!resize: amount duration: aDuration style: aStyle	"Resize the object by the specified amount over the specified duration using the specified animation style."	"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyNumberOrTriple: amount ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.				^ nil ].	(amount isNumber)		ifTrue: [ ^ (self resizeTopToBottom: amount leftToRight: amount frontToBack: amount						duration: 1.0						style: gently). ]		ifFalse: [  ^ (self resizeTopToBottom: (amount at: 2)						leftToRight: (amount at: 1)						frontToBack: (amount at: 3)						duration: 1.0						style: gently). ].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/24/1999 16:53'!resize: amount eachFrameFor: aLifetime	"Resize the object by the specified amount each frame for the specified lifetime."	| aVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyNumberOrTriple: amount ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should resize ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).	(amount isNumber)		ifTrue: [ aVector _ (B3DVector3 x: amount y: amount z: amount) ]		ifFalse: [ aVector _ (B3DVector3 x: (amount at: 1) y: (amount at: 2)									 z: (amount at: 3)) ].	^ self doEachFrame: [ self resizeRightNow: aVector undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/24/1999 16:53'!resize: amount eachFrameUntil: aCondition	"Resize the object by the specified amount each frame until the condition returns true."	| aVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyNumber: amount ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should resize ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).	(amount isNumber)		ifTrue: [ aVector _ (B3DVector3 x: amount y: amount z: amount) ]		ifFalse: [ aVector _ (B3DVector3 x: (amount at: 1) y: (amount at: 2)									 z: (amount at: 3)) ].	^ self doEachFrame: [ self resizeRightNow: aVector undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 12:42'!resizeLikeRubber: amount dimension: aDimension	"Resizes the object using a volume preserving resize"	^ self resizeLikeRubber: amount dimension: aDimension duration: 1.0 style: gently.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 12:42'!resizeLikeRubber: amount dimension: aDimension duration: aDuration	"Resizes the object using a volume preserving resize"	| x y z |	(aDuration = rightNow) ifTrue: [		(aDimension = leftToRight)			ifTrue: [						x _ amount.						y _ 1 / (amount sqrt).						z _ 1 / (amount sqrt).					]			ifFalse: [ (aDimension = topToBottom)					ifTrue: [								x _ 1 / (amount sqrt).								y _ amount.								z _ 1 / (amount sqrt).							]					ifFalse: [ (aDimension = frontToBack)							ifTrue: [										x _ 1 / (amount sqrt).										y _ 1 / (amount sqrt).										z _ amount.									].							].					].			^ self resize: { x. y. z } duration: aDuration.		].	^ self resizeLikeRubber: amount dimension: aDimension duration: aDuration style: gently.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 12:29'!resizeLikeRubber: amount dimension: aDimension duration: aDuration style: aStyle	"Resizes the object using a volume preserving resize"	| x y z |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDimension: aDimension ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine along which dimension to resize ' , myName , '  because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: amount ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , '  because ', msg.			^ nil ].	(aDimension = leftToRight)		ifTrue: [					x _ amount.					y _ 1 / (amount sqrt).					z _ 1 / (amount sqrt).				]		ifFalse: [ (aDimension = topToBottom)				ifTrue: [							x _ 1 / (amount sqrt).							y _ amount.							z _ 1 / (amount sqrt).						]				ifFalse: [ (aDimension = frontToBack)						ifTrue: [									x _ 1 / (amount sqrt).									y _ 1 / (amount sqrt).									z _ amount.								].						].				].	^ self resizeTopToBottom: y leftToRight: x frontToBack: z duration: aDuration style: aStyle.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:11'!resizeTopToBottom: height leftToRight: width frontToBack: thickness	"Resize the object by the specified amount over 1 second using the Gently animation style."	^ (self resizeTopToBottom: height leftToRight: width frontToBack: thickness				duration: 1.0				style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:04'!resizeTopToBottom: height leftToRight: width frontToBack: thickness duration: aDuration	"Resize the object by the specified amount over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyNumber: height ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from top to bottom because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: width ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from left to right because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: thickness ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from front to back because ', msg.				^ nil ].		self resizeRightNow: (B3DVector3 x: width y: height z: thickness) undoable: true.		^ self.									].	(aDuration = eachFrame) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyNumber: height ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from top to bottom because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: width ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from left to right because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: thickness ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from front to back because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).		^ self doEachFrame: [ self resizeRightNow: (B3DVector3 x: width y: height z: thickness)									undoable: false ]									].	^ (self resizeTopToBottom: height leftToRight: width frontToBack: thickness				duration: aDuration style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:03'!resizeTopToBottom: height leftToRight: width frontToBack: thickness duration: aDuration style: aStyle	"Resize the object by the specified amount over the specified duration."	| anim tmpVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyNumber: height ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from top to bottom because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: width ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from left to right because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: thickness ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from front to back because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for resizing ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to resize ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so build the animation"	anim _ RelativeAnimation new.	tmpVector _ B3DVector3 x: 1.0 y: 1.0 z: 1.0.	anim object: self			update: [:tScale | self scaleByVector: (tScale / tmpVector).							tmpVector _ tScale]			getStartState: [ tmpVector x: 1.0; y: 1.0; z: 1.0.									(B3DVector3 x: 1.0 y: 1.0 z: 1.0) ]			getEndState: [ B3DVector3 x: width y: height z: thickness ]			getReverseState: [ B3DVector3 x: (1 / width) y: (1 / height) z: (1 / thickness) ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:07'!resizeTopToBottom: height leftToRight: width frontToBack: thickness eachFrameFor: aLifetime	"Resize the object by the specified amount each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyNumber: height ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from top to bottom because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: width ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from left to right because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: thickness ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from front to back because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should resize ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).	^ self doEachFrame: [ self resizeRightNow: (B3DVector3 x: width y: height z: thickness)									undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:07'!resizeTopToBottom: height leftToRight: width frontToBack: thickness eachFrameUntil: aCondition	"Resize the object by the specified amount each frame until the condition is true."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyNumber: height ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from top to bottom because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: width ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from left to right because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: thickness ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how much to resize ' , myName , ' from front to back because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should resize ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).	^ self doEachFrame: [ self resizeRightNow: (B3DVector3 x: width y: height z: thickness)									undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:50'!roll: aDirection	"Roll the actor a quarter turn in the specified direction, taking 1 second and using the Gently animation style."	^ (self roll: aDirection turns: 0.25 duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:50'!roll: aDirection asSeenBy: reference	"Roll the actor 1/4 turn in the specified direction, taking 1 second and using the Gently animation style."	^ (self roll: aDirection turns: 0.25 duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:43'!roll: aDirection speed: aSpeed	"Creates and returns an action that rolls the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self rollRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				undoable: false						].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:44'!roll: aDirection speed: aSpeed asSeenBy: reference	"Creates and returns an action that rolls the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not roll ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self rollRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				asSeenBy: reference				undoable: false						].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:45'!roll: aDirection speed: aSpeed asSeenBy: reference for: aLifetime	"Creates and returns an action that rolls the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not roll ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should roll ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self rollRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				asSeenBy: reference				undoable: false						]		   for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:46'!roll: aDirection speed: aSpeed asSeenBy: reference until: aCondition	"Creates and returns an action that rolls the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not roll ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should roll ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self rollRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				asSeenBy: reference				undoable: false						]		   until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:45'!roll: aDirection speed: aSpeed for: aLifetime	"Creates and returns an action that rolls the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should roll ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self rollRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				undoable: false						]		   for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:46'!roll: aDirection speed: aSpeed until: aCondition	"Creates and returns an action that rolls the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should roll ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self rollRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				undoable: false						]		   until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:47'!roll: aDirection turns: numTurns	"Roll the actor the specified number of turns in the specified direction, taking 1 second and using the Gently animation style."	^ (self roll: aDirection turns: numTurns duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:48'!roll: aDirection turns: numTurns asSeenBy: reference	"Roll the actor the specified number of turns in the specified direction, taking 1 second and using the Gently animation style."	^ (self roll: aDirection turns: numTurns duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:48'!roll: aDirection turns: numTurns duration: aDuration	"Roll the actor the specified number of turns in the specified direction, taking the specified duration and using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyDirection: aDirection ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: numTurns ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the number of turns to roll ' , myName , ' because ', msg.				^ nil ].			self rollRightNow: aDirection numberOfTurns: numTurns undoable: true.			^ self. ].	^ (self roll: aDirection turns: numTurns duration: aDuration			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:49'!roll: aDirection turns: numTurns duration: aDuration asSeenBy: reference	"Roll the actor the specified number of turns in the specified direction, taking the specified duration and using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyDirection: aDirection ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: numTurns ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the number of turns to roll ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not roll ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].			self rollRightNow: aDirection numberOfTurns: numTurns						asSeenBy: reference undoable: true.			^ self. ].	^ (self roll: aDirection turns: numTurns duration: aDuration asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:50'!roll: aDirection turns: numTurns duration: aDuration asSeenBy: reference style: aStyle	"Roll the actor the specified number of turns in the specified direction, taking the specified duration and using the specified animation style."	| anim updateFunc degrees lastAmount buildMatrix newMatrix tMatrix|	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the number of turns to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for rolling ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not roll ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to roll ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so go ahead and build the animation"	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	buildMatrix _ [ :rotMatrix | newMatrix _ reference getMatrixToRoot.						newMatrix _ newMatrix composeWith: (self getMatrixFromRoot).						newMatrix _ (((myParent getMatrixToRoot)										composeWith: (reference getMatrixFromRoot))										composeWith: rotMatrix)										composeWith: newMatrix. ].	(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to roll ' , myName , ' ', (aDirection asString) , '.'.				^ nil ]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:50'!roll: aDirection turns: numTurns duration: aDuration style: aStyle	"Roll the actor the specified number of turns in the specified direction, taking the specified duration and using the specified animation style."	| anim updateFunc degrees lastAmount tMatrix|	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the number of turns to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for rolling ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to roll ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so go ahead and build the animation"	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to roll ' , myName , ' ', (aDirection asString) , '.'.				^ nil ]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:51'!roll: aDirection turns: numTurns speed: aSpeed	"Roll the actor the specified number of turns in the specified direction, taking the specified duration and using the specified animation style."	| anim aDuration updateFunc degrees lastAmount tMatrix |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the number of turns to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	aDuration _ (numTurns / aSpeed) abs.	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to roll ' , myName , ' ', (aDirection asString) , '.'.				^ nil ]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: abruptly			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:51'!roll: aDirection turns: numTurns speed: aSpeed asSeenBy: reference	"Roll the actor the specified number of turns in the specified direction, taking the specified duration and using the specified animation style."	| anim aDuration updateFunc degrees lastAmount buildMatrix newMatrix tMatrix|	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the number of turns to roll ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to roll ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not roll ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	anim _ RelativeAnimation new.	aDuration _ (numTurns / aSpeed) abs.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	buildMatrix _ [ :rotMatrix | newMatrix _ reference getMatrixToRoot.						newMatrix _ newMatrix composeWith: (self getMatrixFromRoot).						newMatrix _ (((myParent getMatrixToRoot)										composeWith: (reference getMatrixFromRoot))										composeWith: rotMatrix)										composeWith: newMatrix. ].	(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to roll ' , myName , ' ', (aDirection asString) , '.'.				^ nil ]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: abruptly			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/5/1999 12:23'!standUp	"Rotate the object to align it along its parent's up vector"	^ self turnTo: #(0 #asIs 0) duration: 1.0 style: gently.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/8/1999 15:15'!standUpWithDuration: duration	"Rotate the object to align it along its parent's up vector"	^ self turnTo: #(0 #asIs 0) duration: duration.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/5/1999 12:23'!standUpWithDuration: duration style: aStyle	"Rotate the object to align it along its parent's up vector"	^ self turnTo: #(0 #asIs 0) duration: duration style: aStyle.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:58'!turn: aDirection	"Turn the actor once around in the specified direction, taking 1 second and using the Gently animation style."	^ (self turn: aDirection turns: 0.25 duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:59'!turn: aDirection asSeenBy: reference	"Turn the actor once around in the specified direction, taking 1 second and using the Gently animation style."	^ (self turn: aDirection turns: 0.25 duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:08'!turn: aDirection speed: aSpeed	"Creates and returns an action that turn the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self turnRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				undoable: false						].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:09'!turn: aDirection speed: aSpeed asSeenBy: reference	"Creates and returns an action that turn the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self turnRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				asSeenBy: reference				undoable: false						].! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:10'!turn: aDirection speed: aSpeed asSeenBy: reference for: aLifetime	"Creates and returns an action that turn the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self turnRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				asSeenBy: reference				undoable: false						]		   for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:11'!turn: aDirection speed: aSpeed asSeenBy: reference until: aCondition	"Creates and returns an action that turn the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self turnRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				asSeenBy: reference				undoable: false						]		   until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:10'!turn: aDirection speed: aSpeed for: aLifetime	"Creates and returns an action that turn the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self turnRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				undoable: false						]		   for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:11'!turn: aDirection speed: aSpeed until: aCondition	"Creates and returns an action that turn the object in the specified direction at the specified speed."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [				self turnRightNow: aDirection				numberOfTurns: ((myWonderland getScheduler getElapsedTime) * aSpeed)				undoable: false						]		   until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 11:01'!turn: aDirection turns: numTurns	"Turn the actor the specified number of turns in the specified direction, taking one second and using the Gently animation style."	^ (self turn: aDirection turns: numTurns duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 11:00'!turn: aDirection turns: numTurns asSeenBy: reference	"Turn the actor the specified number of turns in the specified direction, taking one second and using the Gently animation style."	^ (self turn: aDirection turns: numTurns duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 11:00'!turn: aDirection turns: numTurns duration: aDuration	"Turn the actor the specified distance in the specified direction, taking the specified duration and using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyDirection: aDirection ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: numTurns ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how many turns to turn ' , myName , ' because ', msg.				^ nil ].		self turnRightNow: aDirection numberOfTurns: numTurns undoable: true.		^ self. ].	^ (self turn: aDirection turns: numTurns duration: aDuration style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:59'!turn: aDirection turns: numTurns duration: aDuration asSeenBy: reference	"Turn the actor the specified distance in the specified direction, taking the specified duration and using the Gently animation style."	(aDuration = rightNow) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyDirection: aDirection ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyNumber: numTurns ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine how many turns to turn ' , myName , ' because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].		self turnRightNow: aDirection numberOfTurns: numTurns								asSeenBy: reference undoable: true.		^ self. ].	^ (self turn: aDirection turns: numTurns duration: aDuration asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:58'!turn: aDirection turns: numTurns duration: aDuration asSeenBy: reference style: aStyle	"Turn the actor the specified numberOfTurns in the specified direction, taking the specified duration and using the specified animation style."	| anim updateFunc degrees lastAmount buildMatrix newMatrix tMatrix|	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how many turns to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for turning ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to turn ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so go ahead and build the animation"	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	buildMatrix _ [ :rotMatrix | newMatrix _ reference getMatrixToRoot.						newMatrix _ newMatrix composeWith: (self getMatrixFromRoot).						newMatrix _ (((myParent getMatrixToRoot)										composeWith: (reference getMatrixFromRoot))										composeWith: rotMatrix)										composeWith: newMatrix. ].	(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle] ]		ifFalse: [(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated ]		ifFalse: [(((aDirection = #up) or: [aDirection = #back]) or: [aDirection = #backward])			ifTrue: [				updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle].				degrees _ degrees negated ]		ifFalse: [((aDirection = #down) or: [aDirection = #forward]) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #ccw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #cw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:57'!turn: aDirection turns: numTurns duration: aDuration style: aStyle	"Turn the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim updateFunc degrees lastAmount tMatrix|	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how many turns to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for turning ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to turn ' , myName , ' because ', msg.			^ nil ].	"The parameters check out, so go ahead and build the animation"	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle] ]		ifFalse: [(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated ]		ifFalse: [(((aDirection = #up) or: [aDirection = #back]) or: [aDirection = #backward])			ifTrue: [				updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle].				degrees _ degrees negated ]		ifFalse: [((aDirection = #down) or: [aDirection = #forward]) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #ccw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #cw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:56'!turn: aDirection turns: numTurns speed: aSpeed	"Turn the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim aDuration updateFunc degrees lastAmount tMatrix |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how many turns to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	aDuration _ (numTurns / aSpeed) abs.	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle] ]		ifFalse: [(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated ]		ifFalse: [(((aDirection = #up) or: [aDirection = #back]) or: [aDirection = #backward])			ifTrue: [				updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle].				degrees _ degrees negated ]		ifFalse: [((aDirection = #down) or: [aDirection = #forward]) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #ccw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #cw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. self rotateByMatrix:										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: abruptly			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/19/1999 10:56'!turn: aDirection turns: numTurns speed: aSpeed asSeenBy: reference	"Turn the actor the specified numberOfTurns in the specified direction, taking the specified duration and using the specified animation style."	| anim aDuration updateFunc degrees lastAmount buildMatrix newMatrix tMatrix|	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: numTurns ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how many turns to turn ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the speed to turn ' , myName , ' at because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	aDuration _ (numTurns / aSpeed) abs.	anim _ RelativeAnimation new.	degrees _ 360 * numTurns.	lastAmount _ 0.	tMatrix _ B3DMatrix4x4 new.	buildMatrix _ [ :rotMatrix | newMatrix _ reference getMatrixToRoot.						newMatrix _ newMatrix composeWith: (self getMatrixFromRoot).						newMatrix _ (((myParent getMatrixToRoot)										composeWith: (reference getMatrixFromRoot))										composeWith: rotMatrix)										composeWith: newMatrix. ].	(aDirection = #right) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle] ]		ifFalse: [(aDirection = #left) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundY: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated ]		ifFalse: [(((aDirection = #up) or: [aDirection = #back]) or: [aDirection = #backward])			ifTrue: [				updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle].				degrees _ degrees negated ]		ifFalse: [((aDirection = #down) or: [aDirection = #forward]) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundX: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #ccw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle]]		ifFalse: [(aDirection = #cw) ifTrue: [			updateFunc _ [:tAngle | tMatrix setIdentity. composite _ buildMatrix value: 										(tMatrix rotationAroundZ: (tAngle - lastAmount)).							lastAmount _ tAngle].			degrees _ degrees negated. ]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].		anim object: self			update: updateFunc			getStartState: [ lastAmount _ 0. (Interpolateable value: 0) ]			getEndState: [ degrees ]			getReverseState: [ degrees negated ]			style: abruptly			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:12'!turnTo: aVector	"Turns the object to the specified orientation in its parent's coordinate system over one second using the Gently animation style."	^ (self turnTo: aVector duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:22'!turnTo: aVector AsSeenBy: reference eachFrameFor: aLifetime	"Turns the object to the specified orientation in its parent's coordinate system each frame for the specified lifetime."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self turnToRightNow: aVector asSeenBy: reference undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:21'!turnTo: aVector AsSeenBy: reference eachFrameUntil: aCondition	"Turns the object to the specified orientation in its parent's coordinate system each frame until the condition returns true."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self turnToRightNow: aVector asSeenBy: reference undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/1/1999 14:12'!turnTo: aVector asSeenBy: reference	"Turns the object to the specified orientation in its parent's coordinate system over one second using the Gently animation style."	^ (self turnTo: aVector duration: 1.0 asSeenBy: reference			style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:16'!turnTo: aVector duration: aDuration	"Turns the object to the specified orientation in its parent's coordinate system over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.				^ nil ].		self turnToRightNow: aVector undoable: true.		^ self. ].	(aDuration = eachFrame) ifTrue: [		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).		^ self doEachFrame: [ self turnToRightNow: aVector	undoable: false ].									].	^ (self turnTo: aVector duration: aDuration style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:19'!turnTo: aVector duration: aDuration asSeenBy: reference	"Turns the object to the specified orientation in its parent's coordinate system over the specified duration using the Gently animation style."	(aDuration = rightNow) ifTrue: [		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].		self turnToRightNow: aVector asSeenBy: reference undoable: true.		^ self. ].	(aDuration = eachFrame) ifTrue: [		"Check our arguments to make sure they're valid"		[ WonderlandVerifier VerifyTarget: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.				^ nil ].		[ WonderlandVerifier VerifyReferenceFrame: reference ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.				^ nil ].		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).		^ self doEachFrame: [ self turnToRightNow: aVector asSeenBy: reference undoable: false ].									].	^ (self turnTo: aVector duration: aDuration asSeenBy: reference style: gently).! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:18'!turnTo: aVector duration: aDuration asSeenBy: reference style: aStyle	"Turns the object to the specified orientation in its parent's coordinate system using the specified style over the specified duration."	| anim endStateFunc angles newComposite vectorMatrix |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the duration to use for turning ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not turn ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to turn ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	vectorMatrix _ B3DMatrix4x4 identity.	endStateFunc _ [		vectorMatrix setIdentity.		angles _ self getAngles: reference.		((aVector at: 1) = asIs) ifFalse: [ angles at: 1 put: (aVector at: 1) ].		((aVector at: 2) = asIs) ifFalse: [ angles at: 2 put: (aVector at: 2) ].		((aVector at: 3) = asIs) ifFalse: [ angles at: 3 put: (aVector at: 3) ].		vectorMatrix rotation: (B3DVector3 x: (angles at: 1) y: (angles at: 2) z: (angles at: 3)).		newComposite _ (myParent getMatrixToRoot) composeWith: (reference getMatrixFromRoot).		newComposite _ newComposite composeWith: vectorMatrix.		newComposite asQuaternion.					].	anim object: self			update: [:tQuat | self setRotationMatrix: (tQuat asMatrix4x4) ]			getStartState: [ composite asQuaternion ]			getEndState: endStateFunc			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:16'!turnTo: aVector duration: aDuration style: aStyle	"Turns the object to the specified orientation in its parent's coordinate system using the specified style over the specified duration."	| anim endStateFunc m angles |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the duration to use for turning ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to turn ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	m _ B3DMatrix4x4 identity.	(aVector isKindOf: WonderlandActor)		ifTrue: [ endStateFunc _ [						m setIdentity.						angles _ aVector getAngles: myParent.						m rotation: (B3DVector3 x: (angles at: 1) y: (angles at: 2) z: (angles at: 3)).						m asQuaternion.								 ]				]		ifFalse: [ endStateFunc _ [						m setIdentity.						angles _ self getRotationVector.						((aVector at: 1) = asIs) ifFalse: [ angles x: (aVector at: 1) ].						((aVector at: 2) = asIs) ifFalse: [ angles y: (aVector at: 2) ].						((aVector at: 3) = asIs) ifFalse: [ angles z: (aVector at: 3) ].						m rotation: angles.						m asQuaternion.								 ]				].	anim object: self			update: [:tQuat | self setRotationMatrix: (tQuat asMatrix4x4) ]			getStartState: [ composite asQuaternion ]			getEndState: endStateFunc			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:22'!turnTo: aVector eachFrameFor: aLifetime	"Turns the object to the specified orientation in its parent's coordinate system each frame for aLifetime seconds."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self turnToRightNow: aVector	undoable: false ]			for: aLifetime.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 11:21'!turnTo: aVector eachFrameUntil: aCondition	"Turns the object to the specified orientation in its parent's coordinate system each frame until the condition returns true."	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTarget: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to turn ' , myName , ' to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long it should turn ' , myName , ' because ', msg.			^ nil ].	myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).	^ self doEachFrame: [ self turnToRightNow: aVector	undoable: false ]			until: aCondition.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/9/1999 15:56'!wait	"Creates an animation where the object merely waits for one second"	| anim |	anim _ RelativeAnimation new.	anim object: self			update: [:temp | temp ]			getStartState: [ Interpolateable value: 0 ]			getEndState: [ 1.0 ]			getReverseState: [ 1.0 ]			style: [:elapsed :total | WonderlandStyle abruptlyAfter: elapsed outOf: total]			duration: 1.0			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'primitive behaviors' stamp: 'jsp 3/18/1999 10:51'!wait: time	"Creates an animation where the object merely waits for the specified amount of time"	| anim |	[ WonderlandVerifier VerifyDuration: time ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine how long ' , myName , ' should wait because ', msg.			^ nil ].	anim _ RelativeAnimation new.	anim object: self			update: [:temp | temp ]			getStartState: [ Interpolateable value: 0 ]			getEndState: [ time ]			getReverseState: [ time ]			style: [:elapsed :total | WonderlandStyle abruptlyAfter: elapsed outOf: total]			duration: time			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 2/24/1999 11:46'!getAngles	"Return the object's current orientation in its parent's coordinate system"	| a3DVector anArray |	anArray _ Array new: 3.	a3DVector _ composite rotation.	anArray at: 1 put: (a3DVector x).	anArray at: 2 put: (a3DVector y).	anArray at: 3 put: (a3DVector z).	^ anArray.	! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/18/1999 16:57'!getAngles: reference	"Returns the object's orientation relative to a reference object"	| newComposite anArray a3DVector |	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not determine the angles of ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	newComposite _ reference getMatrixToRoot.	a3DVector _ (newComposite composeWith: (self getMatrixFromRoot)) rotation.	anArray _ Array new: 3.	anArray at: 1 put: (a3DVector x).	anArray at: 2 put: (a3DVector y).	anArray at: 3 put: (a3DVector z).	^ anArray.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/1/1999 13:26'!getColor	"Return the actor's color"	| tmpArray  |	tmpArray _ Array new:3.	tmpArray at:1 put: (myColor red).	tmpArray at:2 put: (myColor green).	tmpArray at:3 put: (myColor blue).	^ tmpArray.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/12/1999 15:22'!getName	"Returns the object's name"	^ myName.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 2/24/1999 12:45'!getPointOfView	"Returns the object's position and orientation"	| anArray a3DVector |	a3DVector _ composite translation.	anArray _ Array new: 6.	anArray at: 1 put: (a3DVector x).	anArray at: 2 put: (a3DVector y).	anArray at: 3 put: (a3DVector z).	a3DVector _ composite rotation.	anArray at: 4 put: (a3DVector x).	anArray at: 5 put: (a3DVector y).	anArray at: 6 put: (a3DVector z).	^ anArray.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/18/1999 16:57'!getPointOfView: reference	"Returns the object's position and orientation"	| newComposite anArray a3DVector |	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can determine the point of view of ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	newComposite _ reference getMatrixToRoot.	newComposite _ newComposite composeWith: (self getMatrixFromRoot).	a3DVector _ newComposite translation.	anArray _ Array new: 6.	anArray at: 1 put: (a3DVector x).	anArray at: 2 put: (a3DVector y).	anArray at: 3 put: (a3DVector z).	a3DVector _ newComposite rotation.	anArray at: 4 put: (a3DVector x).	anArray at: 5 put: (a3DVector y).	anArray at: 6 put: (a3DVector z).	^ anArray.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 2/10/1999 17:05'!getPosition	"Return the object's current position in its parent's coordinate system"	| a3DVector anArray |	anArray _ Array new: 3.	a3DVector _ composite translation.	anArray at: 1 put: (a3DVector x).	anArray at: 2 put: (a3DVector y).	anArray at: 3 put: (a3DVector z).	^ anArray.	! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/18/1999 16:58'!getPosition: reference	"Returns the object's position relative to a reference object"	| newComposite anArray a3DVector |	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not determine the position of ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	newComposite _ reference getMatrixToRoot.	a3DVector _ (newComposite composeWith: (self getMatrixFromRoot)) translation.	anArray _ Array new: 3.	anArray at: 1 put: (a3DVector x).	anArray at: 2 put: (a3DVector y).	anArray at: 3 put: (a3DVector z).	^ anArray.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/25/1999 14:59'!getPositionInPicturePlane	"Returns the actor's position in the picture plane of the default camera"	| camera d x y z pos |	camera _ myWonderland getDefaultCamera.	pos _ self getPosition: camera.	d _ (camera getFrustum) near.	z _ (pos at: 3) abs.	(z = 0) ifTrue: 	[						x _ 0.						y _ 0.					]			ifFalse: [						x _ (d / z) * (pos at: 1).						y _ (d / z) * (pos at: 2).					].						^ x @ y.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/25/1999 15:59'!getPositionInPixels	"Returns the actor's position in pixels in the Squeak window"	| camera morph point x y frustum |	camera _ myWonderland getDefaultCamera.	morph _ camera getMorph.	point _ self getPositionInPicturePlane.	frustum _ camera getFrustum.	((point x) < 0) ifTrue: [			x _ (morph center x) - (((point x) / (frustum left)) * ((morph width) / 2))						]				ifFalse: [			x _ (morph center x) + (((point x) / (frustum right)) * ((morph width) / 2))						].	((point y) < 0) ifTrue: [			y _ (morph center y) + (((point y) / (frustum bottom)) * ((morph height) / 2))						]				ifFalse: [			y _ (morph center y) - (((point y) / (frustum top)) * ((morph height) / 2))						].	^ (x @ y) rounded.	! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/19/1999 14:45'!getSize	"Returns the scale factor of the actor"	| anArray meshSize |	meshSize _ self getBoundingBox extent.	anArray _ Array new: 3.	anArray at: 1 put: (meshSize x).	anArray at: 2 put: (meshSize y).	anArray at: 3 put: (meshSize z).	^ anArray.! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 3/1/1999 11:50'!getVisibility	"Returns the actor's visibility"	^ ((myMaterial ambientPart) alpha)! !!WonderlandActor methodsFor: 'get property' stamp: 'jsp 2/11/1999 10:12'!isHidden	"Returns true if the object is hidden."	^ hidden.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/19/1999 14:00'!hide	"Tell the object that it should not draw itself each frame"	(myWonderland getUndoStack) push: (UndoShowHide undoHideFor: self).	self setHidden: true.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 14:39'!setColor: newColor	"Set the actor's color"	 ^ (self setColor: newColor duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 13:58'!setColor: newColor duration: time	"Set the actor's color"	(time = rightNow) ifTrue: [		[ WonderlandVerifier VerifyColor: newColor ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what color to make ' , myName , ' because ', msg.				^ nil ].		self setColorRightNow: newColor undoable: true.		^ self. ].	^ (self setColor: newColor duration:time style: gently)! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 13:58'!setColor: newColor duration: time style: aStyle	"Set the actor's color"	| anim aColor |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyColor: newColor ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what color to make ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: time ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for changing the color of ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use for changing the color of ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	((newColor at: 1) isNumber)				ifTrue: [ aColor _ B3DColor4 red: (newColor at: 1) green: (newColor at: 2)										blue: (newColor at: 3) alpha: (myColor alpha) ]				ifFalse: [ aColor _ Color perform: newColor.						  aColor _ B3DColor4 red: (aColor red) green: (aColor green)										blue: (aColor blue) alpha: (myColor alpha) ].	anim _ AbsoluteAnimation new.	anim object: self			update: [:tColor | self setColorVector: tColor]			getStartState: [self getColorVector]			getEndState: [ aColor ]			style: aStyle			duration: time			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/24/1999 10:25'!setMesh: aMesh	"Sets the actor's mesh"	myMesh _ aMesh.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/12/1999 15:22'!setName: newName	"Sets the object's name"	myName _ newName.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/3/1999 17:44'!setPointOfView: aVector	"Sets the object's position and orientation"	^ self setPointOfView: aVector duration: 1.0 style: gently.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/3/1999 17:45'!setPointOfView: aVector asSeenBy: reference	"Sets the object's position and orientation"	^ self setPointOfView: aVector duration: 1.0 asSeenBy: reference style: gently.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:46'!setPointOfView: aVector asSeenBy: reference eachFrameFor: aLifetime	"Sets the object's position and orientation"	| positionVector rotationVector |	[ WonderlandVerifier VerifyPointOfView: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.			^ nil ].	( aVector isKindOf: WonderlandActor) ifTrue: [			myWonderland reportErrorToUser: 'Squeak does not allow you to use an Actor to specify the point of view when using asSeenBy.'.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not set the point of view for ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should keep this point of view because ', msg.			^ nil ].	positionVector _ Array new: 3.	positionVector at: 1 put: (aVector at: 1).	positionVector at: 2 put: (aVector at: 2).	positionVector at: 3 put: (aVector at: 3).	rotationVector _ Array new: 3.	rotationVector at: 1 put: (aVector at: 4).	rotationVector at: 2 put: (aVector at: 5).	rotationVector at: 3 put: (aVector at: 6).	myWonderland getUndoStack push: (UndoPOVChange for: self														from: (self getPointOfView)).	^ self doEachFrame: [ 							self moveToRightNow: positionVector undoable: false.							self turnToRightNow: rotationVector undoable: false.						]			for: aLifetime.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:46'!setPointOfView: aVector asSeenBy: reference eachFrameUntil: aCondition	"Sets the object's position and orientation"	| positionVector rotationVector |	[ WonderlandVerifier VerifyPointOfView: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.			^ nil ].	( aVector isKindOf: WonderlandActor) ifTrue: [			myWonderland reportErrorToUser: 'Squeak does not allow you to use an Actor to specify the point of view when using asSeenBy.'.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not set the point of view for ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long ' , myName , ' should keep this point of view because ', msg.			^ nil ].	positionVector _ Array new: 3.	positionVector at: 1 put: (aVector at: 1).	positionVector at: 2 put: (aVector at: 2).	positionVector at: 3 put: (aVector at: 3).	rotationVector _ Array new: 3.	rotationVector at: 1 put: (aVector at: 4).	rotationVector at: 2 put: (aVector at: 5).	rotationVector at: 3 put: (aVector at: 6).	myWonderland getUndoStack push: (UndoPOVChange for: self														from: (self getPointOfView)).	^ self doEachFrame: [ 							self moveToRightNow: positionVector undoable: false.							self turnToRightNow: rotationVector undoable: false.						]			until: aCondition.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:27'!setPointOfView: aVector duration: aDuration	"Sets the object's position and orientation"	| positionVector rotationVector |	((aDuration = rightNow) or: [ aDuration = eachFrame ]) ifTrue: [		[ WonderlandVerifier VerifyPointOfView: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.				^ nil ].		(aVector isKindOf: WonderlandActor)			ifTrue: [						positionVector _ aVector.						rotationVector _ aVector.					]			ifFalse: [						positionVector _ Array new: 3.						positionVector at: 1 put: (aVector at: 1).						positionVector at: 2 put: (aVector at: 2).						positionVector at: 3 put: (aVector at: 3).						rotationVector _ Array new: 3.						rotationVector at: 1 put: (aVector at: 4).						rotationVector at: 2 put: (aVector at: 5).						rotationVector at: 3 put: (aVector at: 6).					].			myWonderland getUndoStack push: (UndoPOVChange for: self														from: (self getPointOfView)).			(aDuration = eachFrame) ifTrue: [				^ self doEachFrame: [ 										self moveToRightNow: positionVector undoable: false.										self turnToRightNow: rotationVector undoable: false.									]											].			self moveToRightNow: positionVector undoable: false.			self turnToRightNow: rotationVector undoable: false.			^ self ].	^ self setPointOfView: aVector duration: aDuration style: gently.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:46'!setPointOfView: aVector duration: aDuration asSeenBy: reference	"Sets the object's position and orientation"	| positionVector rotationVector |	((aDuration = rightNow) or: [ aDuration = eachFrame ]) ifTrue: [			[ WonderlandVerifier VerifyPointOfView: aVector ]				ifError: [ :msg :rcvr |					myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.					^ nil ].			( aVector isKindOf: WonderlandActor) ifTrue: [					myWonderland reportErrorToUser: 'Squeak does not allow you to use an Actor to specify the point of view when using asSeenBy.'.					^ nil ].			[ WonderlandVerifier VerifyReferenceFrame: reference ]				ifError: [ :msg :rcvr |					myWonderland reportErrorToUser:						'Squeak can not set the point of view for ' , myName , ' relative to ' , (reference asString) , ' because ', msg.					^ nil ].			positionVector _ Array new: 3.			positionVector at: 1 put: (aVector at: 1).			positionVector at: 2 put: (aVector at: 2).			positionVector at: 3 put: (aVector at: 3).			rotationVector _ Array new: 3.			rotationVector at: 1 put: (aVector at: 4).			rotationVector at: 2 put: (aVector at: 5).			rotationVector at: 3 put: (aVector at: 6).			myWonderland getUndoStack push: (UndoPOVChange for: self														from: (self getPointOfView)).			(aDuration = eachFrame) ifTrue: [				^ self doEachFrame: [ 										self moveToRightNow: positionVector undoable: false.										self turnToRightNow: rotationVector undoable: false.									]											].			self moveToRightNow: positionVector asSeenBy: reference undoable: false.			self turnToRightNow: rotationVector asSeenBy: reference undoable: false.			^ self ].	^ self setPointOfView: aVector duration: aDuration asSeenBy: reference style: gently.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:46'!setPointOfView: aVector duration: aDuration asSeenBy: reference style: aStyle	"Sets the object's position and orientation"	| positionVector rotationVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyPointOfView: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.			^ nil ].	( aVector isKindOf: WonderlandActor) ifTrue: [			myWonderland reportErrorToUser: 'Squeak does not allow you to use an Actor to specify the point of view when using asSeenBy.'.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for changing the point of view for ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyReferenceFrame: reference ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak can not set the point of view for ' , myName , ' relative to ' , (reference asString) , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use for changing the point of view for ' , myName , ' because ', msg.			^ nil ].	positionVector _ Array new: 3.	positionVector at: 1 put: (aVector at: 1).	positionVector at: 2 put: (aVector at: 2).	positionVector at: 3 put: (aVector at: 3).	rotationVector _ Array new: 3.	rotationVector at: 1 put: (aVector at: 4).	rotationVector at: 2 put: (aVector at: 5).	rotationVector at: 3 put: (aVector at: 6).	^ myWonderland doTogether: { self moveTo: positionVector duration: aDuration												asSeenBy: reference style: aStyle.								  self turnTo: rotationVector duration: aDuration												asSeenBy: reference style: aStyle }.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:19'!setPointOfView: aVector duration: aDuration style: aStyle	"Sets the object's position and orientation"	| positionVector rotationVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyPointOfView: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for changing the point of view for ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use for changing the point of view for ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so built the animation"	(aVector isKindOf: WonderlandActor)		ifTrue: [					positionVector _ aVector.					rotationVector _ aVector.				]		ifFalse: [					positionVector _ Array new: 3.					positionVector at: 1 put: (aVector at: 1).					positionVector at: 2 put: (aVector at: 2).					positionVector at: 3 put: (aVector at: 3).					rotationVector _ Array new: 3.					rotationVector at: 1 put: (aVector at: 4).					rotationVector at: 2 put: (aVector at: 5).					rotationVector at: 3 put: (aVector at: 6).				].	^ myWonderland doTogether: { self moveTo: positionVector duration: aDuration style: aStyle.								self turnTo: rotationVector duration: aDuration style: aStyle }.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:24'!setPointOfView: aVector eachFrameFor: aLifetime	"Sets the object's position and orientation"	| positionVector rotationVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyPointOfView: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aLifetime ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should keep this point of view because ', msg.			^ nil ].	(aVector isKindOf: WonderlandActor)			ifTrue: [						positionVector _ aVector.						rotationVector _ aVector.					]			ifFalse: [						positionVector _ Array new: 3.						positionVector at: 1 put: (aVector at: 1).						positionVector at: 2 put: (aVector at: 2).						positionVector at: 3 put: (aVector at: 3).						rotationVector _ Array new: 3.						rotationVector at: 1 put: (aVector at: 4).						rotationVector at: 2 put: (aVector at: 5).						rotationVector at: 3 put: (aVector at: 6).					].	myWonderland getUndoStack push: (UndoPOVChange for: self														from: (self getPointOfView)).	^ self doEachFrame: [ 							self moveToRightNow: positionVector undoable: false.							self turnToRightNow: rotationVector undoable: false.						]			for: aLifetime.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:25'!setPointOfView: aVector eachFrameUntil: aCondition	"Sets the object's position and orientation"	| positionVector rotationVector |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyPointOfView: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what point of view to assign ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long ' , myName , ' should keep this point of view because ', msg.			^ nil ].	(aVector isKindOf: WonderlandActor)			ifTrue: [						positionVector _ aVector.						rotationVector _ aVector.					]			ifFalse: [						positionVector _ Array new: 3.						positionVector at: 1 put: (aVector at: 1).						positionVector at: 2 put: (aVector at: 2).						positionVector at: 3 put: (aVector at: 3).						rotationVector _ Array new: 3.						rotationVector at: 1 put: (aVector at: 4).						rotationVector at: 2 put: (aVector at: 5).						rotationVector at: 3 put: (aVector at: 6).					].	myWonderland getUndoStack push: (UndoPOVChange for: self														from: (self getPointOfView)).	^ self doEachFrame: [ 							self moveToRightNow: positionVector undoable: false.							self turnToRightNow: rotationVector undoable: false.						]			until: aCondition.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/4/1999 16:07'!setSize: aVector	"Sets the object's position and orientation"	^ (self setSize: aVector duration: 1.0 style: gently).! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:07'!setSize: aVector duration: time	"Sets the object's position and orientation"	(time = rightNow) ifTrue: [		[ WonderlandVerifier VerifyTriple: aVector ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what size to make ' , myName , ' because ', msg.				^ nil ].		self setSizeRightNow: aVector undoable: true.		^ self. ].	^ (self setSize: aVector duration:time style: gently).! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/19/1999 15:21'!setSize: aVector duration: time style: aStyle	"Sets the object's position and orientation"	| meshSize |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyTriple: aVector ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what size to make ' , myName , ' because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	meshSize _ self getBoundingBox extent.	"Now make sure we don't accidentally divide by zero"	((meshSize x) = 0) ifTrue: [ aVector at: 1 put: 1.							    meshSize x: 1 ].	((meshSize y) = 0) ifTrue: [ aVector at: 2 put: 1.							    meshSize y: 1 ].	((meshSize z) = 0) ifTrue: [ aVector at: 3 put: 1.							    meshSize z: 1 ].	^ self resizeTopToBottom: (aVector at: 2) / (meshSize y)			leftToRight: (aVector at: 1) / (meshSize x)			frontToBack: (aVector at: 3) / (meshSize z)			duration: time			style: aStyle.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/19/1999 16:19'!setTexture: textureFile	"Sets the object's texture"	| dict |	(myWonderland getUndoStack) push: (UndoTextureChange for: self from: myTexture).	(textureFile notNil) 	ifTrue: [			dict _ myWonderland getSharedTextureDict.			myTexture _ dict at: textureFile				ifAbsent: [							myTexture _ (Form fromBMPFileNamed: textureFile) asTexture.							myTexture flipVertically.							myTexture wrap: true.							myTexture interpolate: true.							myTexture envMode: 0.							dict at: textureFile put: myTexture.							].								]						ifFalse: [ myTexture _ nil  ].	myChildren do: [:child | (child isPart) ifTrue: [ child setTexturePointer: myTexture ] ].! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/1/1999 14:15'!setVisibility: newVisibility	"Sets the current object's visibility"	^ (self setVisibility: newVisibility duration: 1.0			style: gently).! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:01'!setVisibility: newVisibility duration: time	"Sets the current object's visibility"	(time = rightNow) ifTrue: [		[ WonderlandVerifier Verify0to1Number: newVisibility ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what visibility to make ' , myName , ' because ', msg.				^ nil ].		self setVisibilityRightNow: newVisibility undoable: true.		^ self. ].	^ (self setVisibility: newVisibility duration: time			style: gently).! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/18/1999 15:00'!setVisibility: newVisibility duration: time style: aStyle	"Sets the current object's visibility"	| anim |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier Verify0to1Number: newVisibility ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what visibility to make ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: time ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for changing the visibility of ' , myName , ' because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use for changing the visibility of ' , myName , ' because ', msg.			^ nil ].	anim _ AbsoluteAnimation new.	anim object: self			update: [:tColor | self setColorVector: tColor]			getStartState: [self getColorVector]			getEndState: [B3DColor4 red: (myColor red) green: (myColor green)						blue: (myColor blue) alpha: newVisibility]			style: aStyle			duration: time			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'set property' stamp: 'jsp 3/19/1999 14:01'!show	"Tell the object that it should draw itself each frame"	(myWonderland getUndoStack) push: (UndoShowHide undoShowFor: self).	self setHidden: false.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/1/1999 13:27'!getColorVector	"Returns the actor's color/alpha vector"	^ myColor.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/24/1999 16:15'!getComposite	"Returns the actor's composite matrix"	^ composite.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/22/1999 14:30'!getMatrixFromRoot	"Returns the composite transformation matrix from the root down to this instance"	^ (myParent getMatrixFromRoot) composeWith: composite.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/22/1999 14:32'!getMatrixToRoot	"Returns the composite transformation matrix from this instance up to the root"	^ ((myParent getMatrixFromRoot) composeWith: composite) inverseTransformation.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/29/1999 14:44'!getPointAtMatrix: target	"create a matrix such that the actor looks at the target using the upDirection"	| aVector m1 m2 |	m1 _ B3DMatrix4x4 identity.	m2 _ B3DMatrix4x4 identity.	"Calculate the vector to look along"	(target isKindOf: WonderlandActor)		ifTrue: [ aVector _ (target getMatrixFromRoot translation) -								(self getMatrixFromRoot translation) ]		ifFalse: [ (target isKindOf: Point)					ifTrue: [							aVector _ ((myWonderland getDefaultCamera)								transformScreenPointToScenePoint: target atDepthOf: self).							aVector _ B3DVector3 x: (aVector at: 1) y: (aVector at: 2)												z: (aVector at: 3).							aVector _ aVector - (self getMatrixFromRoot translation).							]					ifFalse: [							aVector _ (B3DVector3 x: (target at: 1) y: (target at: 2)									z: (target at: 3)) - (self getMatrixFromRoot translation).							].				].	"Calculate the rotation around the z-axis"	((aVector z) = 0) ifTrue: [ ((aVector x ) > 0) ifTrue: [ m1 rotationAroundY: 90 ]												ifFalse: [ ((aVector x) = 0) 													ifTrue: [ m1 rotationAroundY: 0 ]													ifFalse: [ m1 rotationAroundY: -90 ] ]							]					ifFalse: [ ((aVector z) > 0)									ifTrue: [ m1 rotationAroundY:										(((aVector x) / (aVector z)) arcTan radiansToDegrees) ]									ifFalse: [ m1 rotationAroundY: (180 +										(((aVector x) / (aVector z)) arcTan radiansToDegrees)) ]							].	((aVector length) = 0) ifFalse: [		m2 rotationAroundX: (((aVector y) / (aVector length)) arcSin radiansToDegrees negated) ].	^ (myParent getMatrixToRoot) composeWith: (m1 composeWith: m2).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/10/1999 16:45'!getPositionVector	"Returns the current position as a vector."	^ (composite translation).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/24/1999 11:11'!getRotationVector	"Returns the current rotation as a vector."	^ (composite rotation).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/24/1999 14:34'!getSizeVector	"Returns the object's current size as a vector"	^ (B3DVector3 x: (scaleMatrix a11) y: (scaleMatrix a22) z: (scaleMatrix a33)).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/12/1999 10:13'!loadMeshFromFile: meshFile	"Load this object's mesh from the specified file"	| dict words |	dict _ myWonderland getSharedMeshDict.	myMesh _ dict at: meshFile				ifAbsent: [							words _ (meshFile findTokens: #.).							((words last) = 'vfb') ifTrue: [								myMesh _ WonderlandMesh fromVFBFile: meshFile ].							((words last) = 'obj') ifTrue: [								myMesh _ WonderlandMesh fromOBJFile: meshFile ].							dict at: meshFile put: myMesh.						].! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/23/1999 12:03'!makeVectorFromDistance: aDistance andDirection: aDirection	"Generates the vector the object should move along using the specified direction"	| a3DVector |	(aDirection = right) ifTrue: [a3DVector _ B3DVector3 x: aDistance y: 0 z: 0]		ifFalse: [(aDirection = left) ifTrue: [a3DVector _ B3DVector3 x: -1 * aDistance y:0 z:0]		ifFalse: [(aDirection = up) ifTrue: [a3DVector _ B3DVector3 x: 0 y: aDistance z:0]		ifFalse: [(aDirection = down) ifTrue: [a3DVector _ B3DVector3 x: 0 y: -1 * aDistance z:0]		ifFalse: [(aDirection = forward) ifTrue: [a3DVector _ B3DVector3 x: 0 y: 0 z: aDistance]		ifFalse: [((aDirection = back) or: [aDirection = #backward])					 ifTrue: [a3DVector _ B3DVector3 x: 0 y: 0 z: -1 * aDistance]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].	^ a3DVector.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/18/1999 10:18'!moveRightNow: aDirection distance: aDistance asSeenBy: reference undoable: isUndoable	"Move this object in the specified direction instantaneously"	| a3DVector aMatrix newComposite |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoPositionChange for: self from: (self getPosition)).						].	[ a3DVector _ self makeVectorFromDistance: aDistance andDirection: aDirection. ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak does not know how to move ' , myName , ' in that direction.'.			^ nil ].	aMatrix _ B3DMatrix4x4 identity translation: a3DVector.	newComposite _ (reference getMatrixToRoot) composeWith: (self getMatrixFromRoot).	composite _ (((myParent getMatrixToRoot)							composeWith: (reference getMatrixFromRoot))							composeWith: aMatrix)							composeWith: newComposite.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/18/1999 10:18'!moveRightNow: aDirection distance: aDistance undoable: isUndoable	"Move this object in the specified direction instantaneously"	| a3DVector aMatrix |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoPositionChange for: self from: (self getPosition)).						].	[ a3DVector _ self makeVectorFromDistance: aDistance andDirection: aDirection. ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak does not know how to move ' , myName , ' in that direction.'.			^ nil ].	aMatrix _ B3DMatrix4x4 identity translation: a3DVector.	composite _ composite composeWith: aMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 12:42'!moveToRightNow: aVector asSeenBy: reference undoable: isUndoable	"Move this object in the specified direction instantaneously"	| pos aMatrix newComposite |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoPositionChange for: self from: (self getPosition)).						].	aMatrix _ B3DMatrix4x4 identity.	pos _ self getPosition: reference.	((aVector at: 1) = asIs) ifFalse: [ pos at: 1 put: (aVector at: 1) ].	((aVector at: 2) = asIs) ifFalse: [ pos at: 2 put: (aVector at: 2) ].	((aVector at: 3) = asIs) ifFalse: [ pos at: 3 put: (aVector at: 3) ].	aMatrix translation: (B3DVector3 x: (pos at: 1) y: (pos at: 2) z: (pos at: 3)).	newComposite _ (myParent getMatrixToRoot) composeWith: (reference getMatrixFromRoot).	newComposite _ newComposite composeWith: aMatrix.		newComposite translation.	self setPositionVector: (newComposite translation).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 12:39'!moveToRightNow: aVector undoable: isUndoable	"Move this object in the specified direction instantaneously"	| pos |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoPositionChange for: self from: (self getPosition)).						].	(aVector isKindOf: WonderlandActor)		ifTrue: [ pos _ aVector getPositionVector ]		ifFalse: [ pos _ self getPositionVector.				  ((aVector at: 1) = asIs) ifFalse: [pos x: (aVector at: 1) ].				  ((aVector at: 2) = asIs) ifFalse: [pos y: (aVector at: 2) ].				  ((aVector at: 3) = asIs) ifFalse: [pos z: (aVector at: 3) ].				].	self setPositionVector: pos.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 16:02'!placeRightNow: aLocation object: aTarget undoable: isUndoable	"Instantaneously move the object to the specified place."	 | selfPos selfBBox selfLBB selfRUF objBBox objLBB objRUF pos |	selfBBox _ self getBoundingBox: aTarget.	selfLBB _ selfBBox origin.	selfRUF _ selfBBox corner.	objBBox _ aTarget getBoundingBox.	objLBB _ objBBox origin.	objRUF _ objBBox corner.	selfPos _ self getPosition: aTarget.	((aLocation = onTopOf) or: [ aLocation = above])	ifTrue: [				pos _ { 0. (objRUF y) + ((selfPos at: 2) - (selfLBB y)). 0}			] 	ifFalse: [	((aLocation = onBottomOf) or: [ (aLocation = beneath) or: [ aLocation = below ] ])	ifTrue: [				pos _ { 0. (objLBB y) - ((selfRUF y) - (selfPos at: 2)). 0}			]	ifFalse: [	(aLocation = toLeftOf)	ifTrue: [				pos _ { (objLBB x) - ((selfRUF x) - (selfPos at: 1)). 0. 0 }			]	ifFalse: [	(aLocation = toRightOf)	ifTrue: [				pos _ { (objRUF x) + ((selfPos at: 1) - (selfLBB x)). 0. 0 }			]	ifFalse: [	(aLocation = inFrontOf)	ifTrue: [				pos _ { 0. 0. (objRUF z) + ((selfPos at: 3) - (selfLBB z)) }			]	ifFalse: [	((aLocation = inBackOf) or: [ aLocation = behind])	ifTrue: [				pos _ { 0. 0. (objLBB z) - ((selfRUF z) - (selfPos at:3)) }			]	ifFalse: [	(aLocation = onCeilingOf)	ifTrue: [				pos _ { 0. (objRUF y) - ((selfRUF y) - (selfPos at:2)). 0}			]	ifFalse: [	(aLocation = onFloorOf)	ifTrue: [				pos _ { 0. (objLBB y) + ((selfPos at: 2) - (selfLBB y)). 0}			]	ifFalse: [ self error: 'Unrecognized target surface' ]]]]]]]].	self moveToRightNow: pos asSeenBy: aTarget undoable: isUndoable.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 15:57'!pointAtRightNow: aTarget undoable: isUndoable	"Turn this object to the specified orientation instantaneously"	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoRotationChange for: self from: (self getAngles)).						].	self setRotationMatrix: (self getPointAtMatrix: aTarget).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 4/1/1999 17:52'!reparentTo: anObject	"Make this actor a child of the specified object."	| newComposite |	"First break ties with the current parent"	myParent removeChild: self.	"Figure out the new composite transformation matrix"	newComposite _ anObject getMatrixToRoot.	newComposite _ newComposite composeWith: (self getMatrixFromRoot).		"Now build ties with the new parent"	anObject addChild: self.	myParent _ anObject.	composite _ newComposite.	"Now update the actor browser"	myWonderland getEditor updateActorBrowser.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 17:01'!resizeRightNow: aVector undoable: isUndoable	"Set this object's size instantaneously"	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).						].	self scaleByVector: aVector.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/18/1999 10:40'!rollRightNow: aDirection numberOfTurns: numTurns asSeenBy: reference undoable: isUndoable	"Turn the object instantaneously the specified number of turns in the specified direction"	| tMatrix degrees  newMatrix |	tMatrix _ B3DMatrix4x4 identity.	degrees _ 360 * numTurns.	(isUndoable = true) ifTrue: [		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).						].	(aDirection = left) ifTrue: [ tMatrix rotationAroundZ: degrees ]	ifFalse: [(aDirection = right) ifTrue: [ tMatrix rotationAroundZ: (degrees negated) ]								ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to roll ' , myName , ' ', (aDirection asString) , '.'.										^ nil ]].	newMatrix _ reference getMatrixToRoot.	newMatrix _ newMatrix composeWith: (self getMatrixFromRoot).	composite _ (((myParent getMatrixToRoot) composeWith: (reference getMatrixFromRoot))											composeWith: tMatrix)											composeWith: newMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/18/1999 10:40'!rollRightNow: aDirection numberOfTurns: numTurns undoable: isUndoable	"Turn the object instantaneously the specified number of turns in the specified direction"	| tMatrix degrees  |	tMatrix _ B3DMatrix4x4 identity.	degrees _ 360 * numTurns.	(isUndoable = true) ifTrue: [		myWonderland getUndoStack push: (UndoRotationChange for: self from: (self getAngles)).						].	(aDirection = left) ifTrue: [ tMatrix rotationAroundZ: degrees ]		ifFalse: [(aDirection = right) ifTrue: [ tMatrix rotationAroundZ: (degrees negated) ]									ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to roll ' , myName , ' ', (aDirection asString) , '.'.											^ nil ]].	self rotateByMatrix: tMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/10/1999 16:46'!rotateByMatrix: aMatrix	"Rotate the object by composing its rotation matrix with the given matrix."	composite _ composite composeWith: aMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/11/1999 08:57'!scaleByMatrix: aMatrix	"Scale the object by composing its scale matrix with the given matrix."	scaleMatrix _ scaleMatrix composeWith: aMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/19/1999 11:50'!scaleByVector: aVector	"Scale the object by the given vector."	| aMatrix |	aMatrix _ B3DMatrix4x4 identity.	"Scale my matrix"	aMatrix scalingX: (aVector x) y: (aVector y) z: (aVector z).	scaleMatrix _ scaleMatrix composeWith: aMatrix.	"Now scale my parts"	myChildren do: [:child | (child isPart) ifTrue: [								child setPositionVector: (child getPositionVector) * aVector.								child scaleByVector: aVector												].					].! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 16:33'!setColorRightNow: newColor undoable: isUndoable	"Change this instance's color instantaneously"	| aColor |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoColorChange for: self from: (self getColor)) ].	((newColor at: 1) isNumber)				ifTrue: [ aColor _ B3DColor4 red: (newColor at: 1) green: (newColor at: 2)										blue: (newColor at: 3) alpha: (myColor alpha) ]				ifFalse: [ aColor _ Color perform: newColor.						  aColor _ B3DColor4 red: (aColor red) green: (aColor green)										blue: (aColor blue) alpha: (myColor alpha) ].	self setColorVector: aColor.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/1/1999 13:27'!setColorVector: aColor	"Instaneously sets the object's color/alpha vector and copies it down the object tree for all objects that are parts of this object"	"Set our color"	myColor _ aColor.	"Set the color of our parts"	myChildren do: [:child | (child isPart) ifTrue: [child setColorVector: aColor] ].! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/12/1999 16:38'!setComposite: newComposite	"Sets the actor's composite matrix"	composite _ newComposite.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/19/1999 13:55'!setHidden: aBoolean	"Set the object's hidden status (including its parts)"	hidden _ aBoolean.	"Set the show/hide status of our parts"	myChildren do: [:child | (child isPart) ifTrue: [child setHidden: aBoolean] ].! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/10/1999 16:46'!setPositionVector: aVector	"Instantaneously sets the actor's current position"	composite translation: aVector.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/25/1999 09:43'!setRotationMatrix: aMatrix	"Rotate the object by blamming the rotation component of its matrix with the given matrix."	composite a11: (aMatrix a11).	composite a12: (aMatrix a12).	composite a13: (aMatrix a13).	composite a21: (aMatrix a21).	composite a22: (aMatrix a22).	composite a23: (aMatrix a23).	composite a31: (aMatrix a31).	composite a32: (aMatrix a32).	composite a33: (aMatrix a33).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 2/24/1999 09:54'!setRotationVector: aVector	"Instantaneously blam the actor's rotation"	composite rotation: aVector.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/19/1999 16:07'!setSizeRightNow: aVector undoable: isUndoable	"Set this object's size instantaneously"	| meshSize |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoSizeChange for: self from: (self getSize)).						].	meshSize _ self getBoundingBox extent.	"Now make sure we don't accidentally divide by zero"	((meshSize x) = 0) ifTrue: [ aVector at: 1 put: 1.							    meshSize x: 1 ].	((meshSize y) = 0) ifTrue: [ aVector at: 2 put: 1.							    meshSize y: 1 ].	((meshSize z) = 0) ifTrue: [ aVector at: 3 put: 1.							    meshSize z: 1 ].	^ self scaleByVector: (B3DVector3 x: ((aVector at: 1) / (meshSize x))									y: ((aVector at: 2) / (meshSize y))									z: ((aVector at: 3) / (meshSize z)) ).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/19/1999 16:15'!setTexturePointer: texture	"Sets the object's texture"	myTexture _ texture.	myChildren do: [:child | (child isPart) ifTrue: [ child setTexturePointer: texture ] ].! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 16:42'!setVisibilityRightNow: newVisibility undoable: isUndoable	"Change this instance's visibility instantaneously"	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoVisibilityChange for: self																 from: (self getVisibility)) ].	self setColorVector: (B3DColor4 red: (myColor red) green: (myColor green)						blue: (myColor blue) alpha: newVisibility).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 15:25'!turnRightNow: aDirection numberOfTurns: numTurns asSeenBy: reference undoable: isUndoable	"Turn the object instantaneously the specified number of turns in the specified direction"	| tMatrix degrees  newMatrix |	tMatrix _ B3DMatrix4x4 identity.	degrees _ 360 * numTurns.	(isUndoable = true) ifTrue: [		myWonderland getUndoStack push: (UndoPOVChange for: self from: (self getPointOfView)).						].	(aDirection = right) ifTrue: [ tMatrix rotationAroundY: degrees ]		ifFalse: [(aDirection = left) ifTrue: [ tMatrix rotationAroundY: (degrees negated) ]		ifFalse: [(((aDirection = up) or: [aDirection = back]) or: [aDirection = backward])			ifTrue: [ tMatrix rotationAroundX: (degrees negated) ]		ifFalse: [((aDirection = down) or: [aDirection = forward]) ifTrue: [			tMatrix rotationAroundX: degrees ]		ifFalse: [(aDirection = ccw) ifTrue: [ tMatrix rotationAroundZ: degrees ]		ifFalse: [(aDirection = cw) ifTrue: [ tMatrix rotationAroundZ: (degrees negated) ]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].	newMatrix _ reference getMatrixToRoot.	newMatrix _ newMatrix composeWith: (self getMatrixFromRoot).	composite _ (((myParent getMatrixToRoot) composeWith: (reference getMatrixFromRoot))											composeWith: tMatrix)											composeWith: newMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 14:59'!turnRightNow: aDirection numberOfTurns: numTurns undoable: isUndoable	"Turn the object instantaneously the specified number of turns in the specified direction"	| tMatrix degrees  |	tMatrix _ B3DMatrix4x4 identity.	degrees _ 360 * numTurns.	(isUndoable = true) ifTrue: [		myWonderland getUndoStack push: (UndoRotationChange for: self from: (self getAngles)).						].	(aDirection = right) ifTrue: [ tMatrix rotationAroundY: degrees ]		ifFalse: [(aDirection = left) ifTrue: [ tMatrix rotationAroundY: (degrees negated) ]		ifFalse: [(((aDirection = up) or: [aDirection = back]) or: [aDirection = backward])			ifTrue: [ tMatrix rotationAroundX: (degrees negated) ]		ifFalse: [((aDirection = down) or: [aDirection = forward]) ifTrue: [			tMatrix rotationAroundX: degrees ]		ifFalse: [(aDirection = ccw) ifTrue: [ tMatrix rotationAroundZ: degrees ]		ifFalse: [(aDirection = cw) ifTrue: [ tMatrix rotationAroundZ: (degrees negated) ]		ifFalse: [ self error: 'Unrecognized direction' ]]]]]].	self rotateByMatrix: tMatrix.! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 15:48'!turnToRightNow: aVector asSeenBy: reference undoable: isUndoable	"Turn this object to the specified orientation instantaneously"	| m angles newComposite |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoRotationChange for: self from: (self getAngles)).						].	m _ B3DMatrix4x4 identity.	angles _ self getAngles: reference.	((aVector at: 1) = asIs) ifFalse: [ angles at: 1 put: (aVector at: 1) ].	((aVector at: 2) = asIs) ifFalse: [ angles at: 2 put: (aVector at: 2) ].	((aVector at: 3) = asIs) ifFalse: [ angles at: 3 put: (aVector at: 3) ].	m rotation: (B3DVector3 x: (angles at: 1) y: (angles at: 2) z: (angles at: 3)).	newComposite _ (myParent getMatrixToRoot) composeWith: (reference getMatrixFromRoot).	self setRotationMatrix: (newComposite composeWith: m).! !!WonderlandActor methodsFor: 'private' stamp: 'jsp 3/8/1999 15:43'!turnToRightNow: aVector undoable: isUndoable	"Turn this object to the specified orientation instantaneously"	| m angles |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoRotationChange for: self from: (self getAngles)).						].	m _ B3DMatrix4x4 identity.	(aVector isKindOf: WonderlandActor)		ifTrue: [ angles _ aVector getAngles: myParent.				  m rotation: (B3DVector3 x: (angles at: 1) y: (angles at: 2) z: (angles at: 3)).				]		ifFalse: [ angles _ self getRotationVector.				  ((aVector at: 1) = asIs) ifFalse: [ angles x: (aVector at: 1) ].				  ((aVector at: 2) = asIs) ifFalse: [ angles y: (aVector at: 2) ].				  ((aVector at: 3) = asIs) ifFalse: [ angles z: (aVector at: 3) ].				  m rotation: angles.				].	self setRotationMatrix: m.! !!WonderlandActor methodsFor: 'do-ing' stamp: 'jsp 3/18/1999 17:07'!do: aBlock	"Build an animation that causes the object to execute the block"	| anim |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyZeroArgumentBlock: aBlock ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not make ' , myName , ' do what you asked because ', msg.			^ nil ].	anim _ RelativeAnimation new.	anim object: self		update: [:tmp | aBlock value ]		getStartState: [ Interpolateable value: 0 ]		getEndState: [ 1 ]		getReverseState: [ 1 ]		style: abruptly		duration: 0		undoable: false		inWonderland: myWonderland.	^ anim.! !!WonderlandActor methodsFor: 'do-ing' stamp: 'jsp 3/30/1999 11:38'!doEachFrame: aBlock	"Build an action that causes the object to execute the block every frame"	| newAction |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyZeroArgumentBlock: aBlock ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not make ' , myName , ' do what you asked because ', msg.			^ nil ].	newAction _ Action do: aBlock toObject: self inScheduler: (myWonderland getScheduler).	(myWonderland getUndoStack) push:			(UndoByStopping new: newAction in: (myWonderland getUndoStack)).	^ newAction.! !!WonderlandActor methodsFor: 'do-ing' stamp: 'jsp 3/30/1999 11:38'!doEachFrame: aBlock for: aDuration	"Build an action that causes the object to execute the block every frame for the specified amount of time"	| newAction |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyZeroArgumentBlock: aBlock ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not make ' , myName , ' do what you asked because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNonNegativeNumber: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine how long ' , myName , ' should do this because ', msg.			^ nil ].	newAction _ Action do: aBlock eachframefor: aDuration toObject: self						inScheduler: (myWonderland getScheduler).	(myWonderland getUndoStack) push:			(UndoByStopping new: newAction in: (myWonderland getUndoStack)).	^ newAction.! !!WonderlandActor methodsFor: 'do-ing' stamp: 'jsp 3/30/1999 11:39'!doEachFrame: aBlock until: aCondition	"Build an action that causes the object to execute the block every frame until the specified condition is true"	| newAction |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyZeroArgumentBlock: aBlock ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not make ' , myName , ' do what you asked because ', msg.			^ nil ].	[ WonderlandVerifier VerifyCondition: aCondition ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine for how long ' , myName , ' should do this because ', msg.			^ nil ].	newAction _ Action do: aBlock eachframeuntil: aCondition toObject: self						inScheduler: (myWonderland getScheduler).	(myWonderland getUndoStack) push:			(UndoByStopping new: newAction in: (myWonderland getUndoStack)).	^ newAction.! !!WonderlandActor methodsFor: 'animated state' stamp: 'jsp 3/9/1999 16:18'!getActions	"Return the actions currently affecting this object"	^ (myWonderland getScheduler) getActionsFor: self.! !!WonderlandActor methodsFor: 'animated state' stamp: 'jsp 3/9/1999 16:18'!getAnimations	"Return the animations currently affecting this object"	^ (myWonderland getScheduler) getAnimationsFor: self.! !!WonderlandActor methodsFor: 'animated state' stamp: 'jsp 3/15/1999 16:15'!pause	"Pause any actions and animations associated with this object"	| scheduler |	scheduler _ myWonderland getScheduler.	(scheduler getAnimationsFor: self) do: [:anim | anim pause ].	(scheduler getActionsFor: self) do: [:action | action pause ].	myChildren do: [:child | (child isPart) ifTrue: [ child pause ] ].! !!WonderlandActor methodsFor: 'animated state' stamp: 'jsp 3/15/1999 16:15'!resume	"Resume any actions and animations associated with this object"	| scheduler |	scheduler _ myWonderland getScheduler.	(scheduler getAnimationsFor: self) do: [:anim | anim resume ].	(scheduler getActionsFor: self) do: [:action | action resume ].	myChildren do: [:child | (child isPart) ifTrue: [ child resume ] ].! !!WonderlandActor methodsFor: 'animated state' stamp: 'jsp 3/15/1999 16:15'!stop	"Stop any actions and animations associated with this object"	| scheduler |	scheduler _ myWonderland getScheduler.	(scheduler getAnimationsFor: self) do: [:anim | anim stop ].	(scheduler getActionsFor: self) do: [:action | action stop ].	myChildren do: [:child | (child isPart) ifTrue: [ child stop ] ].! !!WonderlandActor class methodsFor: 'instance creation' stamp: 'jsp 3/10/1999 16:14'!createFor: aWonderland	"Create a new instance for this Wonderland."	^ super new initializeFor: aWonderland.! !!WonderlandActorBrowser reorganize!('initialize-release' initializeWith:)('accessing' getMorph)('actor list functions' actorMenu:)('actor menu functions' pass)('actor list management' actorList actorListIndex actorListIndex: updateActorList)!!WonderlandActorBrowser methodsFor: 'initialize-release' stamp: 'jsp 4/1/1999 17:49'!initializeWith: aWonderland	"Initialize this instance."	myWonderland _ aWonderland.	actorListIndex _ 0.	myListMorph _ (PluggableListMorph on: self list: #actorList						selected: #actorListIndex changeSelected: #actorListIndex:						menu: #actorMenu: keystroke: #systemCatListKey:from:).	myListMorph name: 'Actors'.	myListMorph scrollBarOnLeft: false.	myListMorph extent: 400@200.	myListMorph color: (Color r: 0.815 g: 0.972 b: 0.878).! !!WonderlandActorBrowser methodsFor: 'accessing' stamp: 'jsp 4/1/1999 16:57'!getMorph	"Return my morph"	^ myListMorph.! !!WonderlandActorBrowser methodsFor: 'actor list functions' stamp: 'jsp 4/2/1999 12:21'!actorMenu: aMenu^ aMenu addList: { {'testing'. #pass}. {'one two'. #pass}}.! !!WonderlandActorBrowser methodsFor: 'actor menu functions' stamp: 'jsp 4/2/1999 12:21'!pass	! !!WonderlandActorBrowser methodsFor: 'actor list management' stamp: 'jsp 4/1/1999 17:53'!actorList	"Returns a list of actors in the scene"	| scene |	scene _ myWonderland getScene.	^ { scene getName } , (scene appendChildrenNamesTo: '    ').! !!WonderlandActorBrowser methodsFor: 'actor list management' stamp: 'jsp 4/1/1999 16:48'!actorListIndex	"Return the index of the currently selected actor"	^ actorListIndex.! !!WonderlandActorBrowser methodsFor: 'actor list management' stamp: 'jsp 4/2/1999 12:17'!actorListIndex: anInteger	"Set the index of the currently selected actor."	actorListIndex _ anInteger.	myListMorph selectionIndex: anInteger.	self contentsChanged.! !!WonderlandActorBrowser methodsFor: 'actor list management' stamp: 'jsp 4/1/1999 17:38'!updateActorList	"Updates the actor list."	self changed: #actorList.! !!WonderlandActorBrowser class methodsFor: 'instance creation' stamp: 'jsp 4/1/1999 16:44'!newFor: aWonderland	"Create a new actor browser for the Wonderland"	^ self new initializeWith: aWonderland.! !!WonderlandCamera reorganize!('initialize-release' initializeFor: release)('rendering' render:)('get property' getAspectRatio getFarClippingPlane getFieldOfView getNearClippingPlane)('set property' setAspectRatio: setFarClippingPlane: setFieldOfView: setNearClippingPlane:)('accessing' getMorph resetPointOfView turnBackgroundOff turnBackgroundOn)('transforming' transformScreenPointToScenePoint: transformScreenPointToScenePoint:atDepthOf: transformScreenPointToScenePoint:using:)('private' getFrustum getPerspectiveMatrix)!!WonderlandCamera methodsFor: 'initialize-release' stamp: 'jsp 3/25/1999 15:59'!initializeFor: aWonderland	"Initializes the camera."	super initializeFor: aWonderland.	"Set the camera's mesh and geometry"	self setMesh: (WonderlandConstants at: 'cameraMesh').	self setTexturePointer: (WonderlandConstants at: 'cameraTexture').		"Set the camera initial position"	composite translation: (B3DVector3 x: -1.5 y: 0.5 z: 2.6).	self turnTo: #(180 -30 180) duration: #rightNow.	"Initialize the camera viewing parameters"	perspective _ B3DCameraPerspective new.	self setFieldOfView: 40.0.	self setAspectRatio: 1.0.	self setNearClippingPlane: 0.1.	self setFarClippingPlane: 10000.0.	viewMatrix _ B3DMatrix4x4 new.	"Create a WonderlandCameraMorph for the camera to render into"	myMorph _ WonderlandCameraMorph new.	myMorph initializeWithCamera: self.	myMorph openInWorld.	"Initially draw the scene background"	drawSceneBackground _ true.! !!WonderlandCamera methodsFor: 'initialize-release' stamp: 'jsp 3/22/1999 11:07'!release	"Destroy the renderer"	myMorph delete.! !!WonderlandCamera methodsFor: 'rendering' stamp: 'jsp 3/22/1999 16:19'!render: aRenderer	"Render one frame of the Wonderland using this camera."	aRenderer viewport: (myMorph bounds insetBy: 1@1).	(drawSceneBackground)		ifTrue: [ aRenderer clearViewport: (myWonderland getScene) getColorObject. ]		ifFalse: [ ].	aRenderer clearDepthBuffer.	aRenderer loadIdentity.	"Add any existing lights to the renderer for this camera"	(myWonderland getLights) do: [:light | aRenderer addLight: light ].	"Calculate our view matrix by inverting the camera's composite matrix and hand it	to the renderer - note that this will eventually have to walk up the tree"	viewMatrix _ self getMatrixToRoot.	aRenderer transformBy: viewMatrix.	aRenderer perspective: perspective.	"Now render the scene"	myWonderland renderWonderland: aRenderer.	"Force the renderer to draw to the screen"	aRenderer finish.	aRenderer destroy.! !!WonderlandCamera methodsFor: 'get property' stamp: 'jsp 2/11/1999 11:13'!getAspectRatio	"Returns the camera's current aspect ratio."	^ perspective aspectRatio.! !!WonderlandCamera methodsFor: 'get property' stamp: 'jsp 2/11/1999 11:15'!getFarClippingPlane	"Returns the camera's far clipping plane"	^ perspective farDistance.! !!WonderlandCamera methodsFor: 'get property' stamp: 'jsp 3/25/1999 15:58'!getFieldOfView	"Returns the camera's field of view."	^ (perspective fieldOfView) * 2.! !!WonderlandCamera methodsFor: 'get property' stamp: 'jsp 2/11/1999 11:14'!getNearClippingPlane	"Returns the camera's near clipping plane"	^ perspective nearDistance.! !!WonderlandCamera methodsFor: 'set property' stamp: 'jsp 2/11/1999 11:12'!setAspectRatio: aFloat	"Sets the camera's aspect ratio"	perspective aspectRatio: aFloat.! !!WonderlandCamera methodsFor: 'set property' stamp: 'jsp 2/11/1999 11:15'!setFarClippingPlane: aFloat	"Sets the camera's far clipping plane - anything farther than this won't be drawn."	perspective farDistance: aFloat.! !!WonderlandCamera methodsFor: 'set property' stamp: 'jsp 3/25/1999 15:58'!setFieldOfView: aFloat	"Sets the camera's field of view."	perspective fieldOfView: (aFloat / 2).! !!WonderlandCamera methodsFor: 'set property' stamp: 'jsp 2/11/1999 11:14'!setNearClippingPlane: aFloat	"Sets the camera's near clipping plane - anything closer than this won't be drawn."	perspective nearDistance: aFloat.! !!WonderlandCamera methodsFor: 'accessing' stamp: 'jsp 3/22/1999 14:25'!getMorph	"Returns the camera window morph that this camera renders into"	^ myMorph.! !!WonderlandCamera methodsFor: 'accessing' stamp: 'jsp 3/30/1999 16:28'!resetPointOfView	"Return the camera to it's 'home' position and orientation"	^ self setPointOfView: { -1.5. 0.5. 2.6. 180. -30. 180}.! !!WonderlandCamera methodsFor: 'accessing' stamp: 'jsp 3/22/1999 16:19'!turnBackgroundOff	"Stop drawing the scene background"	drawSceneBackground _ false.! !!WonderlandCamera methodsFor: 'accessing' stamp: 'jsp 3/22/1999 16:19'!turnBackgroundOn	"Resume drawing the scene background"	drawSceneBackground _ true.! !!WonderlandCamera methodsFor: 'transforming' stamp: 'jsp 3/29/1999 10:58'!transformScreenPointToScenePoint: aPoint	"Converts a pixel point to a position in the 3D scene. Uses the near clipping plane distance for the depth in the scene."	| d  x y m frustum vector |	frustum _ self getFrustum.	d _ frustum near.	x _ ((aPoint x) - (myMorph center x)) / ((myMorph width) / 2) * (frustum right).	y _ (((aPoint y) - (myMorph center y)) / ((myMorph height) / 2)) * (frustum bottom).	m _ B3DMatrix4x4 identity.	m translation: (B3DVector3 x: x y: y z: d).	m _ (self getMatrixFromRoot) composeWith: m.	vector _ (m translation).	^ { vector at: 1. vector at: 2. vector at: 3 }.! !!WonderlandCamera methodsFor: 'transforming' stamp: 'jsp 3/29/1999 11:00'!transformScreenPointToScenePoint: aPoint atDepthOf: anActor	"Converts a pixel point to a position in the 3D scene using the actor to scale the position of the point. Uses the actor's distance from the camera to determine the depth in the scene."	| d  x y m scale frustum vector |	frustum _ self getFrustum.	d _ (anActor getPosition: self) at: 3.	scale _ d / (frustum near).	x _ ((aPoint x) - (myMorph center x)) / ((myMorph width) / 2) * (frustum right) * scale.	y _ (((aPoint y) - (myMorph center y)) / ((myMorph height) / 2)) * (frustum bottom) * scale.	m _ B3DMatrix4x4 identity.	m translation: (B3DVector3 x: x y: y z: d).	m _ (self getMatrixFromRoot) composeWith: m.	vector _ (m translation).	^ { vector at: 1. vector at: 2. vector at: 3 }.! !!WonderlandCamera methodsFor: 'transforming' stamp: 'jsp 3/29/1999 10:58'!transformScreenPointToScenePoint: aPoint using: anActor	"Converts a pixel point to a position in the 3D scene using the actor to scale the position of the point. Uses the near clipping plane distance for the depth in the scene."	| d  x y m scale frustum vector |	frustum _ self getFrustum.	d _ frustum near.	scale _ ((anActor getPosition: self) at: 3) / d.	x _ ((aPoint x) - (myMorph center x)) / ((myMorph width) / 2) * (frustum right) * scale.	y _ (((aPoint y) - (myMorph center y)) / ((myMorph height) / 2)) * (frustum bottom) * scale.	m _ B3DMatrix4x4 identity.	m translation: (B3DVector3 x: x y: y z: d).	m _ (self getMatrixFromRoot) composeWith: m.	vector _ (m translation).	^ { vector at: 1. vector at: 2. vector at: 3 }.! !!WonderlandCamera methodsFor: 'private' stamp: 'jsp 3/25/1999 10:48'!getFrustum	"Returns the camera's frustum"	^ perspective asFrustum.! !!WonderlandCamera methodsFor: 'private' stamp: 'jsp 3/25/1999 10:50'!getPerspectiveMatrix	"Returns the camera's perspective matrix"	^ perspective asFrustum asPerspectiveMatrix.! !!WonderlandCameraControls reorganize!('initialization' initializeWith:)('accessing' extent:)('event handling' handlesMouseDown: mouseDown: mouseUp:)('camera control' moveCamera)!!WonderlandCameraControls methodsFor: 'initialization' stamp: 'jsp 3/30/1999 14:32'!initializeWith: aCamera	"Initialize this instance"	| b |	myCamera _ aCamera.	myScheduler _ (aCamera getWonderland) getScheduler.	myUndoStack _ (aCamera getWonderland) getUndoStack.	image _ (Form fromBMPFileNamed: 'C:\Program Files\Squeak\camcontrols.bmp').	self extent: 60@60.	b _ (aCamera getMorph) bounds.	self position: ((b center x) - 30) @ (b bottom).	self openInWorld.! !!WonderlandCameraControls methodsFor: 'accessing' stamp: 'jsp 3/30/1999 10:15'!extent: aPoint	bounds extent = aPoint ifFalse: [		self changed.		bounds _ bounds topLeft extent: aPoint.		self layoutChanged.		self changed].! !!WonderlandCameraControls methodsFor: 'event handling' stamp: 'jsp 3/30/1999 10:24'!handlesMouseDown: evt	^ true.! !!WonderlandCameraControls methodsFor: 'event handling' stamp: 'jsp 3/30/1999 11:28'!mouseDown: evt	"Handle a mouse down event."	myUndoStack push: (UndoPOVChange for: myCamera from: (myCamera getPointOfView)).	moveAction _ myCamera doEachFrame: [ self moveCamera ].! !!WonderlandCameraControls methodsFor: 'event handling' stamp: 'jsp 3/30/1999 10:52'!mouseUp: evt	"Handle a mouse up event."	moveAction stop.! !!WonderlandCameraControls methodsFor: 'camera control' stamp: 'jsp 3/30/1999 11:23'!moveCamera	"Move the camera an amount and direction determined by the current position of the mouse and which modifier keys are held down."	| offset dt |	dt _ myScheduler getElapsedTime.	offset _ (self center) - (Sensor mousePoint).	(Sensor shiftPressed)		ifTrue: [ (Sensor controlKeyPressed)					ifTrue: [						myCamera turnRightNow: up numberOfTurns: (dt * (offset y) * 0.01)										undoable: false.							]					ifFalse: [						myCamera moveRightNow: up distance: (dt * (offset y) * 0.1)										undoable: false.						myCamera moveRightNow: left distance: (dt * (offset x) * 0.1)										undoable: false.							].				]		ifFalse: [ (Sensor controlKeyPressed)					ifTrue: [						myCamera turnRightNow: left numberOfTurns: (dt * (offset x) * 0.01)										undoable: false.							]					ifFalse: [						myCamera moveRightNow: forward distance: (dt * (offset y) * 0.1)										undoable: false.						myCamera turnRightNow: left numberOfTurns: (dt * (offset x) * 0.01)										undoable: false.							].				].! !!WonderlandCameraControls class methodsFor: 'instance creation' stamp: 'jsp 3/30/1999 09:57'!newFor: aCamera	"Initialize the camera controls and assign the camera they're controlling"	^ self new initializeWith: aCamera.! !!WonderlandCameraMorph reorganize!('initialization' initializeWithCamera:)('change reporting' layoutChanged)('drawing' drawOn: renderOn:)('stepping' step stepTime wantsSteps)('primitive behaviors' move:distance: move:distance:duration: move:distance:duration:style: moveTo: moveTo:duration: moveTo:duration:style: moveTo:speed:)('picking points' pickPointInBounds: pickPointOnBounds:)('controls' hideCameraControls showCameraControls)!!WonderlandCameraMorph methodsFor: 'initialization' stamp: 'jsp 3/30/1999 16:52'!initializeWithCamera: aCamera	"Initialize this instance and hand it a camera"	myCamera _ aCamera.	myWonderland _ aCamera getWonderland.	"Use a transparent background"	color _ (Color transparent).	self bounds: (20@20 corner: 170@170)! !!WonderlandCameraMorph methodsFor: 'change reporting' stamp: 'jsp 3/4/1999 14:40'!layoutChanged	"Process the changed layout and then change the aspect ratio of the camera to match"	super layoutChanged.	myCamera setAspectRatio: ((self width) / (self height)) asFloat.! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'jsp 3/22/1999 10:42'!drawOn: aCanvas	aCanvas asBalloonCanvas render: self.! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'jsp 3/22/1999 10:47'!renderOn: aRenderer	"Tell our camera to draw"	myCamera render: aRenderer.! !!WonderlandCameraMorph methodsFor: 'stepping' stamp: 'jsp 3/22/1999 10:51'!step	self changed.! !!WonderlandCameraMorph methodsFor: 'stepping' stamp: 'jsp 3/22/1999 10:25'!stepTime		^ 1.! !!WonderlandCameraMorph methodsFor: 'stepping' stamp: 'jsp 3/22/1999 10:25'!wantsSteps	^ true.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 14:23'!move: aDirection distance: aDistance	"Move the morph the specified distance in the specified direction"	^ self move: aDirection distance: aDistance duration: 1.0 style: gently.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 14:23'!move: aDirection distance: aDistance duration: aDuration	"Move the morph the specified distance in the specified direction"	^ self move: aDirection distance: aDistance duration: aDuration style: gently.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 14:55'!move: aDirection distance: aDistance duration: aDuration style: aStyle	"Move the actor the specified distance in the specified direction, taking the specified duration and using the specified animation style."	| anim aPoint tmpPoint |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyDirection: aDirection ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the direction to move the morph because ', msg.			^ nil ].	[ WonderlandVerifier VerifyNumber: aDistance ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the distance to move the morph because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for moving the morph because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to move the morph because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ RelativeAnimation new.	tmpPoint _ 0@0.	(aDirection = left) ifTrue: [ aPoint _ (aDistance negated)@0 ]		ifFalse: [ (aDirection = right) ifTrue: [ aPoint _ aDistance@0 ]					ifFalse: [ (aDirection = up) ifTrue: [ aPoint _ 0@(aDistance negated) ]								ifFalse: [ (aDirection = down) ifTrue: [ aPoint _ 0@aDistance ]										ifFalse: [ myWonderland reportErrorToUser: 'Squeak does not know how to move the morph in that direction.'.												^ nil ].										].							].				].	anim object: self			update: [:tPos | self position: ((self position) + (tPos - tmpPoint)) rounded.							tmpPoint _ tPos]			getStartState: [tmpPoint _ 0@0. Interpolateable value: 0@0. ]			getEndState: [ aPoint ]			getReverseState: [ aPoint negated ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 16:33'!moveTo: aPoint	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	^ self moveTo: aPoint duration: 1.0 style: gently.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 16:33'!moveTo: aPoint duration: aDuration	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	^ self moveTo: aPoint duration: aDuration style: gently.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/22/1999 16:35'!moveTo: aPoint duration: aDuration style: aStyle	"Moves the object to the specified position in its parent's coordinate system using the specified style over the specified duration."	| anim |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyPoint: aPoint ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move the morph to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: aDuration ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for moving the morph because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use to move the morph because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	anim object: self			update: [:tPos | self position: (tPos rounded)]			getStartState: [self position]			getEndState: [ aPoint ]			style: aStyle			duration: aDuration			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandCameraMorph methodsFor: 'primitive behaviors' stamp: 'jsp 3/29/1999 14:59'!moveTo: aPoint speed: aSpeed	"Moves the object to the specified position in its parent's coordinate system at the specified speed."	| anim |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyPoint: aPoint ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine where to move the morph to because ', msg.			^ nil ].	[ WonderlandVerifier VerifyPositiveNumber: aSpeed]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the speed to move the morph because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	anim _ AbsoluteAnimation new.	anim object: self			update: [:tPos | self position: (tPos rounded)]			getStartState: [self position]			getEndState: [ aPoint ]			style: abruptly			duration: ((self position) dist: aPoint) / aSpeed			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandCameraMorph methodsFor: 'picking points' stamp: 'jsp 3/29/1999 11:51'!pickPointInBounds: boundary	"Chooses a random point so that this morph lies within the specified bounds"	| xpos ypos |	xpos _ (boundary left) + (0 to: ((boundary width) - (bounds width))) atRandom.	ypos _ (boundary top) + (0 to: ((boundary height) - (bounds height))) atRandom.	^ xpos@ypos.! !!WonderlandCameraMorph methodsFor: 'picking points' stamp: 'jsp 3/29/1999 11:46'!pickPointOnBounds: boundary	"Chooses a random point so that an edge of this morph lies on the specified bounds"	| side pos |	"First choose which side to move the morph to"	side _ (1 to: 4) atRandom.	"Now choose where on that side to move to"	((side = 1) or: [ side = 3 ])			ifTrue: [ pos _ (0 to: ((boundary height) - (bounds height))) atRandom]			ifFalse: [ pos _ (0 to: ((boundary width) - (bounds width))) atRandom ].	"Now assemble the point)"	"left"	(side = 1) ifTrue: [ ^ (boundary left)@((boundary top) + pos) ].	"top"	(side = 2) ifTrue: [ ^ ((boundary left) + pos) @ (boundary top) ].	"right"	(side = 3) ifTrue: [ ^ ((boundary right) - (bounds width)) @ ((boundary top) + pos) ].	"bottom"	^ ((boundary left) + pos) @ ((boundary bottom) - (bounds height)).! !!WonderlandCameraMorph methodsFor: 'controls' stamp: 'jsp 3/30/1999 15:00'!hideCameraControls	"Hide the camera controls for the camera rendering into this window"	myControls ifNotNil: [ myControls hide ].! !!WonderlandCameraMorph methodsFor: 'controls' stamp: 'jsp 3/30/1999 15:02'!showCameraControls	"Show the camera controls for the camera rendering into this window"	myControls ifNil: [			myControls _ WonderlandCameraControls newFor: myCamera.			self addMorph: myControls.					  ].	myControls show.! !!WonderlandEditor reorganize!('initialization' addPanel: initializeWith:)('user-interface')('accessing' resetNamespace updateActorBrowser)!!WonderlandEditor methodsFor: 'initialization' stamp: 'jsp 4/1/1999 15:15'!addPanel: aMorph	"Adds a new panel to the editor."	(self tabsMorph) addTab: (ReferenceMorph forMorph: aMorph).	(self pages) add: aMorph.! !!WonderlandEditor methodsFor: 'initialization' stamp: 'jsp 4/1/1999 17:06'!initializeWith: aWonderland	"Initialize the editor with the Wonderland."	myWonderland _ aWonderland.	myScriptEditor _ (WonderlandScriptEditor new).	self addPanel: (myScriptEditor getMorph).	(self tabsMorph submorphs at: 1) tabSelected.	myScriptEditor setBindings: (myWonderland getNamespace).	myActorBrowser _ (WonderlandActorBrowser newFor: myWonderland).	self addPanel: (myActorBrowser getMorph).	self position: 250@20.	self openInWorld.! !!WonderlandEditor methodsFor: 'accessing' stamp: 'jsp 4/1/1999 16:21'!resetNamespace	"Reset the namespace used by the script editor"	myScriptEditor setBindings: (myWonderland getNamespace).! !!WonderlandEditor methodsFor: 'accessing' stamp: 'jsp 4/1/1999 17:37'!updateActorBrowser	"Tells the actor browser to update the list of actors"	myActorBrowser updateActorList.! !!WonderlandEditor class methodsFor: 'instance creation' stamp: 'jsp 4/1/1999 15:04'!newFor: aWonderland	"Create a new editor for the Wonderland"	^ self new initializeWith: aWonderland.! !!WonderlandMesh methodsFor: 'initialize' stamp: 'jsp 3/11/1999 10:31'!createFromOBJFile: filename	"Read in a mesh from the obj file"	| aFile pos line words oldWords triple pt1 pt2 pt3 vCount fCount index |		aFile _ (CrLfFileStream readOnlyFileNamed: filename) ascii.	line _ aFile upTo: (Character cr).	words _ line findTokens: ' '.		vCount _ 0.	"Count the vertices"	[ (words at: 1) = 'v' ] whileTrue: [ vCount _ vCount + 1.									   line _ aFile upTo: (Character cr).									   words _ line findTokens: ' ' ].	"Now reset the file and grab the actual data"	aFile position: 0.	"Create the vertex array"	vertices _ B3DVector3Array new: vCount.	"Read in the vertices"	line _ aFile upTo: (Character cr).	words _ line findTokens: ' '.	index _ 1.	[ (words at: 1) = 'v' ] whileTrue: [ vertices at: index put:													(B3DVector3 x: ((words at: 2) asNumber)																y: ((words at: 3) asNumber)																z: ((words at: 4) asNumber)).									   index _ index + 1.									   line _ aFile upTo: (Character cr).									   words _ line findTokens: ' ' ].	"Read in the texture coordinates"	index _ 1.	vtxTexCoords _ B3DTexture2Array new: vCount.	[ (words at: 1) = 'vt' ] whileTrue: [ vtxTexCoords at: index													put: (B3DVector2 u: ((words at: 2) asNumber)																	v: ((words at: 3) asNumber)).										index _ index + 1.										line _ aFile upTo: (Character cr).	  									words _ line findTokens: ' '.									].	"Read in the normals"	index _ 1.	vtxNormals _ B3DVector3Array new: vCount.	[ (words at: 1) = 'vn' ] whileTrue: [ vtxNormals at: index											put: (B3DVector3 x: ((words at: 2) asNumber)															 y: ((words at: 3) asNumber)															 z: ((words at: 4) asNumber)).										index _ index + 1.										line _ aFile upTo: (Character cr).	  									words _ line findTokens: ' '. 									].	pos _ aFile position.	oldWords _ words.	"Count the faces"	fCount _ 0.	[ (words size) > 0 ] whileTrue: [((words at: 1) = 'f') ifTrue: [ fCount _ fCount + 1 ].										line _ aFile upTo: (Character cr).	  									words _ line findTokens: ' '. ].	"Create the faces array"	faces _ B3DIndexedTriangleArray new: fCount.	aFile position: pos.	words _ oldWords.	index _ 1.	"Read in the faces"	[ (words size) > 0 ] whileTrue: [((words at: 1) = 'f') ifTrue: [ 					triple _ (words at: 2) findTokens: '/'.					pt1 _ (triple at: 1) asNumber.					triple _ (words at: 3) findTokens: '/'.					pt2 _ (triple at: 1) asNumber.					triple _ (words at: 4) findTokens: '/'.					pt3 _ (triple at: 1) asNumber.					faces at: index put: (B3DIndexedTriangle with: pt1 with: pt2 with: pt3).					index _ index + 1.										].					line _ aFile upTo: (Character cr).	  				words _ line findTokens: ' '.				].	aFile close.! !!WonderlandMesh methodsFor: 'initialize' stamp: 'jsp 3/15/1999 11:10'!createFromVFBFile: filename	"Read in a mesh from the vfb file"	| aFile w x y z bytes version vCount fCount verticesPerFace  |		aFile _ (StandardFileStream readOnlyFileNamed: filename) binary.	"Read in the version number"	bytes _ aFile next: 4.	version _ bytes unsignedLongAt: 1 bigEndian: false.	(version = 1) ifTrue: [							"Read in the number of vertices"							bytes _ aFile next: 4.							vCount _ bytes unsignedLongAt: 1 bigEndian: false.						]				ifFalse: [							vCount _ version.							version _ 0.						].	(vCount > 0) ifTrue: [		vertices _ B3DVector3Array new: vCount.		vtxNormals _ B3DVector3Array new: vCount.		vtxTexCoords _ B3DTexture2Array new: vCount.		"Read in the vertices"		1 to: vCount do: [:i | bytes _ aFile next: 32.						x _ Float fromIEEE32Bit: (bytes unsignedLongAt: 1 bigEndian: false).						y _ Float fromIEEE32Bit: (bytes unsignedLongAt: 5 bigEndian: false).						z _ Float fromIEEE32Bit: (bytes unsignedLongAt: 9 bigEndian: false).						vertices at: i put: (B3DVector3 x: (x negated) y: y z: z).						x _ Float fromIEEE32Bit: (bytes unsignedLongAt: 13 bigEndian: false).						y _ Float fromIEEE32Bit: (bytes unsignedLongAt: 17 bigEndian: false).						z _ Float fromIEEE32Bit: (bytes unsignedLongAt: 21 bigEndian: false).						vtxNormals at: i put: (B3DVector3 x: (x negated) y: y z: z).						x _ Float fromIEEE32Bit: (bytes unsignedLongAt: 25 bigEndian: false).						y _ Float fromIEEE32Bit: (bytes unsignedLongAt: 29 bigEndian: false).						vtxTexCoords at: i put: (B3DVector2 u: x v: y).						].		"Read in the number of faces"		bytes _ aFile next: 4.		fCount _ bytes unsignedLongAt: 1 bigEndian: false.		(fCount > 0) ifTrue: [				"Read past the faceDataCount value"				aFile next: 4.				(version = 0) ifTrue: [ verticesPerFace _ 0. ]							ifFalse: [										bytes _ aFile next: 4.										verticesPerFace _ bytes unsignedLongAt: 1 bigEndian: false.									].				(verticesPerFace = 0) ifTrue: [							faces _ B3DIndexedTriangleArray new: fCount.							1 to: fCount do: [: i |								bytes _ aFile next: 4.								w _ bytes unsignedLongAt: 1 bigEndian: false.								(w = 3) ifTrue: [									bytes _ aFile next: 4.									x _ (bytes unsignedLongAt: 1 bigEndian: false) + 1.									bytes _ aFile next: 4.									y _ (bytes unsignedLongAt: 1 bigEndian: false) + 1.									bytes _ aFile next: 4.									z _ (bytes unsignedLongAt: 1 bigEndian: false) + 1.									faces at: i put: (B3DIndexedTriangle with: x with: y with: z). 												]										ifFalse: [ 1 to: w do: [: j | aFile next: 4] ].											].																		].							].  " (end if fCount > 0) "						]	" (end if vCount > 0) "			ifFalse: [ ^ nil ].	aFile close.! !!WonderlandMesh class methodsFor: 'instanceCreation' stamp: 'jsp 2/17/1999 15:25'!fromOBJFile: filename	"Reads and creates a mesh from an OBJ file"	^ (WonderlandMesh new) createFromOBJFile: filename.				! !!WonderlandMesh class methodsFor: 'instanceCreation' stamp: 'jsp 3/11/1999 15:03'!fromVFBFile: filename	"Reads and creates a mesh from an OBJ file"	^ (WonderlandMesh new) createFromVFBFile: filename.! !!WonderlandMorph reorganize!('initialization' initializeWith:)('actions' quitWonderland)('stepping' step stepTime wantsSteps)!!WonderlandMorph methodsFor: 'initialization' stamp: 'jsp 3/30/1999 16:51'!initializeWith: aWonderland	"Initialize the instance"	| exitButton resetButton undoButton |	myWonderland _ aWonderland.	myScheduler _ myWonderland getScheduler.	"Use a white background"	color _ (Color white).	"Now add our buttons"	undoButton _ SimpleButtonMorph new.	undoButton initialize.	undoButton label: 'Undo'.	undoButton color: (Color green).	undoButton target: myWonderland.	undoButton actionSelector: #undo.	self addMorph: undoButton.	resetButton _ SimpleButtonMorph new.	resetButton initialize.	resetButton label: 'Reset'.	resetButton color: (Color yellow).	resetButton target: myWonderland.	resetButton actionSelector: #reset.	self addMorph: resetButton.	exitButton _ SimpleButtonMorph new.	exitButton initialize.	exitButton label: 'Quit'.	exitButton color: (Color red).	exitButton target: self.	exitButton actionSelector: #quitWonderland.	self addMorph: exitButton.	undoButton bounds: (10@10 corner: 50@40).	resetButton bounds: (10@50 corner: 50@80).	exitButton bounds: (10@90 corner: 50@120).	"Size and position the window"	self bounds: (20@200 corner: 80@340).! !!WonderlandMorph methodsFor: 'actions' stamp: 'jsp 3/23/1999 15:37'!quitWonderland	"Destroy the wonderland"	myWonderland release.	self delete.! !!WonderlandMorph methodsFor: 'stepping' stamp: 'jsp 3/23/1999 15:04'!step	myScheduler tick.! !!WonderlandMorph methodsFor: 'stepping' stamp: 'jsp 3/23/1999 15:03'!stepTime		^ 1.! !!WonderlandMorph methodsFor: 'stepping' stamp: 'jsp 3/23/1999 15:03'!wantsSteps	^ true.! !!WonderlandMorph class methodsFor: 'instance creation' stamp: 'jsp 3/23/1999 15:30'!newFor: aWonderland	"Create a new instance"	^ self new initializeWith: aWonderland.! !!WonderlandScene reorganize!('initialization' initializeFor:)('drawing' renderOn:)('set property' setColor: setColor:duration: setColor:duration:style:)('get property' getColor)('accessing' asString getName)('private' getColorObject getColorVector getMatrixFromRoot getMatrixToRoot setColorRightNow:undoable: setColorVector:)!!WonderlandScene methodsFor: 'initialization' stamp: 'jsp 3/15/1999 15:27'!initializeFor: aWonderland	"Initialize the Wonderland Scene."	super initialize.	"Set our properties"	myWonderland _ aWonderland.	myColor _ B3DColor4 r: 0.4 g: 0.6 b: 0.85 a: 1.! !!WonderlandScene methodsFor: 'drawing' stamp: 'jsp 2/22/1999 13:54'!renderOn: aRenderer	"Tell the Scene's children to draw themselves"	myChildren do: [:child | child renderOn: aRenderer ].! !!WonderlandScene methodsFor: 'set property' stamp: 'jsp 3/1/1999 14:15'!setColor: newColor	"Set the scene's background color"	^ (self setColor: newColor duration: 1.0			style: gently)! !!WonderlandScene methodsFor: 'set property' stamp: 'jsp 3/22/1999 16:06'!setColor: newColor duration: time	"Set the scene's background color"	(time = rightNow) ifTrue: [		[ WonderlandVerifier VerifyColor: newColor ]			ifError: [ :msg :rcvr |				myWonderland reportErrorToUser: 'Squeak could not determine what color to make the scene because ', msg.				^ nil ].			^ self setColorRightNow: newColor undoable: true ].	^ (self setColor: newColor duration:time style: gently)! !!WonderlandScene methodsFor: 'set property' stamp: 'jsp 3/22/1999 16:06'!setColor: newColor duration: time style: aStyle	"Set the actor's color"	| anim aColor |	"Check our arguments to make sure they're valid"	[ WonderlandVerifier VerifyColor: newColor ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine what color to make the scene because ', msg.			^ nil ].	[ WonderlandVerifier VerifyDuration: time ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser:				'Squeak could not determine the duration to use for changing the color of the scene because ', msg.			^ nil ].	[ WonderlandVerifier VerifyStyle: aStyle ]		ifError: [ :msg :rcvr |			myWonderland reportErrorToUser: 'Squeak could not determine the style to use for changing the color of the scene because ', msg.			^ nil ].	"Our parameters check out, so build the animation"	((newColor at: 1) isNumber)				ifTrue: [ aColor _ B3DColor4 red: (newColor at: 1) green: (newColor at: 2)										blue: (newColor at: 3) alpha: 1.0 ]				ifFalse: [ aColor _ Color perform: newColor.						  aColor _ B3DColor4 red: (aColor red) green: (aColor green)										blue: (aColor blue) alpha: 1.0 ].	anim _ AbsoluteAnimation new.	anim object: self			update: [:tColor | self setColorVector: tColor]			getStartState: [self getColorVector]			getEndState: [ aColor ]			style: aStyle			duration: time			undoable: true			inWonderland: myWonderland.	^ anim.! !!WonderlandScene methodsFor: 'get property' stamp: 'jsp 3/22/1999 10:55'!getColor	"Return the scene's background color"	| tmpArray |	myColor ifNil: [ ^ nil ].	tmpArray _ Array new:3.		tmpArray at:1 put: (myColor red).	tmpArray at:2 put: (myColor green).	tmpArray at:3 put: (myColor blue).	^ tmpArray.! !!WonderlandScene methodsFor: 'accessing' stamp: 'jsp 4/1/1999 17:26'!asString	"Return a string name for the scene"	^ 'scene'.! !!WonderlandScene methodsFor: 'accessing' stamp: 'jsp 4/1/1999 17:26'!getName	"Return the scene's name"	^ 'scene'.! !!WonderlandScene methodsFor: 'private' stamp: 'jsp 3/22/1999 10:16'!getColorObject	"Returns the scene's background color object"	^ myColor.! !!WonderlandScene methodsFor: 'private' stamp: 'jsp 2/23/1999 15:40'!getColorVector	"Return the scene's background color"	^ myColor.! !!WonderlandScene methodsFor: 'private' stamp: 'jsp 2/22/1999 14:39'!getMatrixFromRoot	"Returns the identity matrix"	^ (B3DMatrix4x4 identity).! !!WonderlandScene methodsFor: 'private' stamp: 'jsp 2/22/1999 14:39'!getMatrixToRoot	"Returns the identity matrix"	^ (B3DMatrix4x4 identity).! !!WonderlandScene methodsFor: 'private' stamp: 'jsp 3/22/1999 16:05'!setColorRightNow: newColor undoable: isUndoable	"Change this instance's color instantaneously"	| aColor |	(isUndoable) ifTrue: [		myWonderland getUndoStack push: (UndoColorChange for: self from: (self getColor)) ].	((newColor at: 1) isNumber)				ifTrue: [ aColor _ B3DColor4 red: (newColor at: 1) green: (newColor at: 2)										blue: (newColor at: 3) alpha: (1.0) ]				ifFalse: [ aColor _ Color perform: newColor.						  aColor _ B3DColor4 red: (aColor red) green: (aColor green)										blue: (aColor blue) alpha: (1.0) ].	self setColorVector: aColor.! !!WonderlandScene methodsFor: 'private' stamp: 'jsp 2/23/1999 15:36'!setColorVector: aColor	"Set the scene's background color instantaneously"	myColor _ aColor.! !!WonderlandScene class methodsFor: 'instance creation' stamp: 'jsp 3/10/1999 16:10'!newFor: aWonderland	"Initialize the new instance for a Wonderland before returning it."	^ super new initializeFor: aWonderland.! !!WonderlandScriptEditor methodsFor: 'initialize-release' stamp: 'jsp 4/1/1999 16:01'!initialize	"Create a modified workspace as our script editor"	super initialize.	myTextEditor _ (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:).	myTextEditor name: 'Script'.	myTextEditor scrollBarOnLeft: false.	myTextEditor extent: 600@350.	myTextEditor color: (Color r: 0.815 g: 0.972 b: 0.878).! !!WonderlandScriptEditor methodsFor: 'accessing' stamp: 'jsp 4/1/1999 15:42'!getMorph	"Returns the text editor morph"	^ myTextEditor.! !!WonderlandStyle class reorganize!('class initialization' initialize)('instance creation' new)('generate parameters' abruptlyAfter:outOf: beginGentlyAfter:outOf: endGentlyAfter:outOf: gentlyAfter:outOf: oneAfter:outOf:)('private' gently:lowerBound:upperBound:)!!WonderlandStyle class methodsFor: 'class initialization' stamp: 'jsp 4/2/1999 09:50'!initialize	"Add the style constants gently, beginGently, endGently, and abruptly to the WonderlandConstants dictionary"	| dict |	dict _ Smalltalk at: #WonderlandConstants.	dict at: 'gently' put:			[:elapsed :duration | WonderlandStyle gentlyAfter: elapsed outOf: duration ].	dict at: 'beginGently' put:			[:elapsed :duration | WonderlandStyle beginGentlyAfter: elapsed outOf: duration ].	dict at: 'endGently' put:			[:elapsed :duration | WonderlandStyle endGentlyAfter: elapsed outOf: duration ].	dict at: 'abruptly' put:			[:elapsed :duration | WonderlandStyle abruptlyAfter: elapsed outOf: duration ].! !!WonderlandStyle class methodsFor: 'instance creation' stamp: 'jsp 2/4/1999 14:58'!new	"Users shouldn't create any instances of this class, so this method throws an error if they try."	self error: 'This class exists to generate style parameters, so it should not be instatiated.'! !!WonderlandStyle class methodsFor: 'generate parameters' stamp: 'jsp 3/1/1999 17:04'!abruptlyAfter: elapsed outOf: duration	"Returns the proportion done for an Abrupt animation style after elapsed seconds (out of duration seconds) have elapsed."	(elapsed >= duration) ifTrue: [ ^ 1.0 ].	^ (elapsed / duration).! !!WonderlandStyle class methodsFor: 'generate parameters' stamp: 'jsp 3/1/1999 17:04'!beginGentlyAfter: elapsed outOf: duration	"Returns the proportion done for an animation using the BeginGently style after elapsed seconds (out of duration seconds)."	(elapsed >= duration) ifTrue: [ ^ 1.0 ].	^ (self gently: (elapsed / duration) lowerBound: 0.99 upperBound: 0.999).! !!WonderlandStyle class methodsFor: 'generate parameters' stamp: 'jsp 3/1/1999 17:04'!endGentlyAfter: elapsed outOf: duration	"Returns the proportion done for an animation using the EndGently style after elapsed seconds (out of duration seconds)."	(elapsed >= duration) ifTrue: [ ^ 1.0 ].	^ (self gently: (elapsed / duration) lowerBound: 0.001 upperBound: 0.01).! !!WonderlandStyle class methodsFor: 'generate parameters' stamp: 'jsp 3/1/1999 17:05'!gentlyAfter: elapsed outOf: duration	"Returns the proportion done for an animation using the Gently style after elapsed seconds (out of duration seconds)."	(elapsed >= duration) ifTrue: [ ^ 1.0 ].	^ (self gently: (elapsed / duration) lowerBound: 0.3 upperBound: 0.8).! !!WonderlandStyle class methodsFor: 'generate parameters' stamp: 'jsp 2/4/1999 15:08'!oneAfter: elapsed outOf: duration	"Returns the proportion of Animation done using an instantaneous style - this is also 1.0."	^ 1.0.! !!WonderlandStyle class methodsFor: 'private' stamp: 'jsp 2/4/1999 15:22'!gently: x lowerBound: A upperBound: B	"This method converts a linear proportion done to a slow in - slow out proportion. If x is less than A then the animation is in the slow in part, while if x is greater than B then the animation is in the slow out part."	| y a3 b3 c3 m b2 |  	(x < A) ifTrue: [ y _ ((B - 1)/(A *  ((B * B) - (A * B) + A - 1))) * x * x ]		    ifFalse: [ (x > B) ifTrue: [										a3 _ 1 / ((B * B) - (A * B) + A - 1).										b3 _ -2 * a3.										c3 _ 1 + a3.  										y _ (a3 * x * x) + (b3 * x) + c3.									]							ifFalse: [										m _ 2 * (B - 1) / ((B * B) - (A * B) + A - 1).										b2 _ (0 - m) * A / 2.										y _ m * x + b2.									].  				    ].	^ y.! !!WonderlandUndoStack commentStamp: '<historical>' prior: 0!This class implements the undo stack for Wonderlands.  Every user action is added to the undo stack, and the user can then undo each action one at a time. This stack is intended to be "infinite" so that the user can always roll back to a safe state.!!WonderlandUndoStack reorganize!('initialization' initialize)('accessing' closeStack getMaxDepth isEmpty isOpen openStack pop popAndUndo push: setMaxDepth:)('reset' reset)!!WonderlandUndoStack methodsFor: 'initialization' stamp: 'jsp 3/24/1999 15:53'!initialize	"Initializes the undo stack."	theStack _ OrderedCollection new.	stackIsOpen _ true.	maxStackDepth _ (WonderlandConstants at: 'maxUndoDepth').! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 3/8/1999 12:16'!closeStack	"Close the stack to prevent undoable items from being pushed onto it."	stackIsOpen _ false.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 3/24/1999 15:54'!getMaxDepth	"Returns the current maximum depth of the undo stack"	^ maxStackDepth.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 2/14/1999 18:36'!isEmpty	"Returns true if the undo stack is empty"	^ (theStack size) = 0.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 3/8/1999 12:18'!isOpen	"Returns true if the undo stack is open"	^ stackIsOpen.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 3/8/1999 12:16'!openStack	"Open the stack to allow undoable items to be pushed onto it."	stackIsOpen _ true.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 2/14/1999 18:38'!pop	"Takes the top undo action off the stack."	| lastItem |	(theStack isEmpty) ifTrue: [lastItem _ nil]					   ifFalse: [lastItem _ theStack removeLast].	^ lastItem.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 2/16/1999 16:36'!popAndUndo	"Takes the top undo action off the stack and does it (undoing the original action)."	| lastItem |	(theStack isEmpty) ifTrue: [lastItem _ nil]					   ifFalse: [lastItem _ (theStack removeLast) undoIt].	^ lastItem.! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 3/24/1999 15:55'!push: anAction	"Pushes an undo action on the stack."	(stackIsOpen) ifTrue: [ theStack addLast: anAction ].	((theStack size) > maxStackDepth) ifTrue: [ theStack removeFirst ].! !!WonderlandUndoStack methodsFor: 'accessing' stamp: 'jsp 3/24/1999 15:54'!setMaxDepth: aNumber	"Sets the current maximum depth of the undo stack"	maxStackDepth _ aNumber.! !!WonderlandUndoStack methodsFor: 'reset' stamp: 'jsp 3/30/1999 15:44'!reset	"Reset the undo stack."	theStack _ OrderedCollection new.	stackIsOpen _ true.! !!WonderlandUndoStack class methodsFor: 'instance creation' stamp: 'jsp 2/14/1999 18:41'!new	"Create a new Wonderland undo stack and initializes it."	^ super new initialize.! !Smalltalk renameClassNamed: #WonderlandParser as: #WonderlandVerifier!!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 14:53'!Verify0To1Number: parameter	"If the parameter is a valid number this method returns true, otherwise it throws an exception"	(((parameter isNumber) and: [ parameter >= 0 ]) and: [ parameter <= 1 ])					ifTrue: [ ^ true ]					ifFalse: [ self error: (parameter asString) , ' is not a number between 0 and 1. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:23'!VerifyActor: parameter	"If the parameter is a valid WonderlandActor (or subclass) this method returns true, otherwise it throws an exception"	(parameter isKindOf: WonderlandActor)		ifTrue: [ ^ true ]		ifFalse: [ self error: (parameter asString) , ' is not a valid Wonderland Actor. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 14:59'!VerifyColor: parameter	"If the parameter is a valid color (triple or named color) this method returns true, otherwise it throws an exception"	(parameter isKindOf: SequenceableCollection)		ifTrue: [			(((((parameter size) = 3)				and: [ ((parameter at: 1) isNumber) and:							[ ((parameter at: 1) >= 0) and: [ ((parameter at: 1) <= 1) ] ] ] )				and: [ ((parameter at: 2) isNumber) and: 							[ ((parameter at: 2) >= 0) and: [ ((parameter at: 2) <= 1) ] ] ] )				and: [ ((parameter at: 3) isNumber) and:							[ ((parameter at: 3) >= 0) and: [ ((parameter at: 3) <= 1) ] ] ] )					ifTrue: [ ^ true ]					ifFalse: [ [ Color perform: parameter. ]								ifError: [ :msg : rcvr | self error: (parameter asString) ,												' is not a valid color. '].							  ^ true.							].  				]		ifFalse: [ self error: (parameter asString) , ' is not a valid color. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 13:45'!VerifyCondition: parameter	"If the parameter is a valid style (BlockContext that takes 1 parameter and returns a boolean) this method returns true, otherwise it throws an exception"	| result | 	[ result _ ((parameter value) isKindOf: Boolean) ] 		ifError: [ :msg :rcvr |					self error: 'your condition must be a block that returns true or false.' ].	(result) ifTrue: [ ^ true ]			ifFalse: [ self error: 'your condition does not return true or false. '].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/22/1999 12:25'!VerifyDimension: parameter	"If the parameter is a valid dimension this method returns true, otherwise it throws an exception"	(((parameter = leftToRight) or: [ parameter = topToBottom ]) or: [ parameter = frontToBack ])			ifTrue: [ ^ true ]			ifFalse: [ self error: (parameter asString) , ' is not a valid dimension. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:41'!VerifyDirection: parameter	"If the parameter is a valid direction this method returns true, otherwise it throws an exception"	(((((((((parameter = left) or: [ parameter = right ]) or: [ parameter = up ])			or: [ parameter = down ]) or: [ parameter = forward ])			or: [ parameter = back ]) or: [ parameter = backward ])			or: [ parameter = ccw ]) or: [ parameter = cw ])					ifTrue: [ ^ true ]					ifFalse: [ self error: (parameter asString) , ' is not a valid direction. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:41'!VerifyDuration: parameter	"If the parameter is a valid duration this method returns true, otherwise it throws an exception"	((( parameter = rightNow) or: [ parameter = eachFrame ])		or: [ (parameter isNumber) and: [ parameter >= 0 ]	])					ifTrue: [ ^ true ]					ifFalse: [ self error: (parameter asString) , ' is not a valid duration. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:41'!VerifyLocation: parameter	"If the parameter is a valid location this method returns true, otherwise it throws an exception"	((((((((((parameter = toLeftOf) or: [ parameter = toRightOf ]) or: [ parameter = onTopOf ])			or: [ parameter = onBottomOf ]) or: [ parameter = inFrontOf ])			or: [ parameter = inBackOf ]) or: [ parameter = behind ])			or: [ parameter = below ]) or: [ parameter = onFloorOf ])			or: [ parameter = onCeilingOf ])					ifTrue: [ ^ true ]					ifFalse: [ self error: (parameter asString) , ' is not a valid location. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 16:24'!VerifyNonNegativeNumber: parameter	"If the parameter is a valid number this method returns true, otherwise it throws an exception"	((parameter isNumber) and: [ parameter >= 0 ])			ifTrue: [ ^ true ]			ifFalse: [ self error: (parameter asString) , ' is not a number greater than or equal to zero. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:23'!VerifyNumber: parameter	"If the parameter is a valid number this method returns true, otherwise it throws an exception"	(parameter isNumber)					ifTrue: [ ^ true ]					ifFalse: [ self error: (parameter asString) , ' is not a valid number. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/24/1999 16:43'!VerifyNumberOrTriple: parameter	"If the parameter is a number or a valid triple this method returns true, otherwise it throws an exception"	((parameter isNumber) or: [(((((parameter isKindOf: SequenceableCollection)			and: [ (parameter size) = 3 ] )			and: [ ((parameter at: 1) isNumber) ] )			and: [ ((parameter at: 2) isNumber) ] ) 			and: [ ((parameter at: 3) isNumber) ] ) ]) 				ifTrue: [ ^ true ]				ifFalse: [ self error: (parameter asString) , ' is not a number or triple. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/22/1999 16:25'!VerifyPoint: parameter	"If the parameter is a valid point this method returns true, otherwise it throws an exception"	(parameter isKindOf: Point)		ifTrue: [ ^ true ]		ifFalse: [ self error: (parameter asString) , ' is not a valid point. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 15:16'!VerifyPointOfView: parameter	"If the parameter is a valid point of view (sextuple or kind of WonderlandActor) this method returns true, otherwise it throws an exception"	((parameter isKindOf: WonderlandActor)		or: 	[ (((((((parameter isKindOf: SequenceableCollection)				and: [ (parameter size) = 6 ] )				and: [ ((parameter at: 1) isNumber) or: [ (parameter at: 1) = asIs ] ] )				and: [ ((parameter at: 2) isNumber) or: [ (parameter at: 2) = asIs ] ] )				and: [ ((parameter at: 3) isNumber) or: [ (parameter at: 3) = asIs ] ] ) 				and: [ ((parameter at: 4) isNumber) or: [ (parameter at: 4) = asIs ] ] ) 				and: [ ((parameter at: 5) isNumber) or: [ (parameter at: 5) = asIs ] ] )  				and: [ ((parameter at: 6) isNumber) or: [ (parameter at: 6) = asIs ] ]  			])				ifTrue: [ ^ true ]				ifFalse: [ self error: (parameter asString) , ' is not a valid point of view. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:59'!VerifyPositiveNumber: parameter	"If the parameter is a valid number this method returns true, otherwise it throws an exception"	((parameter isNumber) and: [ parameter > 0 ])			ifTrue: [ ^ true ]			ifFalse: [ self error: (parameter asString) , ' is not a number greater than zero. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 15:43'!VerifyReferenceFrame: parameter	"If the parameter is a valid WonderlandActor (or subclass) or WonderlandScene this method returns true, otherwise it throws an exception"	((parameter isKindOf: WonderlandActor) or: [ parameter isKindOf: WonderlandScene])		ifTrue: [ ^ true ]		ifFalse: [ self error: (parameter asString) , ' does not have an orientation.' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 13:47'!VerifyStyle: parameter	"If the parameter is a valid style (BlockContext that takes 2 parameters) this method returns true, otherwise it throws an exception"	| result |	[ result _ ((parameter numArgs) = 2) ]		ifError: [ :msg :rcvr |					self error: 'your style was not a block that takes 2 parameters and returns a value between 0 and 1.' ].	(result) ifTrue: [ ^ true ]			ifFalse: [ self error: 'your style function did not take exactly 2 parameters. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/17/1999 15:41'!VerifyTarget: parameter	"If the parameter is a valid target (triple or kind of WonderlandActor) this method returns true, otherwise it throws an exception"	((parameter isKindOf: WonderlandActor)		or: 	[ ((((parameter isKindOf: SequenceableCollection)				and: [ (parameter size) = 3 ] )				and: [ ((parameter at: 1) isNumber) or: [ (parameter at: 1) = asIs ] ] )				and: [ ((parameter at: 2) isNumber) or: [ (parameter at: 2) = asIs ] ] ) 				and: [ ((parameter at: 3) isNumber) or: [ (parameter at: 3) = asIs ] ]  			])				ifTrue: [ ^ true ]				ifFalse: [ self error: (parameter asString) , ' is not a valid target. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/29/1999 14:39'!VerifyTargetOrPixel: parameter	"If the parameter is a valid target (triple or kind of WonderlandActor) or a pixel coordinate this method returns true, otherwise it throws an exception"	(((parameter isKindOf: WonderlandActor) or: [ parameter isKindOf: Point ])		or: 	[ ((((parameter isKindOf: SequenceableCollection)				and: [ (parameter size) = 3 ] )				and: [ ((parameter at: 1) isNumber) or: [ (parameter at: 1) = asIs ] ] )				and: [ ((parameter at: 2) isNumber) or: [ (parameter at: 2) = asIs ] ] ) 				and: [ ((parameter at: 3) isNumber) or: [ (parameter at: 3) = asIs ] ]  			])				ifTrue: [ ^ true ]				ifFalse: [ self error: (parameter asString) , ' is not a valid target. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 15:05'!VerifyTriple: parameter	"If the parameter is a valid triple  this method returns true, otherwise it throws an exception"	(((((parameter isKindOf: SequenceableCollection)			and: [ (parameter size) = 3 ] )			and: [ ((parameter at: 1) isNumber) ] )			and: [ ((parameter at: 2) isNumber) ] ) 			and: [ ((parameter at: 3) isNumber) ] ) 				ifTrue: [ ^ true ]				ifFalse: [ self error: (parameter asString) , ' is not a collection with 3 numbers. ' ].! !!WonderlandVerifier class methodsFor: 'parameter parsing' stamp: 'jsp 3/18/1999 17:05'!VerifyZeroArgumentBlock: parameter	"Return true if the parameter is a zero argument block, otherwise throw an exception"	((parameter class) = BlockContext)		ifTrue: [ ((parameter numArgs) = 0)						ifTrue: [ ^ true ]						ifFalse: [ self error: ' the block can not require arguments.' ]				]		ifFalse: [ self error: ' you need to supply a block that does not require arguments.' ].! !AbstractAnimation removeSelector: #resetLoopCount!AbstractAnimation initialize!Action removeSelector: #initialize!Action class removeSelector: #do:eachframeuntil:inScheduler:!Action class removeSelector: #do:inScheduler:!Action class removeSelector: #do:eachframefor:inScheduler:!Animation removeSelector: #update:getStartState:getEndState:style:duration:undoable:inWonderland:!AbsoluteAnimation removeSelector: #update:getStartState:getEndState:style:duration:undoable:inWonderland:!CompositeAnimation removeSelector: #start!RelativeAnimation removeSelector: #update:getStartState:getEndState:getReverseState:style:duration:undoable:inWonderland:!Scheduler removeSelector: #addCamera:!Scheduler removeSelector: #processCameras!Scheduler removeSelector: #sleep!Scheduler removeSelector: #release!Scheduler removeSelector: #wake!Scheduler removeSelector: #removeCamera:!SequentialAnimation removeSelector: #getComponents!SequentialAnimation removeSelector: #start!UndoByStopping removeSelector: #initializeWith:!UndoByStopping class removeSelector: #new:!UndoPositionChange removeSelector: #setOriginalPosition:!UndoPositionChange class removeSelector: #from:!UndoShowHide removeSelector: #undoHideFor:!UndoShowHide removeSelector: #undoShowFor:!Wonderland removeSelector: #addCamera!Wonderland removeSelector: #initializeStress!Wonderland removeSelector: #getScriptEditor!Wonderland class removeSelector: #newStress!WonderlandActor removeSelector: #lookAt:!WonderlandActor removeSelector: #turn:numberOfTurns:speed:!WonderlandActor removeSelector: #turn:speed:duration:!WonderlandActor removeSelector: #moveRightNow:distance:!WonderlandActor removeSelector: #turn:numberOfTurns:eachFrameUntil:!WonderlandActor removeSelector: #turn:numberOfTurns:duration:style:!WonderlandActor removeSelector: #roll:numberOfTurns:duration:style:!WonderlandActor removeSelector: #getRotation!WonderlandActor removeSelector: #move:distance:eachFrameUntil:!WonderlandActor removeSelector: #roll:numberOfTurns:speed:asSeenBy:!WonderlandActor removeSelector: #roll:numberOfTurns:eachFrameFor:!WonderlandActor removeSelector: #turn:numberOfTurns:asSeenBy:eachFrameFor:!WonderlandActor removeSelector: #turn:numberOfTurns:duration:asSeenBy:style:!WonderlandActor removeSelector: #setTextureWithoutUndo:!WonderlandActor removeSelector: #getChildren!WonderlandActor removeSelector: #roll:numberOfTurns:duration:asSeenBy:style:!WonderlandActor removeSelector: #roll:numberOfTurns:speed:!WonderlandActor removeSelector: #turn:numberOfTurns:eachFrameFor:!WonderlandActor removeSelector: #initialize!WonderlandActor removeSelector: #roll:numberOfTurns:eachFrameUntil:!WonderlandActor removeSelector: #move:distance:eachFrameFor:!WonderlandActor removeSelector: #turn:numberOfTurns:duration:!WonderlandActor removeSelector: #move:distance:asSeenBy:eachFrameFor:!WonderlandActor removeSelector: #setParent:!WonderlandActor removeSelector: #move:speed:duration:!WonderlandActor removeSelector: #getParent!WonderlandActor removeSelector: #roll:numberOfTurns:asSeenBy:eachFrameUntil:!WonderlandActor removeSelector: #turn:numberOfTurns:!WonderlandActor removeSelector: #move:speed:asSeenBy:duration:!WonderlandActor removeSelector: #roll:speed:duration:!WonderlandActor removeSelector: #getChild:!WonderlandActor removeSelector: #move:distance:asSeenBy:eachFrameUntil:!WonderlandActor removeSelector: #lookAt:up:!WonderlandActor removeSelector: #turn:numberOfTurns:duration:asSeenBy:!WonderlandActor removeSelector: #turn:numberOfTurns:speed:asSeenBy:!WonderlandActor removeSelector: #turn:numberOfTurns:asSeenBy:eachFrameUntil:!WonderlandActor removeSelector: #oldgetPositionInPicturePlane!WonderlandActor removeSelector: #turn:numberOfTurns:asSeenBy:!WonderlandActor removeSelector: #roll:numberOfTurns:!WonderlandActor removeSelector: #roll:numberOfTurns:duration:asSeenBy:!WonderlandActor removeSelector: #setSizeVector:!WonderlandActor removeSelector: #setWonderland:!WonderlandActor removeSelector: #roll:numberOfTurns:asSeenBy:eachFrameFor:!WonderlandActor removeSelector: #roll:numberOfTurns:duration:!WonderlandActor removeSelector: #roll:numberOfTurns:asSeenBy:!WonderlandActor class removeSelector: #new!WonderlandActorBrowser removeSelector: #actorsMenu:!WonderlandCamera removeSelector: #initialize!WonderlandCamera removeSelector: #transformScreenPointToScenePoint:asSeenBy:!WonderlandCamera removeSelector: #renderWith:!WonderlandCamera removeSelector: #setViewport:!WonderlandCamera removeSelector: #setWonderland:!WonderlandCamera removeSelector: #render!WonderlandCamera removeSelector: #transformScreenPointToScenePoint:scaledBy:!WonderlandCamera removeSelector: #getViewport!WonderlandCamera removeSelector: #transformScreenPointToScenePoint:scaledBy:asSeenBy:!WonderlandCamera removeSelector: #tdrawMesh:!WonderlandCamera removeSelector: #drawMesh:!WonderlandCamera class removeSelector: #new!WonderlandCameraControls removeSelector: #mouseMove:!WonderlandScene removeSelector: #initialize!WonderlandScene removeSelector: #setWonderland:!WonderlandScene removeSelector: #getColorVector:!WonderlandScene removeSelector: #setColorFromVector:!WonderlandScene removeSelector: #getChildren!WonderlandScene removeSelector: #addObject:!WonderlandScene class removeSelector: #new!WonderlandScriptEditor removeSelector: #openAsMorphLabel:inWorld:!WonderlandScriptEditor removeSelector: #externalname!WonderlandScriptEditor removeSelector: #externalName!WonderlandStyle initialize!WonderlandStyle class removeSelector: #initializeConstants!WonderlandVerifier class removeSelector: #ParseStyle:!WonderlandVerifier class removeSelector: #ParseActor:!WonderlandVerifier class removeSelector: #ParseLocation:!WonderlandVerifier class removeSelector: #ParseNumber:!WonderlandVerifier class removeSelector: #Verify0to1Number:!WonderlandVerifier class removeSelector: #ParseTarget:!WonderlandVerifier class removeSelector: #ParseDuration:!WonderlandVerifier class removeSelector: #ParseDirection:!Smalltalk removeClassNamed: #Actor!