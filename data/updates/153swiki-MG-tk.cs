'From Squeak 2.1 of June 30, 1998 on 15 July 1998 at 12:18:51 pm'!ServerAction subclass: #SwikiAction	instanceVariableNames: 'urlmap source name formatters '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!Object subclass: #SwikiPage	instanceVariableNames: 'url map formatted address file date coreID name user editReqDate editReqTime temp '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!HTMLformatter class methodsFor: 'translating' stamp: 'tk 7/15/1998 12:02'!forEvaluatingEmbedded: stringOrStream	"stringOrStream is text with <?expr?> expressions intermingled.  This creates a HTLMLformatter instance which will substitute the <?expr?> expressions with the value of the argument (named request), and which leaves all other text in stringOrStream alone"	| blockStream sourceStream doingEval ch |	blockStream _ WriteStream on: String new. 	blockStream nextPutAll: '[ :request :output | output nextPutAll: '''.	(stringOrStream isKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	doingEval _ false.	[sourceStream atEnd] whileFalse:  [		ch := sourceStream next.		(doingEval not and: [ ch = $<  and: [ sourceStream peek = $? ]]) ifTrue: [			"beginning of an <?...?> expression"			blockStream nextPutAll: '''.  output nextPutAll: ['.			sourceStream next.  "Skip the ?" 			doingEval _ true]		ifFalse: [		(doingEval and: [ ch = $? and: [ sourceStream peek = $> ]]) ifTrue: [			"end of a <?...?> expression"			blockStream nextPutAll: '] value asString.  output nextPutAll: '''.			sourceStream next.  "Skip the >" 			doingEval _ false.]		ifFalse: [			"normal char"			blockStream nextPut: ch.			(doingEval not and: [ ch = $' ]) ifTrue: [				 "double $' marks"  blockStream nextPut: $' ] ] ] ].	"end the block"	doingEval		ifTrue: [ blockStream nextPutAll: '] value asString' ]		ifFalse: [ blockStream nextPutAll: '''' ].	blockStream nextPutAll: ']'.	^HTMLformatter new formattingBlock: (Compiler evaluate: blockStream contents)! !!PWS methodsFor: 'Processing' stamp: 'tk 7/15/1998 12:06'!report: msg for: rec	"Write an error report."	| s |	self log: '*** ', rec asString, ': ', msg.	s _ (msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [msg]		ifFalse: ['HTTP/1.0 400 Bad Request -- ', self class crlfcrlf, msg].	[self reply: s] ifError: [:m :r | "ignore errors"].! !!PWS class methodsFor: 'Serving' stamp: 'tk 7/15/1998 11:27'!serveShowingErrorsOnPort: portNumber	"Start up the HTTP server loop for debugging!!  Operate in this process, synchronously.  Force errors to stop the server and show on the screen.."	| socket logEntry inst |	self stopServer.	Socket initializeNetwork.	ServerLog _ FileStream fileNamed: 'dummy.log'.	ServerLog position: ServerLog size.	ServerPort _ ConnectionQueue portNumber: portNumber queueLength: 6.	ClientNameCache _ Dictionary new.	[true] whileTrue: [		socket _ ServerPort getConnectionOrNil.		socket notNil 			ifTrue: ["serve:"				inst _ self new.				inst initializeFrom: socket.				inst getReply.				socket closeAndDestroy: 30.				logEntry _ inst log contents]		"no logging for now"			ifFalse: [(Delay forMilliseconds: 100) wait]].! !!SwikiAction commentStamp: 'tk 7/15/1998 12:18' prior: 0!SwikiAction is the action to implement a Swiki, a collaborative website.  This is a web server in Squeak.  Each page served has an "Edit this Page" link.  The syntax rules for editing pages (from any web browser) are in the file FormattingRules.The pages may be viewed from any web browser, and the URL is http://thisMachine:80/OurOwnArea.1  ('OurOwnArea' is the name of the Swiki area.)  See http://guzdial.cc.gatech.edu:8080/myswiki for an example focused on discussing Swikis.Swiki is based on the Wiki Server, designed and implemented by Ward Cunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or the Squeak-focused one at http://c2.com:8080/See PWS class howToStart.Modified by Ted Kaehler to have all state on the disk at all times.  Do not snapshot the image during normal server operation.  Restart the server by loading all state from the disk.Each separate Wiki is a folder inside the Server folder.  The name of the folder is the name of the Wiki.  Each page is a file.  (Inefficient on Macs because of large minimum page size, but that's an OS problem.)  All versions of all pages are kept.  Each page contains chunks, just like a changes file.  Each chunk is one version of one page:self name: 'Ted''s Page' date: '1/28/1998' time: '12:47:21' by: 'tk' text: 'Here is the body of the page' back: 116!!The last item is number of bytes in the chunk.  It is the number of bytes from the start of the chunk to just in front of the number.  This allows back-chaining to old versions.  On startup, the chunk is executed explicitly using evaluate:for:logged:.  It supplies the page name to a SwikiPage and installs it in the URLmap.  By doing this for all files in the folder, the map (url->page) is built.  During operation, the chunk is not executed.  Instead, take the file directly, look at 'back:' at the end, jump back to the start of the chunk, scan for 'text:' and read the text. The looks of the pages served are controlled by templates.  They live in the 'swiki' folder in the 'Server' folder.  See page.html for how to change the look of a served page.  Beware that templates are cached by HTMLformatter.  If you change a template, you will not see the effect until you reload the Swiki.  A symbol *append here* may be added anywhere in the page.  Clicking on it will bring up a page with a text editing form.  The what you type will be inserted just before the *append here* marker.  This allows append-only pages, or multiple questions with places to add to the answer.!]style[(671 20 1830)f1,f1LPWS class howToStart;,f1!!SwikiAction methodsFor: 'URL processing' stamp: 'tk 7/15/1998 12:03'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).			"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'page') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file ''page.html'' not found'].	request reply: htmlForUser. ! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 7/14/1998 19:23'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit""	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  store text in a specific place	{swikiname}.searchresult  {with a field named 'searchFor'} conducts the search for that text and sends back the result "	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf, 			((self formatterFor: 'recent') format: (urlmap searchFor: 						(request fields at: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap			storeID: coreRef			text: theText			from: request peerName.		page user: request userID.  "Address is machine, user only if logged in"		^ self].	"return self means do serve the edited page afterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fields printString; cr.! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 7/15/1998 12:08'!process: request 	"URLs are of the form:	 	{swikiname} 		browse Front Page	 	{swikiname}.{coreID} browse the page number coreID 	{swikiname}.{coreID}.edit  request to edit the page 	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}.insert.{placeID}  request to insert text in a specific place in a page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  store text in a specific place	-------	{swikiname}.{coreID}.all  displays the page and all its references 	{swikiname}.searchresult  conducts the search and displays the result 	{swikiname}.recent  to bring up the recent changes list 	{swikiname}.{coreID}.searchresult  returns a search for references to coreID's key 	{swikiname}.{picName}.gif   or .jpeg, .jpg, .jpe, .html (upper or lower case) return 	the picture or static page stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast pvtPageRef htmlForUser |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request reply: PWS success; 		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue: 			[request reply: PWS crlf , ((self formatterFor: 'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: 			["SearchResult, All, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue: 					[request reply: ((self formatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'insert' ifTrue: 					[pvtPageRef _ pageRef clone.					pvtPageRef placeID: (request message at: 4).	"so <?request placeID?> can get it"					htmlForUser _ ((self formatterFor: 'insert') format: pvtPageRef).					htmlForUser size = 0 ifTrue: [						self error: 'template file ''insert.html'' not found'].					request reply: htmlForUser. 					pageRef noteEditRequest.					^ self].			command = 'searchresult' ifTrue: 					[request reply: ((self formatterFor: 'results') 							format: (urlmap searchFor: pageRef name)).					^ self].			command = 'all' ifTrue: 					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: ((self formatterFor: 'page') format: formattedPage).					^ self].			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 7/6/1998 07:31'!checkAuthorization: request	^ authorizer ifNotNil: [authorizer user: request userID].! !!SwikiPage reorganize!('accessing' address address: coreID coreID: date date: file file: formatted formatted: lastEditTime map map: name name: noteEditRequest placeID placeID: text text: timeOfAccept url url: user user:)('save & restore' backupAChunk: chunk1 condenseChanges fromFileNamed:action: name:date:time:by:text:back: rollBack:at: scanFrom:)('insertion points' unique:in: uniqueInsertionPoints:)!!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID	"Temporarily hold onto the placeID value.  For putting into the FORM in insert.html"	^ temp! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID: idNum	"Temporarily hold onto the placeID value.  For putting into the FORM in insert.html"	temp _ idNum! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/13/1998 12:37'!text: aString	"Add onto the end of the file"	| this aFile start end realString |	realString _ self uniqueInsertionPoints: aString.	this _ String streamContents: [:ss | 		ss nextPutAll: self chunk1.		realString storeOn: ss.		ss nextPutAll: ' back: '].	(aFile _ FileStream fileNamed: file) setToEnd.	start _ aFile position.	aFile nextChunkPut: this; skip: -1.	"undo the !! at end"	end _ aFile position.	aFile nextPutAll: (end - start) printString; nextPut: $!!; cr; close.! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/13/1998 13:33'!unique: aTag in: aSet	"If aTag is not in aSet, put it in and return aTag.  If it's there, make up a new tag, insert it, and return it.  For keeping insertion points in text unique, so can tell where to put incoming text."	| base new |	((aSet includes: aTag) not and: [aTag size > 0]) ifTrue: [aSet add: aTag.  ^ aTag].	base _ 0.	[new _ (100 atRandom + base) printString.		aSet includes: new] whileTrue: 			[base _ base + 50].	aSet add: new.	^ new! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/14/1998 20:52'!uniqueInsertionPoints: aString	"Find all occurances of '*append here'.  Make them lower case.  If they don't have a number after them, assign one.  Don't use the same number twice in this page.  Place ID can actually be any string."	| sourceStream targetStream ids char pos inside rest |sourceStream := ReadStream on: aString.targetStream := WriteStream on: String new. ids _ Set new.	"id numbers that have been used"[sourceStream atEnd	] whileFalse: [	targetStream nextPut: (char _ sourceStream next).	char == $* ifTrue: [		pos _ sourceStream position.		inside _ sourceStream upTo: $*.		(inside asLowercase beginsWith: 'append here')			ifFalse: [sourceStream position: pos.	"ignore"				((inside = '') and: [sourceStream atEnd not]) ifTrue: [					targetStream nextPut: (char _ sourceStream next)]]	"Honor **"			ifTrue: ["See if it has a number"				targetStream nextPutAll: 'append here '.				rest _ inside copyFrom: (13 min: inside size +1) to: inside size.				targetStream nextPutAll: (self unique: rest in: ids); nextPut: $*]]].^ targetStream contents! !!URLmap methodsFor: 'linking' stamp: 'tk 7/12/1998 21:48'!linkFor: string from: peer storingTo: aList	| uString newpage fixed |uString _ string asUppercase.fixed _ (uString beginsWith: 'HTTP') or: [uString beginsWith: 'FTP'].("fixed _" fixed or: [uString beginsWith: 'MAILTO'])	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!! Gotta provide-a-link!!"		[newpage _ pages at: string asLowercase ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.].		(aList indexOf: newpage) = 0 ifTrue: [aList add: newpage]. "Add only if not there"		^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'tk 7/14/1998 11:28'!linkFor: string from: peer storingTo: aList page: aPage	| uString newpage fixed placeID |uString _ string asUppercase.(uString beginsWith: 'APPEND HERE') ifTrue: [	placeID _ uString copyFrom: (13 min: uString size) to: uString size.	^'<a href="', aPage url, '.insert.', placeID ,'">','Append Here','</a>'].	"later an image here"fixed _ (uString beginsWith: 'HTTP') or: [uString beginsWith: 'FTP'].("fixed _" fixed or: [uString beginsWith: 'MAILTO'])	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!! Gotta provide-a-link!!"		[newpage _ pages at: string asLowercase ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.].		(aList indexOf: newpage) = 0 ifTrue: [aList add: newpage]. "Add only if not there"		^self pageURL: newpage]! !!URLmap methodsFor: 'creating' stamp: 'tk 7/14/1998 19:32'!storeID: id text: insertedText insertAt: idString	"Insert in a place in the text.  Just before '*append here 34*' if idString is '34'."	| page bigText ind toInsert |	page _ self atID: id.	page date: (Date today).	bigText _ page text.	ind _ bigText findString: '*append here ',idString,'*' startingAt: 1.	"always lower case"	ind = 0 ifTrue: [^ page].		"could not find that place"	"Make sure new text surrounded by line feeds"	toInsert _ (insertedText last == Character linefeed)		ifTrue: [insertedText]		ifFalse: [insertedText, (String with: Character linefeed)].	((insertedText first == Character linefeed) or: [		(bigText at: (ind-1 max: 1)) == Character linefeed])			ifFalse: [toInsert _ (String with: Character linefeed), toInsert].	page text: (bigText copyReplaceFrom: ind to: ind-1 with: toInsert).	"page address: peer.  Don't sign with person who only added"	^ page! !