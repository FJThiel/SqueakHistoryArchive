"Change Set:		PluggableSetDictDate:			11 June 2000Author:			Daniel VainsencherThe pluggable classes are now not initialized with blocks, and assumethe regular =/hash definitions. This supports specializing preciselywhat part of the behavior you want without paying for the blockinvocations for both behaviors."!!PluggableDictionary methodsFor: 'accessing' stamp: 'dvf 6/10/200019:34'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	self equalBlock ifNotNil: [aSet equalBlock: self equalBlock fixTemps].	self hashBlock ifNotNil: [aSet hashBlock: self hashBlock fixTemps].	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:35'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableDictionary methodsFor: 'private' stamp: 'dvf 6/11/2000 01:33'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start _ (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableDictionary class methodsFor: 'as yet unclassified' stamp: 'dvf6/10/2000 18:13'!integerDictionary	^ self new hashBlock: [:integer | integer hash \\ 1064164 * 1009]! !!PluggableSet methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:34'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableSet methodsFor: 'private' stamp: 'dvf 6/11/2000 00:54'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start _ (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element _ array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableSet class methodsFor: 'as yet unclassified' stamp: 'dvf6/10/2000 18:13'!integerSet	^self new hashBlock: [:integer | integer hash \\ 1064164 * 1009]! !PluggableSet removeSelector: #init:!PluggableDictionary removeSelector: #init:!