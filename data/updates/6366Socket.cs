'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 3 November 2004 at 6:32:47 am'!"Change Set:		SocketDate:			3 November 2004Author:			Edgar J. De CleeneThis methods what once we have in OldSockets are needeed>"!!Socket methodsFor: 'receiving' stamp: 'edc 2/15/2004 09:17'!getData	| t1 t2 |	(self waitForDataUntil: Socket standardDeadline)		ifFalse: [self error: 'getData timeout'].	t1 _ String new: 4000.	t2 _ self				primSocket: socketHandle				receiveDataInto: t1				startingAt: 1				count: t1 size.	^ t1 copyFrom: 1 to: t2! !!Socket methodsFor: 'waiting' stamp: 'jm 3/2/98 18:15'!waitForConnectionUntil: deadline	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status |	status _ self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primSocketConnectionStatus: socketHandle].	^ status = Connected! !!Socket methodsFor: 'waiting' stamp: 'edc 2/15/2004 09:19'!waitForDataUntil: deadline 	"Wait up until the given deadline for data to arrive. Return true if data 	arrives by the deadline, false if not."	| dataArrived |	[self isConnected & (dataArrived := self primSocketReceiveDataAvailable: socketHandle) not		and: ["Connection end and final data can happen fast, so test in this 			order "			Time millisecondClockValue < deadline]]		whileTrue: [self readSemaphore waitTimeoutMSecs: deadline - Time millisecondClockValue].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'edc 10/5/2004 11:44'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| extraBytes status |	extraBytes := 0.	status := self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes := extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status := self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'edc 10/5/2004 11:42'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone := self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket methodsFor: 'sending-receiving objects' stamp: 'dgd 2/22/2002 20:28'!getObject	"gets a serialized object from this socket"	| encoded object |	encoded _ String new writeStream.	[encoded size isZero]		whileTrue: [encoded nextPutAll: self getData].	[self isConnected		and: [self dataAvailable]]		whileTrue: [encoded nextPutAll: self getData].	object _ ReferenceStream unStream: encoded contents.	^ object! !!Socket methodsFor: 'sending-receiving objects' stamp: 'dgd 2/22/2002 20:28'!sendObject: anObject 	"sends a serialized object to this socket"	| encoded |	encoded _ ReferenceStream streamedRepresentationOf: anObject.	self sendData: encoded! !Socket class removeSelector: #remoteCommClient!