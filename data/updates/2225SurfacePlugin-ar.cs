'From Squeak2.8alpha of 16 February 2000 [latest update: #2217] on 28 May 2000 at 1:15:59 pm'!"Change Set:		SurfacePlugin-arDate:			28 May 2000Author:			Andreas RaabPrimitive support for OS drawing surfaces. The surface plugin defines the interface for FXBlt which is used to	a) Query information about the drawing surface	b) Get your hands onto the bits of a drawing surface	c) Update Squeak's display using a specified drawing surfaceAll OS surface support should register external drawing surfaces with the surface plugin. This will give FXBlt a way of blitting to and from the external surface directly. Note that the functions provided by the surface plugin are minimal. All other support (such as creating and destroying the OS surface) must be done in specific subclasses of Form. See ExternalForm for an example of use."!ObjectMemory subclass: #Interpreter	instanceVariableNames: 'activeContext theHomeContext method receiver instructionPointer stackPointer localIP localSP localHomeContext messageSelector argumentCount newMethod currentBytecode successFlag primitiveIndex methodCache atCache lkupClass reclaimableContextCount nextPollTick nextWakeupTick lastTick interruptKeycode interruptPending semaphoresToSignal semaphoresToSignalCount savedWindowSize fullScreenFlag deferDisplayUpdates pendingFinalizationSignals compilerInitialized compilerHooks extraVMMemory interpreterVersion obsoleteIndexedPrimitiveTable obsoleteNamedPrimitiveTable interpreterProxy showSurfaceFn '	classVariableNames: 'ActiveProcessIndex AtCacheEntries AtCacheFixedFields AtCacheFmt AtCacheMask AtCacheOop AtCacheSize AtCacheTotalSize AtPutBase BlockArgumentCountIndex BytecodeTable CacheProbeMax CallerIndex CharacterValueIndex CompilerHooksSize CrossedX DirBadPath DirEntryFound DirNoMoreEntries EndOfRun ExcessSignalsIndex FirstLinkIndex HeaderIndex HomeIndex InitialIPIndex InstanceSpecificationIndex InstructionPointerIndex LastLinkIndex LiteralStart MaxPrimitiveIndex MessageArgumentsIndex MessageDictionaryIndex MessageLookupClassIndex MessageSelectorIndex MethodArrayIndex MethodCacheClass MethodCacheEntries MethodCacheEntrySize MethodCacheMask MethodCacheMethod MethodCachePrim MethodCacheSelector MethodCacheSize MethodIndex MyListIndex NextLinkIndex PrimitiveExternalCallIndex PrimitiveTable PriorityIndex ProcessListsIndex ReceiverIndex SelectorStart SemaphoresToSignalSize SenderIndex StackPointerIndex StreamArrayIndex StreamIndexIndex StreamReadLimitIndex StreamWriteLimitIndex SuperclassIndex SuspendedContextIndex TempFrameStart ValueIndex XIndex YIndex '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!InterpreterPlugin subclass: #SurfacePlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!SurfacePlugin commentStamp: '<historical>' prior: 0!This plugin is a fake. It doesn't do anything useful. It's sole purpose is to wrap the C code that's associated with the SurfacePlugin into the main VM generation process. Since the C code isn't easily generated from ST code this is (unfortunately) necessary. But look on the bright side - you don't have to define any weird stuff for the C compiler. Isn't that great?!! (just kidding...) !!Interpreter methodsFor: 'initialization' stamp: 'ar 5/26/2000 21:47'!moduleUnloaded: aModuleName	"The module with the given name was just unloaded.	Make sure we have no dangling references."	self export: true.	self var: #aModuleName type: 'char *'.	(aModuleName strcmp: 'SurfacePlugin') = 0 ifTrue:[		"Surface plugin went away. Should never happen. But then, who knows"		showSurfaceFn _ 0.	].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 5/26/2000 21:49'!displayBitsOf: aForm Left: l Top: t Right: r Bottom: b	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d left right top bottom surfaceHandle |	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	l < 0 ifTrue:[left _ 0] ifFalse:[left _ l].	r > w ifTrue:[right _ w] ifFalse:[right _ r].	t < 0 ifTrue:[top _ 0] ifFalse:[top _ t].	b > h ifTrue:[bottom _ h] ifFalse:[bottom _ b].	((left <= right) and: [top <= bottom]) ifFalse:[^nil].	successFlag ifTrue: [		(self isIntegerObject: dispBits) ifTrue:[			surfaceHandle _ self integerValueOf: dispBits.			showSurfaceFn = 0 ifTrue:[				showSurfaceFn _ self ioLoadFunction: 'ioShowSurface' From: 'SurfacePlugin'.				showSurfaceFn = 0 ifTrue:[^self success: false]].			self cCode:'((int (*) (int, int, int, int, int))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top)'.		] ifFalse:[			dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"			self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom)'				inSmalltalk:[self showDisplayBits: dispBitsIndex 								w: w h: h d: d								left: left right: right top: top bottom: bottom]		].	].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 5/26/2000 21:40'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj w h |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		self displayBitsOf: displayObj Left: 0 Top: 0 Right: w Bottom: h.		self ioForceDisplayUpdate].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 5/26/2000 21:44'!reverseDisplayFrom: startIndex to: endIndex	"Reverse the given range of Display words (at different bit depths, this will reverse different numbers of pixels). Used to give feedback during VM activities such as garbage collection when debugging. It is assumed that the given word range falls entirely within the first line of the Display."	| displayObj dispBitsPtr w reversed |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4])		ifFalse: [^ nil].	w _ self fetchInteger: 1 ofObject: displayObj.	dispBitsPtr _ (self fetchPointer: 0 ofObject: displayObj).	(self isIntegerObject: dispBitsPtr) ifTrue:[^nil].	dispBitsPtr _ BaseHeaderSize + BaseHeaderSize.	dispBitsPtr + (startIndex * 4) to: dispBitsPtr + (endIndex * 4) by: 4 do: [:ptr |		reversed _ (self longAt: ptr) bitXor: 16rFFFFFFFF.		self longAt: ptr put: reversed].	self displayBitsOf: displayObj Left: 0 Top: 0 Right: w Bottom: 1.	self ioForceDisplayUpdate.! !!Interpreter methodsFor: 'other primitives' stamp: 'ar 5/26/2000 21:52'!primitiveUnloadModule	"Primitive. Unload the module with the given name."	"Reloading of the module will happen *later* automatically, when a 	function from it is called. This is ensured by invalidating current sessionID."	| moduleName |	self methodArgumentCount = 1 ifFalse:[^self success: false].	moduleName _ self stackValue: 0.	(self isIntegerObject: moduleName) ifTrue:[^self success: false].	(self isBytes: moduleName) ifFalse:[^self success: false].	(self ioUnloadModule: (self cCoerce: (self firstIndexableField: moduleName) to: 'int')		OfLength: (self byteSizeOf: moduleName)) ifFalse:[^self success: false].	self flushExternalPrimitives.	self pop: 1 "pop moduleName; return receiver"! !!Interpreter class methodsFor: 'translation' stamp: 'ar 5/26/2000 21:57'!storeExports: exports on: aFilename	| s |	"Store the exports on the given file"	s _ CrLfFileStream newFileNamed: aFilename.	s nextPutAll:'/* This is an automatically generated table of all named primitive in the VM */'; cr;cr.	s nextPutAll:'/* Function prototypes */'; cr.	exports do:[:assoc|		assoc value do:[:primName|			s nextPutAll:'int '.			assoc key size > 0 ifTrue:[				s nextPutAll: assoc key; nextPutAll:'_'].			s nextPutAll: primName; nextPutAll:'(void);'; cr.		].	].	s nextPutAll:'/* extra (platform specific) prototypes */'; cr.	s nextPutAll:'#define XFN(name) int name(void);'; cr.	s nextPutAll:'#define XFN2(module, name) int module##_##name(void);'; cr.	s nextPutAll:'#include "platform.exports"'; cr.	s nextPutAll:'#undef XFN'; cr.	s nextPutAll:'#undef XFN2'; cr.	s cr; cr.	s nextPutAll:'/* Function names */'; cr.	s nextPutAll:'char *internalPrimitiveNames[][2] = {';cr.	exports do:[:assoc|		assoc value do:[:primName|			s nextPutAll:'{ "'; nextPutAll: assoc key; nextPutAll:'", '.			s nextPutAll:'"'; nextPutAll: primName; nextPutAll:'" },'; cr.		].	].	s nextPutAll:'/* extra (platform specific) names */'; cr.	s nextPutAll:'#define XFN(name) { "", #name },'; cr.	s nextPutAll:'#define XFN2(module, name) { #module, #name },'; cr.	s nextPutAll:'#include "platform.exports"'; cr.	s nextPutAll:'#undef XFN'; cr.	s nextPutAll:'#undef XFN2'; cr.	s nextPutAll:'{ NULL, NULL }'; cr; nextPutAll:'};'.	s cr; cr.	s nextPutAll:'/* Function addresses */'; cr.	s nextPutAll:'void *internalPrimitiveAddresses[] = {'; cr.	exports do:[:assoc|		assoc value do:[:primName|			s nextPutAll:'(void*)'.			assoc key size > 0 ifTrue:[				s nextPutAll: assoc key; nextPutAll:'_'].			s nextPutAll: primName; nextPutAll:','; cr.		].	].	s nextPutAll:'/* extra (platform specific) addresses */'; cr.	s nextPutAll:'#define XFN(name) (void*) name,'; cr.	s nextPutAll:'#define XFN2(module, name) (void*) module##_##name,'; cr.	s nextPutAll:'#include "platform.exports"'; cr.	s nextPutAll:'#undef XFN'; cr.	s nextPutAll:'#undef XFN2'; cr.	s nextPutAll:'NULL'; cr; nextPutAll:'};'.	s cr; cr.	s close.! !!Interpreter class methodsFor: 'translation' stamp: 'ar 5/26/2000 22:46'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	"Interpreter patchInterp: 'Squeak VM PPC'"	| cg exports |	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	"Get all the named prims from the VM.	Note: the format of exports is:		pluginName -> Array of: primitiveName.	so we can generate a nice table from it."	exports _ Array with: '' -> cg exportedPrimitiveNames asArray.	cg storeCodeOnFile: fileName doInlining: inlineFlag.	"Add our plugins"	{		"Graphics"			"Note: BitBltSimulation should go first, 			because three of it's entries might be 			looked up quite often (due to refs from 			InterpreterProxy). This will go away at			some point but for now it's a good idea			to have those entries early in the table."		BitBltSimulation.			BalloonEnginePlugin. 		SurfacePlugin. "To support OS surfaces through FXBlt"		"I/O subsystems"		FilePlugin.		SocketPlugin. 		SoundPlugin. 		MIDIPlugin. 		SerialPlugin. 		JoystickTabletPlugin. 		AsynchFilePlugin. 	 	"Numerics"		LargeIntegersPlugin.		FFTPlugin. 		FloatArrayPlugin. 		Matrix2x3Plugin. 		"Compression"		DeflatePlugin.		"Note: Optionally, you can translate the following as builtins.		As of Squeak 2.7 they are not builtins by default:			DSAPlugin.			KlattSynthesizerPlugin.			SoundCodecPlugin.			B3DEnginePlugin.			FFIPlugin.		"	} do:[:plugin|		cg _ plugin translate: plugin moduleName, '.c'					doInlining: inlineFlag					locally: true.		exports _ exports copyWith: 			(plugin moduleName -> cg exportedPrimitiveNames asArray).	].	self storeExports: exports on: 'sqNamedPrims.h'.! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:33'!initialiseModule	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioFindSurface	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioGetSurfaceFormat	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioLockSurface	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioRegisterSurface	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioShowSurface	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioUnlockSurface	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:34'!ioUnregisterSurface	"Fake entry point"	self export: true! !!SurfacePlugin methodsFor: 'fake entry points' stamp: 'ar 5/26/2000 22:33'!shutdownModule	"Fake entry point"	self export: true! !!SurfacePlugin class methodsFor: 'translation' stamp: 'ar 5/26/2000 22:32'!headerFile^'#ifndef __SQ_DRAW_SURFACE_H#define __SQ_DRAW_SURFACE_H/* v1.0 */#define SQ_SURFACE_MAJOR 1#define SQ_SURFACE_MINOR 0/* Plugins creating their own surfaces must register these using   the following set of functions. The typedefs are for easier casts. */typedef int (*fn_getSurfaceFormat)(int surfaceHandle, int* width, int* height, int* depth, int* isMSB);typedef int (*fn_lockSurface)(int surfaceHandle, int *pitch, int x, int y, int w, int h);typedef int (*fn_unlockSurface)(int surfaceHandle, int x, int y, int w, int h);typedef int (*fn_showSurface)(int surfaceHandle, int x, int y, int w, int h);typedef struct sqSurfaceDispatch {	/* Version information. Must be provided by the client	   so the surface manager can check if certain operations	   are supported. */	int majorVersion;	int minorVersion;	/* Version 1.0 */	fn_getSurfaceFormat getSurfaceFormat;	fn_lockSurface lockSurface;	fn_unlockSurface unlockSurface;	fn_showSurface showSurface;} sqSurfaceDispatch;/* The functions for sqSurfaceDispatch are:	int getSurfaceFormat(int handle, int* width, int* height, int* depth, int* isMSB);		Return general information about the OS drawing surface.		Return true if successful, false otherwise.		The returned values describe the basic properties such as		width, height, depth and LSB vs. MSB pixels.	int lockSurface(int handle, int *pitch, int x, int y, int w, int h);		Lock the bits of the surface.		Return a pointer to the actual surface bits, or NULL on failure.		If successful, store the pitch of the surface (e.g., the bytes		per scan line).		For equal source/dest handles only one locking operation is performed.		This is to prevent locking of overlapping areas which does not work with		certain APIs (e.g., DirectDraw prevents locking of overlapping areas). 		A special case for non-overlapping but equal source/dest handle would 		be possible but we would have to transfer this information over to 		unlockSurfaces somehow (currently, only one unlock operation is 		performed for equal source and dest handles). Also, this would require		a change in the notion of ioLockSurface() which is right now interpreted		as a hint and not as a requirement to lock only the specific portion of		the surface.		The arguments in ioLockSurface() provide the implementation with		an explicit hint what area is affected. It can be very useful to		know the max. affected area beforehand if getting the bits requires expensive		copy operations (e.g., like a roundtrip to the X server or a glReadPixel op).		However, the returned pointer *MUST* point to the virtual origin of the surface		and not to the beginning of the rectangle. The promise made by BitBlt		is to never access data outside the given rectangle (aligned to 4byte boundaries!!)		so it is okay to return a pointer to the virtual origin that is actually outside		the valid memory area.		The area provided in ioLockSurface() is already clipped (e.g., it will always		be inside the source and dest boundingBox) but it is not aligned to word boundaries		yet. It is up to the support code to compute accurate alignment if necessary.	int unlockSurface(int handle, int x, int y, int w, int h);		Unlock the bits of a (possibly modified) surface after BitBlt completed.		The return value is ignored.		The arguments provided specify the dirty region of the surface. If the		surface is unmodified all arguments are set to zero.	int showSurface(int handle, int x, int y, int w, int h);		Display the contents of the surface on the actual screen.		If ioShowSurface() is called the surface in question represents		a Squeak DisplayScreen.	FXBlt uses a variant of the above functions which are exported from	the surface plugin:	int ioGetSurfaceFormat(int surfaceID, int* width, int* height, int* depth, int* isMSB);	int ioLockSurface(int surfaceID, int *pitch, int x, int y, int w, int h);	int ioUnlockSurface(int surfaceID, int x, int y, int w, int h);	These functions are looked up in the registered surfaces and invoked	as appropriate. The meaning of all values is exactly the same as for	the functions specified in sqSurfaceDispatch with the exception that	the surfaceID represents the ''bits'' handle of the Form that is used	within FXBlt.	Interpreter itself uses a separate entry point for updating the display	int ioShowSurface(int surfaceID, int x, int y, int w, int h);	since the management of deferred updates is currently an intrinsic	property of the VM (which is bad - deferred updates should be a	property of the DisplayScreen in question and not of the VM but	that''s the way it is...).*//* The following are the entry points for the surface manager:	int ioRegisterSurface(int surfaceHandle, sqSurfaceDispatch *fn, int *surfaceID);		Register a new surface with the given handle and		the set of surface functions. The new ID is returned		in surfaceID. Returns true if successful, false 		otherwise.	int ioUnregisterSurface(int surfaceID);		Unregister the surface with the given handle.		Returns true if successful, false otherwise.	int ioFindSurface(int surfaceID, sqSurfaceDispatch *fn, int *surfaceHandle);		Find the surface with the given ID, and, optionally,		the given set of surface functions. The registered handle		is returned in surfaceHandle. Return true if successful		(e.g., the surface has been found), false otherwise.	The above entry points can be looked up through the interpreter, e.g., using		interpreterProxy->ioLoadFunctionFrom("ioRegisterSurface","SurfacePlugin");	The typedefs below are for easier casts.*/typedef int (*fn_ioRegisterSurface)(int surfaceHandle, sqSurfaceDispatch *fn, int *surfaceID);typedef int (*fn_ioUnregisterSurface)(int surfaceID);typedef int (*fn_ioFindSurface)(int surfaceID, sqSurfaceDispatch *fn, int *surfaceHandle);#endif /* __SQ_DRAW_SURFACE_H */'! !!SurfacePlugin class methodsFor: 'translation' stamp: 'ar 5/26/2000 22:45'!sourceCode^'/*	This file contains the low-level support code for OS	surfaces. Since FXBlt may operate on any of these	some functions must be provided by the client. It is	crucial that every client creating surfaces for use	by Squeak registers the surfaces using the functions	provided here. Other concrete primitives (such as	creation or destroy) of surfaces can be handled by	additional support code, querying the surface handle	from ioFindSurface but the functions provided below	are critical for any BitBlt operations.*/#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqVirtualMachine.h"#include "sqConfig.h"#include "sqPlatformSpecific.h"#include "SurfacePlugin.h"/* The definition below will be replaced by 0/1 when the file is generated */#if $$SURFACE_PLUGIN_STANDALONE$$# define XNAME(string) string#else# define XNAME(string) SurfacePlugin_##string#endiftypedef struct SqueakSurface {	int handle; /* client supplied handle */	sqSurfaceDispatch *dispatch;} SqueakSurface;static SqueakSurface *surfaceArray = NULL;static int numSurfaces = 0;static int maxSurfaces = 0;static const char *moduleName = "SurfacePlugin";static VirtualMachine *interpreterProxy;#define FAIL { interpreterProxy->primitiveFail(); return 0; }#pragma export on/* module initialization/shutdown */EXPORT(int) XNAME(setInterpreter)(struct VirtualMachine *interpreterProxy);EXPORT(const char*) XNAME(getModuleName)(void);EXPORT(int) XNAME(initialiseModule)(void);EXPORT(int) XNAME(shutdownModule)(void);/* critical FXBlt entry points */EXPORT(int) XNAME(ioGetSurfaceFormat) (int surfaceID, int* width, int* height, int* depth, int* isMSB);EXPORT(int) XNAME(ioLockSurface) (int surfaceID, int *pitch, int x, int y, int w, int h);EXPORT(int) XNAME(ioUnlockSurface)(int surfaceID, int x, int y, int w, int h);/* interpreter entry point */EXPORT(int) XNAME(ioShowSurface)(int surfaceID, int x, int y, int w, int h);/* client entry points */EXPORT(int) XNAME(ioRegisterSurface)(int surfaceHandle, sqSurfaceDispatch *fn, int *surfaceID);EXPORT(int) XNAME(ioUnregisterSurface)(int surfaceID);EXPORT(int) XNAME(ioFindSurface)(int surfaceID, sqSurfaceDispatch *fn, int *surfaceHandle);#pragma export off/* ioGetSurfaceFormat:	Return information describing the given surface.	Return true if successful, false otherwise. */EXPORT(int) XNAME(ioGetSurfaceFormat) (int surfaceID, int* width, int* height, int* depth, int* isMSB){	SqueakSurface *surface;	if(surfaceID < 0 || surfaceID >= maxSurfaces) FAIL;	surface = surfaceArray + surfaceID;	if(surface->dispatch == NULL) FAIL;	if(!!surface->dispatch->getSurfaceFormat) FAIL;	return surface->dispatch->getSurfaceFormat(surface->handle, width, height, depth, isMSB);}/* ioLockSurface:	Lock the bits of the surface. 	Return a pointer to the actual surface bits,	or NULL on failure. */EXPORT(int) XNAME(ioLockSurface) (int surfaceID, int *pitch, int x, int y, int w, int h){	SqueakSurface *surface;	if(surfaceID < 0 || surfaceID >= maxSurfaces) FAIL;	surface = surfaceArray + surfaceID;	if(surface->dispatch == NULL) FAIL;	if(!!surface->dispatch->lockSurface) FAIL;	return surface->dispatch->lockSurface(surface->handle, pitch, x, y, w, h);}/* ioUnlockSurface:	Unlock the bits of the surface. 	The return value is ignored. */EXPORT(int) XNAME(ioUnlockSurface)(int surfaceID, int x, int y, int w, int h){	SqueakSurface *surface;	if(surfaceID < 0 || surfaceID >= maxSurfaces) FAIL;	surface = surfaceArray + surfaceID;	if(surface->dispatch == NULL) FAIL;	if(!!surface->dispatch->unlockSurface) FAIL;	return surface->dispatch->unlockSurface(surface->handle, x, y, w, h);}/* ioShowSurface:	Transfer the bits of a surface to the screen. */EXPORT(int) XNAME(ioShowSurface)(int surfaceID, int x, int y, int w, int h){	SqueakSurface *surface;	if(surfaceID < 0 || surfaceID >= maxSurfaces) FAIL;	surface = surfaceArray + surfaceID;	if(surface->dispatch == NULL) FAIL;	if(!!surface->dispatch->showSurface) FAIL;	return surface->dispatch->showSurface(surface->handle, x, y, w, h);}/* ioRegisterSurface:	Register a new surface with the given handle and	the set of surface functions. The new ID is returned	in surfaceID. Returns true if successful, false 	otherwise. */EXPORT(int) XNAME(ioRegisterSurface)(int surfaceHandle, sqSurfaceDispatch *fn, int *surfaceID){	int index;	if(!!fn) return 0;	if(fn->majorVersion !!= 1 && fn->minorVersion !!= 0) return 0;	if(numSurfaces == maxSurfaces) {		maxSurfaces = maxSurfaces * 2 + 10;		surfaceArray = realloc(surfaceArray, sizeof(SqueakSurface) * maxSurfaces);		for(index = numSurfaces; index < maxSurfaces; index++){			surfaceArray[index].handle = 0;			surfaceArray[index].dispatch = NULL;		}		index = numSurfaces;	} else {		for(index = 0; index < maxSurfaces; index++)			if(surfaceArray[index].dispatch == NULL)				break;	}	if(index >= maxSurfaces) return 0; /* should not happen */	surfaceArray[index].handle = surfaceHandle;	surfaceArray[index].dispatch = fn;	*surfaceID = index;	numSurfaces++;	return 1;}/* ioUnregisterSurface:	Unregister the surface with the given handle.	Returns true if successful, false otherwise. */EXPORT(int) XNAME(ioUnregisterSurface)(int surfaceID){	SqueakSurface *surface;	if(surfaceID < 0 || surfaceID >= maxSurfaces) return 0;	surface = surfaceArray + surfaceID;	if(surface->dispatch == NULL) return 0;	surface->handle = 0;	surface->dispatch = NULL;	numSurfaces--;	return 1;}/* ioFindSurface:	Find the surface with the given ID, and, optionally,	the given set of surface functions. The registered handle	is returned in surfaceHandle. Return true if successful	(e.g., the surface has been found), false otherwise. */EXPORT(int) XNAME(ioFindSurface)(int surfaceID, sqSurfaceDispatch *fn, int *surfaceHandle){	SqueakSurface *surface;	if(surfaceID < 0 || surfaceID >= maxSurfaces) return 0;	surface = surfaceArray + surfaceID;	if(surface->dispatch == NULL) return 0;	if(fn && fn !!= surface->dispatch) return 0;	*surfaceHandle = surface->handle;	return 1;}EXPORT(int) XNAME(setInterpreter)(struct VirtualMachine* anInterpreter) {    int ok;	interpreterProxy = anInterpreter;	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;	if (ok == 0) {		return 0;	}	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;	return ok;}EXPORT(const char*) XNAME(getModuleName)(void) {	return moduleName;}EXPORT(int) XNAME(initialiseModule)() {	surfaceArray = NULL;	numSurfaces = 0;	maxSurfaces = 0;	return 1;}EXPORT(int) XNAME(shutdownModule)() {	/* This module can only be shut down if no surfaces are registered */	if(numSurfaces !!= 0) return 0;	free(surfaceArray);	return 1;}'! !!SurfacePlugin class methodsFor: 'translation' stamp: 'ar 5/26/2000 22:42'!translate: fileName doInlining: inlineFlag locally: localFlag	"Time millisecondsToRun: [		SurfacePlugin translate.		Smalltalk beep]"	| cg theClass fullName fd |	fullName _ self baseDirectoryName.	fd _ FileDirectory on: fullName.	localFlag ifFalse:[		(fd directoryExists: self moduleName) 			ifFalse:[fd createDirectory: self moduleName].		fd _ fd on: (fd fullNameFor: self moduleName)].	fullName _ fd fullNameFor: fileName.	self initialize.	self headerFile ifNotNil:[		(CrLfFileStream newFileNamed: (fd fullNameFor: self moduleName,'.h'))			nextPutAll: self headerFile;			close].	cg _ self codeGeneratorClass new initialize.	localFlag ifTrue:[cg pluginPrefix: self moduleName].	"Add an extra declaration for module name"	cg var: #moduleName declareC:'const char *moduleName = "', self moduleName,'"'.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	"cg storeCodeOnFile: fullName doInlining: inlineFlag."	(CrLfFileStream newFileNamed: (fd fullNameFor: self moduleName,'.c'))		nextPutAll: 			(self sourceCode 				copyReplaceAll:'$$SURFACE_PLUGIN_STANDALONE$$'				with: (localFlag ifTrue:['0'] ifFalse:['1']));		close.	^cg! !