'From Squeak 2.0 BETA of May 8, 1998 on 13 May 1998 at 12:45:54 pm'!Object subclass: #ServerDirectory	instanceVariableNames: 'server directory type user passwordHolder group moniker url '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 5/13/1998 12:33'!lookFor: beginning	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	Transcript show: resp; cr.	resp size > 0 		ifTrue: [			(resp beginsWith: beginning) ifTrue: [^ true].	"exactly what we wanted"			(resp at: 1) == $2 ifTrue: [^ self lookFor: beginning]]				"Just a chatty server, keep looking"		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!ServerDirectory commentStamp: 'tk 5/13/1998 12:45' prior: 0!Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.url			When a FTP server holds some web pages, the url of those pages is often			different from the FTP directory.  Put the url here.  If the directory is 			'public_html/Squeak/', the url might be 'www.webPage.com/~kaehler2/Squeak/'!]style[(615 8 464)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/13/1998 12:43'!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so resp portInfo list dataPort dd rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 Password') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 User') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 CWD') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	so sendCommand: 'TYPE L 8'.	(rr _ so lookFor: '200 Type') == true ifFalse: [^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	Transcript show: resp; cr.	(resp beginsWith: '227 Entering Passive Mode (') ifFalse: [		so sendCommand: 'QUIT'.		so destroy.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/13/1998 12:05'!checkServers	"Check that all servers are up and have the latest Updates.list.  Return the servers that ready to receiver this update"	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		this class == String ifTrue: [			strm _ HTTPSocket httpGet: url accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile.			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: this.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/13/1998 11:24'!url	^ url! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/13/1998 11:24'!url: aString	url _ aString! !!SmartRefStream methodsFor: 'conversion' stamp: 'tk 5/12/1998 16:18'!layoutMorphbosfcepcbbochvimol0	^ AlignmentMorph! !