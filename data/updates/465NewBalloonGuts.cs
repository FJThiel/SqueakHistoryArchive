'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 10:01:44 pm'!Object subclass: #BalloonEngine	instanceVariableNames: 'workBuffer span bitBlt forms clipRect destOffset externals aaLevel edgeTransform colorTransform deferred postFlushNeeded '	classVariableNames: 'BezierStats BufferCache CacheProtect Counts Debug Times '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!InterpreterPlugin subclass: #BalloonEngineBase	instanceVariableNames: 'workBuffer objBuffer getBuffer aetBuffer spanBuffer engine formArray engineStopped geProfileTime dispatchedValue dispatchReturnValue objUsed '	classVariableNames: 'EdgeInitTable EdgeStepTable FillTable WideLineFillTable WideLineWidthTable '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!CArrayAccessor subclass: #CPluggableAccessor	instanceVariableNames: 'readBlock writeBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:52'!floatAt: index	"For simulation only"	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:52'!floatAt: index put: value	"For simulation only"	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!BalloonBuffer methodsFor: 'private' stamp: 'ar 11/24/1998 20:52'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!BalloonBuffer methodsFor: 'private' stamp: 'ar 11/24/1998 20:52'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.	^value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!colorTransform	self returnTypeC:'float *'.	^self cCoerce: workBuffer + GWColorTransform to:'float *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 20:28'!currentZGet	^workBuffer at: GWCurrentZ! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 20:29'!currentZPut: value	^workBuffer at: GWCurrentZ put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!edgeTransform	self returnTypeC:'float *'.	^self cCoerce: workBuffer + GWEdgeTransform to:'float *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!hasColorTransformGet	^workBuffer at: GWHasColorTransform! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!hasColorTransformPut: value	^workBuffer at: GWHasColorTransform put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:36'!hasEdgeTransformGet	^workBuffer at: GWHasEdgeTransform! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/24/1998 21:35'!hasEdgeTransformPut: value	^workBuffer at: GWHasEdgeTransform put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/25/1998 00:20'!needsFlushGet	^workBuffer at: GWNeedsFlush! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/25/1998 00:20'!needsFlushPut: value	^workBuffer at: GWNeedsFlush put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:22'!obj: object at: index	^objBuffer at: object + index! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:22'!obj: object at: index put: value	^objBuffer at: object + index put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:02'!objectHeaderOf: obj	^self makeUnsignedFrom:(self obj: obj at: GEObjectType)! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectIndexOf: obj	^self obj: obj at: GEObjectIndex! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectIndexOf: obj put: value	^self obj: obj at: GEObjectIndex put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectLengthOf: obj	^self obj: obj at: GEObjectLength! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectLengthOf: obj put: value	^self obj: obj at: GEObjectLength put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectTypeOf: obj	^(self makeUnsignedFrom:(self obj: obj at: GEObjectType)) bitAnd: GEPrimitiveTypeMask! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/24/1998 22:03'!objectTypeOf: obj put: value	^self obj: obj at: GEObjectType put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeLeftFillOf: edge	^self obj: edge at: GEFillIndexLeft! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeLeftFillOf: edge put: value	^self obj: edge at: GEFillIndexLeft put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeNumLinesOf: edge	^self obj: edge at: GENumLines! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:04'!edgeNumLinesOf: edge put: value	^self obj: edge at: GENumLines put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeRightFillOf: edge	^self obj: edge at: GEFillIndexRight! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeRightFillOf: edge put: value	^self obj: edge at: GEFillIndexRight put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeXValueOf: edge	^self obj: edge at: GEXValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeXValueOf: edge put: value	^self obj: edge at: GEXValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:05'!edgeYValueOf: edge	^self obj: edge at: GEYValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:06'!edgeYValueOf: edge put: value	^self obj: edge at: GEYValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:06'!edgeZValueOf: edge	^self obj: edge at: GEZValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/24/1998 22:06'!edgeZValueOf: edge put: value	^self obj: edge at: GEZValue put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:31'!stackFillEntryLength	^3! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:35'!stackFillRightX: index	^self wbStackValue: index+2! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:35'!stackFillRightX: index put: value	^self wbStackValue: index+2 put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:49'!topDepth	self stackFillSize = 0		ifTrue:[^-1]		ifFalse:[^self topFillDepth].! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:36'!topFillRightX	^self stackFillRightX: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 14:36'!topFillRightXPut: value	^self stackFillRightX: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/25/1998 15:19'!topRightX	self stackFillSize = 0		ifTrue:[^999999999]		ifFalse:[^self topFillRightX].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/24/1998 20:05'!loadArrayTransformFrom: transformOop into: destPtr length: n	"Load a transformation from the given array."	| value |	self inline: false.	self var: #destPtr declareC:'float *destPtr'.	0 to: n-1 do:[:i|		value _ interpreterProxy fetchPointer: i ofObject: transformOop.		((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])			ifFalse:[^interpreterProxy primitiveFail].		(interpreterProxy isIntegerObject: value)			ifTrue:[destPtr at: i put: 				(self cCoerce: (interpreterProxy integerValueOf: value) asFloat to:'float')]			ifFalse:[destPtr at: i put: 				(self cCoerce: (interpreterProxy floatValueOf: value) to: 'float')].	].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 21:04'!loadColorTransformFrom: transformOop	"Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise"	| okay transform |	self var: #transform declareC:'float *transform'.	transform _ self colorTransform.	self hasColorTransformPut: 0.	okay _ self loadTransformFrom: transformOop into: transform length: 8.	okay ifFalse:[^false].	self hasColorTransformPut: 1.	"Scale transform to be in 0-256 range"	transform at: 1 put: (transform at: 1) * (self cCoerce: 256.0 to:'float').	transform at: 3 put: (transform at: 3) * (self cCoerce: 256.0 to:'float').	transform at: 5 put: (transform at: 5) * (self cCoerce: 256.0 to:'float').	transform at: 7 put: (transform at: 7) * (self cCoerce: 256.0 to:'float').	^okay! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/24/1998 21:33'!loadEdgeTransformFrom: transformOop	"Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise"	| transform okay |	self inline: false.	self var: #transform declareC:'float *transform'.	self hasEdgeTransformPut: 0.	transform _ self edgeTransform.	okay _ self loadTransformFrom: transformOop into: transform length: 6.	interpreterProxy failed ifTrue:[^nil].	okay ifFalse:[^false].	self hasEdgeTransformPut: 1.	"Add the fill offset to the matrix"	transform at: 2 put: 		(self cCoerce: (transform at: 2) + self destOffsetXGet asFloat to:'float').	transform at: 5 put: 		(self cCoerce: (transform at: 5) + self destOffsetYGet asFloat to:'float').	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 17:26'!loadFormsFrom: arrayOop	"Check all the forms from arrayOop."	| formOop bmBits bmBitsSize bmWidth bmHeight bmDepth ppw bmRaster |	(interpreterProxy fetchClassOf: arrayOop) == interpreterProxy classArray		ifFalse:[^false].	formArray _ arrayOop.	0 to: (interpreterProxy slotSizeOf: formArray) - 1 do:[:i|		formOop _ interpreterProxy fetchPointer: i ofObject: formArray.		(interpreterProxy isIntegerObject: formOop) ifTrue:[^false].		(interpreterProxy isPointers: formOop) ifFalse:[^false].		(interpreterProxy slotSizeOf: formOop) < 5 ifTrue:[^false].		bmBits _ interpreterProxy fetchPointer: 0 ofObject: formOop.		(interpreterProxy fetchClassOf: bmBits) == interpreterProxy classBitmap			ifFalse:[^false].		bmBitsSize _ interpreterProxy slotSizeOf: bmBits.		bmWidth _ interpreterProxy fetchInteger: 1 ofObject: formOop.		bmHeight _ interpreterProxy fetchInteger: 2 ofObject: formOop.		bmDepth _ interpreterProxy fetchInteger: 3 ofObject: formOop.		interpreterProxy failed ifTrue:[^false].		(bmWidth >= 0 and:[bmHeight >= 0]) ifFalse:[^false].		ppw _ 32 // bmDepth.		bmRaster _ bmWidth + (ppw-1) // ppw.		bmBitsSize = (bmRaster * bmHeight)			ifFalse:[^false].	].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 23:22'!loadTransformFrom: transformOop into: destPtr length: n	"Load a transformation from transformOop into the float array	defined by destPtr. The transformation is assumed to be either	an array or a FloatArray of length n."	self inline: false.	self var: #destPtr declareC:'float *destPtr'.	transformOop = interpreterProxy nilObject ifTrue:[^false].	(interpreterProxy isIntegerObject: transformOop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: transformOop) = n 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: transformOop) 		ifTrue:[self loadWordTransformFrom: transformOop into: destPtr length: n]		ifFalse:[self loadArrayTransformFrom: transformOop into: destPtr length: n].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/24/1998 20:03'!loadWordTransformFrom: transformOop into: destPtr length: n	"Load a float array transformation from the given oop"	| srcPtr |	self inline: false.	self var: #srcPtr declareC:'float *srcPtr'.	self var: #destPtr declareC:'float *destPtr'.	srcPtr _ self cCoerce: (interpreterProxy firstIndexableField: transformOop) to: 'float *'.	0 to: n-1 do:[:i| destPtr at: i put: (srcPtr at: i)].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/25/1998 00:36'!quickLoadEngineFrom: engineOop	"Load the minimal required state from the engineOop, e.g., just the work buffer."	self inline: false.	interpreterProxy failed ifTrue:[^false].	(interpreterProxy isIntegerObject: engineOop) ifTrue:[^false].	(interpreterProxy isPointers: engineOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: engineOop) < BEBalloonEngineSize ifTrue:[^false].	engine _ engineOop.	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engineOop))			ifFalse:[^false].	self stopReasonPut: 0.	objUsed _ self objUsedGet.	engineStopped _ false.	^true! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/25/1998 00:36'!storeEngineStateInto: oop	self objUsedPut: objUsed.! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/24/1998 19:39'!hasColorTransform	^self hasColorTransformGet ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/24/1998 19:38'!hasEdgeTransform	^self hasEdgeTransformGet ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/25/1998 00:43'!isObject: obj	^obj >= 0 and:[obj < objUsed]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/25/1998 00:21'!needsFlush	^self needsFlushGet ~= 0! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:55'!gePrimitiveGetDepth	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self currentZGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/25/1998 22:30'!gePrimitiveNeedsFlush	| needFlush |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	needFlush _ self needsFlush.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: needFlush.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 19:59'!gePrimitiveSetColorTransform	| transformOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	transformOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadColorTransformFrom: transformOop.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 20:32'!gePrimitiveSetDepth	| depth |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	depth _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self currentZPut: depth.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/24/1998 21:39'!gePrimitiveSetEdgeTransform	| transformOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	transformOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadEdgeTransformFrom: transformOop.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/25/1998 16:57'!gePrimitiveNextFillEntry	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop hasFill |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateScanningAET)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for internal handling of fills"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check if we have to clear the span buffer before proceeding"	(self clearSpanBufferGet = 0) ifFalse:[		(self currentYGet bitAnd: self aaScanMaskGet) = 0			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0].	hasFill _ self findNextExternalFillFromAET.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	hasFill ifTrue:[self storeFillStateInto: fillOop].	interpreterProxy failed ifFalse:[		hasFill			ifTrue:[	self statePut: GEStateWaitingForFill]			ifFalse:[	self wbStackClear.					self spanEndAAPut: 0.					self statePut: GEStateBlitBuffer].		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushBool: hasFill not.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/25/1998 16:56'!loadRenderingState	"Load the entire state from the interpreter for the rendering primitives"	| edgeOop fillOop state |	self inline: false.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	edgeOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^false].	(self quickLoadEngineFrom: engine)		ifFalse:[^false].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^false].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^false].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^false].	"Check edgeOop and fillOop"	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^false].	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^false].	"Note: Rendering can only take place if we're not in one of the intermediate	(e.g., external) states."	state _ self stateGet.	(state = GEStateWaitingForEdge or:[		state = GEStateWaitingForFill or:[			state = GEStateWaitingChange]]) ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/25/1998 02:22'!proceedRenderingImage	"This is the main rendering entry"	| external |	self inline: false.	[self finishedProcessing] whileFalse:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalEntryFromGET.		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		geProfileTime _ self ioMicroMSecs.		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		self wbStackClear.		self spanEndAAPut: 0.		geProfileTime _ self ioMicroMSecs.		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalUpdateFromAET.		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/25/1998 02:20'!proceedRenderingScanline	"Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween."	"This is the main rendering entry"	| external state |	self inline: false.	state _ self stateGet.	state = GEStateUnlocked ifTrue:[		self initializeGETProcessing.		engineStopped ifTrue:[^0].		state _ GEStateAddingFromGET.	]. 	state = GEStateAddingFromGET ifTrue:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalEntryFromGET.		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		state _ GEStateScanningAET.	].	state = GEStateScanningAET ifTrue:[		geProfileTime _ self ioMicroMSecs.		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		state _ GEStateBlitBuffer.		self wbStackClear.		self spanEndAAPut: 0.	].	state = GEStateBlitBuffer ifTrue:[		geProfileTime _ self ioMicroMSecs.		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		state _ GEStateUpdateEdges.		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.	].	state = GEStateUpdateEdges ifTrue:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalUpdateFromAET.		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].		self statePut: GEStateAddingFromGET.	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/25/1998 00:21'!gePrimitiveInitializeBuffer	| wbOop size |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	wbOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: wbOop) 		ifFalse:[^interpreterProxy primitiveFail].	(size _ interpreterProxy slotSizeOf: wbOop) < GWMinimalSize		ifTrue:[^interpreterProxy primitiveFail].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	objBuffer _ workBuffer + GWHeaderSize.	self magicNumberPut: GWMagicNumber.	self wbSizePut: size.	self wbTopPut: size.	self statePut: GEStateUnlocked.	self objStartPut: GWHeaderSize.	self objUsedPut: 4.	"Dummy fill object"	self objectTypeOf: 0 put: GEPrimitiveFill.	self objectLengthOf: 0 put: 4.	self objectIndexOf: 0 put: 0.	self getStartPut: 0.	self getUsedPut: 0.	self aetStartPut: 0.	self aetUsedPut: 0.	self stopReasonPut: 0.	self needsFlushPut: 0.	self clipMinXPut: 0.	self clipMaxXPut: 0.	self clipMinYPut: 0.	self clipMaxYPut: 0.	self currentZPut: 0.	self resetGraphicsEngineStats.	self initEdgeTransform.	self initColorTransform.	interpreterProxy pop: 2.	interpreterProxy push: wbOop.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/25/1998 00:42'!gePrimitiveRegisterExternalEdge	| rightFillIndex leftFillIndex initialZ initialY initialX index  edge |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	initialZ _ interpreterProxy stackIntegerValue: 2.	initialY _ interpreterProxy stackIntegerValue: 3.	initialX _ interpreterProxy stackIntegerValue: 4.	index _ interpreterProxy stackIntegerValue: 5.	engine _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(self allocateObjEntry: GEBaseEdgeSize) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	(self isFillOkay: leftFillIndex)		ifFalse:[^interpreterProxy primitiveFail].	(self isFillOkay: rightFillIndex)		ifFalse:[^interpreterProxy primitiveFail].	edge _ objUsed.	objUsed _ edge + GEBaseEdgeSize.	"Install type and length"	self objectTypeOf: edge put: GEPrimitiveEdge.	self objectLengthOf: edge put: GEBaseEdgeSize.	self objectIndexOf: edge put: index.	"Install remaining stuff"	self edgeXValueOf: edge put: initialX.	self edgeYValueOf: edge put: initialY.	self edgeZValueOf: edge put: initialZ.	self edgeLeftFillOf: edge put: (self transformColor: leftFillIndex).	self edgeRightFillOf: edge put: (self transformColor: rightFillIndex).	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/25/1998 00:37'!gePrimitiveRegisterExternalFill	| index  fill |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1 		ifFalse:[^interpreterProxy primitiveFail].	index _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Note: We *must* not allocate any fill with index 0"	fill _ 0.	[fill = 0] whileTrue:[		(self allocateObjEntry: GEBaseEdgeSize) 			ifFalse:[^interpreterProxy primitiveFail].		fill _ objUsed.		objUsed _ fill + GEBaseFillSize.		"Install type and length"		self objectTypeOf: fill put: GEPrimitiveFill.		self objectLengthOf: fill put: GEBaseFillSize.		self objectIndexOf: fill put: index.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushInteger: fill.	].! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 11/25/1998 02:19'!needAvailableSpace: nSlots	"Check if we have n slots available"	GWHeaderSize + objUsed + self getUsedGet + self aetUsedGet + nSlots > self wbTopGet ifTrue:[		self stopBecauseOf: GErrorNoMoreSpace.		^false	].	^true! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/25/1998 00:41'!createGlobalEdgeTable	"Create the global edge table"	| object end |	self inline: false.	object _ 0.	end _ objUsed.	[object < end] whileTrue:[		"Note: addEdgeToGET: may fail on insufficient space but that's not a problem here"		(self isEdge: object) ifTrue:[			"Check if the edge starts below fillMaxY."			(self edgeYValueOf: object) >= self fillMaxYGet ifFalse:[				self checkedAddEdgeToGET: object.			].		].		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/25/1998 00:41'!initializeGETProcessing	"Initialization stuff that needs to be done before any processing can take place."	self inline: false.	"Make sure aaLevel is initialized"	self setAALevel: self aaLevelGet.	self clipMinXGet < 0 ifTrue:[self clipMinXPut: 0].	self clipMaxXGet > self spanSizeGet ifTrue:[self clipMaxXPut: self spanSizeGet].	"Convert clipRect to aaLevel"	self fillMinXPut: self clipMinXGet << self aaShiftGet.	self fillMinYPut: self clipMinYGet << self aaShiftGet.	self fillMaxXPut: self clipMaxXGet << self aaShiftGet.	self fillMaxYPut: self clipMaxYGet << self aaShiftGet.	"Reset GET and AET"	self getUsedPut: 0.	self aetUsedPut: 0.	getBuffer _ aetBuffer _ objBuffer + objUsed.	"Create the global edge table"	self createGlobalEdgeTable.	engineStopped ifTrue:[^nil].	self getUsedGet = 0 ifTrue:[		"Nothing to do"		self currentYPut: self fillMaxYGet.		^0].	"Sort entries in the GET"	self sortGlobalEdgeTable.	"Find the first y value to be processed"	self currentYPut: (self edgeYValueOf: (getBuffer at: 0)).	self currentYGet < self fillMinYGet ifTrue:[self currentYPut: self fillMinYGet].	"Load and clear the span buffer"	self spanStartPut: 0.	self spanEndPut: (self spanSizeGet << self aaShiftGet) - 1.	self clearSpanBuffer. "@@: Is this really necessary?!!"! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/24/1998 22:47'!findNextAETEdgeFrom: leftEdge	| depth rightEdge |	depth _ self edgeZValueOf: leftEdge.	[self aetStartGet < self aetUsedGet] whileTrue:[		rightEdge _ aetBuffer at: self aetStartGet.		(self edgeZValueOf: rightEdge) >= depth ifTrue:[^rightEdge].		self aetStartPut: self aetStartGet + 1.	].	^nil! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/25/1998 23:21'!findNextExternalFillFromAET	"Scan the active edge table. If there is any fill that cannot be handled by the engine itself,  return true. Otherwise handle the fills and return false."	| leftEdge rightEdge leftX rightX |"self currentYGet >= 680 ifTrue:[self printAET.self halt.]."	self inline: false.	leftX _ rightX _ self fillMaxXGet.	[self aetStartGet < self aetUsedGet] whileTrue:[		leftEdge _ rightEdge _ aetBuffer at: self aetStartGet.		"TODO: We should check if leftX from last operation 			is  greater than leftX from next edge.			Currently, we rely here on spanEndAA			from the span buffer fill."		leftX _ rightX _ self edgeXValueOf: leftEdge.		leftX >= self fillMaxXGet ifTrue:[^false]. "Nothing more visible"		self quickRemoveInvalidFillsAt: leftX.		"Check if we need to draw the edge"		(self isWide: leftEdge) ifTrue:[			self toggleWideFillOf: leftEdge.			"leftX _ rightX _ self drawWideEdge: leftEdge from: leftX."		].		(self areEdgeFillsValid: leftEdge) ifTrue:[			self toggleFillsOf: leftEdge. "Adjust the fills"			engineStopped ifTrue:[^false].		].		self aetStartPut: self aetStartGet + 1.		self aetStartGet < self aetUsedGet ifTrue:[			rightEdge _ aetBuffer at: self aetStartGet.			rightX _ self edgeXValueOf: rightEdge.			rightX >= self fillMinXGet ifTrue:["This is the visible portion"				self fillAllFrom: leftX to: rightX.				"Fetch the currently active fill"				"fill _ self makeUnsignedFrom: self topFill.				fill = 0 ifFalse:[self fillSpan: fill from: leftX to: rightX max: self topRightX]"			].		].	].	"Note: Due to pre-clipping we may have to draw remaining stuff with the last fill"	rightX < self fillMaxXGet ifTrue:[		self fillAllFrom: rightX to: self fillMaxXGet.		"fill _ self makeUnsignedFrom: self topFill.		fill = 0 ifFalse:[self fillSpan: fill from: rightX to: self fillMaxXGet max: self topRightX]."	].	^false! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/24/1998 22:42'!fillSorts: fillEntry1 before: fillEntry2	"Return true if fillEntry1 should be drawn before fillEntry2"	| diff |	self inline: false.	"First check the depth value"	diff _ (self stackFillDepth: fillEntry1) - (self stackFillDepth: fillEntry2).	diff = 0 ifFalse:[^diff > 0].	"See the class comment for aetScanningProblems"	^(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry1)) to:'unsigned') <		(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry2)) to: 'unsigned')! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:47'!findStackFill: fillIndex depth: depth	| index |	index _ 0.	[index < self stackFillSize and:[		(self stackFillValue: index) ~= fillIndex or:[			(self stackFillDepth: index) ~= depth]]]				whileTrue:[index _ index + self stackFillEntryLength].	index >= self stackFillSize 		ifTrue:[^-1]		ifFalse:[^index].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:48'!hideFill: fillIndex depth: depth	"Make the fill style with the given index invisible"	| index newTopIndex newTop newDepth newRightX |	self inline: false.	index _ self findStackFill: fillIndex depth: depth.	index = -1 ifTrue:[^false].	index = 0 ifTrue:[		self freeStackFillEntry.		^true].	"Fill is visible - replace it with the last entry on the stack"	self stackFillValue: index put: (self stackFillValue: 0).	self stackFillDepth: index put: (self stackFillDepth: 0).	self stackFillRightX: index put: (self stackFillRightX: 0).	self freeStackFillEntry.	(self stackFillSize <= self stackFillEntryLength) ifTrue:[^true]. "Done"	"Find the new top fill"	newTopIndex _ 0.	index _ self stackFillEntryLength.	[index < self stackFillSize] whileTrue:[		(self fillSorts: index before: newTopIndex)			ifTrue:[newTopIndex _ index].		index _ index + self stackFillEntryLength.	].	(newTopIndex + self stackFillEntryLength = self stackFillSize) 		ifTrue:[^true]. "Top fill not changed"	newTop _ self stackFillValue: newTopIndex.	self stackFillValue: newTopIndex put: self topFillValue.	self topFillValuePut: newTop.	newDepth _ self stackFillDepth: newTopIndex.	self stackFillDepth: newTopIndex put: self topFillDepth.	self topFillDepthPut: newDepth.	newRightX _ self stackFillRightX: newTopIndex.	self stackFillRightX: newTopIndex put: self topFillRightX.	self topFillRightXPut: newRightX.	^true! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:16'!quickRemoveInvalidFillsAt: leftX	"Remove any top fills if they have become invalid."	self stackFillSize = 0 ifTrue:[^nil].	[self topRightX <= leftX] whileTrue:[		self hideFill: self topFill depth: self topDepth.		self stackFillSize = 0 ifTrue:[^nil].	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 14:38'!showFill: fillIndex depth: depth rightX: rightX	self inline: false.	(self allocateStackFillEntry) ifFalse:[^nil]. "Insufficient space"	self stackFillValue: 0 put: fillIndex.	self stackFillDepth: 0 put: depth.	self stackFillRightX: 0 put: rightX.	self stackFillSize = self stackFillEntryLength ifTrue:[^nil]. "No need to update"	(self fillSorts: 0 before: self stackFillSize - self stackFillEntryLength) ifTrue:[		"New top fill"		self stackFillValue: 0 put: self topFillValue.		self stackFillDepth: 0 put: self topFillDepth.		self stackFillRightX: 0 put: self topFillRightX.		self topFillValuePut: fillIndex.		self topFillDepthPut: depth.		self topFillRightXPut: rightX.	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 14:38'!toggleFill: fillIndex depth: depth rightX: rightX	"Make the fill style with the given index either visible or invisible"	| hidden |	self inline: false.	self stackFillSize = 0 ifTrue:[		(self allocateStackFillEntry) ifTrue:[			self topFillValuePut: fillIndex.			self topFillDepthPut: depth.			self topFillRightXPut: rightX.		].	] ifFalse:[		hidden _ self hideFill: fillIndex depth: depth.		hidden ifFalse:[self showFill: fillIndex depth: depth rightX: rightX].	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:19'!toggleFillsOf: edge	| depth fillIndex |	self inline: false.	(self needAvailableSpace: self stackFillEntryLength * 2) 		ifFalse:[^nil]. "Make sure we have enough space left"	depth _ (self edgeZValueOf: edge) << 1.	fillIndex _ self edgeLeftFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth rightX: 999999999].	fillIndex _ self edgeRightFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth rightX: 999999999].	self quickRemoveInvalidFillsAt: (self edgeXValueOf: edge).! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/25/1998 15:50'!toggleWideFillOf: edge	| fill type lineWidth depth rightX index |	self inline: false.	type _ self edgeTypeOf: edge.	dispatchedValue _ edge.	self dispatchOn: type in: WideLineWidthTable.	lineWidth _ dispatchReturnValue.	self dispatchOn: type in: WideLineFillTable.	fill _ dispatchReturnValue.	fill = 0 ifTrue:[^nil].	(self needAvailableSpace: self stackFillEntryLength) 		ifFalse:[^nil]. "Make sure we have enough space left"	depth _ (self edgeZValueOf: edge) << 1 + 1. "So lines sort before interior fills"	rightX _ (self edgeXValueOf: edge) + lineWidth.	index _ self findStackFill: fill depth: depth.	index = -1 ifTrue:[		self showFill: fill 			depth: depth			rightX: rightX.	] ifFalse:[		(self stackFillRightX: index) < rightX			ifTrue:[self stackFillRightX: index put: rightX].	].	self quickRemoveInvalidFillsAt: (self edgeXValueOf: edge).! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/25/1998 02:34'!drawWideEdge: edge from: leftX	"Draw the given edge starting from leftX with the edge's fill.	Return the end value of the drawing operation."	| rightX fill type lineWidth |	self inline: false. "Not for the moment"	type _ self edgeTypeOf: edge.	dispatchedValue _ edge.	self dispatchOn: type in: WideLineWidthTable.	lineWidth _ dispatchReturnValue.	self dispatchOn: type in: WideLineFillTable.	fill _ self makeUnsignedFrom: dispatchReturnValue.	fill = 0 ifTrue:[^leftX].	"Check if this line is only partially visible"	"self assert:(self isFillColor: fill)."	rightX _ leftX + lineWidth.	self fillSpan: fill from: leftX to: rightX.	^rightX! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/25/1998 15:12'!fillAllFrom: leftX to: rightX	"Fill the span buffer from leftX to rightX with the given fill."	| fill startX stopX |	self inline: true.	fill _ self topFill.	startX _ leftX.	stopX _ self topRightX.	[stopX < rightX] whileTrue:[		fill _ self makeUnsignedFrom: self topFill.		fill = 0 ifFalse:[			(self fillSpan: fill from: startX to: stopX) ifTrue:[^true]].		self quickRemoveInvalidFillsAt: stopX.		startX _ stopX.		stopX _ self topRightX].	fill _ self makeUnsignedFrom: self topFill.	fill = 0 ifFalse:[^self fillSpan: fill from: startX to: rightX].	^false! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/25/1998 14:57'!fillSpan: fill from: leftX to: rightX max: maxRightX	"Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code."	| x0 x1 type |	self inline: false.	fill = 0 ifTrue:[^false]. "Nothing to do"	"Start from spEnd - we must not paint pixels twice at a scan line"	leftX < self spanEndAAGet 		ifTrue:[x0 _ self spanEndAAGet]		ifFalse:[x0 _ leftX].	rightX > (self spanSizeGet << self aaShiftGet) 		ifTrue:[x1 _ (self spanSizeGet << self aaShiftGet)]		ifFalse:[x1 _ rightX].	maxRightX < x1 ifTrue:[x1 _ maxRightX].	"Clip left and right values"	x0 < self fillMinXGet ifTrue:[x0 _ self fillMinXGet].	x1 > self fillMaxXGet ifTrue:[x1 _ self fillMaxXGet].	"Adjust start and end values of span"	x0 < self spanStartGet ifTrue:[self spanStartPut: x0].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].	x0 >= x1 ifTrue:[^false]. "Nothing to do"	(self isFillColor: fill) ifTrue:[		self fillColorSpan: fill from: x0 to: x1.	] ifFalse:[		"Store the values for the dispatch"		self lastExportedFillPut: fill.		self lastExportedLeftXPut: x0.		self lastExportedRightXPut: x1.		type _ self fillTypeOf: fill.		type <= 1 ifTrue:[^true].		self dispatchOn: type in: FillTable.	].	^false! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/29/1998 18:42'!transformColor: fillIndex	| r g b a transform |	self var: #transform declareC:'float *transform'.	(fillIndex = 0 or:[self isFillColor: fillIndex]) ifFalse:[^fillIndex].	b _ fillIndex bitAnd: 255.	g _ (fillIndex >> 8) bitAnd: 255.	r _ (fillIndex >> 16) bitAnd: 255.	a _ (fillIndex >> 24) bitAnd: 255.	(self hasColorTransform) ifTrue:[		transform _ self colorTransform.		r _ (r * (transform at: 0) + (transform at: 1)) asInteger.		g _ (g * (transform at: 2) + (transform at: 3)) asInteger.		b _ (b * (transform at: 4) + (transform at: 5)) asInteger.		a _ (a * (transform at: 6) + (transform at: 7)) asInteger.		r _ r max: 0. r _ r min: 255.		g _ g max: 0. g _ g min: 255.		b _ b max: 0. b _ b min: 255.		a _ a max: 0. a _ a min: 255.	].	a < 16 ifTrue:[^0]."ALWAYS return zero for transparent fills"	"If alpha is not 255 (or close thereto) then we need to flush the engine before proceeding.	Use alpha = 240 -- this is the max value for aaLevel 4"	(a < 240 and:[self needsFlush]) 		ifTrue:[self stopBecauseOf: GErrorNeedFlush].	^b + (g << 8) + (r << 16) + (a << 24)! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:47'!transformPoint: point	"Transform the given point. If haveMatrix is true then use the current transformation."	self var:#point declareC:'int *point'.	self hasEdgeTransform ifFalse:[		"Multiply each component by aaLevel and add a half pixel"		point at: 0 put: (point at: 0) + self destOffsetXGet * self aaLevelGet.		point at: 1 put: (point at: 1) + self destOffsetYGet * self aaLevelGet.	] ifTrue:[		"Note: AA adjustment is done in #transformPoint: for higher accuracy"		self transformPoint: point into: point.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:25'!transformPointX: xValue y: yValue into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This should be rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	| x y transform |	self inline: true. "Won't help at the moment ;-("	self var: #dstPoint declareC:'int *dstPoint'.	self var: #xValue declareC: 'double xValue'.	self var: #yValue declareC: 'double yValue'.	self var: #transform declareC:'float *transform'.	transform _ self edgeTransform.	x _ ((((transform at: 0) * xValue) +		((transform at: 1) * yValue) +		(transform at: 2)) * self aaLevelGet asFloat) asInteger.	y _ ((((transform at: 3) * xValue) +		((transform at: 4) * yValue) +		(transform at: 5)) * self aaLevelGet asFloat) asInteger.	dstPoint at: 0 put: x.	dstPoint at: 1 put: y.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:48'!transformPoints: n	"Transform n (n=1,2,3) points.	If haveMatrix is true then the matrix contains the actual transformation."	self inline: true.	n > 0 ifTrue:[self transformPoint: self point1Get].	n > 1 ifTrue:[self transformPoint: self point2Get].	n > 2 ifTrue:[self transformPoint: self point3Get].	n > 3 ifTrue:[self transformPoint: self point4Get].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/24/1998 19:51'!transformWidth: w	"Transform the given width"	| deltaX deltaY destWidth destWidth2 |	self inline: false.	self var: #deltaX declareC:'double deltaX'.	self var: #deltaY declareC:'double deltaY'.	w = 0 ifTrue:[^0].	self point1Get at: 0 put: 0.	self point1Get at: 1 put: 0.	self point2Get at: 0 put: w * 256.	self point2Get at: 1 put: 0.	self point3Get at: 0 put: 0.	self point3Get at: 1 put: w * 256.	self transformPoints: 3.	deltaX _ ((self point2Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point2Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	deltaX _ ((self point3Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point3Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth2 _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	destWidth2 < destWidth ifTrue:[destWidth _ destWidth2].	destWidth = 0		ifTrue:[^1]		ifFalse:[^destWidth]! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/25/1998 21:33'!uncheckedTransformColor: fillIndex	| r g b a transform |	self var: #transform declareC:'float *transform'.	(self hasColorTransform) ifFalse:[^fillIndex].	b _ fillIndex bitAnd: 255.	g _ (fillIndex >> 8) bitAnd: 255.	r _ (fillIndex >> 16) bitAnd: 255.	a _ (fillIndex >> 24) bitAnd: 255.	transform _ self colorTransform.	r _ (r * (transform at: 0) + (transform at: 1)) asInteger.	g _ (g * (transform at: 2) + (transform at: 3)) asInteger.	b _ (b * (transform at: 4) + (transform at: 5)) asInteger.	a _ (a * (transform at: 6) + (transform at: 7)) asInteger.	r _ r max: 0. r _ r min: 255.	g _ g max: 0. g _ g min: 255.	b _ b max: 0. b _ b min: 255.	a _ a max: 0. a _ a min: 255.	a < 16 ifTrue:[^0]."ALWAYS return zero for transparent fills"	^b + (g << 8) + (r << 16) + (a << 24)! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/24/1998 19:45'!initColorTransform	| transform |	self inline: false.	self var: #transform declareC:'float *transform'.	transform _ self colorTransform.	transform at: 0 put: (self cCoerce: 1.0 to: 'float').	transform at: 1 put: (self cCoerce: 0.0 to: 'float').	transform at: 2 put: (self cCoerce: 1.0 to: 'float').	transform at: 3 put: (self cCoerce: 0.0 to: 'float').	transform at: 4 put: (self cCoerce: 1.0 to: 'float').	transform at: 5 put: (self cCoerce: 0.0 to: 'float').	transform at: 6 put: (self cCoerce: 1.0 to: 'float').	transform at: 7 put: (self cCoerce: 0.0 to: 'float').	self hasColorTransformPut: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/24/1998 19:45'!initEdgeTransform	| transform |	self inline: false.	self var: #transform declareC:'float *transform'.	transform _ self edgeTransform.	transform at: 0 put: (self cCoerce: 1.0 to: 'float').	transform at: 1 put: (self cCoerce: 0.0 to: 'float').	transform at: 2 put: (self cCoerce: 0.0 to: 'float').	transform at: 3 put: (self cCoerce: 0.0 to: 'float').	transform at: 4 put: (self cCoerce: 1.0 to: 'float').	transform at: 5 put: (self cCoerce: 0.0 to: 'float').	self hasEdgeTransformPut: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/25/1998 02:22'!stopBecauseOf: stopReason	self stopReasonPut: stopReason.	engineStopped _ true.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/25/1998 19:46'!initializeFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex "Type zero - undefined"		errorWrongIndex "Type one - external fill"		fillLinearGradient "Linear gradient fill"		fillRadialGradient "Radial gradient fill"		fillBitmapSpan	"Clipped bitmap fill"		fillBitmapSpan	"Repeated bitmap fill"	)! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/24/1998 23:54'!initEdgeConstants: dict	"Initialize the edge constants"	self initFromSpecArray:	#(		"Edge primitive types"		(GEPrimitiveEdge 2)			"External edge - not handled by the GE"		(GEPrimitiveWideEdge 3)		"Wide external edge"		(GEPrimitiveLine 4)			"Straight line"		(GEPrimitiveWideLine 5)		"Wide line"		(GEPrimitiveBezier 6)		"Quadratic bezier curve"		(GEPrimitiveWideBezier 7)	"Wide bezier curve"		"Special flags"		(GEPrimitiveWide 16r01)		"Flag determining a wide primitive"		(GEPrimitiveWideMask 16rFE)	"Mask for clearing the wide flag"		(GEEdgeFillsInvalid 16r10000) "Flag determining if left/right fills of an edge are invalid"		(GEEdgeClipFlag 16r20000)	"Flag determining if this is a clip edge"		"General edge state constants"		(GEXValue 4)					"Current raster x"		(GEYValue 5)					"Current raster y"		(GEZValue 6)					"Current raster z"		(GENumLines 7)					"Number of scan lines remaining"		(GEFillIndexLeft 8)				"Left fill index"		(GEFillIndexRight 9)				"Right fill index"		(GEBaseEdgeSize 10)				"Basic size of each edge"		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"General Line state constants"		(GLXDirection 10)				"Direction of edge (1: left-to-right; -1: right-to-left)"		(GLYDirection 11)				"Direction of edge (1: top-to-bottom; -1: bottom-to-top)"		(GLXIncrement 12)				"Increment at each scan line"		(GLError 13)						"Current error"		(GLErrorAdjUp 14)				"Error to add at each scan line"		(GLErrorAdjDown 15)				"Error to subtract on roll-over"			"Note: The following entries are only needed before the incremental			state is computed. They are therefore aliased to the error values above"		(GLEndX 14)						"End X of line"		(GLEndY 15)						"End Y of line"		(GLBaseSize 16)					"Basic size of each line"		"Additional stuff for wide lines"		(GLWideFill 16)					"Current fill of line"		(GLWideWidth 17)				"Current width of line"		(GLWideEntry 18)				"Initial steps"		(GLWideExit 19)					"Final steps"		(GLWideExtent 20)				"Target width"		(GLWideSize 21)					"Size of wide lines"		"General Bezier state constants"		(GBUpdateData 10)				"Incremental update data for beziers"			(GBUpdateX 0)				"Last computed X value (24.8)"			(GBUpdateY 1)				"Last computed Y value (24.8)"			(GBUpdateDX 2)				"Delta X forward difference step (8.24)"			(GBUpdateDY 3)				"Delta Y forward difference step (8.24)"			(GBUpdateDDX 4)				"Delta DX forward difference step (8.24)"			(GBUpdateDDY 5)				"Delta DY forward difference step (8.24)"		"Note: The following four entries are only needed before the incremental			state is computed. They are therefore aliased to the incremental values above"		(GBViaX 12)						"via x"		(GBViaY 13)						"via y"		(GBEndX 14)						"end x"		(GBEndY 15)						"end y"		(GBBaseSize 16)					"Basic size of each bezier.										Note: MUST be greater or equal to the size of lines"		"Additional stuff for wide beziers"		(GBWideFill 16)					"Current fill of line"		(GBWideWidth 17)				"Current width of line"		(GBWideEntry 18)				"Initial steps"		(GBWideExit 19)					"Final steps"		(GBWideExtent 20)				"Target extent"		(GBFinalX 21)					"Final X value"		(GBWideUpdateData 22)	"Update data for second curve"		(GBWideSize 28)					"Size of wide beziers"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/27/1998 14:19'!initFillConstants: dict	"Initialize the fill constants"	"BalloonEngineBase initPool"	self initFromSpecArray:	#(		"Fill primitive types"		(GEPrimitiveFill 16r100)		(GEPrimitiveLinearGradientFill 16r200)		(GEPrimitiveRadialGradientFill 16r300)		(GEPrimitiveClippedBitmapFill 16r400)		(GEPrimitiveRepeatedBitmapFill 16r500)		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"Oriented fill constants"		(GFOriginX 4)				"X origin of fill"		(GFOriginY 5)				"Y origin of fill"		(GFDirectionX 6)				"X direction of fill"		(GFDirectionY 7)				"Y direction of fill"		(GFNormalX 8)				"X normal of fill"		(GFNormalY 9)				"Y normal of fill"		"Gradient fill constants"		(GFRampLength 10)			"Length of following color ramp"		(GFRampOffset 12)			"Offset of first ramp entry"		(GGBaseSize 12)		"Bitmap fill constants"		(GBBitmapWidth 10)			"Width of bitmap"		(GBBitmapHeight 11)			"Height of bitmap"		(GBBitmapDepth 12)			"Depth of bitmap"		(GBBitmapSize 13)			"Size of bitmap words"		(GBBitmapRaster 14)			"Size of raster line"		(GBColormapSize 15)			"Size of colormap, if any"		(GBTileFlag 16)				"True if the bitmap is tiled"		(GBColormapOffset 18)		"Offset of colormap, if any"		(GBMBaseSize 18)			"Basic size of bitmap fill"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/25/1998 00:25'!initStateConstants: dict	"Initialize the state Constants"	"BalloonEngineBase initPool"	self initFromSpecArray:	#(		(GEStateUnlocked 0)			"Buffer is unlocked and can be modified as wanted"		(GEStateAddingFromGET 1)	"Adding edges from the GET"		(GEStateWaitingForEdge 2)	"Waiting for edges added to GET"		(GEStateScanningAET 3)		"Scanning the active edge table"		(GEStateWaitingForFill 4)		"Waiting for a fill to mix in during AET scan"		(GEStateBlitBuffer 5)			"Blt the current scan line"		(GEStateUpdateEdges 6)		"Update edges to next scan line"		(GEStateWaitingChange 7)	"Waiting for a changed edge"		(GEStateCompleted 8)			"Rendering completed"		"Error constants"		(GErrorNoMoreSpace 1)		"No more space in collection"		(GErrorBadState 2)			"Tried to call a primitive while engine in bad state"		(GErrorNeedFlush 3)			"Tried to call a primitive that requires flushing before"		"Incremental error constants"		(GErrorGETEntry 4)			"Unknown entry in GET"		(GErrorFillEntry 5)			"Unknown FILL encountered"		(GErrorAETEntry 6)			"Unknown entry in AET"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/25/1998 00:20'!initWorkBufferConstants: dict	"Initialize the work buffer constants"	"BalloonEngineBase initPool"	self initFromSpecArray:	#(		"General work buffer constants"		(GWMagicNumber 16r416E6469)	"Magic number"		(GWHeaderSize 128)				"Size of header"		(GWMinimalSize 256)				"Minimal size of work buffer"		"Header entries"		(GWMagicIndex 0)				"Index of magic number"		(GWSize 1)						"Size of full buffer"		(GWState 2)						"Current state (e.g., locked or not)"		"Buffer entries"		(GWObjStart 8)					"objStart"		(GWObjUsed 9)					"objUsed"		(GWBufferTop 10)				"wbTop"		(GWGETStart 11)					"getStart"		(GWGETUsed 12)					"getUsed"		(GWAETStart 13)					"aetStart"		(GWAETUsed 14)					"aetUsed"		"Transform entries"		(GWHasEdgeTransform 16)		"True if we have an edge transformation"		(GWHasColorTransform 17)		"True if we have a color transformation"		(GWEdgeTransform 18)			"2x3 edge transformation"		(GWColorTransform 24)			"8 word RGBA color transformation"		"Span entries"		(GWSpanStart 32)				"spStart"		(GWSpanSize 33)					"spSize"		(GWSpanEnd 34)					"spEnd"		(GWSpanEndAA 35)				"spEndAA"		"Bounds entries"		(GWFillMinX 36)					"fillMinX"		(GWFillMaxX 37)					"fillMaxX"		(GWFillMinY 38)					"fillMinY"		(GWFillMaxY 39)					"fillMaxY"		(GWFillOffsetX 40)				"fillOffsetX"		(GWFillOffsetY 41)				"fillOffsetY"		(GWClipMinX 42)		(GWClipMaxX 43)		(GWClipMinY 44)		(GWClipMaxY 45)		(GWDestOffsetX 46)		(GWDestOffsetY 47)		"AA entries"		(GWAALevel 48)					"aaLevel"		(GWAAShift 49)					"aaShift"		(GWAAColorShift 50)				"aaColorShift"		(GWAAColorMask 51)				"aaColorMask"		(GWAAScanMask 52)				"aaScanMask"		(GWAAHalfPixel 53)				"aaHalfPixel"		"Misc entries"		(GWNeedsFlush 63)				"True if the engine may need a flush"		(GWStopReason 64)				"stopReason"		(GWLastExportedEdge 65)			"last exported edge"		(GWLastExportedFill 66)			"last exported fill"		(GWLastExportedLeftX 67)			"last exported leftX"		(GWLastExportedRightX 68)		"last exported rightX"		(GWClearSpanBuffer 69)			"Do we have to clear the span buffer?"		(GWPointListFirst 70)				"First point list in buffer"		(GWPoint1 80)		(GWPoint2 82)		(GWPoint3 84)		(GWPoint4 86)		(GWCurrentY 88)		"Profile stats"		(GWTimeInitializing 90)		(GWCountInitializing 91)		(GWTimeFinishTest 92)		(GWCountFinishTest 93)		(GWTimeNextGETEntry 94)		(GWCountNextGETEntry 95)		(GWTimeAddAETEntry 96)		(GWCountAddAETEntry 97)		(GWTimeNextFillEntry 98)		(GWCountNextFillEntry 99)		(GWTimeMergeFill 100)		(GWCountMergeFill 101)		(GWTimeDisplaySpan 102)		(GWCountDisplaySpan 103)		(GWTimeNextAETEntry 104)		(GWCountNextAETEntry 105)		(GWTimeChangeAETEntry 106)		(GWCountChangeAETEntry 107)		"Bezier stats"		(GWBezierMonotonSubdivisions 108) 	"# of subdivision due to non-monoton beziers"		(GWBezierHeightSubdivisions 109)		"# of subdivisions due to excessive height"		(GWBezierOverflowSubdivisions 110)	"# of subdivisions due to possible int overflow"		(GWBezierLineConversions 111)		"# of beziers converted to lines"		(GWHasClipShapes 112)		"True if the engine contains clip shapes"		(GWCurrentZ 113)			"Current z value of primitives"	) in: dict.! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:29'!gePrimitiveAddBezier	| leftFill rightFill viaOop endOop startOop nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	rightFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	viaOop _ interpreterProxy stackObjectValue: 2.	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFill) and:[self isFillOkay: rightFill])			ifFalse:[^interpreterProxy primitiveFail].	"Do a quick check if the fillIndices are equal - if so, just ignore it"	leftFill = rightFill & false ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: viaOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self transformPoints: 3.	nSegments _ self loadAndSubdivideBezierFrom: self point1Get 						via: self point2Get 						to: self point3Get 						isWide: false.	self needAvailableSpace: nSegments * GBBaseSize.	engineStopped ifFalse:[		leftFill _ self transformColor: leftFill.		rightFill _ self transformColor: rightFill].	engineStopped ifFalse:[		self loadWideBezier: 0 lineFill: 0 leftFill: leftFill rightFill: rightFill n: nSegments.	].	engineStopped ifTrue:[		"Make sure the stack is okay"		self wbStackClear.		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:29'!gePrimitiveAddBezierShape	| points lineFill lineWidth fillIndex length isArray segSize nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	lineWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	nSegments _ interpreterProxy stackIntegerValue: 3.	points _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = (nSegments * 3) or:[length = (nSegments * 6)])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = (nSegments * 3)			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Transform colors"	lineFill _ self transformColor: lineFill.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 5].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual shape"	isArray ifTrue:[		self loadArrayShape: points nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill.	] ifFalse:[		self loadShape: (interpreterProxy firstIndexableField: points) nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nSegments * 3 = length)].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/27/1998 14:26'!gePrimitiveAddBitmapFill	| nrmOop dirOop originOop tileFlag fill xIndex cmOop formOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 7 		ifFalse:[^interpreterProxy primitiveFail].	xIndex _ interpreterProxy stackIntegerValue: 0.	xIndex <= 0 ifTrue:[^interpreterProxy primitiveFail].	nrmOop _ interpreterProxy stackObjectValue: 1.	dirOop _ interpreterProxy stackObjectValue: 2.	originOop _ interpreterProxy stackObjectValue: 3.	tileFlag _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 4).	tileFlag ifTrue:[tileFlag _ 1] ifFalse:[tileFlag _ 0].	cmOop _ interpreterProxy stackObjectValue: 5.	formOop _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 7) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadBitmapFill: formOop 				colormap: cmOop				tile: tileFlag				from: self point1Get 				along: self point2Get 				normal: self point3Get 				xIndex: xIndex-1.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 8.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:29'!gePrimitiveAddCompressedShape	| fillIndexList lineFills lineWidths rightFills leftFills nSegments points pointsShort |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 7 		ifFalse:[^interpreterProxy primitiveFail].	fillIndexList _ interpreterProxy stackObjectValue: 0.	lineFills _ interpreterProxy stackObjectValue: 1.	lineWidths _ interpreterProxy stackObjectValue: 2.	rightFills _ interpreterProxy stackObjectValue: 3.	leftFills _ interpreterProxy stackObjectValue: 4.	nSegments _ interpreterProxy stackIntegerValue: 5.	points _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 7) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the compressed shape is okay"	(self checkCompressedShape: points 			segments: nSegments 			leftFills: leftFills 			rightFills: rightFills 			lineWidths: lineWidths 			lineFills: lineFills 			fillIndexList: fillIndexList) ifFalse:[^interpreterProxy primitiveFail].	"Now check that we have some hope to have enough free space.	Do this by assuming nSegments boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(self needAvailableSpace: (GBBaseSize max: GLBaseSize) * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check if the points are short"	pointsShort _ (interpreterProxy slotSizeOf: points) = (nSegments * 3).	"Then actually load the compressed shape"	self loadCompressedShape: (interpreterProxy firstIndexableField: points)			segments: nSegments 			leftFills: (interpreterProxy firstIndexableField: leftFills)			rightFills: (interpreterProxy firstIndexableField: rightFills)			lineWidths: (interpreterProxy firstIndexableField: lineWidths)			lineFills: (interpreterProxy firstIndexableField: lineFills)			fillIndexList: (interpreterProxy firstIndexableField: fillIndexList)			pointShort: pointsShort.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 7. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/24/1998 21:15'!gePrimitiveAddGradientFill	| isRadial nrmOop dirOop originOop rampOop fill |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	isRadial _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	nrmOop _ interpreterProxy stackValue: 1.	dirOop _ interpreterProxy stackValue: 2.	originOop _ interpreterProxy stackValue: 3.	rampOop _ interpreterProxy stackValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadGradientFill: rampOop 				from: self point1Get 				along: self point2Get 				normal: self point3Get 				isRadial: isRadial.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:27'!gePrimitiveAddLine	| leftFill rightFill endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 4 		ifFalse:[^interpreterProxy primitiveFail].	rightFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	endOop _ interpreterProxy stackObjectValue: 2.	startOop _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 4) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFill) and:[self isFillOkay: rightFill])			ifFalse:[^interpreterProxy primitiveFail].	"Load the points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	"Transform points"	self transformPoints: 2.	"Transform colors"	leftFill _ self transformColor: leftFill.	rightFill _ self transformColor: rightFill.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Load line"	self loadWideLine: 0 from: self point1Get to: self point2Get 		lineFill: 0 leftFill: leftFill rightFill: rightFill.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 4. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:40'!gePrimitiveAddOval	| fillIndex borderWidth borderIndex endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	borderWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Transform colors"	fillIndex _ self transformColor: fillIndex.	borderIndex _ self transformColor: borderIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth <= 0]]) ifTrue:[		^interpreterProxy pop: 5. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (16 * GBBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth]		ifFalse:[borderWidth _ 0].	"Load the rectangle points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self loadOval: borderWidth lineFill: borderIndex 		leftFill: 0 rightFill: fillIndex.	engineStopped ifTrue:[		self wbStackClear.		^interpreterProxy primitiveFail.	].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:30'!gePrimitiveAddPolygon	| points lineFill lineWidth fillIndex nPoints length isArray segSize |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	lineWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	nPoints _ interpreterProxy stackIntegerValue: 3.	points _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = nPoints or:[nPoints * 2 = length])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = nPoints			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nPoints)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Transform colors"	lineFill _ self transformColor: lineFill.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[lineWidth _ self transformWidth: lineWidth].	"And load the actual polygon"	isArray ifTrue:[		self loadArrayPolygon: points nPoints: nPoints			fill: fillIndex lineWidth: lineWidth lineFill: lineFill	] ifFalse:[		self loadPolygon: (interpreterProxy firstIndexableField: points) nPoints: nPoints 			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nPoints = length)].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/25/1998 00:30'!gePrimitiveAddRect	| fillIndex borderWidth borderIndex endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	borderWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Transform colors"	borderIndex _ self transformColor: borderIndex.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth = 0]]) ifTrue:[		^interpreterProxy pop: 5. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (4 * GLBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth]		ifFalse:[borderWidth _ 0].	"Load the rectangle"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^nil].	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).	"Transform the points"	self transformPoints: 4.	self loadRectangle: borderWidth lineFill: borderIndex leftFill: 0 rightFill: fillIndex.	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndXOf: line	^self obj: line at: GLEndX! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndXOf: line put: value	^self obj: line at: GLEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndYOf: line	^self obj: line at: GLEndY! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineEndYOf: line put: value	^self obj: line at: GLEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineErrorAdjDownOf: line	^self obj: line at: GLErrorAdjDown! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:07'!lineErrorAdjDownOf: line put: value	^self obj: line at: GLErrorAdjDown put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorAdjUpOf: line	^self obj: line at: GLErrorAdjUp! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorAdjUpOf: line put: value	^self obj: line at: GLErrorAdjUp put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorOf: line	^self obj: line at: GLError! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineErrorOf: line put: value	^self obj: line at: GLError put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:08'!lineXDirectionOf: line	^self obj: line at: GLXDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineXDirectionOf: line put: value	^self obj: line at: GLXDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineXIncrementOf: line	^self obj: line at: GLXIncrement! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineXIncrementOf: line put: value	^self obj: line at: GLXIncrement put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineYDirectionOf: line	^self obj: line at: GLYDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!lineYDirectionOf: line put: value	^self obj: line at: GLYDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:09'!wideLineEntryOf: line	^self obj: line at: GLWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineEntryOf: line put: value	^self obj: line at: GLWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExitOf: line	^self obj: line at: GLWideExit! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExitOf: line put: value	^self obj: line at: GLWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExtentOf: line	^self obj: line at: GLWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineExtentOf: line put: value	^self obj: line at: GLWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:10'!wideLineFillOf: line	^self obj: line at: GLWideFill! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:11'!wideLineFillOf: line put: value	^self obj: line at: GLWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:11'!wideLineWidthOf: line	^self obj: line at: GLWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/24/1998 22:11'!wideLineWidthOf: line put: value	^self obj: line at: GLWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!bezierEndXOf: bezier	^self obj: bezier at: GBEndX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierEndXOf: bezier put: value	^self obj: bezier at: GBEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierEndYOf: bezier	^self obj: bezier at: GBEndY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!bezierEndYOf: bezier put: value	^self obj: bezier at: GBEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:19'!bezierFinalXOf: bezier	^self obj: bezier at: GBFinalX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!bezierFinalXOf: bezier put: value	^self obj: bezier at: GBFinalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:24'!bezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier + GBUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!bezierViaXOf: bezier	^self obj: bezier at: GBViaX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierViaXOf: bezier put: value	^self obj: bezier at: GBViaX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!bezierViaYOf: bezier	^self obj: bezier at: GBViaY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!bezierViaYOf: bezier put: value	^self obj: bezier at: GBViaY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierEntryOf: line	^self obj: line at: GBWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierEntryOf: line put: value	^self obj: line at: GBWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierExitOf: line	^self obj: line at: GBWideExit! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:18'!wideBezierExitOf: line put: value	^self obj: line at: GBWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierExtentOf: bezier	^self obj: bezier at: GBWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierExtentOf: bezier put: value	^self obj: bezier at: GBWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:19'!wideBezierFillOf: bezier	^self obj: bezier at: GBWideFill! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:17'!wideBezierFillOf: bezier put: value	^self obj: bezier at: GBWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:25'!wideBezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier +  GBWideUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierWidthOf: line	^self obj: line at: GBWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/24/1998 22:20'!wideBezierWidthOf: line put: value	^self obj: line at: GBWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/24/1998 22:18'!gradientRampLengthOf: fill	^self obj: fill at: GFRampLength! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/24/1998 22:17'!gradientRampLengthOf: fill put: value	^self obj: fill at: GFRampLength put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/24/1998 22:25'!gradientRampOf: fill	self returnTypeC:'int *'.	^objBuffer + fill +  GFRampOffset! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/24/1998 23:15'!loadLine: line from: point1 to: point2 offset: yOffset leftFill: leftFill rightFill: rightFill	"Load the line defined by point1 and point2."	| p1 p2 yDir |	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(point1 at: 1) <= (point2 at: 1) 		ifTrue:[	p1 _ point1.				p2 _ point2.				yDir _ 1]		ifFalse:[	p1 _ point2.				p2 _ point1.				yDir _ -1].	self edgeXValueOf: line put: (p1 at: 0).	self edgeYValueOf: line put: (p1 at: 1) - yOffset.	self edgeZValueOf: line put: self currentZGet.	self edgeLeftFillOf: line put: leftFill.	self edgeRightFillOf: line put: rightFill.	self lineEndXOf: line put: (p2 at: 0).	self lineEndYOf: line put: (p2 at: 1) - yOffset.	self lineYDirectionOf: line put: yDir.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/24/1998 23:15'!loadBezier: bezier segment: index leftFill: leftFillIndex rightFill: rightFillIndex offset: yOffset	"Initialize the bezier segment stored on the stack"	self inline: false.	(self bzEndY: index) >= (self bzStartY: index) ifTrue:[		"Top to bottom"		self edgeXValueOf: bezier put: (self bzStartX: index).		self edgeYValueOf: bezier put: (self bzStartY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzEndX: index).		self bezierEndYOf: bezier put: (self bzEndY: index) - yOffset.	] ifFalse:[		self edgeXValueOf: bezier put: (self bzEndX: index).		self edgeYValueOf: bezier put: (self bzEndY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzStartX: index).		self bezierEndYOf: bezier put: (self bzStartY: index) - yOffset.	].	self edgeZValueOf: bezier put: self currentZGet.	self edgeLeftFillOf: bezier put: leftFillIndex.	self edgeRightFillOf: bezier put: rightFillIndex.	"self debugDrawBezier: bezier."! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/25/1998 23:21'!loadOval: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a rectangular oval currently defined by point1/point2"	| w h cx cy nSegments |	self inline: false.	w _ ((self point2Get at: 0) - (self point1Get at: 0)) // 2.	h _ ((self point2Get at: 1) - (self point1Get at: 1)) // 2.	cx _ ((self point2Get at: 0) + (self point1Get at: 0)) // 2.	cy _ ((self point2Get at: 1) + (self point1Get at: 1)) // 2.	0 to: 15 do:[:i|		self loadOvalSegment: i w: w h: h cx: cx cy: cy.		self transformPoints: 3.		nSegments _ self loadAndSubdivideBezierFrom: self point1Get 							via: self point2Get to: self point3Get							isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).		engineStopped ifTrue:[^nil].		self loadWideBezier: lineWidth lineFill: lineFill 			leftFill: leftFill rightFill: rightFill n: nSegments.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/25/1998 00:42'!checkCompressedFills: indexList	"Check if the indexList (containing fill handles) is okay."	| fillPtr length fillIndex |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	"First check if the oops have the right format"	(interpreterProxy isWords: indexList) ifFalse:[^false].	"Then check the fill entries"	length _ interpreterProxy slotSizeOf: indexList.	fillPtr _ interpreterProxy firstIndexableField: indexList.	1 to: length do:[:i|		fillIndex _ fillPtr at: 0.		"Make sure the fill is okay"		(self isFillOkay: fillIndex) ifFalse:[^false].		fillPtr _ fillPtr + 1].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/24/1998 21:13'!loadCompressedSegment: segmentIndex from: points short: pointsShort leftFill: leftFill rightFill: rightFill lineWidth: lineWidth lineColor: lineFill 	"Load the compressed segment identified by segment index"	| x0 y0 x1 y1 x2 y2 index segs |	self inline: true.	"Check if have anything to do at all"	(leftFill = rightFill and:[lineWidth = 0 or:[lineFill = 0]]) 		ifTrue:[^nil]. "Nothing to do"	index _ segmentIndex * 6. "3 points with x/y each"	pointsShort ifTrue:["Load short points"		x0 _ self loadPointShortAt: (index+0) from: points.		y0 _ self loadPointShortAt: (index+1) from: points.		x1 _ self loadPointShortAt: (index+2) from: points.		y1 _ self loadPointShortAt: (index+3) from: points.		x2 _ self loadPointShortAt: (index+4) from: points.		y2 _ self loadPointShortAt: (index+5) from: points.	] ifFalse:[		x0 _ self loadPointIntAt: (index+0) from: points.		y0 _ self loadPointIntAt: (index+1) from: points.		x1 _ self loadPointIntAt: (index+2) from: points.		y1 _ self loadPointIntAt: (index+3) from: points.		x2 _ self loadPointIntAt: (index+4) from: points.		y2 _ self loadPointIntAt: (index+5) from: points.	].	"Briefly check if can represent the bezier as a line"	((x0 = x1 and:[y0 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[		"We can use a line from x0/y0 to x2/y2"		(x0 = x2 and:[y0 = y2]) ifTrue:[^nil]. "Nothing to do"		"Load and transform points"		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x2.		self point2Get at: 1 put: y2.		self transformPoints: 2.		^self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: leftFill 			rightFill: rightFill.	].	"Need bezier curve"	"Load and transform points"	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	self transformPoints: 3.	segs _ self loadAndSubdivideBezierFrom: self point1Get 				via: self point2Get 				to: self point3Get 				isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).	engineStopped ifTrue:[^nil].	self loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: segs.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/25/1998 00:28'!loadCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList pointShort: pointsShort	"Load a compressed shape into the engine.		WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!!!!!	"	| leftRun rightRun widthRun lineFillRun	leftLength rightLength widthLength lineFillLength	leftValue rightValue widthValue lineFillValue |	self inline: false. "Don't you!!!!!!!!"	self var: #points declareC:'int *points'.	self var: #leftFills declareC:'int *leftFills'.	self var: #rightFills declareC:'int *rightFills'.	self var: #lineWidths declareC:'int *lineWidths'.	self var: #lineFills declareC:'int *lineFills'.	self var: #fillIndexList declareC:'int *fillIndexList'.	nSegments = 0 ifTrue:[^0].	"Initialize run length encodings"	leftRun _  rightRun _ widthRun _ lineFillRun _ -1.	leftLength _ rightLength _ widthLength _ lineFillLength _ 1.	leftValue _ rightValue _ widthValue _ lineFillValue _ 0.	1 to: nSegments do:[:i|		"Decrement current run length and load new stuff"		(leftLength _ leftLength - 1) <= 0 ifTrue:[			leftRun _ leftRun + 1.			leftLength _ self shortRunLengthAt: leftRun from: leftFills.			leftValue _ self shortRunValueAt: leftRun from: leftFills.			leftValue = 0 ifFalse:[				leftValue _ fillIndexList at: leftValue-1.				leftValue _ self transformColor: leftValue.				engineStopped ifTrue:[^nil]]].		(rightLength _ rightLength - 1) <= 0 ifTrue:[			rightRun _ rightRun + 1.			rightLength _ self shortRunLengthAt: rightRun from: rightFills.			rightValue _ self shortRunValueAt: rightRun from: rightFills.			rightValue = 0 ifFalse:[				rightValue _ fillIndexList at: rightValue-1.				rightValue _ self transformColor: rightValue]].		(widthLength _ widthLength - 1) <= 0 ifTrue:[			widthRun _ widthRun + 1.			widthLength _ self shortRunLengthAt: widthRun from: lineWidths.			widthValue _ self shortRunValueAt: widthRun from: lineWidths.			widthValue = 0 ifFalse:[widthValue _ self transformWidth: widthValue]].		(lineFillLength _ lineFillLength - 1) <= 0 ifTrue:[			lineFillRun _ lineFillRun + 1.			lineFillLength _ self shortRunLengthAt: lineFillRun from: lineFills.			lineFillValue _ self shortRunValueAt: lineFillRun from: lineFills.			lineFillValue = 0 ifFalse:[lineFillValue _ fillIndexList at: lineFillValue-1]].		self loadCompressedSegment: i - 1			from: points 			short: pointsShort 			leftFill: leftValue 			rightFill: rightValue 			lineWidth: widthValue 			lineColor: lineFillValue.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 23:09'!loadArrayPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill	| x0 y0 x1 y1 |	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: points).	interpreterProxy failed ifTrue:[^nil].	x0 _ self point1Get at: 0.	y0 _ self point1Get at: 1.	1 to: nPoints-1 do:[:i|		self loadPoint: self point1Get from: (interpreterProxy fetchPointer: i ofObject: points).		interpreterProxy failed ifTrue:[^nil].		x1 _ self point1Get at: 0.		y1 _ self point1Get at: 1.		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 23:14'!loadArrayShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill 	| pointOop x0 y0 x1 y1 x2 y2 segs |	self inline: false.	0 to: nSegments-1 do:[:i|		pointOop _ interpreterProxy fetchPointer: (i * 3) ofObject: points.		self loadPoint: self point1Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 1) ofObject: points.		self loadPoint: self point2Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 2) ofObject: points.		self loadPoint: self point3Get from: pointOop.		interpreterProxy failed ifTrue:[^nil].		self transformPoints: 3.		x0 _ self point1Get at: 0.		y0 _ self point1Get at: 1.		x1 _ self point2Get at: 0.		y1 _ self point2Get at: 1.		x2 _ self point3Get at: 0.		y2 _ self point3Get at: 1.		"Check if we can use a line"		((x0 = y0 and:[x1 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[			self loadWideLine: lineWidth				from: self point1Get				to: self point3Get				lineFill: lineFill				leftFill: fillIndex				rightFill: 0.		] ifFalse:["Need bezier"			segs _ self loadAndSubdivideBezierFrom: self point1Get					via: self point2Get					to: self point3Get					isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).			engineStopped ifTrue:[^nil].			self loadWideBezier: lineWidth				lineFill: lineFill				leftFill: fillIndex				rightFill: 0				n: segs.		].		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 23:10'!loadPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill pointsShort: isShort	| x0 y0 x1 y1 |	self var:#points declareC:'int *points'.	isShort ifTrue:[		x0 _ self loadPointShortAt: 0 from: points.		y0 _ self loadPointShortAt: 1 from: points.	] ifFalse:[		x0 _ self loadPointIntAt: 0 from: points.		y0 _ self loadPointIntAt: 1 from: points.	].	1 to: nPoints-1 do:[:i|		isShort ifTrue:[			x1 _ self loadPointShortAt: i*2 from: points.			y1 _ self loadPointShortAt: i*2+1 from: points.		] ifFalse:[			x1 _ self loadPointIntAt: i*2 from: points.			y1 _ self loadPointIntAt: i*2+1 from: points.		].		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/24/1998 21:14'!loadShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill  pointsShort: pointsShort	self inline: false.	self var:#points declareC:'int *points'.	1 to: nSegments do:[:i|		self loadCompressedSegment: i-1			from: points			short: pointsShort			leftFill: fillIndex			rightFill: 0			lineWidth: lineWidth			lineColor: lineFill.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 21:50'!fillLinearGradient: fill from: leftX to: rightX at: yValue	"Draw a linear gradient fill."	| x0 x1 ramp rampSize dsX ds x rampIndex |	self inline: false.	self var: #ramp declareC:'int *ramp'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	dsX _ self fillDirectionXOf: fill.	ds _ ((leftX - (self fillOriginXOf: fill)) * dsX) + 			((yValue - (self fillOriginYOf: fill)) * (self fillDirectionYOf: fill)).	x _ x0 _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	[(rampIndex _ ds // 16r10000) < 0 and:[x < x1]] 		whileTrue:[	x _ x + 1.					ds _ ds + dsX].	x > x0 ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: 0)) from: x0 to: x].	"Part two: Fill everything inside the boundaries"	self aaLevelGet = 1 ifTrue:[		"Fast version w/o anti-aliasing"		[((rampIndex _ ds // 16r10000) < rampSize and:[rampIndex >= 0]) and:[x < x1]] whileTrue:[			spanBuffer at: x put: (self makeUnsignedFrom: (ramp at: rampIndex)).			x _ x + 1.			ds _ ds + dsX.		].	] ifFalse:[x _ self fillLinearGradientAA: fill ramp: ramp ds: ds dsX: dsX from: x to: rightX].	"Part three fill everything outside right boundary"	x < x1 ifTrue:[		rampIndex < 0 ifTrue:[rampIndex _ 0].		rampIndex >= rampSize ifTrue:[rampIndex _ rampSize-1].		self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampIndex)) from: x to: x1].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 19:02'!fillRadialDecreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ rightX.	x1 > (self fillOriginXOf: fill) ifTrue:[x1 _ self fillOriginXOf: fill].	[x < x1] whileTrue:[		"Try to copy the current value more than just once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		"Step to next ramp value"		nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[nextLength < length2] whileTrue:[			rampIndex _ rampIndex - 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			length2 _ (rampIndex-1) * (rampIndex-1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 19:02'!fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength x1	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ self fillOriginXOf: fill.	x1 > rightX ifTrue:[x1 _ rightX].	firstPixel _ self aaFirstPixelFrom: leftX to: x1.	lastPixel _ self aaLastPixelFrom: leftX to: x1.	"Deal with the first n sub-pixels"	(x < firstPixel) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the full pixels"	(x < lastPixel) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the last n sub-pixels"	(x < x1) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < x1] whileTrue:[			"Try to copy the current value more than just once"			[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/24/1998 19:02'!fillRadialGradient: fill from: leftX to: rightX at: yValue	"Draw a radial gradient fill."	| x x1 ramp rampSize dsX ds dtX dt length2 deltaX deltaY deltaST |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:'int *deltaST'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	deltaX _ leftX - (self fillOriginXOf: fill).	deltaY _ yValue - (self fillOriginYOf: fill).	dsX _ self fillDirectionXOf: fill.	dtX _ self fillNormalXOf: fill.	ds _ (deltaX * dsX) + (deltaY * (self fillDirectionYOf: fill)).	dt _ (deltaX * dtX) + (deltaY * (self fillNormalYOf: fill)).	x _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	[(self squaredLengthOf: ds // 16r10000 with: dt // 16r10000) >= length2 and:[x < x1]]		whileTrue:[	x _ x + 1.	ds _ ds + dsX.	dt _ dt + dtX].	x > leftX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: leftX to: x].	"Part two: Fill everything inside the boundaries"	deltaST _ self point1Get.	deltaST at: 0 put: ds.	deltaST at: 1 put: dt.	(x < (self fillOriginXOf: fill)) ifTrue:[		"Draw the decreasing part"		self aaLevelGet = 1 			ifTrue:[x _ self fillRadialDecreasing: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1].	].	x < x1 ifTrue:[		"Draw the increasing part"		self aaLevelGet = 1			ifTrue:[x _ self fillRadialIncreasing: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1].	].	"Part three fill everything outside right boundary"	x < rightX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: x to: rightX].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/27/1998 13:36'!loadFillOrientation: fill from: point1 along: point2 normal: point3 width: fillWidth height: fillHeight	"Transform the points"	| dirX dirY nrmX nrmY dsLength2 dsX dsY dtLength2 dtX dtY |	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	point2 at: 0 put: (point2 at: 0) + (point1 at: 0).	point2 at: 1 put: (point2 at: 1) + (point1 at: 1).	point3 at: 0 put: (point3 at: 0) + (point1 at: 0).	point3 at: 1 put: (point3 at: 1) + (point1 at: 1).	self transformPoint: point1.	self transformPoint: point2.	self transformPoint: point3.	dirX _ (point2 at: 0) - (point1 at: 0).	dirY _ (point2 at: 1) - (point1 at: 1).	nrmX _ (point3 at: 0) - (point1 at: 0).	nrmY _ (point3 at: 1) - (point1 at: 1).	"Compute the scale from direction/normal into ramp size"	dsLength2 _ (dirX * dirX) + (dirY * dirY).	dsLength2 > 0 ifTrue:[		dsX _ (dirX asFloat * fillWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.		dsY _ (dirY asFloat * fillWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.	] ifFalse:[ dsX _ 0. dsY _ 0].	dtLength2 _ (nrmX * nrmX) + (nrmY * nrmY).	dtLength2 > 0 ifTrue:[		dtX _ (nrmX asFloat * fillHeight asFloat * 65536.0 / dtLength2 asFloat) asInteger.		dtY _ (nrmY asFloat * fillHeight asFloat * 65536.0 / dtLength2 asFloat) asInteger.	] ifFalse:[dtX _ 0. dtY _ 0].	self fillOriginXOf: fill put: (point1 at: 0).	self fillOriginYOf: fill put: (point1 at: 1).	self fillDirectionXOf: fill put: dsX.	self fillDirectionYOf: fill put: dsY.	self fillNormalXOf: fill put: dtX.	self fillNormalYOf: fill put: dtY.! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/25/1998 16:44'!loadGradientFill: rampOop from: point1 along: point2 normal: point3 isRadial: isRadial	"Load the gradient fill as defined by the color ramp."	| rampWidth fill |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	(interpreterProxy fetchClassOf: rampOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	rampWidth _ interpreterProxy slotSizeOf: rampOop.	fill _ self allocateGradientFill: (interpreterProxy firstIndexableField: rampOop)				rampWidth: rampWidth isRadial: isRadial.	engineStopped ifTrue:[^nil].	self loadFillOrientation: fill 		from: point1 along: point2 normal: point3 		width: rampWidth height: rampWidth.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:38'!allocateBezier	| bezier |	(self allocateObjEntry: GBBaseSize) ifFalse:[^0].	bezier _ objUsed.	objUsed _ bezier + GBBaseSize.	self objectTypeOf: bezier put: GEPrimitiveBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBBaseSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 16:40'!allocateBitmapFill: cmSize colormap: cmBits	| fill fillSize cm |	self var:#cm declareC:'int *cm'.	self var:#cmBits declareC:'int *cmBits'.	fillSize _ GBMBaseSize + cmSize.	(self allocateObjEntry: fillSize) ifFalse:[^0].	fill _ objUsed.	objUsed _ fill + fillSize.	self objectTypeOf: fill put: GEPrimitiveClippedBitmapFill.	self objectIndexOf: fill put: 0.	self objectLengthOf: fill put: fillSize.	cm _ self colormapOf: fill.	self hasColorTransform ifTrue:[		0 to: cmSize-1 do:[:i| cm at: i put: (self transformColor: (cmBits at: i))].	] ifFalse:[		0 to: cmSize-1 do:[:i| cm at: i put: (cmBits at: i)].	].	self bitmapCmSizeOf: fill put: cmSize.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:38'!allocateGradientFill: ramp rampWidth: rampWidth isRadial: isRadial	| fill fillSize rampPtr |	self var:#ramp declareC:'int *ramp'.	self var:#rampPtr declareC:'int *rampPtr'.	fillSize _ GGBaseSize + rampWidth.	(self allocateObjEntry: fillSize) ifFalse:[^0].	fill _ objUsed.	objUsed _ fill + fillSize.	isRadial		ifTrue:[self objectTypeOf: fill put: GEPrimitiveRadialGradientFill]		ifFalse:[self objectTypeOf: fill put: GEPrimitiveLinearGradientFill].	self objectIndexOf: fill put: 0.	self objectLengthOf: fill put: fillSize.	rampPtr _ self gradientRampOf: fill.	self hasColorTransform ifTrue:[		0 to: rampWidth-1 do:[:i| rampPtr at: i put: (self transformColor: (ramp at: i))].	] ifFalse:[		0 to: rampWidth-1 do:[:i| rampPtr at: i put: (ramp at: i)].	].	self gradientRampLengthOf: fill put: rampWidth.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:39'!allocateLine	| line |	(self allocateObjEntry: GLBaseSize) ifFalse:[^0].	line _ objUsed.	objUsed _ line + GLBaseSize.	self objectTypeOf: line put: GEPrimitiveLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLBaseSize.	^line! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:39'!allocateWideBezier	| bezier |	(self allocateObjEntry: GBWideSize) ifFalse:[^0].	bezier _ objUsed.	objUsed _ bezier + GBWideSize.	self objectTypeOf: bezier put: GEPrimitiveWideBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBWideSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/25/1998 00:39'!allocateWideLine	| line |	(self allocateObjEntry: GLWideSize) ifFalse:[^0].	line _ objUsed.	objUsed _ line + GLWideSize.	self objectTypeOf: line put: GEPrimitiveWideLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLWideSize.	^line! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/25/1998 19:27'!rShiftTable	| theTable |	self returnTypeC:'int *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static int theTable[17] =		{0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1}'.	^theTable! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillDirectionXOf: fill	^self obj: fill at: GFDirectionX! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillDirectionXOf: fill put: value	^self obj: fill at: GFDirectionX put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:19'!fillDirectionYOf: fill	^self obj: fill at: GFDirectionY! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillDirectionYOf: fill put: value	^self obj: fill at: GFDirectionY put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillNormalXOf: fill	^self obj: fill at: GFNormalX! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillNormalXOf: fill put: value	^self obj: fill at: GFNormalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillNormalYOf: fill	^self obj: fill at: GFNormalY! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:16'!fillNormalYOf: fill put: value	^self obj: fill at: GFNormalY put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:17'!fillOriginXOf: fill	^self obj: fill at: GFOriginX! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:17'!fillOriginXOf: fill put: value	^self obj: fill at: GFOriginX put: value! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:17'!fillOriginYOf: fill	^self obj: fill at: GFOriginY! !!BalloonEnginePlugin methodsFor: 'accessing fills' stamp: 'ar 11/24/1998 22:18'!fillOriginYOf: fill put: value	^self obj: fill at: GFOriginY put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:20'!bitmapCmSizeOf: bmFill	^self obj: bmFill at: GBColormapSize! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:19'!bitmapCmSizeOf: bmFill put: value	^self obj: bmFill at: GBColormapSize put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapDepthOf: bmFill	^self obj: bmFill at: GBBitmapDepth! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:20'!bitmapDepthOf: bmFill put: value	^self obj: bmFill at: GBBitmapDepth put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapHeightOf: bmFill	^self obj: bmFill at: GBBitmapHeight! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapHeightOf: bmFill put: value	^self obj: bmFill at: GBBitmapHeight put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapRasterOf: bmFill	^self obj: bmFill at: GBBitmapRaster! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapRasterOf: bmFill put: value	^self obj: bmFill at: GBBitmapRaster put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:19'!bitmapSizeOf: bmFill	^self obj: bmFill at: GBBitmapSize! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapSizeOf: bmFill put: value	^self obj: bmFill at: GBBitmapSize put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/27/1998 14:20'!bitmapTileFlagOf: bmFill	^self obj: bmFill at: GBTileFlag! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/27/1998 14:20'!bitmapTileFlagOf: bmFill put: value	^self obj: bmFill at: GBTileFlag put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:18'!bitmapWidthOf: bmFill	^self obj: bmFill at: GBBitmapWidth! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/24/1998 22:17'!bitmapWidthOf: bmFill put: value	^self obj: bmFill at: GBBitmapWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing bitmaps' stamp: 'ar 11/25/1998 16:39'!colormapOf: bmFill	self returnTypeC:'int *'.	^objBuffer + bmFill + GBColormapOffset! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/25/1998 21:33'!bitmapValue: bmFill bits: bits atX: xp y: yp	| bmDepth bmRaster value rShift cMask r g b a |	self inline: true.	bmDepth _ self bitmapDepthOf: bmFill.	bmRaster _ self bitmapRasterOf: bmFill.	bmDepth = 32 ifTrue:[		value _ (self cCoerce: bits to:'int*') at: (bmRaster * yp) + xp.		(value ~= 0 and:[(value bitAnd: 16rFF000000) = 0])				ifTrue:[value _ value bitOr: 16rFF000000].		^self uncheckedTransformColor: value].	"rShift - shift value to convert from pixel to word index"	rShift _ self rShiftTable at: bmDepth.	value _ self makeUnsignedFrom: 		((self cCoerce: bits to:'int*') at: (bmRaster * yp) + (xp >> rShift)).	"cMask - mask out the pixel from the word"	cMask _ (1 << bmDepth) - 1.	"rShift - shift value to move the pixel in the word to the lowest bit position"	rShift _ 32 - bmDepth - ((xp bitAnd: (1 << rShift - 1)) * bmDepth).	value _ (value >> rShift) bitAnd: cMask.	bmDepth = 16 ifTrue:[		"Must convert by expanding bits"		value = 0 ifFalse:[			b _ (value bitAnd: 31) << 3.		b _ b + (b >> 5).			g _ (value >> 5 bitAnd: 31) << 3.	g _ g + (g >> 5).			r _ (value >> 10 bitAnd: 31) << 3.	r _ r + (r >> 5).			a _ 255.			value _ b + (g << 8) + (r << 16) + (a << 24)].	] ifFalse:[		"Must convert by using color map"		(self bitmapCmSizeOf: bmFill) = 0			ifTrue:[value _ 0]			ifFalse:[value _ self makeUnsignedFrom: ((self colormapOf: bmFill) at: value)].	].	^self uncheckedTransformColor: value.! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:19'!clampValue: value max: maxValue	self inline: true.	value < 0 		ifTrue:[^0]		ifFalse:[value >= maxValue 					ifTrue:[^maxValue-1]					ifFalse:[^value]]! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/25/1998 19:46'!fillBitmapSpan	self inline: true.	^self fillBitmapSpan: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:23'!fillBitmapSpan: bmFill from: leftX to: rightX at: yValue	| x x1 dsX ds dtX dt deltaX deltaY bits xp yp bmWidth bmHeight fillValue tileFlag |	self inline: false.	self var: #bits declareC:'int *bits'.	self aaLevelGet = 1		ifFalse:[^self fillBitmapSpanAA: bmFill from: leftX to: rightX at: yValue].	bits _ self loadBitsFrom: bmFill.	bits == nil ifTrue:[^nil].	bmWidth _ self bitmapWidthOf: bmFill.	bmHeight _ self bitmapHeightOf: bmFill.	tileFlag _ (self bitmapTileFlagOf: bmFill) = 1.	deltaX _ leftX - (self fillOriginXOf: bmFill).	deltaY _ yValue - (self fillOriginYOf: bmFill).	dsX _ self fillDirectionXOf: bmFill.	dtX _ self fillNormalXOf: bmFill.	ds _ (deltaX * dsX) + (deltaY * (self fillDirectionYOf: bmFill)).	dt _ (deltaX * dtX) + (deltaY * (self fillNormalYOf: bmFill)).	x _ leftX.	x1 _ rightX.	[x < x1] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			spanBuffer at: x put: fillValue.		].		ds _ ds + dsX.		dt _ dt + dtX.		x _ x + 1.	].! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:23'!fillBitmapSpanAA: bmFill from: leftX to: rightX at: yValue	| x dsX ds dtX dt deltaX deltaY bits xp yp bmWidth bmHeight fillValue baseShift cMask cShift idx aaLevel firstPixel lastPixel tileFlag |	self inline: false.	self var: #bits declareC:'int *bits'.	bits _ self loadBitsFrom: bmFill.	bits == nil ifTrue:[^nil].	bmWidth _ self bitmapWidthOf: bmFill.	bmHeight _ self bitmapHeightOf: bmFill.	tileFlag _ (self bitmapTileFlagOf: bmFill) = 1.	deltaX _ leftX - (self fillOriginXOf: bmFill).	deltaY _ yValue - (self fillOriginYOf: bmFill).	dsX _ self fillDirectionXOf: bmFill.	dtX _ self fillNormalXOf: bmFill.	ds _ (deltaX * dsX) + (deltaY * (self fillDirectionYOf: bmFill)).	dt _ (deltaX * dtX) + (deltaY * (self fillNormalYOf: bmFill)).	aaLevel _ self aaLevelGet.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	baseShift _ self aaShiftGet.	cMask _ self aaColorMaskGet.	cShift _ self aaColorShiftGet.	x _ leftX.	[x < firstPixel] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			fillValue _ (fillValue bitAnd: cMask) >> cShift.			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + fillValue.		].		ds _ ds + dsX.		dt _ dt + dtX.		x _ x + 1.	].	cMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.	cShift _ self aaShiftGet.	[x < lastPixel] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			fillValue _ (fillValue bitAnd: cMask) >> cShift.			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + fillValue.		].		ds _ ds + (dsX << cShift).		dt _ dt + (dtX << cShift).		x _ x + aaLevel.	].	cMask _ self aaColorMaskGet.	cShift _ self aaColorShiftGet.	[x < rightX] whileTrue:[		tileFlag ifTrue:[			ds _ self repeatValue: ds max: bmWidth << 16.			dt _ self repeatValue: dt max: bmHeight << 16].		xp _ ds // 16r10000.		yp _ dt // 16r10000.		tileFlag ifFalse:[			xp _ self clampValue: xp max: bmWidth.			yp _ self clampValue: yp max: bmHeight].		(xp >= 0 and:[yp >= 0 and:[xp < bmWidth and:[yp < bmHeight]]]) ifTrue:[			fillValue _ self bitmapValue: bmFill bits: bits atX: xp y: yp.			fillValue _ (fillValue bitAnd: cMask) >> cShift.			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + fillValue.		].		ds _ ds + dsX.		dt _ dt + dtX.		x _ x + 1.	].! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:24'!loadBitmapFill: formOop colormap: cmOop tile: tileFlag from: point1 along: point2 normal: point3 xIndex: xIndex	"Load the bitmap fill."	| bmFill cmSize cmBits bmBits bmBitsSize bmWidth bmHeight bmDepth ppw bmRaster |	self var: #cmBits declareC:'int *cmBits'.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	cmOop == interpreterProxy nilObject ifTrue:[		cmSize _ 0.		cmBits _ nil.	] ifFalse:[		(interpreterProxy fetchClassOf: cmOop) == interpreterProxy classBitmap			ifFalse:[^interpreterProxy primitiveFail].		cmSize _ interpreterProxy slotSizeOf: cmOop.		cmBits _ interpreterProxy firstIndexableField: cmOop.	].	(interpreterProxy isIntegerObject: formOop) 		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: formOop) 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: formOop) < 5 		ifTrue:[^interpreterProxy primitiveFail].	bmBits _ interpreterProxy fetchPointer: 0 ofObject: formOop.	(interpreterProxy fetchClassOf: bmBits) == interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	bmBitsSize _ interpreterProxy slotSizeOf: bmBits.	bmWidth _ interpreterProxy fetchInteger: 1 ofObject: formOop.	bmHeight _ interpreterProxy fetchInteger: 2 ofObject: formOop.	bmDepth _ interpreterProxy fetchInteger: 3 ofObject: formOop.	interpreterProxy failed ifTrue:[^nil].	(bmWidth >= 0 and:[bmHeight >= 0]) ifFalse:[^interpreterProxy primitiveFail].	(bmDepth = 32) | (bmDepth = 8) | (bmDepth = 16) | 		(bmDepth = 1) | (bmDepth = 2) | (bmDepth = 4)			ifFalse:[^interpreterProxy primitiveFail].	(cmSize = 0 or:[cmSize = (1 << bmDepth)])		ifFalse:[^interpreterProxy primitiveFail].	ppw _ 32 // bmDepth.	bmRaster _ bmWidth + (ppw-1) // ppw.	bmBitsSize = (bmRaster * bmHeight)		ifFalse:[^interpreterProxy primitiveFail].	bmFill _ self allocateBitmapFill: cmSize colormap: cmBits.	engineStopped ifTrue:[^nil].	self bitmapWidthOf: bmFill put: bmWidth.	self bitmapHeightOf: bmFill put: bmHeight.	self bitmapDepthOf: bmFill put: bmDepth.	self bitmapRasterOf: bmFill put: bmRaster.	self bitmapSizeOf: bmFill put: bmBitsSize.	self bitmapTileFlagOf: bmFill put: tileFlag.	self objectIndexOf: bmFill put: xIndex.	self loadFillOrientation: bmFill		from: point1 along: point2 normal: point3		width: bmWidth height: bmHeight.	^bmFill! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/25/1998 17:25'!loadBitsFrom: bmFill	"Note: Assumes that the contents of formArray has been checked before"	| xIndex formOop bitsOop bitsLen |	self returnTypeC:'int *'.	xIndex _ self objectIndexOf: bmFill.	xIndex > (interpreterProxy slotSizeOf: formArray) ifTrue:[^nil].	formOop _ interpreterProxy fetchPointer: xIndex ofObject: formArray.	bitsOop _ interpreterProxy fetchPointer: 0 ofObject: formOop.	bitsLen _ interpreterProxy slotSizeOf: bitsOop.	bitsLen = (self bitmapSizeOf: bmFill) ifFalse:[^nil].	^interpreterProxy firstIndexableField: bitsOop! !!BalloonEnginePlugin methodsFor: 'fills-bitmaps' stamp: 'ar 11/27/1998 14:14'!repeatValue: delta max: maxValue	| newDelta |	self inline: true.	newDelta _ delta.	[newDelta < 0] whileTrue:[newDelta _ newDelta + maxValue].	[newDelta >= maxValue] whileTrue:[newDelta _ newDelta - maxValue].	^newDelta! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/24/1998 20:50'!colorTransform	^super colorTransform asPluggableAccessor:		(Array 			with:[:obj :index| obj floatAt: index]			with:[:obj :index :value| obj floatAt: index put: value])! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/24/1998 20:50'!edgeTransform	^super edgeTransform asPluggableAccessor:		(Array 			with:[:obj :index| obj floatAt: index]			with:[:obj :index :value| obj floatAt: index put: value])! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/25/1998 19:24'!rShiftTable	^CArrayAccessor on: #(0 5 4 0 3 0 0 0 2 0 0 0 0 0 0 0 1).! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/25/1998 02:23'!stopBecauseOf: stopReason	"Don't stop because of need to flush."	stopReason = GErrorNeedFlush ifFalse:[		^super stopBecauseOf: stopReason.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/25/1998 00:43'!debugPrintObjects	| object end |	self inline: false.	object _ 0.	end _ objUsed.	[object < end] whileTrue:[		Transcript cr; 			nextPut:$#; print: object; space;			print: (self objectHeaderOf: object); space.		(self isEdge: object) 			ifTrue:[Transcript nextPutAll:'(edge) '].		(self isFill:object)			ifTrue:[Transcript nextPutAll:'(fill) '].		Transcript print: (self objectLengthOf: object); space.		Transcript endEntry.		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineSimulation methodsFor: 'initialize' stamp: 'ar 11/24/1998 19:25'!initialize! !!CObjectAccessor methodsFor: 'converting' stamp: 'ar 11/24/1998 20:51'!asPluggableAccessor: accessorArray	^((CPluggableAccessor on: object) += offset)		readBlock: accessorArray first		writeBlock: accessorArray last! !!CPluggableAccessor methodsFor: 'initialize' stamp: 'ar 11/24/1998 20:51'!readBlock: rBlock writeBlock: wBlock	readBlock _ rBlock.	writeBlock _ wBlock! !!CPluggableAccessor methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:45'!at: index	^readBlock value: object value: index + offset + 1! !!CPluggableAccessor methodsFor: 'accessing' stamp: 'ar 11/24/1998 20:45'!at: index put: value	^writeBlock value: object value: index + offset + 1 value: value! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/29/1998 15:49'!m23PrimitiveInvertPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3InvertPoint: matrix.	interpreterProxy failed ifFalse:[self roundAndStoreResultPoint: 2].! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 11/29/1998 15:50'!m23PrimitiveInvertRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	interpreterProxy failed ifFalse:[		dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !BalloonEngineBase removeSelector: #transformPoints:haveMatrix:!BalloonEngineBase removeSelector: #transformPoint:haveMatrix:!BalloonEngineBase removeSelector: #loadMatrixFrom:!BalloonEngineBase removeSelector: #toggleFill:depth:!BalloonEngineBase removeSelector: #loadWordMatrixFrom:!BalloonEngineBase removeSelector: #loadArrayMatrixFrom:!BalloonEngineBase removeSelector: #transformWidth:haveMatrix:!BalloonEngineBase removeSelector: #showFill:depth:!BalloonEnginePlugin removeSelector: #loadShape:nSegments:fill:lineWidth:lineFill:pointsShort:haveMatrix:!BalloonEnginePlugin removeSelector: #loadGradientFill:from:along:normal:isRadial:haveMatrix:!BalloonEnginePlugin removeSelector: #loadCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:fillIndexList:haveMatrix:pointShort:!BalloonEnginePlugin removeSelector: #gradientNormalYOf:put:!BalloonEnginePlugin removeSelector: #gePrimitiveAddLineWithMatrix!BalloonEnginePlugin removeSelector: #gradientOriginYOf:!BalloonEnginePlugin removeSelector: #loadArrayPolygon:nPoints:fill:lineWidth:lineFill:haveMatrix:!BalloonEnginePlugin removeSelector: #gradientOriginXOf:!BalloonEnginePlugin removeSelector: #loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort:haveMatrix:!BalloonEnginePlugin removeSelector: #loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor:haveMatrix:!BalloonEnginePlugin removeSelector: #gePrimitiveAddOvalWithMatrix!BalloonEnginePlugin removeSelector: #gradientDirectionXOf:put:!BalloonEnginePlugin removeSelector: #gradientNormalXOf:put:!BalloonEnginePlugin removeSelector: #gradientNormalYOf:!BalloonEnginePlugin removeSelector: #gradientNormalXOf:!BalloonEnginePlugin removeSelector: #gradientDirectionYOf:put:!BalloonEnginePlugin removeSelector: #gradientDirectionXOf:!BalloonEnginePlugin removeSelector: #gradientDirectionYOf:!BalloonEnginePlugin removeSelector: #gradientOriginXOf:put:!BalloonEnginePlugin removeSelector: #gePrimitiveAddRectWithMatrix!BalloonEnginePlugin removeSelector: #gePrimitiveAddBezierWithMatrix!BalloonEnginePlugin removeSelector: #gradientOriginYOf:put:!BalloonEnginePlugin removeSelector: #loadArrayShape:nSegments:fill:lineWidth:lineFill:haveMatrix:!BalloonEnginePlugin removeSelector: #loadOval:lineFill:leftFill:rightFill:haveMatrix:!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."BalloonEngineBase initPool.!