'From Squeak2.9alpha of 13 June 2000 [latest update: #2854] on 10 October 2000 at 10:17:42 pm'!"Change Set:		EventCleanupDate:			10 October 2000Author:			Andreas RaabA bit of cleanup in the event stuff. Removes an unused instVar from the mouse over handler and makes sure #handleEvent: is called from all places rather than any of the handler methods directly."!Object subclass: #MouseOverHandler	instanceVariableNames: 'mouseOverMorphs enteredMorphs overMorphs leftMorphs isDrag '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!HaloMorph methodsFor: 'events' stamp: 'ar 10/10/2000 22:00'!rejectsEvent: anEvent	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it."	(super rejectsEvent: anEvent) ifTrue:[^true].	anEvent isDropEvent ifTrue:[^true]. "never attempt to drop on halos"	^false! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:13'!dispatchDropEvent: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."	| inside index morphs child localEvt |	"Try to get out quickly"	(aMorph fullBounds containsPoint: anEvent cursorPoint)		ifFalse:[^#rejected].	"Give aMorph a chance to repel the dropping morph"	aMorph rejectDropEvent: anEvent.	anEvent wasHandled ifTrue:[^self].	"Go looking if any of our submorphs wants it"	index _ 1.	inside _ false.	morphs _ aMorph submorphs.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			localEvt wasHandled ifTrue:[^anEvent wasHandled: true]. "done"			inside _ true.			index _ morphs size]. "break"		index _ index + 1.	].	inside ifFalse:[inside _ aMorph containsPoint: anEvent cursorPoint event: anEvent].	inside ifTrue:[^aMorph handleEvent: anEvent].	^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:14'!dispatchMouseDown: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. Default rules:	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event."	| globalPt localEvt index child morphs handler inside lastHandler |	"Try to get out quickly"	globalPt _ anEvent cursorPoint.	(aMorph fullBounds containsPoint: globalPt) ifFalse:[^#rejected].	"Install the prospective handler for the receiver"	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"	handler _ aMorph handlerForMouseDown: anEvent.	handler ifNotNil:[anEvent handler: handler].	"Now give our submorphs a chance to handle the event"	index _ 1.	morphs _ aMorph submorphs.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Some child did contain the point so we're part of the top-most chain."			inside _ false.			localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].			index _ morphs size].		index _ index + 1.	].	(inside == false or:[aMorph containsPoint: anEvent cursorPoint event: anEvent]) ifTrue:[		"Receiver is in the top-most unlocked, visible chain."		handler ifNotNil:[handler handleEvent: anEvent].		"Note: Re-installing the handler is not really necessary but good style."		anEvent handler: lastHandler.		^self	].	"Mouse was not on receiver nor any of its children"	anEvent handler: lastHandler.	^#rejected! !!MouseOverHandler methodsFor: 'event handling' stamp: 'ar 10/10/2000 21:18'!processMouseOver: anEvent	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus evt |	hand _ anEvent hand.	leftMorphs _ mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs _ WriteStream on: (Array new: leftMorphs size).	enteredMorphs _ WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs size = 0 and:[enteredMorphs position = 0]) 		ifTrue:[^leftMorphs _ enteredMorphs _ overMorphs _ nil].	focus _ hand mouseFocus.	"Send #mouseLeave as appropriate"	evt _ anEvent asMouseLeave.	leftMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[localEvt _ evt transformedBy: (m transformedFrom: hand).					m handleEvent: localEvt]			ifFalse:[overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	evt _ anEvent asMouseEnter.	enteredMorphs _ enteredMorphs contents.	enteredMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[	localEvt _ evt transformedBy: (m transformedFrom: hand).					m handleEvent: localEvt]].	"And remember the over list"	mouseOverMorphs _ overMorphs contents.	leftMorphs _ enteredMorphs _ overMorphs _ nil.! !!NewMorphicEvent methodsFor: 'accessing' stamp: 'ar 10/10/2000 21:28'!cursorPoint	"Backward compatibility. Use #position instead"	^ self position! !!NewMorphicEvent methodsFor: 'testing' stamp: 'ar 10/10/2000 21:27'!isKeystroke	^false! !!MouseEvent methodsFor: 'converting' stamp: 'ar 10/10/2000 21:17'!asMouseEnter	^self clone setType: #mouseEnter! !!MouseEvent methodsFor: 'converting' stamp: 'ar 10/10/2000 21:17'!asMouseLeave	^self clone setType: #mouseLeave! !!MouseEvent methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:15'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #mouseOver ifTrue:[^anObject handleMouseOver: self].	type == #mouseEnter ifTrue:[^anObject handleMouseEnter: self].	type == #mouseLeave ifTrue:[^anObject handleMouseLeave: self].	^super sentTo: anObject.! !!MouseEvent methodsFor: 'private' stamp: 'ar 10/10/2000 21:15'!setType: aSymbol	"For quick conversion between event types"	type _ aSymbol.! !!MouseMoveEvent methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:15'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #mouseMove ifTrue:[^anObject handleMouseMove: self].	^super sentTo: anObject.! !MouseMoveEvent removeSelector: #beMouseEnter!MouseMoveEvent removeSelector: #beMouseLeave!Object subclass: #MouseOverHandler	instanceVariableNames: 'mouseOverMorphs enteredMorphs overMorphs leftMorphs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!