'From Squeak2.9alpha of 17 July 2000 [latest update: #2590] on 10 September 2000 at 11:56:36 am'!"Change Set:		fasterHandDate:			10 September 2000Author:			Bob Arning- reduce the number of times #worldUnderCursor is sent for a given event since it is expensive to calculate in some cases"!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab currentCommand worldUnderCursor '	classVariableNames: 'DoubleClickTime NormalCursor PasteBuffer '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!!HandMorph methodsFor: 'event handling' stamp: 'RAA 9/10/2000 11:52'!processEvents	"Process user input events from the local input devices.	Note: Ugly as it is, several places in Morphic currently rely on sending at least one mouse event per cycle. There's no way around this so we're checking if the first event is a mouse event and if not, we synthesize one.	Another interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt currentExtent evtBuf type hadMouse |	hadMouse _ false. "see first note above"	[evtBuf _ Sensor nextEvent.	worldUnderCursor _ nil.		"start over for each event"	evtBuf isNil and:[hadMouse]] whileFalse:[		evtBuf == nil ifTrue:[			"Make us a fake mouse event so hadMouse will be true"			evtBuf _ Array with: EventTypeMouse							with: Time millisecondClockValue							with: lastEvent cursorPoint x							with: lastEvent cursorPoint y							with: (lastEvent buttons bitAnd: 7)							with: (lastEvent buttons bitShift: 3)].		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		type = EventTypeMouse ifTrue:[			hadMouse _ true.			evt _ MorphicEvent new				setMousePoint: (evtBuf at: 3) @ (evtBuf at: 4)				buttons: (evtBuf at: 5)				modifiers: (evtBuf at: 6)				lastEvent: lastEvent				hand: self].		(type = EventTypeKeyboard) ifTrue:[			evt _ MorphicEvent new				setKeyValue: (evtBuf at: 3)				type: (evtBuf at: 4)				mousePoint: self position				modifiers: (evtBuf at: 5)				hand: self].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				lastWorldExtent _ currentExtent].			self transmitEvent: evt].		"Finally, handle it"		self handleEvent: evt.		"See the note on running a World in MVC in the method comment"		(hadMouse and:[Sensor eventQueue == nil]) ifTrue:[worldUnderCursor _ nil. ^self].	].! !!HandMorph methodsFor: 'world hacking' stamp: 'RAA 9/9/2000 21:46'!worldUnderCursor	^worldUnderCursor ifNil: [		worldUnderCursor _ (owner ifNil: [^super worldUnderCursor]) worldUnderCursor	].! !!HandMorph methodsFor: 'object fileIn' stamp: 'RAA 9/10/2000 11:54'!convertbosfceekmmmdccffuleatdccttggrtllmhssffac0: varDict bosfceekmmmdccffuleatdccttggrtllmhssffacw0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'eventSubscribers' 'keyboardFocus' 'mouseDownMorph' 'mouseOverMorphs' 'mouseOverTimes' 'dragOverMorphs' 'clickClient' 'clickState' 'firstClickEvent' 'firstClickTime' 'userInitials' 'lastEvent' 'eventTransform' 'argument' 'targetOffset' 'damageRecorder' 'cacheCanvas' 'cachedCanvasHasHoles' 'temporaryCursor' 'temporaryCursorOffset' 'grid' 'gridOn' 'remoteConnections' 'transmitBuffer' 'lastEventTransmitted' 'lastWorldExtent' 'menuTargetOffset' 'hasChanged' 'savedPatch' 'suppressDrawing' 'formerOwner' 'formerPosition' 'addedFlexAtGrab' 'currentCommand').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('worldUnderCursor')  If a non-nil value is needed, please assign it."	"worldUnderCursor is just fine as nil"! !