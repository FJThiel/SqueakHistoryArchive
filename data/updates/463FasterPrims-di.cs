'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 12:49:37 pm'!"Change Set:		FasterPrimsDate:			5 December 1998Author:			Your Name<your descriptive text goes here>"!!Interpreter methodsFor: 'return bytecodes' stamp: 'di 12/4/1998 01:02'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self internalPush: resultObj.	"self internalQuickCheckForInterrupts."! !!Interpreter methodsFor: 'primitive support' stamp: 'di 12/5/1998 12:09'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	successFlag _ true.	nextWakeupTick = 0 ifTrue:		[self dispatchOn: primitiveIndex in: PrimitiveTable.		^ successFlag].	startTime _ self ioLowResMSecs.	self dispatchOn: primitiveIndex in: PrimitiveTable.	self ioLowResMSecs ~= startTime ifTrue:		["primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: ["process the interrupt now"						self checkForInterrupts]				ifFalse: ["process the interrupt in primtive failure code"						interruptCheckCounter _ 0]]].	^ successFlag! !