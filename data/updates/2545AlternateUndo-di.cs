'From Squeak2.9alpha of 12 June 2000 [latest update: #2537] on 30 August 2000 at 4:21:42 pm'!"Change Set:		AlternateUndoDate:			30 August 2000Author:			Dan IngallsThis changeSet provides an alternate protocol and representation for undoable commandsSelectors and argument arrays are used in place of blocks and parameter dictionaries."!Object subclass: #Command	instanceVariableNames: 'phase commandee parameters undoBlock redoBlock cmdWording undoTarget undoArguments redoTarget redoArguments undoSelector redoSelector '	classVariableNames: 'CommandExcursions CommandHistory LastCommand '	poolDictionaries: ''	category: 'Morphic-Undo'!!Command commentStamp: 'di 8/30/2000 16:06' prior: 0!An object representing an undoable command to be done in the environment.Structure:	phase			indicates whether the cmd is current in undone or redone mode 	cmdWording		The wording of the command (used in arming the "undo"/"redo" menu items 	parameters		an IdentityDictionary /NOT USED/	undoTarget		Receiver, selector and arguments to accomplish undo	undoSelector	undoArguments	redoTarget		Receiver, selector and arguments to accomplish redo	redoSelector	redoArgumentsTo use this, for any command you wish to use, you	*	Create an instance of Command, as follows...			cmd _ Command new cmdWording: 'resizing'.	*	Give the the command undo state and redo state, as follows...			cmd undoTarget: target selector: #extent: argument: oldExtent.			cmd redoTarget: target selector: #extent: argument: newExtent.	*	Send a message of the form			Command rememberCommand: cmdLastCommand is the last command that was actually done or undone.CommandHistory, applicable only when infiniteUndo is set, holds a 'tape' of the complete history of commands, as far back as it's possible to go.CommandExcursions, also applicable only in the infiniteUndo case, and rather at the fringe even then, holds segments of former CommandHistory that have been lopped off because of variant paths taken.!!Object methodsFor: 'accessing' stamp: 'di 8/30/2000 13:14'!doIfNotNil: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 14:09'!printOn: aStream	"Provide more detailed info about the receiver, put in for debugging, maybe should be removed"	super printOn: aStream.	aStream nextPutAll: ' phase: ', phase printString.	cmdWording ifNotNil: [aStream nextPutAll: '; ', cmdWording asString].	parameters ifNotNil:		[parameters associationsDo:			[:assoc | aStream nextPutAll: ': ', assoc printString]]! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 13:04'!redoTarget: target selector: aSymbol argument: argument	^ self redoTarget: target selector: aSymbol arguments: {argument}! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 12:28'!redoTarget: target selector: aSymbol arguments: arguments	redoTarget _ target.	redoSelector _ aSymbol.	redoArguments _ arguments! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 15:58'!remember	Command rememberCommand: self! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 13:04'!undoTarget: target selector: aSymbol argument: argument	^ self undoTarget: target selector: aSymbol arguments: {argument}! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 12:26'!undoTarget: target selector: aSymbol arguments: arguments	undoTarget _ target.	undoSelector _ aSymbol.	undoArguments _ arguments! !!Command methodsFor: 'command execution' stamp: 'di 8/30/2000 16:04'!doCommand	"Do the command represented by the receiver.  Not actually called by active current code, but reachable by the not-yet-unsealed promoteToCurrent: action."	redoTarget ifNotNil: [redoTarget perform: redoSelector withArguments: redoArguments]! !!Command methodsFor: 'command execution' stamp: 'di 8/30/2000 16:04'!redoCommand	"Perform the 'redo' operation"	redoTarget ifNotNil: [redoTarget perform: redoSelector withArguments: redoArguments]! !!Command methodsFor: 'command execution' stamp: 'di 8/30/2000 16:02'!undoCommand	"Perform the 'undo' operation"	undoTarget ifNotNil: [undoTarget perform: undoSelector withArguments: undoArguments]! !!Form methodsFor: 'displaying' stamp: 'di 8/30/2000 15:57'!setAsBackground	"Set this form as a background image."	| world newColor |	Smalltalk isMorphic 		ifTrue:			[world _ self currentWorld.			newColor _ InfiniteForm with: self.			Command new cmdWording: 'set background to a picture';				undoTarget: world selector: #color: argument: world color;				redoTarget: world selector: #color: argument: newColor;				remember.			world color: newColor]		ifFalse:			[ScheduledControllers screenController model form: self.			Display restoreAfter: []]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/30/2000 15:22'!undoCommand: cmd redo: redo owner: formerOwner bounds: formerBounds predecessor: formerPredecessor	self owner ifNil: [^ self beep].	redo ifFalse:		["undo sets up the redo state first"		cmd redoTarget: self			selector: #undoCommand:redo:owner:bounds:predecessor:			arguments: {cmd. true. owner. bounds. (owner morphPreceding: self)}].	formerOwner ifNotNil:		[formerPredecessor			ifNil: [formerOwner addMorphBack: self]			ifNotNil: [formerOwner addMorph: self after: formerPredecessor]].	self bounds: formerBounds.	(self isKindOf: SystemWindow) ifTrue: [self activate]! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'di 8/30/2000 13:49'!originalColor: colorOrSymbol	"Set the receiver's original color.  It is at this point that a command is launched to represent the action of the picker, in support of Undo."	originalColor _ (colorOrSymbol isKindOf: Color)		ifTrue: [colorOrSymbol]		ifFalse: [Color lightGreen].	originalForm fill: RevertBox fillColor: originalColor.	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: 'color change';			undoTarget: target selector: selector arguments: (self argumentsWith: originalColor))! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'di 8/30/2000 13:40'!selector: aSymbol	"Set the selector to be associated with the receiver.  Store it in the receiver's command, if appropriate"	selector _ aSymbol.	self updateSelectorDisplay! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 8/30/2000 13:47'!argumentsWith: aColor	"Return an argument array appropriate to this action selector"	| nArgs |	nArgs _ selector numArgs.	nArgs = 1 ifTrue:[^ {aColor}].	nArgs = 2 ifTrue:[^ {aColor. sourceHand}].	nArgs = 3 ifTrue:[^ {aColor. argument. sourceHand}].! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 8/30/2000 13:47'!updateTargetColorWith: aColor	"Update the target so that it reflects aColor as the color choice"	(target ~~ nil and: [selector ~~ nil]) ifTrue:		[self updateSelectorDisplay.		^ target perform: selector withArguments: (self argumentsWith: aColor)]! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 8/30/2000 13:54'!delete	"The moment of departure has come.  If the receiver has an affiliated command, finalize it and have the system remember it.  In any case, delete the receiver"	(self valueOfProperty: #commandInProgress) doIfNotNil:		[:cmd | selectedColor ~= originalColor ifTrue:			[cmd redoTarget: target selector: selector arguments: (self argumentsWith: selectedColor).			Command rememberCommand: cmd]].	super delete! !!HaloMorph methodsFor: 'private' stamp: 'di 8/30/2000 13:28'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse |	newExtent _ (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	target renderedMorph extent: (extentToUse _ newExtent max: minExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) doIfNotNil:  		[:cmd | "Update the final extent"		cmd redoTarget: target selector: #extent: argument: extentToUse]! !!HaloMorph methodsFor: 'private' stamp: 'di 8/30/2000 13:28'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |	degrees _ (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	((innerTarget isKindOf: SketchMorph) and: [innerTarget rotationStyle == #normal]) ifTrue:		[self removeAllHandlesBut: rotHandle.		target player ifNotNil: [self addDirectionShaft]].	target rotationDegrees: degrees.	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	(self valueOfProperty: #commandInProgress) doIfNotNil:		[:cmd | "Update the final rotation"		cmd redoTarget: target selector: #rotationDegrees: argument: degrees].	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'di 8/30/2000 13:16'!endInteraction	"Clean up after a user interaction with the a halo control"	| m |	(target isInWorld not or: [owner == nil]) ifTrue: [^ self].	[target isFlexMorph and: [target hasNoScaleOrRotation]]		whileTrue:			[m _ target firstSubmorph.			target removeFlexShell.			target _ m].	self isInWorld ifTrue:		["make sure handles show in front, even if flex shell added"		self comeToFront.		self addHandles].	(self valueOfProperty: #commandInProgress) doIfNotNil:		[:cmd | Command rememberCommand: cmd.		self removeProperty: #commandInProgress] ! !!HaloMorph methodsFor: 'private' stamp: 'di 8/30/2000 12:29'!startGrow: evt with: growHandle	| botRt |	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	growingOrRotating _ true.	self removeAllHandlesBut: growHandle.  "remove all other handles"	botRt _ target pointInWorld: target bottomRight.	(self world viewBox containsPoint: botRt)		ifTrue: [positionOffset _ evt cursorPoint - botRt]		ifFalse: [positionOffset _ 0@0].	target isAlignmentMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 1@1].	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: 'resizing';			undoTarget: target selector: #extent: argument: target extent)! !!HaloMorph methodsFor: 'private' stamp: 'di 8/30/2000 13:21'!startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"	target isFlexMorph ifFalse: 		[target isInWorld ifFalse: [self setTarget: target player costume].		target addFlexShell].	growingOrRotating _ true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset _ evt cursorPoint - (target pointInWorld: target referencePosition).	angleOffset _ Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees.	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: 'rotating';			undoTarget: target selector: #rotationDegrees: argument: target rotationDegrees)! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 8/30/2000 15:29'!grabMorphInner: aMorph	"The real work of grabbing a morph.  Set up a command object to represent the forthcoming move (in support of Undo), then actually wrench the morph out of its old home and add it as one of MY submorphs."	| myPos morphPos localPt trans morphToGrab newT |	formerOwner _ aMorph owner.	formerPosition _ aMorph position.	(formerOwner notNil and: [(aMorph isKindOf: NewHandleMorph orOf: MenuMorph) not]) ifTrue:		[(currentCommand _ Command new)			cmdWording: 'move ', (aMorph externalName truncateTo: 10);			undoTarget: aMorph				selector: #undoCommand:redo:owner:bounds:predecessor:				arguments: {currentCommand. false. formerOwner. aMorph bounds. (formerOwner morphPreceding: aMorph)}].	"Check if the morph will keep its transform while grabbed"	myPos _ self position.	morphPos _ aMorph position.	localPt _ (aMorph keepsTransform "or: [formerOwner isNil]")		ifTrue:[myPos]		ifFalse:[((aMorph world ifNil: [self worldUnderCursor]) 							globalPointToLocal: myPos) truncated].						"fix grabbing new morph in embedded world"	(formerOwner == nil		or: [aMorph keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		aMorph position: myPos + (morphPos - localPt).		morphToGrab _ aMorph.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ aMorph addFlexShell transform: trans asMorphicTransform.		aMorph position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	(morphToGrab isKindOf: PhraseTileMorph) ifTrue:		[morphToGrab position: Sensor cursorPoint].	self addMorphBack: morphToGrab! !!UndefinedObject methodsFor: 'testing' stamp: 'di 8/30/2000 13:15'!doIfNotNil: aBlock	"Override to do nothing."	^ self! !ColorPickerMorph removeSelector: #command!ColorPickerMorph removeSelector: #command:!Command removeSelector: #commandee!Command removeSelector: #commandee:!Command removeSelector: #redoBlock:!Command removeSelector: #undoBlock:!Object subclass: #Command	instanceVariableNames: 'phase cmdWording undoTarget undoSelector undoArguments redoTarget redoSelector redoArguments parameters '	classVariableNames: 'CommandExcursions CommandHistory LastCommand '	poolDictionaries: ''	category: 'Morphic-Undo'!"Postscript:Drop all obsolete commands..."Command resetCommandHistory!