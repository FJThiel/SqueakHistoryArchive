'From Squeak2.9alpha of 13 June 2000 [latest update: #3389] on 2 February 2001 at 3:52:35 pm'!"Change Set:		MoreNamedPrims-arDate:			2 February 2001Author:			Andreas RaabMaps the obsolete named primitives to their actual versions in the image."!!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!floatAt: index	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!B3DPrimitiveVertex methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!floatAt: index put: value	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!floatAt: index	"For simulation only"	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!floatAt: index put: value	"For simulation only"	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:48'!primClipRectInto: rect	<primitive: 'primitiveGetClipRect' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:47'!primFlushNeeded	<primitive: 'primitiveNeedsFlush' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:47'!primFlushNeeded: aBoolean	<primitive: 'primitiveNeedsFlushPut' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetAALevel	"Set the AA level"	<primitive: 'primitiveGetAALevel' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetBezierStats: statsArray	<primitive: 'primitiveGetBezierStats' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetClipRect: rect	<primitive: 'primitiveGetClipRect' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetCounts: statsArray	<primitive: 'primitiveGetCounts' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:47'!primGetDepth	<primitive: 'primitiveGetDepth' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetFailureReason	<primitive: 'primitiveGetFailureReason' module: 'B2DPlugin'>	^0! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetOffset	<primitive: 'primitiveGetOffset' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primGetTimes: statsArray	<primitive: 'primitiveGetTimes' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primSetAALevel: level	"Set the AA level"	<primitive: 'primitiveSetAALevel' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primSetClipRect: rect	<primitive: 'primitiveSetClipRect' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:47'!primSetColorTransform: transform	<primitive: 'primitiveSetColorTransform' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:47'!primSetDepth: depth	<primitive: 'primitiveSetDepth' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:47'!primSetEdgeTransform: transform	<primitive: 'primitiveSetEdgeTransform' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 2/2/2001 15:49'!primSetOffset: point	<primitive: 'primitiveSetOffset' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'primitiveAddBezier' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	<primitive: 'primitiveAddBezierShape' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	<primitive: 'primitiveAddBitmapFill' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	<primitive: 'primitiveAddCompressedShape' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'primitiveRegisterExternalEdge' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddExternalFill: index	<primitive: 'primitiveRegisterExternalFill' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalFill: index	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial	<primitive: 'primitiveAddGradientFill' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddGradientFill: colorRamp 				from: origin 				along: direction 				normal: normal 				radial: isRadial	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'primitiveAddLine' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	<primitive: 'primitiveAddOval' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	<primitive: 'primitiveAddPolygon' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 2/2/2001 15:47'!primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	<primitive: 'primitiveAddRect' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:48'!primAddActiveEdgeTableEntryFrom: edgeEntry	"Add edge entry to the AET."	<primitive: 'primitiveAddActiveEdgeEntry' module: 'B2DPlugin'>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddActiveEdgeTableEntryFrom: edgeEntry	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:48'!primChangeActiveEdgeTableEntryFrom: edgeEntry	"Change the entry in the active edge table from edgeEntry"	<primitive: 'primitiveChangedActiveEdgeEntry' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:48'!primDisplaySpanBuffer	"Display the current scan line if necessary"	<primitive: 'primitiveDisplaySpanBuffer' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primFinishedProcessing	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	<primitive: 'primitiveFinishedProcessing' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primInitializeProcessing	"Initialize processing in the GE.	Create the active edge table and sort it."	<primitive: 'primitiveInitializeProcessing' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primMergeFill: fillBitmap from: fill	"Merge the filled bitmap into the current output buffer."	<primitive: 'primitiveMergeFillFrom' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primNextActiveEdgeEntryInto: edgeEntry	"Store the next entry of the AET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'primitiveNextActiveEdgeEntry' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primNextFillEntryInto: fillEntry	"Store the next fill entry of the active edge table in fillEntry.	Return false if there is no such entry, true otherwise"	<primitive: 'primitiveNextFillEntry' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primNextGlobalEdgeEntryInto: edgeEntry	"Store the next entry of the GET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'primitiveNextGlobalEdgeEntry' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primRenderImage: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'primitiveRenderImage' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 2/2/2001 15:49'!primRenderScanline: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'primitiveRenderScanline' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 2/2/2001 15:48'!primCopyBufferFrom: oldBuffer to: newBuffer	"Copy the contents of oldBuffer into the (larger) newBuffer"	<primitive: 'primitiveCopyBuffer' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 2/2/2001 15:49'!primInitializeBuffer: buffer	<primitive: 'primitiveInitializeBuffer' module: 'B2DPlugin'>	^self primitiveFailed! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!doProfileStats: aBool	"Note: On Macintosh systems turning on profiling can significantly	degrade the performance of Balloon since we're using the high	accuracy timer for measuring."	"BalloonEngine doProfileStats: true"	"BalloonEngine doProfileStats: false"	<primitive: 'primitiveDoProfileStats' module: 'B2DPlugin'>	^false! !!DeflateStream methodsFor: 'private' stamp: 'ar 2/2/2001 15:47'!updateHashTable: table delta: delta	| pos |	<primitive: 'primitiveDeflateUpdateHashTable' module: 'ZipPlugin'>	1 to: table size do:[:i|		"Discard entries that are out of range"		(pos _ table at: i) >= delta			ifTrue:[table at: i put: pos - delta]			ifFalse:[table at: i put: 0]].! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 2/2/2001 15:47'!pluginTransformData: forward	"Plugin testing -- if the primitive is not implemented 	or cannot be found run the simulation. See also: FFTPlugin"	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	^FFTPlugin doPrimitive: 'primitiveFFTTransformData'.! !!FastInflateStream methodsFor: 'inflating' stamp: 'ar 2/2/2001 15:47'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	<primitive: 'primitiveInflateDecompressBlock' module: 'ZipPlugin'>	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit _ readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra _ (value bitShift: -16) - 1.			length _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ (value bitShift: -16).			distance _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length >= collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length + 1 					with: collection 					startingAt: readLimit - distance + 1.			readLimit _ readLimit + length.		].	].! !!FloatArray methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!at: index	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!FloatArray methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!at: index put: value	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!FloatArray methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!= aFloatArray 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	aFloatArray class = self class ifFalse: [^ false].	length _ self size.	length = aFloatArray size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aFloatArray at: i) ifFalse: [^ false]].	^ true! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primAddArray: floatArray	<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primAddScalar: scalarValue	<primitive: 'primitiveAddScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primDivArray: floatArray	<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primDivScalar: scalarValue	<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primMulArray: floatArray	<primitive: 'primitiveMulFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primMulScalar: scalarValue	<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primSubArray: floatArray	<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 2/2/2001 15:47'!primSubScalar: scalarValue	<primitive: 'primitiveSubScalar' module: 'FloatArrayPlugin'>	1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue].! !!B3DFloatArray methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!floatAt: index	"For subclasses that override #at:"	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!B3DFloatArray methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!floatAt: index put: value	"For subclasses that override #at:put:"	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	self basicAt: index put: value asIEEE32BitWord.	^value! !!B3DMatrix4x4 methodsFor: 'arithmetic' stamp: 'ar 2/2/2001 15:47'!+ aB3DMatrix	"Optimized for Matrix/Matrix operations"	<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>	^super + aB3DMatrix! !!B3DMatrix4x4 methodsFor: 'arithmetic' stamp: 'ar 2/2/2001 15:47'!- aB3DMatrix	"Optimized for Matrix/Matrix operations"	<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>	^super - aB3DMatrix! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!at: index	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 2/2/2001 15:47'!at: index put: value	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 2/2/2001 15:47'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	<primitive: 'primitiveIsIdentity' module: 'Matrix2x3Plugin'>	^self isPureTranslation and:[self a13 = 0.0 and:[self a23 = 0.0]]! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 2/2/2001 15:47'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	<primitive: 'primitiveIsPureTranslation' module: 'Matrix2x3Plugin'>	^self a11 = 1.0 and:[self a12 = 0.0 and:[self a22 = 0.0 and:[self a21 = 1.0]]]! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!= aMatrixTransform2x3 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	self class = aMatrixTransform2x3 class ifFalse: [^ false].	length _ self size.	length = aMatrixTransform2x3 size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aMatrixTransform2x3 at: i) ifFalse: [^ false]].	^ true! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!hash	| result |	<primitive: 'primitiveHash' module: 'FloatArrayPlugin'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 2/2/2001 15:47'!composedWithLocal: aTransformation into: result	"Return the composition of the receiver and the local transformation passed in.	Store the composed matrix into result."	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |	<primitive: 'primitiveComposeMatrix' module: 'Matrix2x3Plugin'>	matrix _ aTransformation asMatrixTransform2x3.	a11 _ self a11.		b11 _ matrix a11.	a12 _ self a12.		b12 _ matrix a12.	a13 _ self a13.		b13 _ matrix a13.	a21 _ self a21.		b21 _ matrix a21.	a22 _ self a22.		b22 _ matrix a22.	a23 _ self a23.		b23 _ matrix a23.	result a11: (a11 * b11) + (a12 * b21).	result a12: (a11 * b12) + (a12 * b22).	result a13: a13 + (a11 * b13) + (a12 * b23).	result a21: (a21 * b11) + (a22 * b21).	result a22: (a21 * b12) + (a22 * b22).	result a23: a23 + (a21 * b13) + (a22 * b23).	^result! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 2/2/2001 15:47'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	<primitive: 'primitiveInvertPoint' module: 'Matrix2x3Plugin'>	^(self invertPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 2/2/2001 15:47'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	<primitive: 'primitiveTransformPoint' module: 'Matrix2x3Plugin'>	^(self transformPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 2/2/2001 15:47'!globalBounds: srcRect toLocal: dstRect	"Transform aRectangle from global coordinates into local coordinates"	<primitive: 'primitiveInvertRectInto' module: 'Matrix2x3Plugin'>	^super globalBoundsToLocal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 2/2/2001 15:47'!localBounds: srcRect toGlobal: dstRect	"Transform aRectangle from local coordinates into global coordinates"	<primitive: 'primitiveTransformRectInto' module: 'Matrix2x3Plugin'>	^super localBoundsToGlobal: srcRect! !!ZipEncoder methodsFor: 'private' stamp: 'ar 2/2/2001 15:47'!privateSendBlock: literalStream with: distanceStream with: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| lit dist code extra sum |	<primitive: 'primitiveZipSendBlock' module: 'ZipPlugin'>	sum _ 0.	[lit _ literalStream next.	dist _ distanceStream next.	lit == nil] whileFalse:[		dist = 0 ifTrue:["lit is a literal"			sum _ sum + 1.			self nextBits: (litTree bitLengthAt: lit)				put: (litTree codeAt: lit).		] ifFalse:["lit is match length"			sum _ sum + lit + MinMatch.			code _ (MatchLengthCodes at: lit + 1).			self nextBits: (litTree bitLengthAt: code)				put: (litTree codeAt: code).			extra _ ExtraLengthBits at: code-NumLiterals.			extra = 0 ifFalse:[				lit _ lit - (BaseLength at: code-NumLiterals).				self nextBits: extra put: lit.			].			dist _ dist - 1.			dist < 256				ifTrue:[code _ DistanceCodes at: dist + 1]				ifFalse:[code _ DistanceCodes at: 257 + (dist bitShift: -7)].			"self assert:[code < MaxDistCodes]."			self nextBits: (distTree bitLengthAt: code)				put: (distTree codeAt: code).			extra _ ExtraDistanceBits at: code+1.			extra = 0 ifFalse:[				dist _ dist - (BaseDistance at: code+1).				self nextBits: extra put: dist.			].		].	].	^sum! !!ZipWriteStream methodsFor: 'deflating' stamp: 'ar 2/2/2001 15:47'!deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch	"^DeflatePlugin doPrimitive:#primitiveDeflateBlock"	<primitive: 'primitiveDeflateBlock' module: 'ZipPlugin'>	^super deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 2/2/2001 15:47'!updateCrc: oldCrc from: start to: stop in: aCollection	| newCrc |	<primitive: 'primitiveUpdateGZipCrc32' module: 'ZipPlugin'>	newCrc _ oldCrc.	start to: stop do:[:i|		newCrc _ (CrcTable at: ((newCrc bitXor: (aCollection byteAt: i)) 				bitAnd: 255) + 1) bitXor: (newCrc bitShift: -8).	].	^newCrc! !