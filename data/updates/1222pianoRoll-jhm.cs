'From Squeak 2.4c of May 10, 1999 on 30 May 1999 at 9:28:36 pm'!"Change Set:		pianoRoll-jhmDate:			30 May 1999Author:			John MaloneyVarious piano roll improvements, including better performance (achievedby moving the cursor, rather than moving the notes under the cursor)and the ability to hide muted parts.Also adds a bassoon sound and a cool new FM clarinet (clarinet2). Check it out!!"!FMSound subclass: #FMBassoonSound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!FMSound subclass: #FMClarinetSound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!RectangleMorph subclass: #PianoRollScoreMorph	instanceVariableNames: 'scorePlayer score colorForTrack lowestNote leftEdgeTime timeScale indexInTrack lastUpdateTick lastMutedState cursor '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!FMBassoonSound methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 21:17'!setPitch: pitchNameOrNumber dur: d loudness: l	"Select a modulation ratio and modulation envelope scale based on my pitch."	| p modScale |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	modScale _ 9.4.	p > 100.0 ifTrue: [modScale _ 8.3].	p > 150.0 ifTrue: [modScale _ 6.4].	p > 200.0 ifTrue: [modScale _ 5.2].	p > 300.0 ifTrue: [modScale _ 3.9].	p > 400.0 ifTrue: [modScale _ 2.8].	p > 600.0 ifTrue: [modScale _ 1.7].	envelopes size > 0 ifTrue: [		envelopes do: [:e |			(e updateSelector = #modulation:)				ifTrue: [e scale: modScale]]].	super setPitch: p dur: d loudness: l.! !!FMClarinetSound reorganize!('initialization' setPitch:dur:loudness:)!!FMClarinetSound methodsFor: 'initialization' stamp: 'jm 5/30/1999 10:10'!setPitch: pitchNameOrNumber dur: d loudness: l	"Select a modulation ratio and modulation envelope scale based on my pitch."	| p modScale |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	p < 262.0		ifTrue: [modScale _ 25.0. self ratio: 4]		ifFalse: [modScale _ 20.0. self ratio: 2].	p > 524.0 ifTrue: [modScale _ 8.0].	envelopes size > 0 ifTrue: [		envelopes do: [:e |			(e updateSelector = #modulation:)				ifTrue: [e scale: modScale]]].	super setPitch: p dur: d loudness: l.! !!FMSound class methodsFor: 'instruments' stamp: 'jm 5/30/1999 20:37'!bassoon1	"FMSound bassoon1 play"	"(FMSound lowMajorScaleOn: FMSound bassoon1) play"	| snd p env |	snd _ FMBassoonSound new ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 40@0.45; add: 90@1.0; add: 180@0.9; add: 270@1.0; add: 320@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.2; add: 40@0.9; add: 90@0.6; add: 270@0.6; add: 320@0.5.	env _ Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #modulation:; scale: 5.05.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 5/30/1999 10:20'!clarinet2	"FMSound clarinet2 play"	"(FMSound lowMajorScaleOn: FMSound clarinet2) play"	| snd p env |	snd _ FMClarinetSound new modulation: 0 ratio: 2.	p _ OrderedCollection new.	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	p _ OrderedCollection new.	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.	env _ Envelope points: p loopStart: 2 loopEnd: 3.	env updateSelector: #modulation:; scale: 10.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 5/29/1999 18:56'!findStartPointAfter: index	"Answer the index of the last zero crossing sample before the given index."	| i |	i _ index min: lastSample.	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:55'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #openToDragAndDrop) == true		ifTrue: [aCustomMenu add: 'close drag anddrop' action: #closeDragAndDrop]		ifFalse: [aCustomMenu add: 'open drag and drop' action: #openDragAndDrop].! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:32'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"	(track _ score ambientTrack) ifNotNil:		[i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1]].	"Then add note morphs"	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size or: [scorePlayer mutedForTrack: trackIndex].		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated - 1.							visibleMorphs add:								("PianoRollNoteMorph"  Morph  "<-- Change comment quotes here**"									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	"Add the cursor morph in front of all notes."	cursor ifNil: [  "create the cursor if needed; this is for legacy PianoRollScoreMorphs..."		cursor _			Morph newBounds: (self topLeft extent: 1@1)  "height and position are set later"			color: Color red].	visibleMorphs addFirst: cursor.	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:28'!contractTime	timeScale _ timeScale / 1.5.	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:56'!drawOn: aCanvas	super drawOn: aCanvas.	self drawStaffOn: aCanvas.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:29'!expandTime	timeScale _ timeScale * 1.5.	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:57'!extent: aPoint	"Force rebuild when re-sized."	super extent: aPoint. 	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 18:37'!moveCursorToTime: scoreTime	| cursorOffset desiredCursorHeight |	cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger.	((cursorOffset < 0) or:	 [cursorOffset > (self width - (2 * borderWidth))]) ifTrue: [		self goToTime: scoreTime - (5.0 / timeScale) truncated.		self addNotes.		cursorOffset _ 0].	cursor position: (self left + borderWidth + cursorOffset)@(self top + borderWidth).	desiredCursorHeight _ self height.	cursor height ~= desiredCursorHeight ifTrue: [cursor extent: 1@desiredCursorHeight].! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 20:28'!on: aScorePlayer	| n |	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	lowestNote _ 24.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.	"find the actual lowest note in the score"	lowestNote _ 128.	score tracks do: [:track |		1 to: track size do: [:i |			n _ track at: i.			(n isNoteEvent and: [n midiKey < lowestNote])				ifTrue: [lowestNote _ n midiKey - 4]]].! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 17:28'!rebuildFromScore	"Rebuild my submorphs from the score. This method should be invoked after changing the time scale, the color or visibility of a track, the extent of this morph, etc."	score ifNil: [^ self].	self addNotes.	self moveCursorToTime: lastUpdateTick.! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 18:01'!step	| t |	score ifNil: [^ self].	lastMutedState ~= scorePlayer mutedState ifTrue: [		self rebuildFromScore.		lastMutedState _ scorePlayer mutedState copy].	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		self moveCursorToTime: t.		lastUpdateTick _ t].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 5/30/1999 17:16'!mutedState	^ muted! !"Postscript:Add new instruments to the library."AbstractSound soundNamed: 'clarinet2' put: FMSound clarinet2.AbstractSound soundNamed: 'bassoon1' put: FMSound bassoon1.!