'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 28 February 2001 update 3904] on 5 April 2001 at 9:53:15 am'!"Change Set:		versionFix-mirDate:			5 April 2001Author:			Michael RuegerFixes a few bugs in SystemVersion. It also adds all known updates at this time to the SystemVersion."!!ChangeSorter methodsFor: 'changeSet menu' stamp: 'mir 4/5/2001 09:44'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first,  and if doPrompt is true, get the user to confirm his intentions first"	| message aName changeSetNumber |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	(doPrompt and: [myChangeSet hasPreamble or: [myChangeSet hasPostscript]])		ifTrue:			[(self confirm: 'Caution!!  This change set has a preambleand/or a postscript, which will be lost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]].	"Go ahead and remove the change set"	changeSetNumber _ myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	AllChangeSets remove: myChangeSet.	myChangeSet wither.		"clear out its contents"	self showChangeSet: Smalltalk changes.! !!Utilities class methodsFor: 'fetching updates' stamp: 'mir 4/5/2001 09:47'!applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Utilities applyUpdatesFromDiskToUpdateNumber: 1234 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory _ self getUpdateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest _ SystemVersion current highestUpdate.	currentUpdateNumber _ previousHighest.	done _ false.	loaded _ 0.	[done]		whileFalse: [currentUpdateNumber _ currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done _ true]				ifFalse: [fileNames _ updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done _ stopIfGapFlag]						ifFalse: [ChangeSorter								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded _ loaded + 1]]].	aMessage _ loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!Utilities class methodsFor: 'fetching updates' stamp: 'mir 4/5/2001 09:39'!newUpdatesOn: serverList throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	existing _ SystemVersion current updates.	serverList do: [:server |		doc _ HTTPSocket httpGet: server,'updates.list' accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				itsNumber _ ff initialIntegerOrNil. 				(existing includes: itsNumber)					ifFalse:						[						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	PopUpMenu notify: 'All code update servers seem to be unavailable'.	^ out! !!Utilities class methodsFor: 'fetching updates' stamp: 'mir 4/5/2001 09:10'!readServer: serverList updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""Utilities readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| urls failed loaded docQueue this nextDoc docQueueSema str updateName |	Cursor wait showWhile: [	urls _ self newUpdatesOn: (serverList collect: [:url | url, 'updates/']) 				throughNumber: maxNumber.	loaded _ 0.	failed _ nil.	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	[ this _ docQueue next.	  nextDoc _ docQueue next.  	  nextDoc = #failed ifTrue: [ failed _ this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed _ this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage				ifTrue: [					updateName _ (this findTokens: '/') last.					ChangeSorter newChangesFromStream: nextDoc named: updateName.					SystemVersion current registerUpdate: updateName initialIntegerOrNil].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1].		docQueueSema signal].	].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str _ loaded printString ,' new update file(s) processed.'.		str _ str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !"Postscript:"| existing |	existing _ ChangeSorter allChangeSetNames.	existing _ existing collect: [:cngSet | cngSet copyReplaceAll: '/' with: '_'].	existing _ existing collect: [:each | each initialIntegerOrNil].	(existing select: [:each | each notNil]) asSet do: [:each |		SystemVersion current registerUpdate: each]	!