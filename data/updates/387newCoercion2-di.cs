'From Squeak 2.2 of Sept 23, 1998 on 6 November 1998 at 11:16:00 am'!"Change Set:		newCoercion2Date:			6 November 1998Author:			Dan IngallsThis is the second part of a new arithmetic coercion package for Squeak.See the file newCoercion1 for a full description."!!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!* arg	^ arg adaptToCollection: self andSend: #*! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!+ arg	^ arg adaptToCollection: self andSend: #+! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!- arg	^ arg adaptToCollection: self andSend: #-! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:53'!/ arg	^ arg adaptToCollection: self andSend: #/! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!// arg	^ arg adaptToCollection: self andSend: #//! !!Collection methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!\\ arg	^ arg adaptToCollection: self andSend: #\\! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!* aNumber 	"Primitive. Answer the result of multiplying the receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 49>	^ aNumber adaptToFloat: self andSend: #*! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:22'!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ aNumber adaptToFloat: self andSend: #+! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55'!- aNumber 	"Primitive. Answer the difference between the receiver and aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 42>	^ aNumber adaptToFloat: self andSend: #-! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0 ifTrue: [self error: 'attempt to divide by zero'].	^ aNumber adaptToFloat: self andSend: #/! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ aNumber adaptToFloat: self andSend: #<! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ aNumber adaptToFloat: self andSend: #<=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:56'!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ aNumber adaptToFloat: self andSend: #=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andSend: #>! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction ifTrue: 		[d1 _ numerator gcd: aNumber denominator.		d2 _ denominator gcd: aNumber numerator.		(d2 = denominator and: [d1 = aNumber denominator])			ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].		^ Fraction numerator: numerator // d1 * (aNumber numerator // d2)				denominator: denominator // d2 * (aNumber denominator // d1)].	^ aNumber adaptToFraction: self andSend: #*! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction ifTrue: 		[d _ denominator gcd: aNumber denominator.		n _ numerator * (d1 _ aNumber denominator // d) + (aNumber numerator * (d2 _ denominator // d)).		d1 _ d1 * d2.		n _ n // (d2 _ n gcd: d).		(d _ d1 * (d // d2)) = 1 ifTrue: [^ n].		^ Fraction numerator: n denominator: d].	^ aNumber adaptToFraction: self andSend: #+! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!- aNumber	"Answer the difference between the receiver and aNumber."	aNumber isFraction ifTrue:		[^ self + aNumber negated].	^ aNumber adaptToFraction: self andSend: #-! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!/ aNumber	"Answer the result of dividing the receiver by aNumber."	aNumber isFraction		ifTrue: [^self * aNumber reciprocal].	^ aNumber adaptToFraction: self andSend: #/! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58'!< aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator < (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #<! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [aNumber numerator = 0				ifTrue: [^ numerator = 0]				ifFalse: [^ aNumber numerator = numerator 							and: [aNumber denominator = denominator]]].	^ aNumber adaptToFraction: self andSend: #=! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue:		[^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative].	^ aNumber adaptToInteger: self andSend: #*! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ (self digitAdd: aNumber) normalize]			ifFalse: [^ self digitSubtract: aNumber]].	^ aNumber adaptToInteger: self andSend: #+! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!- aNumber	"Refer to the comment in Number - "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ self digitSubtract: aNumber]			ifFalse: [^ (self digitAdd: aNumber) normalize]].	^ aNumber adaptToInteger: self andSend: #-! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng _ self negative == aNumber negative == false.		quo _ (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andSend: #<! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andSend: #=! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andSend: #>! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!SmallInteger methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:12'!+ aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 1>	aNumber isInteger ifTrue: [^ super + aNumber].	^ aNumber adaptToInteger: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!* arg	^ arg adaptToString: self andSend: #*! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!+ arg	^ arg adaptToString: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!- arg	^ arg adaptToString: self andSend: #-! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!/ arg	^ arg adaptToString: self andSend: #/! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!// arg	^ arg adaptToString: self andSend: #//! !!String methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:03'!\\ arg	^ arg adaptToString: self andSend: #\\! !Number removeSelector: #adaptFloat:!Number removeSelector: #adaptToInteger!Number removeSelector: #adaptInteger:!Number removeSelector: #adaptToFloat!Number removeSelector: #adaptToFraction!Number removeSelector: #adaptFraction:!Float removeSelector: #adaptToInteger!Float removeSelector: #adaptToFraction!Float removeSelector: #adaptInteger:!Float removeSelector: #adaptFraction:!Fraction removeSelector: #adaptToFloat!Fraction removeSelector: #adaptToInteger!Fraction removeSelector: #adaptFloat:!Fraction removeSelector: #adaptInteger:!Integer removeSelector: #adaptToFloat!Integer removeSelector: #adaptFloat:!Integer removeSelector: #adaptToFraction!Integer removeSelector: #adaptFraction:!Point removeSelector: #adaptToFloat!Point removeSelector: #adaptToInteger!Point removeSelector: #adaptFloat:!Point removeSelector: #adaptInteger:!SmallInteger removeSelector: #adaptToFloat!