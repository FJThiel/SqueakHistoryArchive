'From Squeak2.7 of 5 January 2000 [latest update: #1797] on 27 January 2000 at 1:10:29 pm'!"Change Set:		vmSupportCode-jmDate:			27 January 2000Author:			John MaloneyUpdate the VM support code built into the image.Updated compareWithFilesInFolder: to include sqVirtualMachine.h and .c.Support code changes relevant to all platforms include:  sqPlatformSpecific.h -- minor tweak to support WinCE  sqFilePrims.c -- Support for 'sandbox' when running a web browser plugin.    The function plugInAllowAccessToFilePath() must be implemented to return true    if you use sqFilePrims.c.  Entry points were added to sqMacExternalPrims.c to support the upcoming    Foreign Function Interface; other platforms should add the new functions.Changes relevant only to the Mac included:  sqMacDirectory.c	-- support for 'sandbox'  sqMacNetwork.c	-- better error handling  sqMacSound.c		-- play silence if Squeak fails to fill a buffer in time  sqMacWindow.c	-- changes to support browser plugins and reduce footprint"!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 1/19/2000 14:01'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:Squeak VM Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqADPCMPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakADPCMCodecPrimsFile		ifFalse: [self inform: 'File sqADPCMPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqGSMCodecPlugin.c') contentsOfEntireFile =	InterpreterSupportCode squeakGSMCodecPluginFile		ifFalse: [self inform: 'File sqGSMCodecPlugin.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacExternalPrims.c') contentsOfEntireFile =	InterpreterSupportCode macExternalPrimsFile		ifFalse: [self inform: 'File sqMacExternalPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystickAndTablet.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickAndTabletFile		ifFalse: [self inform: 'File sqMacJoystickAndTablet.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.h') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineHeaderFile		ifFalse: [self inform: 'File sqVirtualMachine.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqVirtualMachine.c') contentsOfEntireFile =	InterpreterSupportCode squeakVirtualMachineFile		ifFalse: [self inform: 'File sqVirtualMachine.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 11:57'!macDirectoryFile	^ '#include <Files.h>#include <Strings.h>#include "sq.h" /***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delete(char *pathString, int pathStringLength) {	/* Delete the existing directory with the given path. */	int okay, refNum, volNum, i;	HParamBlockRec pb;	Str255 name;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return false;	}	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	okay = lookupPath(pathString, pathStringLength, &refNum, &volNum);	if (!!okay) {		return false;	}	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = volNum;	pb.fileParam.ioDirID = refNum;	return PBHDeleteSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if (!!plugInAllowAccessToFilePath(pathString, pathStringLength)) {		return NO_MORE_ENTRIES;	}	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}int dir_PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	char thisName[256];	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy(thisName, ":");	pb.hFileInfo.ioNamePtr = c2pstr(thisName);	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}		p2cstr((unsigned char *) thisName);		pathLen = prefixPathWith(pathName, pathLen, pathNameMax, thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (GetFInfo(name, 0, &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (SetFInfo(name, 0, &finderInfo) !!= noErr) return false;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {	/* Look up the next directory in a path starting from the folder and volume	   with the given reference numbers and setting *refNumPtr to the reference	   number of the resulting folder. Return true if this succeeds. */	CInfoPBRec pb;	c2pstr((char *) name);	pb.hFileInfo.ioNamePtr = (unsigned char *) name;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioVRefNum = volRefNum;	pb.hFileInfo.ioDirID = folderRefNum;	if (PBGetCatInfoSync(&pb) == noErr) {		p2cstr((unsigned char *) name);		*refNumPtr = pb.hFileInfo.ioDirID;		return true;	}	p2cstr((unsigned char *) name);	return false;}int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	char chunk[100];	int stIndex, chunkIndex, ch;	int okay, thisVolNum = 0, thisRefNum = 0;	int firstChunk = true, hasLeadingDelimitors = false;	stIndex = 0;	while (stIndex < pathStringLength) {		chunkIndex = 0;		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {			/* copy any leading delimitors */			chunk[chunkIndex++] = pathString[stIndex++];			hasLeadingDelimitors = true;		}		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {			/* copy up to the next delimitor */			ch = chunk[chunkIndex++] = pathString[stIndex++];		}		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {			/* Add a trailing delimiter to the first chunk of the			   path to indicate that it is a volume name. If the			   path starts with an initial delimitor, it will be			   interpreted as a path relative to the current working			   directory even with a trailing delimitor, which is			   exactly the behavior we want. */			chunk[chunkIndex++] = DELIMITOR;			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {				stIndex++;			}			firstChunk = false;		}		chunk[chunkIndex] = 0;  /* terminate this chunk */		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {			okay = lookupVolume(chunk, &thisVolNum);			thisRefNum = 0;		} else {			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);		}		if (!!okay) {			*refNumPtr = 0;			*volNumPtr = 0;			return false;		}	}	*refNumPtr = thisRefNum;	*volNumPtr = thisVolNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	volumeParams.ioNamePtr = c2pstr(volName);	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	p2cstr((unsigned char *) volName);	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		error("path name to working directory is too long for available space");	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = DELIMITOR;  /* insert delimitor */	return pathNameSize + offset;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 11:54'!macExternalPrimsFile	^ '#include <CodeFragments.h>#include <Strings.h>#include "sq.h"/*** Functions Exported to sqVirtualMachine.c ***/int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/*** Variables ***/CFragConnectionID squeakVMLib = nil;  /* connection to the VM itself as a shared library *//*** Function Type Declaration ***/typedef int (*RecordVMProxyProc)(struct VirtualMachine *interpreterProxy);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag);CFragConnectionID FindOrLoadLib(char *libName, int loadFlag) {	CFragLoadOptions action;	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg;	OSErr err;	action = loadFlag ? kLoadCFrag : kFindCFrag;	err = GetSharedLibrary(		c2pstr(libName), kCurrentCFragArch, action, &libHandle, &mainAddr, errorMsg);	p2cstr((unsigned char *) libName);  /* undo C to Pascal conversion */	if (err) {		return null;	}	return libHandle;}int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength, int moduleNameIndex, int moduleNameLength) {	Str255 functionName, moduleName;	CFragConnectionID libHandle;	CFragSymbolClass ignored;	Ptr functionPtr;	OSErr err;	int i, ok;	/* copy function and module names into C strings */	for (i = 0; i < functionNameLength; i++) {		functionName[i] = ((char *) functionNameIndex)[i];	}	functionName[functionNameLength] = 0;	for (i = 0; i < moduleNameLength; i++) {		moduleName[i] = ((char *) moduleNameIndex)[i];	}	moduleName[moduleNameLength] = 0;	/* find the library */	if (moduleNameLength > 0) {		/* look for the primitive in named library */		/* first try to find it */		libHandle = FindOrLoadLib((char *) moduleName, false);		if (!!libHandle) {			/* then try to load it */			libHandle = FindOrLoadLib((char *) moduleName, true);		}	} else {		/* look for the primitive in the Squeak VM itself */		if (!!squeakVMLib) {			/* try to get a handle on the Squeak VM itself, viewed as a library */			squeakVMLib = FindOrLoadLib("SqueakVMPrims", false);		}		libHandle = squeakVMLib;	}	if (!!libHandle) return success(false);  /* could not open the library */	/* if library is external, initialize its VMProxy pointer */	if (libHandle !!= squeakVMLib) {		/* get the setInterpreter() function */		err = FindSymbol(libHandle, "\psetInterpreter", &functionPtr, &ignored);		if (err) return success(false);		/* call setInterpreter() */		ok = ((RecordVMProxyProc) functionPtr)(sqGetInterpreterProxy());		if(!!ok) return success(false);	}	/* get the address of the desired primitive function */	c2pstr((char *) functionName);	err = FindSymbol(libHandle, functionName, &functionPtr, &ignored);	if (err) return success(false);	return (int) functionPtr;}int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength) {	Str255 moduleName;	CFragConnectionID libHandle;	int i;	/* copy module name into C string */	for (i = 0; i < moduleNameLength; i++) {		moduleName[i] = ((char *) moduleNameIndex)[i];	}	moduleName[moduleNameLength] = 0;	/* find the library */	if (moduleNameLength > 0) {		/* look for the named library */		/* first try to find it */		libHandle = FindOrLoadLib((char *) moduleName, false);		if (!!libHandle) {			/* then try to load it */			libHandle = FindOrLoadLib((char *) moduleName, true);		}	} else {		/* look for the Squeak VM itself */		if (!!squeakVMLib) {			/* try to get a handle on the Squeak VM itself, viewed as a library */			squeakVMLib = FindOrLoadLib("SqueakVMPrims", false);		}		libHandle = squeakVMLib;	}	if (!!libHandle) {  /* could not open the library */		success(false);		return nil;	}	return (int) libHandle;}int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle) {	Str255 functionName;	CFragConnectionID libHandle;	CFragSymbolClass ignored;	Ptr functionPtr;	OSErr err;	int i;	/* copy function and module names into C strings */	for (i = 0; i < functionNameLength; i++) {		functionName[i] = ((char *) functionNameIndex)[i];	}	functionName[functionNameLength] = 0;	/* get the address of the desired primitive function */	if (!!moduleHandle) moduleHandle = ioLoadModuleOfLength(0, 0);	libHandle = (CFragConnectionID) moduleHandle;	if (libHandle == nil) {		if (squeakVMLib !!= nil) {			libHandle = squeakVMLib;		} else {  /* no module handle */			success(false);			return nil;		}	}	c2pstr((char *) functionName);	err = FindSymbol(libHandle, functionName, &functionPtr, &ignored);		if (err) {  /* could not find the given function */		success(false);		return nil;	}	return (int) functionPtr;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 13:10'!macNetworkFile	^ '#include <MacHeaders.h>#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"#include "sq.h"/*** Socket TYpe Constants ***/#define TCPSocketType 0#define UDPSocketType 1/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	(8 * 1024)#define RecvBufferSize	(8 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of sockets */	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 8TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* open network driver */	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		return -1;	}	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		ResolverTerminate();		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;		} else {		mtuSize = 1024;  /* guess */		ResolverTerminate();		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);	} else {		success(false);	}}void sqSocketAcceptFromRecvBytesSendBytesSemaID(  SocketPtr s, SocketPtr serverSocket,  int recvBufSize, int sendBufSize, int semaIndex) {	/* xxx stubbed out */	success(false);}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);	} else {		success(false);	}}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	} else {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);	} else {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);	}}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}	} else {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}	}}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	} else {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	} else {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);	} else {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);	}}void sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {	/* xxx stubbed out */	success(false);}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	} else {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	} else {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	} else {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	} else {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	} else {		resolver.status = RESOLVER_SUCCESS;		resolver.error = noErr;	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;	resolver.error = OpenResolver(nil);	if (resolver.error !!= noErr) {		resolver.status = RESOLVER_ERROR;		return resolver.error;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	if ((r == null) || (r->status !!= RESOLVER_BUSY)) return;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;		s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	s->lastError = noErr;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	int sendCount;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;		/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	s->lastError = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;		if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;		s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void) {	// xxx	return nil;}void		UDPSockDestroy(UDPSockPtr s) {	// xxx	s;}int			UDPSockLocalAddress(UDPSockPtr s) {	// xxx	s;}int			UDPSockLocalPort(UDPSockPtr s) {	// xxx	s;}int			UDPSockRemoteAddress(UDPSockPtr s) {	// xxx	s;}int			UDPSockRemotePort(UDPSockPtr s) {	// xxx	s;}void		UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	// xxx	s; addr; port;}void		UDPSockListenOn(UDPSockPtr s, int port) {	// xxx	s; port;}int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	// xxx	s; buf; bufSize;}int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	// xxx	s; buf; bufSize;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 12:03'!macSoundFile	^ '#include <Sound.h>#include <SoundInput.h>#include "sq.h"/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 2)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, 0, 0, 0, 0, 0, true};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {  /* Switch buffers (at interrupt time). The given buffer just finished playing. */	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();	FillBufferWithSilence(buf);  /* avoids ugly stutter if not filled in time */}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 12:05'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & 0xFF;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	serialPortClose(0);	serialPortClose(1);	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */	ioProcessEvents();  /* process all pending events */}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}#ifdef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Plugin allocates Squeak object heap memory from the system heap. */	MaxBlockSys();	return NewPtrSys(desiredHeapSize);}#elsevoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */	MaxBlock();	return NewPtr(desiredHeapSize);}#endif/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 11:55'!squeakFilePrimsFile	^ '#include "sq.h"/***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	Files are always opened in binary mode; Smalltalk code	does (or someday will do) line-end conversion if needed.	Writeable files are opened read/write. The stdio spec	requires that a positioning operation be done when	switching between reading and writing of a read/write	filestream. The lastOp field records whether the last	operation was a read or write operation, allowing this	positioning operation to be done automatically if needed.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //	} SQFile;***//*** Constants ***/#define UNCOMMITTED	0#define READ_OP		1#define WRITE_OP	2#ifndef SEEK_SET#define SEEK_SET	0#define SEEK_CUR	1#define SEEK_END	2#endif/*** Variables ***/int thisSession = 0;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;	f->lastOp = UNCOMMITTED;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return success(false);	}	/* copy the file name into a null-terminated C string */	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (!!plugInAllowAccessToFilePath(cFileName, sqFileNameSize)) {		return success(false);	}	err = remove(cFileName);	if (err) {		return success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return success(false);	position = ftell(f->file);	if (position < 0) return success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return success(false);	}	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (!!plugInAllowAccessToFilePath(cFileName, sqFileNameSize)) {		return success(false);	}	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "r+b");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "w+b");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator(cFileName, strlen(cFileName), "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = UNCOMMITTED;}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return success(false);	if (f->writable && (f->lastOp == WRITE_OP)) fseek(f->file, 0, SEEK_CUR);  /* seek between writing and reading */	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	f->lastOp = READ_OP;	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return success(false);	}	/* copy the file names into null-terminated C strings */	for (i = 0; i < oldNameSize; i++) {		cOldName[i] = *((char *) (oldNameIndex + i));	}	cOldName[oldNameSize] = 0;	for (i = 0; i < newNameSize; i++) {		cNewName[i] = *((char *) (newNameIndex + i));	}	cNewName[newNameSize] = 0;	if (!!plugInAllowAccessToFilePath(cOldName, oldNameSize) ||		!!plugInAllowAccessToFilePath(cNewName, newNameSize)) {		return success(false);	}	err = rename(cOldName, cNewName);	if (err) {		return success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return success(false);	fseek(f->file, position, SEEK_SET);	f->lastOp = UNCOMMITTED;}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return success(false);	return f->fileSize;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return success(false);	if (f->lastOp == READ_OP) fseek(f->file, 0, SEEK_CUR);  /* seek between reading and writing */	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		success(false);	}	f->lastOp = WRITE_OP;	return bytesWritten;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/27/2000 11:54'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*/#ifdef UNIX/* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#endif /* UNIX */#ifdef macintosh/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#undef sqAllocateMemorytypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);void *						sqAllocateMemory(int minHeapSize, int desiredHeapSize);/* override reserveExtraCHeapBytes() macro to reduce Squeak object heap size on Mac */#undef reserveExtraCHeapBytes#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) (origHeapSize - bytesToReserve)/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num)/* undefine clock macros that are implemented as functions */#undef ioMicroMSecs#endif /* ACORN */#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#ifdef _MSC_VER#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioLowResMSecs#undef ioMicroMSecs/* Declare GetTickCount() in case <windows.h> is not included */#if !!defined(_WINDOWS_) && !!defined(_WIN32_WCE)__declspec(dllimport) unsigned long __stdcall GetTickCount(void);#endif#define ioLowResMSecs() GetTickCount()#endif /* WIN32 */'! !