'From Squeak2.8alpha of 12 January 2000 [latest update: #2299] on 8 June 2000 at 1:31:50 pm'!"Change Set:		AlternateSyntaxTweaksDate:			7 June 2000Author:			Dan IngallsA number of changes to render appropriate templates for alternate syntax."!!Browser methodsFor: 'accessing' stamp: 'di 6/7/2000 22:47'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClassOrMetaClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^ self selectedClassOrMetaClass definitionST80: Preferences printAlternateSyntax not].	editSelection == #editComment 		ifTrue: [(theClass _ self selectedClass) ifNil: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [^ 'This class has not yet been commented.']				ifFalse: [^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [^ self selectedClassOrMetaClass sourceCodeTemplate].	editSelection == #editMessage		ifTrue:			[currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	editSelection == #byteCodes ifTrue:		[^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)			symbolic asText].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'class functions' stamp: 'di 6/7/2000 21:43'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	keywdIx _ defTokens findFirst: [:x | x beginsWith: 'category'].	envt _ Smalltalk environmentForCategory: ((defTokens at: keywdIx+1) copyWithout: $').	keywdIx _ defTokens findFirst: [:x | x beginsWith: 'subclass'].	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [envt includesKeyOrAbove: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: [self changed: #classList.				self classListIndex: 					(self classList indexOf: 						((class isKindOf: Metaclass)							ifTrue: [class soleInstance name]							ifFalse: [class name])).				self clearUserEditFlag; editClass.				^ true]		ifFalse: [^ false]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 6/7/2000 21:48'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |	newDef _ class definition.	oldDef _ (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm _ ReadStream on: oldDef.	newStrm _ ReadStream on: newDef.	outStrm _ WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.	outStrm nextPutAll: (newStrm upToAll: 'instanceVariableNames'); nextPutAll: 'instanceVariableNames:';		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars _ (oldStrm upTo: $') findTokens: Character separators.	newVars _ (newStrm upTo: $') findTokens: Character separators.	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars _ (oldStrm upTo: $') findTokens: Character separators.		newVars _ (newStrm upTo: $') findTokens: Character separators.		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!ClassDescription methodsFor: 'printing' stamp: 'di 6/7/2000 22:23'!instanceVariablesString	"Answer a string of my instance variable names separated by spaces."	^ String streamContents:		[:strm | self instVarNames do: [:varName | strm nextPutAll: varName; space]]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:46'!definition	"Answer a String that defines the receiver in good old ST-80."	^ self definitionST80! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:38'!definitionST80	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:42'!definitionST80: isST80	"Answer a String that defines the receiver."	| aStream path |	isST80 ifTrue: [^ self definitionST80].	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutKeyword: self kindOfSubclass			withArg: self name.	aStream cr; tab; nextPutKeyword: 'instanceVariableNames: '			withArg: self instanceVariablesString.	aStream cr; tab; nextPutKeyword: 'classVariableNames: 'withArg: self classVariablesString.	aStream cr; tab; nextPutKeyword: 'poolDictionaries: '			withArg: self sharedPoolsString.	aStream cr; tab; nextPutKeyword: 'category: '			withArg: (SystemOrganization categoryOfElement: self name) asString.	^ aStream contents! !!Class class methodsFor: 'instance creation' stamp: 'di 6/7/2000 22:01'!template: aSystemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class."	^ self templateForSubclassOf: Object name category: aSystemCategoryName ! !!Class class methodsFor: 'instance creation' stamp: 'di 6/7/2000 21:57'!templateForSubclassOf: priorClassName category: systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	Preferences printAlternateSyntax 		ifTrue: [^ priorClassName asString, ' subclass (#NameOfSubclass)	instanceVariableNames ('''')	classVariableNames ('''')	poolDictionaries ('''')	category (''' , systemCategoryName asString , ''')']		ifFalse: [^ priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , '''']! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 22:53'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse:			[source _ class sourceMethodAt: selector.			currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil]..			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definitionST80: Preferences printAlternateSyntax not].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:48'!definitionST80	"Refer to the comment in ClassDescription|definition."	^ String streamContents: 		[:strm |		strm print: self;			nextPutAll: ' instanceVariableNames: ';			store: self instanceVariablesString]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 6/7/2000 22:50'!definitionST80: isST80	"Refer to the comment in ClassDescription|definition."	isST80 ifTrue: [^ self definitionST80].	^ String streamContents: 		[:strm |		strm print: self;			nextPutKeyword: ' instanceVariableNames: '				withArg: self instanceVariablesString]! !!Parser methodsFor: 'public access' stamp: 'di 6/7/2000 23:05'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of 	a parse tree. Parsing is done with respect to the argument, class, to find 	instance, class, and pool variables; and with respect to the argument, 	ctxt, to find temporary variables. Errors in parsing are reported to the 	argument, req, if not nil; otherwise aBlock is evaluated. The argument 	noPattern is a Boolean that is true if the the sourceStream does not 	contain a method header (i.e., for DoIts)."	 | meth repeatNeeded myStream parser |	(req notNil and: [Preferences printAlternateSyntax and: [(sourceStream isKindOf: FileStream) not]])		ifTrue: [parser _ self as: DialectParser]		ifFalse: [parser _ self].	myStream _ sourceStream.	[repeatNeeded _ false.	parser init: myStream notifying: req failBlock: [^ aBlock value].	doitFlag _ noPattern.	failBlock_ aBlock.	[meth _ parser method: noPattern context: ctxt				encoder: (Encoder new init: class context: ctxt notifying: parser)] 		on: ParserRemovedUnusedTemps 		do: 			[repeatNeeded _ true.			myStream _ ReadStream on: requestor text string].	repeatNeeded] whileTrue.	encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	^ meth! !!WriteStream methodsFor: 'character writing' stamp: 'di 6/7/2000 22:43'!nextPutKeyword: keyword withArg: argValue	"Emit a keyword/value pair in the alternate syntax"	self nextPutAll: (keyword copyWithout: $:);		nextPut: $(;		store: argValue;		nextPut: $)! !Metaclass removeSelector: #definition!