'From Squeak2.9alpha of 16 June 2000 [latest update: #2809] on 11 October 2000 at 11:29:43 am'!"Change Set:		ProjStore5-tkDate:			11 October 2000Author:			Ted KaehlerBetter handling of classes that are inside an ImageSegment.  (Uniclasses always go in the segment and are never stored in structures.  If a normal class is in roots, then it goes in the segment and is not in structures.)"!!Class methodsFor: 'fileIn/Out' stamp: 'tk 10/10/2000 14:16'!objectForDataStream: refStrm	| |	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	refStrm insideASegment		ifFalse: ["Normal use"			^ DiskProxy global: self theNonMetaClass name selector: #yourself				args: #()]		ifTrue: ["recording objects to go into an ImageSegment"			self isSystemDefined not ifTrue: [^ self].	"do trace me"			(refStrm rootObject includes: self) ifTrue: [^ self].				"is in roots, intensionally write out, ^ self"						"A normal class.  remove it from references.  Do not trace."			refStrm references removeKey: self ifAbsent: []. 	"already there"			^ nil]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 10/10/2000 14:22'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots. 	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [aRoot ensureChangeSetNameUnique].		aRoot class class == Metaclass ifTrue: [ self declare: aRoot]	].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/10/2000 13:36'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls list |	"Do not record Player class inst vars.  They are in the segement."	refs keysDo: [:each | 		cls _ each class.		cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].		cls class == Metaclass 			ifFalse: [structures at: cls name put: false.				(each isKindOf: ImageSegment) ifTrue: [					each outPointers do: [:out |						(out isKindOf: Class) ifTrue: [							structures at: out theNonMetaClass name put: false].						out class == DiskProxy ifTrue: [							out simpleGlobalOrNil ifNotNil: [								(out simpleGlobalOrNil isKindOf: Class) ifTrue: [									structures at: out simpleGlobalOrNil name put: false]]]].					"each arrayOfRoots do: [:rr | (rr isKindOf: Class) ifTrue: [							structures at: rr theNonMetaClass name put: false]]."					 	"all classes in roots are local to seg"]]].	list _ refs at: #BlockReceiverClasses ifAbsent: [^ self].	list do: [:meta | structures at: meta name put: false].		"Just the metaclasses whose instances are block receivers.  Otherwise metaclasses are not allowed."! !