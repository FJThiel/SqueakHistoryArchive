'From Squeak 2.1 of June 30, 1998 on 13 August 1998 at 9:54:43 am'!"Change Set:		Network-URLDate:			12 August 1998Author:			Lex Spoona basic URL hierarchy.  It centralizes the notion of 'location of an object', and it handles the parsing of several standard URL types"!SimpleClientSocket subclass: #HTTPSocket	instanceVariableNames: 'headerTokens headers responseCode '	classVariableNames: 'HTTPBlabEmail HTTPPort HTTPProxy ParamDelimiters '	poolDictionaries: ''	category: 'System-Network'!Object subclass: #MIMEDocument	instanceVariableNames: 'mainType subType content url '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!Object subclass: #Url	instanceVariableNames: 'fragment '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!Url subclass: #FileUrl	instanceVariableNames: 'path isAbsolute '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!Url subclass: #GenericUrl	instanceVariableNames: 'schemeName locator '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!GenericUrl subclass: #BrowserUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!Url subclass: #HierarchicalUrl	instanceVariableNames: 'schemeName authority path query '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!HierarchicalUrl subclass: #FtpUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!HierarchicalUrl subclass: #HttpUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!GenericUrl subclass: #MailtoUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!HttpUrl subclass: #MswUrl	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!!ChangeSet methodsFor: 'change management' stamp: 'ls 8/12/1998 23:47'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	classChanges removeKey:  cname ifAbsent: [].	methodChanges removeKey:  cname ifAbsent: [].	classRemoves remove:  cname ifAbsent: [].! !!ChangeSorter methodsFor: 'class list' stamp: 'ls 8/12/1998 23:47'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!Character methodsFor: 'testing' stamp: 'ls 7/26/1998 20:27'!isSafeForHTTP	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"	^self isAlphaNumeric or: [ '.~-_' includes: self ]! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:37'!getHeader: name 	^self getHeader: name  default: nil! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:36'!getHeader: name  default: defaultValue	^headers at: name  ifAbsent: [ defaultValue ]! !!HTTPSocket methodsFor: 'all'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 7/4/1998 19:01'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close"	| buf response bytesRead |	buf _ String new: (length ifNil: [ 2000 ]).	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: (length ifNil: [ 2000 ]).	[(length isNil ifTrue: [ true ] ifFalse: [response position < length]) 	 & (self dataAvailable | self isConnected)] 	whileTrue: [		[self waitForDataUntil: (Socket deadlineSecs: 5)] whileFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: (length isNil ifTrue: [ buf size ] ifFalse: [ length - response size ]). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed']). 	"response text.	is already a text stream"	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/13/1998 00:33'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines _ headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine _ lines first.	lines _ lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode _ (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines _ OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers _ Dictionary new.	foldedLines do: [ :line |		i _ line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ]..! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:41'!responseCode	^responseCode! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/13/1998 09:54'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."        | resp what all |        readAhead size > 0                ifTrue: [resp _ readAhead removeFirst]  "response already came in"                ifFalse: [                        all _ self getResponseUpTo: CrLf.                        resp _ all at: 1.       "150 Opening binary mode data conn"                        readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].        Transcript show: resp; cr.        resp size > 0                 ifTrue: [                        resp first isDigit ifFalse: [ ^self lookFor: beginning ].  "we're in the middle of a line, not the end." #XXX. "this should be fixed..."                        (resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"                        (resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"                        "((resp at: 1) isDigit) & ((resp at: 1) digitValue < 4) ifTrue: [^ self lookFor: beginning]."                                "the way I used to detect comments"                        ]                ifFalse: [resp _ '[timeout]'].        what _ (PopUpMenu labels: 'OK\ debug ' withCRs)                 startUpWithCaption: 'Server reported this error:\' withCRs, resp.        what = 2 ifTrue: [self halt].        self destroy.        ^ resp! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:40'!httpGet: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:28'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/4/1998 00:36'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil  accept: mimeType! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:28'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/12/1998 02:03'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index first connectToHost connectToPort type argsString newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ HTTPPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [		argsString _ WriteStream on: String new.		argsString nextPut: $?.		first _ true.		args associationsDo: [ :assoc |			assoc value do: [ :value |				first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].				argsString nextPutAll: assoc key encodeForHTTP.				argsString nextPut: $=.				argsString nextPutAll: value encodeForHTTP. ] ].		argsString _ argsString contents.		page _ page, argsString ].	HTTPProxy isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxy.			connectToPort _ HTTPPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	sock header: header.	length _ sock getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ sock getHeader: 'content-type'.	sock responseCode first = $3 ifTrue: [		newUrl _ sock getHeader: 'location'.		newUrl ifNotNil: [ 			Transcript show: 'redirecting to ', newUrl; cr.			sock destroy.			^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].	aStream _ sock getRestOfBuffer: firstData totalLength: length.	sock destroy.	"Always OK to destroy!!" 	^ MIMEDocument contentType: type content: aStream contents url: url! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:40'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:36'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/12/1998 02:04'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ HTTPPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxy.		port _ HTTPPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!MIMEDocument commentStamp: 'ls 8/13/1998 09:54' prior: 0!a MIME object, along with its type!!MIMEDocument methodsFor: 'printing' stamp: 'ls 7/23/1998 20:12'!printOn: aStream	aStream nextPutAll: self class name;		nextPutAll: ' (';		nextPutAll: self contentType;		nextPutAll: ', ';		nextPutAll: self content size printString;		nextPutAll: ' bytes)'.! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:11'!privateContent: aString	content _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateMainType: aString	mainType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateSubType: aString	subType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 8/12/1998 00:25'!privateUrl: aUrl	url _ aUrl! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!content	"return the raw data in this object"	^content! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!contentType	^self mainType, '/', self subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!mainType	#XXX.  "is there a better name?"	^mainType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!subType	^subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!type	^mainType, '/', subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 8/12/1998 00:25'!url	"returns the URL this object was downloaded from.  It may legitimately be nil"	^url! !!MIMEDocument class methodsFor: 'content-types' stamp: 'ls 8/8/1998 03:15'!guessTypeFromName: url	"guesses a content type from the url"	| extension |	extension _ url asString.	(extension includes: $.) ifFalse: [ ^self defaultContentType].	extension _ (extension findTokens: '.') last asLowercase.	extension = 'html' ifTrue: [ ^'text/html' ].	extension = 'htm' ifTrue:[ ^'text/html' ].	extension = 'txt' ifTrue: [ ^'text/plain' ].	extension = 'gif' ifTrue: [ ^'image/gif' ].	extension = 'jpg' ifTrue: [ ^'image/jpeg' ].	extension = 'jpeg' ifTrue: [ ^'image/jpeg' ].	extension = 'mid' ifTrue: [ ^'audio/midi' ].	^self defaultContentType! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!content: aString	^self contentType: self defaultContentType  content: aString! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 08:00'!contentType: aString  content: content	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/12/1998 00:26'!contentType: aString  content: content  url: aUrl	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	ans privateUrl: aUrl asUrl.	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!defaultContentType	^'application/octet-stream'! !!String methodsFor: 'converting' stamp: 'ls 6/29/1998 00:35'!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: 'converting' stamp: 'ls 7/15/1998 18:40'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: 'converting' stamp: 'ls 8/12/1998 23:31'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	| encodedStream |	encodedStream _ WriteStream on: (String new).		self do: [ :c |		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [			encodedStream nextPut: $%.			encodedStream nextPut: (c asciiValue // 16) asHexDigit.			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.		]	].	^encodedStream contents. ! !!String methodsFor: 'internet' stamp: 'ls 7/22/1998 22:19'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| inStream ans c tok asciiVal |	inStream _ ReadStream on: self.	ans _ WriteStream on: String new.	[ c _ inStream next.  c = nil ] whileFalse: [ 		c = $+ ifTrue: [ ans nextPut: $ ] ifFalse: [			(c = $%) ifTrue: [				tok _ inStream next: 2.				asciiVal _ Integer readFrom: (ReadStream on: tok) base: 16.				ans nextPut: (Character value: asciiVal). ]			ifFalse: [				ans nextPut: c ] ] ].	^ans contents ! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asUrl	^self asString asUrl! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:20'!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!Url commentStamp: 'ls 8/13/1998 09:54' prior: 0!A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.!!Url methodsFor: 'parsing' stamp: 'ls 8/5/1998 00:57'!newFromRelativeText: aString	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"	"if the scheme is the same, or not specified, then use the same class"	| newSchemeName remainder fragmentStart newFragment newUrl bare |	bare _ aString withBlanksTrimmed.	newSchemeName _ Url schemeNameForString: bare.	(newSchemeName isNil not and: [ newSchemeName ~= self schemeName ]) ifTrue: [		"different scheme -- start from scratch"		^Url absoluteFromText: aString ].	remainder _ bare.	"remove the fragment, if any"	fragmentStart _ remainder indexOf: $#.	fragmentStart > 0 ifTrue: [		newFragment _ remainder copyFrom: fragmentStart+1 to: remainder size. 		remainder _ remainder copyFrom: 1 to: fragmentStart-1].	"remove the scheme name"	newSchemeName ifNotNil: [		remainder _ remainder copyFrom: (newSchemeName size + 2) to: remainder size ].	"create and initialize the new url"	newUrl _ self class new privateInitializeFromText: remainder  relativeTo: self.	"set the fragment"	newUrl privateFragment: newFragment.	^newUrl! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:50'!privateInitializeFromText: aString	^self subclassResponsibility! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:55'!privateInitializeFromText: aString relativeTo: aUrl	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"	"by default, just do regular initialization"	^self privateInitializeFromText: aString! !!Url methodsFor: 'classification' stamp: 'ls 6/16/1998 16:22'!scheme	"return a string with the scheme of this URL.  For instance, HTTP"	^self subclassResponsibility! !!Url methodsFor: 'classification' stamp: 'ls 7/3/1998 21:11'!schemeName	"return a lowercase string with the scheme of this URL.  For instance, 'http'"	^self subclassResponsibility! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!printOn: aStream	aStream nextPutAll: self toText! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!toText	"give a String representation of the Url, suitable for printing, etc."	^self subclassResponsibility! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:41'!activate	"spawn an external handler for this URL"	! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:40'!hasContents	"whether this URL can download contents to be displayed; if not, it fundamentally requires an outside application to deal with it.  For example, mailto: and telnet: urls"	^false! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContents	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved"	^nil! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContentsForBrowser: aBrowser	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved.  Since aBrowser is specified, this could do browser specific things"	^self retrieveContents! !!Url methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asText	^self asString asText! !!Url methodsFor: 'converting' stamp: 'ls 6/29/1998 00:36'!asUrl	^self! !!Url methodsFor: 'converting' stamp: 'ls 7/3/1998 21:11'!asUrlRelativeTo: aUrl	^self! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:41'!fragment	^fragment! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:02'!privateFragment: aString	fragment _ aString! !!FileUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!A reference to a local file.  Currently this is quite UNIX specific!!FileUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:39'!privateInitializeFromText: text	| bare schemeName pathString |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	path _ pathString findTokens: '/'.	(pathString endsWith: '/') ifTrue: [ path addLast: '' ].	isAbsolute _ pathString beginsWith: '/'.! !!FileUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:38'!privateInitializeFromText: aString  relativeTo: aUrl	| bare |	bare _ aString.	(bare beginsWith: (self schemeName, ':')) ifTrue: [		bare _ bare copyFrom: (self schemeName size + 2) to: bare size ].	(bare beginsWith: '/') ifTrue: [ ^self privateInitializeFromText: aString ].	isAbsolute _ aUrl isAbsolute.	path _ aUrl path copy.	path removeLast.	(bare findTokens: '/') do: [ :token |		token = '..' ifTrue: [ path isEmpty ifFalse: [ path last = '..' ifFalse: [ path removeLast ] ] ]		ifFalse: [ token = '.' ifFalse: [ path addLast: token ] ] ].	(bare endsWith: '/') ifTrue: [ path add: '' ].! !!FileUrl methodsFor: 'printing' stamp: 'ls 8/4/1998 02:40'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self pathString.	fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: fragment ].	^s contents! !!FileUrl methodsFor: 'access' stamp: 'ls 8/2/1998 05:39'!isAbsolute	^isAbsolute! !!FileUrl methodsFor: 'access' stamp: 'ls 7/23/1998 07:29'!path	"return an ordered collection of the path elements"	^path! !!FileUrl methodsFor: 'access' stamp: 'ls 7/26/1998 21:14'!pathString	| first |	^String streamContents: [ :s |		isAbsolute ifTrue:[ s nextPut: $/ ].		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: $/ ].			first _ false.			s nextPutAll: p ] ]! !!FileUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!FileUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 21:20'!retrieveContents	| file pathString s dir |		pathString _ self pathString.	path last size > 0 ifTrue: [		file _ FileStream oldFileOrNoneNamed: pathString.		file ifNotNil: [ 			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: file contentsOfEntireFile ] ].	"assume it's a directory..."	s _ WriteStream on: String new.	dir _ FileDirectory on: pathString.	(pathString endsWith: '/') ifFalse: [ pathString _ pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	dir entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file:', pathString)! !!FileUrl methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 07:29'!path: aCollection	"set the path this file refers to"	path _ aCollection! !!FileUrl methodsFor: 'private-initialization' stamp: 'ls 7/26/1998 20:43'!path: aCollection isAbsolute: aBoolean	path _ aCollection.	isAbsolute _ aBoolean! !!FileUrl methodsFor: 'classification' stamp: 'ls 7/26/1998 21:11'!schemeName	^'file'! !!GenericUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!a URL type that can't be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.!!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ self error: 'opaque URL with no scheme--shouldn''t happen!!'. ].	locator _ aString copyFrom: (schemeName size+2) to: aString size.! !!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString relativeTo: aUrl	schemeName _ aUrl schemeName.	locator _ aString.! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!locator	^locator! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!schemeName	^schemeName! !!GenericUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName0  locator: locator0	schemeName _ schemeName0.	locator _ locator0.! !!GenericUrl methodsFor: 'printing' stamp: 'ls 8/4/1998 02:41'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self locator.	self fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: self fragment ].	^s contents! !!BrowserUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!URLs that instruct a browser to do something.!!BrowserUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!BrowserUrl methodsFor: 'downloading' stamp: 'ls 7/26/1998 21:21'!retrieveContentsForBrowser: aBrowser	^aBrowser browserUrlContents: locator! !!HierarchicalUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.!!HierarchicalUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:44'!hasContents	"most of these do...."	^true! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:24'!privateInitializeFromText: aString	| remainder ind nextTok s specifiedSchemeName |	remainder _ aString.	schemeName ifNil: [ 		specifiedSchemeName _ Url schemeNameForString: remainder.		specifiedSchemeName ifNotNil: [ 			schemeName _ specifiedSchemeName.			remainder _ remainder copyFrom: (schemeName size+2) to: remainder size ].		schemeName ifNil: [ "assume HTTP"  schemeName _ 'http' ] ].	"remove leading // if it's there"	(remainder beginsWith: '//') ifTrue: [		remainder _ remainder copyFrom: 3 to: remainder size ].	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ].	"get the authority"	ind _ remainder indexOf: $/.	ind > 0 ifTrue: [		ind = 1 ifTrue: [ authority _ '' ] ifFalse: [			authority _ remainder copyFrom: 1 to: ind-1.			remainder _ remainder copyFrom: ind+1 to: remainder size. ] ]	ifFalse: [		authority _ remainder.		remainder _ ''. ].	"get the path"	path _ OrderedCollection new.	s _ ReadStream on: remainder.	[ 		s peek = $/ ifTrue: [ s next ].		nextTok _ WriteStream on: String new.		[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].		nextTok _ nextTok contents unescapePercents.		nextTok = '..' 			ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]			ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].		s atEnd 	] whileFalse.	path isEmpty ifTrue: [ path add: '' ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:29'!privateInitializeFromText: aString relativeTo: aUrl	| remainder ind nextTok s |	remainder _ aString.	"set the scheme"	schemeName _ aUrl schemeName.	"a leading // means the authority is specified, meaning it is absolute"	(remainder beginsWith: '//') ifTrue: [		^self privateInitializeFromText: aString ].	"otherwise, use the same authority"	authority _ aUrl authority.	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ]. 	"get the path"	(remainder beginsWith: '/')		ifTrue: [ path _ OrderedCollection new ]		ifFalse: [ path _ aUrl path shallowCopy.			path size > 0 ifTrue: [ path removeLast ] ]. 	s _ ReadStream on: remainder.	[ 		s peek = $/ ifTrue: [ s next ].		nextTok _ WriteStream on: String new.		[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].		nextTok _ nextTok contents unescapePercents.		nextTok = '..' 			ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]			ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].		s atEnd 	] whileFalse.	path isEmpty ifTrue: [ path add: '' ].! !!HierarchicalUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName0  authority: authority0  path: path0  query: query0	"initialize a new instance"	schemeName _ schemeName0.	authority _ authority0.	path _ path0.	query _ query0.! !!HierarchicalUrl methodsFor: 'printing' stamp: 'ls 7/21/1998 07:23'!toText	| ans |	ans _ WriteStream on: String new.	ans nextPutAll: self schemeName.	ans nextPutAll: '://'.	ans nextPutAll: self authority.	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!authority	^authority! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!path	"return an ordered collection of the decoded path elements, as strings"	^path! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:59'!query	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"	^query ! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!schemeName	^schemeName! !!FtpUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!a reference to a file which may be downloaded by anonymous ftp!!FtpUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 01:24'!retrieveContents	| server contents pathString listing |	"currently assumes directories end in /, and things that don't end in / are files.  Also, doesn't handle errors real well...."	server _ ServerDirectory new.	server server: self authority.	server directory: '/'.	server user: 'anonymous'.	server password: 'SqueakUser'.	pathString _ self pathString.	pathString _ pathString copyFrom: 2 to: pathString size. "remove the leading /"	self path last size = 0 ifFalse: [		"a file"		contents _ (server getFileNamed: pathString).		(contents respondsTo: #contents) ifTrue: [ 			"the file exists--return it"			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: contents contents ]		ifFalse: [			"some error"			^nil ]. ].	"a directory?"	server directory: self pathString.	listing _ String streamContents: [ :stream |		stream nextPutAll: '<title>', self pathString, '</title>'; cr.		stream nextPutAll: '<h1>Listing for ', self pathString, '</h1>'; cr.		stream nextPutAll: '<ul>'; cr.		server entries do: [ :entry |			stream nextPutAll: '<li>';				nextPutAll: '<a href="', entry name encodeForHTTP.			entry isDirectory ifTrue: [ stream nextPut: $/ ].			stream nextPutAll: '">';				nextPutAll: entry name;				nextPutAll: '</a>';				cr ] ].	^MIMEDocument contentType: 'text/html' content: listing! !!FtpUrl methodsFor: 'access' stamp: 'ls 7/24/1998 00:18'!pathString	self path isEmpty ifTrue: [ ^'/' copy ].	^String streamContents: [ :s |		self path do: [ :p |		 	s nextPut: $/.			s nextPutAll: p ] ]! !!HttpUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URL!!HttpUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 01:24'!retrieveContents	| contents |	contents _ (HTTPSocket httpGetDocument: self toText).	(contents isKindOf: String) ifTrue: [		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents. ].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: contents content url: contents url ].	^contents! !!MailtoUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!a URL specifying a mailing address; activating it triggers a mail-sender to start up, if one is present.!!MailtoUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 21:05'!activate	(Smalltalk includesKey: #EmailWindow) ifTrue: [		(Smalltalk at: #EmailWindow) beginNewMessageTo: self locator	].	self notify: 'no mail reader present'! !!MswUrl commentStamp: 'ls 8/13/1998 09:54' prior: 0!(out of date class....)!!MswUrl methodsFor: 'misc' stamp: 'ls 7/1/1998 02:23'!httpUrlOfServer	"return the HTTP address to make queries to"		#XXX.  "should come up with a better name for this when I'm less tired"	^HttpUrl schemeName: 'http'  authority: authority  path: path  query: nil.! !!MswUrl methodsFor: 'access' stamp: 'ls 7/12/1998 23:34'!query	"return the query.  There is never a MuSwiki URL without a query; the query defaults to 'top' if none is explicitly specified"	| q |	q _ super query.	q isNil ifTrue: [ q _ 'top' ].	^q! !!Url class methodsFor: 'parsing' stamp: 'ls 8/4/1998 20:42'!absoluteFromText: aString	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"	"Url absoluteFromText: 'file:/etc/passwd'"	| remainder scheme fragment ind newUrl |	"trim surrounding whitespace"	remainder _ aString withBlanksTrimmed.		"extract the fragment, if any"	ind _ remainder indexOf: $#.	ind > 0 ifTrue: [		fragment _ remainder copyFrom: ind+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: ind-1 ].	"choose class based on the scheme name, and let that class do the bulk of the parsing"	scheme _ self schemeNameForString: remainder.	scheme = nil ifTrue: [		newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'http') ifTrue: [ newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'msw') ifTrue: [ newUrl _ MswUrl new privateInitializeFromText: remainder ]. 	(scheme = 'ftp') ifTrue:[ newUrl _ FtpUrl new privateInitializeFromText: remainder ].	(scheme = 'file') ifTrue: [newUrl _ FileUrl new privateInitializeFromText: remainder ].		(scheme = 'browser') ifTrue: [ newUrl _ BrowserUrl new privateInitializeFromText: remainder ].	(scheme = 'mailto') ifTrue: [ newUrl _ MailtoUrl new privateInitializeFromText: remainder ].	newUrl ifNil: [  newUrl _ GenericUrl new privateInitializeFromText: remainder ].	"set the fragment"	newUrl privateFragment: fragment.	"all done"	^newUrl! !!Url class methodsFor: 'parsing' stamp: 'ls 7/26/1998 20:37'!schemeNameForString: aString	"get the scheme name from a string, or return nil if it's not specified.  used in internal parsing routines--an outsider may as well use asUrl.  lowercases the return value."	"Url schemeNameForString: 'http://www.yahoo.com'"	"Url schemeNameForString: '/etc/passwed'"	"Url schemeNameForString: '/etc/testing:1.2.3'"	| idx schemeName |	idx _ aString indexOf: $:.	idx = 0 ifTrue: [ ^nil ].	schemeName _ aString copyFrom: 1 to: idx-1.	schemeName do: [ :c |		"make sure it is all alphabetic"		c isLetter ifFalse: [ ^nil ]. ].	^schemeName asLowercase! !!Url class methodsFor: 'testing' stamp: 'ls 8/4/1998 02:42'!quickieTest	"run some quick tests on the Url hierarchy"	"	Url quickieTest	"	| tests url block correct actual numCorrect numWrong baseUrl |	"each item in tests in a two-element array.  it has a block, followed by the string the block should evaluate to"	tests _ OrderedCollection new.	"parsing absolute urls of various kinds"	tests add: (Array with: 		[url _ 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.		url schemeName, '|', url authority, '|', url path first, '|', url path size printString, '|', url query, '|',url fragment.]		with: 'http|chaos.resnet.gatech.edu:8000|docs|3|A%20query%20|part').	tests add: (Array with:		[url _ 'ftP://some.server/some/directory/' asUrl.		url schemeName, '|', url class name, '|', url authority, '|', url path first , '|', url path size printString]		with: 'ftp|FtpUrl|some.server|some|3').	tests add: (Array with:		[url _ 'telNet:chaos.resnet.gatech.edu#goo' asUrl.		url schemeName, '|', url locator, '|', url fragment] 		with: 'telnet|chaos.resnet.gatech.edu|goo').	tests add: (Array with:		[url _ Url absoluteFromText: 'file:/etc/passwd#foo'.		url schemeName, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|etc|2|foo').	tests add: (Array with: 		[url _ Url absoluteFromText: 'browser:bookmarks#mainPart'.		url schemeName, '|', url locator, '|', url fragment, '|', url class name ]		with: 'browser|bookmarks|mainPart|BrowserUrl').	tests add: (Array with:		[url _ 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.		url schemeName, '|', url class name, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|FileUrl|foo|5|fragger').	"relative urls of each kind, relative to the original"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp://a.b'.		url toText]		with: 'ftp://a.b/').	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp:xyz'.		url toText.]		with: 'ftp://somewhere/some/dir/xyz').	tests add: (Array with: [		baseUrl _ 'http://some.where/some/dir?query1#fragment1' asUrl.		url _ baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.		url toText]		with: 'http://some.where/another/dir/?query2#fragment2').	tests add: (Array with: [		baseUrl _ 'file:/some/dir#fragment1' asUrl.		url _ baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.		url toText]		with: 'file:/another/dir/#fragment2').	"relative urls of a different scheme"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'http:xyz'.		url toText.]		with: 'http://xyz/').	"run the tests"	numCorrect _ 0.	numWrong _ 0.	tests do: [ :test |		block _ test at: 1.		correct _ test at: 2.		actual _ block value.		Transcript show: actual.		correct = actual 			ifTrue: [ numCorrect _ numCorrect + 1 ]			ifFalse: [				numWrong _ numWrong + 1.				Transcript show: '<-- should be: ', correct ].		Transcript cr. ].	Transcript show: numCorrect printString, ' correct, ', numWrong printString, ' wrong.', String cr.	numWrong > 0 		ifTrue: [ Transcript show: 'happy hacking!!' ]		ifFalse: [ Transcript show: 'yay!!!!!!' ].	Transcript cr.! !!FileUrl class methodsFor: 'parsing' stamp: 'ls 8/2/1998 05:47'!absoluteFromText: text	| schemeName pathString bare |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	^self new path: (pathString findTokens: '/') isAbsolute: (pathString beginsWith: '/')! !!GenericUrl class methodsFor: 'parsing' stamp: 'ls 7/26/1998 21:24'!absoluteFromText: aString	| schemeName locator |	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].	locator _ aString copyFrom: (schemeName size + 2) to: aString size.	^self schemeName: schemeName locator: locator! !!GenericUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName  locator: locator	^self new schemeName: schemeName  locator: locator! !!HierarchicalUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName  authority: authority  path: path  query: query	^self new schemeName: schemeName  authority: authority  path: path  query: query! !