'From Squeak 2.3 of January 14, 1999 on 7 March 1999 at 12:06:13 am'!"Change Set:		EventRecorderII-diDate:			6 March 1999Author:			Dan IngallsEliminated two classes:  EventTape and EventRecorder.Renamed GhostHandMorph to be HandMorphForReplay.Changed to a simple inboard array for the tape (event storage).Provided the ability to condense linear mouse movement with interpolation at replay.Made simple provisions for wrap-around of the millisecond clock.Eliminated step methods in favor of using the processEvents cycle in the playback hand.Provided a pause/resume mechanism that is capable of surviving project changes.Added the ability to spawn a simple 'play me' button that can be saved as a morph.Caused the playback hand to display its cursor double size for visibility.Integrated a voice recorder with on-the-fly compression.	This currently does NOT survive project changes, not is its data stored on the tape.	Right now it can only be saved by saving the entire recorder as a morph.	This will be fixed by adding a startSound event at each project change.	We will also convert read/write file to use saveOnFile.Added a journal file facility for recording sequences that end in a crash.The above two features can be engaged via the ER's morph menu.Substantially reworked the SoundRecorder to allow on-the-fly compression	and the ability to convert near-silence to space-saving rests.Also reworked the handling of cursor offsets in morphic."!Object subclass: #CompressedSoundData	instanceVariableNames: 'channels soundClassName codecName loopEnd loopLength perceivedPitch samplingRate gain firstSample cachedSound '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Synthesis'!AlignmentMorph subclass: #EventRecorderMorph	instanceVariableNames: 'tape state time recHand playHand lastEvent lastDelta tapeStream saved statusLight voiceRecorder startSoundEvent recordMeter caption journalFile '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Smalltalk renameClassNamed: #GhostHandMorph as: #HandMorphForReplay!HandMorph subclass: #HandMorphForReplay	instanceVariableNames: 'recorder '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!MorphicEvent subclass: #MorphicSoundEvent	instanceVariableNames: 'sound '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Object subclass: #SoundRecorder	instanceVariableNames: 'stereo samplingRate recordLevel recordedBuffers recordedSound recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex codec '	classVariableNames: 'CanRecordWhilePlaying '	poolDictionaries: ''	category: 'Music-Synthesis'!!CompressedSoundData commentStamp: 'di 2/17/1999 08:49' prior: 0!Instances of this class hold the data resulting from compressing a sound.  Each carries a reference to the codec class that created it, so that it can reconstruct a sound similar to the original in response to the message asSound.In order to facilitate integration with existing sounds, a CompressedSoundData instance can masquerade as a sound by caching a copy of its original sound and delegating the essential sound-playing protocol to that cached copy.  It should probably be made a subclass of AbstractSound to complete the illusion.!!CompressedSoundData reorganize!('accessing' channels channels: codecName codecName: firstSample firstSample: gain gain: loopEnd loopEnd: loopLength loopLength: perceivedPitch perceivedPitch: samplingRate samplingRate: soundClassName soundClassName:)('asSound' asSound doControl mixSampleCount:into:startingAt:leftVol:rightVol: reset samples samplesRemaining)!!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:15'!asSound	"Answer the result of decompressing the receiver."	| codecClass |	codecClass _ Smalltalk at: codecName		ifAbsent: [^ self error: 'The codec for decompressing this sound is not available'].	^ (codecClass new decompressSound: self) reset! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!doControl	cachedSound doControl! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	cachedSound mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:49'!reset	"This message is the cue to start behaving like a real sound in order to be played.	We do this by caching a decompressed version of this sound.	See also samplesRemaining."	cachedSound == nil ifTrue: [cachedSound _ self asSound].	cachedSound reset! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:44'!samples	^ self asSound samples! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:49'!samplesRemaining	"This message is the cue that the cached sound may no longer be needed.	We know it is done playing when samplesRemaining=0."	| samplesRemaining |	samplesRemaining _ cachedSound samplesRemaining.	samplesRemaining <= 0 ifTrue: [cachedSound _ nil].	^ samplesRemaining! !!Cursor class methodsFor: 'class initialization' stamp: 'di 3/6/1999 21:27'!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor _ Cursor new.		self initXeq.		self initSquare.		self initNormalWithMask.		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		self makeCursorsWithMask.		"Cursor initialize"! !!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 2/18/1999 08:56'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask ext |	ext _ aForm extent.	cursor _ self extent: ext.	cursor copy: (1@1 extent: ext) from: 0@0 in: aForm rule: Form over.	mask _ Form extent: ext.	(1@1) eightNeighbors do:		[:p | mask copy: (p extent: ext) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: ((aForm offset - (1@1)) max: ext negated).	^ cursor! !!Form methodsFor: 'filling' stamp: 'di 2/19/1999 07:07'!anyShapeFill	"Fill the interior of the outermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape:fillColor: to paint a solid color.  See also convexShapeFill:"	| shape |	"Draw a seed line around the edge and fill inward from the outside."	shape _ self findShapeAroundSeedBlock: [:f | f borderWidth: 1].	"Reverse so that this becomes solid in the middle"	shape _ shape reverse.	"Finally erase any bits from the original so the fill is only elsewhere"	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'other' stamp: 'di 2/26/1999 07:29'!asCursorForm	^ self! !!Cursor methodsFor: 'converting' stamp: 'di 3/6/1999 23:54'!asCursorForm	| form |	form _ Form extent: self extent depth: 8.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset negated! !!CursorWithMask methodsFor: 'all' stamp: 'di 3/6/1999 23:54'!asCursorForm	| form |	form _ Form extent: self extent depth: 8.	form fillShape: maskForm fillColor: Color white.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset negated! !!Morph methodsFor: 'event handling' stamp: 'di 3/5/1999 15:12'!cursorPoint	"A convenience"	^ self activeHand lastEvent cursorPoint! !!EventRecorderMorph commentStamp: 'di 3/6/1999 22:56' prior: 0!During recording, the EventRecorder subscribes to all events of the normal morphic hand, and saves them as they occur.For replay, a second playback hand is created that reads events from the recorder and plays them back in the world.The EventRecorder began with the work of Ted Kaehler and John Malone.  This was then signifcantly expanded by Leandro Caniglia and Valeria Murgia as a tutorial aid for the Morphic Wrapper project.Since that time, I have...Changed to a simple inboard array for the tape (event storage).Provided the ability to condense linear mouse movement with interpolation at replay.Made simple provisions for wrap-around of the millisecond clock.Eliminated step methods in favor of using the processEvents cycle in the playback hand.Provided a pause/resume mechanism that is capable of surviving project changes.Added the ability to spawn a simple 'play me' button that can be saved as a morph.Caused the playback hand to display its cursor double size for visibility.Integrated a voice recorder with on-the-fly compression.	This currently does NOT survive project changes, not is its data stored on the tape.	Right now it can only be saved by saving the entire recorder as a morph.	This will be fixed by adding a startSound event at each project change.	We will also convert read/write file to use saveOnFile.Added a journal file facility for recording sequences that end in a crash.The above two features can be engaged via the ER's morph menu.	- Dan Ingalls 3/6/99!!EventRecorderMorph reorganize!('initialization' addButtons addCustomMenuItems:hand: addJournalFile addVoiceControls buttonFor: caption:voiceRecorder:tape: initialize)('accessing' button: recTime)('commands' button condense play record shrink stop)('pause/resume' pauseIn: resumeIn: resumePlayIn: resumeRecordIn:)('event handling' handleEvent: nextEventToPlay)('fileIn/Out' readFrom: readTape readTape: writeCheck writeFileNamed: writeTape writeTape:)!!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 2/17/1999 17:58'!addButtons	| r b w |	caption ifNotNil:		["Special setup for play-only interface"		r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 centering: #center;			 minCellSize: 4;			 color: Color blue.		r addMorphBack: (SimpleButtonMorph new target: self;	 							label: caption; actionSelector: #play).		r addMorphBack: (Morph new extent: 4@4; color: Color transparent).		r addMorphBack: (statusLight _ EllipseMorph new extent: 11 @ 11;								color: Color green; borderWidth: 0).		r addMorphBack: (Morph new extent: 4@4; color: Color transparent).		^ self addMorphBack: r].	"record - stop - play"	r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 minCellSize: 4;			 color: Color blue.	r addMorphBack: (b _ self buttonFor: #record).	w _ b width.	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #stop) width: w).	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #play) width: w).	self addMorphBack: r.	"read file - write file"	r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 minCellSize: 4;			 color: Color blue.	r addMorphBack: (b _ self buttonFor: #writeTape).	w _ b width.	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #readTape)			width: w).	self addMorphBack: r.	"rewind - light - reset"	r _ AlignmentMorph newRow vResizing: #shrinkWrap;			 centering: #center;			 minCellSize: 4;			 color: Color blue.	r addMorphBack: (b _ self buttonFor: #shrink).	w _ b width.	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: (statusLight _ EllipseMorph new extent: 11 @ 11;			color: Color green;		 	borderWidth: 0).	r addMorphBack: (AlignmentMorph newSpacer: Color transparent).	r addMorphBack: ((self buttonFor: #button)			width: w).	self addMorph: r! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 3/6/1999 15:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add voice controls' action: #addVoiceControls.	aCustomMenu add: 'add journal file' action: #addJournalFile.! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 3/6/1999 15:46'!addJournalFile	"In case there is a chance of not regaining control to stop recording and save a file, the EventRecorder can write directly to file as it is recording.  This is useful for capturing a sequence that results in a nasty crash."	journalFile ifNotNil: [journalFile close].	journalFile _ FileStream newFileNamed: 'EventRecorder.tape'.! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 2/17/1999 11:09'!addVoiceControls	| levelSlider r meterBox |	voiceRecorder _ SoundRecorder new samplingRate: 11025.0; codec: GSMCodec new.	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: voiceRecorder;		actionSelector: #recordLevel:;		adjustToValue: voiceRecorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.	meterBox _ Morph new extent: 102@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: meterBox topLeft + (1@1).	meterBox addMorph: recordMeter.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: meterBox.	self addMorphBack: r.! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 2/17/1999 17:44'!caption: butnCaption voiceRecorder: butnRecorder tape: butnTape	caption _ butnCaption.	voiceRecorder _ butnRecorder.	tape _ butnTape! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 3/6/1999 15:44'!initialize	super initialize.	saved _ true.	borderWidth _ 2.	borderColor _ #raised.	color _ Color red.	orientation _ #vertical.	centering _ #center.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 2.	minCellSize _ 4.	self addButtons.! !!EventRecorderMorph methodsFor: 'accessing' stamp: 'di 2/15/1999 10:15'!recTime	| ms |	ms _ 0.	tape do:		[:cell | ms _ ms + cell key].	^ String streamContents:		[:stream | (Time fromSeconds: ms // 1000) print24: true on: stream]! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 2/17/1999 17:45'!button	"Make a simple button interface for replay only"	| butnCaption erm |	butnCaption _ FillInTheBlank request: 'Caption for this butn?' initialAnswer: 'play'.	butnCaption isEmpty ifTrue: [^ self].	erm _ (EventRecorderMorph basicNew				caption: butnCaption				voiceRecorder: voiceRecorder copy				tape: tape) initialize.	self world primaryHand attachMorph: erm! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 2/15/1999 15:17'!condense	"Shorten the tape by deleting mouseMove events that can just as well be	interpolated later at playback time."	| e1 e2 dt1 dt2 e3 dt3 |	"e1, e2, and e3 are three consecutive events on the tape.	dt1, dt2, and dt3 are the associated time steps for each of them."	tape _ Array streamContents:	[:tStream |	e1 _ e2 _ e3 _ nil.  dt1 _ dt2 _ dt3 _ nil.	tape do:		[:a | 		e1 _ e2.  dt1 _ dt2.		e2 _ e3.  dt2 _ dt3.		e3 _ a value.  dt3 _ a key.		((e1 ~~ nil and: [(e2 type == #mouseMove) &				(e1 type == #mouseMove or: [e3 type == #mouseMove])]) and: 			["Middle point within 3 pixels of mean of outer two"			e2 cursorPoint onLineFrom: e1 cursorPoint to: e3 cursorPoint within: 2.5])			ifTrue: ["Delete middle mouse move event.  Absorb its time into e3"					dt3 _ dt2 + dt3.  					e2 _ e1.  dt2 _ dt1]			ifFalse: [e1 ifNotNil: [tStream nextPut: dt1 -> e1]]].	e2 ifNotNil: [tStream nextPut: dt2 -> e2].	e3 ifNotNil: [tStream nextPut: dt3 -> e3]].! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 3/3/1999 16:19'!play	self isInWorld ifFalse: [^ self].	self stop.	tape ifNil: [^ self].	tapeStream _ ReadStream on: tape.	self resumePlayIn: self world.	statusLight color: Color yellow.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 3/6/1999 15:13'!record	self isInWorld ifFalse: [^ self].	self stop.	self writeCheck.	journalFile ifNotNil:		[journalFile close.		journalFile _ FileStream newFileNamed: 'EventRecorder.tape'].	tapeStream _ WriteStream on: (Array new: 10000).	self resumeRecordIn: self world.	statusLight color: Color red.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 2/17/1999 21:20'!shrink	"Shorten the tape by deleting mouseMove events that can just as well be	interpolated later at playback time."	| oldSize priorSize |	self writeCheck.	oldSize _ priorSize _ tape size.	[self condense.  tape size < priorSize] whileTrue: [priorSize _ tape size].	PopUpMenu notify: oldSize printString , ' events reduced to ' , tape size printString.	voiceRecorder ifNotNil: [voiceRecorder suppressSilence].	saved _ false.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'di 3/5/1999 15:27'!stop	state = #record ifTrue:		[tape _ tapeStream contents.		saved _ false].	journalFile ifNotNil:		[journalFile close].	self pauseIn: self world.	state _ nil.	statusLight color: Color green.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 3/4/1999 14:55'!pauseIn: aWorld	"Suspend playing or recording, either as part of a stop command,	or as part of a project switch, after which it will be resumed."	state = #play ifTrue:		[state _ #suspendedPlay.		playHand delete.		aWorld removeHand: playHand.		playHand _ nil].	state = #record ifTrue:		[state _ #suspendedRecord.		recHand stopReportingEventsTo: self.		recHand _ nil].	voiceRecorder ifNotNil:		[voiceRecorder pause.		"And install sound in startSoundEvent..."].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 3/3/1999 15:56'!resumeIn: aWorld	"Resume playing or recording after a project switch."	state = #suspendedPlay ifTrue:		[self resumePlayIn: aWorld].	state = #suspendedRecord ifTrue:		[self resumeRecordIn: aWorld].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 3/6/1999 15:37'!resumePlayIn: aWorld	playHand _ HandMorphForReplay new recorder: self.	playHand position: tapeStream peek value cursorPoint.	aWorld addHand: playHand.	playHand newKeyboardFocus: aWorld.	playHand userInitials: 'play'.	lastEvent _ nil.	lastDelta _ 0@0.	state _ #play.	voiceRecorder ifNotNil:		[voiceRecorder playback].	time _ Time millisecondClockValue.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'di 3/6/1999 22:39'!resumeRecordIn: aWorld	recHand _ aWorld activeHand ifNil: [aWorld primaryHand].	recHand newKeyboardFocus: aWorld.	recHand startReportingEventsTo: self.	lastEvent _ nil.	state _ #record.	voiceRecorder ifNotNil:		[voiceRecorder clearRecordedSound.		voiceRecorder resumeRecording].	time _ Time millisecondClockValue.! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'di 3/6/1999 15:49'!handleEvent: newEvent 	| now |	state == #record ifFalse: [^ self].	newEvent hand == recHand ifFalse: [^ self].	newEvent = lastEvent ifTrue: [^ self].	newEvent keyCharacter = (Character value: 27 "esc")		ifTrue: [^ self stop].	now _ Time millisecondClockValue.	now < time ifTrue:		["If the ms clock wraps, output a small delta"		time _ now-10].	tapeStream nextPut: (now - time) -> newEvent.	journalFile ifNotNil:		[journalFile store: (now - time); space; store: newEvent; cr; flush]."Transcript cr; print: ((now - time) -> newEvent); endEntry."	lastEvent _ newEvent.	time _ now.! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'di 3/4/1999 14:48'!nextEventToPlay	"Return the next event when it is time to be replayed.	If it is not yet time, then return an interpolated mouseMove.	Return nil if nothing has happened.	Return an EOF event if there are no more events to be played."	| nextEvent nextAssn nextTime now lastP delta |	tapeStream atEnd ifTrue: [^ MorphicEvent basicNew						setType: #EOF cursorPoint: 0@0						buttons: 0 keyValue: 0].	nextAssn _ tapeStream next.	nextEvent _ nextAssn value.	nextTime _ time + nextAssn key.	now _ Time millisecondClockValue.	now < time ifTrue:		["If the ms clock wraps, simply jump to next event"		nextTime _ now].	now >= nextTime	ifTrue: ["It's time to play the next event"			time _ nextTime.			lastDelta _ 0@0.			^ lastEvent _ nextEvent]	ifFalse: [tapeStream skip: -1.			"Not time for the next event yet, but interpolate the mouse.			This allows tapes to be compressed when velocity is fairly constant."			lastEvent ifNil: [^ nil].			lastP _ lastEvent cursorPoint.			delta _ (nextEvent cursorPoint - lastP) * (now-time) // (nextTime-time).			delta = lastDelta ifTrue: [^ nil]. "No movement"			lastDelta _ delta.			^ MorphicEvent basicNew					setType: #mouseMove cursorPoint: lastP + delta					buttons: lastEvent buttons keyValue: 0]! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 2/15/1999 16:01'!readFrom: aStream	"Private"	| cr t evt line lineStream |	cr _ Character cr.	tape _ Array streamContents:		[:tStream |		[aStream atEnd] whileFalse:			[line _ aStream upTo: cr.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream _ ReadStream on: line.						t _ Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt _ MorphicEvent readFrom: lineStream.						tStream nextPut: t -> evt]]].	saved _ true  "Still exists on file"! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 2/12/1999 23:11'!readTape	(Smalltalk at: #RequestBoxMorph			ifAbsent: [^ self readTape: (FillInTheBlankMorph							request: 'Tape to read')])		request: 'Tape to read'		respondTo: self		selector: #readTape:! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 2/15/1999 16:06'!readTape: fileName 	| file |	self writeCheck.	(FileStream isAFileNamed: fileName) ifFalse: [^ nil].	file _ FileStream oldFileNamed: fileName.	self readFrom: file.	file close! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 2/15/1999 16:05'!writeCheck	(saved not and: [self confirm: 'The current tape has not been saved.Would you like to do so now?']) ifTrue:		[self writeTape].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 2/15/1999 16:07'!writeFileNamed: fileName	| file |	file _ FileStream newFileNamed: fileName.	tape do:		[:cell |		file store: cell key; space.		file store: cell value; cr].	file close.	saved _ true.	^ file name! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'di 2/12/1999 23:09'!writeTape	| args b |	args _ (b _ self button: 'writeTape') isNil				ifTrue: [#()]				ifFalse: [b arguments].	(args size > 0 and: [args first size > 0])		ifTrue: [args first.				self writeTape: args first]		ifFalse: [(Smalltalk at: #RequestBoxMorph							ifAbsent: [^ self writeTape: (FillInTheBlankMorph											request: 'Tape to write')])						request: 'Tape to write'						respondTo: self						selector: #writeTape:]! !!HandMorph methodsFor: 'accessing' stamp: 'di 3/6/1999 23:52'!showTemporaryCursor: cursorOrNil	"Set the temporary cursor to the given Form. If the argument is nil, revert to the normal cursor."	self showTemporaryCursor: cursorOrNil hotSpotOffset: 0@0! !!HandMorph methodsFor: 'accessing' stamp: 'di 3/6/1999 23:54'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset	"Set the temporary cursor to the given Form. If the argument is nil, revert to the normal cursor."	self changed.	cursorOrNil == nil		ifTrue: [temporaryCursor _ nil.				bounds _ self position extent: NormalCursor extent.				temporaryCursorOffset _ 0@0]		ifFalse: [temporaryCursor _ cursorOrNil asCursorForm.				bounds _ self position - temporaryCursorOffset							extent: temporaryCursor extent.				temporaryCursorOffset _ hotSpotOffset + temporaryCursor offset].	self userInitials: userInitials.	self layoutChanged.	self changed.! !!HandMorph methodsFor: 'accessing' stamp: 'di 2/15/1999 12:34'!userInitials: aString	userInitials _ aString.	self bounds: (bounds merge: (bounds topRight + (0@4) extent: (userInitials asParagraph extent))).! !!HandMorph methodsFor: 'geometry' stamp: 'di 3/6/1999 23:40'!position	temporaryCursorOffset ifNil: [temporaryCursorOffset _ 0@0].	^ bounds topLeft + temporaryCursorOffset! !!HandMorph methodsFor: 'geometry' stamp: 'di 3/6/1999 23:40'!position: aPoint	"Overridden to align submorph origins to the grid if gridding is on."	temporaryCursorOffset ifNil: [temporaryCursorOffset _ 0@0].	gridOn		ifTrue: [^ super position: (aPoint grid: grid) - temporaryCursorOffset]		ifFalse: [^ super position: aPoint - temporaryCursorOffset].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 3/6/1999 20:52'!handleEvent: evt		eventSubscribers do: [:m | m handleEvent: evt]."--"	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]]."--"	lastEvent _ evt.	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		evt isMouseDown ifTrue: [ ^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]].	evt isKeystroke ifTrue: [		keyboardFocus ifNotNil: [keyboardFocus keyStroke: evt].		^ self].! !!HandMorph methodsFor: 'event reporting' stamp: 'di 3/4/1999 14:57'!pauseEventRecorderIn: aWorld	"Suspend any recorder prior to a project change, and return it.	It will be resumed after starting the new project."	eventSubscribers do:		[:er | (er isKindOf: EventRecorderMorph) ifTrue: [^ er pauseIn: aWorld]].	^ nil! !!HandMorph methodsFor: 'event reporting' stamp: 'di 3/6/1999 21:55'!startReportingEventsTo: subscriber	"Start reporting events to the given object. All input events are reported to every event subscriber, in addition to being sent to the current mouse/keyboard focus morph. This allows one to build things like macro recorders, eyes that follow the mouse, etc."	eventSubscribers add: subscriber! !!HandMorphForReplay commentStamp: 'di 3/3/1999 21:01' prior: 0!I am a hand for replaying events stored in an EventRecorderMorph.  When there are no more events, I delete myself.!!HandMorphForReplay methodsFor: 'initialization' stamp: 'di 3/2/1999 20:07'!initialize	super initialize.	self showTemporaryCursor: Cursor normal! !!HandMorphForReplay methodsFor: 'initialization' stamp: 'di 3/3/1999 14:54'!recorder: anEventRecorder	recorder _ anEventRecorder! !!HandMorphForReplay methodsFor: 'event dispatching' stamp: 'di 3/4/1999 14:57'!pauseEventRecorderIn: aWorld	"Suspend my recorder prior to a project change, and return it.	It will be resumed after starting the new project."	^ recorder pauseIn: aWorld! !!HandMorphForReplay methodsFor: 'event dispatching' stamp: 'di 3/4/1999 14:55'!processEvents	"Play back the next event"	| evt |	(evt _ recorder nextEventToPlay) ifNil: [^ self].	evt type = #EOF ifTrue: [recorder pauseIn: self world.  ^ self].	self handleEvent: (evt setHand: self).! !!HandMorphForReplay methodsFor: 'halos' stamp: 'di 3/7/1999 00:00'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset	"When I show my cursor, it appears double size,	unless it is a form such as a paint brush."	cursorOrNil	ifNil: ["Setting cursor to nil cannot revert to hardware cursor -- just show normal."			^ self showTemporaryCursor: Cursor normal hotSpotOffset: Cursor normal offset]	ifNotNil:		[(cursorOrNil isKindOf: Cursor)			ifTrue: ["Show cursors magnified for visibility"					^ super showTemporaryCursor:									(CursorWithMask derivedFrom: (cursorOrNil magnifyBy: 2))				 				hotSpotOffset: (cursorOrNil offset negated*2) + hotSpotOffset]			ifFalse: [^ super showTemporaryCursor: cursorOrNil				 				hotSpotOffset: hotSpotOffset]]! !!MorphicSoundEvent methodsFor: 'as yet unclassified' stamp: 'di 3/2/1999 17:06'!initialize	super initialize.	type _ #startSound! !!MorphicSoundEvent methodsFor: 'as yet unclassified' stamp: 'di 3/2/1999 17:07'!sound: aSound	sound _ aSound! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 3/5/1999 15:12'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	| cursorPoint |	cursorPoint _ World == nil 			ifTrue: [Sensor cursorPoint]			ifFalse: [World cursorPoint].	^ self startUpWithCaption: captionOrNil		at: cursorPoint - (frame width//2@0)! !!Project methodsFor: 'menu messages' stamp: 'di 3/6/1999 22:38'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom priorProject recorderOrNil |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	priorProject _ CurrentProject.	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	showZoom _ Preferences showProjectZoom		and: ["Only show zoom if there is room for the both displays plus a megabyte"			Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+1000000)].	World isMorph ifTrue: [recorderOrNil _ World pauseEventRecorder].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	World isMorph ifTrue:		[recorderOrNil ifNotNil: [recorderOrNil resumeIn: World]].	showZoom		ifTrue: ["Show animated zoom to new display"				entering					ifTrue: [vanishingPoint _ Sensor cursorPoint]					ifFalse: [vanishingPoint _ self viewLocFor: priorProject].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				Display copyFrom: newDisplay].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!RestSound methodsFor: 'accessing' stamp: 'di 2/17/1999 21:09'!samples	^ SoundBuffer newMonoSampleCount: initialCount! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 3/6/1999 19:28'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| curs poly top |	super mouseEnter: evt.	top _ evt hand recipientForMouseDown: evt.	top == self ifTrue: ["none of my buttons in the way"		curs _ palette actionCursor.		evt hand showTemporaryCursor: curs.		palette getSpecial == #polygon: ifTrue:			[(poly _ self valueOfProperty: #polygon) ifNil: [^ self].			currentColor _ palette getColor.			poly color: currentColor; borderWidth: palette getNib width.			poly changed]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'di 3/6/1999 19:31'!pickupMouseUp: evt	"Grab a part of the picture (or screen) and store it in a known place. Like Copy on the Mac menu. Then switch to the stamp tool."	| rr pp pForm ii oldRect curs |	lastEvent == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ strokeOrigin rect: lastEvent cursorPoint + (14@14).			self restoreRect: oldRect].	self primaryHand showTemporaryCursor: nil.	"later get rid of this"		rr _ strokeOrigin rect: evt cursorPoint + (14@14).	pp _ rr translateBy: self world viewBox origin.	ii _ rr translateBy: (0@0) - bounds origin.	(rr intersects: bounds) ifTrue: [		pForm _ paintingForm copy: ii.		pForm primCountBits > 0 			ifTrue: []	"normal case.  Can be transparent in parts"			ifFalse: [pForm _ nil.			"Get an un-dimmed picture of other objects on the playfield"			"don't know how yet"]].	pForm ifNil: [pForm _ Form fromDisplay: pp].		"Anywhere on the screen"	palette pickupForm: pForm.	curs _ palette actionCursor.	evt hand showTemporaryCursor: curs.! !!SoundRecorder methodsFor: 'initialization' stamp: 'di 2/17/1999 10:59'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordLevel _ 0.5.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'accessing' stamp: 'di 2/17/1999 11:08'!codec: aSoundCodec	codec _ aSoundCodec! !!SoundRecorder methodsFor: 'accessing' stamp: 'di 2/16/1999 09:58'!samplingRate: newRate	samplingRate _ newRate  "Best are 44100 22050 11025"! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 2/17/1999 10:54'!clearRecordedSound	"Clear the sound recorded thus far. Go into pause mode if currently recording."	paused _ true.	recordedSound _ SequentialSound new.	self allocateBuffer.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 2/16/1999 09:13'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused _ true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer.				self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying _ nil].	CanRecordWhilePlaying ifFalse: [self stopRecording].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 3/4/1999 22:38'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 2/16/1999 09:13'!stopRecording	"Stop the recording process and turn of the sound input driver."	recordProcess ifNotNil: [recordProcess terminate].	recordProcess _ nil.	self primStopRecording.	Smalltalk unregisterExternalObject: bufferAvailableSema.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer].	self initializeRecordingState.! !!SoundRecorder methodsFor: 'results' stamp: 'di 3/4/1999 21:40'!condensedSamples	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."	| sz newBuf i |	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ SoundBuffer new: 0].	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	newBuf _ SoundBuffer newMonoSampleCount: sz.	i _ 1.	recordedBuffers do: [:b |		1 to: b size do: [:j |			newBuf at: i put: (b at: j).			i _ i + 1]].	recordedBuffers _ nil.	^ newBuf! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/16/1999 20:49'!condensedStereoSound	"Decompose my buffers into left and right channels and return a mixed sound consisting of the those two channels. This may be take a while, since the data must be copied into new buffers."	| sz leftBuf rightBuf leftI rightI left |	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	leftBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	rightBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	leftI _ rightI _ 1.	left _ true.	recordedBuffers do: [:b |		1 to: b size do: [:j |			left				ifTrue: [leftBuf at: leftI put: (b at: j). leftI _ leftI + 1. left _ false]				ifFalse: [rightBuf at: rightI put: (b at: j). rightI _ rightI + 1. left _ true]]].	^ MixedSound new		add: (SampledSound new setSamples: leftBuf samplingRate: samplingRate) pan: 0.0;		add: (SampledSound new setSamples: rightBuf samplingRate: samplingRate) pan: 1.0! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 11:07'!recordedSound	"Return the sound that was recorded."	^ recordedSound! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 21:24'!soundSegments	^ self segmentsAbove: 1000 normalizedVolume: 80.0! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!endPlace	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!firstSampleOverThreshold: threshold dcOffset: dcOffset startingAt: startPlace	"Beginning at startPlace, this routine will return the first place at which a sample exceeds the given threshold."	| buf s iStart jStart nThreshold |	nThreshold _ threshold negated.	iStart _ startPlace first.	jStart _ startPlace second.	iStart to: recordedBuffers size do:		[:i | buf _ recordedBuffers at: i.		jStart to: buf size do:			[:j | s _ (buf at: j) - dcOffset.			(s < nThreshold or: [s > threshold]) ifTrue:				["found a sample over threshold"				^ Array with: i with: j]].		jStart _ 1].	^ self endPlace! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 23:01'!place: startPlace plus: nSamples	"Return the place that is nSamples (may be negative) beyond thisPlace."	| i j remaining buf |	i _ startPlace first.	j _ startPlace second.	nSamples >= 0	ifTrue: [remaining _ nSamples.			[buf _ recordedBuffers at: i.			(j + remaining) <= buf size ifTrue: [^ Array with: i with: j + remaining].			i < recordedBuffers size]				whileTrue: [remaining _ remaining - (buf size - j + 1).							i _ i+1.  j _ 1].			^ self endPlace]	ifFalse: [remaining _ nSamples negated.			[buf _ recordedBuffers at: i.			(j - remaining) >= 1 ifTrue: [^ Array with: i with: j - remaining].			i > 1]				whileTrue: [remaining _ remaining - j.							i _ i-1.  j _ (recordedBuffers at: i) size].			^ #(1 1)]! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 23:19'!scanForEndThreshold: threshold dcOffset: dcOffset minLull: lull startingAt: startPlace	"Beginning at startPlace, this routine will find the last sound that exceeds threshold, such that if you look lull samples later you will not find another sound over threshold within the following block of lull samples.	Return the place that is lull samples beyond to that last sound.	If no end of sound is found, return endPlace."	| buf s iStart jStart nThreshold n |	nThreshold _ threshold negated.	iStart _ startPlace first.	jStart _ startPlace second.	n _ 0.	iStart to: recordedBuffers size do:		[:i | buf _ recordedBuffers at: i.		jStart to: buf size do:			[:j | s _ (buf at: j) - dcOffset.			(s < nThreshold or: [s > threshold])				ifTrue: ["found a sample over threshold"						n _ 0]				ifFalse: ["still not over threshold"						n _ n + 1.						n >= lull ifTrue: [^ Array with: i with: j]]].		jStart _ 1].	^ self endPlace! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:13'!scanForStartThreshold: threshold dcOffset: dcOffset minDur: duration startingAt: startPlace	"Beginning at startPlace, this routine will find the first sound that exceeds threshold, such that if you look duration samples later you will find another sound over threshold within the following block of duration samples.	Return the place that is duration samples prior to that first sound.	If no sound is found, return endPlace."	| soundPlace lookPlace nextSoundPlace thirdPlace |	soundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: startPlace.	[soundPlace = self endPlace ifTrue: [^ soundPlace].	"Found a sound -- look duration later"	lookPlace _ self place: soundPlace plus: duration.	nextSoundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: lookPlace.	thirdPlace _ self place: lookPlace plus: duration.	nextSoundPlace first < thirdPlace first		or: [nextSoundPlace first = thirdPlace first			and: [nextSoundPlace second < thirdPlace second]]]		whileFalse: [soundPlace _ nextSoundPlace].	"Yes, there is sound in the next interval as well"	^ self place: soundPlace plus: 0-duration! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 21:26'!segmentsAbove: threshold normalizedVolume: percentOfMaxVolume	"Break the current recording up into a sequence of sound segments separated by silences."	| max min sum totalSamples bufSize s dcOffset firstPlace endPlace resultBuf nFactor lastPlace segments gapSize minDur minLull soundSize restSize |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	(recordedSound == nil or: [recordedSound sounds isEmpty]) ifTrue:[^ self].	"Reconstruct buffers so old trimming code will work"	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	soundSize _ restSize _ 0.	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	minDur _ (samplingRate/20.0) asInteger.  " 1/20 second "	minLull _ (samplingRate/4.0) asInteger.  " 1/2 second "	segments _ SequentialSound new.	endPlace _ self endPlace.	lastPlace _ #(1 1).	[firstPlace _ self scanForStartThreshold: threshold						dcOffset: dcOffset						minDur: minDur						startingAt: lastPlace.	firstPlace = endPlace]		whileFalse:		[firstPlace = lastPlace ifFalse:			["Add a silence equal to the gap size"			"Wasteful but simple way to get gap size..."			gapSize _ (self copyFrom: lastPlace to: firstPlace						normalize: 1000 dcOffset: dcOffset) size - 2.			"... -2 makes up for overlap of one sample on either end"			segments add: (RestSound dur: gapSize asFloat / samplingRate).			restSize _ restSize + gapSize."Transcript cr; print: firstPlace; space; print: lastPlace; space; print: gapSize; space; show: 'gap'."			].		lastPlace _ self scanForEndThreshold: threshold						dcOffset: dcOffset						minLull: minLull + minDur						startingAt: firstPlace.		"Allow room for lead time of next sound"		lastPlace _ self place: lastPlace plus: minDur negated.		nFactor _ self normalizeFactorFor: percentOfMaxVolume						min: min max: max dcOffset: dcOffset.		resultBuf _ self copyFrom: firstPlace to: lastPlace						normalize: nFactor dcOffset: dcOffset.		soundSize _ soundSize + resultBuf size."Transcript cr; print: firstPlace; space; print: lastPlace; space; print: resultBuf size; space; show: 'sound'."		segments add: (codec == nil			ifTrue: [SampledSound new setSamples: resultBuf samplingRate: samplingRate]			ifFalse: [codec compressSound: (SampledSound new setSamples: resultBuf samplingRate: samplingRate)])].	"Final gap for consistency"	gapSize _ (self copyFrom: lastPlace to: self endPlace				normalize: 1000 dcOffset: dcOffset) size - 1.	segments add: (RestSound dur: gapSize asFloat / samplingRate).	restSize _ restSize + gapSize.	PopUpMenu notify: ((soundSize+restSize/samplingRate) roundTo: 0.1) printString , ' secs reduced to ' , ((soundSize/samplingRate) roundTo: 0.1) printString.	recordedBuffers _ nil.	^ segments! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/17/1999 20:38'!suppressSilence	recordedSound _ self soundSegments! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:52'!trim: threshold normalizedVolume: percentOfMaxVolume	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ self].	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	"a place is an array of <buffer index><index of sample in buffer>"	startPlace _ self scanForStartThreshold: threshold					dcOffset: dcOffset					minDur: (samplingRate/60.0) asInteger "at least 1/60th of a second"					startingAt: #(1 1).	startPlace = self endPlace ifTrue:		["no samples above threshold"		recordedBuffers _ nil.  ^ self].	endPlace _ self scanForEndThreshold: threshold					dcOffset: dcOffset					minLull: (samplingRate/5) asInteger					startingAt: startPlace.	nFactor _ self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.	resultBuf _ self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.	recordedSound _ SampledSound new setSamples: resultBuf samplingRate: samplingRate.	recordedBuffers _ nil! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 11:13'!allocateBuffer	"Allocate a new buffer and reset nextIndex."	| bufferTime |	bufferTime _ stereo  "Buffer time = 1/2 second"		ifTrue: [self samplingRate asInteger]		ifFalse: [self samplingRate asInteger // 2].	currentBuffer _ SoundBuffer newMonoSampleCount:		"Multiple of samplesPerFrame that is approx. bufferTime long"		(bufferTime truncateTo: self samplesPerFrame).	nextIndex _ 1.! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 10:52'!emitBuffer: buffer	| sound |	sound _ SampledSound new setSamples: buffer samplingRate: samplingRate.	recordedSound add:		(codec == nil			ifTrue: [sound]			ifFalse: [codec compressSound: sound])! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 11:13'!emitPartialBuffer	| s |	s _ self samplesPerFrame.	self emitBuffer: (currentBuffer copyFrom: 1 to: ((nextIndex-1) +( s-1) truncateTo: s))! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/16/1999 08:55'!recordLoop	"Record process loop that records samples."	| n sampleCount |	n _ 0.	[true] whileTrue: [		n = 0 ifTrue: [bufferAvailableSema wait].		paused			ifTrue: [				n _ self primRecordSamplesInto: meteringBuffer startingAt: 1.				self meterFrom: 1 count: n in: meteringBuffer]			ifFalse: [				n _ self primRecordSamplesInto: currentBuffer startingAt: nextIndex.				self meterFrom: nextIndex count: n in: currentBuffer.				nextIndex _ nextIndex + n.				stereo					ifTrue: [sampleCount _ currentBuffer stereoSampleCount]					ifFalse: [sampleCount _ currentBuffer monoSampleCount].				nextIndex > sampleCount					ifTrue: [						self emitBuffer: currentBuffer.						self allocateBuffer]]].! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 10:39'!samplesPerFrame	"Can be overridden to quantize buffer size for, eg, fixed-frame codecs"	codec == nil		ifTrue: [^ 1]		ifFalse: [^ codec samplesPerFrame]! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 3/4/1999 14:57'!pauseEventRecorder	"Suspend any event recorder, and return it if found"	| er |	self hands do: [:h | (er _ h pauseEventRecorderIn: self) ifNotNil: [^ er]].	^ nil! !!WorldMorph methodsFor: 'hands' stamp: 'di 3/6/1999 22:37'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifTrue: [		aHandMorph dropMorphsEvent: MorphicEvent new.		hands _ hands copyWithout: aHandMorph.		self invalidRect: aHandMorph fullBounds.		activeHand == aHandMorph ifTrue: [self activeHand: nil]].! !CompressedSoundData removeSelector: #doesNotUnderstand:!Cursor initialize!Cursor removeSelector: #asColorForm!Cursor removeSelector: #magnifyBy:!CursorWithMask removeSelector: #asColorForm!EventRecorderMorph removeSelector: #suspendIn:!EventRecorderMorph removeSelector: #privatePlayBack!EventRecorderMorph removeSelector: #tape!EventRecorderMorph removeSelector: #wantsSteps!EventRecorderMorph removeSelector: #light!EventRecorderMorph removeSelector: #nextTrack!EventRecorderMorph removeSelector: #resumePlay!EventRecorderMorph removeSelector: #addSlider!EventRecorderMorph removeSelector: #privatePlayBack:!EventRecorderMorph removeSelector: #playOrInterpolateOneEvent!EventRecorderMorph removeSelector: #playHand:!EventRecorderMorph removeSelector: #reset!EventRecorderMorph removeSelector: #suspend!EventRecorderMorph removeSelector: #prevTrack!EventRecorderMorph removeSelector: #privatePlayBackEvent:!EventRecorderMorph removeSelector: #state!EventRecorderMorph removeSelector: #addRecordLevelSlider!EventRecorderMorph removeSelector: #playHand!EventRecorderMorph removeSelector: #record:!EventRecorderMorph removeSelector: #time!EventRecorderMorph removeSelector: #playBackEvent:!EventRecorderMorph removeSelector: #storeOn:!EventRecorderMorph removeSelector: #resume!EventRecorderMorph removeSelector: #resumeRecord!EventRecorderMorph removeSelector: #step!EventRecorderMorph removeSelector: #checkForDoubleClick!EventRecorderMorph removeSelector: #recHand!EventRecorderMorph removeSelector: #caption:voiceRecorder:tapeStream:!EventRecorderMorph removeSelector: #rewind!EventRecorderMorph removeSelector: #stepTime!EventRecorderMorph removeSelector: #tape:!EventRecorderMorph removeSelector: #recHand:!EventRecorderMorph removeSelector: #showInterpolation!HandMorph removeSelector: #suspendEventRecorder!HandMorph removeSelector: #suspendEventRecorderIn:!HandMorphForReplay removeSelector: #suspendEventRecorder!HandMorphForReplay removeSelector: #privateOwner:!HandMorphForReplay removeSelector: #delete!HandMorphForReplay removeSelector: #suspendEventRecorderIn:!SoundRecorder removeSelector: #speechSegmentsAbove:normalizedVolume:!SoundRecorder removeSelector: #scanForStartThreshold:minDur:startingAt:dcOffset:!WorldMorph removeSelector: #suspendEventRecorder!WorldMorph removeSelector: #pauseActiveRecorder!Smalltalk removeClassNamed: #EventRecorderButtonMorph!Smalltalk removeClassNamed: #EventTape!Smalltalk removeClassNamed: #EventRecorder!Smalltalk removeClassNamed: #SoundRecorderWithCodec!