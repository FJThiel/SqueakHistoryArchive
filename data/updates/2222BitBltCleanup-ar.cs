'From Squeak2.8alpha of 16 February 2000 [latest update: #2217] on 28 May 2000 at 1:06:09 pm'!"Change Set:		BitBltCleanupDate:			28 May 2000Author:			Andreas RaabThe change set makes all references to BitBlt and WarpBlt go through 'BitBlt current' and 'WarpBlt current' so that the actual class to be used can be queried from the current Display."!!ControlManager methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:06'!restore: aRectangle below: index without: aView	"Restore all windows visible in aRectangle, but without aView"	| view | 	view _ (scheduledControllers at: index) view.	view == aView ifTrue: 		[index >= scheduledControllers size ifTrue: [^ self].		^ self restore: aRectangle below: index+1 without: aView].	view displayOn: ((BitBlt current toForm: Display) clipRect: aRectangle).	index >= scheduledControllers size ifTrue: [^ self].	(aRectangle areasOutside: view windowBox) do:		[:rect | self restore: rect below: index + 1 without: aView]! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'ar 5/28/2000 12:06'!follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |   location _ loc.   rect1 _ location extent: self extent.   save1 _ initialBitsBehind.   save1Blt _ BitBlt current toForm: save1.   buffer _ Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"   bufferBlt _ BitBlt current toForm: buffer.   Display deferUpdates: true.   self displayOn: Display at: location rule: Form paint.   Display deferUpdates: false; forceToScreen: (location extent: self extent).   [durationBlock value] whileTrue: [		newLoc _ locationBlock value.		newLoc ~= location ifTrue: [			rect2 _ newLoc extent: self extent.			bothRects _ rect1 merge: rect2.			(rect1 intersects: rect2)				ifTrue: [  "when overlap, buffer background for both rectangles"					bufferBlt copyFrom: bothRects in: Display to: 0@0.					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.					"now buffer is clean background; get new bits for save1"					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.					self displayOnPort: bufferBlt at: rect2 origin - bothRects origin rule: Form paint.					Display deferUpdates: true.					Display copy: bothRects from: 0@0 in: buffer rule: Form over.					Display deferUpdates: false; forceToScreen: bothRects]				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"					Display deferUpdates: true.					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.					save1Blt copyFrom: rect2 in: Display to: 0@0.					self displayOn: Display at: newLoc rule: Form paint.					Display deferUpdates: false; 						forceToScreen: (location extent: save1 extent); 						forceToScreen: (newLoc extent: self extent)].			location _ newLoc.			rect1 _ rect2]].	^ save1 displayOn: Display at: location! !!DisplayMedium methodsFor: 'coloring' stamp: 'ar 5/28/2000 12:06'!fillShape: aShapeForm fillColor: aColor at: location	"Fill a region corresponding to 1 bits in aShapeForm with aColor"	((BitBlt current destForm: self sourceForm: aShapeForm fillColor: aColor		combinationRule: Form paint		destOrigin: location + aShapeForm offset sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits! !!DisplayScanner methodsFor: 'private' stamp: 'ar 5/28/2000 12:07'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt current toForm: aParagraph destinationForm.	bitBlt fillColor: aParagraph fillColor.	"sets halftoneForm"	bitBlt combinationRule: aParagraph rule.	bitBlt clipRect: clippingRectangle.! !!DisplayScanner methodsFor: 'quick print' stamp: 'ar 5/28/2000 12:07'!quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Initialize myself."	bitBlt _ BitBlt current toForm: aForm.	backgroundColor _ Color transparent.	paragraphColor _ textColor.	font _ aStrikeFont ifNil: [TextStyle defaultFont].	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	self setFont.	"Override cbrule and map"	bitBlt combinationRule: Form paint.	bitBlt colorMap: (Bitmap with: 0      "Assumes 1-bit deep fonts"						with: (textColor pixelValueForDepth: bitBlt destForm depth)).	bitBlt clipRect: aRectangle.! !!FishEyeMorph methodsFor: 'private' stamp: 'ar 5/28/2000 12:12'!magnifiedForm	| warp warpForm fromForm |	savedExtent ~= srcExtent ifTrue: [		savedExtent _ srcExtent.		self calculateTransform].	warpForm _ Form extent: srcExtent depth: Display depth.	fromForm _ super magnifiedForm.	warp _  (WarpBlt current toForm: warpForm)		sourceForm: fromForm;		colorMap: nil;		cellSize: 2;		combinationRule: Form over.	1 to: gridNum y do: [:j |		1 to: gridNum x do: [:i |			warp				clipRect: ((clipRects at: j) at: i);				copyQuad: ((quads at: j) at: i)					toRect: ((toRects at: j) at: i).		].	].	^warpForm! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:07'!asFormOfDepth: d	| newForm |	d = depth ifTrue:[^self].	newForm _ Form extent: self extent depth: d.	(BitBlt current toForm: newForm)		colorMap: (self colormapIfNeededForDepth: d);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	^newForm! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copy: destRectangle from: sourcePt in: sourceForm rule: rule 	"Make up a BitBlt table and copy the bits."	(BitBlt current toForm: self)		copy: destRectangle		from: sourcePt in: sourceForm		fillColor: nil rule: rule! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm 	"Make up a BitBlt table and copy the bits."	(BitBlt current 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) copyBits! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map	"Make up a BitBlt table and copy the bits.  Use a colorMap."	((BitBlt current 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) colorMap: map) copyBits! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceRect from: sourceForm at: destOrigin colorMap: map 	"Make up a BitBlt table and copy the bits with the given colorMap."	((BitBlt current 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: self boundingBox) colorMap: map) copyBits! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Refer to the comment in 	DisplayMedium|drawLine:from:to:clippingBox:rule:mask:." 		| dotSetter |	"set up an instance of BitBlt for display"	dotSetter _ BitBlt current		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: anInteger		destOrigin: beginPoint		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: clipRect.	dotSetter drawFrom: beginPoint to: endPoint! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:08'!fill: aRectangle rule: anInteger fillColor: aForm 	"Replace a rectangular area of the receiver with the pattern described by aForm 	according to the rule anInteger."	(BitBlt current toForm: self)		copy: aRectangle		from: 0@0 in: nil		fillColor: aForm rule: anInteger! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:08'!fillFromXYColorBlock: colorBlock	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker _ BitBlt current bitPokerToForm: self.	0 to: height-1 do:		[:y | yRel _ y asFloat / (height-1) asFloat.		0 to: width-1 do:			[:x |  xRel _ x asFloat / (width-1) asFloat.			poker pixelAt: x@y				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: depth)]]" | d |((Form extent: 100@20 depth: Display depth)	fillFromXYColorBlock:	[:x :y | d _ 1.0 - (x - 0.5) abs - (y - 0.5) abs.	Color r: d g: 0 b: 1.0-d]) display"! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:08'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all _ self boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"	previousSmear _ smearForm deepCopy.	count _ 1.	[count = 10 and:   "check for no change every 10 smears"		[count _ 1.		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1@0 rule: Form under.			smearPort copyForm: smearForm to: -1@0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			smearPort copyForm: smearForm to: 0@1 rule: Form under.			smearPort copyForm: smearForm to: 0@-1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			count _ count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:08'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. This pixel value depends on the receiver's depth. Typical clients use colorAt: to get a Color.  "	^ (BitBlt current bitPeekerFromForm: self) pixelAt: aPoint! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:08'!pixelValueAt: aPoint put: pixelValue	"Store the given raw pixel value at the given point. Typical clients use colorAt:put: to store a color. "	(BitBlt current bitPokerToForm: self) pixelAt: aPoint put: pixelValue.! !!Form methodsFor: 'filling' stamp: 'ar 5/28/2000 12:09'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt current destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'bordering' stamp: 'ar 5/28/2000 12:07'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a border whose rectangular area is defined by rect. Thewidth of the border of each side is borderWidth. Uses fillColor for drawingthe border."        | blt |        blt _ (BitBlt current toForm: self) combinationRule: rule; fillColor: fillColor.        blt sourceOrigin: 0@0.        blt destOrigin: rect origin.        blt width: rect width; height: borderWidth; copyBits.        blt destY: rect corner y - borderWidth; copyBits.        blt destY: rect origin y + borderWidth.        blt height: rect height - borderWidth - borderWidth; width:borderWidth; copyBits.        blt destX: rect corner x - borderWidth; copyBits! !!Form methodsFor: 'bordering' stamp: 'ar 5/28/2000 12:07'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self deepCopy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt current toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/28/2000 12:12'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ self class extent: self extent depth: depth.	quad _ self boundingBox innerCorners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/28/2000 12:12'!magnify: aRectangle by: scale smoothing: cellSize        "Answer a Form created as a scaling of the receiver.        Scale may be a Float, and may be greater or less than 1.0."        | newForm |        newForm _ self blankCopyOf: aRectangle scaledBy: scale.        (WarpBlt current toForm: newForm)                sourceForm: self;                colorMap: (self colormapIfNeededForDepth: depth);                cellSize: cellSize;  "installs a new colormap if cellSize > 1"                combinationRule: 3;                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.        ^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:        [(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:        [cp _ Sensor cursorPoint.        (f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/28/2000 12:12'!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #none, #right, #left, or #pi"	| newForm quad rot |	direction == #none ifTrue: [^ self].	newForm _ self class extent: (direction = #pi ifTrue: [width@height]											ifFalse: [height@width]) depth: depth.	quad _ self boundingBox innerCorners.	rot _ #(right pi left) indexOf: direction.	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/28/2000 12:12'!rotateBy: deg magnify: scale smoothing: cellSize	"Rotate the receiver by the indicated number of degrees and magnify.  "	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts p bigSide |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	bigSide _ (side * scale) rounded.	rot _ Form extent: bigSide@bigSide depth: self depth.	warp _ (WarpBlt current toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint.	r1 _ (0@0 extent: side@side) align: (side@side)//2 with: self boundingBox center.	"Rotate the corners of the source rectangle." 	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) magnify: 0.75 smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/28/2000 12:12'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt current toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:08'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt current toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt current toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:08'!primCountBits	"Count the non-zero pixels of this form."	depth > 8 ifTrue:		[^(self asFormOfDepth: 8) primCountBits].	^ (BitBlt current toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm _ Bitmap new: (1 bitShift: (depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	cm _ ColorMap colors: cm.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice _ Form extent: width@1 depth: 1.	copyBlt _ (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt _ (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top _ (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom _ (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH _ bottom - top + 1.	slice _ Form extent: 1@newH depth: 1.	copyBlt _ (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt _ (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left _ (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right _ (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	depth = 32		ifTrue: [cm _ (Color  cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm _ Bitmap new: (1 bitShift: (depth min: 15)).				1 to: cm size do: [:i | cm at: i put: i - 1]].	newInd _ newColor pixelValueForDepth: depth.	cm at: (oldColor pixelValueForDepth: (depth min: 16))+1 put: newInd.	target _ newColor isTransparent 		ifTrue: [ff _ Form extent: self extent depth: depth.			ff fillWithColor: newColor.  ff]		ifFalse: [self].	(BitBlt current toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!smear: dir distance: dist	"Smear any black pixels in this form in the direction dir in Log N steps"	| skew bb |	bb _ BitBlt current destForm: self sourceForm: self fillColor: nil		combinationRule: Form under destOrigin: 0@0 sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox.	skew _ 1.	[skew < dist] whileTrue:		[bb destOrigin: dir*skew; copyBits.		skew _ skew+skew]! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBlt current toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt current destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt current toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt current destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt current toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'other' stamp: 'ar 5/28/2000 12:07'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt current toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt current toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Form methodsFor: 'other' stamp: 'ar 5/28/2000 12:08'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	map _ (Color cachedColormapFrom: depth to: depth) copy.	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: depth).	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'other' stamp: 'ar 5/28/2000 12:08'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	depth < 16		ifTrue: [map _ (Color cachedColormapFrom: depth to: depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'transitions' stamp: 'ar 5/28/2000 12:12'!pageWarp: otherImage at: topLeft forward: forward	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.	forward == true means turn pages toward you, else away. [ignored for now]"	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |	pageRect _ otherImage boundingBox.	oldPage _ self copy: (pageRect translateBy: topLeft).	(forward ifTrue: [oldPage] ifFalse: [otherImage])		border: pageRect		widthRectangle: (Rectangle				left: 0				right: 2				top: 1				bottom: 1)		rule: Form over		fillColor: Color black.	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).	nSteps _ 8.	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.	1 to: nSteps-1 do:		[:i | forward			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * i // nSteps)]			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).		sourceQuad _ Array with: pageRect topLeft			with: pageRect bottomLeft + (0@p y)			with: pageRect bottomRight			with: pageRect topRight - (0@p y).		warp _ (WarpBlt current toForm: buffer)				clipRect: leafRect;				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);				combinationRule: Form paint.		warp copyQuad: sourceQuad toRect: leafRect.		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.		Display forceDisplayUpdate].	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.	Display forceDisplayUpdate."1 to: 4 do: [:corner | Display pageWarp:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 forward: false]"! !!Form methodsFor: 'converting' stamp: 'ar 5/28/2000 12:07'!asTexture	| newForm |	newForm _ B3DTexture extent: self extent depth: 32.	(BitBlt current toForm: newForm)		colorMap: (self colormapIfNeededForDepth: 32);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	newForm interpolate: false.	newForm wrap: false.	newForm envMode: 0.	^newForm! !!ColorForm methodsFor: 'pixel accessing' stamp: 'ar 5/28/2000 12:06'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. Typical clients use colorAt: to get a Color."	"Details: To get the raw pixel value, be sure the peeker's colorMap is nil."	^ (BitBlt current bitPeekerFromForm: self) colorMap: nil; pixelAt: aPoint! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/28/2000 12:06'!twoToneFromDisplay: aRectangle backgroundColor: bgColor	"Copy one-bit deep ColorForm from the Display using a color map that maps all colors except the background color to black. Used for caching the contents of inactive MVC windows."	| map |	(width = aRectangle width and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	"make a color map mapping the background color	 to zero and all other colors to one"	map _ Bitmap new: (1 bitShift: (Display depth min: 9)).	1 to: map size do: [:i | map at: i put: 16rFFFFFFFF].	map at: (bgColor indexInMap: map) put: 0.	(BitBlt current toForm: self)		destOrigin: 0@0;		sourceForm: Display;		sourceRect: aRectangle;		combinationRule: Form over;		colorMap: map;		copyBits.! !!ColorForm methodsFor: 'copying' stamp: 'ar 5/28/2000 12:06'!copy: aRect 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."	| newForm |	newForm _ self class extent: aRect extent depth: depth.	((BitBlt current		destForm: newForm		sourceForm: self		fillColor: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: aRect origin		extent: aRect extent		clipRect: newForm boundingBox)		colorMap: nil) copyBits.	colors ifNotNil: [newForm colors: colors copy].	^ newForm! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:07'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf 	(BitBlt current		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) copyBits! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:07'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map	((BitBlt current		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits! !!Form class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:07'!dotOfSize: diameter	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius _ diameter//2.	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).		bb _ (BitBlt current toForm: form)		sourceX: 0; sourceY: 0;		combinationRule: Form over;		fillColor: Color black.	rect _ form boundingBox.	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		bb	destX: centerX - centerXBias - dx			destY: centerY - centerYBias - dy			width: dx + dx + centerXBias + 1			height: 1;			copyBits.		bb	destY: centerY + dy;			copyBits].	^ form"Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]"! !!Form class methodsFor: 'examples' stamp: 'ar 5/28/2000 12:08'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors _ Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade _ Form extent: diam@diam offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball _ Form dotOfSize: diam.	color _ 8.	[ true ] whileTrue:		[port _ BitBlt current toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue _ OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ Sensor cursorPoint.		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"		colr2 _ colr mixed: 0.3 with: Color white.		[Sensor redButtonPressed or: [queue size > 0]] whileTrue:			[filter _ filter * 4 + Sensor cursorPoint // 5.			point _ Sensor redButtonPressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q _ queue removeFirst) == nil ifTrue: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor redButtonPressed ifTrue: [queue addLast: point]]].! !!FormCanvas methodsFor: 'other' stamp: 'ar 5/28/2000 12:09'!showAt: pt invalidRects: updateRects	| blt |	blt _ (BitBlt current toForm: Display)		sourceForm: form;		combinationRule: Form over.	updateRects do:		[:rect |		blt sourceRect: rect;			destOrigin: rect topLeft + pt;			copyBits]! !!FormCanvas methodsFor: 'other' stamp: 'ar 5/28/2000 12:12'!warpFrom: sourceQuad toRect: destRect        ^ (WarpBlt current toForm: port destForm)                combinationRule: Form paint;                sourceQuad: sourceQuad destRect: (destRect translateBy: origin);                clipRect: clipRect! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 5/28/2000 12:12'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	| warp dstRect srcQuad dstOffset center |	(self ifNoTransformWithIn: sourceRect) & false		ifTrue:[^super image: aForm at: aPoint sourceRect: sourceRect rule: rule].	dstRect _ (transform localBoundsToGlobal: (aForm boundingBox translateBy: aPoint)).	dstOffset _ 0@0. "dstRect origin."	"dstRect _ 0@0 corner: dstRect extent."	center _ 0@0."transform globalPointToLocal: dstRect origin."	srcQuad _ transform globalPointsToLocal: (dstRect innerCorners).	srcQuad _ srcQuad collect:[:pt| pt - aPoint].	warp _ (WarpBlt current toForm: Display)			sourceForm: aForm;			cellSize: 2;  "installs a new colormap if cellSize > 1"			combinationRule: Form over.	warp copyQuad: srcQuad toRect: (dstRect translateBy: dstOffset).	self frameRectangle: (aForm boundingBox translateBy: aPoint) color: Color green.	"... TODO ... create a bitmap fill style from the form and use it for a simple rectangle."! !!FormEditor methodsFor: 'editing tools' stamp: 'ar 5/28/2000 12:09'!repeatCopy	"As long as the red button is pressed, copy the source form onto the 	display screen."	[sensor redButtonPressed]		whileTrue: 		[(BitBlt current destForm: Display sourceForm: form halftoneForm: color			combinationRule: (Display depth > 1 ifTrue: [Form paint]										ifFalse: [mode])			destOrigin: self cursorPoint sourceOrigin: 0@0 extent: form extent			clipRect: view insetDisplayBox)			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF);			copyBits]! !!ImageMorphWithSpotlight methodsFor: 'all' stamp: 'ar 5/28/2000 12:09'!step	| cp |	((self bounds expandBy: spotBuffer extent // 2) containsPoint: (cp _ self cursorPoint))		ifTrue:		[(cp - (spotBuffer extent // 2)) = spotBuffer offset ifTrue: [^ self].  "No change"		"Cursor has moved where its spotShape is visible"		spotOn _ true.		self spotChanged.		spotBuffer offset: cp - (spotBuffer extent // 2).		self spotChanged.		(BitBlt current toForm: spotBuffer)			"clear the buffer"			fill: spotBuffer boundingBox fillColor: (Bitmap with: 0) rule: Form over;			"Clip anything outside the base form"			clipRect: (spotBuffer boundingBox				intersect: (self bounds translateBy: spotBuffer offset negated));			"Fill the spotBuffer with the spot image"			copyForm: spotImage to: self position - spotBuffer offset rule: Form over;			"Mask everything outside the spot shape to 0 (transparent)."			copyForm: spotShape to: spotShape offset negated rule: Form and				colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)]		ifFalse:		[spotOn ifTrue: [self spotChanged. spotOn _ false]]! !!InfiniteForm methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:09'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the real display message, but it doesn't get used until the new	display protocol is installed."	| targetBox patternBox bb |	(patternForm isKindOf: Form) ifFalse:		[^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm].	"Do it iteratively"	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.	patternBox _ patternForm boundingBox.	bb _ BitBlt current destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0		extent: patternBox extent clipRect: clipRectangle.	bb colorMap:		(patternForm colormapIfNeededForDepth: aDisplayMedium depth).	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			bb destOrigin: x@y; copyBits]]! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 5/28/2000 12:09'!nextImageDitheredToDepth: depth	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	"Fixup the alpha channel in the 32bit form"	(BitBlt current toForm: form)		destRect: form boundingBox;		fillColor: (Bitmap with: 16rFF000000);		combinationRule: 7; "bitOr:with:"		copyBits.			^ form! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:09'!copyPixelsGray: y	"Handle non-interlaced grayscale color mode (colorType = 0)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel |	blitter _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 16		ifTrue:			[0 to: width - 1 do: [:x | blitter pixelAt: x @ yput: 255 - (thisScanline at: x << 1 + 1)].			^ self]		ifFalse:			[bitsPerChannel = 8				ifTrue:					[1 to: width do: [:x | blitterpixelAt: x - 1 @ y put: (thisScanline at: x)].					^ self].			bitsPerChannel = 1				ifTrue:					[pixPerByte _ 8.					mask _ 1.					shifts _ #(7 6 5 4 3 2 1 0 )].			bitsPerChannel = 2				ifTrue:					[pixPerByte _ 4.					mask _ 3.					shifts _ #(6 4 2 0 )].			bitsPerChannel = 4				ifTrue:					[pixPerByte _ 2.					mask _ 15.					shifts _ #(4 0 )].			pixelNumber _ 0.			0 to: width - 1 do:				[:x |				rawByte _ thisScanline at: pixelNumber // pixPerByte + 1.				pixel _ rawByte >> (shifts at: pixelNumber\\ pixPerByte + 1) bitAnd: mask.				blitter pixelAt: x @ y put: pixel.				pixelNumber _ pixelNumber + 1]]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:09'!copyPixelsGray: y at: startX by: incX	"Handle interlaced grayscale color mode (colorType = 0)"	| b offset bits w pixel mask blitter pixelNumber pixPerByte rawByteshifts |	bitsPerChannel = 16		ifTrue: [			b _ BitBlt current bitPokerToForm: form.			startX to: width-1 by: incX do: [ :x |				b pixelAt: x@y put: 255 - (thisScanline at:(x//incX<<1)+1).				].			^ self			].	offset _ y*rowSize+1.	bits _ form bits.	bitsPerChannel = 8 ifTrue: [		startX to: width-1 by: incX do: [ :x |			w _ offset + (x>>2).			b _ 3- (x \\ 4) * 8.			pixel _ (thisScanline at: x // incX + 1)<<b.			mask _ (255<<b) bitInvert32.			bits at: w put: (((bits at: w) bitAnd: mask) bitOr:pixel)		].		^ self	].	bitsPerChannel = 1 ifTrue: [		pixPerByte _ 8.		mask _ 1.		shifts _ #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte _ 4.		mask _ 3.		shifts _ #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte _ 2.		mask _ 15.		shifts _ #(4 0).	].	blitter _ BitBlt current bitPokerToForm: form.	pixelNumber _ 0.	startX to: width-1 by: incX do: [ :x |		rawByte _ thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel _ (rawByte >> (shifts at: (pixelNumber \\ pixPerByte)+ 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber _ pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:09'!copyPixelsGrayAlpha: y	"Handle non-interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			0 to: width-1 do: [ :x |				i _ (x << 1) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+1)<<24)					+ (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			0 to: width-1 do: [ :x |				i _ (x << 2) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+2)<<24)					+ (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsGrayAlpha: y at: startX by: incX	"Handle interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 1) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+1)<<24)					+ (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 2) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+2)<<24)					+ (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsIndexed: y	"Handle non-interlaced indexed color mode (colorType = 3)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel |	blitter _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue:			[1 to: width do: [:x | blitter pixelAt: x - 1 @ yput: (thisScanline at: x)].			^ self].	bitsPerChannel = 1		ifTrue:			[pixPerByte _ 8.			mask _ 1.			shifts _ #(7 6 5 4 3 2 1 0 )].	bitsPerChannel = 2		ifTrue:			[pixPerByte _ 4.			mask _ 3.			shifts _ #(6 4 2 0 )].	bitsPerChannel = 4		ifTrue:			[pixPerByte _ 2.			mask _ 15.			shifts _ #(4 0 )].	pixelNumber _ 0.	0 to: width - 1 do:		[:x |		rawByte _ thisScanline at: pixelNumber // pixPerByte + 1.		pixel _ rawByte >> (shifts at: pixelNumber \\ pixPerByte +1) bitAnd: mask.		blitter pixelAt: x @ y put: pixel.		pixelNumber _ pixelNumber + 1]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsIndexed: y at: startX by: incX	"Handle interlaced indexed color mode (colorType = 3)"	| offset b bits w pixel mask pixPerByte shifts blitter pixelNumberrawByte |	offset _ y*rowSize+1.	bits _ form bits.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				w _ offset + (x>>2).				b _ 3 - (x \\ 4) * 8.				pixel _ (thisScanline at: x // incX + 1)<<b.				mask _ (255<<b) bitInvert32.				bits at: w put: (((bits at: w) bitAnd:mask) bitOr: pixel)].			^ self ].	bitsPerChannel = 1 ifTrue: [		pixPerByte _ 8.		mask _ 1.		shifts _ #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte _ 4.		mask _ 3.		shifts _ #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte _ 2.		mask _ 15.		shifts _ #(4 0).	].	blitter _ BitBlt current bitPokerToForm: form.	pixelNumber _ 0.	startX to: width-1 by: incX do: [ :x |		rawByte _ thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel _ (rawByte >> (shifts at: (pixelNumber \\ pixPerByte)+ 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber _ pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			0 to: width-1 do: [ :x |				i _ (x * 3) + 1.				pixel _ 16rFF000000				     + ((thisScanline at: i)<<16)					+ ((thisScanline at: i+1)<<8)					+ ((thisScanline at: i+2)).				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			0 to: width-1 do: [ :x |				i _ (x * 6) + 1.				pixel _ 16rFF000000					+  ((thisScanline at: i)<<16)					+ ((thisScanline at: i+2)<<8)					+ ((thisScanline at: i+4)).				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX * 3) + 1.				pixel _ 16rFF000000				     + ((thisScanline at: i)<<16)					+ ((thisScanline at: i+1)<<8)					+ ((thisScanline at: i+2)).				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX * 6) + 1.				pixel _ 16rFF000000					+  ((thisScanline at: i)<<16)					+ ((thisScanline at: i+2)<<8)					+ ((thisScanline at: i+4)).				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			0 to: width-1 do: [ :x |				i _ (x << 2) + 1.				pixel _ ((thisScanline at: i+3)<<24)					+ ((thisScanline at: i)<<16)					+ ((thisScanline at: i+1)<<8)					+ ((thisScanline at: i+2)).				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			0 to: width-1 do: [ :x |				i _ (x << 3) +1.				pixel _ ((thisScanline at: i+6)<<24)					+  ((thisScanline at: i)<<16)					+ ((thisScanline at: i+2)<<8)					+ ((thisScanline at: i+4)).				b pixelAt: x@y put: pixel				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 5/28/2000 12:10'!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel b |	b _ BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 2) + 1.				pixel _ ((thisScanline at: i+3)<<24)					+ ((thisScanline at: i)<<16)					+ ((thisScanline at: i+1)<<8)					+ ((thisScanline at: i+2)).				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 3) +1.				pixel _ ((thisScanline at: i+6)<<24)					+  ((thisScanline at: i)<<16)					+ ((thisScanline at: i+2)<<8)					+ ((thisScanline at: i+4)).				b pixelAt: x@y put: pixel				]			]! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!init3	"Just a record of how we loaded in the latest paintbox button images"| bb rect lay pic16Bit aa blt on thin |self loadoffImage: 'etoy_default.gif'.self allMorphsDo: [:button |	(button isKindOf: ThreePhaseButtonMorph) 		ifTrue: [button offImage: nil]		ifFalse: [button position: button position + (100@0)]].(bb _ self findButton: #keep:) position: bb position + (100@0).(bb _ self findButton: #toss:) position: bb position + (100@0).(bb _ self findButton: #undo:) position: bb position + (100@0)."Transparent is (Color r: 1.0 g: 0 b: 1.0)"self moveButtons.self loadOnImage: 'etoy_in.gif'.AllOnImage _ nil.	'save space'.	self loadPressedImage: 'etoy_in.gif'.AllPressedImage _ nil.	'save space'.self loadCursors."position the stamp buttons"stampHolder stampButtons owner last delete.stampHolder pickupButtons last delete.stampHolder stampButtons: (stampHolder stampButtons copyFrom: 1 to: 3).stampHolder pickupButtons: (stampHolder pickupButtons copyFrom: 1 to: 3)."| rect |"stampHolder pickupButtons do: [:button |		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser.		button bounds: rect.	"image is nil"		]."| rect lay |"stampHolder clear.stampHolder stampButtons do: [:button |		button offImage: nil; pressedImage: nil.		lay _ button owner.		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser.		button image: (Form fromDisplay: (rect insetBy: 2)).		lay borderWidth: 2.		lay bounds: rect.	"image is nil"		]."| pic16Bit blt aa on |"	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: 'etoy_in.gif'.	aa _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	"Collect all the images for the buttons in the on state"	stampHolder pickupButtons do: [:button |			on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button image: on; pressedImage: on; offImage: nil.			].	self invalidRect: bounds.((self findButton: #erase:) arguments at: 3) offset: (12@35).((self findButton: #eyedropper:) arguments at: 3) offset: (0@0).((self findButton: #fill:) arguments at: 3) offset: (10@44).((self findButton: #paint:) arguments at: 3) offset: (3@3). "unused"((self findButton: #rect:) arguments at: 3) offset: (6@17).((self findButton: #ellipse:) arguments at: 3) offset: (5@4).((self findButton: #polygon:) arguments at: 3) offset: (5@4).((self findButton: #line:) arguments at: 3) offset: (5@17).((self findButton: #star:) arguments at: 3) offset: (2@5).thumbnail delete.thumbnail _ nil.(submorphs select: [:e | e class == RectangleMorph]) first bounds: 	Rectangle fromUser.(submorphs select: [:e | e class == RectangleMorph]) first borderWidth: 1; borderColor: Color black."| thin |"	submorphs do: [:ss | ss class == ImageMorph ifTrue: [thin _ ss "first"]].colorMemoryThin _ thin.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!init4	"Just a record of how Ted loaded in the paintbox button images, Feb 98"| bb im pp newImage pic24Bit picNewBit blt |"self loadoffImage: 'roundedPalette3.bmp'."pic24Bit _ GIFReadWriter formFromServerFile: 'updates/137roundedPalette3.bmp'.picNewBit _ Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.OriginalBounds _ picNewBit boundingBox.AllOffImage _ Form extent: OriginalBounds extent depth: 16.blt _ BitBlt current toForm: AllOffImage.blt sourceForm: picNewBit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.AllOffImage mapColor: Color transparent to: Color black.self image: AllOffImage.self invalidRect: bounds.self submorphsDo: [:button | button position: button position + (10@10)].(im _ submorphs at: 28) class == ImageMorph ifTrue: [	im position: im position + (2@0)].	"color picker""exercise it once"(bb _ self findButton: #keep:) position: bb position + (0@25).(bb _ self findButton: #toss:) position: bb position + (0@25).(bb _ self findButton: #undo:) position: bb position + (0@-25).(bb _ self findButton: #clear:) position: bb position + (0@-25).(bb _ self findButton: #undo:) position: bb position + (0@-69).(bb _ self findButton: #clear:) position: bb position + (0@-69).self submorphsDo: [:button | 	button class == AlignmentMorph ifTrue: [		button position: button position + (0@25)].	(button printString includesSubString: 'stamp:') ifTrue: [		button position: button position + (0@25)]].(bb _ self findButton: #prevStamp:) position: bb position + (0@25).(bb _ self findButton: #nextStamp:) position: bb position + (0@25).bb _ self findButton: #keep:.newImage _ bb pressedImage copy: (0@4 corner: (bb pressedImage boundingBox extent)).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (4@1).pp _ (bb _ self findButton: #toss:) pressedImage.newImage _ pp copy: (0@4 corner: (bb pressedImage extent - (3@0))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@1).pp _ (bb _ self findButton: #undo:) pressedImage.newImage _ pp copy: (0@0 corner: (bb pressedImage extent - (3@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pp _ (bb _ self findButton: #clear:) pressedImage.newImage _ pp copy: (0@0 corner: (bb pressedImage extent - (0@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pic24Bit _ GIFReadWriter formFromServerFile: 'updates/137pencil.bmp'.picNewBit _ Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.newImage _ picNewBit as8BitColorForm.newImage transparentColor: (Color r: 0 g: 0 b: 0).(bb _ self findButton: #erase:) pressedImage: newImage; onImage: newImage;	extent: newImage extent.bb position: bb position + (-11@-1).! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!loadOnImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadOnImage: 'NoSh_on.bmp'.		AllOnImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa mapColor: Color transparent to: Color black.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button onImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!loadPressedImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadPressedImage: 'NoSh_on.bmp'.		AllPressedImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa mapColor: Color transparent to: Color black.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button pressedImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!loadoffImage: fileName	"Read in and convert the background image for the paintBox.  Allbuttons off.  A .bmp 24-bit image."	"	Prototype loadoffImage: 'roundedPalette3.bmp'	"	| pic16Bit blt type getBounds |	type _ 'bmp'.  " gif or bmp  "	getBounds _ 'fromPic'.	"fromUser = draw out rect of paintbox on image"		"fromOB = just read in new bits, keep same size and place as last time."		"fromPic = picture is just the PaintBox, use its bounds"type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].	getBounds = 'fromPic' ifTrue: [OriginalBounds _ pic16Bit boundingBox].	].		"Use OriginalBounds as it was last time".type = 'bmp' ifTrue: [	pic16Bit _ (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].		"Use OriginalBounds as it was last time".	(getBounds = 'fromPic') ifTrue: [OriginalBounds _ pic16Bit boundingBox].	AllOffImage _ Form extent: OriginalBounds extent depth: 16.	].type = 'gif' ifTrue: [	AllOffImage _ ColorForm extent: OriginalBounds extent depth: 8.	AllOffImage colors: pic16Bit colors].	blt _ BitBlt current toForm: AllOffImage.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.type = 'bmp' ifTrue: [AllOffImage mapColor: Color transparent to: Color black].	self image: AllOffImage.	self invalidRect: bounds.	! !!Paragraph methodsFor: 'selecting' stamp: 'ar 5/28/2000 12:10'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box _ CaretForm boundingBox.	f _ Form extent: box extent depth: depth.	map _ (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb _ BitBlt current toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/28/2000 12:10'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt current toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: self viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r translateBy: self viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!Pen methodsFor: 'operations' stamp: 'ar 5/28/2000 12:10'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart form charStart rowStart scale wasDown bb pix |	scale _ sourceForm width.	wasDown _ penDown.	lineStart _ location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[form _ font characterFormAt: char.			charStart _ location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart _ location.				bb _ BitBlt current bitPeekerFromForm: form.				pix _ RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = 0						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: TextStyle defaultFont]"! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'ar 5/28/2000 12:12'!feltTip: width cellSize: cellSize	"Warning: This example potentially uses a large amount of memory--it creates a Form with cellSize squared bits for every Display pixel."	"In this example, all drawing is done into a large, monochrome Form and then scaled down onto the Display using smoothing. The larger the cell size, the more possible shades of gray can be generated, and the smoother the resulting line appears. A cell size of 8 yields 64 possible grays, while a cell size of 16 gives 256 levels, which is about the maximum number of grays that the human visual system can distinguish. The width parameter determines the maximum line thickness. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen feltTip: 2.7 cellSize: 8"	| tabletScale bitForm pen warp p srcR dstR nibSize startP r |	tabletScale _ self tabletScaleFactor.	bitForm _ Form extent: Display extent * cellSize depth: 1.	pen _ Pen newOnForm: bitForm.	pen color: Color black.	warp _ (WarpBlt current toForm: Display)		sourceForm: bitForm;		colorMap: (bitForm colormapIfNeededForDepth: Display depth);		cellSize: cellSize;		combinationRule: Form over.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * cellSize * tabletScale) rounded.			nibSize _ (Sensor tabletPressure * (cellSize * width)) rounded.		     nibSize > 0				ifTrue: [					pen squareNib: nibSize.					startP _ pen location.					pen goto: p.					r _ startP rect: pen location.					dstR _ (r origin // cellSize) corner: ((r corner + nibSize + (cellSize - 1)) // cellSize).					srcR _ (dstR origin * cellSize) corner: (dstR corner * cellSize).					warp copyQuad: srcR innerCorners toRect: dstR]				ifFalse: [					pen place: p]]].! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/28/2000 12:10'!buildImage     "(PlayingCard the: 12 of: #hearts) cardForm display"	"World addMorph: (ImageMorph new image: (PlayingCard the: 12 of: #hearts) cardForm)"	"PlayingCard test"	| blt numForm suitForm spot face ace sloc colorMap fillColor |		"Set up blt to copy in color for 1-bit forms"	blt _ BitBlt current toForm: cardForm.	fillColor _ self color.	colorMap _ (((Array with: Color white with: fillColor)				collect: [:c | c pixelWordForDepth: cardForm depth])					 as: Bitmap).	blt copy: cardForm boundingBox from: 0@0 in: self blankCard.  "Start with a blank card image"	numForm _ NumberForms at: cardNo.  "Put number in topLeft"	blt copyForm: numForm to: NumberLoc rule: Form over colorMap: colorMap.	suitForm _ SuitForms at: suitNo*3-2.   "Put small suit just below number"	sloc _ SuitLoc.	cardNo > 10 ifTrue:		[suitForm _ SuitForms at: suitNo*3-1.   "Smaller for face cards"		sloc _ SuitLoc - (1@0)].	blt copyForm: suitForm to: sloc rule: Form over colorMap: colorMap.	cardNo <= 10	ifTrue:		["Copy top-half spots to the number cards"		spot _ SuitForms at: suitNo*3.   "Large suit spots"		(TopSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]]	ifFalse:		["Copy top half of face cards"		face _ FaceForms at: suitNo-1*3 + 14-cardNo.		blt colorMap: self faceColorMap;			copy: (FaceLoc extent: face extent) from: 0@0 in: face].	"Now copy top half to bottom"	self copyTopToBottomHalf.	cardNo <= 10 ifTrue:		["Copy middle spots to the number cards"		(MidSpotLocs at: cardNo) do:			[:loc | blt copyForm: spot to: loc rule: Form over colorMap: colorMap]].	(cardNo = 1 and: [suitNo = 4]) ifTrue:		["Special treatment for the ace of spades"		ace _ FaceForms at: 13.		blt colorMap: self faceColorMap;			copy: (ASpadesLoc extent: ace extent) from: 0@0 in: ace]	! !!PlayingCard methodsFor: 'all' stamp: 'ar 5/28/2000 12:13'!copyTopToBottomHalf	"The bottom half is a 180-degree rotation of the top half (except for 7)"	| topHalf corners |	topHalf _ 0@0 corner: cardForm width@(cardForm height+1//2).	corners _ topHalf corners.	(WarpBlt current toForm: cardForm)		sourceForm: cardForm;		combinationRule: 3;		copyQuad: ((3 to: 6) collect: [:i | corners atWrap: i])		toRect: (CardSize - topHalf extent corner: CardSize).	! !!PolygonMorph methodsFor: 'private' stamp: 'ar 5/28/2000 12:10'!computeArrowFormAt: endPoint from: priorPoint	"Compute a triangle oriented along the line from priorPoint to endPoint.	Then draw those lines in a form and return that form, with appropriate offset"	| d v p1 pts box arrowForm bb origin angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	box _ ((pts first rect: pts last) encompass: (pts at: 2)) expandBy: 1.	arrowForm _ Form extent: box extent asIntegerPoint.	bb _ (BitBlt current toForm: arrowForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ box topLeft.	p1 _ pts last - origin.	pts do: [:p | bb drawFrom: p1 to: p-origin.  p1 _ p-origin].	arrowForm convexShapeFill: Color black.	^ arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'ar 5/28/2000 12:10'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ Form extent: bounds extent+2.	"Draw the border..."	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	"Fill it in..."	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ filledForm anyShapeFill].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue:		["If border is stored as a form, then erase any overlap now."		filledForm copy: self borderForm boundingBox from: self borderForm			to: 1@1 rule: Form erase].	^ filledForm! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 5/28/2000 12:11'!nextWordsInto: aBitmap 	| blt pos mainX mainY frontX frontY little source |	"Fill the word based buffer from my collection.  Stored on stream as Little Endian.  Optimized for speed."	(collection class isBytes) ifTrue:		["1 to: aBitmap size do: [:index | aBitmap at: index put: (self nextNumber: 4)]."		little _ Smalltalk endianness == #little.		collection basicSize \\ 4 = 0 			ifTrue: [source _ collection.  					pos _ self position.					self skip: aBitmap size * aBitmap bytesPerElement "1, 2, or 4"]			ifFalse: [source _ self next: aBitmap size * aBitmap bytesPerElement.						"forced to copy it into a buffer"					pos _ 0].		mainX _ pos \\ 4.   mainY _ pos // 4.	"two Blts required if not word aligned"		frontX _ 0.  frontY _ mainY + 1.		blt _ (BitBlt current toForm: (Form new hackBits: aBitmap)) 					sourceForm: (Form new hackBits: source).		blt combinationRule: Form over.  "store"		blt sourceX: mainX; sourceY: mainY; height: aBitmap basicSize; width: 4-mainX.		blt destX: 0; destY: 0.		little ifTrue: [blt sourceX: 0; destX: mainX].	"just happens to be this way!!"		blt copyBits.		mainX = 0 ifTrue: [^ aBitmap].		"second piece when not word aligned"		blt sourceX: frontX; sourceY: frontY; height: aBitmap size; width: mainX.		blt destX: 4-mainX; destY: 0.		little ifTrue: [blt sourceX: 4-mainX; destX: frontX].	"draw picture to understand this"		blt copyBits.		^ aBitmap].	^ self next: aBitmap size into: aBitmap startingAt: 1.! !!Project methodsFor: 'menu messages' stamp: 'ar 5/28/2000 12:13'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt current toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 5/28/2000 12:13'!drawOn: aCanvas	project ifNil: [^ super drawOn: aCanvas].	project isInMemory ifFalse: [^ super drawOn: aCanvas].	"use lastProjectThumbnail"	project class == DiskProxy ifTrue: [^ super drawOn: aCanvas].	"still on server"	project thumbnail ifNil: [		image fill: (0@0 extent: image extent) rule: Form over 			fillColor: project defaultBackgroundColor.		^ super drawOn: aCanvas].	project thumbnail ~~ lastProjectThumbnail ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt current toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	super drawOn: aCanvas.! !!ScreeningMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 12:11'!fullDrawOn: aCanvas	| mergeForm |	submorphs size = 0 ifTrue: [^ super fullDrawOn: aCanvas].	(submorphs size = 1 or: [displayMode == #showScreenOnly]) ifTrue:		[^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showSourceOnly ifTrue:		[^ aCanvas fullDrawMorph: self sourceMorph].	displayMode == #showScreenOverSource ifTrue:		[aCanvas fullDrawMorph: self sourceMorph.		^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showScreened ifTrue:		[aCanvas fullDrawMorph: self screenMorph.		self flag: #fixCanvas. "There should be a more general way than this"		mergeForm _ self sourceMorph imageFormForRectangle: self screenMorph bounds.		(BitBlt current toForm: mergeForm) copyForm: self screenForm to: 0@0 rule: Form and			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas paintImage: mergeForm at: self screenMorph position]! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 5/28/2000 12:11'!brushAlphaFromGray	"Get currentNib again, (a gray-scale Form) and transform it into an alpha brush.  3/15/97 tk"	| d alphaMap this alpha colorMaker newBox smallNib |	currentNib _ palette getNib.	newBox _ currentNib rectangleEnclosingPixelsNotOfColor: Color transparent.	"minimum size"	smallNib _ Form extent: newBox extent depth: currentNib depth.	smallNib copyBits: newBox from: currentNib at: 0@0 		clippingBox: smallNib boundingBox rule: Form over fillColor: nil."smallNib display.  newBox printString displayAt: 0@50."	d _ currentNib depth.	"usually 8"	alphaMap _ (Color cachedColormapFrom: d to: 32) copy.	"force a map to be there"	1 to: alphaMap size do: [:pixVal |		this _ Color colorFromPixelValue: pixVal-1 depth: d.		alpha _ 1.0 - this brightness.	"based on brightness"		"alpha _ alpha * 0.14 - 0.01."	"Adjust sensitivity for buffer depth"		"alpha _ alpha raisedTo: 2.0."	"Adjust sensitivity for buffer depth"		alphaMap at: pixVal 				put: ((currentColor alpha: alpha) pixelWordForDepth: 32)].		brush _ Form extent: smallNib extent depth: 32.	"brush offset: smallNib offset."	colorMaker _ BitBlt current toForm: brush.	colorMaker sourceForm: smallNib; colorMap: alphaMap.	colorMaker sourceOrigin: 0@0; destOrigin: 0@0; combinationRule: Form over;		width: brush width; height: brush height; copyBits.	^ brush	! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 5/28/2000 12:13'!transBrushPrep	"Prepare to paint with a transparent brush at twice the resolution.  Do the work in 32-bits.  See BitBlt.alphaBlendDemo8 for details.  "	| buffSize scale cm1 cm2 |	currentColor class == Bitmap ifTrue: [currentColor _ palette getColor]. "do not force white"	brush _ self brushAlphaFromGray.	"Get currentNib again, 		(a gray-scale Form) and transform it into an alpha brush"	scale _ 3.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	buffSize _ 100.	buff _ Form extent: (buffSize * scale) asPoint + brush extent depth: 32.  "Travelling 32-bit buffer"	picToBuff _ (WarpBlt current toForm: buff)  "from Picture to buff - magnify by 2"		sourceForm: paintingForm;		combinationRule: Form over.	cm1 _ (Color cachedColormapFrom: paintingForm depth to: 32) copy.	cm1 ifNotNil: [		"map off-the-edge pixels to the background color, so blend will look right at edge"		cm1 at: 1 put: (self world color pixelValueForDepth: 32)].	picToBuff colorMap: cm1.	brushToBuff _ (BitBlt current toForm: buff)  "from brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	"use buffToPic instead of paintingFormPen"	buffToPic _ (WarpBlt current toForm: paintingForm)  "from buff to Picture - shrink by 2"		sourceForm: buff;		cellSize: scale;    "...and use smoothing"		combinationRule: Form over.	cm2 _ (Color cachedColormapFrom: 32 to: paintingForm depth) copy.	cm2 ifNotNil: [		"remap background color to transparent"		cm2 at: (self world color indexInMap: cm2) put: 0].	buffToPic colorMap: cm2.	buffToBuff _ BitBlt current toForm: buff.  "for slewing the buffer"! !!SketchMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 12:13'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ 0.0 - self setupAngle]			"let TransformationMorph do directional image turn, we subtract green arrow angle"		ifFalse: [adjustedAngle _ 0.0].	"leftRight, upDown, none"	((adjustedAngle = 0.0) and: [1.0@1.0 = scalePoint])		ifTrue: [			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: ["do the actual rotation!!"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt current				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: 		[rotationDegrees < -90.0]]) ifTrue: [			"headed down; use flipped"			rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ offsetWhenRotated + 				((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).			^ self].! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:11'!characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm 	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii destPoint bb leftX rightX sourceRect |	destPoint _ aPoint.	bb _ BitBlt current toForm: Display.	anInterval do: 		[:i | 		ascii _ (sourceString at: i) asciiValue.		(ascii < minAscii or: [ascii > maxAscii])			ifTrue: [ascii _ maxAscii].		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		sourceRect _ leftX@0 extent: (rightX-leftX) @ self height.		bb copyFrom: sourceRect in: glyphs to: destPoint.		destPoint _ destPoint + ((rightX-leftX)@0)].	^ destPoint! !!StrikeFont methodsFor: 'emphasis' stamp: 'ar 5/28/2000 12:11'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt current toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].! !!WarpBlt methodsFor: 'primitives' stamp: 'ar 5/28/2000 12:11'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 147>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt current bitPeekerFromForm: sourceForm.	poker _ BitBlt current bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !