'From Squeak 2.0 of May 22, 1998 on 17 June 1998 at 7:51:19 pm'!!Integer methodsFor: 'arithmetic' stamp: 'LC 6/18/1998 09:33'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger		ifTrue: [quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"								neg: self negative ~~ aNumber negative.				(quoRem at: 2) = 0					ifTrue: [^(quoRem at: 1) normalize]					ifFalse: [^(Fraction numerator: self denominator: aNumber) reduced]]		ifFalse: [^ (aNumber adaptInteger: self) / aNumber adaptToInteger]! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'private' stamp: 'LC 6/18/1998 10:07'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	arg = 0 ifTrue: [^ self error: 'division by 0'].	"*****We've added this line*****"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0 ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l				put: lo - (lo // 256 * 256) "sign-tolerant form of (lo bitAnd: 255)".			a _ (lo // 256) - (hi bitShift: -4).			l _ l + 1].		a < 0 ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem! !