'From Squeak3.8alpha of 8 September 2004 [latest update: #6297] on 22 October 2004 at 12:04:32 pm'!"Change Set:		shiffmanTimeout-brpDate:				21 October 2004Author:			Brent PinkneyImplementation of #valueWithin:onTimeout:.This changeset reimplements Allan Schiffman's timeout mechanism for Squeak 3.8.Usage:	[ 50000 factorial ] valueWithin: 1 second onTimeout: [ 666 ].  ""Answers 666""	[ 3 + 4 ] valueWithin: 1 second onTimeout: [ 666 ].  ""Answers 7""Allan's implementation has been reworked to satisfy ANSI exception handling and the Duration class in the Chronology package.Included in this changest are three new SUnit tests.	ExceptionTests >> #testNoTimeout	ExceptionTests >> #testTimeout	ExceptionTests >> #testTimeoutWithZeroDurationThis changest makes some minor changes to ExceptionTester to accomodate #testTimeout."!Object subclass: #ExceptionTester	instanceVariableNames: 'log suiteLog iterationsBeforeTimeout '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Tests'!Notification subclass: #TimedOut	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!TimedOut commentStamp: 'brp 10/21/2004 17:47' prior: 0!I am signalled by #duration:timeoutDo: if the receiving block takes too long to execute.I am signalled by a watchdog process spawned by #duration:timeoutDo: and caught in the same method. I am not intended to be used elsewhere.!!BlockClosure methodsFor: 'evaluating' stamp: 'brp 10/22/2004 11:57'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog done result |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		done ifFalse: [ theProcess signal: TimedOut ] 	] newProcess.	"watchdog needs to run at high priority to do its job"	watchdog priority: Processor timingPriority.	"catch the timeout signal"	^ [	done := false.		watchdog resume.				"start up the watchdog"		result := self value.				"evaluate the receiver"		done := true.						"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"		result ]			on: TimedOut do: [ :e | timeoutBlock value ].! !!BlockContext methodsFor: 'evaluating' stamp: 'brp 10/22/2004 11:57'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog done result |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		done ifFalse: [ theProcess signal: TimedOut ] 	] newProcess.	"watchdog needs to run at high priority to do its job"	watchdog priority: Processor timingPriority.	"catch the timeout signal"	^ [	done := false.		watchdog resume.				"start up the watchdog"		result := self value.				"evaluate the receiver"		done := true.						"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"		result ]			on: TimedOut do: [ :e | timeoutBlock value ].! !!Delay methodsFor: 'public' stamp: 'brp 10/21/2004 16:05'!delaySemaphore	^ delaySemaphore! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:54'!basicTestSelectors	^ #(#simpleEnsureTest #simpleEnsureTestWithNotification #simpleEnsureTestWithUparrow #simpleEnsureTestWithError #signalFromHandlerActionTest #resumableFallOffTheEndHandler #nonResumableFallOffTheEndHandler #doubleResumeTest #simpleTimeoutWithZeroDurationTest #simpleTimeoutTest simpleNoTimeoutTest)! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:15'!iterationsBeforeTimeout	^ iterationsBeforeTimeout! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:16'!iterationsBeforeTimeout: anInteger	iterationsBeforeTimeout := anInteger! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleNoTimeoutTest	[ self doSomething ]		valueWithin: 1 day onTimeout:			[ self doSomethingElse ].	! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleTimeoutTest	| n |	[1 to: 1000000 do: [ :i | n := i. self doSomething ] ]		valueWithin: 50 milliSeconds onTimeout:			[ self iterationsBeforeTimeout: n.			self doSomethingElse ]! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleTimeoutWithZeroDurationTest	[ self doSomething ]		valueWithin: 0 seconds onTimeout:			[ self doSomethingElse ].	! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 16:54'!simpleNoTimeoutTestResults	^OrderedCollection new		add: self doSomethingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 17:44'!simpleTimeoutTestResults	| things |	things := OrderedCollection new: self iterationsBeforeTimeout.	self iterationsBeforeTimeout timesRepeat: [ things add: self  doSomethingString ].	things add: self doSomethingElseString.	^ things! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 16:52'!simpleTimeoutWithZeroDurationTestResults	^OrderedCollection new		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'testing' stamp: 'brp 10/21/2004 17:40'!runTest: aSelector	| actualResult expectedResult |	[ self 		logTest: aSelector;		clearLog;		perform: aSelector ]			on: MyTestError do: 				[ :ex | self log: 'Unhandled Exception'.					ex return: nil ].	actualResult	:= self log.	expectedResult := self perform: (aSelector, #Results) asSymbol.	actualResult = expectedResult		ifTrue: [self logTestResult: 'succeeded']		ifFalse: [self logTestResult: 'failed' ].! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:42'!testNoTimeout	self assertSuccess: (ExceptionTester new runTest: #simpleNoTimeoutTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:42'!testTimeout	self assertSuccess: (ExceptionTester new runTest: #simpleTimeoutTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:41'!testTimeoutWithZeroDuration	self assertSuccess: (ExceptionTester new runTest: #simpleTimeoutWithZeroDurationTest ) ! !Object subclass: #ExceptionTester	instanceVariableNames: 'log suiteLog iterationsBeforeTimeout'	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Tests'!!Delay reorganize!('delaying' isExpired unschedule wait)('private' activate adjustResumptionTimeOldBase:newBase: resumptionTime schedule setDelay:forSemaphore: signalWaitingProcess)('public' delaySemaphore)!