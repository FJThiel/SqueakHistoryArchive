'From Squeak2.9alpha of 16 June 2000 [latest update: #2800] on 3 October 2000 at 10:57:58 pm'!"Change Set:		paneResize-tkDate:			3 October 2000Author:			Ted KaehlerFix annoying bug that kept a pane resizing in a window after you let up on the mouse button.  Caused by race contition -- if mouse button went up just before entering Rectangle>>newRectFrom:, it resizes with the button up.  newRectFrom: is too general because it tries to handle both mouseUp and mouseDown dragging.And fix a bug in how code versions are displayed in Active Essays."!!Rectangle methodsFor: 'transforming' stamp: 'tk 10/3/2000 22:43'!newRectButtonPressedDo: newRectBlock 	"Track the outline of a new rectangle until mouse button changes.  newFrameBlock produces each new rectangle from the previous.  Only tracks while mouse is down."	| rect newRect buttonNow |	buttonNow _ Sensor anyButtonPressed.	rect _ self.	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	[buttonNow] whileTrue: 		[Processor yield.		buttonNow _ Sensor anyButtonPressed.		newRect _ newRectBlock value: rect.		newRect = rect ifFalse:			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.			rect _ newRect]].	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	^ rect! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'tk 10/3/2000 22:45'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds adjoiningPanes limit |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) ifTrue: [^self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ growingPane bounds				  newRectButtonPressedDo:					[:f | growingPane bounds withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: newBounds]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!Time class methodsFor: 'general inquiries' stamp: 'tk 10/3/2000 13:53'!namesForTimes: arrayOfSeconds	| simpleEnglish prev final prevPair myPair |	"Return English descriptions of the times in the array.  They are each seconds since 1901.  If two names are the same, append the date and time to distinguish them."	simpleEnglish _ arrayOfSeconds collect: [:secsAgo |		self humanWordsForSecondsAgo: self totalSeconds - secsAgo].	prev _ ''.	final _ simpleEnglish copy.	simpleEnglish withIndexDo: [:eng :ind | 		eng = prev ifFalse: [eng]			ifTrue: ["both say 'a month ago'"				prevPair _ self dateAndTimeFromSeconds: 						(arrayOfSeconds at: ind-1).				myPair _ self dateAndTimeFromSeconds: 						(arrayOfSeconds at: ind).				(final at: ind-1) = prev ifTrue: ["only has 'a month ago'"					final at: ind-1 put: 							(final at: ind-1), ', ', prevPair first mmddyyyy].				final at: ind put: 							(final at: ind), ', ', myPair first mmddyyyy.				prevPair first = myPair first 					ifTrue: [						(final at: ind-1) last == $m ifFalse: ["date but no time"							final at: ind-1 put: 								(final at: ind-1), ', ', prevPair second printMinutes].						final at: ind put: 							(final at: ind), ', ', myPair second printMinutes]].		prev _ eng].	^ final! !