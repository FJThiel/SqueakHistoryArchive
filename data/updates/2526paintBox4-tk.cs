'From Squeak2.9alpha of 16 June 2000 [latest update: #2525] on 22 August 2000 at 11:56:30 pm'!"Change Set:		paintBox4-tkDate:			22 August 2000Author:			Ted KaehlerChanges to the PaintBox:When you start painting, the PaintBox will do its best to pick a position fully within the current world.  All flop-out parts will appear in bounds.  (PaintBox may sometimes appear on top of the painting.  If you accidentally make that happen, tell me how.)Both the 'shapes' and 'stamps' drawers can show at once, as Kim asked.ColorPicker and PaintBox both come to the front when used.  (Could go behind painting before)The PaintBox itself has a new item on its menu (via the red handle).  'Grab stamp from screen' allows you to grab any section of the screen and make it a stamp.  Very useful for combining two images into one sketch.  A normal stamp can't do this because it leaves pickup mode when it leaves the paint area.  When you want to make a stamp from within the picture, use the normal stamp icon on the blank stamp."!!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 8/22/2000 11:52'!submorphNamed: aName ifNone: aBlock	"Find the first submorph with this name, or a button with an action selector of that name"	| sub |	self submorphs do: [:p | p knownName = aName ifTrue: [^p]].	self submorphs do: [:button |		(button respondsTo: #actionSelector) ifTrue: [			button actionSelector == aName ifTrue: [^ button]].		(button respondsTo: #arguments) 			ifTrue: [(button arguments at: 2 ifAbsent: [nil]) == aName ifTrue: [^ button]].		(button isKindOf: AlignmentMorph) ifTrue: [			(sub _ button submorphNamed: aName ifNone: [nil]) ifNotNil: [^ sub]].		].	^ aBlock value! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/2000 11:55'!createButtons	"Create buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button nib |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: pickup: "pickup: pickup: pickup:" stamp: "stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |	(self submorphNamed: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		button actionSelector: #tool:action:cursor:evt:; arguments: (Array with: button with: sel with: nil).		button actWhen: #buttonUp; target: self.		]].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |	(self submorphNamed: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		nib _ Form dotOfSize: (#(1 2 3 6 11 26) at: ind).		button actionSelector: #brush:action:nib:evt:; 				arguments: (Array with: button with: sel with: nib).		button actWhen: #buttonUp; target: self.		]]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/2000 11:55'!init3	"Just a record of how we loaded in the latest paintbox button images"| bb rect lay pic16Bit aa blt on thin |self loadoffImage: 'etoy_default.gif'.self allMorphsDo: [:button |	(button isKindOf: ThreePhaseButtonMorph) 		ifTrue: [button offImage: nil]		ifFalse: [button position: button position + (100@0)]].(bb _ self submorphNamed: #keep:) position: bb position + (100@0).(bb _ self submorphNamed: #toss:) position: bb position + (100@0).(bb _ self submorphNamed: #undo:) position: bb position + (100@0)."Transparent is (Color r: 1.0 g: 0 b: 1.0)"self moveButtons.self loadOnImage: 'etoy_in.gif'.AllOnImage _ nil.	'save space'.	self loadPressedImage: 'etoy_in.gif'.AllPressedImage _ nil.	'save space'.self loadCursors."position the stamp buttons"stampHolder stampButtons owner last delete.stampHolder pickupButtons last delete.stampHolder stampButtons: (stampHolder stampButtons copyFrom: 1 to: 3).stampHolder pickupButtons: (stampHolder pickupButtons copyFrom: 1 to: 3)."| rect |"stampHolder pickupButtons do: [:button |		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser.		button bounds: rect.	"image is nil"		]."| rect lay |"stampHolder clear.stampHolder stampButtons do: [:button |		button offImage: nil; pressedImage: nil.		lay _ button owner.		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser.		button image: (Form fromDisplay: (rect insetBy: 2)).		lay borderWidth: 2.		lay bounds: rect.	"image is nil"		]."| pic16Bit blt aa on |"	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: 'etoy_in.gif'.	aa _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	"Collect all the images for the buttons in the on state"	stampHolder pickupButtons do: [:button |			on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button image: on; pressedImage: on; offImage: nil.			].	self invalidRect: bounds.((self submorphNamed: #erase:) arguments at: 3) offset: (12@35).((self submorphNamed: #eyedropper:) arguments at: 3) offset: (0@0).((self submorphNamed: #fill:) arguments at: 3) offset: (10@44).((self submorphNamed: #paint:) arguments at: 3) offset: (3@3). "unused"((self submorphNamed: #rect:) arguments at: 3) offset: (6@17).((self submorphNamed: #ellipse:) arguments at: 3) offset: (5@4).((self submorphNamed: #polygon:) arguments at: 3) offset: (5@4).((self submorphNamed: #line:) arguments at: 3) offset: (5@17).((self submorphNamed: #star:) arguments at: 3) offset: (2@5).thumbnail delete.thumbnail _ nil.(submorphs select: [:e | e class == RectangleMorph]) first bounds: 	Rectangle fromUser.(submorphs select: [:e | e class == RectangleMorph]) first borderWidth: 1; borderColor: Color black."| thin |"	submorphs do: [:ss | ss class == ImageMorph ifTrue: [thin _ ss "first"]].colorMemoryThin _ thin.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/2000 11:56'!init4	"Just a record of how Ted loaded in the paintbox button images, Feb 98"| bb im pp newImage pic24Bit picNewBit blt |"self loadoffImage: 'roundedPalette3.bmp'."pic24Bit _ GIFReadWriter formFromServerFile: 'updates/137roundedPalette3.bmp'.picNewBit _ Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.OriginalBounds _ picNewBit boundingBox.AllOffImage _ Form extent: OriginalBounds extent depth: 16.blt _ BitBlt current toForm: AllOffImage.blt sourceForm: picNewBit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.AllOffImage mapColor: Color transparent to: Color black.self image: AllOffImage.self invalidRect: bounds.self submorphsDo: [:button | button position: button position + (10@10)].(im _ submorphs at: 28) class == ImageMorph ifTrue: [	im position: im position + (2@0)].	"color picker""exercise it once"(bb _ self submorphNamed: #keep:) position: bb position + (0@25).(bb _ self submorphNamed: #toss:) position: bb position + (0@25).(bb _ self submorphNamed: #undo:) position: bb position + (0@-25).(bb _ self submorphNamed: #clear:) position: bb position + (0@-25).(bb _ self submorphNamed: #undo:) position: bb position + (0@-69).(bb _ self submorphNamed: #clear:) position: bb position + (0@-69).self submorphsDo: [:button | 	button class == AlignmentMorph ifTrue: [		button position: button position + (0@25)].	(button printString includesSubString: 'stamp:') ifTrue: [		button position: button position + (0@25)]].(bb _ self submorphNamed: #prevStamp:) position: bb position + (0@25).(bb _ self submorphNamed: #nextStamp:) position: bb position + (0@25).bb _ self submorphNamed: #keep:.newImage _ bb pressedImage copy: (0@4 corner: (bb pressedImage boundingBox extent)).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (4@1).pp _ (bb _ self submorphNamed: #toss:) pressedImage.newImage _ pp copy: (0@4 corner: (bb pressedImage extent - (3@0))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@1).pp _ (bb _ self submorphNamed: #undo:) pressedImage.newImage _ pp copy: (0@0 corner: (bb pressedImage extent - (3@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pp _ (bb _ self submorphNamed: #clear:) pressedImage.newImage _ pp copy: (0@0 corner: (bb pressedImage extent - (0@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pic24Bit _ GIFReadWriter formFromServerFile: 'updates/137pencil.bmp'.picNewBit _ Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.newImage _ picNewBit as8BitColorForm.newImage transparentColor: (Color r: 0 g: 0 b: 0).(bb _ self submorphNamed: #erase:) pressedImage: newImage; onImage: newImage;	extent: newImage extent.bb position: bb position + (-11@-1).! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/2000 11:56'!loadCursors	"Display the form containing the cursors.  Transparent is (Color r: 1.0 g: 0 b: 1.0).  Grab the forms one at a time, and they are stored away.	self loadCursors.	"| button transp cursor map |transp _ Color r: 1.0 g: 0 b: 1.0.map _ Color indexedColors copy.	"just in case"1 to: 256 do: [:ind | (map at: ind) = transp ifTrue: [			map at: ind put: Color transparent]].#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: ) do: [:sel |	PopUpMenu notify: 'Rectangle for ',sel.	cursor _ ColorForm fromUser.	cursor colors: map.	"share it"	button _ self submorphNamed: sel.	button arguments at: 3 put: cursor.	].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/2000 11:57'!moveButtons	"Move buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: "pickup: pickup: pickup: pickup:" "stamp: stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ self submorphNamed: sel.		button bounds: rect.	"image is nil"		].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ self submorphNamed: sel.		button bounds: rect.	"image is nil"		]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."""! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 8/22/2000 12:52'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"super addCustomMenuItems: aCustomMenu hand: aHandMorph."		"don't want the ones from ImageMorph"	aCustomMenu add: 'grab stamp from screen' action: #grabFromScreen:.! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 8/22/2000 11:57'!maxBounds	| rr |	"fullBounds if all flop-out parts of the paintBox were showing."	rr _ bounds merge: colorMemory bounds.	rr _ rr merge: (self submorphNamed: 'stamps') bounds.	rr _ rr origin corner: rr corner + (0@ (self submorphNamed: 'shapes') height 				+ 10 "what is showing of (self submorphNamed: #toggleShapes) height").	^ rr! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 8/22/2000 23:48'!offsetFromMaxBounds	"location of normal PaintBox within maxBounds."	^ self left - colorMemory left @ 0! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/22/2000 12:55'!grabFromScreen: evt	"Allow the user to grab a picture from the screen OUTSIDE THE PAINTING AREA and install it in a blank stamp.  To get a stamp in the painting area, click on the stamp tool in a blank stamp."	| stampButton form |	"scroll to blank stamp"	stampButton _ stampHolder stampButtons first.	[(stampHolder stampFormFor: stampButton) == nil] whileFalse: [stampHolder scroll: 1].	form _ Form fromUser.	tool state: #off.	tool _ stampHolder otherButtonFor: stampButton.	stampHolder stampForm: form for: tool.	"install it"	stampButton state: #on.	stampButton doButtonAction: evt.	evt hand showTemporaryCursor: (focusMorph getCursorFor: evt).! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/22/2000 11:57'!setAction: aSelector evt: evt	"Find this button and turn it on.  Does not work for stamps or pickups"	| button |	button _ self submorphNamed: aSelector. 	button ifNotNil: [		button state: #on.		button doButtonAction: evt].	"select it!!"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/22/2000 11:58'!showColor	"Display the current color in all brushes, both on and off."	| offIndex onIndex center |	currentColor ifNil: [^ self].	"colorPatch color: currentColor.	May delete later"	(brushes == nil or: [brushes first owner ~~ self]) ifTrue: [		brushes _ OrderedCollection new.		#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |			brushes addLast: (self submorphNamed: sel)]].	center _ (brushes at: 6) offImage extent // 2.	offIndex _ (brushes at: 6) offImage pixelValueAt: center.	onIndex _ (brushes at: 6) onImage pixelValueAt: center.	brushes do: [:bb |		bb offImage colors at: offIndex+1 put: currentColor.		bb offImage clearColormapCache.		bb onImage colors at: onIndex+1 put: currentColor.		bb onImage clearColormapCache.		bb invalidRect: bb bounds].	self invalidRect: (brushes first topLeft rect: brushes last bottomRight).! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/22/2000 11:31'!showColorPalette: evt	| pp myEvt |	self comeToFront.	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory.	"Be sure it gets a mouseEnter: and a mouseLeave:, even if mouse leaves on the next cycle." 	pp _ (colorMemory bounds insetBy: 1@1) pointNearestTo: evt cursorPoint.			"so it will be inside"	myEvt _ evt copy setCursorPoint: pp.	evt hand handleMouseOver: myEvt.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/22/2000 11:58'!stampCursorBeCursorFor: anAction	"User just chose a stamp.  Take that stamp picture and make it be the cursor for the tool named."	"self stampCursorBeCursorFor: #star:.	currentCursor offset: -9@-3.			Has side effect on the saved cursor."	(self submorphNamed: anAction) arguments at: 3 put: currentCursor.		"Already converted to 8 bits and in the right form"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/21/2000 16:06'!toggleShapes	| tab sh stamps |	"The sub panel that has the shape tools on it.  Rect, line..."	stamps _ self submorphNamed: 'stamps'.	tab _ self submorphNamed: 'shapeTab'.	(sh _ self submorphNamed: 'shapes') visible		ifTrue: [sh hide.  tab top: stamps bottom-1]		ifFalse: [sh comeToFront.  sh top: stamps bottom-9.  				sh show.  tab top: sh bottom - tab height + 10].	self layoutChanged.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/21/2000 15:57'!toggleStamps	| tab otherTab st shapes |	"The sub panel that has the stamps in it.  For saving and moving parts of an image."	shapes _ self submorphNamed: 'shapes'.	otherTab _ self submorphNamed: 'shapeTab'.	tab _ self submorphNamed: 'stampTab'.	(st _ self submorphNamed: 'stamps') visible		ifTrue: [st hide.  st bottom: self bottom.  tab top: self bottom-1.				shapes top: self bottom-9.				otherTab top: (shapes visible ifTrue: [shapes bottom - otherTab height + 10] 									ifFalse: [self bottom-1])]		ifFalse: [st top: self bottom-10.  st show.  tab top: st bottom-0.				shapes top: st bottom-9.				otherTab top: (shapes visible ifTrue: [shapes bottom - otherTab height + 10] 									ifFalse: [st bottom-0])].	self layoutChanged.! !!PaintBoxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 8/21/2000 12:52'!fixUpPrototype	"PaintBoxMorph fixUpPrototype"self error: 'who uses this?'.	Prototype eventHandler: nil! !!PaintBoxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 8/21/2000 12:58'!initialize	"PaintBoxMorph initialize"	Prototype eventHandler: nil.	Prototype focusMorph: nil.	Prototype stampHolder clear.  "clear stamps"	Prototype delete.  "break link to world, if any"	AllOnImage _ AllOffImage _ AllPressedImage _ nil.	OriginalBounds _ nil.! !!PaintBoxMorph class methodsFor: 'as yet unclassified' stamp: 'tk 8/22/2000 11:55'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb submorphNamed: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ button onImage getCanvas.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PasteUpMorph methodsFor: 'world state' stamp: 'tk 8/21/2000 15:36'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox refPoint aPalette |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	refPoint _ (aPalette _ self standardPalette)		ifNotNil:			[aPalette showNoPalette.			aPalette topRight + (0 @ 12)]		ifNil:			[self topRight].	newPaintBox _ PaintBoxMorph new.	newPaintBox position: (refPoint - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'tk 8/21/2000 14:54'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| aPaintBox newPaintBoxBounds worldBounds requiredWidth newOrigin aPosition aPal aTab paintBoxFullBounds |	(aTab _ self world paintingFlapTab) ifNotNil:		[aTab showFlap.		^ self initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: nil].	aPaintBox _ self world paintBox.	worldBounds _ self world bounds.	requiredWidth _ aPaintBox width.	aPosition _ (aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[boundsToUse topRight].	newOrigin _ ((aPosition x  + requiredWidth <= worldBounds right) or: [Preferences unlimitedPaintArea])			ifTrue:  "will fit to right of aPasteUpMorph"				[aPosition]			ifFalse:  "won't fit to right, try left"				[boundsToUse topLeft - (requiredWidth @ 0)].	paintBoxFullBounds _ aPaintBox maxBounds.	paintBoxFullBounds _ (newOrigin - aPaintBox offsetFromMaxBounds) extent: 					paintBoxFullBounds extent.	newPaintBoxBounds _ paintBoxFullBounds translatedToBeWithin: worldBounds.		self initializeFor: aSketchMorph inBounds: boundsToUse 		pasteUpMorph: aPasteUpMorph 		paintBoxPosition: newPaintBoxBounds origin + aPaintBox offsetFromMaxBounds.! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'tk 8/21/2000 12:59'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph initialize.	"forces Prototype to let go of extra things it might hold"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Symbol rehash! !!EToySystem class methodsFor: 'development support' stamp: 'tk 8/21/2000 12:59'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph initialize.	"forces Prototype to let go of extra things it might hold"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Symbol rehash.! !PaintBoxMorph class removeSelector: #flushPrototype!PaintBoxMorph initialize!PaintBoxMorph class removeSelector: #releaseTemporaryForms!PaintBoxMorph removeSelector: #findButton:!PaintBoxMorph removeSelector: #grabFromScreen!