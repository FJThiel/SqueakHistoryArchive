'From Squeak2.9alpha of 13 June 2000 [latest update: #2837] on 10 October 2000 at 2:18:48 am'!"Change Set:		MoreEventFixesDate:			10 October 2000Author:			Andreas RaabTons of fixes all over the place, mostly derived from Scott's and Alan's bug list. Not everything's working yet but the biggest issues have been addressed."!!HaloMorph methodsFor: 'events' stamp: 'ar 10/9/2000 21:13'!popUpFor: aMorph event: evt	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| tfm hand inTransfer anEvent |	self flag: #arNote.	self flag: #workAround. "We really need an event here to trigger drags etc. but too many senders still use the obsolete #addHalo so we'll make a less than educated guess if the event is nil."	evt isNil		ifTrue:[	hand _ aMorph world activeHand.				hand ifNil:[hand _ aMorph world primaryHand].				anEvent _ hand lastEvent]		 ifFalse:[hand _ evt hand.				anEvent _ evt].	self target: aMorph.	self flag: #workAround.	"Distinguish between putting up a new halo (e.g., from a click on aMorph) and transferring the halo. See the comment in HaloMorph>>transferHalo: for an explanation."	inTransfer _ hand halo notNil and:[hand halo hasProperty: #haloTransfer].	hand halo: self.	hand world addMorphFront: self.	positionOffset _ anEvent position - aMorph position.	self startStepping.	"wait for drags or ignore"	tfm _ (aMorph transformedFrom: nil) inverseTransformation.	self flag: #workAround.	inTransfer ifFalse:[		hand newMouseFocus: self. "Necessary or else we won't get #mouseMove..."		hand 			waitForClicksOrDrag: self 			event: (anEvent transformedBy: tfm)			selectors: { nil. nil. #startDragTarget:. }			threshold: 5.	].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/10/2000 02:04'!handleEvent: anEvent	| evt prevEvt |	anEvent isMorphicEvent 		ifTrue:[evt _ anEvent]		ifFalse:[			prevEvt _ lastEvent.			lastEvent _ anEvent.			evt _ anEvent asNewEventFrom: prevEvt].	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseFocus].ShowEvents == true ifTrue:[	evt printString displayAt: (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: 0@45.].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on non-move mouse events"		(self hasSubmorphs) ifTrue:[self dropMorphs: evt].		self sendEvent: evt focus: mouseFocus.	].	ShowEvents == true ifTrue:[mouseFocus printString displayAt: 0@15].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/9/2000 20:06'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event |	event _ DropEvent new setPosition: self position contents: aMorph hand: self.	owner processEvent: event.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	aMorph owner == self ifTrue:[aMorph delete].	self mouseOverHandler processMouseOver: anEvent.! !!MenuItemMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 02:05'!deleteIfPopUp: evt	"Recurse up for nested pop ups"	owner ifNotNil:[owner deleteIfPopUp: evt].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:38'!activateOwnerMenu: evt	"Activate our owner menu; e.g., pass control to it"	owner ifNil:[^false]. "not applicable"	(owner fullContainsPoint: evt position) ifFalse:[^false].	owner activate: evt.	^true! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:37'!activateSubmenu: evt	"Activate our submenu; e.g., pass control to it"	subMenu ifNil:[^false]. "not applicable"	(subMenu fullContainsPoint: evt position) ifFalse:[^false].	subMenu activate: evt.	self removeAlarm: #deselectTimeOut:.	^true! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:50'!deselectTimeOut: evt	"Deselect timout. Now really deselect"	owner selectedItem == self ifTrue:[owner selectItem: nil event: evt].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 02:06'!invokeWithEvent: evt	"Perform the action associated with the given menu item."	| selArgCount w |	self isEnabled ifFalse: [^ self].	target class == HandMorph ifTrue: [(self notObsolete) ifFalse: [^ self]].	owner ifNotNil:[selector == #toggleStayUp: ifFalse:[		self flag: #workAround. "The tile system invokes menus straightforwardly so the menu might not be in the world."		(w _ self world) ifNotNil:[			owner deleteIfPopUp: evt.			"Repair damage before invoking the action for better feedback"			w displayWorldSafely]]].	selector ifNil:[^self].	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		(selArgCount _ selector numArgs) = 0			ifTrue:				[target perform: selector]			ifFalse:				[selArgCount = arguments size					ifTrue: [target perform: selector withArguments: arguments]					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 00:26'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	evt hand newMouseFocus: owner. "Redirect to menu for valid transitions"	owner selectItem: self event: evt.! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 00:24'!mouseEnterDragging: evt	"The mouse entered the receiver. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."	evt hand mouseFocus == owner ifTrue:[owner selectItem: self event: evt]! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 00:25'!mouseLeaveDragging: evt	"The mouse left the receiver. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."	evt hand mouseFocus == owner ifFalse:[^self].	"If we have a submenu, make sure we've got some time to enter it before actually leaving the menu item"	subMenu == nil		ifTrue:[owner selectItem: nil event: evt]		ifFalse:[self addAlarm: #deselectTimeOut: with: evt after: 500].! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 00:32'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."	evt hand mouseFocus == owner ifFalse:[^self].	self deselect: evt.	self invokeWithEvent: evt.		! !!MenuItemMorph methodsFor: 'events' stamp: 'ar 10/10/2000 02:18'!receiveNewFocus: evt	"Obsolete. Left in for not getting errors during the update where this entire stuff is removed."	evt hand releaseKeyboardFocus.	self flag: #arNote. "Remove it"! !!MenuItemMorph methodsFor: 'selecting' stamp: 'ar 10/10/2000 01:39'!deselect: evt	self isSelected: false.	subMenu ifNotNil: [		owner ifNotNil:[owner activeSubmenu: nil].		self removeAlarm: #deselectTimeOut:].! !!MenuItemMorph methodsFor: 'meta actions' stamp: 'ar 10/10/2000 02:13'!wantsHaloFromClick	"Only if I'm not a lonely submenu"	^owner notNil and:[owner submorphs size > 1]! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 10/10/2000 02:00'!stayUp: aBoolean	stayUp _ aBoolean.! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/10/2000 00:54'!deleteIfPopUp: evt	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."	stayUp ifFalse: [self topRendererOrSelf delete].	(popUpOwner notNil) ifTrue: [		popUpOwner isSelected: false.		popUpOwner deleteIfPopUp: evt].	evt ifNotNil:[evt hand releaseMouseFocus: self].! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/10/2000 01:59'!justDroppedInto: aMorph event: anEvent	"This menu was grabbed and moved"	super justDroppedInto: aMorph event: anEvent.	stayUp ifFalse:[anEvent hand newMouseFocus: self]. "regain focus for pop ups"! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/10/2000 02:00'!popUpAt: aPoint forHand: hand in: aWorld	"Present this menu at the given point under control of the given hand."	self items isEmpty ifTrue: [^ self].	self positionAt: aPoint relativeTo: (selectedItem ifNil:[self items first]) inWorld: aWorld.	aWorld addMorphFront: self; startSteppingSubmorphsOf: self.	"Aquire focus for valid pop up behavior"	hand newMouseFocus: self.	self changed! !!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 01:57'!delete	activeSubMenu ifNotNil:[activeSubMenu delete].	^super delete! !!MenuMorph methodsFor: 'menu' stamp: 'ar 10/10/2000 01:22'!toggleStayUp: evt	"Toggle my 'stayUp' flag and adjust the menu item to reflect its new state."	self items do: [:item |		item selector = #toggleStayUp: ifTrue:			[self stayUp: stayUp not.				 stayUp				ifTrue: [item contents: 'dismiss this menu']				ifFalse: [item contents: 'keep this menu up']]].	evt hand releaseMouseFocus: self.	stayUp ifFalse: [self topRendererOrSelf delete].! !!MenuMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:35'!activate: evt	"Receiver should be activated; e.g., so that control passes correctly."	evt hand newMouseFocus: self.! !!MenuMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:52'!handleFocusEvent: evt	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."	self processEvent: evt.	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"	(evt isMouseOver or:[evt isMouse not]) ifTrue:[^self].	"What remains are mouse buttons and moves"	evt isMove ifFalse:[^self handleEvent: evt]. "handle clicks outside by regular means"	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."	selectedItem ifNotNil:[(selectedItem activateSubmenu: evt) ifTrue:[^self]].	"Note: The following does not traverse upwards but it's the best I can do for now"	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: evt) ifTrue:[^self]].! !!MenuMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:53'!mouseDown: evt	"Handle a mouse down event."	(stayUp or:[self fullContainsPoint: evt position]) 		ifFalse:[^self deleteIfPopUp: evt]. "click outside"	"Grab the menu and drag it to some other place"	evt hand grabMorph: self.! !!MenuMorph methodsFor: 'events' stamp: 'ar 10/10/2000 01:57'!mouseUp: evt	"Handle a mouse up event.	Note: This might be sent from a modal shell."	(self fullContainsPoint: evt position) ifFalse:[		"Mouse up outside. Release eventual focus and delete if pop up."		evt hand releaseMouseFocus: self.		^self deleteIfPopUp: evt].	stayUp ifFalse:[		"Still in pop-up transition; keep focus"		evt hand newMouseFocus: self].! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'ar 10/9/2000 21:16'!mouseDownPriority	^100! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 01:20'!dispatchDefault: anEvent with: aMorph	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."	| localEvt index child morphs inside |	"See if we're fully outside aMorphs bounds"	(aMorph fullBounds containsPoint: anEvent position) ifFalse:[^#rejected]. "outside"	"Traverse children"	index _ 1.	morphs _ aMorph submorphs.	inside _ false.	[index <= morphs size] whileTrue:[		child _ morphs at: index.		localEvt _ anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Not rejected. The event was in some submorph of the receiver"			inside _ true.			localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].			index _ morphs size. "break"		].		index _ index + 1.	].	"Check for being inside the receiver"	inside ifFalse:[inside _ aMorph containsPoint: anEvent position event: anEvent].	inside ifTrue:[^aMorph handleEvent: anEvent].	^#rejected! !!MouseClickState methodsFor: 'initialize' stamp: 'ar 10/9/2000 19:08'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt transformedBy: (clickClient transformedFrom: aHand owner).	isDrag _ (localEvt cursorPoint - firstClickDown cursorPoint) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag if requested"			clickState _ #firstClickTimedOut.			dragSelector ifNil:[				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown]].			^true].		localEvt isMouseUp ifTrue:[			"If timedOut or the client's not interested in dbl clicks get outta here"			(timedOut or:[dblClickSelector isNil]) ifTrue:[				aHand resetClickState.				clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp _ evt copy.			clickState _ #firstClickUp.			^false].		isDrag ifTrue:["drag start"			aHand resetClickState.			dragSelector == nil "If no drag selector send #click instead"				ifTrue:[clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown]]				ifFalse:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			^true].		isDrag ifTrue:["drag start"			aHand resetClickState.			dragSelector ifNotNil:[clickClient perform: dragSelector with: localEvt].			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			aHand resetClickState.			clickSelector ifNotNil:[clickClient perform: clickSelector with: firstClickDown].			"Note: Using aHand handleEvent here (rather than clickClient handleMouseUp:) to be consistent with a timeout before firstClickUp in which case aHand would process the up event."			aHand handleEvent: firstClickUp.			^true].		localEvt isMouseDown ifTrue:["double click"			aHand resetClickState.			dblClickSelector ifNotNil:[clickClient perform: dblClickSelector with: firstClickDown].			^false]].	^true! !!MouseOverHandler methodsFor: 'event handling' stamp: 'ar 10/10/2000 02:08'!processMouseOver: anEvent	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus |	hand _ anEvent hand.	leftMorphs _ mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs _ WriteStream on: (Array new: leftMorphs size).	enteredMorphs _ WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs size = 0 and:[enteredMorphs position = 0]) 		ifTrue:[^leftMorphs _ enteredMorphs _ overMorphs _ nil].	focus _ hand mouseFocus.	"Send #mouseLeave as appropriate"	leftMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[localEvt _ anEvent transformedBy: (m transformedFrom: hand).					m handleMouseLeave: localEvt]			ifFalse:[overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	enteredMorphs _ enteredMorphs contents.	enteredMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[	localEvt _ anEvent transformedBy: (m transformedFrom: hand).					m handleMouseEnter: localEvt]].	"And remember the over list"	mouseOverMorphs _ overMorphs contents.	leftMorphs _ enteredMorphs _ overMorphs _ nil.! !!NewMorphicEvent methodsFor: 'accessing' stamp: 'ar 10/10/2000 01:19'!wasHandled	"Return true if this event was handled. May be ignored for some types of events."	^false! !!NewMorphicEvent methodsFor: 'accessing' stamp: 'ar 10/10/2000 01:20'!wasHandled: aBool	"Determine if this event was handled. May be ignored for some types of events."! !!NewMorphicEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!copyHandlerState: anEvent	"Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."! !!NewMorphicEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"! !!DropEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:19'!copyHandlerState: anEvent	"Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."	wasHandled _ anEvent wasHandled.! !!DropEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	wasHandled _ false.! !ScrollPane removeSelector: #handlesMouseOverDragging:!ScrollPane removeSelector: #mouseEnterDragging:!ScrollPane removeSelector: #mouseLeaveDragging:!MenuMorph removeSelector: #aboutToBeGrabbedBy:!MenuMorph removeSelector: #addModalShell!MenuMorph removeSelector: #handlesMouseOver:!MenuMorph removeSelector: #handlesMouseOverDragging:!MenuMorph removeSelector: #invokeItem:event:!MenuMorph removeSelector: #mouseEnter:!MenuMorph removeSelector: #mouseEnterDragging:!MenuMorph removeSelector: #mouseLeave:!MenuMorph removeSelector: #mouseLeaveDragging:!MenuMorph removeSelector: #noticeMouseEntered:!MenuMorph removeSelector: #noticeMouseLeft:event:!MenuMorph removeSelector: #receiveNewFocus:!MenuItemMorph removeSelector: #handleMouseUp:!MenuItemMorph removeSelector: #noticeMouseEntered:!MenuItemMorph removeSelector: #noticeMouseLeft:event:!HandMorph removeSelector: #newProcessEvents!