'From Squeak3.1alpha of 4 February 2001 [latest update: #3820] on 9 March 2001 at 12:57:16 am'!"Change Set:		ClassBuilderFixDate:			5 March 2001Author:			Andreas RaabFixes a problem with the way obsolete subclasses were handled."!!ClassBuilder methodsFor: 'class definition' stamp: 'ar 3/5/2001 11:53'!reshapeClass: aClass to: templateClass super: newSuper	"Reshape the given class to the new super class.	If templateClass is not nil then it defines the shape of the new class"	| fmt newClass newMeta newSuperMeta oldMeta instVars oldClass |	templateClass == nil		ifTrue:[oldClass _ aClass]		ifFalse:[oldClass _ templateClass].	aClass becomeUncompact.	"Compute the new format of the class"	instVars _ instVarMap at: aClass name ifAbsent:[oldClass instVarNames].	fmt _ self computeFormat: oldClass typeOfClass				instSize: instVars size				forSuper: newSuper				ccIndex: 0."Known to be 0 since we uncompacted aClass first"	fmt == nil ifTrue:[^nil].	aClass isMeta ifFalse:["Create a new meta class"		oldMeta _ aClass class.		newMeta _ oldMeta clone.		newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].		newMeta 			superclass: newSuperMeta			methodDictionary: MethodDictionary new			format: (self computeFormat: oldMeta typeOfClass 							instSize: oldMeta instVarNames size 							forSuper: newSuperMeta							ccIndex: 0);			setInstVarNames: oldMeta instVarNames;			organization: oldMeta organization.		"Recompile the meta class"		oldMeta hasMethods 			ifTrue:[newMeta compileAllFrom: oldMeta].		"Fix up meta class structure"		oldMeta superclass addObsoleteSubclass: oldMeta.		(oldMeta superclass subclasses includes: oldMeta) ifTrue:[			oldMeta superclass removeSubclass: oldMeta.			newMeta superclass addSubclass: newMeta].		"And record the change so we can fix global refs later"		self recordClass: oldMeta replacedBy: newMeta.	].	newClass _ newMeta == nil		ifTrue:[oldClass clone]		ifFalse:[newMeta adoptInstance: oldClass from: oldMeta].	newClass		superclass: newSuper		methodDictionary: MethodDictionary new		format: fmt;		setInstVarNames: instVars;		organization: aClass organization.	"Recompile the new class"	aClass hasMethods 		ifTrue:[newClass compileAllFrom: aClass].	"Export the new class into the environment"	aClass isMeta ifFalse:[		"Derefence super sends in the old class"		self fixSuperSendsFrom: aClass.		"Export the class"		environ at: newClass name put: newClass.		"And use the ST association in the new class"		self fixSuperSendsTo: newClass].	"Fix up the class hierarchy"	(aClass superclass subclasses includes: aClass) ifTrue:[		aClass superclass removeSubclass: aClass.		newClass superclass addSubclass: newClass.	].	"And record the change"	self recordClass: aClass replacedBy: newClass.	^newClass! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/5/2001 12:00'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	aClass isObsolete ifTrue:[^self].	currentClassIndex _ currentClassIndex + 1.	(aClass hasMethods and: [aClass wantsRecompilationProgressReported]) ifTrue:		[progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')]! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/9/2001 00:39'!update: oldClass to: newClass	"Convert oldClass and all its instances into newClass. The process is to do a two-way #become of the old vs. new instances, then we map the old instances into a temporary class and then we do a one-way become of the old into the new class. The entire process must be run unpreemptively so that	a) nobody can create any more instances of oldClass 	   (which may happen in a process switch), and	b) in case we don't #primitiveChangeClassTo: nobody can	   hold on to any of the old instances (which would #become	   instances of the new class later on).	The return value of this method is the temporary class we used for converting instances so that the senders still have a handle on the 'old' class."	| oldInstances someLeft tmp tmpClass |	[		someLeft _ false.		tmpClass _ oldClass clone.		oldInstances _ newClass updateInstancesFrom: oldClass.		oldInstances size > 0 ifTrue:[			"need to map instances"			self hasPrimitiveChangeClassTo ifTrue:[				"Much easier, faster, and better that way"				tmp _ tmpClass basicNew.				oldInstances do:[:inst| 					inst primitiveChangeClassTo: tmp.					inst class == tmpClass ifFalse:[self error:'Ouch']].			] ifFalse:[				"Do it the hard way. We need to make sure that there are no				instances of oldClass anymore. Thus we're #becoming the old				instances into temp instances and do a big GC afterwards. 				This is sloooooow (a bulk become + full GC for any class having				instances) but it's most definitely a way to get the required result."				tmpClass updateInstances: oldInstances from: oldClass isMeta: oldClass isMeta.				Smalltalk garbageCollect.			].		].		"It's better to be sure than sorry..."		someLeft _ oldClass someInstance notNil.		someLeft ifFalse:[			"remap obsolete subclasses in case they have instances"			oldClass obsoleteSubclasses do:[:obs| obs superclass: tmpClass].			oldClass becomeForward: newClass.			tmpClass isMeta ifFalse:				[tmpClass class replaceObsoleteInstanceWith: tmpClass]].	] valueUnpreemptively.	someLeft		ifTrue:[self error:'Illegal pointers to obsolete instances found'].	tmpClass superclass addObsoleteSubclass: tmpClass.	tmpClass obsolete.	^tmpClass! !"Postscript:Fix up the class hierarchy"Smalltalk allObjectsDo:[:cls| cls isBehavior ifTrue:[	cls isObsolete ifTrue:[		cls superclass removeSubclass: cls.	] ifFalse:[		cls isMeta ifFalse:[			((cls name beginsWith:'AnObsolete') or:[				(Smalltalk at: cls name ifAbsent:[nil]) ~~ cls]) ifTrue:[					cls obsolete.					cls superclass removeSubclass: cls.			].		].	].]].!