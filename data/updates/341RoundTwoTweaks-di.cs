'From Squeak 2.2 of Sept 23, 1998 on 6 October 1998 at 11:54:23 am'!"Change Set:		RoundTwoTweaks-diDate:			6 October 1998Author:			Your NameFixes three problems with the Round Two update:Dismissal of a mouse-up menu by clicking outsidewill not invoke other mouseDown activity.Erroneous return of a non-boolean is fixedin TransformMorph>>fullDrawOn:without:.Typing across the boundary of linked textMorphsnow works properly again."!!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 09:45'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/6/1998 09:48'!newMouseFocus: aMorphOrNil	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: ["Crock: If a menu is proffered with the mouse up						and the user clicks down outside it (as is normal in MVC),						then the menu goes away and nothing else happens."						mouseDownMorph owner deleteIfPopUp.						^ nil]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/6/1998 11:17'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!TextMorph methodsFor: 'editing' stamp: 'di 10/6/1998 10:32'!passKeyboardFocusTo: otherMorph	| w |	(w _ self world) ifNotNil: 		[w hands do:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].! !!TextMorph methodsFor: 'private' stamp: 'di 10/6/1998 11:22'!updateFromParagraph  	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be release, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [oldEditor _ editor.					sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				editor ifNotNil: [self installEditorToReplace: editor]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditorToReplace: editor.							^ self passKeyboardFocusTo: m]].		self error: 'Inconsistency in text editor' "Must be somewhere in the successor chain"].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditorToReplace: oldEditor]! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/6/1998 09:53'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas stopped patchForm |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation	ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas								without: stopMorph								andStopThere: stopThere)							ifTrue: [^ true]]].		^ false]	ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform transformBoundsRect: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		stopped _ false.		submorphs reverseDo:			[:m | stopped ifFalse:				["If we have not hit stopMorph..."				(m == stopMorph  "and this submorph is not stopMorph"					or: ["Then display it"						m fullDrawOn: offsetCanvas							without: stopMorph							andStopThere: stopThere])					ifTrue: ["We hit stopMorph here or below, so..."							stopped _ stopThere]]].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits.		^ stopped]! !