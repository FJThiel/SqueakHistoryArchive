'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:04:49 am'!"Change Set:		Balloon-6-EngineDate:			11 October 1998Author:			Andreas RaabDefines the actual graphics execution engine.BalloonEngineBase defines the base level of execution for graphical primitives that are executed either at primitive level or by Smalltalk code. BalloonEnginePlugin defines methods for dealing with graphical primitives (currently, bezier and line representations) at the primitive level."(Smalltalk includesKey: #BalloonEngineConstants) ifFalse:[	Smalltalk declare: #BalloonEngineConstants from: Undeclared.].(Smalltalk at: #BalloonEngineConstants) isNil ifTrue:[	(Smalltalk associationAt: #BalloonEngineConstants) value: Dictionary new.].!Object subclass: #BalloonBezierSimulation	instanceVariableNames: 'start end via lastX lastY fwDx fwDy fwDDx fwDDy maxSteps '	classVariableNames: 'HeightSubdivisions LineConversions MonotonSubdivisions OverflowSubdivisions '	poolDictionaries: ''	category: 'Balloon-Simulation'!Object variableWordSubclass: #BalloonBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!Object subclass: #BalloonEdgeData	instanceVariableNames: 'index xValue yValue zValue lines source '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!Object subclass: #BalloonEngine	instanceVariableNames: 'workBuffer span bitBlt clipRect destOffset externals aaLevel '	classVariableNames: 'BezierStats BufferCache CacheProtect Counts Debug Times '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!InterpreterPlugin subclass: #BalloonEngineBase	instanceVariableNames: 'workBuffer objBuffer getBuffer aetBuffer spanBuffer engine engineStopped geProfileTime edgeTransform dispatchedValue dispatchReturnValue '	classVariableNames: 'EdgeInitTable EdgeStepTable FillTable WideLineFillTable WideLineWidthTable '	poolDictionaries: 'BalloonEngineConstants '	category: 'Balloon-Engine'!BalloonEngineBase subclass: #BalloonEnginePlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!BalloonEnginePlugin subclass: #BalloonEngineSimulation	instanceVariableNames: 'bbObj '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!Object subclass: #BalloonFillData	instanceVariableNames: 'index minX maxX yValue source destForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!Object subclass: #BalloonLineSimulation	instanceVariableNames: 'start end xIncrement xDirection error errorAdjUp errorAdjDown '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!Object subclass: #BalloonSolidFillSimulation	instanceVariableNames: 'color '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Simulation'!FormCanvas subclass: #BalloonCanvas	instanceVariableNames: 'transform transformStack engine aaLevel '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-Engine'!!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!end	^end! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!end: aPoint	end _ aPoint! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 01:57'!inTangent	"Return the tangent at the start point"	^via - start! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialX	^start y <= end y		ifTrue:[start x]		ifFalse:[end x]! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialY	^start y <= end y		ifTrue:[start y]		ifFalse:[end y]! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!initialZ	^0 "Assume no depth given"! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 01:57'!outTangent	"Return the tangent at the end point"	^end - via! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!start	^start! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!start: aPoint	start _ aPoint! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!via	^via! !!BalloonBezierSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:45'!via: aPoint	via _ aPoint! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:46'!computeInitialStateFrom: source with: transformation	"Compute the initial state in the receiver."	start _ (transformation localPointToGlobal: source start) asIntegerPoint.	end _ (transformation localPointToGlobal: source end) asIntegerPoint.	via _ (transformation localPointToGlobal: source via) asIntegerPoint.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:39'!computeSplitAt: t	"Split the receiver at the parametric value t"	| left right newVia1 newVia2 newPoint |	left _ self clone.	right _ self clone.	"Compute new intermediate points"	newVia1 _ (via - start) * t + start.	newVia2 _ (end - via) * t + via.	"Compute new point on curve"	newPoint _ ((newVia1 - newVia2) * t + newVia2) asIntegerPoint.	left via: newVia1 asIntegerPoint.	left end: newPoint.	right start: newPoint.	right via: newVia2 asIntegerPoint.	^Array with: left with: right! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 01:34'!floatStepToFirstScanLineAt: yValue in: edgeTableEntry	"Float version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	steps scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[		^edgeTableEntry lines: 0].	fwX1 _ (startX + endX - (2 * via x)) asFloat.	fwX2 _ (via x - startX * 2) asFloat.	fwY1 _ (startY + endY - (2 * via y)) asFloat.	fwY2 _ ((via y - startY) * 2) asFloat.	steps _ deltaY asInteger * 2.	scaledStepSize _ 1.0 / steps asFloat.	squaredStepSize _ scaledStepSize * scaledStepSize.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2.0 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2.0 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx * 0.5).	fwDy _ fwDy + (fwDDy * 0.5).	lastX _ startX asFloat.	lastY _ startY asFloat.	"self xDirection: xDir.	self yDirection: yDir."	edgeTableEntry xValue: startX.	edgeTableEntry yValue: startY.	edgeTableEntry zValue: 0.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		self stepToNextScanLineAt: yValue in: edgeTableEntry.		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:45'!floatStepToNextScanLineAt: yValue in: edgeTableEntry	"Float version of forward differencing"	[yValue asFloat > lastY] whileTrue:[		(fwDx < -50.0 or:[fwDx > 50.0]) ifTrue:[self halt].		(fwDy < -50.0 or:[fwDy > 50.0]) ifTrue:[self halt].		(fwDDx < -50.0 or:[fwDDx > 50.0]) ifTrue:[self halt].		(fwDDy < -50.0 or:[fwDDy > 50.0]) ifTrue:[self halt].		lastX _ lastX + fwDx.		lastY _ lastY + fwDy.		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.	].	edgeTableEntry xValue: lastX asInteger.	edgeTableEntry zValue: 0.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 16:23'!intStepToFirstScanLineAt: yValue in: edgeTableEntry	"Scaled integer version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	 scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[		^edgeTableEntry lines: 0].	fwX1 _ (startX + endX - (2 * via x)).	fwX2 _ (via x - startX * 2).	fwY1 _ (startY + endY - (2 * via y)).	fwY2 _ ((via y - startY) * 2).	maxSteps _ deltaY asInteger * 2.	scaledStepSize _ 16r1000000 // maxSteps.	"@@: Okay, we need some fancy 64bit multiplication here"	squaredStepSize _ self absoluteSquared8Dot24: scaledStepSize.	squaredStepSize = ((scaledStepSize * scaledStepSize) bitShift: -24)		ifFalse:[self error:'Bad computation'].	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwDy + (fwDDy // 2).	self validateIntegerRange.	lastX _ startX * 256.	lastY _ startY * 256.	edgeTableEntry xValue: startX.	edgeTableEntry yValue: startY.	edgeTableEntry zValue: 0.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		self stepToNextScanLineAt: yValue in: edgeTableEntry.		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 04:02'!intStepToNextScanLineAt: yValue in: edgeTableEntry	"Scaled integer version of forward differencing"	[maxSteps >= 0 and:[yValue * 256 > lastY]] whileTrue:[		self validateIntegerRange.		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.		maxSteps _ maxSteps - 1.	].	edgeTableEntry xValue: lastX // 256.	edgeTableEntry zValue: 0.! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/29/1998 22:14'!isMonoton	"Return true if the receiver is monoton along the y-axis,	e.g., check if the tangents have the same sign"	^(via y - start y) * (end y - via y) >= 0! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/31/1998 16:36'!stepToFirstScanLineAt: yValue in: edgeTableEntry	"Compute the initial x value for the scan line at yValue"	^self intStepToFirstScanLineAt: yValue in: edgeTableEntry! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 03:40'!stepToNextScanLineAt: yValue in: edgeTableEntry	"Compute the next x value for the scan line at yValue.	This message is sent during incremental updates. 	The yValue parameter is passed in here for edges	that have more complicated computations,"	^self intStepToNextScanLineAt: yValue in: edgeTableEntry! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 11/1/1998 00:31'!subdivide	"Subdivide the receiver"	| dy dx |	"Test 1: If the bezier curve is not monoton in Y, we need a subdivision"	self isMonoton ifFalse:[		MonotonSubdivisions _ MonotonSubdivisions + 1.		^self subdivideToBeMonoton].	"Test 2: If the receiver is horizontal, don't do anything"	(end y = start y) ifTrue:[^nil].	"Test 3: If the receiver can be represented as a straight line,			make a line from the receiver and declare it invalid"	((end - start) crossProduct: (via - start)) = 0 ifTrue:[		LineConversions _ LineConversions + 1.		^self subdivideToBeLine].	"Test 4: If the height of the curve exceeds 256 pixels, subdivide 			(forward differencing is numerically not very stable)"	dy _ end y - start y.	dy < 0 ifTrue:[dy _ dy negated].	(dy > 255) ifTrue:[		HeightSubdivisions _ HeightSubdivisions + 1.		^self subdivideAt: 0.5].	"Test 5: Check if the incremental values could possibly overflow the scaled integer range"	dx _ end x - start x.	dx < 0 ifTrue:[dx _ dx negated].	dy * 32 < dx ifTrue:[		OverflowSubdivisions _ OverflowSubdivisions + 1.		^self subdivideAt: 0.5].	^nil! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 22:13'!subdivideAt: parameter	"Subdivide the receiver at the given parameter"	| both |	(parameter <= 0.0 or:[parameter >= 1.0]) ifTrue:[self halt].	both _ self computeSplitAt: parameter.	"Transcript cr.	self quickPrint: self.	Transcript space.	self quickPrint: both first.	Transcript space.	self quickPrint: both last.	Transcript endEntry."	self via: both first via.	self end: both first end.	^both last! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 11/11/1998 22:15'!subdivideToBeLine	"Not a true subdivision.	Just return a line representing the receiver and fake me to be of zero height"	| line |	line _ BalloonLineSimulation new.	line start: start.	line end: end.	"Make me invalid"	end _ start.	via _ start.	 ^line! !!BalloonBezierSimulation methodsFor: 'computing' stamp: 'ar 10/30/1998 02:24'!subdivideToBeMonoton	"Subdivide the receiver at it's extreme point"	| v1 v2 t other |	v1 _ (via - start).	v2 _ (end - via).	t _ (v1 y / (v2 y - v1 y)) negated asFloat.	other _ self subdivideAt: t.	self isMonoton ifFalse:[self halt].	other isMonoton ifFalse:[self halt].	^other! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 16:37'!absoluteSquared8Dot24: value	"Compute the squared value of a 8.24 number with 0.0 <= value < 1.0,	e.g., compute (value * value) bitShift: -24"	| halfWord1 halfWord2 result |	(value >= 0 and:[value < 16r1000000]) ifFalse:[^self error:'Value out of range'].	halfWord1 _ value bitAnd: 16rFFFF.	halfWord2 _ (value bitShift: -16) bitAnd: 255.	result _ (halfWord1 * halfWord1) bitShift: -16. "We don't need the lower 16bits at all"	result _ result + ((halfWord1 * halfWord2) * 2).	result _ result + ((halfWord2 * halfWord2) bitShift: 16).	"word1 _ halfWord1 * halfWord1.	word2 _ (halfWord2 * halfWord1) + (word1 bitShift: -16).	word1 _ word1 bitAnd: 16rFFFF.	word2 _ word2 + (halfWord1 * halfWord2).	word2 _ word2 + ((halfWord2 * halfWord2) bitShift: 16)."	^result bitShift: -8! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 11/11/1998 22:12'!debugDraw	| entry minY maxY lX lY canvas |	entry _ BalloonEdgeData new.	canvas _ FormCanvas on: Display.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	self stepToFirstScanLineAt: minY in: entry.	lX _ entry xValue.	lY _ entry yValue.	minY+1 to: maxY do:[:y|		self stepToNextScanLineAt: y in: entry.		canvas line: lX@lY to: entry xValue @ y width: 2 color: Color black.		lX _ entry xValue.		lY _ y.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/29/1998 21:26'!debugDraw2	| canvas last max t next |	canvas _ FormCanvas on: Display.	max _ 100.	last _ nil.	0 to: max do:[:i|		t _ i asFloat / max asFloat.		next _ self valueAt: t.		last ifNotNil:[			canvas line: last to: next rounded width: 2 color: Color blue.		].		last _ next rounded.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 11/11/1998 22:12'!debugDrawWide: n	| entry minY maxY canvas curve p1 p2 entry2 y |	curve _ self class new.	curve start: start + (0@n).	curve via: via + (0@n).	curve end: end + (0@n).	entry _ BalloonEdgeData new.	entry2 _ BalloonEdgeData new.	canvas _ FormCanvas on: Display.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	entry2 yValue: minY + n.	self stepToFirstScanLineAt: minY in: entry.	curve stepToFirstScanLineAt: minY+n in: entry2.	y _ minY.	1 to: n do:[:i|		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p1 _ entry xValue @ y.		canvas line: p1 to: p1 + (n@0) width: 1 color: Color black.	].	[y < maxY] whileTrue:[		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p2 _ (entry xValue + n) @ y.		curve stepToNextScanLineAt: y in: entry2.		p1 _ entry2 xValue @ y.		canvas line: p1 to: p2 width: 1 color: Color black.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 00:35'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: start;		nextPutAll:' - ';		print: via;		nextPutAll:' - ';		print: end;		nextPut:$)! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 21:56'!quickPrint: curve	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 22:13'!quickPrint: curve first: aBool	aBool ifTrue:[Transcript cr].	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).	Transcript endEntry.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:53'!stepToFirst	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	steps scaledStepSize squaredStepSize |	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(deltaY = 0) ifTrue:[^self].	fwX1 _ (startX + endX - (2 * via x)) asFloat.	fwX2 _ (via x - startX * 2) asFloat.	fwY1 _ (startY + endY - (2 * via y)) asFloat.	fwY2 _ ((via y - startY) * 2) asFloat.	steps _ deltaY asInteger * 2.	scaledStepSize _ 1.0 / steps asFloat.	squaredStepSize _ scaledStepSize * scaledStepSize.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2.0 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2.0 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx * 0.5).	fwDy _ fwDy + (fwDDy * 0.5).	lastX _ startX asFloat.	lastY _ startY asFloat.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:50'!stepToFirstInt	"Scaled integer version of forward differencing"	|  startX endX startY endY deltaY fwX1 fwX2 fwY1 fwY2 	 scaledStepSize squaredStepSize |	self halt.	(end y) >= (start y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.	].	deltaY _ endY - startY.	"Quickly check if the line is visible at all"	(deltaY = 0) ifTrue:[^nil].	fwX1 _ (startX + endX - (2 * via x)).	fwX2 _ (via x - startX * 2).	fwY1 _ (startY + endY - (2 * via y)).	fwY2 _ ((via y - startY) * 2).	maxSteps _ deltaY asInteger * 2.	scaledStepSize _ 16r1000000 // maxSteps.	"@@: Okay, we need some fancy 64bit multiplication here"	squaredStepSize _ (scaledStepSize * scaledStepSize) bitShift: -24.	fwDx _ fwX2 * scaledStepSize.	fwDDx _ 2 * fwX1 * squaredStepSize.	fwDy _ fwY2 * scaledStepSize.	fwDDy _ 2 * fwY1 * squaredStepSize.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwDy + (fwDDy // 2).	self validateIntegerRange.	lastX _ startX * 256.	lastY _ startY * 256.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 00:26'!stepToNext		lastX _ lastX + fwDx.		lastY _ lastY + fwDy.		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 04:01'!stepToNextInt	"Scaled integer version of forward differencing"	self halt.	(maxSteps >= 0) ifTrue:[		self validateIntegerRange.		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + fwDDx.		fwDy _ fwDy + fwDDy.		maxSteps _ maxSteps - 1.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/30/1998 03:27'!validateIntegerRange	fwDx class == SmallInteger ifFalse:[self halt].	fwDy class == SmallInteger ifFalse:[self halt].	fwDDx class == SmallInteger ifFalse:[self halt].	fwDDy class == SmallInteger ifFalse:[self halt].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 10/29/1998 21:26'!valueAt: parameter	"Return the point at the value parameter:		p(t) =	(1-t)^2 * p1 + 				2*t*(1-t) * p2 + 				t^2 * p3.	"	| t1 t2 t3 |	t1 _ (1.0 - parameter) squared.	t2 _ 2 * parameter * (1.0 - parameter).	t3 _ parameter squared.	^(start * t1) + (via * t2) + (end * t3)! !!BalloonBezierSimulation class methodsFor: 'class initialization' stamp: 'ar 10/30/1998 03:04'!initialize	"GraphicsBezierSimulation initialize"	HeightSubdivisions _ 0.	LineConversions _ 0.	MonotonSubdivisions _ 0.	OverflowSubdivisions _ 0.! !!BalloonBuffer reorganize!('accessing' at: at:put:)!!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 10/26/1998 21:12'!at: index	"For simulation only"	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!BalloonBuffer methodsFor: 'accessing' stamp: 'ar 10/26/1998 21:12'!at: index put: anInteger	"For simulation only"	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!BalloonBuffer class methodsFor: 'instance creation' stamp: 'ar 10/26/1998 21:11'!mew: n	^self new: (n max: 256)! !!BalloonBuffer class methodsFor: 'instance creation' stamp: 'ar 10/26/1998 21:11'!new	^self new: 256.! !!BalloonCanvas class reorganize!('instance creation' new)!!BalloonCanvas class methodsFor: 'instance creation' stamp: 'ar 11/11/1998 19:14'!new	^super new initialize! !!BalloonEdgeData commentStamp: '<historical>' prior: 0!BalloonEdgeData defines an entry in the internal edge table of the Balloon engine.Instance Variables:	index	<Integer>	The index into the external objects array of the associated graphics engine	xValue	<Integer>	The computed x-value of the requested operation	yValue	<Integer>	The y-value for the requested operation	height	<Integer>	The (remaining) height of the edge	source	<Object>		The object from the external objects array!!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!index	^index! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!index: anInteger	index _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:13'!lines	^lines! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:13'!lines: anInteger	^lines _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!source	^source! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 21:39'!source: anObject	source _ anObject! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!xValue	^xValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!xValue: anInteger	xValue _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:34'!yValue	^yValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:35'!yValue: anInteger	yValue _ anInteger! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 19:56'!zValue	^zValue! !!BalloonEdgeData methodsFor: 'accessing' stamp: 'ar 10/27/1998 19:56'!zValue: anInteger	zValue _ anInteger! !!BalloonEdgeData methodsFor: 'computing' stamp: 'ar 10/27/1998 15:53'!stepToFirstScanLine	source stepToFirstScanLineAt: yValue in: self! !!BalloonEdgeData methodsFor: 'computing' stamp: 'ar 10/27/1998 15:53'!stepToNextScanLine	source stepToNextScanLineAt: yValue in: self! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/11/1998 22:54'!initialize	externals _ OrderedCollection new: 100.	span _ Bitmap new: 2048.	bitBlt _ nil.	self bitBlt: ((BitBlt toForm: Display) destRect: Display boundingBox; yourself).! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/11/1998 22:52'!release	self class recycleBuffer: workBuffer.	workBuffer _ nil.! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 11/15/1998 18:46'!reset	workBuffer ifNil:[workBuffer _ self class allocateOrRecycleBuffer: 10000].	self primInitializeBuffer: workBuffer.	self primSetAALevel: self aaLevel.	self primSetOffset: destOffset.	self primSetClipRect: clipRect.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/14/1998 20:52'!drawBezierShape: points fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	self primAddBezierShape: points		segments: points size		fill: (self registerFill: fillStyle transform: aTransform)		lineWidth: borderWidth		lineFill: (self registerFill: borderFill transform: aTransform)		matrix: aTransform.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/16/1998 02:16'!drawCompressedShape: shape transform: aTransform	| fillIndexList fills |	self reset.	fills _ shape fillStyles.	fillIndexList _ WordArray new: fills size.	1 to: fills size do:[:i|		fillIndexList at: i put: (self registerFill: (fills at: i) transform: aTransform).	].	self doAddCompressedShape: shape points		segments: shape numSegments		leftFills: shape leftFills		rightFills: shape rightFills		lineWidths: shape lineWidths		lineFills: shape lineFills		fillIndexList: fillIndexList		matrix: aTransform.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/14/1998 20:52'!drawGeneralBezierShape: contours fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	contours do:[:points|		self primAddBezierShape: points			segments: (points size // 3)			fill: (self registerFill: fillStyle transform: aTransform)			lineWidth: borderWidth			lineFill: (self registerFill: borderFill transform: aTransform)			matrix: aTransform.	].	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/14/1998 19:54'!drawGeneralPolygon: contours fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	contours do:[:points|		self primAddPolygon: points			segments: points size			fill: (self registerFill: fillStyle transform: aTransform)			lineWidth: borderWidth			lineFill: (self registerFill: borderFill transform: aTransform)			matrix: aTransform.	].	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:54'!drawOval: rect fill: fillStyle borderWidth: borderWidth borderColor: borderColor transform: aMatrix	self reset.	self primAddOvalFrom: rect origin 			to: rect corner			fillIndex: (self registerFill: fillStyle transform: aMatrix)			borderWidth: borderWidth			borderColor: (self registerFill: borderColor transform: aMatrix)			matrix: aMatrix.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:53'!drawPolygon: points fill: fillStyle borderWidth: borderWidth borderColor: borderFill transform: aTransform	self reset.	self primAddPolygon: points		segments: points size		fill: (self registerFill: fillStyle transform: aTransform)		lineWidth: borderWidth		lineFill: (self registerFill: borderFill transform: aTransform)		matrix: aTransform.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:54'!drawRectangle: rect fill: fillStyle borderWidth: borderWidth borderColor: borderColor transform: aMatrix	self reset.	self primAddRectFrom: rect origin 			to: rect corner			fillIndex: (self registerFill: fillStyle transform: aMatrix)			borderWidth: borderWidth			borderColor: (self registerFill: borderColor transform: aMatrix)			matrix: aMatrix.	self copyBits.	self release.! !!BalloonEngine methodsFor: 'drawing' stamp: 'ar 11/12/1998 19:53'!registerFill: aFillStyle transform: aTransform	aFillStyle ifNil:[^0].	aFillStyle isSolidFill 		ifTrue:[^aFillStyle pixelValue32].	aFillStyle isGradientFill ifTrue:[		^self doAddGradientFill: aFillStyle pixelRamp			from: aFillStyle origin			along: aFillStyle direction			normal: aFillStyle normal			radial: aFillStyle isRadialFill			matrix: aTransform.		].	^0! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:08'!canProceedAfter: failureReason	"Check if we can proceed after the failureReason indicated."	| newBuffer |	failureReason = GErrorNoMoreSpace ifTrue:[		"Work buffer is too small"		newBuffer _ workBuffer species new: workBuffer size * 2.		self primCopyBufferFrom: workBuffer to: newBuffer.		workBuffer _ newBuffer.		^true].	"Not handled"	^false! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:16'!copyBits	self copyLoopFastest.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:32'!copyLoop	"This is the basic rendering loop using as little primitive support as possible."	| finished edge fill |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	self primInitializeProcessing. "Initialize the GE for processing"	[self primFinishedProcessing] whileFalse:[		"Step 1: Process the edges in the global edge table that will be added in this step"		[finished _ self primNextGlobalEdgeEntryInto: edge.		finished] whileFalse:[			edge source: (externals at: edge index).			edge stepToFirstScanLine.			self primAddActiveEdgeTableEntryFrom: edge].		"Step 2: Scan the active edge table"		[finished _ self primNextFillEntryInto: fill.		finished] whileFalse:[			fill source: (externals at: fill index).			"Compute the new fill"			fill computeFill.			"And mix it in the out buffer"			self primMergeFill: fill destForm bits from: fill].		"Step 3: Display the current span buffer if necessary"		self primDisplaySpanBuffer.		"Step 4: Advance and resort the active edge table"		[finished _ self primNextActiveEdgeEntryInto: edge.		finished] whileFalse:[			"If the index is zero then the edge has been handled by the GE"			edge source: (externals at: edge index).			edge stepToNextScanLine.			self primChangeActiveEdgeTableEntryFrom: edge].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:32'!copyLoopFaster	"This is a copy loop drawing one scan line at a time"	| edge fill reason |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	[self primFinishedProcessing] whileFalse:[		reason _ self primRenderScanline: edge with: fill.		"reason ~= 0 means there has been a problem"		reason = 0 ifFalse:[			self processStopReason: reason edge: edge fill: fill.		].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/14/1998 19:33'!copyLoopFastest	"This is a copy loop drawing the entire image"	| edge fill reason |	edge _ BalloonEdgeData new.	fill _ BalloonFillData new.	[self primFinishedProcessing] whileFalse:[		reason _ self primRenderImage: edge with: fill.		"reason ~= 0 means there has been a problem"		reason = 0 ifFalse:[			self processStopReason: reason edge: edge fill: fill.		].	].	self primGetTimes: Times.	self primGetCounts: Counts.	self primGetBezierStats: BezierStats.! !!BalloonEngine methodsFor: 'copying' stamp: 'ar 11/11/1998 21:19'!processStopReason: reason edge: edge fill: fill	"The engine has stopped because of some reason.	Try to figure out how to respond and do the necessary actions."	"Note: The order of operations below can affect the speed"	"Process unknown fills first"	reason = GErrorFillEntry ifTrue:[		fill source: (externals at: fill index).		"Compute the new fill"		fill computeFill.		"And mix it in the out buffer"		^self primMergeFill: fill destForm bits from: fill].	"Process unknown steppings in the AET second"	reason = GErrorAETEntry ifTrue:[		edge source: (externals at: edge index).		edge stepToNextScanLine.		^self primChangeActiveEdgeTableEntryFrom: edge].	"Process unknown entries in the GET third"	reason = GErrorGETEntry ifTrue:[		edge source: (externals at: edge index).		edge stepToFirstScanLine.		^self primAddActiveEdgeTableEntryFrom: edge].	"Process generic problems last"	(self canProceedAfter: reason) ifTrue:[^self]. "Okay."	^self error:'Unkown stop reason in graphics engine'! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:04'!aaLevel	^aaLevel ifNil:[1]! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:04'!aaLevel: anInteger	aaLevel _ (anInteger min: 4) max: 1.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/29/1998 01:51'!aaTransform	"Return a transformation for the current anti-aliasing level"	| matrix |	matrix _ MatrixTransform2x3 withScale: (self aaLevel) asFloat asPoint.	matrix offset: (self aaLevel // 2) asFloat asPoint.	^matrix composedWith:(MatrixTransform2x3 withOffset: destOffset asFloatPoint)! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/13/1998 03:04'!bitBlt	^bitBlt! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:07'!bitBlt: aBitBlt	bitBlt _ aBitBlt.	bitBlt isNil ifTrue:[^self].	self clipRect: bitBlt clipRect.	bitBlt 		sourceForm: (Form extent: span size @ 1 depth: 32 bits: span);		sourceRect: (0@0 extent: 1@span size);		colorMap: (Color colorMapIfNeededFrom: 32 to: bitBlt destForm depth);		combinationRule: (bitBlt destForm depth >= 8 ifTrue:[34] ifFalse:[Form paint]).! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/1/1998 02:57'!clipRect	^clipRect! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/13/1998 02:44'!clipRect: aRect	clipRect _ aRect truncated! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/1/1998 02:56'!destOffset	^destOffset! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 11/12/1998 00:22'!destOffset: aPoint	destOffset _ aPoint asIntegerPoint.	bitBlt destX: aPoint x; destY: aPoint y.! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 10/29/1998 01:51'!fullTransformFrom: aMatrix	| m |	m _ self aaTransform composedWith: aMatrix.	"m offset: m offset + destOffset."	^m! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primClipRectInto: rect	<primitive: 'gePrimitiveGetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive:'gePrimitiveGetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetAALevel	"Set the AA level"	<primitive: 'gePrimitiveGetAALevel'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetAALevel'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetBezierStats: statsArray	<primitive:'gePrimitiveGetBezierStats'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetBezierStats'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetClipRect: rect	<primitive: 'gePrimitiveGetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetCounts: statsArray	<primitive:'gePrimitiveGetCounts'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetCounts'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetFailureReason	<primitive: 'gePrimitiveGetFailureReason'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetFailureReason'].	^0! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetOffset	<primitive: 'gePrimitiveGetOffset'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetOffset'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primGetTimes: statsArray	<primitive:'gePrimitiveGetTimes'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveGetTimes'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetAALevel: level	"Set the AA level"	<primitive: 'gePrimitiveSetAALevel'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetAALevel'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetClipRect: rect	<primitive: 'gePrimitiveSetClipRect'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetClipRect'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 21:55'!primSetOffset: point	<primitive: 'gePrimitiveSetOffset'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveSetOffset'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:16'!primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	<primitive: 'gePrimitiveAddBezierWithMatrix' module:'blurb'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBezierWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/14/1998 20:53'!primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	<primitive: 'gePrimitiveAddBezierShape'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddBezierShape'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:16'!primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	<primitive: 'gePrimitiveAddCompressedShape'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddCompressedShape'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:18'!primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'gePrimitiveRegisterExternalEdge'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRegisterExternalEdge'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddExternalFill: index	<primitive: 'gePrimitiveRegisterExternalFill'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRegisterExternalFill'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalFill: index	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix	<primitive: 'gePrimitiveAddGradientFill'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddGradientFill'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	<primitive: 'gePrimitiveAddLineWithMatrix'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddLineWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	<primitive: 'gePrimitiveAddOvalWithMatrix'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddOvalWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	<primitive: 'gePrimitiveAddPolygon'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddPolygon'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar 11/13/1998 13:17'!primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	<primitive: 'gePrimitiveAddRectWithMatrix'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddRectWithMatrix'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32 matrix: aMatrix	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/14/1998 20:47'!primAddActiveEdgeTableEntryFrom: edgeEntry	"Add edge entry to the AET."	<primitive: 'gePrimitiveAddActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveAddActiveEdgeEntry'].	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddActiveEdgeTableEntryFrom: edgeEntry	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:56'!primChangeActiveEdgeTableEntryFrom: edgeEntry	"Change the entry in the active edge table from edgeEntry"	<primitive: 'gePrimitiveChangedActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveChangedActiveEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primDisplaySpanBuffer	"Display the current scan line if necessary"	<primitive: 'gePrimitiveDisplaySpanBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveDisplaySpanBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primFinishedProcessing	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	<primitive: 'gePrimitiveFinishedProcessing'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveFinishedProcessing'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primInitializeProcessing	"Initialize processing in the GE.	Create the active edge table and sort it."	<primitive: 'gePrimitiveInitializeProcessing'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeProcessing'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primMergeFill: fillBitmap from: fill	"Merge the filled bitmap into the current output buffer."	<primitive: 'gePrimitiveMergeFillFrom'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveMergeFillFrom'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primNextActiveEdgeEntryInto: edgeEntry	"Store the next entry of the AET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'gePrimitiveNextActiveEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextActiveEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primNextFillEntryInto: fillEntry	"Store the next fill entry of the active edge table in fillEntry.	Return false if there is no such entry, true otherwise"	<primitive: 'gePrimitiveNextFillEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextFillEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:56'!primNextGlobalEdgeEntryInto: edgeEntry	"Store the next entry of the GET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'gePrimitiveNextGlobalEdgeEntry'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveNextGlobalEdgeEntry'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primRenderImage: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'gePrimitiveRenderImage'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderImage'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 21:55'!primRenderScanline: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'gePrimitiveRenderScanline'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveRenderScanline'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 11/11/1998 21:55'!primCopyBufferFrom: oldBuffer to: newBuffer	"Copy the contents of oldBuffer into the (larger) newBuffer"	<primitive: 'gePrimitiveCopyBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveCopyBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar 11/11/1998 21:55'!primInitializeBuffer: buffer	<primitive: 'gePrimitiveInitializeBuffer'>	Debug ifTrue:[^BalloonEnginePlugin doPrimitive: 'gePrimitiveInitializeBuffer'].	^self primitiveFailed! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:53'!registerBezier: aCurve transformation: aMatrix	self primAddBezierFrom: aCurve start		to: aCurve end		via: aCurve via		leftFillIndex: (self registerFill: aCurve leftFill transform: aMatrix)		rightFillIndex: (self registerFill: aCurve rightFill transform: aMatrix)		matrix: aMatrix! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/11/1998 21:15'!registerBoundary: boundaryObject transformation: aMatrix	| external |	external _ boundaryObject asEdgeRepresentation: (self fullTransformFrom: aMatrix).	self subdivideExternalEdge: external from: boundaryObject.! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:54'!registerExternalEdge: externalEdge from: boundaryObject	externals addLast: externalEdge.	self primAddExternalEdge: externals size		initialX: externalEdge initialX		initialY: externalEdge initialY		initialZ: externalEdge initialZ		leftFillIndex: (self registerFill: boundaryObject leftFill transform: nil)		rightFillIndex: (self registerFill: boundaryObject rightFill transform: nil)! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/12/1998 19:54'!registerLine: aLine transformation: aMatrix	self primAddLineFrom: aLine start to: aLine end		leftFillIndex: (self registerFill: aLine leftFill transform: aMatrix)		rightFillIndex: (self registerFill: aLine rightFill transform: aMatrix)		matrix: aMatrix! !!BalloonEngine methodsFor: 'experimental' stamp: 'ar 11/11/1998 21:15'!subdivideExternalEdge: external from: boundaryObject	| external2 |	external2 _ external subdivide.	external2 notNil ifTrue:[		self subdivideExternalEdge: external from: boundaryObject.		self subdivideExternalEdge: external2 from: boundaryObject.	] ifFalse:[		self registerExternalEdge: external from: boundaryObject.	].! !!BalloonEngine methodsFor: 'profiling' stamp: 'ar 11/11/1998 21:16'!doAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix	"Note: This method is for profiling the overhead of loading a compressed shape into the engine."	^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList matrix: aMatrix! !!BalloonEngine methodsFor: 'profiling' stamp: 'ar 11/11/1998 21:16'!doAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix	^self primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial matrix: aMatrix! !!BalloonEngine class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 21:44'!new	^super new initialize! !!BalloonEngine class methodsFor: 'class initialization' stamp: 'ar 11/11/1998 22:49'!initialize	"BalloonEngine initialize"	BufferCache _ WeakArray new: 1.	Smalltalk garbageCollect. "Make the cache old"	CacheProtect _ Semaphore forMutualExclusion.	Times _ WordArray new: 10.	Counts _ WordArray new: 10.	BezierStats _ WordArray new: 4.	Debug ifNil:[Debug _ false].! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/25/1998 17:37'!debug: aBoolean	"BalloonEngine debug: true"	"BalloonEngine debug: false"	Debug _ aBoolean! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/30/1998 23:57'!printBezierStats	"BalloonEngine printBezierStats"	"BalloonEngine resetBezierStats"	Transcript 		cr; nextPutAll:'Bezier statistics:';		crtab; print: (BezierStats at: 1); tab; nextPutAll:' non-monoton curves splitted';		crtab; print: (BezierStats at: 2); tab; nextPutAll:' curves splitted for numerical accuracy';		crtab; print: (BezierStats at: 3); tab; nextPutAll:' curves splitted to avoid integer overflow';		crtab; print: (BezierStats at: 4); tab; nextPutAll:' curves internally converted to lines';	endEntry.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/28/1998 23:59'!printStat: time count: n string: aString	Transcript		cr;		print: time; tab;		nextPutAll:' mSecs -- ';		print: n; tab;		nextPutAll:' ops -- ';		print: ((time asFloat / (n max: 1) asFloat) roundTo: 0.01); tab;		nextPutAll: ' avg. mSecs/op -- ';		nextPutAll: aString.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/29/1998 19:59'!printStats	"BalloonEngine printStats"	"BalloonEngine resetStats"	Transcript cr; nextPutAll:'/************** BalloonEngine statistics ****************/'.	self printStat: (Times at: 1) count: (Counts at: 1) string: 'Initialization'.	self printStat: (Times at: 2) count: (Counts at: 2) string: 'Finish test'.	self printStat: (Times at: 3) count: (Counts at: 3) string: 'Fetching/Adding GET entries'.	self printStat: (Times at: 4) count: (Counts at: 4) string: 'Adding AET entries'.	self printStat: (Times at: 5) count: (Counts at: 5) string: 'Fetching/Computing fills'.	self printStat: (Times at: 6) count: (Counts at: 6) string: 'Merging fills'.	self printStat: (Times at: 7) count: (Counts at: 7) string: 'Displaying span buffer'.	self printStat: (Times at: 8) count: (Counts at: 8) string: 'Fetching/Updating AET entries'.	self printStat: (Times at: 9) count: (Counts at: 9) string: 'Changing AET entries'.	Transcript cr; print: Times sum; nextPutAll:' mSecs for all operations'.	Transcript cr; print: Counts sum; nextPutAll: ' overall operations'.	Transcript endEntry.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/30/1998 23:57'!resetBezierStats	BezierStats _ WordArray new: 4.! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar 10/28/1998 23:38'!resetStats	Times _ WordArray new: 10.	Counts _ WordArray new: 10.! !!BalloonEngine class methodsFor: 'private' stamp: 'ar 11/11/1998 22:50'!allocateOrRecycleBuffer: initialSize	"Try to recycly a buffer. If this is not possibly, create a new one."	| buffer |	CacheProtect critical:[		buffer _ BufferCache at: 1.		BufferCache at: 1 put: nil.	].	^buffer ifNil:[BalloonBuffer new: initialSize]! !!BalloonEngine class methodsFor: 'private' stamp: 'ar 11/11/1998 22:51'!recycleBuffer: balloonBuffer	"Try to keep the buffer for later drawing operations."	| buffer |	CacheProtect critical:[		buffer _ BufferCache at: 1.		(buffer isNil or:[buffer size < balloonBuffer size] )			ifTrue:[BufferCache at: 1 put: balloonBuffer].	].! !!BalloonEngineBase reorganize!('accessing state' aaColorMaskGet aaColorMaskPut: aaColorShiftGet aaColorShiftPut: aaHalfPixelGet aaHalfPixelPut: aaLevelGet aaLevelPut: aaScanMaskGet aaScanMaskPut: aaShiftGet aaShiftPut: aetStartGet aetStartPut: aetUsedGet aetUsedPut: clearSpanBufferGet clearSpanBufferPut: clipMaxXGet clipMaxXPut: clipMaxYGet clipMaxYPut: clipMinXGet clipMinXPut: clipMinYGet clipMinYPut: currentYGet currentYPut: destOffsetXGet destOffsetXPut: destOffsetYGet destOffsetYPut: fillMaxXGet fillMaxXPut: fillMaxYGet fillMaxYPut: fillMinXGet fillMinXPut: fillMinYGet fillMinYPut: fillOffsetXGet fillOffsetXPut: fillOffsetYGet fillOffsetYPut: firstPointListGet firstPointListPut: getStartGet getStartPut: getUsedGet getUsedPut: incrementStat:by: lastExportedEdgeGet lastExportedEdgePut: lastExportedFillGet lastExportedFillPut: lastExportedLeftXGet lastExportedLeftXPut: lastExportedRightXGet lastExportedRightXPut: magicNumberGet magicNumberPut: objStartGet objStartPut: objUsedGet objUsedPut: point1Get point2Get point3Get point4Get spanEndAAGet spanEndAAPut: spanEndGet spanEndPut: spanSizeGet spanSizePut: spanStartGet spanStartPut: stateGet statePut: stopReasonGet stopReasonPut: wbSizeGet wbSizePut: wbTopGet wbTopPut:)('accessing objects' objectHeaderOf: objectIndexOf: objectIndexOf:put: objectLengthOf: objectLengthOf:put: objectTypeOf: objectTypeOf:put:)('accessing edges' edgeFillsInvalidate: edgeFillsValidate: edgeLeftFillOf: edgeLeftFillOf:put: edgeNumLinesOf: edgeNumLinesOf:put: edgeRightFillOf: edgeRightFillOf:put: edgeTypeOf: edgeXValueOf: edgeXValueOf:put: edgeYValueOf: edgeYValueOf:put: edgeZValueOf: edgeZValueOf:put:)('accessing stack' wbStackClear wbStackPop: wbStackPush: wbStackSize wbStackValue: wbStackValue:put:)('accessing fills' fillTypeOf: stackFillDepth: stackFillDepth:put: stackFillEntryLength stackFillSize stackFillValue: stackFillValue:put: topFill topFillDepth topFillDepthPut: topFillValue topFillValuePut:)('loading state' loadArrayMatrixFrom: loadEdgeStateFrom: loadMatrixFrom: loadPoint:from: loadSpanBufferFrom: loadWordMatrixFrom: loadWorkBufferFrom: quickLoadEngineFrom: quickLoadEngineFrom:requiredState: quickLoadEngineFrom:requiredState:or:)('storing state' storeEdgeStateFrom:into: storeEngineStateInto: storeFillStateInto: storeStopStateIntoEdge:fill:)('testing' areEdgeFillsValid: finishedProcessing isEdge: isFill: isFillColor: isObject: isRealFill: isStackEntry: isStackIndex: isWide:)('primitives-access' gePrimitiveGetAALevel gePrimitiveGetClipRect gePrimitiveGetCounts gePrimitiveGetFailureReason gePrimitiveGetOffset gePrimitiveGetTimes gePrimitiveSetAALevel gePrimitiveSetClipRect gePrimitiveSetOffset)('primitives-incremental' gePrimitiveAddActiveEdgeEntry gePrimitiveChangedActiveEdgeEntry gePrimitiveDisplaySpanBuffer gePrimitiveInitializeProcessing gePrimitiveMergeFillFrom gePrimitiveNextActiveEdgeEntry gePrimitiveNextFillEntry gePrimitiveNextGlobalEdgeEntry)('primitives-rendering' gePrimitiveRenderImage gePrimitiveRenderScanline loadRenderingState proceedRenderingImage proceedRenderingScanline storeRenderingState)('primitives-other' gePrimitiveAbortProcessing gePrimitiveCopyBuffer gePrimitiveFinishedProcessing gePrimitiveInitializeBuffer gePrimitiveRegisterExternalEdge gePrimitiveRegisterExternalFill)('allocating' allocateAETEntry: allocateGETEntry: allocateObjEntry: allocateStackEntry: allocateStackFillEntry freeStackFillEntry needAvailableSpace:)('GET processing' addEdgeToGET: createGlobalEdgeTable findNextExternalEntryFromGET getSorts:before: initializeGETProcessing quickSortGlobalEdgeTable:from:to: sortGlobalEdgeTable)('AET processing' findNextExternalFillFromAET findNextExternalUpdateFromAET indexForInsertingIntoAET: insertEdgeIntoAET: insertToAET:beforeIndex: moveAETEntryFrom:edge:x: removeFirstAETEntry resortFirstAETEntry)('FILL processing' fillSorts:before: hideFill:depth: showFill:depth: toggleFill:depth: toggleFillsOf:)('displaying' aaFirstPixelFrom:to: aaLastPixelFrom:to: adjustAALevel clearSpanBuffer displaySpanBufferAt: drawWideEdge:from: fillBitmapSpan:from:to: fillColorSpan:from:to: fillColorSpanAA:x0:x1: fillSpan:from:to: postDisplayAction)('transforming' incrementPoint:by: transformPoint:haveMatrix: transformPoint:into: transformPointX:y:into: transformPoints:haveMatrix: transformWidth:haveMatrix:)('other' accurateLengthOf:with: computeSqrt: estimatedLengthOf:with: resetGraphicsEngineStats setAALevel: smallSqrtTable squaredLengthOf:with:)('private' errorWrongIndex makeUnsignedFrom:)!!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorMaskGet	^workBuffer at: GWAAColorMask! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorMaskPut: value	^workBuffer at: GWAAColorMask put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorShiftGet	^workBuffer at: GWAAColorShift! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaColorShiftPut: value	^workBuffer at: GWAAColorShift put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:34'!aaHalfPixelGet	^workBuffer at: GWAAHalfPixel! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaHalfPixelPut: value	^workBuffer at: GWAAHalfPixel put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaLevelGet	^workBuffer at: GWAALevel! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaLevelPut: value	^workBuffer at: GWAALevel put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaScanMaskGet	^workBuffer at: GWAAScanMask! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaScanMaskPut: value	^workBuffer at: GWAAScanMask put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:35'!aaShiftGet	^workBuffer at: GWAAShift! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 00:36'!aaShiftPut: value	^workBuffer at: GWAAShift put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!aetStartGet	^workBuffer at: GWAETStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!aetStartPut: value	^workBuffer at: GWAETStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!aetUsedGet	^workBuffer at: GWAETUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!aetUsedPut: value	^workBuffer at: GWAETUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 00:43'!clearSpanBufferGet	^workBuffer at: GWClearSpanBuffer! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 00:44'!clearSpanBufferPut: value	^workBuffer at: GWClearSpanBuffer put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxXGet	^workBuffer at: GWClipMaxX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxXPut: value	^workBuffer at: GWClipMaxX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxYGet	^workBuffer at: GWClipMaxY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMaxYPut: value	^workBuffer at: GWClipMaxY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:46'!clipMinXGet	^workBuffer at: GWClipMinX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinXPut: value	^workBuffer at: GWClipMinX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinYGet	^workBuffer at: GWClipMinY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 18:47'!clipMinYPut: value	^workBuffer at: GWClipMinY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!currentYGet	^workBuffer at: GWCurrentY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 21:27'!currentYPut: value	^workBuffer at: GWCurrentY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:23'!destOffsetXGet	^workBuffer at: GWDestOffsetX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:24'!destOffsetXPut: value	^workBuffer at: GWDestOffsetX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:23'!destOffsetYGet	^workBuffer at: GWDestOffsetY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 16:24'!destOffsetYPut: value	^workBuffer at: GWDestOffsetY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMaxXGet	^workBuffer at: GWFillMaxX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:29'!fillMaxXPut: value	^workBuffer at: GWFillMaxX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMaxYGet	^workBuffer at: GWFillMaxY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMaxYPut: value	^workBuffer at: GWFillMaxY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMinXGet	^workBuffer at: GWFillMinX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMinXPut: value	^workBuffer at: GWFillMinX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillMinYGet	^workBuffer at: GWFillMinY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillMinYPut: value	^workBuffer at: GWFillMinY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillOffsetXGet	^workBuffer at: GWFillOffsetX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillOffsetXPut: value	^workBuffer at: GWFillOffsetX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!fillOffsetYGet	^workBuffer at: GWFillOffsetY! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!fillOffsetYPut: value	^workBuffer at: GWFillOffsetY put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 17:08'!firstPointListGet	^workBuffer at: GWPointListFirst! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/29/1998 17:08'!firstPointListPut: value	^workBuffer at: GWPointListFirst put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!getStartGet	^workBuffer at: GWGETStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:30'!getStartPut: value	^workBuffer at: GWGETStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:27'!getUsedGet	^workBuffer at: GWGETUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!getUsedPut: value	^workBuffer at: GWGETUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/9/1998 15:36'!incrementStat: statIndex by: value	^workBuffer at: statIndex put: (workBuffer at: statIndex) + value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!lastExportedEdgeGet	^workBuffer at: GWLastExportedEdge! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 20:11'!lastExportedEdgePut: value	^workBuffer at: GWLastExportedEdge put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 14:24'!lastExportedFillGet	^workBuffer at: GWLastExportedFill! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 14:24'!lastExportedFillPut: value	^workBuffer at: GWLastExportedFill put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedLeftXGet	^workBuffer at: GWLastExportedLeftX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedLeftXPut: value	^workBuffer at: GWLastExportedLeftX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedRightXGet	^workBuffer at: GWLastExportedRightX! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:51'!lastExportedRightXPut: value	^workBuffer at: GWLastExportedRightX put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!magicNumberGet	^workBuffer at: GWMagicIndex! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:39'!magicNumberPut: value	^workBuffer at: GWMagicIndex put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!objStartGet	^workBuffer at: GWObjStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!objStartPut: value	^workBuffer at: GWObjStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!objUsedGet	^workBuffer at: GWObjUsed! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!objUsedPut: value	^workBuffer at: GWObjUsed put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:33'!point1Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint1 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:34'!point2Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint2 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/28/1998 16:34'!point3Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint3 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 11/1/1998 03:13'!point4Get	self returnTypeC:'int *'.	^self cCoerce: workBuffer + GWPoint4 to:'int *'! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanEndAAGet	^workBuffer at: GWSpanEndAA! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanEndAAPut: value	^workBuffer at: GWSpanEndAA put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanEndGet	^workBuffer at: GWSpanEnd! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanEndPut: value	^workBuffer at: GWSpanEnd put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanSizeGet	^workBuffer at: GWSpanSize! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanSizePut: value	^workBuffer at: GWSpanSize put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!spanStartGet	^workBuffer at: GWSpanStart! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!spanStartPut: value	^workBuffer at: GWSpanStart put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!stateGet	^workBuffer at: GWState! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!statePut: value	^workBuffer at: GWState put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!stopReasonGet	^workBuffer at: GWStopReason! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:31'!stopReasonPut: value	^workBuffer at: GWStopReason put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:28'!wbSizeGet	^workBuffer at: GWSize! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:37'!wbSizePut: value	^workBuffer at: GWSize put: value! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 23:29'!wbTopGet	^workBuffer at: GWBufferTop! !!BalloonEngineBase methodsFor: 'accessing state' stamp: 'ar 10/27/1998 18:32'!wbTopPut: value	^workBuffer at: GWBufferTop put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:36'!objectHeaderOf: obj	^self makeUnsignedFrom:(objBuffer at: obj + GEObjectType)! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:36'!objectIndexOf: obj	^objBuffer at: obj + GEObjectIndex! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectIndexOf: obj put: value	^objBuffer at: obj + GEObjectIndex put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectLengthOf: obj	^objBuffer at: obj + GEObjectLength! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectLengthOf: obj put: value	^objBuffer at: obj + GEObjectLength put: value! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectTypeOf: obj	^(self makeUnsignedFrom:(objBuffer at: obj + GEObjectType)) bitAnd: GEPrimitiveTypeMask! !!BalloonEngineBase methodsFor: 'accessing objects' stamp: 'ar 11/9/1998 15:34'!objectTypeOf: obj put: value	^objBuffer at: obj + GEObjectType put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeFillsInvalidate: edge	^self objectTypeOf: edge put: 		((self objectTypeOf: edge) bitOr: GEEdgeFillsInvalid)! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeFillsValidate: edge	^self objectTypeOf: edge put: 		((self objectTypeOf: edge) bitAnd: GEEdgeFillsInvalid bitInvert32)! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeLeftFillOf: edge	^objBuffer at: edge + GEFillIndexLeft! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeLeftFillOf: edge put: value	^objBuffer at: edge + GEFillIndexLeft put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeNumLinesOf: edge	^objBuffer at: edge + GENumLines! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeNumLinesOf: edge put: value	^objBuffer at: edge + GENumLines put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeRightFillOf: edge	^objBuffer at: edge + GEFillIndexRight! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeRightFillOf: edge put: value	^objBuffer at: edge + GEFillIndexRight put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeTypeOf: edge	"Return the edge type (e.g., witout the wide edge flag)"	^(self objectTypeOf: edge) >> 1! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeXValueOf: edge	^objBuffer at: edge + GEXValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeXValueOf: edge put: value	^objBuffer at: edge + GEXValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeYValueOf: edge	^objBuffer at: edge + GEYValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeYValueOf: edge put: value	^objBuffer at: edge + GEYValue put: value! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:35'!edgeZValueOf: edge	^objBuffer at: edge + GEZValue! !!BalloonEngineBase methodsFor: 'accessing edges' stamp: 'ar 11/9/1998 15:36'!edgeZValueOf: edge put: value	^objBuffer at: edge + GEZValue put: value! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/31/1998 00:43'!wbStackClear	self wbTopPut: self wbSizeGet.! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackPop: nItems	self wbTopPut: self wbTopGet + nItems.! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/30/1998 17:16'!wbStackPush: nItems	(self allocateStackEntry: nItems) ifFalse:[^false].	self wbTopPut: self wbTopGet - nItems.	^true! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 10/30/1998 17:17'!wbStackSize	^self wbSizeGet - self wbTopGet! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackValue: index	^workBuffer at: self wbTopGet + index! !!BalloonEngineBase methodsFor: 'accessing stack' stamp: 'ar 11/9/1998 15:34'!wbStackValue: index put: value	^workBuffer at: self wbTopGet + index put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 11/7/1998 22:25'!fillTypeOf: fill	^((self objectTypeOf: fill) bitAnd: GEPrimitiveFillMask) >> 8! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:08'!stackFillDepth: index	^self wbStackValue: index+1! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:08'!stackFillDepth: index put: value	^self wbStackValue: index+1 put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:24'!stackFillEntryLength	^2! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:10'!stackFillSize	^self wbStackSize! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:09'!stackFillValue: index	^self wbStackValue: index! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:09'!stackFillValue: index put: value	^self wbStackValue: index put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:28'!topFill	self stackFillSize = 0		ifTrue:[^0]		ifFalse:[^self topFillValue].! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillDepth	^self stackFillDepth: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillDepthPut: value	^self stackFillDepth: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillValue	^self stackFillValue: self stackFillSize - self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'accessing fills' stamp: 'ar 10/30/1998 19:27'!topFillValuePut: value	^self stackFillValue: self stackFillSize - self stackFillEntryLength put: value! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/9/1998 16:12'!loadArrayMatrixFrom: matrixOop	"Load a 2x3 matrix from the given array."	| value |	self inline: false.	0 to: 5 do:[:i|		value _ interpreterProxy fetchPointer: i ofObject: matrixOop.		((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])			ifFalse:[^interpreterProxy primitiveFail].		(interpreterProxy isIntegerObject: value)			ifTrue:[edgeTransform at: i put: 				(self cCoerce: (interpreterProxy integerValueOf: value) asFloat to:'float')]			ifFalse:[edgeTransform at: i put: 				(self cCoerce: (interpreterProxy floatValueOf: value) to: 'float')].	].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/11/1998 22:21'!loadEdgeStateFrom: edgeOop	| edge |	self inline: false.	edge _ self lastExportedEdgeGet.	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^interpreterProxy primitiveFail].	self edgeXValueOf: edge 		put: (interpreterProxy fetchInteger: ETXValueIndex ofObject: edgeOop).	self edgeYValueOf: edge 		put: (interpreterProxy fetchInteger: ETYValueIndex ofObject: edgeOop).	self edgeZValueOf: edge 		put: (interpreterProxy fetchInteger: ETZValueIndex ofObject: edgeOop).	self edgeNumLinesOf: edge 		put: (interpreterProxy fetchInteger: ETLinesIndex ofObject: edgeOop).	^edge! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/9/1998 16:12'!loadMatrixFrom: matrixOop	"Load a 2x3 transformation matrix from the given oop.	Return true if the matrix is not nil, false otherwise"	self inline: false.	matrixOop = interpreterProxy nilObject ifTrue:[^false].	(interpreterProxy isIntegerObject: matrixOop)		ifTrue:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: matrixOop) = 6 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: matrixOop) 		ifTrue:[self loadWordMatrixFrom: matrixOop]		ifFalse:[self loadArrayMatrixFrom: matrixOop].	"Add the fill offset to the matrix"	edgeTransform at: 2 put: 		(self cCoerce: (edgeTransform at: 2) + self destOffsetXGet asFloat to:'float').	edgeTransform at: 5 put: 		(self cCoerce: (edgeTransform at: 5) + self destOffsetYGet asFloat to:'float').	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/27/1998 21:24'!loadPoint: pointArray from: pointOop	"Load the contents of pointOop into pointArray"	| value |	self inline: false.	self var: #pointArray declareC:'int *pointArray'.	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint 		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchPointer: 0 ofObject: pointOop.	((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isIntegerObject: value)		ifTrue:[pointArray at: 0 put: (interpreterProxy integerValueOf: value)]		ifFalse:[pointArray at: 0 put: (interpreterProxy floatValueOf: value) asInteger].	value _ interpreterProxy fetchPointer: 1 ofObject: pointOop.	((interpreterProxy isIntegerObject: value) or:[interpreterProxy isFloatObject: value])		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isIntegerObject: value)		ifTrue:[pointArray at: 1 put: (interpreterProxy integerValueOf: value)]		ifFalse:[pointArray at: 1 put: (interpreterProxy floatValueOf: value) asInteger].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 00:46'!loadSpanBufferFrom: spanOop	"Load the span buffer from the given oop."	self inline: false.	(interpreterProxy fetchClassOf: spanOop) = (interpreterProxy classBitmap) ifFalse:[^false].	spanBuffer _ interpreterProxy firstIndexableField: spanOop.	"Leave last entry unused to avoid complications"	self spanSizePut: (interpreterProxy slotSizeOf: spanOop) - 1.	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/9/1998 16:13'!loadWordMatrixFrom: matrixOop	"Load a 2x3 float array matrix from the given oop"	| floatPtr |	self inline: false.	self var: #floatPtr declareC:'float *floatPtr'.	floatPtr _ self cCoerce: (interpreterProxy firstIndexableField: matrixOop) to: 'float *'.	0 to: 5 do:[:i| edgeTransform at: i put: (floatPtr at: i)].! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 19:37'!loadWorkBufferFrom: wbOop	"Load the working buffer from the given oop"	self inline: false.	(interpreterProxy isIntegerObject: wbOop) ifTrue:[^false].	(interpreterProxy isWords: wbOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: wbOop) < GWMinimalSize ifTrue:[^false].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	self magicNumberGet = GWMagicNumber ifFalse:[^false].	"Sanity checks"	(self wbSizeGet = (interpreterProxy slotSizeOf: wbOop)) ifFalse:[^false].	self objStartGet = GWHeaderSize ifFalse:[^false].	"Load buffers"	objBuffer _ workBuffer + self objStartGet.	getBuffer _ objBuffer + self objUsedGet.	aetBuffer _ getBuffer + self getUsedGet.	"Make sure we don't exceed the work buffer"	GWHeaderSize + self objUsedGet + self getUsedGet + self aetUsedGet > self wbSizeGet ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 11/11/1998 22:06'!quickLoadEngineFrom: engineOop	"Load the minimal required state from the engineOop, e.g., just the work buffer."	self inline: false.	interpreterProxy failed ifTrue:[^false].	(interpreterProxy isIntegerObject: engineOop) ifTrue:[^false].	(interpreterProxy isPointers: engineOop) ifFalse:[^false].	(interpreterProxy slotSizeOf: engineOop) < BEBalloonEngineSize ifTrue:[^false].	engine _ engineOop.	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engineOop))			ifFalse:[^false].	self stopReasonPut: 0.	engineStopped _ false.	^true! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/28/1998 21:06'!quickLoadEngineFrom: oop requiredState: requiredState	self inline: false.	(self quickLoadEngineFrom: oop) ifFalse:[^false].	self stateGet = requiredState ifTrue:[^true].	self stopReasonPut: GErrorBadState.	^false! !!BalloonEngineBase methodsFor: 'loading state' stamp: 'ar 10/31/1998 17:23'!quickLoadEngineFrom: oop requiredState: requiredState or: alternativeState	self inline: false.	(self quickLoadEngineFrom: oop) ifFalse:[^false].	self stateGet = requiredState ifTrue:[^true].	self stateGet = alternativeState ifTrue:[^true].	self stopReasonPut: GErrorBadState.	^false! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/11/1998 22:21'!storeEdgeStateFrom: edge into: edgeOop	self inline: false.	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy storeInteger: ETIndexIndex ofObject: edgeOop withValue: 		(self objectIndexOf: edge).	interpreterProxy storeInteger: ETXValueIndex ofObject: edgeOop withValue: 		(self edgeXValueOf: edge).	interpreterProxy storeInteger: ETYValueIndex ofObject: edgeOop withValue: 		(self currentYGet).	interpreterProxy storeInteger: ETZValueIndex ofObject: edgeOop withValue: 		(self edgeZValueOf: edge).	interpreterProxy storeInteger: ETLinesIndex ofObject: edgeOop withValue: 		(self edgeNumLinesOf: edge).	self lastExportedEdgePut: edge.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 10/28/1998 19:10'!storeEngineStateInto: oop	"Nothing to do yet"! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/11/1998 22:24'!storeFillStateInto: fillOop	| fillIndex leftX rightX |	self inline: false.	fillIndex _ self lastExportedFillGet.	leftX _ self lastExportedLeftXGet.	rightX _ self lastExportedRightXGet.	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy storeInteger: FTIndexIndex ofObject: fillOop withValue: 		(self objectIndexOf: fillIndex).	interpreterProxy storeInteger: FTMinXIndex ofObject: fillOop withValue: leftX.	interpreterProxy storeInteger: FTMaxXIndex ofObject: fillOop withValue: rightX.	interpreterProxy storeInteger: FTYValueIndex ofObject: fillOop withValue: self currentYGet.! !!BalloonEngineBase methodsFor: 'storing state' stamp: 'ar 11/9/1998 15:34'!storeStopStateIntoEdge: edgeOop fill: fillOop	| reason edge |	reason _ self stopReasonGet.	reason = GErrorGETEntry ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1.	].	reason = GErrorFillEntry ifTrue:[		self storeFillStateInto: fillOop.	].	reason = GErrorAETEntry ifTrue:[		edge _ aetBuffer at: self aetStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		"Do not advance to the next aet entry yet"		"self aetStartPut: self aetStartGet + 1."	].! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/9/1998 15:34'!areEdgeFillsValid: edge	^((self objectHeaderOf: edge) bitAnd: GEEdgeFillsInvalid) = 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/31/1998 17:06'!finishedProcessing	"Return true if processing is finished"	^self stateGet = GEStateCompleted! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/29/1998 19:36'!isEdge: edge	| type |	type _ self objectTypeOf: edge.	type > GEPrimitiveEdgeMask ifTrue:[^false].	^((self objectTypeOf: edge) bitAnd: GEPrimitiveEdgeMask) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/7/1998 21:28'!isFill: fill	^(self isFillColor: fill) or:[self isRealFill: fill]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/29/1998 19:31'!isFillColor: fill	^((self makeUnsignedFrom: fill) bitAnd: 16rFF000000) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/27/1998 23:36'!isObject: obj	^obj >= 0 and:[obj < self objUsedGet]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/7/1998 21:28'!isRealFill: fill	^((self objectTypeOf: fill) bitAnd: GEPrimitiveFillMask) ~= 0! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/31/1998 23:12'!isStackEntry: entry	^entry >= self wbTopGet and:[entry < self wbSizeGet]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 10/30/1998 17:38'!isStackIndex: index	^index >= 0 and:[index < self wbStackSize]! !!BalloonEngineBase methodsFor: 'testing' stamp: 'ar 11/9/1998 15:36'!isWide: object	^((self objectTypeOf: object) bitAnd: GEPrimitiveWide) ~= 0! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:23'!gePrimitiveGetAALevel	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self aaLevelGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/14/1998 02:40'!gePrimitiveGetClipRect	| rectOop pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMinXGet yValue: self clipMinYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: pointOop.	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMaxXGet yValue: self clipMaxYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: pointOop.	interpreterProxy pop: 2.	interpreterProxy push: rectOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetCounts	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWCountInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWCountFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWCountNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWCountAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWCountNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWCountMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWCountDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWCountNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWCountChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/11/1998 22:05'!gePrimitiveGetFailureReason	"Return the reason why the last operation failed."	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	"Note -- don't call loadEngineFrom here because this will override the stopReason with Zero"	(interpreterProxy isIntegerObject: engine) ifTrue:[^false].	(interpreterProxy isPointers: engine) ifFalse:[^false].	(interpreterProxy slotSizeOf: engine) < BEBalloonEngineSize ifTrue:[^false].	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy makePointwithxValue: self destOffsetXGet yValue: self destOffsetYGet.	interpreterProxy pop: 1.	interpreterProxy push: pointOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:25'!gePrimitiveGetTimes	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWTimeInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWTimeFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWTimeNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWTimeAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWTimeNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWTimeMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWTimeDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWTimeNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWTimeChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:23'!gePrimitiveSetAALevel	| level |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	level _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self setAALevel: level.	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leace rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:27'!gePrimitiveSetClipRect	| rectOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: rectOop).	self loadPoint: self point2Get from: (interpreterProxy fetchPointer: 1 ofObject: rectOop).	interpreterProxy failed ifFalse:[		self clipMinXPut: (self point1Get at: 0).		self clipMinYPut: (self point1Get at: 1).		self clipMaxXPut: (self point2Get at: 0).		self clipMaxYPut: (self point2Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 11/10/1998 21:27'!gePrimitiveSetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: pointOop.	interpreterProxy failed ifFalse:[		self destOffsetXPut: (self point1Get at: 0).		self destOffsetYPut: (self point1Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:23'!gePrimitiveAddActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForEdge)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self needAvailableSpace: 1) 		ifFalse:[^interpreterProxy primitiveFail].	(self edgeNumLinesOf: edge) > 0 ifTrue:[		self insertEdgeIntoAET: edge.	].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Back to adding edges from GET"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	self incrementStat: GWCountAddAETEntry by: 1.	self incrementStat: GWTimeAddAETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:24'!gePrimitiveChangedActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingChange)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self edgeNumLinesOf: edge) = 0 		ifTrue:[	self removeFirstAETEntry]		ifFalse:[	self resortFirstAETEntry.				self aetStartPut: self aetStartGet + 1].	self statePut: GEStateUpdateEdges. "Back to updating edges"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	self incrementStat: GWCountChangeAETEntry by: 1.	self incrementStat: GWTimeChangeAETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:05'!gePrimitiveDisplaySpanBuffer	"Note: Must load bitBlt and spanBuffer"	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateBlitBuffer)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[		self displaySpanBufferAt: self currentYGet.		self postDisplayAction.	].	self finishedProcessing ifFalse:[		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		self statePut: GEStateUpdateEdges].	self storeEngineStateInto: engine.	self incrementStat: GWCountDisplaySpan by: 1.	self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:06'!gePrimitiveInitializeProcessing	"Note: No need to load bitBlt but must load spanBuffer"	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked) 		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for clear operation"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	self initializeGETProcessing.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Initialized"	interpreterProxy failed ifFalse:[self storeEngineStateInto: engine].	self incrementStat: GWCountInitializing by: 1.	self incrementStat: GWTimeInitializing by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:23'!gePrimitiveMergeFillFrom	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop bitsOop value |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	bitsOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForFill)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for merging the fill"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check bitmap"	(interpreterProxy fetchClassOf: bitsOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	"Check fillOop"	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize		ifTrue:[^interpreterProxy primitiveFail].	"Check if this was the fill we have exported"	value _ interpreterProxy fetchInteger: FTIndexIndex ofObject: fillOop.	(self objectIndexOf: self lastExportedFillGet) = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMinXIndex ofObject: fillOop.	self lastExportedLeftXGet = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMaxXIndex ofObject: fillOop.	self lastExportedRightXGet = value		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: bitsOop) < (self lastExportedRightXGet - self lastExportedLeftXGet)		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	self fillBitmapSpan: (interpreterProxy firstIndexableField: bitsOop)		from: self lastExportedLeftXGet		to: self lastExportedRightXGet.	self statePut: GEStateScanningAET. "Back to scanning AET"	self storeEngineStateInto: engine.	interpreterProxy pop: 2. "Leave rcvr on stack"	self incrementStat: GWCountMergeFill by: 1.	self incrementStat: GWTimeMergeFill by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:26'!gePrimitiveNextActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUpdateEdges or: GEStateCompleted)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ false.	self stateGet = GEStateCompleted ifFalse:[		hasEdge _ self findNextExternalUpdateFromAET.		hasEdge ifTrue:[			edge _ aetBuffer at: self aetStartGet.			self storeEdgeStateFrom: edge into: edgeOop.			"Do not advance to the next aet entry yet"			"self aetStartPut: self aetStartGet + 1."			self statePut: GEStateWaitingChange. "Wait for changed edge"		] ifFalse:[self statePut: GEStateAddingFromGET]. "Start over"	].	interpreterProxy failed ifTrue:[^nil].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	self incrementStat: GWCountNextAETEntry by: 1.	self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/11/1998 22:06'!gePrimitiveNextFillEntry	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop hasFill |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateScanningAET)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for internal handling of fills"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check if we have to clear the span buffer before proceeding"	(self clearSpanBufferGet = 0) ifFalse:[		(self currentYGet bitAnd: self aaScanMaskGet) = 0			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0].	hasFill _ self findNextExternalFillFromAET.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	hasFill ifTrue:[self storeFillStateInto: fillOop].	interpreterProxy failed ifFalse:[		hasFill			ifTrue:[	self statePut: GEStateWaitingForFill]			ifFalse:[	self wbStackClear.					self spanEndAAPut: 0.					self statePut: GEStateBlitBuffer].		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushBool: hasFill not.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 11/10/1998 21:26'!gePrimitiveNextGlobalEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateAddingFromGET)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ self findNextExternalEntryFromGET.	hasEdge ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1].	interpreterProxy failed ifTrue:[^nil].	hasEdge		ifTrue:[	self statePut: GEStateWaitingForEdge] "Wait for adding edges"		ifFalse:[ "Start scanning the AET"				self statePut: GEStateScanningAET.				self clearSpanBufferPut: 1. "Clear span buffer at next entry"				self aetStartPut: 0.				self wbStackClear].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	self incrementStat: GWCountNextGETEntry by: 1.	self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:21'!gePrimitiveRenderImage	"Start/Proceed rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish this scan line"	engineStopped ifTrue:[^self storeRenderingState].	self proceedRenderingImage. "And go on as usual"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:21'!gePrimitiveRenderScanline	"Start rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish the current scan line"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/11/1998 22:24'!loadRenderingState	"Load the entire state from the interpreter for the rendering primitives"	| edgeOop fillOop state |	self inline: false.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	edgeOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^false].	(self quickLoadEngineFrom: engine)		ifFalse:[^false].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^false].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^false].	"Check edgeOop and fillOop"	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^false].	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^false].	"Note: Rendering can only take place if we're not in one of the intermediate	(e.g., external) states."	state _ self stateGet.	(state = GEStateWaitingForEdge or:[		state = GEStateWaitingForFill or:[			state = GEStateWaitingChange]]) ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 11/5/1998 21:45'!proceedRenderingImage	"This is the main rendering entry"	| external |	self inline: false.	[self finishedProcessing] whileFalse:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalEntryFromGET.		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self stopReasonPut: GErrorGETEntry.			self statePut: GEStateWaitingForEdge.			^engineStopped _ true.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		geProfileTime _ self ioMicroMSecs.		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self stopReasonPut: GErrorFillEntry.			self statePut: GEStateWaitingForFill.			^engineStopped _ true.		].		self wbStackClear.		self spanEndAAPut: 0.		geProfileTime _ self ioMicroMSecs.		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalUpdateFromAET.		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self stopReasonPut: GErrorAETEntry.			self statePut: GEStateWaitingChange.			^engineStopped _ true.		].	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 17:29'!proceedRenderingScanline	"Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween."	"This is the main rendering entry"	| external state |	self inline: false.	state _ self stateGet.	state = GEStateUnlocked ifTrue:[		self initializeGETProcessing.		engineStopped ifTrue:[^0].		state _ GEStateAddingFromGET.	]. 	state = GEStateAddingFromGET ifTrue:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalEntryFromGET.		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self stopReasonPut: GErrorGETEntry.			self statePut: GEStateWaitingForEdge.			^engineStopped _ true.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		state _ GEStateScanningAET.	].	state = GEStateScanningAET ifTrue:[		geProfileTime _ self ioMicroMSecs.		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		self incrementStat: GWCountNextFillEntry by: 1.		self incrementStat: GWTimeNextFillEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self stopReasonPut: GErrorFillEntry.			self statePut: GEStateWaitingForFill.			^engineStopped _ true.		].		state _ GEStateBlitBuffer.		self wbStackClear.		self spanEndAAPut: 0.	].	state = GEStateBlitBuffer ifTrue:[		geProfileTime _ self ioMicroMSecs.		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		state _ GEStateUpdateEdges.		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.	].	state = GEStateUpdateEdges ifTrue:[		geProfileTime _ self ioMicroMSecs.		external _ self findNextExternalUpdateFromAET.		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (self ioMicroMSecs - geProfileTime).		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self stopReasonPut: GErrorAETEntry.			self statePut: GEStateWaitingChange.			^engineStopped _ true.		].		self statePut: GEStateAddingFromGET.	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 10/31/1998 23:54'!storeRenderingState	self inline: false.	interpreterProxy failed ifTrue:[^nil].	engineStopped ifTrue:[		"Check the stop reason and store the required information"		self storeStopStateIntoEdge: (interpreterProxy stackObjectValue: 1) 			fill: (interpreterProxy stackObjectValue: 0).	].	self storeEngineStateInto: engine.	interpreterProxy pop: 3.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/31/1998 17:23'!gePrimitiveAbortProcessing	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	self statePut: GEStateCompleted.	self storeEngineStateInto: engine.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/29/1998 16:24'!gePrimitiveCopyBuffer	| buf1 buf2 diff src dst |	self export: true.	self inline: false.	self var: #src declareC:'int * src'.	self var: #dst declareC:'int * dst'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	buf2 _ interpreterProxy stackObjectValue: 0.	buf1 _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	"Make sure the old buffer is properly initialized"	(self loadWorkBufferFrom: buf1) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the buffers are of the same type"	(interpreterProxy fetchClassOf: buf1) = (interpreterProxy fetchClassOf: buf2)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure buf2 is at least of the size of buf1"	diff _ (interpreterProxy slotSizeOf: buf2) - (interpreterProxy slotSizeOf: buf1).	diff < 0 ifTrue:[^interpreterProxy primitiveFail].	"Okay - ready for copying. First of all just copy the contents up to wbTop"	src _ workBuffer.	dst _ interpreterProxy firstIndexableField: buf2.	0 to: self wbTopGet-1 do:[:i|		dst at: i put: (src at: i).	].	"Adjust wbSize and wbTop in the new buffer"	dst at: GWBufferTop put: self wbTopGet + diff.	dst at: GWSize put: self wbSizeGet + diff.	"Now copy the entries from wbTop to wbSize"	src _ src + self wbTopGet.	dst _ dst + self wbTopGet + diff.	0 to: (self wbSizeGet - self wbTopGet - 1) do:[:i|		dst at: i put: (src at: i).	].	"Okay, done. Check the new buffer by loading the state from it"	(self loadWorkBufferFrom: buf2) 		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 10/31/1998 17:05'!gePrimitiveFinishedProcessing	| finished |	self export: true.	self inline: false.	geProfileTime _ self ioMicroMSecs.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	finished _ self finishedProcessing.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: finished.	self incrementStat: GWCountFinishTest by: 1.	self incrementStat: GWTimeFinishTest by: (self ioMicroMSecs - geProfileTime).! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/9/1998 17:04'!gePrimitiveInitializeBuffer	| wbOop size |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	wbOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: wbOop) 		ifFalse:[^interpreterProxy primitiveFail].	(size _ interpreterProxy slotSizeOf: wbOop) < GWMinimalSize		ifTrue:[^interpreterProxy primitiveFail].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	objBuffer _ workBuffer + GWHeaderSize.	self magicNumberPut: GWMagicNumber.	self wbSizePut: size.	self wbTopPut: size.	self statePut: GEStateUnlocked.	self objStartPut: GWHeaderSize.	self objUsedPut: 4.	"Dummy fill object"	self objectTypeOf: 0 put: GEPrimitiveFill.	self objectLengthOf: 0 put: 4.	self objectIndexOf: 0 put: 0.	self getStartPut: 0.	self getUsedPut: 0.	self aetStartPut: 0.	self aetUsedPut: 0.	self stopReasonPut: 0.	self clipMinXPut: 0.	self clipMaxXPut: 0.	self clipMinYPut: 0.	self clipMaxYPut: 0.	self resetGraphicsEngineStats.	interpreterProxy pop: 2.	interpreterProxy push: wbOop.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/10/1998 21:26'!gePrimitiveRegisterExternalEdge	| rightFillIndex leftFillIndex initialZ initialY initialX index  edge |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	initialZ _ interpreterProxy stackIntegerValue: 2.	initialY _ interpreterProxy stackIntegerValue: 3.	initialX _ interpreterProxy stackIntegerValue: 4.	index _ interpreterProxy stackIntegerValue: 5.	engine _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(self allocateObjEntry: GEBaseEdgeSize) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	(leftFillIndex = 0 or:[(self isFillColor: leftFillIndex) or:[		((self isObject: leftFillIndex) and:[self isFill: leftFillIndex])]]) 			ifFalse:[^interpreterProxy primitiveFail].	(rightFillIndex = 0 or:[(self isFillColor: rightFillIndex) or:[		((self isObject: rightFillIndex) and:[self isFill: rightFillIndex])]]) 			ifFalse:[^interpreterProxy primitiveFail].	edge _ self objUsedGet.	self objUsedPut: edge + GEBaseEdgeSize.	"Install type and length"	self objectTypeOf: edge put: GEPrimitiveEdge.	self objectLengthOf: edge put: GEBaseEdgeSize.	self objectIndexOf: edge put: index.	"Install remaining stuff"	self edgeXValueOf: edge put: initialX.	self edgeYValueOf: edge put: initialY.	self edgeZValueOf: edge put: initialZ.	self edgeLeftFillOf: edge put: leftFillIndex.	self edgeRightFillOf: edge put: rightFillIndex.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 11/10/1998 21:26'!gePrimitiveRegisterExternalFill	| index  fill |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1 		ifFalse:[^interpreterProxy primitiveFail].	index _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Note: We *must* not allocate any fill with index 0"	fill _ 0.	[fill = 0] whileTrue:[		(self allocateObjEntry: GEBaseEdgeSize) 			ifFalse:[^interpreterProxy primitiveFail].		fill _ self objUsedGet.		self objUsedPut: fill + GEBaseFillSize.		"Install type and length"		self objectTypeOf: fill put: GEPrimitiveFill.		self objectLengthOf: fill put: GEBaseFillSize.		self objectIndexOf: fill put: index.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushInteger: fill.	].! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!allocateAETEntry: nSlots	"Allocate n slots in the active edge table"	^self needAvailableSpace: nSlots! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/28/1998 21:06'!allocateGETEntry: nSlots	"Allocate n slots in the global edge table"	| srcIndex dstIndex |	self inline: false.	"First allocate nSlots in the AET"	(self allocateAETEntry: nSlots) ifFalse:[^false].	self aetUsedGet = 0 ifFalse:["Then move the AET upwards"		srcIndex _ self aetUsedGet.		dstIndex _ self aetUsedGet + nSlots.		1 to: self aetUsedGet do:[:i|			aetBuffer at: (dstIndex _ dstIndex - 1) put: (aetBuffer at: (srcIndex _ srcIndex - 1))].	].	aetBuffer _ aetBuffer + nSlots.	^true! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/28/1998 21:16'!allocateObjEntry: nSlots	"Allocate n slots in the object buffer"	| srcIndex dstIndex |	self inline: false.	"First allocate nSlots in the GET"	(self allocateGETEntry: nSlots) ifFalse:[^false].	self getUsedGet = 0 ifFalse:["Then move the GET upwards"		srcIndex _ self getUsedGet.		dstIndex _ self getUsedGet + nSlots.		1 to: self getUsedGet do:[:i|			getBuffer at: (dstIndex _ dstIndex - 1) put: (getBuffer at: (srcIndex _ srcIndex - 1))].	].	getBuffer _ getBuffer + nSlots.	^true! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!allocateStackEntry: nSlots	"AET and Stack allocation are symmetric"	^self needAvailableSpace: nSlots! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/30/1998 19:24'!allocateStackFillEntry	^self wbStackPush: self stackFillEntryLength! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/30/1998 19:24'!freeStackFillEntry	self wbStackPop: self stackFillEntryLength.! !!BalloonEngineBase methodsFor: 'allocating' stamp: 'ar 10/29/1998 18:37'!needAvailableSpace: nSlots	"Check if we have n slots available"	GWHeaderSize + self objUsedGet + self getUsedGet + self aetUsedGet + nSlots > self wbTopGet ifTrue:[		self stopReasonPut: GErrorNoMoreSpace.		engineStopped _ true.		^false	].	^true! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/1/1998 01:07'!addEdgeToGET: edge	self inline: false.	(self allocateGETEntry: 1) ifFalse:[^0].	"Install edge in the GET"	getBuffer at: self getUsedGet put: edge.	self getUsedPut: self getUsedGet + 1.! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/10/1998 17:52'!createGlobalEdgeTable	"Create the global edge table"	| object end |	self inline: false.	object _ 0.	end _ self objUsedGet.	[object < end] whileTrue:[		"Note: addEdgeToGET: may fail on insufficient space but that's not a problem here"		(self isEdge: object) ifTrue:[			"Check if the edge starts below fillMaxY."			(self edgeYValueOf: object) >= self fillMaxYGet ifFalse:[				self checkedAddEdgeToGET: object.			].		].		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:36'!findNextExternalEntryFromGET	"Check the global edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, initialize the the edge and add it to the AET"	| yValue edge type |	yValue _ self currentYGet.	"As long as we have entries in the GET"	[self getStartGet < self getUsedGet] whileTrue:[		edge _ getBuffer at: self getStartGet.		(self edgeYValueOf: edge) > yValue ifTrue:[^false]. "No more edges to add"		type _ self objectTypeOf: edge.		(type bitAnd: GEPrimitiveWideMask) = GEPrimitiveEdge 			ifTrue:[^true]. "This is an external edge"		"Note: We must make sure not to do anything with the edge if there is not		enough room in the AET"		(self needAvailableSpace: 1) ifFalse:[^false]. "No more room"		"Process the edge in the engine itself"		self dispatchOn: type in: EdgeInitTable.		"Insert the edge into the AET"		self insertEdgeIntoAET: edge.		self getStartPut: self getStartGet + 1.	].	"No entries in GET"	^false! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/28/1998 21:07'!getSorts: edge1 before: edge2	"Return true if the edge at index i should sort before the edge at index j."	| diff |	self inline: false.	edge1 = edge2 ifTrue:[^true].	"First, sort by Y"	diff _ (self edgeYValueOf: edge1) - (self edgeYValueOf: edge2).	diff = 0 ifFalse:[^diff < 0].	"Then, by X"	diff _ (self edgeXValueOf: edge1) - (self edgeXValueOf: edge2).	^diff < 0! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 11/15/1998 02:06'!initializeGETProcessing	"Initialization stuff that needs to be done before any processing can take place."	self inline: false.	"Make sure aaLevel is initialized"	self setAALevel: self aaLevelGet.	self clipMinXGet < 0 ifTrue:[self clipMinXPut: 0].	self clipMaxXGet > self spanSizeGet ifTrue:[self clipMaxXPut: self spanSizeGet].	"Convert clipRect to aaLevel"	self fillMinXPut: self clipMinXGet << self aaShiftGet.	self fillMinYPut: self clipMinYGet << self aaShiftGet.	self fillMaxXPut: self clipMaxXGet << self aaShiftGet.	self fillMaxYPut: self clipMaxYGet << self aaShiftGet.	"Reset GET and AET"	self getUsedPut: 0.	self aetUsedPut: 0.	getBuffer _ aetBuffer _ objBuffer + self objUsedGet.	"Create the global edge table"	self createGlobalEdgeTable.	engineStopped ifTrue:[^nil].	self getUsedGet = 0 ifTrue:[		"Nothing to do"		self currentYPut: self fillMaxYGet.		^0].	"Sort entries in the GET"	self sortGlobalEdgeTable.	"Find the first y value to be processed"	self currentYPut: (self edgeYValueOf: (getBuffer at: 0)).	self currentYGet < self fillMinYGet ifTrue:[self currentYPut: self fillMinYGet].	"Load and clear the span buffer"	self spanStartPut: 0.	self spanEndPut: (self spanSizeGet << self aaShiftGet) - 1.	self clearSpanBuffer. "@@: Is this really necessary?!!"! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/27/1998 17:55'!quickSortGlobalEdgeTable: array from: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	"Note: The original loop has been heavily re-written for C translation"	| di dij dj tt ij k l n tmp again before |	self var: #array declareC:'int *array'.	self inline: false.	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^0].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	before _ self getSorts: di before: dj. "i.e., should di precede dj?"	before ifFalse:[		tmp _ array at: i.		array at: i put: (array at: j).		array at: j put: tmp.		tt _ di.	di _ dj.	dj _ tt].	n <= 2 ifTrue:[^0].	"More than two elements."	ij _ (i + j) // 2.  "ij is the midpoint of i and j."	dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."	before _ (self getSorts: di before: dij). "i.e. should di precede dij?"	before ifTrue:[		before _ (self getSorts: dij before: dj). "i.e., should dij precede dj?"		before ifFalse:["i.e., should dij precede dj?"			tmp _ array at: j.			array at: j put: (array at: ij).			array at: ij put: tmp.			dij _ dj]	] ifFalse:[  "i.e. di should come after dij"		tmp _ array at: i.		array at: i put: (array at: ij).		array at: ij put: tmp.		 dij _ di].	n <= 3 ifTrue:[^0].	 "More than three elements."	"Find k>i and l<j such that dk,dij,dl are in reverse order.	Swap k and l.  Repeat this procedure until k and l pass each other."	k _ i.	l _ j.	again _ true.	[again] whileTrue:[		before _ true.		[before] whileTrue:[			k <= (l _ l - 1)				ifTrue:[	tmp _ array at: l.						before _ self getSorts: dij before: tmp]				ifFalse:[before _ false].		].		before _ true.		[before] whileTrue:[			(k _ k + 1) <= l				ifTrue:[	tmp _ array at: k.						before _ self getSorts: tmp before: dij]				ifFalse:[before _ false]].		again _ k <= l.		again ifTrue:[			tmp _ array at: k.			array at: k put: (array at: l).			array at: l put: tmp]].	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."	self quickSortGlobalEdgeTable: array from: i to: l.	self quickSortGlobalEdgeTable: array from: k to: j.! !!BalloonEngineBase methodsFor: 'GET processing' stamp: 'ar 10/27/1998 23:34'!sortGlobalEdgeTable	"Sort the entire global edge table"	self quickSortGlobalEdgeTable: getBuffer from: 0 to: self getUsedGet-1.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/11/1998 00:49'!findNextExternalFillFromAET	"Scan the active edge table. If there is any fill that cannot be handled by the engine itself,  return true. Otherwise handle the fills and return false."	| leftEdge rightEdge leftX rightX fill |"self currentYGet >= 680 ifTrue:[self printAET.self halt.]."	self inline: false.	leftX _ rightX _ self fillMaxXGet.	[self aetStartGet < self aetUsedGet] whileTrue:[		leftEdge _ rightEdge _ aetBuffer at: self aetStartGet.		"TODO: We should check if leftX from last operation 			is  greater than leftX from next edge.			Currently, we rely here on spanEndAA			from the span buffer fill."		leftX _ rightX _ self edgeXValueOf: leftEdge.		leftX >= self fillMaxXGet ifTrue:[^false]. "Nothing more visible"		"Check if we need to draw the edge"		(self isWide: leftEdge) ifTrue:[			leftX _ rightX _ self drawWideEdge: leftEdge from: leftX.		].		(self areEdgeFillsValid: leftEdge) ifTrue:[			self toggleFillsOf: leftEdge. "Adjust the fills"			engineStopped ifTrue:[^false].		].		self aetStartPut: self aetStartGet + 1.		self aetStartGet < self aetUsedGet ifTrue:[			rightEdge _ aetBuffer at: self aetStartGet.			rightX _ self edgeXValueOf: rightEdge.			rightX >= self fillMinXGet ifTrue:["This is the visible portion"				"Fetch the currently active fill"				fill _ self makeUnsignedFrom: self topFill.				fill = 0 ifFalse:[self fillSpan: fill from: leftX to: rightX]			].		].	].	"Note: Due to pre-clipping we may have to draw remaining stuff with the last fill"	rightX < self fillMaxXGet ifTrue:[		fill _ self makeUnsignedFrom: self topFill.		fill = 0 ifFalse:[self fillSpan: fill from: rightX to: self fillMaxXGet].	].	^false! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 11/9/1998 15:36'!findNextExternalUpdateFromAET	"Check the active edge table for any entries that cannot be handled by the engine itself.	If there are any, return true. Otherwise, step the the edge to the next y value."	| edge count type |	self inline: false.	[self aetStartGet < self aetUsedGet] whileTrue:[		edge _ aetBuffer at: self aetStartGet.		count _ (self edgeNumLinesOf: edge) - 1.		count = 0 ifTrue:[			"Edge at end -- remove it"			self removeFirstAETEntry		] ifFalse:[			"Store remaining lines back"			self edgeNumLinesOf: edge put: count.			type _ self objectTypeOf: edge.			(type bitAnd: GEPrimitiveWideMask) = GEPrimitiveEdge 				ifTrue:[^true]. "This is an external edge"			self dispatchOn: type in: EdgeStepTable.			self resortFirstAETEntry.			self aetStartPut: self aetStartGet+1.		].	].	^false! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!indexForInsertingIntoAET: edge	"Find insertion point for the given edge in the AET"	| initialX index |	self inline: false.	initialX _ self edgeXValueOf: edge.	index _ 0.	[index < self aetUsedGet and:[		(self edgeXValueOf: (aetBuffer at: index)) < initialX]]			whileTrue:[index _ index + 1].	[index < self aetUsedGet and:[		(self edgeXValueOf: (aetBuffer at: index)) = initialX and:[			(self getSorts: (aetBuffer at: index) before: edge)]]]				whileTrue:[index _ index + 1].	^index! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 19:52'!insertEdgeIntoAET: edge	"Insert the edge with the given index from the global edge table into the active edge table.	The edge has already been stepped to the initial yValue -- thus remainingLines and rasterX	are both set."	| index |	self inline: false.	"Check for the number of lines remaining"	(self edgeNumLinesOf: edge) <= 0 ifTrue:[^nil]. "Nothing to do"	"Find insertion point"	index _ self indexForInsertingIntoAET: edge.	"And insert edge"	self insertToAET: edge beforeIndex: index.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!insertToAET: edge beforeIndex: index	"Insert the given edge into the AET."	| i |	self inline: false.	"Make sure we have space in the AET"	(self allocateAETEntry: 1) ifFalse:[^nil]. "Insufficient space in AET"	i _ self aetUsedGet-1.	[i < index] whileFalse:[		aetBuffer at: i+1 put: (aetBuffer at: i).		i _ i - 1.	].	aetBuffer at: index put: edge.	self aetUsedPut: self aetUsedGet + 1.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 01:39'!moveAETEntryFrom: index edge: edge x: xValue	"The entry at index is not in the right position of the AET. 	Move it to the left until the position is okay."	| newIndex |	self inline: false.	newIndex _ index.	[newIndex > 0 and:[(self edgeXValueOf: (aetBuffer at: newIndex-1)) > xValue]]		whileTrue:[	aetBuffer at: newIndex put: (aetBuffer at: newIndex-1).					newIndex _ newIndex - 1].	aetBuffer at: newIndex put: edge.! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!removeFirstAETEntry	| index |	self inline: false.	index _ self aetStartGet.	self aetUsedPut: self aetUsedGet - 1.	[index < self aetUsedGet] whileTrue:[		aetBuffer at: index put: (aetBuffer at: index + 1).		index _ index + 1.	].! !!BalloonEngineBase methodsFor: 'AET processing' stamp: 'ar 10/28/1998 21:07'!resortFirstAETEntry	| edge xValue leftEdge |	self inline: false.	self aetStartGet = 0 ifTrue:[^nil]. "Nothing to resort"	edge _ aetBuffer at: self aetStartGet.	xValue _ self edgeXValueOf: edge.	leftEdge _ aetBuffer at: (self aetStartGet - 1).	(self edgeXValueOf: leftEdge) <= xValue ifTrue:[^nil]. "Okay"	self moveAETEntryFrom: self aetStartGet edge: edge x: xValue.! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/11/1998 00:58'!fillSorts: fillEntry1 before: fillEntry2	"Return true if fillEntry1 should be drawn before fillEntry2"	| diff |	self inline: false.	"First check the depth value"	diff _ (self stackFillDepth: fillEntry1) - (self stackFillDepth: fillEntry2).	diff = 0 ifFalse:[^diff < 0].	"See the class comment for aetScanningProblems"	^(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry1)) to:'unsigned') <		(self cCoerce: (self makeUnsignedFrom: (self stackFillValue: fillEntry2)) to: 'unsigned')! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 10/30/1998 19:43'!hideFill: fillIndex depth: depth	"Make the fill style with the given index invisible"	| index newTopIndex newTop newDepth |	self inline: false.	index _ 0.	[index < self stackFillSize and:[		(self stackFillValue: index) ~= fillIndex or:[			(self stackFillDepth: index) ~= depth]]]				whileTrue:[index _ index + self stackFillEntryLength].	index >= self stackFillSize ifTrue:[^false].	index = 0 ifTrue:[		self freeStackFillEntry.		^true].	"Fill is visible - replace it with the last entry on the stack"	self stackFillValue: index put: (self stackFillValue: 0).	self stackFillDepth: index put: (self stackFillDepth: 0).	self freeStackFillEntry.	(self stackFillSize <= self stackFillEntryLength) ifTrue:[^true]. "Done"	"Find the new top fill"	newTopIndex _ 0.	index _ self stackFillEntryLength.	[index < self stackFillSize] whileTrue:[		(self fillSorts: index before: newTopIndex)			ifTrue:[newTopIndex _ index].		index _ index + self stackFillEntryLength.	].	(newTopIndex + self stackFillEntryLength = self stackFillSize) 		ifTrue:[^true]. "Top fill not changed"	newTop _ self stackFillValue: newTopIndex.	self stackFillValue: newTopIndex put: self topFillValue.	self topFillValuePut: newTop.	newDepth _ self stackFillDepth: newTopIndex.	self stackFillDepth: newTopIndex put: self topFillDepth.	self topFillDepthPut: newDepth.	^true! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 10/30/1998 19:23'!showFill: fillIndex depth: depth	self inline: false.	(self allocateStackFillEntry) ifFalse:[^nil]. "Insufficient space"	self stackFillValue: 0 put: fillIndex.	self stackFillDepth: 0 put: depth.	self stackFillSize = self stackFillEntryLength ifTrue:[^nil]. "No need to update"	(self fillSorts: 0 before: self stackFillSize - self stackFillEntryLength) ifTrue:[		"New top fill"		self stackFillValue: 0 put: self topFillValue.		self stackFillDepth: 0 put: self topFillDepth.		self topFillValuePut: fillIndex.		self topFillDepthPut: depth.	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/9/1998 15:34'!toggleFill: fillIndex depth: depth	"Make the fill style with the given index either visible or invisible"	| hidden |	self inline: false.	self stackFillSize = 0 ifTrue:[		(self allocateStackFillEntry) ifTrue:[			self topFillValuePut: fillIndex.			self topFillDepthPut: depth.		].	] ifFalse:[		hidden _ self hideFill: fillIndex depth: depth.		hidden ifFalse:[self showFill: fillIndex depth: depth].	].! !!BalloonEngineBase methodsFor: 'FILL processing' stamp: 'ar 11/9/1998 15:34'!toggleFillsOf: edge	| depth fillIndex |	self inline: false.	(self needAvailableSpace: self stackFillEntryLength * 2) 		ifFalse:[^nil]. "Make sure we have enough space left"	depth _ self edgeZValueOf: edge.	fillIndex _ self edgeLeftFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth].	fillIndex _ self edgeRightFillOf: edge.	fillIndex = 0 ifFalse:[self toggleFill: fillIndex depth: depth].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:53'!aaFirstPixelFrom: leftX to: rightX	"Common function to compute the first full pixel for AA drawing"	| firstPixel |	self inline: true.	firstPixel _ (leftX + self aaLevelGet - 1) bitAnd: (self aaLevelGet - 1) bitInvert32.	firstPixel > rightX 		ifTrue:[^rightX]		ifFalse:[^firstPixel]! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:53'!aaLastPixelFrom: leftX to: rightX	"Common function to compute the last full pixel for AA drawing"	self inline: true.	^(rightX - 1) bitAnd: (self aaLevelGet - 1) bitInvert32.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:50'!adjustAALevel		"NOTE: 	This method is (hopefully) obsolete due to unrolling 				the fill loops to deal with full pixels."	"Adjust the span buffers values by the appropriate color offset for anti-aliasing.	We do this by replicating the top bits of each color in the lower bits. The idea is that we can scale each color value uniquely from 0 to 255 and thus fill the entire range of colors."	| adjustShift adjustMask x0 x1 pixelValue |	self inline: false.	adjustShift _ 8 - self aaColorShiftGet.	adjustMask _ self aaColorMaskGet bitInvert32.	x0 _ self spanStartGet >> self aaShiftGet.	x1 _ self spanEndGet >> self aaShiftGet.	[x0 < x1] whileTrue:[		pixelValue _ spanBuffer at: x0.		spanBuffer at: x0 put: (pixelValue bitOr: (pixelValue >> adjustShift bitAnd: adjustMask)).		x0 _ x0 + 1].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/14/1998 19:31'!clearSpanBuffer	"Clear the current span buffer.	The span buffer is only cleared in the area that has been used by the previous scan line."	| x0 x1 |	self inline: false.	x0 _ self spanStartGet >> self aaShiftGet.	x1 _ self spanEndGet >> self aaShiftGet + 1.	x0 < 0 ifTrue:[x0 _ 0].	x1 > self spanSizeGet ifTrue:[x1 _ self spanSizeGet].	[x0 < x1] whileTrue:[		spanBuffer at: x0 put: 0.		x0 _ x0 + 1].	self spanStartPut: self spanSizeGet.	self spanEndPut: 0.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/10/1998 22:05'!displaySpanBufferAt: y	"Display the span buffer at the current scan line."	| targetX0 targetX1 targetY |	self inline: false.	"self aaLevelGet > 1 ifTrue:[self adjustAALevel]."	targetX0 _ self spanStartGet >> self aaShiftGet.	targetX0 < self clipMinXGet ifTrue:[targetX0 _ self clipMinXGet].	targetX1 _ (self spanEndGet + self aaLevelGet - 1) >> self aaShiftGet.	targetX1 > self clipMaxXGet ifTrue:[targetX1 _ self clipMaxXGet].	targetY _ y >> self aaShiftGet.	(targetY < self clipMinYGet or:[targetY >= self clipMaxYGet or:[		targetX1 < self clipMinXGet or:[targetX0 >= self clipMaxXGet]]]) ifTrue:[^0].	self copyBitsFrom: targetX0 to: targetX1 at: targetY.	self showDisplayBits.! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 15:35'!drawWideEdge: edge from: leftX	"Draw the given edge starting from leftX with the edge's fill.	Return the end value of the drawing operation."	| rightX fill type lineWidth |	self inline: false. "Not for the moment"	type _ self edgeTypeOf: edge.	dispatchedValue _ edge.	self dispatchOn: type in: WideLineWidthTable.	lineWidth _ dispatchReturnValue.	self dispatchOn: type in: WideLineFillTable.	fill _ self makeUnsignedFrom: dispatchReturnValue.	fill = 0 ifTrue:[^leftX].	"self assert:(self isFillColor: fill)."	rightX _ leftX + lineWidth.	self fillSpan: fill from: leftX to: rightX.	^rightX! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 16:10'!fillBitmapSpan: bits from: leftX to: rightX	"Fill the span buffer between leftEdge and rightEdge using the given bits.	Note: We always start from zero - this avoids using huge bitmap buffers if the bitmap is to be displayed at the very far right hand side and also gives us a chance of using certain bitmaps (e.g., those with depth 32) directly."	| x0 x1 x bitX colorMask colorShift baseShift fillValue |	self inline: false.	self var: #bits declareC:'int *bits'.	x0 _ leftX.	x1 _ rightX.	bitX _ -1. "Hack for pre-increment"	self aaLevelGet = 1 ifTrue:["Speedy version for no anti-aliasing"		[x0 < x1] whileTrue:[			fillValue _ (self cCoerce: bits to: 'int *') at: (bitX _ bitX + 1).			spanBuffer at: x0 put: fillValue.			x0 _ x0 + 1.		].	] ifFalse:["Generic version with anti-aliasing"		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		baseShift _ self aaShiftGet.		[x0 < x1] whileTrue:[			x _ x0 >> baseShift.			fillValue _ (self cCoerce: bits to: 'int *') at: (bitX _ bitX + 1).			fillValue _ (fillValue bitAnd: colorMask) >> colorShift.			spanBuffer at: x put: (spanBuffer at: x) + fillValue.			x0 _ x0 + 1.		].	].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/8/1998 03:30'!fillColorSpan: pixelValue32 from: leftX to: rightX	"Fill the span buffer between leftEdge and rightEdge with the given pixel value."	| x0 x1 |	self inline: true.	"Use a unrolled version for anti-aliased fills..."	self aaLevelGet = 1		ifFalse:[^self fillColorSpanAA: pixelValue32 x0: leftX x1: rightX].	x0 _ leftX.	x1 _ rightX.	"Unroll the inner loop four times, since we're only storing data."	[x0 + 4 < x1] whileTrue:[		spanBuffer at: x0 put: pixelValue32.		spanBuffer at: x0+1 put: pixelValue32.		spanBuffer at: x0+2 put: pixelValue32.		spanBuffer at: x0+3 put: pixelValue32.		x0 _ x0+4.	].	[x0 < x1] whileTrue:[		spanBuffer at: x0 put: pixelValue32.		x0 _ x0 + 1.	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/9/1998 00:52'!fillColorSpanAA: pixelValue32 x0: leftX x1: rightX	"This is the inner loop for solid color fills with anti-aliasing.	This loop has been unrolled for speed and quality into three parts:		a) copy all pixels that fall into the first full pixel.		b) copy aaLevel pixels between the first and the last full pixel		c) copy all pixels that fall in the last full pixel"	| colorMask baseShift x idx firstPixel lastPixel aaLevel pv32 |	self inline: false. "Not now -- maybe later"	"Compute the pixel boundaries."	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	x _ leftX.	"Part a: Deal with the first n sub-pixels"	x < firstPixel ifTrue:[		pv32 _ (pixelValue32 bitAnd: self aaColorMaskGet) >> self aaColorShiftGet.		[x < firstPixel] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + 1.		].	].	"Part b: Deal with the full pixels"	x < lastPixel ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		pv32 _ (pixelValue32 bitAnd: colorMask) >> self aaShiftGet.		[x < lastPixel] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + aaLevel.		].	].	"Part c: Deal with the last n sub-pixels"	x < rightX ifTrue:[		pv32 _ (pixelValue32 bitAnd: self aaColorMaskGet) >> self aaColorShiftGet.		[x < rightX] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + pv32.			x _ x + 1.		].	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/15/1998 02:04'!fillSpan: fill from: leftX to: rightX	"Fill the span buffer from leftX to rightX with the given fill.	Clip before performing any operations. Return true if the fill must	be handled by some Smalltalk code."	| x0 x1 type |	self inline: false.	fill = 0 ifTrue:[^false]. "Nothing to do"	"Start from spEnd - we must not paint pixels twice at a scan line"	leftX < self spanEndAAGet 		ifTrue:[x0 _ self spanEndAAGet]		ifFalse:[x0 _ leftX].	rightX > (self spanSizeGet << self aaShiftGet) 		ifTrue:[x1 _ (self spanSizeGet << self aaShiftGet)]		ifFalse:[x1 _ rightX].	"Clip left and right values"	x0 < self fillMinXGet ifTrue:[x0 _ self fillMinXGet].	x1 > self fillMaxXGet ifTrue:[x1 _ self fillMaxXGet].	"Adjust start and end values of span"	x0 < self spanStartGet ifTrue:[self spanStartPut: x0].	x1 > self spanEndGet ifTrue:[self spanEndPut: x1].	x1 > self spanEndAAGet ifTrue:[self spanEndAAPut: x1].	x0 >= x1 ifTrue:[^false]. "Nothing to do"	(self isFillColor: fill) ifTrue:[		self fillColorSpan: fill from: x0 to: x1.	] ifFalse:[		"Store the values for the dispatch"		self lastExportedFillPut: fill.		self lastExportedLeftXPut: x0.		self lastExportedRightXPut: x1.		type _ self fillTypeOf: fill.		type <= 1 ifTrue:[^true].		self dispatchOn: type in: FillTable.	].	^false! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 11/8/1998 15:13'!postDisplayAction	"We have just blitted a scan line to the screen.	Do whatever seems to be a good idea here."	"Note: In the future we may check the time needed for this scan line and interrupt processing to give the Smalltalk code a chance to run at a certain time."	self inline: false.	"Check if there is any more work to do."	(self getStartGet >= self getUsedGet and:[self aetUsedGet = 0]) ifTrue:[		"No more entries to process"		self statePut: GEStateCompleted.	].	(self currentYGet >= self fillMaxYGet) ifTrue:[		"Out of clipping range"		self statePut: GEStateCompleted.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/8/1998 14:26'!incrementPoint: point by: delta	self var: #point declareC:'int *point'.	point at: 0 put: (point at: 0) + delta.	point at: 1 put: (point at: 1) + delta.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/11/1998 20:33'!transformPoint: point haveMatrix: haveMatrix	"Transform the given point. If haveMatrix is true then use the current transformation."	self var:#point declareC:'int *point'.	haveMatrix ifFalse:[		"Multiply each component by aaLevel and add a half pixel"		point at: 0 put: (point at: 0) + self destOffsetXGet * self aaLevelGet.		point at: 1 put: (point at: 1) + self destOffsetYGet * self aaLevelGet.	] ifTrue:[		"Note: AA adjustment is done in #transformPoint: for higher accuracy"		self transformPoint: point into: point.	].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/1/1998 16:59'!transformPoint: srcPoint into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This method has been rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	self inline: true.	self transformPointX: ((self cCoerce: srcPoint to: 'int *') at: 0) asFloat 		y: ((self cCoerce: srcPoint to:'int *') at: 1) asFloat		into: (self cCoerce: dstPoint to: 'int *')! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/1/1998 16:56'!transformPointX: xValue y: yValue into: dstPoint	"Transform srcPoint into dstPoint by using the currently loaded matrix"	"Note: This should be rewritten so that inlining works (e.g., removing	the declarations and adding argument coercions at the appropriate points)"	| x y |	self inline: true. "Won't help at the moment ;-("	self var: #dstPoint declareC:'int *dstPoint'.	self var: #xValue declareC: 'double xValue'.	self var: #yValue declareC: 'double yValue'.	x _ ((((edgeTransform at: 0) * xValue) +		((edgeTransform at: 1) * yValue) +		(edgeTransform at: 2)) * self aaLevelGet asFloat) asInteger.	y _ ((((edgeTransform at: 3) * xValue) +		((edgeTransform at: 4) * yValue) +		(edgeTransform at: 5)) * self aaLevelGet asFloat) asInteger.	dstPoint at: 0 put: x.	dstPoint at: 1 put: y.! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/11/1998 20:35'!transformPoints: n haveMatrix: haveMatrix	"Transform n (n=1,2,3) points.	If haveMatrix is true then the matrix contains the actual transformation."	self inline: true.	n > 0 ifTrue:[self transformPoint: self point1Get haveMatrix: haveMatrix].	n > 1 ifTrue:[self transformPoint: self point2Get haveMatrix: haveMatrix].	n > 2 ifTrue:[self transformPoint: self point3Get haveMatrix: haveMatrix].	n > 3 ifTrue:[self transformPoint: self point4Get haveMatrix: haveMatrix].! !!BalloonEngineBase methodsFor: 'transforming' stamp: 'ar 11/12/1998 13:29'!transformWidth: w haveMatrix: haveMatrix	"Transform the given width"	| deltaX deltaY destWidth destWidth2 |	self inline: false.	self var: #deltaX declareC:'double deltaX'.	self var: #deltaY declareC:'double deltaY'.	w = 0 ifTrue:[^0].	self point1Get at: 0 put: 0.	self point1Get at: 1 put: 0.	self point2Get at: 0 put: w * 256.	self point2Get at: 1 put: 0.	self point3Get at: 0 put: 0.	self point3Get at: 1 put: w * 256.	self transformPoints: 3 haveMatrix: haveMatrix.	deltaX _ ((self point2Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point2Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	deltaX _ ((self point3Get at: 0) - (self point1Get at: 0)) asFloat.	deltaY _ ((self point3Get at: 1) - (self point1Get at: 1)) asFloat.	destWidth2 _ (((deltaX * deltaX) + (deltaY * deltaY)) sqrt asInteger + 128) // 256.	destWidth2 < destWidth ifTrue:[destWidth _ destWidth2].	destWidth = 0		ifTrue:[^1]		ifFalse:[^destWidth]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/9/1998 02:06'!accurateLengthOf: deltaX with: deltaY	"Return the accurate length of the vector described by deltaX and deltaY"	| length2 |	deltaX = 0 ifTrue:[deltaY < 0 ifTrue:[^0-deltaY] ifFalse:[^deltaY]].	deltaY = 0 ifTrue:[deltaX < 0 ifTrue:[^0-deltaX] ifFalse:[^deltaX]].	length2 _ (deltaX * deltaX) + (deltaY * deltaY).	^self computeSqrt: length2! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!computeSqrt: length2	length2 < 32 		ifTrue:[^self smallSqrtTable at: length2]		ifFalse:[^(length2 asFloat sqrt + 0.5) asInteger]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 14:33'!estimatedLengthOf: deltaX with: deltaY	"Estimate the length of the vector described by deltaX and deltaY.	This method may be extremely inaccurate - use it only	if you know exactly that this doesn't matter. Otherwise	use #accurateLengthOf:width:"	| absDx absDy |	deltaX >= 0 ifTrue:[absDx _ deltaX] ifFalse:[absDx _ 0 - deltaX].	deltaY >= 0 ifTrue:[absDy _ deltaY] ifFalse:[absDy _ 0 - deltaY].	absDx > absDy 		ifTrue:[^absDx + (absDy // 2)]		ifFalse:[^absDy + (absDx // 2)]! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!resetGraphicsEngineStats	self inline: false.	workBuffer at: GWTimeInitializing put: 0.	workBuffer at: GWTimeFinishTest put: 0.	workBuffer at: GWTimeNextGETEntry put: 0.	workBuffer at: GWTimeAddAETEntry put: 0.	workBuffer at: GWTimeNextFillEntry put: 0.	workBuffer at: GWTimeMergeFill put: 0.	workBuffer at: GWTimeDisplaySpan put: 0.	workBuffer at: GWTimeNextAETEntry put: 0.	workBuffer at: GWTimeChangeAETEntry put: 0.	workBuffer at: GWCountInitializing put: 0.	workBuffer at: GWCountFinishTest put: 0.	workBuffer at: GWCountNextGETEntry put: 0.	workBuffer at: GWCountAddAETEntry put: 0.	workBuffer at: GWCountNextFillEntry put: 0.	workBuffer at: GWCountMergeFill put: 0.	workBuffer at: GWCountDisplaySpan put: 0.	workBuffer at: GWCountNextAETEntry put: 0.	workBuffer at: GWCountChangeAETEntry put: 0.	workBuffer at: GWBezierMonotonSubdivisions put: 0.	workBuffer at: GWBezierHeightSubdivisions put: 0.	workBuffer at: GWBezierOverflowSubdivisions put: 0.	workBuffer at: GWBezierLineConversions put: 0.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/7/1998 14:26'!setAALevel: level	"Set the anti-aliasing level. Three levels are supported:		1 - No antialiasing		2 - 2x2 unweighted anti-aliasing		4 - 4x4 unweighted anti-aliasing.	"	| aaLevel |	self inline: false.	level >= 4 ifTrue:[aaLevel _ 4].	(level >= 2) & (level < 4) ifTrue:[aaLevel _ 2].	level < 2 ifTrue:[aaLevel _ 1].	self aaLevelPut: aaLevel.	aaLevel = 1 ifTrue:[		self aaShiftPut: 0.		self aaColorMaskPut: 16rFFFFFFFF.		self aaScanMaskPut: 0.	].	aaLevel = 2 ifTrue:[		self aaShiftPut: 1.		self aaColorMaskPut: 16rFCFCFCFC.		self aaScanMaskPut: 1.	].	aaLevel = 4 ifTrue:[		self aaShiftPut: 2.		self aaColorMaskPut: 16rF0F0F0F0.		self aaScanMaskPut: 3.	].	self aaColorShiftPut: self aaShiftGet * 2.	self aaHalfPixelPut: self aaShiftGet.! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 15:25'!smallSqrtTable	| theTable |	self inline: false.	self returnTypeC:'int *'.	self var: #theTable declareC:'static int theTable[32] = 	{0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6}'.	^theTable! !!BalloonEngineBase methodsFor: 'other' stamp: 'ar 11/8/1998 20:57'!squaredLengthOf: deltaX with: deltaY	^(deltaX * deltaX) + (deltaY * deltaY)! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 10/29/1998 18:45'!errorWrongIndex	self error:'BalloonEngine: Fatal dispatch error'! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 10/28/1998 20:58'!makeUnsignedFrom: someIntegerValue	^someIntegerValue! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 10/31/1998 00:48'!declareCVarsIn: cg	"Buffers"	cg var: 'workBuffer' declareC:'int *workBuffer'.	cg var: 'objBuffer' declareC:'int *objBuffer'.	cg var: 'getBuffer' declareC:'int *getBuffer'.	cg var: 'aetBuffer' declareC:'int *aetBuffer'.	cg var: 'spanBuffer' declareC:'unsigned int *spanBuffer'.	cg var: 'edgeTransform' declareC: 'float edgeTransform[6]'.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/7/1998 22:26'!initialize	"BalloonEngineBase initialize"	"BalloonEnginePlugin translateDoInlining: true."	EdgeInitTable _ self initializeEdgeInitTable.	EdgeStepTable _ self initializeEdgeStepTable.	WideLineWidthTable _ self initializeWideLineWidthTable.	WideLineFillTable _ self initializeWideLineFillTable.	FillTable _ self initializeFillTable.! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 21:52'!initializeEdgeInitTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		errorWrongIndex		errorWrongIndex		stepToFirstLine		stepToFirstWideLine		stepToFirstBezier		stepToFirstWideBezier	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 21:52'!initializeEdgeStepTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		errorWrongIndex		errorWrongIndex		stepToNextLine		stepToNextWideLine		stepToNextBezier		stepToNextWideBezier	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/7/1998 22:26'!initializeFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex "Type zero - undefined"		errorWrongIndex "Type one - external fill"		fillLinearGradient "Linear gradient fill"		fillRadialGradient "Radial gradient fill"	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 23:03'!initializeWideLineFillTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		returnWideLineFill		returnWideBezierFill	)! !!BalloonEngineBase class methodsFor: 'class initialization' stamp: 'ar 11/4/1998 23:03'!initializeWideLineWidthTable	"BalloonEngineBase initialize"	^#(		errorWrongIndex		errorWrongIndex		returnWideLineWidth		returnWideBezierWidth	)! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 10/28/1998 20:48'!moduleName	^'sqBalloonEngine'! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 11/11/1998 21:56'!simulatorClass	^BalloonEngineSimulation! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:33'!a1EngineOutline	"The following is a brief outline on how the engine works.	In general, we're using a pretty straight-forward active edge approach, e.g., 	we classify all edges into three different states:		a) Waiting for processing		b) Active (e.g., being processed)		c) Finished	Before the engine starts all edges are sorted by their y-value in a so-called	'global edge table' (furthermore referred to as GET) and processed in top 	to bottom order (the edges are also sorted by x-value but this is only for 	simplifying the insertion when adding edges).	Then, we start at the first visible scan line and execute the following steps:	1) Move all edges starting at the current scan line from state a) to state b)	This step requires the GET to be sorted so that we only need to check	the first edges of the GET. After the initial state of the edge (e.g., it's current	pixel value and data required for incremental updates) the edges are then 	inserted in the 'active edge table' (called AET). The sort order in the AET is 	defined by the pixel position of each edge at the current scan line and thus 	edges are kept in increasing x-order.	This step does occur for every edge only once and is therefore not the most	time-critical part of the approach.	2) Draw the current scan line	This step includes two sub-parts. In the first part, the scan line is assembled.	This involves walking through the AET and drawing the pixels between	each two neighbour edges. Since each edge can have two associated fills	(a 'left' and a 'right' fill) we need to make sure that edges falling on the	same pixel position do not affect the painted image. This issue is discussed	in the aetScanningProblems documentation.	Wide edges (e.g., edges having an associated width) are also handled during	this step. Wide edges are always preferred over interior fills - this ensures	that the outline of an object cannot be overdrawn by any interior fill of	a shape that ends very close to the edge (for more information see wideEdges 	documentation).	After the scan is assembled it is blitted to the screen. This only happens all	'aaLevel' scan lines (for further information see the antiAliasing documentation).	This second step is done at each scan line in the image, and is usually the most	time-critical part.	3) Update all currently active edges	Updating the active edges basically means either to remove the edge from the AET	(if it is at the end y value) or incrementally computing the pixel value for the	next scan line. Based on the information gathered in the first step, this part	should be executed as fast as possible - it happens for each edge in the AET	at each scan line and may be the bottleneck if many edges are involved in	the drawing operations (see the TODO list; part of it probably deals with the	issue)."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:55'!a2AntiAliasing	"The engine currently used a very simple, but efficient anti-aliasing scheme. It is based on a square unweighted filter of size 1, 2, or 4 resulting in three levels of anti-aliasing:	* No anti-aliasing (filter size 1)	This simply draws each pixel 'as is' on the screen	* Slight anti-aliasing (filter size 2)	Doubles the rasterization size in each direction and assembles the pixel value as the medium of the four sub-pixels falling into the full pixel	* Full anti-aliasing (filter size 4)	Quadruples the rasterization in each direction and assembles the pixel value as the medium of the sixteen sub-pixels falling into the full pixelThe reason for using these three AA levels is simply efficiency of computing. Since the above filters (1x1, 2x2, 4x4) have all power of two elements (1, 4, and 16) we can compute the weighted sum of the final pixel by computing	destColor _ destColor + (srcColor // subPixels)And, since we're only working on 32bit destination buffer we do not need to compute the components of each color separately but can neatly put the entire color into a single formula:	destPixel32 _ destPixel32 + ((srcPixel32 bitAnd: aaMask) >> aaShift).with aaMask = 16rFFFFFFFF for aaLevel = 1, aaMask = 16rFCFCFCFC for aaLevel = 2, aaMask = 16rF0F0F0F0 for aaLevel = 4 and aaShift = 0, 2, or 4 for the different levels. However, while the above is efficient to compute, it also drops accuracy. So, for the 4x4 anti-aliasing we're effectively only using the high 4 bits of each color component. While is generally not a problem (we add 16 sub-pixels into this value) there is a simple arithmetic difficulty because the above cannot fill the entire range of values, e.g.,	16 * (255 // 16) = 16 * 15 = 240and not 255 as expected. We solve this problem by replicating the top n (n=0, 2, 4) bits of each component as the low bits in an adjustment step before blitting to scan line to the screen. This has the nice effect that a zero pixel value (e.g., transparent) will remain zero, a white pixel (as computed above) will result in a value of 255 for each component (defining opaque white) and each color inbetween linearly mapped between 0 and 255. "	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:35'!a3RasterizationRules	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:35'!a4WideEdges! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/7/1998 03:36'!a5AETScanningProblems	"Due to having two fill entries (one left and one right) there can be problems while scanning the active edge table. In general, the AET should look like the following (ri - regions, ei - edges, fi - fills):			|				\				|	r1		|		r2		 \		r3		|		r4			|				  \				|			e1				 e2				e3			with:		f(r1) = fLeft(e1) = 0				(empty fill, denoted -)		f(r2) = fRight(e1) = fLeft(e2)		(denoted x)		f(r3) = fRight(e2) = fLeft(e3)	(denoted o)		f(r4) = fRight(e3) = 0	However, due to integer arithmetic used during computations the AET may look like the following:			X			\|						|			 | \						|			 |   \					|	r1		 | r2 \			r3		|		r4			 |	   \					|			e1		e2				e3			In this case, the starting point of e1 and e2 have the same x value at the first scan line but e2 has been sorted before e1 (Note: This can happen in *many* cases - the above is just a very simple example). Given the above outlined fill relations we have a problem. So, for instance, using the left/right fills as defined by the edges would lead to the effect that in the first scan line region r3 is actually filled with the right fill of e1 while it should actually be filled with the right fill of e2. This leads to noticable artifacts in the image and increasing resolution does not help.	What we do here is defining an arbitrary sort order between fills (you can think of it as a depth value but the only thing that matters is that you can order the fills by this number and that the empty fill is always sorted at the end), and toggle the fills between an 'active' and an 'inactive' state at each edge. This is done as follows:	For each edge ei in the AET do:		* if fLeft(ei) isActive then removeActive(fLeft(ei)) else addActive(fLeft(ei))		* if fRight(ei) isActive then removeActive(fRight(ei)) else addActive(fRight(ei))		* draw the span from ei to ei+1 with currentActive	where addActive adds the fill to the list of currently active fills, removeActive() removes the fill from the active list and currentActive returns the fill AS DEFINED BY THE SORT ORDER from the list of active fills. Note that this does not change anything in the first example above because the list will only contain one entry (besides the empty fill). In the second case however, it will lead to the following sequence:	* toggle fLeft(e2) = f(r2) = 'x'		- makes fLeft(e2) active		- activeList = 'x'	* toggle fRight(e2) = f(r3) = 'o'		- makes fRight(e2) active		- activeList = 'xo'	* draw span from e2 to e1		Depending on the sort order between 'x' and 'o' the region will be drawn with either one of the fills. It is significant to note here that the occurence of such a problem is generally only *very* few pixels large (in the above example zero pixels) and will therefore not be visually noticable. In any case, there is a unique decision for the fill to use here and that is what we need if the problem did not happen accidentally (e.g., someone has manually changed one fill of an edge but not the fill of the opposite edge).	* toggle fLeft(e1) = f(r1) = '-'		- makes fLeft(r1) visible		- activeList = 'xo-'		[Note: empty fills are a special case. 		They can be ignored since they sort last		and the activeList can return the empty		fill if it is itself empty].	* toggle fRight(e1) = f(r2) = 'x'		- makes fRight(e1) invisible		- activeList = 'o-'	* draw span from e2 to e3		Since the active list contains (besides the empty fill) only one fill value this will be used. Fortunately, this is the correct fill because it is the fill we had initially defined for the region r2.An interesting side effect of the above is that there is no such notion as a 'left' or 'right' fill anymore. Another (not-so-nice) side effect is that the entire AET has to be scanned from the beginning even if only the last few edges actually affect the visible region.PS. I need to find a way of clipping the edges for this. More on it later..."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'documentation' stamp: 'ar 11/8/1998 00:06'!a6StuffTODO	"This is an unordered list of things to do:BalloonEnginePlugin>>stepToFirstBezierIn:at:	1)	Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure.BalloonEngineBase>>dispatchOn:in:	1)	Check what dispatches cost most and must be inlined		by an #inlinedDispatchOn:in: Probably this will be		stepping and eventually wide line stuff but we'll see.BalloonEngineBase	1)	Check which variables should become inst vars, if any.		This will remove an indirection during memory access		and might allow a couple of optimizations by the C compiler.Anti-Aliasing:	1)	Check if we can use a weighted 3x3 filter function of the form				1	2	1				2	4	2				1	2	1		Which should be *extremely* nice for fonts (it's sharpening		edges). The good thing about the above is that it sums up to		16 (as in the 4x4 case) but I don't know how to keep a history		without needing two extra scan lines.	2)	Check if we can - somehow - integrate more general filters.	3) Unroll the loops during AA so we can copy and mask aaLevel pixels	   in each step between start and end. This should speed up filling	   by a factor of 2-4 (in particular for difficult stuff like radial gradients).Clipping	1)	Find a way of clipping edges left of the clip rectangle		or at least ignoring most of them after the first scan line.		The AET scanning problems discuss the issue but it should be		possible to keep the color list between spans (if not empty)		and speed up drawing at the very right (such as in the		Winnie Pooh example where a lot of stuff is between the		left border and the clipping rect.	2)	Check if we can determine empty states of the color list and		an edge that is longer than anything left of it. This should		work in theory but might be relatively expensive to compute."	^self error:'Comment only'! !!BalloonEngineBase class methodsFor: 'private' stamp: 'ar 11/9/1998 15:41'!localTranslate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		BalloonEnginePlugin localTranslate: 'sqBalloonEngine.c' doInlining: true.		Smalltalk beep]"	| cg theClass |	self initialize.	cg _ CCodeGenerator new initialize.	theClass _ self.	[theClass == InterpreterPlugin] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initEdgeConstants: dict	"Initialize the edge constants"	self initFromSpecArray:	#(		"Edge primitive types"		(GEPrimitiveEdge 2)			"External edge - not handled by the GE"		(GEPrimitiveWideEdge 3)		"Wide external edge"		(GEPrimitiveLine 4)			"Straight line"		(GEPrimitiveWideLine 5)		"Wide line"		(GEPrimitiveBezier 6)		"Quadratic bezier curve"		(GEPrimitiveWideBezier 7)	"Wide bezier curve"		"Special flags"		(GEPrimitiveWide 16r01)		"Flag determining a wide primitive"		(GEPrimitiveWideMask 16rFE)	"Mask for clearing the wide flag"		(GEEdgeFillsInvalid 16r10000) "Flag determining if left/right fills of an edge are invalid"		"General edge state constants"		(GEXValue 4)					"Current raster x"		(GEYValue 5)					"Current raster y"		(GEZValue 6)					"Current raster z"		(GENumLines 7)					"Number of scan lines remaining"		(GEFillIndexLeft 8)				"Left fill index"		(GEFillIndexRight 9)				"Right fill index"		(GEBaseEdgeSize 10)				"Basic size of each edge"		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"General Line state constants"		(GLXDirection 10)				"Direction of edge (1: left-to-right; -1: right-to-left)"		(GLYDirection 11)				"Direction of edge (1: top-to-bottom; -1: bottom-to-top)"		(GLXIncrement 12)				"Increment at each scan line"		(GLError 13)						"Current error"		(GLErrorAdjUp 14)				"Error to add at each scan line"		(GLErrorAdjDown 15)				"Error to subtract on roll-over"			"Note: The following entries are only needed before the incremental			state is computed. They are therefore aliased to the error values above"		(GLEndX 14)						"End X of line"		(GLEndY 15)						"End Y of line"		(GLBaseSize 16)					"Basic size of each line"		"Additional stuff for wide lines"		(GLWideFill 16)					"Current fill of line"		(GLWideWidth 17)				"Current width of line"		(GLWideEntry 18)				"Initial steps"		(GLWideExit 19)					"Final steps"		(GLWideExtent 20)				"Target width"		(GLWideSize 21)					"Size of wide lines"		"General Bezier state constants"		(GBUpdateData 10)				"Incremental update data for beziers"			(GBUpdateX 0)				"Last computed X value (24.8)"			(GBUpdateY 1)				"Last computed Y value (24.8)"			(GBUpdateDX 2)				"Delta X forward difference step (8.24)"			(GBUpdateDY 3)				"Delta Y forward difference step (8.24)"			(GBUpdateDDX 4)				"Delta DX forward difference step (8.24)"			(GBUpdateDDY 5)				"Delta DY forward difference step (8.24)"		"Note: The following four entries are only needed before the incremental			state is computed. They are therefore aliased to the incremental values above"		(GBViaX 12)						"via x"		(GBViaY 13)						"via y"		(GBEndX 14)						"end x"		(GBEndY 15)						"end y"		(GBBaseSize 16)					"Basic size of each bezier.										Note: MUST be greater or equal to the size of lines"		"Additional stuff for wide beziers"		(GBWideFill 16)					"Current fill of line"		(GBWideWidth 17)				"Current width of line"		(GBWideEntry 18)				"Initial steps"		(GBWideExit 19)					"Final steps"		(GBWideExtent 20)				"Target extent"		(GBFinalX 21)					"Final X value"		(GBWideUpdateData 22)	"Update data for second curve"		(GBWideSize 28)					"Size of wide beziers"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initFillConstants: dict	"Initialize the fill constants"	self initFromSpecArray:	#(		"Fill primitive types"		(GEPrimitiveFill 16r100)		(GEPrimitiveLinearGradientFill 16r200)		(GEPrimitiveRadialGradientFill 16r300)		(GEPrimitiveClippedBitmapFill 16r400)		(GEPrimitiveRepeatedBitmapFill 16r500)		"General fill state constants"		(GEBaseFillSize 4)				"Basic size of each fill"		"Gradient fill constants"		(GFOriginX 4)				"X origin of fill"		(GFOriginY 5)				"Y origin of fill"		(GFDirectionX 6)				"X direction of fill"		(GFDirectionY 7)				"Y direction of fill"		(GFNormalX 8)				"X normal of fill"		(GFNormalY 9)				"Y normal of fill"		(GFRampLength 10)			"Length of following color ramp"		(GFRampOffset 12)			"Offset of first ramp entry"		(GGBaseSize 12)	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:26'!initFromSpecArray: specArray in: aDictionary	specArray do:[:spec|		self initPoolVariable: spec first value: spec last in: aDictionary.	]! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPool	"BalloonEngineBase initPool"	(Smalltalk includesKey: #BalloonEngineConstants) ifFalse:[		Smalltalk declare: #BalloonEngineConstants from: Undeclared.	].	(Smalltalk at: #BalloonEngineConstants) isNil ifTrue:[		(Smalltalk associationAt: #BalloonEngineConstants) value: Dictionary new.	].	self initPool: (Smalltalk at: #BalloonEngineConstants).! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPool: aDictionary	self initStateConstants: aDictionary.	self initWorkBufferConstants: aDictionary.	self initPrimitiveConstants: aDictionary.	self initEdgeConstants: aDictionary.	self initFillConstants: aDictionary.	self initializeInstVarNames: BalloonEngine in: aDictionary prefixedBy: 'BE'.	self initializeInstVarNames: BalloonEdgeData in: aDictionary prefixedBy: 'ET'.	self initializeInstVarNames: BalloonFillData in: aDictionary prefixedBy: 'FT'.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPoolFull	"BalloonEngineBase initPoolFull"	"Move old stuff to Undeclared and re-initialize the receiver"	BalloonEngineConstants associationsDo:[:assoc|		Undeclared declare: assoc key from: BalloonEngineConstants.	].	self initPool.	Undeclared removeUnreferencedKeys.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPoolVariable: token value: value in: aDictionary	aDictionary declare: token from: Undeclared.	(aDictionary associationAt: token) value: value.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initPrimitiveConstants: dict	"Initialize the primitive constants"	self initFromSpecArray:	#(		"Primitive type constants"		(GEPrimitiveUnknown 0)		(GEPrimitiveEdgeMask 16rFF)		(GEPrimitiveFillMask 16rFF00)		(GEPrimitiveTypeMask 16rFFFF)		"General state constants (Note: could be compressed later)"		(GEObjectType 0)				"Type of object"		(GEObjectLength 1)			"Length of object"		(GEObjectIndex 2)			"Index into external objects"		(GEObjectUnused 3)			"Currently unused"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initStateConstants: dict	"Initialize the state Constants"	self initFromSpecArray:	#(		(GEStateUnlocked 0)			"Buffer is unlocked and can be modified as wanted"		(GEStateAddingFromGET 1)	"Adding edges from the GET"		(GEStateWaitingForEdge 2)	"Waiting for edges added to GET"		(GEStateScanningAET 3)		"Scanning the active edge table"		(GEStateWaitingForFill 4)		"Waiting for a fill to mix in during AET scan"		(GEStateBlitBuffer 5)			"Blt the current scan line"		(GEStateUpdateEdges 6)		"Update edges to next scan line"		(GEStateWaitingChange 7)	"Waiting for a changed edge"		(GEStateCompleted 8)			"Rendering completed"		"Error constants"		(GErrorNoMoreSpace 1)		"No more space in collection"		(GErrorBadState 2)			"Tried to call a primitive while engine in bad state"		"Incremental error constants"		(GErrorGETEntry 4)			"Unknown entry in GET"		(GErrorFillEntry 5)			"Unknown FILL encountered"		(GErrorAETEntry 6)			"Unknown entry in AET"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initWorkBufferConstants: dict	"Initialize the work buffer constants"	self initFromSpecArray:	#(		"General work buffer constants"		(GWMagicNumber 16r416E6469)	"Magic number"		(GWHeaderSize 128)				"Size of header"		(GWMinimalSize 256)				"Minimal size of work buffer"		"Header entries"		(GWMagicIndex 0)				"Index of magic number"		(GWSize 1)						"Size of full buffer"		(GWState 2)						"Current state (e.g., locked or not)"		"Buffer entries"		(GWObjStart 8)					"objStart"		(GWObjUsed 9)					"objUsed"		(GWBufferTop 10)				"wbTop"		(GWGETStart 11)					"getStart"		(GWGETUsed 12)					"getUsed"		(GWAETStart 13)					"aetStart"		(GWAETUsed 14)					"aetUsed"		"Span entries"		(GWSpanStart 32)				"spStart"		(GWSpanSize 33)					"spSize"		(GWSpanEnd 34)					"spEnd"		(GWSpanEndAA 35)				"spEndAA"		"Bounds entries"		(GWFillMinX 36)					"fillMinX"		(GWFillMaxX 37)					"fillMaxX"		(GWFillMinY 38)					"fillMinY"		(GWFillMaxY 39)					"fillMaxY"		(GWFillOffsetX 40)				"fillOffsetX"		(GWFillOffsetY 41)				"fillOffsetY"		(GWClipMinX 42)		(GWClipMaxX 43)		(GWClipMinY 44)		(GWClipMaxY 45)		(GWDestOffsetX 46)		(GWDestOffsetY 47)		"AA entries"		(GWAALevel 48)					"aaLevel"		(GWAAShift 49)					"aaShift"		(GWAAColorShift 50)				"aaColorShift"		(GWAAColorMask 51)				"aaColorMask"		(GWAAScanMask 52)				"aaScanMask"		(GWAAHalfPixel 53)				"aaHalfPixel"		"Misc entries"		(GWStopReason 64)				"stopReason"		(GWLastExportedEdge 65)			"last exported edge"		(GWLastExportedFill 66)			"last exported fill"		(GWLastExportedLeftX 67)			"last exported leftX"		(GWLastExportedRightX 68)		"last exported rightX"		(GWClearSpanBuffer 69)			"Do we have to clear the span buffer?"		(GWPointListFirst 70)				"First point list in buffer"		(GWPoint1 80)		(GWPoint2 82)		(GWPoint3 84)		(GWPoint4 86)		(GWCurrentY 88)		"Profile stats"		(GWTimeInitializing 90)		(GWCountInitializing 91)		(GWTimeFinishTest 92)		(GWCountFinishTest 93)		(GWTimeNextGETEntry 94)		(GWCountNextGETEntry 95)		(GWTimeAddAETEntry 96)		(GWCountAddAETEntry 97)		(GWTimeNextFillEntry 98)		(GWCountNextFillEntry 99)		(GWTimeMergeFill 100)		(GWCountMergeFill 101)		(GWTimeDisplaySpan 102)		(GWCountDisplaySpan 103)		(GWTimeNextAETEntry 104)		(GWCountNextAETEntry 105)		(GWTimeChangeAETEntry 106)		(GWCountChangeAETEntry 107)		"Bezier stats"		(GWBezierMonotonSubdivisions 108) 	"# of subdivision due to non-monoton beziers"		(GWBezierHeightSubdivisions 109)		"# of subdivisions due to excessive height"		(GWBezierOverflowSubdivisions 110)	"# of subdivisions due to possible int overflow"		(GWBezierLineConversions 111)		"# of beziers converted to lines"	) in: dict.! !!BalloonEngineBase class methodsFor: 'pool initialization' stamp: 'ar 11/11/1998 22:27'!initializeInstVarNames: aClass in: aDictionary prefixedBy: aString	| token value |	aClass instVarNames doWithIndex:[:instVarName :index|		token _ (aString, instVarName first asUppercase asString, (instVarName copyFrom: 2 to: instVarName size),'Index') asSymbol.		value _ index - 1.		aDictionary declare: token from: Undeclared.		(aDictionary associationAt: token) value: value.	].	token _ (aString, aClass name,'Size') asSymbol.	aDictionary declare:  token from: Undeclared.	(aDictionary associationAt: token) value: aClass instSize.! !!BalloonEnginePlugin reorganize!('primitives' gePrimitiveAddBezierShape gePrimitiveAddBezierWithMatrix gePrimitiveAddCompressedShape gePrimitiveAddGradientFill gePrimitiveAddLineWithMatrix gePrimitiveAddOvalWithMatrix gePrimitiveAddPolygon gePrimitiveAddRectWithMatrix gePrimitiveGetBezierStats)('accessing lines' lineEndXOf: lineEndXOf:put: lineEndYOf: lineEndYOf:put: lineErrorAdjDownOf: lineErrorAdjDownOf:put: lineErrorAdjUpOf: lineErrorAdjUpOf:put: lineErrorOf: lineErrorOf:put: lineXDirectionOf: lineXDirectionOf:put: lineXIncrementOf: lineXIncrementOf:put: lineYDirectionOf: lineYDirectionOf:put: wideLineEntryOf: wideLineEntryOf:put: wideLineExitOf: wideLineExitOf:put: wideLineExtentOf: wideLineExtentOf:put: wideLineFillOf: wideLineFillOf:put: wideLineWidthOf: wideLineWidthOf:put:)('accessing beziers' bezierEndXOf: bezierEndXOf:put: bezierEndYOf: bezierEndYOf:put: bezierFinalXOf: bezierFinalXOf:put: bezierUpdateDataOf: bezierViaXOf: bezierViaXOf:put: bezierViaYOf: bezierViaYOf:put: bzEndX: bzEndX:put: bzEndY: bzEndY:put: bzStartX: bzStartX:put: bzStartY: bzStartY:put: bzViaX: bzViaX:put: bzViaY: bzViaY:put: wideBezierEntryOf: wideBezierEntryOf:put: wideBezierExitOf: wideBezierExitOf:put: wideBezierExtentOf: wideBezierExtentOf:put: wideBezierFillOf: wideBezierFillOf:put: wideBezierUpdateDataOf: wideBezierWidthOf: wideBezierWidthOf:put:)('accessing gradients' gradientDirectionXOf: gradientDirectionXOf:put: gradientDirectionYOf: gradientDirectionYOf:put: gradientNormalXOf: gradientNormalXOf:put: gradientNormalYOf: gradientNormalYOf:put: gradientOriginXOf: gradientOriginXOf:put: gradientOriginYOf: gradientOriginYOf:put: gradientRampLengthOf: gradientRampLengthOf:put: gradientRampOf:)('testing' isBezier: isFillOkay: isLine: isWideBezier: isWideLine:)('lines-simple' stepToFirstLine stepToFirstLineIn:at: stepToNextLine stepToNextLineIn:at:)('lines-loading' loadLine:from:to:offset:leftFill:rightFill: loadRectangle:lineFill:leftFill:rightFill: loadWideLine:from:to:lineFill:leftFill:rightFill:)('lines-wide' adjustWideLine:afterSteppingFrom:to: returnWideLineFill returnWideLineWidth stepToFirstWideLine stepToFirstWideLineIn:at: stepToNextWideLine stepToNextWideLineIn:at:)('bezier-loading' assureValue:between:and: computeBezier:splitAt: computeBezierSplitAtHalf: loadAndSubdivideBezierFrom:via:to:isWide: loadBezier:segment:leftFill:rightFill:offset: loadOval:lineFill:leftFill:rightFill:haveMatrix: loadOvalSegment:w:h:cx:cy: loadWideBezier:lineFill:leftFill:rightFill:n: subdivideBezier: subdivideBezierFrom: subdivideToBeMonoton:inX: subdivideToBeMonotonInX: subdivideToBeMonotonInY:)('beziers-simple' stepToFirstBezier stepToFirstBezierIn:at: stepToNextBezier stepToNextBezierForward:at: stepToNextBezierIn:at:)('beziers-wide' adjustWideBezierLeft:width:offset:endX: adjustWideBezierRight:width:offset:endX: computeFinalWideBezierValues:width: returnWideBezierFill returnWideBezierWidth stepToFirstWideBezier stepToFirstWideBezierIn:at: stepToNextWideBezier stepToNextWideBezierIn:at:)('shapes-compressed' checkCompressedFillIndexList:max:segments: checkCompressedFills: checkCompressedLineWidths:segments: checkCompressedPoints:segments: checkCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:fillIndexList: loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor:haveMatrix: loadCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:fillIndexList:haveMatrix:pointShort:)('shapes-polygons' loadArrayPolygon:nPoints:fill:lineWidth:lineFill:haveMatrix: loadArrayShape:nSegments:fill:lineWidth:lineFill:haveMatrix: loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort:haveMatrix: loadShape:nSegments:fill:lineWidth:lineFill:pointsShort:haveMatrix:)('fills-gradient' fillLinearGradient fillLinearGradient:from:to:at: fillLinearGradientAA:ramp:ds:dsX:from:to: fillRadialDecreasing:ramp:deltaST:dsX:dtX:from:to: fillRadialDecreasingAA:ramp:deltaST:dsX:dtX:from:to: fillRadialGradient fillRadialGradient:from:to:at: fillRadialIncreasing:ramp:deltaST:dsX:dtX:from:to: fillRadialIncreasingAA:ramp:deltaST:dsX:dtX:from:to: loadGradientFill:from:along:normal:isRadial:haveMatrix:)('allocation' allocateBezier allocateBezierStackEntry allocateGradientFill:rampWidth:isRadial: allocateLine allocateWideBezier allocateWideLine)('GET processing' checkedAddBezierToGET: checkedAddEdgeToGET: checkedAddLineToGET:)('private' absoluteSquared8Dot24: circleCosTable circleSinTable loadPointIntAt:from: loadPointShortAt:from: makeRectFromPoints offsetFromWidth: shortRunLengthAt:from: shortRunValueAt:from:)!!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/14/1998 20:51'!gePrimitiveAddBezierShape	| transform points haveMatrix lineFill lineWidth fillIndex length isArray segSize nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackValue: 0.	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	lineWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	nSegments _ interpreterProxy stackIntegerValue: 4.	points _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = (nSegments * 3) or:[length = (nSegments * 6)])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = (nSegments * 3)			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Load transformation if necessary"	haveMatrix _ transform ~= interpreterProxy nilObject.	haveMatrix ifTrue:[		self loadMatrixFrom: transform.		interpreterProxy failed ifTrue:[^nil]].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth haveMatrix: haveMatrix.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual shape"	isArray ifTrue:[		self loadArrayShape: points nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			haveMatrix: haveMatrix	] ifFalse:[		self loadShape: (interpreterProxy firstIndexableField: points) nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nSegments * 3 = length) haveMatrix: haveMatrix].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/8/1998 15:06'!gePrimitiveAddBezierWithMatrix	| leftFillIndex rightFillIndex viaOop endOop startOop transform nSegments haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	viaOop _ interpreterProxy stackObjectValue: 3.	endOop _ interpreterProxy stackObjectValue: 4.	startOop _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFillIndex) and:[self isFillOkay: rightFillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Do a quick check if the fillIndices are equal - if so, just ignore it"	leftFillIndex = rightFillIndex & false ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: viaOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^0].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^0].	self transformPoints: 3 haveMatrix: haveMatrix.	nSegments _ self loadAndSubdivideBezierFrom: self point1Get 						via: self point2Get 						to: self point3Get 						isWide: false.	self needAvailableSpace: nSegments * GBBaseSize.	engineStopped ifFalse:[		self loadWideBezier: 0 lineFill: 0 leftFill: leftFillIndex rightFill: rightFillIndex n: nSegments.	].	engineStopped ifTrue:[		"Make sure the stack is okay"		self wbStackClear.		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/12/1998 21:22'!gePrimitiveAddCompressedShape	| transform fillIndexList lineFills lineWidths rightFills leftFills nSegments points haveMatrix pointsShort |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 8 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackValue: 0.	fillIndexList _ interpreterProxy stackObjectValue: 1.	lineFills _ interpreterProxy stackObjectValue: 2.	lineWidths _ interpreterProxy stackObjectValue: 3.	rightFills _ interpreterProxy stackObjectValue: 4.	leftFills _ interpreterProxy stackObjectValue: 5.	nSegments _ interpreterProxy stackIntegerValue: 6.	points _ interpreterProxy stackObjectValue: 7.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 8) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the compressed shape is okay"	(self checkCompressedShape: points 			segments: nSegments 			leftFills: leftFills 			rightFills: rightFills 			lineWidths: lineWidths 			lineFills: lineFills 			fillIndexList: fillIndexList) ifFalse:[^interpreterProxy primitiveFail].	"Now check that we have some hope to have enough free space.	Do this by assuming nSegments boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(self needAvailableSpace: (GBBaseSize max: GLBaseSize) * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Load transformation if necessary"	haveMatrix _ transform ~= interpreterProxy nilObject.	haveMatrix ifTrue:[		self loadMatrixFrom: transform.		interpreterProxy failed ifTrue:[^nil]].	"Check if the points are short"	pointsShort _ (interpreterProxy slotSizeOf: points) = (nSegments * 3).	"Then actually load the compressed shape"	self loadCompressedShape: (interpreterProxy firstIndexableField: points)			segments: nSegments 			leftFills: (interpreterProxy firstIndexableField: leftFills)			rightFills: (interpreterProxy firstIndexableField: rightFills)			lineWidths: (interpreterProxy firstIndexableField: lineWidths)			lineFills: (interpreterProxy firstIndexableField: lineFills)			fillIndexList: (interpreterProxy firstIndexableField: fillIndexList)			haveMatrix: haveMatrix			pointShort: pointsShort.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 8. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/8/1998 16:15'!gePrimitiveAddGradientFill	| transform isRadial nrmOop dirOop originOop rampOop haveMatrix fill |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	isRadial _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 1).	nrmOop _ interpreterProxy stackValue: 2.	dirOop _ interpreterProxy stackValue: 3.	originOop _ interpreterProxy stackValue: 4.	rampOop _ interpreterProxy stackValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadGradientFill: rampOop 				from: self point1Get 				along: self point2Get 				normal: self point3Get 				isRadial: isRadial 				haveMatrix: haveMatrix.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 7.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/6/1998 01:39'!gePrimitiveAddLineWithMatrix	| leftFillIndex rightFillIndex endOop startOop transform haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFillIndex) and:[self isFillOkay: rightFillIndex])			ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	"Load the points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	"Transform points"	self transformPoints: 2 haveMatrix: haveMatrix.	"Load line"	self loadWideLine: 0 from: self point1Get to: self point2Get 		lineFill: 0 leftFill: leftFillIndex rightFill: rightFillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 22:18'!gePrimitiveAddOvalWithMatrix	| fillIndex borderWidth borderIndex endOop startOop transform objUsedNow haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	borderWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	endOop _ interpreterProxy stackObjectValue: 4.	startOop _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth <= 0]]) ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (16 * GBBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Note: If we run out of space, we have to restore objUsed"	objUsedNow _ self objUsedGet.	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth haveMatrix: haveMatrix]		ifFalse:[borderWidth _ 0].	"Load the rectangle points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self loadOval: borderWidth lineFill: borderIndex 		leftFill: 0 rightFill: fillIndex haveMatrix: haveMatrix.	engineStopped ifTrue:[		self wbStackClear.		self objUsedPut: objUsedNow.		^interpreterProxy primitiveFail.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/14/1998 20:09'!gePrimitiveAddPolygon	| transform points haveMatrix lineFill lineWidth fillIndex nPoints length isArray segSize |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackValue: 0.	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	lineWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	nPoints _ interpreterProxy stackIntegerValue: 4.	points _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = nPoints or:[nPoints * 2 = length])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = nPoints			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nPoints)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Load transformation if necessary"	haveMatrix _ transform ~= interpreterProxy nilObject.	haveMatrix ifTrue:[		self loadMatrixFrom: transform.		interpreterProxy failed ifTrue:[^nil]].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth haveMatrix: haveMatrix.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual polygon"	isArray ifTrue:[		self loadArrayPolygon: points nPoints: nPoints			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			haveMatrix: haveMatrix	] ifFalse:[		self loadPolygon: (interpreterProxy firstIndexableField: points) nPoints: nPoints 			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nPoints = length) haveMatrix: haveMatrix].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 22:19'!gePrimitiveAddRectWithMatrix	| fillIndex borderWidth borderIndex endOop startOop transform haveMatrix |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	transform _ interpreterProxy stackObjectValue: 0.	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	borderWidth _ interpreterProxy stackIntegerValue: 2.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 3).	endOop _ interpreterProxy stackObjectValue: 4.	startOop _ interpreterProxy stackObjectValue: 5.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 6) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	haveMatrix _ self loadMatrixFrom: transform.	interpreterProxy failed ifTrue:[^nil].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth = 0]]) ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (4 * GLBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth haveMatrix: haveMatrix]		ifFalse:[borderWidth _ 0].	"Load the rectangle"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^nil].	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).	"Transform the points"	self transformPoints: 4 haveMatrix: haveMatrix.	self loadRectangle: borderWidth lineFill: borderIndex leftFill: 0 rightFill: fillIndex.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 11/10/1998 21:28'!gePrimitiveGetBezierStats	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 4		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWBezierMonotonSubdivisions).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWBezierHeightSubdivisions).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWBezierOverflowSubdivisions).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWBezierLineConversions).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:37'!lineEndXOf: line	^objBuffer at: line + GLEndX! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:37'!lineEndXOf: line put: value	^objBuffer at: line + GLEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineEndYOf: line	^objBuffer at: line + GLEndY! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineEndYOf: line put: value	^objBuffer at: line + GLEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjDownOf: line	^objBuffer at: line + GLErrorAdjDown! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjDownOf: line put: value	^objBuffer at: line + GLErrorAdjDown put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjUpOf: line	^objBuffer at: line + GLErrorAdjUp! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorAdjUpOf: line put: value	^objBuffer at: line + GLErrorAdjUp put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorOf: line	^objBuffer at: line + GLError! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineErrorOf: line put: value	^objBuffer at: line + GLError put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXDirectionOf: line	^objBuffer at: line + GLXDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXDirectionOf: line put: value	^objBuffer at: line + GLXDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXIncrementOf: line	^objBuffer at: line + GLXIncrement! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineXIncrementOf: line put: value	^objBuffer at: line + GLXIncrement put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineYDirectionOf: line	^objBuffer at: line + GLYDirection! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:38'!lineYDirectionOf: line put: value	^objBuffer at: line + GLYDirection put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:39'!wideLineEntryOf: line	^objBuffer at: line + GLWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:39'!wideLineEntryOf: line put: value	^objBuffer at: line + GLWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExitOf: line	^objBuffer at: line + GLWideExit! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExitOf: line put: value	^objBuffer at: line + GLWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExtentOf: line	^objBuffer at: line + GLWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineExtentOf: line put: value	^objBuffer at: line + GLWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineFillOf: line	^objBuffer at: line + GLWideFill! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineFillOf: line put: value	^objBuffer at: line + GLWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineWidthOf: line	^objBuffer at: line + GLWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing lines' stamp: 'ar 11/9/1998 15:40'!wideLineWidthOf: line put: value	^objBuffer at: line + GLWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:34'!bezierEndXOf: bezier	^objBuffer at: bezier + GBEndX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierEndXOf: bezier put: value	^objBuffer at: bezier + GBEndX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierEndYOf: bezier	^objBuffer at: bezier + GBEndY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierEndYOf: bezier put: value	^objBuffer at: bezier + GBEndY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierFinalXOf: bezier	^objBuffer at: bezier + GBFinalX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:33'!bezierFinalXOf: bezier put: value	^objBuffer at: bezier + GBFinalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:36'!bezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier + GBUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:36'!bezierViaXOf: bezier	^objBuffer at: bezier + GBViaX! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:37'!bezierViaXOf: bezier put: value	^objBuffer at: bezier + GBViaX put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:37'!bezierViaYOf: bezier	^objBuffer at: bezier + GBViaY! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:37'!bezierViaYOf: bezier put: value	^objBuffer at: bezier + GBViaY put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndX: index	^self wbStackValue: self wbStackSize - index + 4! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndX: index put: value	^self wbStackValue: self wbStackSize - index + 4 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndY: index	^self wbStackValue: self wbStackSize - index + 5! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzEndY: index put: value	^self wbStackValue: self wbStackSize - index + 5 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartX: index	^self wbStackValue: self wbStackSize - index + 0! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartX: index put: value	^self wbStackValue: self wbStackSize - index + 0 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzStartY: index	^self wbStackValue: self wbStackSize - index + 1! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzStartY: index put: value	^self wbStackValue: self wbStackSize - index + 1 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzViaX: index	^self wbStackValue: self wbStackSize - index + 2! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzViaX: index put: value	^self wbStackValue: self wbStackSize - index + 2 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:53'!bzViaY: index	^self wbStackValue: self wbStackSize - index + 3! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 10/30/1998 20:54'!bzViaY: index put: value	^self wbStackValue: self wbStackSize - index + 3 put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierEntryOf: line	^objBuffer at: line + GBWideEntry! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierEntryOf: line put: value	^objBuffer at: line + GBWideEntry put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExitOf: line	^objBuffer at: line + GBWideExit! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExitOf: line put: value	^objBuffer at: line + GBWideExit put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExtentOf: bezier	^objBuffer at: bezier + GBWideExtent! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierExtentOf: bezier put: value	^objBuffer at: bezier + GBWideExtent put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierFillOf: bezier	^objBuffer at: bezier + GBWideFill! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierFillOf: bezier put: value	^objBuffer at: bezier + GBWideFill put: value! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierUpdateDataOf: bezier	self returnTypeC: 'int *'.	^objBuffer + bezier + GBWideUpdateData! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierWidthOf: line	^objBuffer at: line + GBWideWidth! !!BalloonEnginePlugin methodsFor: 'accessing beziers' stamp: 'ar 11/9/1998 15:39'!wideBezierWidthOf: line put: value	^objBuffer at: line + GBWideWidth put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionXOf: fill	^objBuffer at: fill + GFDirectionX! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionXOf: fill put: value	^objBuffer at: fill + GFDirectionX put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionYOf: fill	^objBuffer at: fill + GFDirectionY! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientDirectionYOf: fill put: value	^objBuffer at: fill + GFDirectionY put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalXOf: fill	^objBuffer at: fill + GFNormalX! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalXOf: fill put: value	^objBuffer at: fill + GFNormalX put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalYOf: fill	^objBuffer at: fill + GFNormalY! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientNormalYOf: fill put: value	^objBuffer at: fill + GFNormalY put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginXOf: fill	^objBuffer at: fill + GFOriginX! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginXOf: fill put: value	^objBuffer at: fill + GFOriginX put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginYOf: fill	^objBuffer at: fill + GFOriginY! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientOriginYOf: fill put: value	^objBuffer at: fill + GFOriginY put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientRampLengthOf: fill	^objBuffer at: fill + GFRampLength! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientRampLengthOf: fill put: value	^objBuffer at: fill + GFRampLength put: value! !!BalloonEnginePlugin methodsFor: 'accessing gradients' stamp: 'ar 11/9/1998 15:37'!gradientRampOf: fill	self returnTypeC:'int *'.	^objBuffer + fill + GFRampOffset! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 21:46'!isBezier: bezier	^((self objectTypeOf: bezier) bitAnd: GEPrimitiveWideMask) = GEPrimitiveBezier! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/8/1998 15:14'!isFillOkay: fill	self inline: false.	^(fill = 0 or:[(self isFillColor: fill) or:[((self isObject: fill) and:[self isFill: fill])]]) ! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 21:46'!isLine: line	^((self objectTypeOf: line) bitAnd: GEPrimitiveWideMask) = GEPrimitiveLine! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/6/1998 01:53'!isWideBezier: bezier	^(self isBezier: bezier) and:[self isWide: bezier]! !!BalloonEnginePlugin methodsFor: 'testing' stamp: 'ar 11/4/1998 22:08'!isWideLine: line	^(self isLine: line) and:[self isWide: line]! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/4/1998 21:52'!stepToFirstLine	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstLineIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/9/1998 15:38'!stepToFirstLineIn: line at: yValue	"Initialize the line at yValue"	| deltaX deltaY xDir widthX error xInc errorAdjUp startY |	self inline: false.	"Do a quick check if there is anything at all to do"	((self isWide: line) not and:[yValue >= (self lineEndYOf: line)])		ifTrue:[^self edgeNumLinesOf: line put: 0].	deltaX _ (self lineEndXOf: line) - (self edgeXValueOf: line).	deltaY _ (self lineEndYOf: line) - (self edgeYValueOf: line).	"Check if edge goes left to right"	deltaX >= 0 		ifTrue:[	xDir _ 1.				widthX _ deltaX.				error _ 0]		ifFalse:[	xDir _ -1.				widthX _ 0 - deltaX.				error _ 1 - deltaY].	"Check if deltaY is zero.	Note: We could actually get out here immediately 	but wide lines rely on an accurate setup in this case"	deltaY = 0		ifTrue:[	error _ 0.			"No error for horizontal edges"				xInc _ deltaX.		"Encodes width and direction"				errorAdjUp _ 0]		ifFalse:["Check if edge is y-major"				deltaY > widthX "Note: The '>' instead of '>=' could be important here..."					ifTrue:[	xInc _ 0.							errorAdjUp _ widthX]					ifFalse:[	xInc _ (widthX // deltaY) * xDir.							errorAdjUp _ widthX \\ deltaY]].	"Store the values"	self edgeNumLinesOf: line put: deltaY.	self lineXDirectionOf: line put: xDir.	"self lineYDirectionOf: line put: yDir." "<-- Already set"	self lineXIncrementOf: line put: xInc.	self lineErrorOf: line put: error.	self lineErrorAdjUpOf: line put: errorAdjUp.	self lineErrorAdjDownOf: line put: deltaY.	"And step to the first scan line"	(startY _ self edgeYValueOf: line) = yValue ifFalse:[		startY to: yValue-1 do:[:i| self stepToNextLineIn: line at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: line put: deltaY - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/4/1998 21:53'!stepToNextLine	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextLineIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-simple' stamp: 'ar 11/9/1998 15:39'!stepToNextLineIn: line at: yValue	"Incrementally step to the next scan line in the given line"	| x  err |	self inline: true.	x _ (self edgeXValueOf: line) + (self lineXIncrementOf: line).	err _ (self lineErrorOf: line) + (self lineErrorAdjUpOf: line).	err > 0 ifTrue:[		x _ x + (self lineXDirectionOf: line).		err _ err - (self lineErrorAdjDownOf: line).	].	self lineErrorOf: line put: err.	self edgeXValueOf: line put: x.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/9/1998 15:38'!loadLine: line from: point1 to: point2 offset: yOffset leftFill: leftFill rightFill: rightFill	"Load the line defined by point1 and point2."	| p1 p2 yDir |	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(point1 at: 1) <= (point2 at: 1) 		ifTrue:[	p1 _ point1.				p2 _ point2.				yDir _ 1]		ifFalse:[	p1 _ point2.				p2 _ point1.				yDir _ -1].	self edgeXValueOf: line put: (p1 at: 0).	self edgeYValueOf: line put: (p1 at: 1) - yOffset.	self edgeZValueOf: line put: 0.	self edgeLeftFillOf: line put: leftFill.	self edgeRightFillOf: line put: rightFill.	self lineEndXOf: line put: (p2 at: 0).	self lineEndYOf: line put: (p2 at: 1) - yOffset.	self lineYDirectionOf: line put: yDir.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/6/1998 17:07'!loadRectangle: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a rectangle currently defined by point1-point4"	self loadWideLine: lineWidth from: self point1Get to: self point2Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point2Get to: self point3Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point3Get to: self point4Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.	self loadWideLine: lineWidth from: self point4Get to: self point1Get		lineFill: lineFill leftFill: leftFill rightFill: rightFill.! !!BalloonEnginePlugin methodsFor: 'lines-loading' stamp: 'ar 11/8/1998 19:24'!loadWideLine: lineWidth from: p1 to: p2 lineFill: lineFill leftFill: leftFill rightFill: rightFill	"Load a (possibly wide) line defined by the points p1 and p2"	| line offset |	self var: #p1 declareC:'int *p1'.	self var: #p2 declareC:'int *p2'.	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[	line _ self allocateLine.				offset _ 0]		ifFalse:[	line _ self allocateWideLine.				offset _ self offsetFromWidth: lineWidth].	engineStopped ifTrue:[^0].	self loadLine: line 		from: p1		to: p2		offset: offset 		leftFill: leftFill		rightFill: rightFill.	(self isWide: line) ifTrue:[		self wideLineFillOf: line put: lineFill.		self wideLineWidthOf: line put: lineWidth.		self wideLineExtentOf: line put: lineWidth].! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:34'!adjustWideLine: line afterSteppingFrom: lastX to: nextX	"Adjust the wide line after it has been stepped from lastX to nextX.	Special adjustments of line width and start position are made here	to simulate a rectangular brush"	|  yEntry yExit lineWidth lineOffset deltaX xDir baseWidth |	self inline: false.	"Don't inline this"	"Fetch the values the adjustment decisions are based on"	yEntry _ (self wideLineEntryOf: line).	yExit _ (self wideLineExitOf: line).	baseWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: baseWidth.	lineWidth _ self wideLineWidthOf: line.	xDir _ self lineXDirectionOf: line.	deltaX _ nextX - lastX.	"Adjust the start of the line to fill an entire rectangle"	yEntry < baseWidth ifTrue:[		xDir < 0			ifTrue:[	lineWidth _ lineWidth - deltaX] "effectively adding"			ifFalse:[	lineWidth _ lineWidth + deltaX.					self edgeXValueOf: line put: lastX].	].	"Adjust the end of x-major lines"	((yExit + lineOffset) = 0) ifTrue:[		xDir > 0			ifTrue:[lineWidth _ lineWidth - (self lineXIncrementOf: line)]			ifFalse:[lineWidth _ lineWidth + (self lineXIncrementOf: line).	"effectively subtracting"					self edgeXValueOf: line put: lastX].	].	"Adjust the end of the line to fill an entire rectangle"	(yExit + lineOffset) > 0 ifTrue:[		xDir < 0			ifTrue:[	lineWidth _ lineWidth + deltaX. "effectively subtracting"					self edgeXValueOf: line put: lastX]			ifFalse:[	lineWidth _ lineWidth - deltaX]	].	"Store the manipulated line width back"	self wideLineWidthOf: line put: lineWidth.! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/6/1998 17:08'!returnWideLineFill	"Return the fill of the (wide) line - this method is called from a case."	^(dispatchReturnValue _ self wideLineFillOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/6/1998 17:08'!returnWideLineWidth	"Return the width of the (wide) line - this method is called from a case."	^(dispatchReturnValue _ self wideLineWidthOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/4/1998 21:54'!stepToFirstWideLine	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstWideLineIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:38'!stepToFirstWideLineIn: line at: yValue	"Initialize the wide line at yValue."	| startY yEntry yExit lineWidth nLines lineOffset startX xDir |	self inline: false.	"Get some values"	lineWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: lineWidth.	"Compute the incremental values of the line"	startX _ self edgeXValueOf: line.	startY _ self edgeYValueOf: line.	self stepToFirstLineIn: line at: startY.	nLines _ (self edgeNumLinesOf: line).	xDir _ self lineXDirectionOf: line.	"Adjust the line to start at the correct X position"	self edgeXValueOf: line put: startX - lineOffset.	"Adjust the number of lines to include the lineWidth"	self edgeNumLinesOf: line put: nLines + lineWidth.	"Adjust the values for x-major lines"	xDir > 0 ifTrue:[		self wideLineWidthOf: line put: (self lineXIncrementOf: line) + lineWidth.	] ifFalse:[		self wideLineWidthOf: line put: lineWidth - (self lineXIncrementOf: line). "adding"		self edgeXValueOf: line put: (self edgeXValueOf: line) + (self lineXIncrementOf: line).	].	"Compute the points where we have to turn on/off the fills"	yEntry _ 0.						"turned on at lineOffset"	yExit _ 0 - nLines - lineOffset.	"turned off at zero"	self wideLineEntryOf: line put: yEntry.	self wideLineExitOf: line put: yExit.	"Turn the fills on/off as necessary"	(yEntry >= lineOffset and:[yExit < 0])		ifTrue:[self edgeFillsValidate: line]		ifFalse:[self edgeFillsInvalidate: line].	"And step to the first scan line"	startY = yValue ifFalse:[		startY to: yValue-1 do:[:i| self stepToNextWideLineIn: line at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: line put: (self edgeNumLinesOf: line) - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/4/1998 21:55'!stepToNextWideLine	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextWideLineIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'lines-wide' stamp: 'ar 11/9/1998 15:39'!stepToNextWideLineIn: line at: yValue	"Incrementally step to the next scan line in the given wide line"	|  yEntry yExit lineWidth lineOffset lastX nextX |	self inline: true.	"Adjust entry/exit values"	yEntry _ (self wideLineEntryOf: line) + 1.	yExit _ (self wideLineExitOf: line) + 1.	self wideLineEntryOf: line put: yEntry.	self wideLineExitOf: line put: yExit.	"Turn fills on/off"	lineWidth _ self wideLineExtentOf: line.	lineOffset _ self offsetFromWidth: lineWidth.	yEntry >= lineOffset ifTrue:[self edgeFillsValidate: line].	yExit >= 0 ifTrue:[self edgeFillsInvalidate: line].	"Step to the next scan line"	lastX _ self edgeXValueOf: line.	self stepToNextLineIn: line at: yValue.	nextX _ self edgeXValueOf: line.	"Check for special start/end adjustments"	(yEntry <= lineWidth or:[yExit+lineOffset >= 0]) ifTrue:[		"Yes, need an update"		self adjustWideLine: line afterSteppingFrom: lastX to: nextX.	].! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/9/1998 01:56'!assureValue: val1 between: val2 and: val3	"Make sure that val1 is between val2 and val3."	self inline: true.	val2 > val3 ifTrue:[		val1 > val2 ifTrue:[^val2].		val1 < val3 ifTrue:[^val3].	] ifFalse:[		val1 < val2 ifTrue:[^val2].		val1 > val3 ifTrue:[^val3].	].	^val1	! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/9/1998 01:57'!computeBezier: index splitAt: param	"Split the bezier curve at the given parametric value.	Note: Since this method is only invoked to make non-monoton		beziers monoton we must check for the resulting y values		to be *really* between the start and end value."	| startX startY viaX viaY endX endY newIndex 	leftViaX  leftViaY rightViaX rightViaY sharedX sharedY |	self inline: false.	self var: #param declareC:'double param'.	leftViaX _ startX _ self bzStartX: index.	leftViaY _ startY _ self bzStartY: index.	rightViaX _ viaX _ self bzViaX: index.	rightViaY _ viaY _ self bzViaY: index.	endX _ self bzEndX: index.	endY _ self bzEndY: index.	"Compute intermediate points"	sharedX _ leftViaX _ leftViaX + ((viaX - startX) asFloat * param) asInteger.	sharedY _ leftViaY _ leftViaY + ((viaY - startY) asFloat * param) asInteger.	rightViaX _ rightViaX + ((endX - viaX) asFloat * param) asInteger.	rightViaY _ rightViaY + ((endY - viaY) asFloat * param) asInteger.	"Compute new shared point"	sharedX _ sharedX + ((rightViaX - leftViaX) asFloat * param) asInteger.	sharedY _ sharedY + ((rightViaY - leftViaY) asFloat * param) asInteger.	"Check the new via points"	leftViaY _ self assureValue: leftViaY between: startY and: sharedY.	rightViaY _ self assureValue: rightViaY between: sharedY and: endY.	newIndex _ self allocateBezierStackEntry.	engineStopped ifTrue:[^0]. "Something went wrong"	"Store the first part back"	self bzViaX: index put: leftViaX.	self bzViaY: index put: leftViaY.	self bzEndX: index put: sharedX.	self bzEndY: index put: sharedY.	"Store the second point back"	self bzStartX: newIndex put: sharedX.	self bzStartY: newIndex put: sharedY.	self bzViaX: newIndex put: rightViaX.	self bzViaY: newIndex put: rightViaY.	self bzEndX: newIndex put: endX.	self bzEndY: newIndex put: endY.	^newIndex! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/6/1998 01:26'!computeBezierSplitAtHalf: index	"Split the bezier curve at 0.5."	| startX startY viaX viaY endX endY newIndex 	leftViaX  leftViaY rightViaX rightViaY sharedX sharedY |	self inline: false.	newIndex _ self allocateBezierStackEntry.	engineStopped ifTrue:[^0]. "Something went wrong"	leftViaX _ startX _ self bzStartX: index.	leftViaY _ startY _ self bzStartY: index.	rightViaX _ viaX _ self bzViaX: index.	rightViaY _ viaY _ self bzViaY: index.	endX _ self bzEndX: index.	endY _ self bzEndY: index.	"Compute intermediate points"	leftViaX _ leftViaX + ((viaX - startX) // 2).	leftViaY _ leftViaY + ((viaY - startY) // 2).	sharedX _ rightViaX _ rightViaX + ((endX - viaX) // 2).	sharedY _ rightViaY _ rightViaY + ((endY - viaY) // 2).	"Compute new shared point"	sharedX _ sharedX + ((leftViaX - rightViaX) // 2).	sharedY _ sharedY + ((leftViaY - rightViaY) // 2).	"Store the first part back"	self bzViaX: index put: leftViaX.	self bzViaY: index put: leftViaY.	self bzEndX: index put: sharedX.	self bzEndY: index put: sharedY.	"Store the second point back"	self bzStartX: newIndex put: sharedX.	self bzStartY: newIndex put: sharedY.	self bzViaX: newIndex put: rightViaX.	self bzViaY: newIndex put: rightViaY.	self bzEndX: newIndex put: endX.	self bzEndY: newIndex put: endY.	^newIndex! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 20:15'!loadAndSubdivideBezierFrom: point1 via: point2 to: point3 isWide: wideFlag	"Load and subdivide the bezier curve from point1/point2/point3.	If wideFlag is set then make sure the curve is monoton in X."	| bz1 bz2 index2 index1 |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	bz1 _ self allocateBezierStackEntry.		engineStopped ifTrue:[^0].	"Load point1/point2/point3 on the top of the stack"	self bzStartX: bz1 put: (point1 at: 0).	self bzStartY: bz1 put: (point1 at: 1).	self bzViaX: bz1 put: (point2 at: 0).	self bzViaY: bz1 put: (point2 at: 1).	self bzEndX: bz1 put: (point3 at: 0).	self bzEndY: bz1 put: (point3 at: 1).	"Now check if the bezier curve is monoton. If not, subdivide it."	index2 _ bz2 _ self subdivideToBeMonoton: bz1 inX: wideFlag.	bz1 to: bz2 by: 6 do:[:index|		index1 _ self subdivideBezierFrom: index.		index1 > index2 ifTrue:[index2 _ index1].		engineStopped ifTrue:[^0]. "Something went wrong"	].	"Return the number of segments"	^index2 // 6! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:40'!loadBezier: bezier segment: index leftFill: leftFillIndex rightFill: rightFillIndex offset: yOffset	"Initialize the bezier segment stored on the stack"	self inline: false.	(self bzEndY: index) >= (self bzStartY: index) ifTrue:[		"Top to bottom"		self edgeXValueOf: bezier put: (self bzStartX: index).		self edgeYValueOf: bezier put: (self bzStartY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzEndX: index).		self bezierEndYOf: bezier put: (self bzEndY: index) - yOffset.	] ifFalse:[		self edgeXValueOf: bezier put: (self bzEndX: index).		self edgeYValueOf: bezier put: (self bzEndY: index) - yOffset.		self bezierViaXOf: bezier put: (self bzViaX: index).		self bezierViaYOf: bezier put: (self bzViaY: index) - yOffset.		self bezierEndXOf: bezier put: (self bzStartX: index).		self bezierEndYOf: bezier put: (self bzStartY: index) - yOffset.	].	self edgeZValueOf: bezier put: 0.	self edgeLeftFillOf: bezier put: leftFillIndex.	self edgeRightFillOf: bezier put: rightFillIndex.	"self debugDrawBezier: bezier."! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!loadOval: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill haveMatrix: haveMatrix	"Load a rectangular oval currently defined by point1/point2"	| w h cx cy nSegments |	self inline: false.	w _ ((self point2Get at: 0) - (self point1Get at: 0)) // 2.	h _ ((self point2Get at: 1) - (self point1Get at: 1)) // 2.	cx _ ((self point2Get at: 0) + (self point1Get at: 0)) // 2.	cy _ ((self point2Get at: 1) + (self point1Get at: 1)) // 2.	0 to: 15 do:[:i|		self loadOvalSegment: i w: w h: h cx: cx cy: cy.		self transformPoints: 3 haveMatrix: haveMatrix.		nSegments _ self loadAndSubdivideBezierFrom: self point1Get 							via: self point2Get to: self point3Get							isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).		engineStopped ifTrue:[^nil].		self loadWideBezier: lineWidth lineFill: lineFill 			leftFill: leftFill rightFill: rightFill n: nSegments.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!loadOvalSegment: seg w: w h: h cx: cx cy: cy	| x0 y0 x2 y2 x1 y1 |	self inline: false.	"Load start point of segment"	x0 _ ((self circleCosTable at: seg * 2 + 0) * w asFloat + cx) asInteger.	y0 _ ((self circleSinTable at: seg * 2 + 0) * h asFloat + cy) asInteger.	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	"Load end point of segment"	x2 _ ((self circleCosTable at: seg * 2 + 2) * w asFloat + cx) asInteger.	y2 _ ((self circleSinTable at: seg * 2 + 2) * h asFloat + cy) asInteger.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	"Load intermediate point of segment"	x1 _ ((self circleCosTable at: seg * 2 + 1) * w asFloat + cx) asInteger.	y1 _ ((self circleSinTable at: seg * 2 + 1) * h asFloat + cy) asInteger.	"NOTE: The intermediate point is the point ON the curve	and not yet the control point (which is OFF the curve)"	x1 _ (x1 * 2) - (x0 + x2 // 2).	y1 _ (y1 * 2) - (y0 + y2 // 2).	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:41'!loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: nSegments	"Load the (possibly wide) bezier from the segments currently on the bezier stack."	| index bezier wide offset |	self inline: false.	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[wide _ false.				offset _ 0]		ifFalse:[wide _ true.				offset _ self offsetFromWidth: lineWidth].	index _ nSegments * 6.	[index > 0] whileTrue:[		wide 			ifTrue:[bezier _ self allocateWideBezier]			ifFalse:[bezier _ self allocateBezier].		engineStopped ifTrue:[^0].		self loadBezier: bezier 			segment: index 			leftFill: leftFill 			rightFill: rightFill 			offset: offset.		wide ifTrue:[			self wideBezierFillOf: bezier put: lineFill.			self wideBezierWidthOf: bezier put: lineWidth.			self wideBezierExtentOf: bezier put: lineWidth.		].		index _ index - 6.	].	self wbStackClear.! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 14:36'!subdivideBezier: index	"Subdivide the given bezier curve if necessary"	| startX startY endX endY deltaX deltaY |	self inline: false.	startY _ self bzStartY: index.	endY _ self bzEndY: index.	"If the receiver is horizontal, don't do anything"	(endY = startY) ifTrue:[^index].	"TODO: If the curve can be represented as a line, then do so"	"If the height of the curve exceeds 256 pixels, subdivide 	(forward differencing is numerically not very stable)"	deltaY _ endY - startY.	deltaY < 0 ifTrue:[deltaY _ 0 - deltaY].	(deltaY > 255) ifTrue:[		self incrementStat: GWBezierHeightSubdivisions by: 1.		^self computeBezierSplitAtHalf: index].	"Check if the incremental values could possibly overflow the scaled integer range"	startX _ self bzStartX: index.	endX _ self bzEndX: index.	deltaX _ endX - startX.	deltaX < 0 ifTrue:[deltaX _ 0 - deltaX].	deltaY * 32 < deltaX ifTrue:[		self incrementStat: GWBezierOverflowSubdivisions by: 1.		^self computeBezierSplitAtHalf: index].	^index! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 03:43'!subdivideBezierFrom: index	"Recursively subdivide the curve on the bezier stack."	| otherIndex index1 index2 |	self inline: false.	otherIndex _ self subdivideBezier: index.	otherIndex = index ifFalse:[		index1 _ self subdivideBezierFrom: index.		engineStopped ifTrue:[^0].		index2 _ self subdivideBezierFrom: otherIndex.		engineStopped ifTrue:[^0].		index1 >= index2			ifTrue:[^index1]			ifFalse:[^index2]	].	^index! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/8/1998 15:17'!subdivideToBeMonoton: base inX: doTestX	"Check if the given bezier curve is monoton in Y, and, if desired in X. 	If not, subdivide it"	| index1 index2 base2 |	self inline: false.	base2 _ index1 _ index2 _ self subdivideToBeMonotonInY: base.	doTestX ifTrue:[index1 _ self subdivideToBeMonotonInX: base].	index1 > index2 ifTrue:[index2 _ index1].	(base ~= base2 and:[doTestX]) ifTrue:[index1 _ self subdivideToBeMonotonInX: base2].	index1 > index2 ifTrue:[index2 _ index1].	^index2! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/7/1998 19:42'!subdivideToBeMonotonInX: index	"Check if the given bezier curve is monoton in X. If not, subdivide it"	| denom num startX viaX endX dx1 dx2 |	self inline: false.	startX _ self bzStartX: index.	viaX _ self bzViaX: index.	endX _ self bzEndX: index.	dx1 _ viaX - startX.	dx2 _ endX - viaX.	(dx1 * dx2) >= 0 ifTrue:[^index]. "Bezier is monoton"	self incrementStat: GWBezierMonotonSubdivisions by: 1.	"Compute split value"	denom _ dx2 - dx1.	num _ dx1.	num < 0 ifTrue:[num _ 0 - num].	denom < 0 ifTrue:[denom _ 0 - denom].	^self computeBezier: index splitAt: (num asFloat / denom asFloat).! !!BalloonEnginePlugin methodsFor: 'bezier-loading' stamp: 'ar 11/7/1998 19:42'!subdivideToBeMonotonInY: index	"Check if the given bezier curve is monoton in Y. If not, subdivide it"	| startY viaY endY dy1 dy2 denom num |	self inline: false.	startY _ self bzStartY: index.	viaY _ self bzViaY: index.	endY _ self bzEndY: index.	dy1 _ viaY - startY.	dy2 _ endY - viaY.	(dy1 * dy2) >= 0 ifTrue:[^index]. "Bezier is monoton"	self incrementStat: GWBezierMonotonSubdivisions by: 1.	"Compute split value"	denom _ dy2 - dy1.	num _ dy1.	num < 0 ifTrue:[num _ 0 - num].	denom < 0 ifTrue:[denom _ 0 - denom].	^self computeBezier: index splitAt: (num asFloat / denom asFloat).! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/6/1998 00:07'!stepToFirstBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstBezierIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 15:38'!stepToFirstBezierIn: bezier at: yValue	"Initialize the bezier at yValue.	TODO: Check if reducing maxSteps from 2*deltaY to deltaY 		brings a *significant* performance improvement.		In theory this should make for double step performance		but will cost in quality. Might be that the AA stuff will		compensate for this - but I'm not really sure."	| updateData deltaY maxSteps scaledStepSize squaredStepSize 	startX startY viaX viaY endX endY 	fwX1 fwX2 fwY1 fwY2 	fwDx fwDDx fwDy fwDDy |	self inline: false. "Too many temps for useful inlining"	self var: #updateData declareC:'int *updateData'.	"Do a quick check if there is anything at all to do"	((self isWide: bezier) not and:[yValue >= (self bezierEndYOf: bezier)])		ifTrue:[^self edgeNumLinesOf: bezier put: 0].	"Now really initialize bezier"	startX _ self edgeXValueOf: bezier.	startY _ self edgeYValueOf: bezier.	viaX _ self bezierViaXOf: bezier.	viaY _ self bezierViaYOf: bezier.	endX _ self bezierEndXOf: bezier.	endY _ self bezierEndYOf: bezier.	deltaY _ endY - startY.	"Initialize integer forward differencing"	fwX1 _ (viaX - startX) * 2.	fwX2 _ startX + endX - (viaX * 2).	fwY1 _ (viaY - startY) * 2.	fwY2 _ startY + endY - (viaY * 2).	maxSteps _ deltaY * 2.	maxSteps < 2 ifTrue:[maxSteps _ 2].	scaledStepSize _ 16r1000000 // maxSteps.	squaredStepSize _ self absoluteSquared8Dot24: scaledStepSize.	fwDx _ fwX1 * scaledStepSize.	fwDDx _ fwX2 * squaredStepSize * 2.	fwDx _ fwDx + (fwDDx // 2).	fwDy _ fwY1 * scaledStepSize.	fwDDy _ fwY2 * squaredStepSize * 2.	fwDy _ fwDy + (fwDDy // 2).	"Store the values"	self edgeNumLinesOf: bezier put: deltaY.	updateData _ self bezierUpdateDataOf: bezier.	updateData at: GBUpdateX put: (startX * 256).	updateData at: GBUpdateY put: (startY * 256).	updateData at: GBUpdateDX put: fwDx.	updateData at: GBUpdateDY put: fwDy.	updateData at: GBUpdateDDX put: fwDDx.	updateData at: GBUpdateDDY put: fwDDy.	"And step to the first scan line"	(startY _ self edgeYValueOf: bezier) = yValue ifFalse:[		self stepToNextBezierIn: bezier at: yValue.		"Adjust number of lines remaining"		self edgeNumLinesOf: bezier put: deltaY - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/6/1998 00:08'!stepToNextBezier	"Process the current entry in the AET by stepping to the next scan line"	self inline: true.	^self stepToNextBezierIn: (aetBuffer at: self aetStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 01:49'!stepToNextBezierForward: updateData at: yValue	"Incrementally step to the next scan line in the given bezier update data.	Note: This method has been written so that inlining works, e.g.,		not declaring updateData as 'int*' but casting it on every use."	| minY lastX lastY fwDx fwDy |	self inline: true.	lastX _ (self cCoerce: updateData to: 'int*') at: GBUpdateX.	lastY _ (self cCoerce: updateData to: 'int*') at: GBUpdateY.	fwDx _ (self cCoerce: updateData to: 'int*') at: GBUpdateDX.	fwDy _ (self cCoerce: updateData to: 'int*') at: GBUpdateDY.	minY _ yValue * 256.	"Step as long as we haven't yet reached minY and also	as long as fwDy is greater than zero thus stepping down.	Note: The test for fwDy should not be necessary in theory		but is a good insurance in practice."	[minY > lastY and:[fwDy >= 0]] whileTrue:[		lastX _ lastX + ((fwDx + 16r8000) // 16r10000).		lastY _ lastY + ((fwDy + 16r8000) // 16r10000).		fwDx _ fwDx + ((self cCoerce: updateData to: 'int*') at: GBUpdateDDX).		fwDy _ fwDy + ((self cCoerce: updateData to: 'int*') at: GBUpdateDDY).	].	(self cCoerce: updateData to: 'int*') at: GBUpdateX put: lastX.	(self cCoerce: updateData to: 'int*') at: GBUpdateY put: lastY.	(self cCoerce: updateData to: 'int*') at: GBUpdateDX put: fwDx.	(self cCoerce: updateData to: 'int*') at: GBUpdateDY put: fwDy.	^lastX // 256! !!BalloonEnginePlugin methodsFor: 'beziers-simple' stamp: 'ar 11/9/1998 15:39'!stepToNextBezierIn: bezier at: yValue	"Incrementally step to the next scan line in the given bezier"	|  xValue |	self inline: true.	xValue _ self stepToNextBezierForward: (self bezierUpdateDataOf: bezier) at: yValue.	self edgeXValueOf: bezier put: xValue.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 15:18'!adjustWideBezierLeft: bezier width: lineWidth offset: lineOffset endX: endX	"Adjust the wide bezier curve (dx < 0) to start/end at the right point"	| lastX lastY |	self inline: false.	(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 		(((self bezierUpdateDataOf: bezier) at: GBUpdateX) - (lineOffset * 256)).	"Set the lastX/Y value of the second curve lineWidth pixels right/down"	lastX _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateX.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateX put: lastX + (lineWidth - lineOffset * 256).	"Set lineWidth pixels down"	lastY _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateY.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateY put: lastY + (lineWidth * 256).	"Record the last X value"	self bezierFinalXOf: bezier put: endX - lineOffset.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 15:18'!adjustWideBezierRight: bezier width: lineWidth offset: lineOffset endX: endX	"Adjust the wide bezier curve (dx >= 0) to start/end at the right point"	| lastX lastY |	self inline: false.	(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 		(((self bezierUpdateDataOf: bezier) at: GBUpdateX) + (lineOffset * 256)).	"Set the lastX/Y value of the second curve lineWidth pixels right/down"	"Set lineWidth-lineOffset pixels left"	lastX _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateX.	(self wideBezierUpdateDataOf: bezier) at: GBUpdateX put: lastX - (lineWidth - lineOffset * 256).	lastY _ (self wideBezierUpdateDataOf: bezier) at: GBUpdateY.	"Set lineWidth pixels down"	(self wideBezierUpdateDataOf: bezier) at: GBUpdateY put: lastY + (lineWidth * 256).	"Record the last X value"	self bezierFinalXOf: bezier put: endX - lineOffset + lineWidth.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/8/1998 03:44'!computeFinalWideBezierValues: bezier width: lineWidth	"Get both values from the two boundaries of the given bezier 	and compute the actual position/width of the line"	| leftX rightX temp |	leftX _ ((self bezierUpdateDataOf: bezier) at: GBUpdateX) // 256.	rightX _ ((self wideBezierUpdateDataOf: bezier) at: GBUpdateX) // 256.	leftX > rightX ifTrue:[temp _ leftX. leftX _ rightX. rightX _ temp].	self edgeXValueOf: bezier put: leftX.	(rightX - leftX) > lineWidth ifTrue:[		self wideBezierWidthOf: bezier put: (rightX - leftX).	] ifFalse:[		self wideBezierWidthOf: bezier put: lineWidth.	].! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 01:54'!returnWideBezierFill	^(dispatchReturnValue _ self wideBezierFillOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 01:54'!returnWideBezierWidth	^(dispatchReturnValue _ self wideBezierWidthOf: dispatchedValue).! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 02:00'!stepToFirstWideBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	^self stepToFirstWideBezierIn: (getBuffer at: self getStartGet) at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/9/1998 15:38'!stepToFirstWideBezierIn: bezier at: yValue	"Initialize the bezier at yValue"		| lineWidth startY nLines yEntry yExit lineOffset endX xDir |	self inline: false.	"Get some values"	lineWidth _ self wideBezierExtentOf: bezier.	lineOffset _ self offsetFromWidth: lineWidth.	"Compute the incremental values of the bezier"	endX _ self bezierEndXOf: bezier.	startY _ self edgeYValueOf: bezier.	self stepToFirstBezierIn: bezier at: startY.	nLines _ (self edgeNumLinesOf: bezier).	"Copy the incremental update data"	0 to: 5 do:[:i|		(self wideBezierUpdateDataOf: bezier) at: i put:			((self bezierUpdateDataOf: bezier) at: i).	].	"Compute primary x direction of curve (e.g., 1: left to right; -1: right to left)."	xDir _ ((self bezierUpdateDataOf: bezier) at: GBUpdateDX).	xDir = 0 ifTrue:[((self bezierUpdateDataOf: bezier) at: GBUpdateDDX)].	xDir >= 0 ifTrue:[xDir _ 1] ifFalse:[xDir _ -1].	"Adjust the curve to start/end at the right position"	xDir < 0		ifTrue:[self adjustWideBezierLeft: bezier width: lineWidth offset: lineOffset endX: endX]		ifFalse:[self adjustWideBezierRight: bezier width: lineWidth offset: lineOffset endX: endX].	"Adjust the last value for horizontal lines"	nLines = 0 ifTrue:[(self bezierUpdateDataOf: bezier) at: GBUpdateX put: 						(self bezierFinalXOf: bezier) * 256].	"Adjust the number of lines to include the lineWidth"	self edgeNumLinesOf: bezier put: nLines + lineWidth.	"Compute the points where we have to turn on/off the fills"	yEntry _ 0.						"turned on at lineOffset"	yExit _ 0 - nLines - lineOffset.	"turned off at zero"	self wideBezierEntryOf: bezier put: yEntry.	self wideBezierExitOf: bezier put: yExit.	"Turn the fills on/off as necessary"	(yEntry >= lineOffset and:[yExit < 0])		ifTrue:[self edgeFillsValidate: bezier]		ifFalse:[self edgeFillsInvalidate: bezier].	self computeFinalWideBezierValues: bezier width: lineWidth.	"And step to the first scan line"	startY = yValue ifFalse:[		"Note: Must single step here so that entry/exit works"		startY to: yValue-1 do:[:i| self stepToNextWideBezierIn: bezier at: i].		"Adjust number of lines remaining"		self edgeNumLinesOf: bezier put: (self edgeNumLinesOf: bezier) - (yValue - startY).	].! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/6/1998 02:34'!stepToNextWideBezier	"Initialize the current entry in the GET by stepping to the current scan line"	self inline: true.	self stepToNextWideBezierIn: (aetBuffer at: self aetStartGet) at: self currentYGet.! !!BalloonEnginePlugin methodsFor: 'beziers-wide' stamp: 'ar 11/9/1998 15:39'!stepToNextWideBezierIn: bezier at: yValue	"Incrementally step to the next scan line in the given wide bezier"	|  yEntry yExit lineWidth lineOffset |	self inline: false.	"Don't inline this"	lineWidth _ self wideBezierExtentOf: bezier.	lineOffset _ self offsetFromWidth: lineWidth.	yEntry _ (self wideBezierEntryOf: bezier) + 1.	yExit _ (self wideBezierExitOf: bezier) + 1.	self wideBezierEntryOf: bezier put: yEntry.	self wideBezierExitOf: bezier put: yExit.	yEntry >= lineOffset ifTrue:[self edgeFillsValidate: bezier].	yExit >= 0 ifTrue:[self edgeFillsInvalidate: bezier].	"Check if we have to step the upper curve"	(yExit + lineOffset < 0) ifTrue:[		self stepToNextBezierForward: (self bezierUpdateDataOf: bezier) at: yValue.	] ifFalse:[		"Adjust the last x value to the final x recorded previously"		(self bezierUpdateDataOf: bezier) at: GBUpdateX put: (self bezierFinalXOf: bezier) * 256.	].	"Step the lower curve"	self stepToNextBezierForward: (self wideBezierUpdateDataOf: bezier) at: yValue.	self computeFinalWideBezierValues: bezier width: lineWidth.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/9/1998 16:07'!checkCompressedFillIndexList: fillList max: maxIndex segments: nSegs	"Check the fill indexes in the run-length encoded fillList"	| length runLength runValue nFills fillPtr |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	length _ interpreterProxy slotSizeOf: fillList.	fillPtr _ interpreterProxy firstIndexableField: fillList.	nFills _ 0.	0 to: length-1 do:[:i|		runLength _ self shortRunLengthAt: i from: fillPtr.		runValue _ self shortRunValueAt: 0 from: fillPtr.		(runValue >= 0 and:[runValue <= maxIndex]) ifFalse:[^false].		nFills _ nFills + runLength.	].	^nFills = nSegs! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 15:19'!checkCompressedFills: indexList	"Check if the indexList (containing fill handles) is okay."	| fillPtr length fillIndex |	self inline: false.	self var: #fillPtr declareC:'int *fillPtr'.	"First check if the oops have the right format"	(interpreterProxy isWords: indexList) ifFalse:[^false].	"Then check the fill entries"	length _ interpreterProxy slotSizeOf: indexList.	fillPtr _ interpreterProxy firstIndexableField: indexList.	1 to: length do:[:i|		fillIndex _ fillPtr at: 0.		"Make sure the fill is okay"		(fillIndex = 0 or:[(self isFillColor: fillIndex) or:[			((self isObject: fillIndex) and:[self isFill: fillIndex])]]) 				ifFalse:[^false].		fillPtr _ fillPtr + 1].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/9/1998 16:07'!checkCompressedLineWidths: lineWidthList segments: nSegments	"Check the run-length encoded lineWidthList matches nSegments"	| length runLength nItems ptr |	self inline: false.	self var: #ptr declareC:'int *ptr'.	length _ interpreterProxy slotSizeOf: lineWidthList.	ptr _ interpreterProxy firstIndexableField: lineWidthList.	nItems _ 0.	0 to: length-1 do:[:i|		runLength _ self shortRunLengthAt: i from: ptr.		nItems _ nItems + runLength.	].	^nItems = nSegments! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 15:19'!checkCompressedPoints: points segments: nSegments	"Check if the given point array can be handled by the engine."	| pSize |	self inline: false.	(interpreterProxy isWords: points) ifFalse:[^false].	pSize _ interpreterProxy slotSizeOf: points.	"The points must be either in PointArray format or ShortPointArray format.	Also, we currently handle only quadratic segments (e.g., 3 points each) and thus either		pSize = nSegments * 3,		for ShortPointArrays or,		pSize = nSegments * 6,		for PointArrays"	(pSize = (nSegments * 3) or:[pSize = (nSegments * 6)]) 		ifFalse:[^false]. "Can't handle this"	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/12/1998 21:22'!checkCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	"Check if the given shape can be handled by the engine. 	Since there are a number of requirements this is an extra method."	| maxFillIndex |	self inline: false.	(self checkCompressedPoints: points segments: nSegments) 		ifFalse:[^false].	(self checkCompressedFills: fillIndexList)		ifFalse:[^false].	maxFillIndex _ interpreterProxy slotSizeOf: fillIndexList.	(self checkCompressedFillIndexList: leftFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedFillIndexList: rightFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedFillIndexList: lineFills max: maxFillIndex segments: nSegments)		ifFalse:[^false].	(self checkCompressedLineWidths: lineWidths segments: nSegments)		ifFalse:[^false].	^true! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 19:39'!loadCompressedSegment: segmentIndex from: points short: pointsShort leftFill: leftFill rightFill: rightFill lineWidth: lineWidth lineColor: lineFill haveMatrix: haveMatrix	"Load the compressed segment identified by segment index"	| x0 y0 x1 y1 x2 y2 index segs |	self inline: true.	"Check if have anything to do at all"	(leftFill = rightFill and:[lineWidth = 0 or:[lineFill = 0]]) 		ifTrue:[^nil]. "Nothing to do"	index _ segmentIndex * 6. "3 points with x/y each"	pointsShort ifTrue:["Load short points"		x0 _ self loadPointShortAt: (index+0) from: points.		y0 _ self loadPointShortAt: (index+1) from: points.		x1 _ self loadPointShortAt: (index+2) from: points.		y1 _ self loadPointShortAt: (index+3) from: points.		x2 _ self loadPointShortAt: (index+4) from: points.		y2 _ self loadPointShortAt: (index+5) from: points.	] ifFalse:[		x0 _ self loadPointIntAt: (index+0) from: points.		y0 _ self loadPointIntAt: (index+1) from: points.		x1 _ self loadPointIntAt: (index+2) from: points.		y1 _ self loadPointIntAt: (index+3) from: points.		x2 _ self loadPointIntAt: (index+4) from: points.		y2 _ self loadPointIntAt: (index+5) from: points.	].	"Briefly check if can represent the bezier as a line"	((x0 = x1 and:[y0 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[		"We can use a line from x0/y0 to x2/y2"		(x0 = x2 and:[y0 = y2]) ifTrue:[^nil]. "Nothing to do"		"Load and transform points"		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x2.		self point2Get at: 1 put: y2.		self transformPoints: 2 haveMatrix: haveMatrix.		^self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: leftFill 			rightFill: rightFill.	].	"Need bezier curve"	"Load and transform points"	self point1Get at: 0 put: x0.	self point1Get at: 1 put: y0.	self point2Get at: 0 put: x1.	self point2Get at: 1 put: y1.	self point3Get at: 0 put: x2.	self point3Get at: 1 put: y2.	self transformPoints: 3 haveMatrix: haveMatrix.	segs _ self loadAndSubdivideBezierFrom: self point1Get 				via: self point2Get 				to: self point3Get 				isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).	engineStopped ifTrue:[^nil].	self loadWideBezier: lineWidth lineFill: lineFill leftFill: leftFill rightFill: rightFill n: segs.! !!BalloonEnginePlugin methodsFor: 'shapes-compressed' stamp: 'ar 11/8/1998 03:48'!loadCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList haveMatrix: haveMatrix pointShort: pointsShort	"Load a compressed shape into the engine.		WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!!!!!	"	| leftRun rightRun widthRun lineFillRun	leftLength rightLength widthLength lineFillLength	leftValue rightValue widthValue lineFillValue |	self inline: false. "Don't you!!!!!!!!"	self var: #points declareC:'int *points'.	self var: #leftFills declareC:'int *leftFills'.	self var: #rightFills declareC:'int *rightFills'.	self var: #lineWidths declareC:'int *lineWidths'.	self var: #lineFills declareC:'int *lineFills'.	self var: #fillIndexList declareC:'int *fillIndexList'.	nSegments = 0 ifTrue:[^0].	"Initialize run length encodings"	leftRun _  rightRun _ widthRun _ lineFillRun _ -1.	leftLength _ rightLength _ widthLength _ lineFillLength _ 1.	leftValue _ rightValue _ widthValue _ lineFillValue _ 0.	1 to: nSegments do:[:i|		"Decrement current run length and load new stuff"		(leftLength _ leftLength - 1) <= 0 ifTrue:[			leftRun _ leftRun + 1.			leftLength _ self shortRunLengthAt: leftRun from: leftFills.			leftValue _ self shortRunValueAt: leftRun from: leftFills.			leftValue = 0 ifFalse:[leftValue _ fillIndexList at: leftValue-1]].		(rightLength _ rightLength - 1) <= 0 ifTrue:[			rightRun _ rightRun + 1.			rightLength _ self shortRunLengthAt: rightRun from: rightFills.			rightValue _ self shortRunValueAt: rightRun from: rightFills.			rightValue = 0 ifFalse:[rightValue _ fillIndexList at: rightValue-1]].		(widthLength _ widthLength - 1) <= 0 ifTrue:[			widthRun _ widthRun + 1.			widthLength _ self shortRunLengthAt: widthRun from: lineWidths.			widthValue _ self shortRunValueAt: widthRun from: lineWidths.			widthValue = 0 ifFalse:[				widthValue _ self transformWidth: widthValue haveMatrix: haveMatrix.				"Always require at least one pixel width"				widthValue = 0 ifTrue:[widthValue _ 1]]].		(lineFillLength _ lineFillLength - 1) <= 0 ifTrue:[			lineFillRun _ lineFillRun + 1.			lineFillLength _ self shortRunLengthAt: lineFillRun from: lineFills.			lineFillValue _ self shortRunValueAt: lineFillRun from: lineFills.			lineFillValue = 0 ifFalse:[lineFillValue _ fillIndexList at: lineFillValue-1]].		self loadCompressedSegment: i - 1			from: points 			short: pointsShort 			leftFill: leftValue 			rightFill: rightValue 			lineWidth: widthValue 			lineColor: lineFillValue			haveMatrix: haveMatrix.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/10/1998 18:34'!loadArrayPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill haveMatrix: haveMatrix	| firstX firstY x0 y0 x1 y1 |	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: points).	interpreterProxy failed ifTrue:[^nil].	firstX _ x0 _ self point1Get at: 0.	firstY _ y0 _ self point1Get at: 1.	1 to: nPoints-1 do:[:i|		self loadPoint: self point1Get from: (interpreterProxy fetchPointer: i ofObject: points).		interpreterProxy failed ifTrue:[^nil].		x1 _ self point1Get at: 0.		y1 _ self point1Get at: 1.		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].	(x1 = firstX and:[y1 = firstY]) ifFalse:[		self point1Get at: 0 put: x1.		self point1Get at: 1 put: y1.		self point2Get at: 0 put: firstX.		self point2Get at: 1 put: firstY.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/14/1998 20:44'!loadArrayShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill  haveMatrix: haveMatrix	| pointOop x0 y0 x1 y1 x2 y2 segs |	self inline: false.	0 to: nSegments-1 do:[:i|		pointOop _ interpreterProxy fetchPointer: (i * 3) ofObject: points.		self loadPoint: self point1Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 1) ofObject: points.		self loadPoint: self point2Get from: pointOop.		pointOop _ interpreterProxy fetchPointer: (i * 3 + 2) ofObject: points.		self loadPoint: self point3Get from: pointOop.		interpreterProxy failed ifTrue:[^nil].		self transformPoints: 3 haveMatrix: haveMatrix.		x0 _ self point1Get at: 0.		y0 _ self point1Get at: 1.		x1 _ self point2Get at: 0.		y1 _ self point2Get at: 1.		x2 _ self point3Get at: 0.		y2 _ self point3Get at: 1.		"Check if we can use a line"		((x0 = y0 and:[x1 = y1]) or:[x1 = x2 and:[y1 = y2]]) ifTrue:[			self loadWideLine: lineWidth				from: self point1Get				to: self point3Get				lineFill: lineFill				leftFill: fillIndex				rightFill: 0.		] ifFalse:["Need bezier"			segs _ self loadAndSubdivideBezierFrom: self point1Get					via: self point2Get					to: self point3Get					isWide: (lineWidth ~= 0 and:[lineFill ~= 0]).			engineStopped ifTrue:[^nil].			self loadWideBezier: lineWidth				lineFill: lineFill				leftFill: fillIndex				rightFill: 0				n: segs.		].		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/10/1998 19:27'!loadPolygon: points nPoints: nPoints fill: fillIndex lineWidth: lineWidth lineFill: lineFill pointsShort: isShort haveMatrix: haveMatrix	| firstX firstY x0 y0 x1 y1 |	self var:#points declareC:'int *points'.	isShort ifTrue:[		firstX _ x0 _ self loadPointShortAt: 0 from: points.		firstY _ y0 _ self loadPointShortAt: 1 from: points.	] ifFalse:[		firstX _ x0 _ self loadPointIntAt: 0 from: points.		firstY _ y0 _ self loadPointIntAt: 1 from: points.	].	1 to: nPoints-1 do:[:i|		isShort ifTrue:[			x1 _ self loadPointShortAt: i*2 from: points.			y1 _ self loadPointShortAt: i*2+1 from: points.		] ifFalse:[			x1 _ self loadPointIntAt: i*2 from: points.			y1 _ self loadPointIntAt: i*2+1 from: points.		].		self point1Get at: 0 put: x0.		self point1Get at: 1 put: y0.		self point2Get at: 0 put: x1.		self point2Get at: 1 put: y1.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.		engineStopped ifTrue:[^nil].		x0 _ x1.		y0 _ y1.	].	(x1 = firstX and:[y1 = firstY]) ifFalse:[		self point1Get at: 0 put: x1.		self point1Get at: 1 put: y1.		self point2Get at: 0 put: firstX.		self point2Get at: 1 put: firstY.		self transformPoints: 2 haveMatrix: haveMatrix.		self loadWideLine: lineWidth 			from: self point1Get			to: self point2Get			lineFill: lineFill 			leftFill: fillIndex			rightFill: 0.	].! !!BalloonEnginePlugin methodsFor: 'shapes-polygons' stamp: 'ar 11/14/1998 20:45'!loadShape: points nSegments: nSegments fill: fillIndex lineWidth: lineWidth lineFill: lineFill  pointsShort: pointsShort haveMatrix: haveMatrix	self inline: false.	self var:#points declareC:'int *points'.	1 to: nSegments do:[:i|		self loadCompressedSegment: i-1			from: points			short: pointsShort			leftFill: fillIndex			rightFill: 0			lineWidth: lineWidth			lineColor: lineFill			haveMatrix: haveMatrix.		engineStopped ifTrue:[^nil].	].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 15:20'!fillLinearGradient	self inline: true.	^self fillLinearGradient: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 17:15'!fillLinearGradient: fill from: leftX to: rightX at: yValue	"Draw a linear gradient fill."	| x0 x1 ramp rampSize dsX ds x rampIndex |	self inline: false.	self var: #ramp declareC:'int *ramp'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	dsX _ self gradientDirectionXOf: fill.	ds _ ((leftX - (self gradientOriginXOf: fill)) * dsX) + 			((yValue - (self gradientOriginYOf: fill)) * (self gradientDirectionYOf: fill)).	x _ x0 _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	[((rampIndex _ ds // 16r10000) < 0 or:[rampIndex > rampSize]) and:[x < x1]] 		whileTrue:[	x _ x + 1.					ds _ ds + dsX].	x > x0 ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: 0)) from: x0 to: x].	"Part two: Fill everything inside the boundaries"	self aaLevelGet = 1 ifTrue:[		"Fast version w/o anti-aliasing"		[((rampIndex _ ds // 16r10000) < rampSize and:[rampIndex >= 0]) and:[x < x1]] whileTrue:[			spanBuffer at: x put: (self makeUnsignedFrom: (ramp at: rampIndex)).			x _ x + 1.			ds _ ds + dsX.		].	] ifFalse:[x _ self fillLinearGradientAA: fill ramp: ramp ds: ds dsX: dsX from: x to: rightX].	"Part three fill everything outside right boundary"	x < x1 ifTrue:[		rampIndex < 0 ifTrue:[rampIndex _ 0].		rampIndex >= rampSize ifTrue:[rampIndex _ rampSize-1].		self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampIndex)) from: x to: x1].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 17:18'!fillLinearGradientAA: fill ramp: ramp ds: deltaS dsX: dsX from: leftX to: rightX	"This is the AA version of linear gradient filling."	| colorMask colorShift baseShift rampIndex ds rampSize x idx rampValue 	 aaLevel firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampSize _ self gradientRampLengthOf: fill.	ds _ deltaS.	x _ leftX.	rampIndex _ ds // 16r10000.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	"Deal with the first n sub-pixels"	colorMask _ self aaColorMaskGet.	colorShift _ self aaColorShiftGet.	[x < firstPixel and:[rampIndex < rampSize and:[rampIndex >= 0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < firstPixel and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + 1.			ds _ ds + dsX].		rampIndex _ ds // 16r10000.	].	"Deal with the full pixels"	colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.	colorShift _ self aaShiftGet.	[x < lastPixel and:[rampIndex < rampSize and:[rampIndex >= 0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < lastPixel and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + aaLevel.			ds _ ds + (dsX << colorShift)].		rampIndex _ ds // 16r10000.	].	"Deal with the last n sub-pixels"	colorMask _ self aaColorMaskGet.	colorShift _ self aaColorShiftGet.	[x < rightX and:[rampIndex < rampSize and:[rampIndex>=0]]] whileTrue:[		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		"Copy as many pixels as possible"		[x < rightX and:[(ds//16r10000) = rampIndex]] whileTrue:[			idx _ x >> baseShift.			spanBuffer at: idx put: (spanBuffer at: idx) + rampValue.			x _ x + 1.			ds _ ds + dsX].		rampIndex _ ds // 16r10000.	].	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 22:51'!fillRadialDecreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ rightX.	x1 > (self gradientOriginXOf: fill) ifTrue:[x1 _ self gradientOriginXOf: fill].	[x < x1] whileTrue:[		"Try to copy the current value more than just once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		"Step to next ramp value"		nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[nextLength < length2] whileTrue:[			rampIndex _ rampIndex - 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			length2 _ (rampIndex-1) * (rampIndex-1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 16:09'!fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2a) Compute the decreasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength x1	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	length2 _ (rampIndex-1) * (rampIndex-1).	x _ leftX.	x1 _ self gradientOriginXOf: fill.	x1 > rightX ifTrue:[x1 _ rightX].	firstPixel _ self aaFirstPixelFrom: leftX to: x1.	lastPixel _ self aaLastPixelFrom: leftX to: x1.	"Deal with the first n sub-pixels"	(x < firstPixel) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the full pixels"	(x < lastPixel) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel] whileTrue:[			"Try to copy the current value more than just once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Deal with the last n sub-pixels"	(x < x1) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < x1] whileTrue:[			"Try to copy the current value more than just once"			[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) >= length2]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			"Step to next ramp value"			nextLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[nextLength < length2] whileTrue:[				rampIndex _ rampIndex - 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				length2 _ (rampIndex-1) * (rampIndex-1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/8/1998 15:20'!fillRadialGradient	self inline: true.	^self fillRadialGradient: self lastExportedFillGet from: self lastExportedLeftXGet to: self lastExportedRightXGet at: self currentYGet! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 18:57'!fillRadialGradient: fill from: leftX to: rightX at: yValue	"Draw a radial gradient fill."	| x x1 ramp rampSize dsX ds dtX dt length2 deltaX deltaY deltaST |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:'int *deltaST'.	ramp _ self gradientRampOf: fill.	rampSize _ self gradientRampLengthOf: fill.	deltaX _ leftX - (self gradientOriginXOf: fill).	deltaY _ yValue - (self gradientOriginYOf: fill).	dsX _ self gradientDirectionXOf: fill.	dtX _ self gradientNormalXOf: fill.	ds _ (deltaX * dsX) + (deltaY * (self gradientDirectionYOf: fill)).	dt _ (deltaX * dtX) + (deltaY * (self gradientNormalYOf: fill)).	x _ leftX.	x1 _ rightX.	"Note: The inner loop has been divided into three parts for speed"	"Part one: Fill everything outside the left boundary"	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	[(self squaredLengthOf: ds // 16r10000 with: dt // 16r10000) >= length2 and:[x < x1]]		whileTrue:[	x _ x + 1.	ds _ ds + dsX.	dt _ dt + dtX].	x > leftX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: leftX to: x].	"Part two: Fill everything inside the boundaries"	deltaST _ self point1Get.	deltaST at: 0 put: ds.	deltaST at: 1 put: dt.	(x < (self gradientOriginXOf: fill)) ifTrue:[		"Draw the decreasing part"		self aaLevelGet = 1 			ifTrue:[x _ self fillRadialDecreasing: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialDecreasingAA: fill ramp: ramp deltaST: deltaST 							dsX: dsX dtX: dtX from: x to: x1].	].	x < x1 ifTrue:[		"Draw the increasing part"		self aaLevelGet = 1			ifTrue:[x _ self fillRadialIncreasing: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1]			ifFalse:[x _ self fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST							dsX: dsX dtX: dtX from: x to: x1].	].	"Part three fill everything outside right boundary"	x < rightX ifTrue:[self fillColorSpan: (self makeUnsignedFrom: (ramp at: rampSize-1)) from: x to: rightX].! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 01:21'!fillRadialIncreasing: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2b) Compute the increasing part of the ramp"	| ds dt rampIndex rampValue length2 x x1 nextLength rampSize lastLength |	self inline: true.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).	rampSize _ self gradientRampLengthOf: fill.	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	nextLength _ (rampIndex+1) * (rampIndex+1).	lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.	x _ leftX.	x1 _ rightX.	[x < x1 and:[lastLength < length2]] whileTrue:[		"Try to copy the current value more than once"		[x < x1 and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]			whileTrue:[	spanBuffer at: x put: rampValue.						x _ x + 1.						ds _ ds + dsX.						dt _ dt + dtX].		lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.		[lastLength > nextLength] whileTrue:[			rampIndex _ rampIndex + 1.			rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).			nextLength _ (rampIndex+1) * (rampIndex+1).		].	].	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/9/1998 16:09'!fillRadialIncreasingAA: fill ramp: ramp deltaST: deltaST dsX: dsX dtX: dtX from: leftX to: rightX	"Part 2b) Compute the increasing part of the ramp"	| ds dt rampIndex rampValue length2 x nextLength rampSize lastLength 	aaLevel colorMask colorShift baseShift index firstPixel lastPixel |	self inline: false.	self var: #ramp declareC:'int *ramp'.	self var: #deltaST declareC:' int *deltaST'.	ds _ (self cCoerce: deltaST to:'int*') at: 0.	dt _ (self cCoerce: deltaST to:'int*') at: 1.	aaLevel _ self aaLevelGet.	baseShift _ self aaShiftGet.	rampIndex _ self accurateLengthOf: ds // 16r10000 with: dt // 16r10000.	rampSize _ self gradientRampLengthOf: fill.	length2 _ (rampSize-1) * (rampSize-1). "This is the upper bound"	nextLength _ (rampIndex+1) * (rampIndex+1).	lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.	x _ leftX.	firstPixel _ self aaFirstPixelFrom: leftX to: rightX.	lastPixel _ self aaLastPixelFrom: leftX to: rightX.	"Deal with the first n subPixels"	(x < firstPixel and:[lastLength < length2]) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < firstPixel and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < firstPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Deal with the full pixels"	(x < lastPixel and:[lastLength < length2]) ifTrue:[		colorMask _ (self aaColorMaskGet >> self aaShiftGet) bitOr: 16rF0F0F0F0.		colorShift _ self aaShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < lastPixel and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < lastPixel and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + aaLevel.							ds _ ds + (dsX << colorShift).							dt _ dt + (dtX << colorShift)].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Deal with last n sub-pixels"	(x < rightX and:[lastLength < length2]) ifTrue:[		colorMask _ self aaColorMaskGet.		colorShift _ self aaColorShiftGet.		rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).		rampValue _ (rampValue bitAnd: colorMask) >> colorShift.		[x < rightX and:[lastLength < length2]] whileTrue:[			"Try to copy the current value more than once"			[x < rightX and:[(self squaredLengthOf: ds //  16r10000 with: dt // 16r10000) <= nextLength]]				whileTrue:[	index _ x >> baseShift.							spanBuffer at: index put: (spanBuffer at: index) + rampValue.							x _ x + 1.							ds _ ds + dsX.							dt _ dt + dtX].			lastLength _ self squaredLengthOf: ds //  16r10000 with: dt // 16r10000.			[lastLength > nextLength] whileTrue:[				rampIndex _ rampIndex + 1.				rampValue _ self makeUnsignedFrom: ((self cCoerce: ramp to:'int *') at: rampIndex).				rampValue _ (rampValue bitAnd: colorMask) >> colorShift.				nextLength _ (rampIndex+1) * (rampIndex+1).			].		].	].	"Done -- store stuff back"	(self cCoerce: deltaST to: 'int *') at: 0 put: ds.	(self cCoerce: deltaST to: 'int *') at: 1 put: dt.	^x! !!BalloonEnginePlugin methodsFor: 'fills-gradient' stamp: 'ar 11/10/1998 19:03'!loadGradientFill: rampOop from: point1 along: point2 normal: point3 isRadial: isRadial haveMatrix: haveMatrix	"Load the gradient fill as defined by the color ramp."	| rampWidth fill dirX dirY nrmX nrmY dsLength2 dsX dsY dtLength2 dtX dtY |	self inline: false.	self var: #point1 declareC:'int *point1'.	self var: #point2 declareC:'int *point2'.	self var: #point3 declareC:'int *point3'.	(interpreterProxy fetchClassOf: rampOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	rampWidth _ interpreterProxy slotSizeOf: rampOop.	fill _ self allocateGradientFill: (interpreterProxy firstIndexableField: rampOop)				rampWidth: rampWidth isRadial: isRadial.	engineStopped ifTrue:[^nil].	"Transform the points"	point2 at: 0 put: (point2 at: 0) + (point1 at: 0).	point2 at: 1 put: (point2 at: 1) + (point1 at: 1).	point3 at: 0 put: (point3 at: 0) + (point1 at: 0).	point3 at: 1 put: (point3 at: 1) + (point1 at: 1).	self transformPoint: point1 haveMatrix: haveMatrix.	self transformPoint: point2 haveMatrix: haveMatrix.	self transformPoint: point3 haveMatrix: haveMatrix.	dirX _ (point2 at: 0) - (point1 at: 0).	dirY _ (point2 at: 1) - (point1 at: 1).	nrmX _ (point3 at: 0) - (point1 at: 0).	nrmY _ (point3 at: 1) - (point1 at: 1).	"Compute the scale from direction/normal into ramp size"	dsLength2 _ (dirX * dirX) + (dirY * dirY).	dsLength2 > 0 ifTrue:[		dsX _ (dirX asFloat * rampWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.		dsY _ (dirY asFloat * rampWidth asFloat * 65536.0 / dsLength2 asFloat) asInteger.		"(isRadial not and:[dsX < 0]) ifTrue:[			dsX _ 0 - dsX.			self swapRampEntries: fill]."	] ifFalse:[ dsX _ 0. dsY _ 0].	dtLength2 _ (nrmX * nrmX) + (nrmY * nrmY).	dtLength2 > 0 ifTrue:[		dtX _ (nrmX asFloat * rampWidth asFloat * 65536.0 / dtLength2 asFloat) asInteger.		dtY _ (nrmY asFloat * rampWidth asFloat * 65536.0 / dtLength2 asFloat) asInteger.	] ifFalse:[dtX _ 0. dtY _ 0].	self gradientOriginXOf: fill put: (point1 at: 0).	self gradientOriginYOf: fill put: (point1 at: 1).	self gradientDirectionXOf: fill put: dsX.	self gradientDirectionYOf: fill put: dsY.	self gradientNormalXOf: fill put: dtX.	self gradientNormalYOf: fill put: dtY.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 10/30/1998 21:49'!allocateBezier	| bezier |	(self allocateObjEntry: GBBaseSize) ifFalse:[^0].	bezier _ self objUsedGet.	self objUsedPut: self objUsedGet + GBBaseSize.	self objectTypeOf: bezier put: GEPrimitiveBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBBaseSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 10/30/1998 20:52'!allocateBezierStackEntry	self wbStackPush: 6.	^self wbStackSize! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/8/1998 14:55'!allocateGradientFill: ramp rampWidth: rampWidth isRadial: isRadial	| fill fillSize rampPtr |	self var:#ramp declareC:'int *ramp'.	self var:#rampPtr declareC:'int *rampPtr'.	fillSize _ GGBaseSize + rampWidth.	(self allocateObjEntry: fillSize) ifFalse:[^0].	fill _ self objUsedGet.	self objUsedPut: self objUsedGet + fillSize.	isRadial		ifTrue:[self objectTypeOf: fill put: GEPrimitiveRadialGradientFill]		ifFalse:[self objectTypeOf: fill put: GEPrimitiveLinearGradientFill].	self objectIndexOf: fill put: 0.	self objectLengthOf: fill put: fillSize.	rampPtr _ self gradientRampOf: fill.	0 to: rampWidth-1 do:[:i| rampPtr at: i put: (ramp at: i)].	self gradientRampLengthOf: fill put: rampWidth.	^fill! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/1/1998 02:41'!allocateLine	| line |	(self allocateObjEntry: GLBaseSize) ifFalse:[^0].	line _ self objUsedGet.	self objUsedPut: self objUsedGet + GLBaseSize.	self objectTypeOf: line put: GEPrimitiveLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLBaseSize.	^line! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/6/1998 01:23'!allocateWideBezier	| bezier |	(self allocateObjEntry: GBWideSize) ifFalse:[^0].	bezier _ self objUsedGet.	self objUsedPut: self objUsedGet + GBWideSize.	self objectTypeOf: bezier put: GEPrimitiveWideBezier.	self objectIndexOf: bezier put: 0.	self objectLengthOf: bezier put: GBWideSize.	^bezier! !!BalloonEnginePlugin methodsFor: 'allocation' stamp: 'ar 11/4/1998 22:15'!allocateWideLine	| line |	(self allocateObjEntry: GLWideSize) ifFalse:[^0].	line _ self objUsedGet.	self objUsedPut: self objUsedGet + GLWideSize.	self objectTypeOf: line put: GEPrimitiveWideLine.	self objectIndexOf: line put: 0.	self objectLengthOf: line put: GLWideSize.	^line! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddBezierToGET: bezier	"Add the bezier to the global edge table if it intersects the clipping region"	| lineWidth |	self inline: true.	(self isWide: bezier) 		ifTrue:[lineWidth _ (self wideBezierExtentOf: bezier)]		ifFalse:[lineWidth _ 0].	(self bezierEndYOf: bezier) + lineWidth < (self fillMinYGet) ifTrue:[^0].	"Overlaps in Y but may still be entirely right of clip region"	((self edgeXValueOf: bezier) - lineWidth >= self fillMaxXGet and:[		(self bezierEndXOf: bezier) - lineWidth >= self fillMaxXGet]) ifTrue:[^0].	self addEdgeToGET: bezier.! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddEdgeToGET: edge	"Add the edge to the global edge table.	For known edge types, check if the edge intersects the visible region"	self inline: true.	(self isLine: edge) ifTrue:[^self checkedAddLineToGET: edge].	(self isBezier: edge) ifTrue:[^self checkedAddBezierToGET: edge].	self addEdgeToGET: edge.! !!BalloonEnginePlugin methodsFor: 'GET processing' stamp: 'ar 11/9/1998 15:37'!checkedAddLineToGET: line	"Add the line to the global edge table if it intersects the clipping region"	| lineWidth |	self inline: true.	(self isWide: line) 		ifTrue:[lineWidth _ (self wideLineExtentOf: line)]		ifFalse:[lineWidth _ 0].	(self lineEndYOf: line) + lineWidth < (self fillMinYGet) ifTrue:[^0].	"Overlaps in Y but may still be entirely right of clip region"	((self edgeXValueOf: line) - lineWidth >= self fillMaxXGet and:[		(self lineEndXOf: line) - lineWidth >= self fillMaxXGet]) ifTrue:[^0].	self addEdgeToGET: line.! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 10/30/1998 20:02'!absoluteSquared8Dot24: value	"Compute the squared value of a 8.24 number with 0.0 <= value < 1.0,	e.g., compute (value * value) bitShift: -24"	| word1 word2 |	self inline: true.	word1 _ value bitAnd: 16rFFFF.	word2 _ (value bitShift: -16) bitAnd: 255.	^(( (self cCoerce: (word1 * word1) to:'unsigned') bitShift: -16) +		((word1 * word2) * 2) +			((word2 * word2) bitShift: 16)) bitShift: -8! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 17:06'!circleCosTable	| theTable |	self returnTypeC:'double *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static double theTable[33] =		{1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,		1.0 }'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 17:06'!circleSinTable	| theTable |	self returnTypeC:'double *'.	self inline: false. "Don't you inline this!!!!!!"	self var:#theTable declareC:'static double theTable[33] =		{0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,		0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,		1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,		 0.0 }'.	^theTable! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 23:24'!loadPointIntAt: index from: intArray	"Load the int value from the given index in intArray"	^(self cCoerce: intArray to: 'int *') at: index! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 23:23'!loadPointShortAt: index from: shortArray	"Load the short value from the given index in shortArray"	self returnTypeC:'short'.	^(self cCoerce: shortArray to: 'short *') at: index! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/1/1998 03:16'!makeRectFromPoints	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/6/1998 17:55'!offsetFromWidth: lineWidth	"Common function so that we don't compute that wrong in any place	and can easily find all the places where we deal with one-pixel offsets."	self inline: true.	^lineWidth // 2! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 22:55'!shortRunLengthAt: i from: runArray	"Return the run-length value from the given ShortRunArray."	^((self cCoerce: runArray to:'int *') at: i) bitShift: - 16! !!BalloonEnginePlugin methodsFor: 'private' stamp: 'ar 11/3/1998 22:54'!shortRunValueAt: i from: runArray	"Return the run-length value from the given ShortRunArray.	Note: We don't need any coercion to short/int here, since	we deal basically only with unsigned values."	^(((self cCoerce: runArray to:'int *') at: i) bitAnd: 16rFFFF)! !!BalloonEnginePlugin class reorganize!('class initialization' declareCVarsIn:)!!BalloonEnginePlugin class methodsFor: 'class initialization' stamp: 'ar 11/11/1998 22:01'!declareCVarsIn: cg	"Nothing to declare"! !!BalloonEngineSimulation reorganize!('simulation' assert: circleCosTable circleSinTable copyBitsFrom:to:at: dispatchOn:in: ioMicroMSecs loadBitBltFrom: loadPointIntAt:from: loadPointShortAt:from: makeUnsignedFrom: shortRunLengthAt:from: shortRunValueAt:from: showDisplayBits smallSqrtTable)('debug support' debugDrawBezier: debugDrawEdge: debugDrawHLine: debugDrawLine: debugDrawLineFrom:to: debugDrawPt: debugDrawPtLineFrom:to: debugPrintObjects debugPrintPoints: printAET printGET quickPrint: quickPrintBezier: quickPrintBezier:first:)('initialize' initialize)!!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 20:46'!assert: bool	bool ifFalse:[^self error:'Assertion failed'].! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/9/1998 01:23'!circleCosTable	^CArrayAccessor on:#(1.0 0.98078528040323 0.923879532511287 0.831469612302545 0.7071067811865475 0.555570233019602 0.38268343236509 0.1950903220161286 0.0 -0.1950903220161283 -0.3826834323650896 -0.555570233019602 -0.707106781186547 -0.831469612302545 -0.9238795325112865 -0.98078528040323 -1.0 -0.98078528040323 -0.923879532511287 -0.831469612302545 -0.707106781186548 -0.555570233019602 -0.3826834323650903 -0.1950903220161287 0.0 0.1950903220161282 0.38268343236509 0.555570233019602 0.707106781186547 0.831469612302545 0.9238795325112865 0.98078528040323 1.0 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/9/1998 01:23'!circleSinTable	^CArrayAccessor on:#(0.0 0.1950903220161282 0.3826834323650897 0.555570233019602 0.707106781186547 0.831469612302545 0.923879532511287 0.98078528040323 1.0 0.98078528040323 0.923879532511287 0.831469612302545 0.7071067811865475 0.555570233019602 0.38268343236509 0.1950903220161286 0.0 -0.1950903220161283 -0.3826834323650896 -0.555570233019602 -0.707106781186547 -0.831469612302545 -0.9238795325112865 -0.98078528040323 -1.0 -0.98078528040323 -0.923879532511287 -0.831469612302545 -0.707106781186548 -0.555570233019602 -0.3826834323650903 -0.1950903220161287 0.0 )! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 13:32'!copyBitsFrom: x0 to: x1 at: y	bbObj copyBitsFrom: x0 to: x1 at: y.! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/29/1998 18:44'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	self perform: (selectorArray at: (anInteger + 1)).! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/29/1998 19:19'!ioMicroMSecs	^Time millisecondClockValue! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 01:05'!loadBitBltFrom: oop	bbObj _ oop.	^true! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 14:05'!loadPointIntAt: index from: intArray	"Load the int value from the given index in intArray"	^(index bitAnd: 1) = 0		ifTrue:[(intArray getObject at: (index // 2) + 1) x]		ifFalse:[(intArray getObject at: (index // 2) + 1) y]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 14:04'!loadPointShortAt: index from: intArray	"Load the int value from the given index in intArray"	^(index bitAnd: 1) = 0		ifTrue:[(intArray getObject at: (index // 2) + 1) x]		ifFalse:[(intArray getObject at: (index // 2) + 1) y]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/28/1998 01:05'!makeUnsignedFrom: integer	integer < 0 		ifTrue:[^(0 - integer - 1) bitInvert32]		ifFalse:[^integer]! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 13:54'!shortRunLengthAt: i from: runArray	^runArray getObject lengthAtRun: i+1! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 13:55'!shortRunValueAt: i from: runArray	^runArray getObject valueAtRun: i+1! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 10/31/1998 23:07'!showDisplayBits	"Do nothing."! !!BalloonEngineSimulation methodsFor: 'simulation' stamp: 'ar 11/4/1998 19:51'!smallSqrtTable	"Return a lookup table for rounded integer square root values from 0 to 31"	^CArrayAccessor on:#(0 1 1 2 2 2 2 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6 )! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:17'!debugDrawBezier: line	| canvas p1 p2 p3 |	self assert:(self isBezier: line).	p1 _ (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet.	p2 _ (self bezierViaXOf: line) @ (self bezierViaYOf: line) // self aaLevelGet.	p3 _ (self bezierEndXOf: line) @ (self bezierEndYOf: line) // self aaLevelGet.	canvas _ FormCanvas on: Display.	canvas		line: p1 to: p2 width: 2 color: Color blue;		line: p2 to: p3 width: 2 color: Color blue.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:16'!debugDrawEdge: edge	self assert: (self isEdge: edge).	(self isLine: edge) ifTrue:[^self debugDrawLine: edge].	(self isBezier: edge) ifTrue:[^self debugDrawBezier: edge].	self halt.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 13:26'!debugDrawHLine: yValue	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: 0 @ (yValue // self aaLevelGet)		to: Display extent x @ (yValue // self aaLevelGet)		width: 2		color: Color green.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 01:17'!debugDrawLine: line	| canvas |	self assert: (self isLine: line).	canvas _ FormCanvas on: Display.	canvas		line: (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet		to: (self lineEndXOf: line) @ (self lineEndYOf: line) // self aaLevelGet		width: 2		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 00:17'!debugDrawLineFrom: pt1 to: pt2	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: (pt1 at: 0) @ (pt1 at: 1) // self aaLevelGet		to: (pt2 at: 0) @ (pt2 at: 1) // self aaLevelGet		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/9/1998 01:31'!debugDrawPt: pt	| canvas |	canvas _ FormCanvas on: Display.	canvas		fillRectangle:((pt-2) corner: pt+2) color: Color red! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/9/1998 01:24'!debugDrawPtLineFrom: pt1 to: pt2	| canvas |	canvas _ FormCanvas on: Display.	canvas		line: pt1		to: pt2		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/6/1998 02:26'!debugPrintObjects	| object end |	self inline: false.	object _ 0.	end _ self objUsedGet.	[object < end] whileTrue:[		Transcript cr; 			nextPut:$#; print: object; space;			print: (self objectHeaderOf: object); space.		(self isEdge: object) 			ifTrue:[Transcript nextPutAll:'(edge) '].		(self isFill:object)			ifTrue:[Transcript nextPutAll:'(fill) '].		Transcript print: (self objectLengthOf: object); space.		Transcript endEntry.		object _ object + (self objectLengthOf: object).	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/1/1998 17:21'!debugPrintPoints: n	Transcript cr.	n > 0 ifTrue:[		Transcript print: (self point1Get at: 0) @ (self point1Get at: 1); space.	].	n > 1 ifTrue:[		Transcript print: (self point2Get at: 0) @ (self point2Get at: 1); space.	].	n > 2 ifTrue:[		Transcript print: (self point3Get at: 0) @ (self point3Get at: 1); space.	].	n > 3 ifTrue:[		Transcript print: (self point4Get at: 0) @ (self point4Get at: 1); space.	].	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 21:15'!printAET	| edge |	Transcript cr; show:'************* ActiveEdgeTable **************'.	0 to: self aetUsedGet - 1 do:[:i|		edge _ aetBuffer at: i.		Transcript cr;			print: i; space;			nextPutAll:'edge #';print: edge; space;			nextPutAll:'x: '; print: (self edgeXValueOf: edge); space;			nextPutAll:'y: '; print: (self edgeYValueOf: edge); space;			nextPutAll:'z: '; print: (self edgeZValueOf: edge); space;			nextPutAll:'fill0: '; print: (self edgeLeftFillOf: edge); space;			nextPutAll:'fill1: '; print: (self edgeRightFillOf: edge); space;			nextPutAll:'lines: '; print: (self edgeNumLinesOf: edge); space.		(self areEdgeFillsValid: edge) ifFalse:[Transcript nextPutAll:' disabled'].		Transcript endEntry.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 11/5/1998 21:14'!printGET	| edge |	Transcript cr; show:'************* GlobalEdgeTable **************'.	0 to: self getUsedGet - 1 do:[:i|		edge _ getBuffer at: i.		Transcript cr;			print: i; space;			nextPutAll:'edge #';print: edge; space;			nextPutAll:'x: '; print: (self edgeXValueOf: edge); space;			nextPutAll:'y: '; print: (self edgeYValueOf: edge); space;			nextPutAll:'z: '; print: (self edgeZValueOf: edge); space;			nextPutAll:'fill0: '; print: (self edgeLeftFillOf: edge); space;			nextPutAll:'fill1: '; print: (self edgeRightFillOf: edge); space;			nextPutAll:'lines: '; print: (self edgeNumLinesOf: edge); space.		(self areEdgeFillsValid: edge) ifFalse:[Transcript nextPutAll:' disabled'].		Transcript endEntry.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 21:57'!quickPrint: curve	Transcript nextPut:$(;		print: curve start;		space;		print: curve via;		space;		print: curve end;		nextPut:$).! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 22:18'!quickPrintBezier: bezier	Transcript cr.	Transcript nextPut:$(;		print: (self edgeXValueOf: bezier)@(self edgeYValueOf: bezier);		space;		print: (self bezierViaXOf: bezier)@(self bezierViaYOf: bezier);		space;		print: (self bezierEndXOf: bezier)@(self bezierEndYOf: bezier);		nextPut:$).	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 10/30/1998 22:00'!quickPrintBezier: index first: aBool	aBool ifTrue:[Transcript cr].	Transcript nextPut:$(;		print: (self bzStartX: index)@(self bzStartY: index);		space;		print: (self bzViaX: index)@(self bzViaY: index);		space;		print: (self bzEndX: index)@(self bzEndY: index);		nextPut:$).	Transcript endEntry.! !!BalloonEngineSimulation methodsFor: 'initialize' stamp: 'ar 11/8/1998 01:42'!initialize	edgeTransform _ CArrayAccessor on: (FloatArray new: 6).! !!BalloonEngineSimulation class methodsFor: 'instance creation' stamp: 'ar 10/29/1998 19:18'!new	^super new initialize! !!BalloonFillData reorganize!('accessing' destForm destForm: index index: maxX maxX: minX minX: source source: width yValue yValue:)('computing' computeFill)!!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!destForm	^destForm! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!destForm: aForm	destForm _ aForm! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!index	^index! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!index: anInteger	index _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!maxX	^maxX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!maxX: anInteger	maxX _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!minX	^minX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!minX: anInteger	minX _ anInteger! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!source	^source! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:56'!source: anObject	source _ anObject! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/28/1998 16:35'!width	^maxX - minX! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!yValue	^yValue! !!BalloonFillData methodsFor: 'accessing' stamp: 'ar 10/27/1998 15:55'!yValue: anInteger	yValue _ anInteger! !!BalloonFillData methodsFor: 'computing' stamp: 'ar 11/14/1998 19:32'!computeFill	(destForm isNil or:[destForm width < self width]) ifTrue:[		destForm _ Form extent: (self width + 10) @ 1 depth: 32.	].	source computeFillFrom: minX to: maxX at: yValue in: destForm! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!end	^end! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!end: aPoint	end _ aPoint! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialX	^start y <= end y		ifTrue:[start x]		ifFalse:[end x]! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialY	^start y <= end y		ifTrue:[start y]		ifFalse:[end y]! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/27/1998 20:31'!initialZ	^0 "Assume no depth given"! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!start	^start! !!BalloonLineSimulation methodsFor: 'accessing' stamp: 'ar 10/30/1998 03:02'!start: aPoint	start _ aPoint! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:52'!computeInitialStateFrom: source with: aTransformation	"Compute the initial state in the receiver."	start _ (aTransformation localPointToGlobal: source start) asIntegerPoint.	end _ (aTransformation localPointToGlobal: source end) asIntegerPoint.! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:22'!stepToFirstScanLineAt: yValue in: edgeTableEntry	"Compute the initial x value for the scan line at yValue"	|  startX endX startY endY yDir deltaY deltaX widthX |	(start y) <= (end y) ifTrue:[		startX _ start x.	endX _ end x.		startY _ start y.	endY _ end y.		yDir _ 1.	] ifFalse:[		startX _ end x.	endX _ start x.		startY _ end y.	endY _ start y.		yDir _ -1.	].	deltaY _ endY - startY.	deltaX _ endX - startX.	"Quickly check if the line is visible at all"	(yValue >= endY or:[deltaY = 0]) ifTrue:[^edgeTableEntry lines: 0].	"Check if edge goes left to right"	deltaX >= 0 ifTrue:[		xDirection _ 1.		widthX _ deltaX.		error _ 0.	] ifFalse:[		xDirection _ -1.		widthX _ 0 - deltaX.		error _ 1 - deltaY.	].	"Check if edge is horizontal"	deltaY = 0 		ifTrue:[	xIncrement _ 0.				errorAdjUp _ 0]		ifFalse:["Check if edge is y-major"			deltaY > widthX 				ifTrue:[	xIncrement _ 0.						errorAdjUp _ widthX]				ifFalse:[	xIncrement _ (widthX // deltaY) * xDirection.						errorAdjUp _ widthX \\ deltaY]].	errorAdjDown _ deltaY.	edgeTableEntry xValue: startX.	edgeTableEntry lines: deltaY.	"If not at first scan line then step down to yValue"	yValue = startY ifFalse:[		startY to: yValue do:[:y| self stepToNextScanLineAt: y in: edgeTableEntry].		"And adjust remainingLines"		edgeTableEntry lines: deltaY - (yValue - startY).	].! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 20:39'!stepToNextScanLineAt: yValue in: edgeTableEntry	"Compute the next x value for the scan line at yValue.	This message is sent during incremental updates. 	The yValue parameter is passed in here for edges	that have more complicated computations,"	| x |	x _ edgeTableEntry xValue + xIncrement.	error _ error + errorAdjUp.	error > 0 ifTrue:[		x _ x + xDirection.		error _ error - errorAdjDown.	].	edgeTableEntry xValue: x.! !!BalloonLineSimulation methodsFor: 'computing' stamp: 'ar 10/29/1998 23:42'!subdivide	^nil! !!BalloonLineSimulation methodsFor: 'printing' stamp: 'ar 10/27/1998 23:20'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut:$(;		print: start;		nextPutAll:' - ';		print: end;		nextPut:$)! !!BalloonSolidFillSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:07'!computeFillFrom: minX to: maxX at: yValue in: form	| bb |	color isTransparent ifFalse:[		bb _ BitBlt toForm: form.		bb fillColor: color.		bb destX: 0 destY: 0 width: (maxX - minX) height: 1.		bb combinationRule: Form over.		bb copyBits].! !!BalloonSolidFillSimulation methodsFor: 'computing' stamp: 'ar 10/27/1998 23:08'!computeInitialStateFrom: source with: aColorTransform	color _ source asColor.! !!Canvas methodsFor: 'testing' stamp: 'ar 11/13/1998 13:19'!isBalloonCanvas	^false! !!FormCanvas methodsFor: 'other' stamp: 'ar 11/11/1998 22:57'!asBalloonCanvas	^(BalloonCanvas on: form) setOrigin: origin clipRect: clipRect! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/11/1998 20:49'!initialize	transformStack _ OrderedCollection new.	aaLevel _ 1.! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/11/1998 20:25'!resetEngine	engine _ nil.! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/13/1998 01:02'!aaLevel	^aaLevel! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/14/1998 00:55'!aaLevel: newLevel	"Only allow changes to aaLevel if we're working on 32 bit forms"	form depth >= 8 ifFalse:[^self].	aaLevel _ newLevel.	engine ifNotNil:[engine aaLevel: aaLevel].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 11/11/1998 23:37'!ensuredEngine	^engine ifNil:[		engine _ BalloonEngine new.		engine aaLevel: aaLevel.		engine bitBlt: port.		engine destOffset: origin.		engine clipRect: clipRect.		engine].! !!BalloonCanvas methodsFor: 'testing' stamp: 'ar 11/13/1998 13:19'!isBalloonCanvas	^true! !!BalloonCanvas methodsFor: 'testing' stamp: 'ar 11/12/1998 01:07'!isVisible: aRectangle	^transform 		ifNil:[super isVisible: aRectangle]		ifNotNil:[super isVisible: (transform localBoundsToGlobal: aRectangle)]! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/11/1998 19:10'!copy	^super copy resetEngine! !!BalloonCanvas methodsFor: 'copying' stamp: 'ar 11/12/1998 00:31'!copyTransform: aTransform	^self copy transformBy: aTransform! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:20'!fillColor: c	"Note: This always fills, even if the color is transparent."	"Note2: To achieve the above we must make sure that c is NOT transparent"	self frameAndFillRectangle: form boundingBox 		fillColor: (c alpha: 1.0)		borderWidth: 0		borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:45'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	^self drawOval: (r insetBy: borderWidth // 2) color: c borderWidth: borderWidth borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:49'!fillRectangle: r color: c	^self frameAndFillRectangle: r			fillColor: c			borderWidth: 0			borderColor: nil! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:56'!frameAndFillRectangle: r fillColor: c borderWidth: borderWidth borderColor: borderColor	^self drawRectangle: (r insetBy: borderWidth // 2) color: c borderWidth: borderWidth borderColor: borderColor! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:40'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| bw |	"Fill rectangle and draw top and left border"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now draw bottom right border.	Note: Must inset this manually!!"	bw _ borderWidth // 2.	self drawPolygon: (Array with: r topRight + (bw negated@bw) 							with: r bottomRight - bw asPoint							with: r bottomLeft + (bw@bw negated))		color: nil		borderWidth: borderWidth		borderColor: bottomRightColor.! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:42'!frameRectangle: r width: w color: c	^self frameAndFillRectangle: r			fillColor: nil			borderWidth: w			borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 20:40'!line: pt1 to: pt2 width: w color: c	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:39'!point: pt color: c	"Is there any use for this?"	| myPt |	transform 		ifNil:[myPt _ pt]		ifNotNil:[myPt _ transform localPointToGlobal: pt].	^super point: myPt color: c! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:51'!drawBezierShape: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a boundary shape that is defined by a list of vertices.	Each three subsequent vertices define a quadratic bezier segment.	For lines, the control point should be set to either the start or the end	of the bezier curve."	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawBezierShape: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:54'!drawCompressedShape: compressedShape	"Draw a compressed shape"	self ensuredEngine		drawCompressedShape: compressedShape		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:51'!drawGeneralBezierShape: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general boundary shape (e.g., possibly containing holes)"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawGeneralBezierShape: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:49'!drawGeneralPolygon: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general polygon (e.g., a polygon that can contain holes)"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawGeneralPolygon: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:55'!drawOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw the oval defined by the given rectangle"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawOval: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:50'!drawPolygon: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a simple polygon defined by the list of vertices."	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawPolygon: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 11/14/1998 20:55'!drawRectangle: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw a rectangle"	| fillC borderC |	fillC _ self drawColor: c.	borderC _ self drawColor: borderColor.	self ensuredEngine		drawRectangle: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:36'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	^super image: aForm at: aPoint sourceRect: sourceRect rule: rule! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/12/1998 13:33'!line: point1 to: point2 brushForm: brush	| pt1 pt2 |	transform 		ifNil:[pt1 _ point1. pt2 _ point2]		ifNotNil:[pt1 _ transform localPointToGlobal: point1.				pt2 _ transform localPointToGlobal: point2].	^super line: pt1 to: pt2 brushForm: brush! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:38'!paragraph: para bounds: bounds color: c	^super paragraph: para bounds: bounds color: c! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 11/11/1998 19:39'!text: s bounds: boundsRect font: fontOrNil color: c	^super text: s bounds: boundsRect font: fontOrNil color: c! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/12/1998 00:32'!transformBy: aTransform	aTransform ifNil:[^self].	transform 		ifNil:[transform _ aTransform]		ifNotNil:[transform _ transform composedWithLocal: aTransform]! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/12/1998 00:32'!transformBy: aTransform while: aBlock	"Incorporate the local transformation in the receiver while evaluating aBlock"	| result |	aTransform ifNil:[^aBlock value: self].	transformStack addLast: transform.	self transformBy: aTransform.	result _ aBlock value: self.	transform _ transformStack removeLast.	^result! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 11/11/1998 20:12'!drawColor: c	(c isNil or:[c isTransparent]) ifTrue:[^nil].	^shadowDrawing		ifTrue:[Color gray]		ifFalse:[c]! !!BalloonCanvas methodsFor: 'converting' stamp: 'ar 11/11/1998 22:57'!asBalloonCanvas	^self! !BalloonBezierSimulation initialize!BalloonEngine initialize!BalloonEngineBase initialize!"Postscript:Initialize the Balloon engine pool constants"BalloonEngineBase initPool.!