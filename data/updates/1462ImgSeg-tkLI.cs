'From Squeak 2.5 of August 6, 1999 on 21 September 1999 at 2:09:17 pm'!!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/21/1999 14:00'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	"(self confirm: 'Installing segment.  Want a debugger?') ifTrue: [self halt]."	state _ #inactive.	PluckedSound pitch: 261.625*3 dur: 0.25 loudness: 0.1.	"interrupts previous sound"! !!Interpreter methodsFor: 'debug support' stamp: 'tk 9/21/1999 12:58'!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = (Metaclass instSize +1*4) ifTrue: [		self printNameOfClass: (self fetchPointer: 5 "thisClass" ofObject: classOop) 			count: cnt - 1.		self print: ' class'.	] ifFalse: [		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).	].! !!InterpreterSimulator methodsFor: 'testing' stamp: 'tk 9/21/1999 12:19'!validate: oop	| header type cc sz fmt nextChunk | 	header _ self longAt: oop.	type _ header bitAnd: 3.	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].	sz _ (header >> 2) bitAnd: 16r3F.	(self isFreeObject: oop)		ifTrue: [ nextChunk _ oop + (self sizeOfFree: oop) ]		ifFalse: [  nextChunk _ oop + (self sizeBitsOf: oop) ].	nextChunk > endOfMemory		ifTrue: [oop = endOfMemory ifFalse: [self halt]].	(self headerType: nextChunk) = 0 ifTrue: [		(self headerType: (nextChunk + 8)) = 0 ifFalse: [self halt]].	(self headerType: nextChunk) = 1 ifTrue: [		(self headerType: (nextChunk + 4)) = 1 ifFalse: [self halt]].	type = 2 ifTrue:		["free block" ^ self].	fmt _ (header >> 8) bitAnd: 16rF.	cc _ (header >> 12) bitAnd: 31.	cc > 16 ifTrue: [self halt].	"up to 32 are legal, but not used"	type = 0 ifTrue:		["three-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-8) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-4) = type) ifTrue: [self halt].	"Class word is 0"		sz = 0 ifFalse: [self halt]].	type = 1 ifTrue:		["two-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].		sz = 0 ifTrue: [self halt]].	type = 3 ifTrue:		["one-word header"		cc = 0 ifTrue: [self halt]].	fmt = 5 ifTrue: [self halt].	fmt = 7 ifTrue: [self halt].	fmt >= 12 ifTrue:		["CompiledMethod -- check for integer header"		(self isIntegerObject: (self longAt: oop + 4)) ifFalse: [self halt]].! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'tk 9/21/1999 12:52'!nameOfClass: classOop	(self sizeBitsOf: classOop) = (Metaclass instSize +1*4) ifTrue:		[^ (self nameOfClass:				(self fetchPointer: 5 "thisClass" ofObject: classOop)) , ' class'].	^ self stringOf: (self fetchPointer: 6 "name" ofObject: classOop)! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'tk 9/18/1999 16:33'!shortPrint: oop	| name classOop |	(self isIntegerObject: oop) ifTrue: [^ '=' , (self integerValueOf: oop) printString , 		' (' , (self integerValueOf: oop) hex , ')'].	classOop _ self fetchClassOf: oop.	(self sizeBitsOf: classOop) = (Metaclass instSize +1*4) ifTrue: [		^ 'class ' , (self nameOfClass: oop)].	name _ self nameOfClass: classOop.	name size = 0 ifTrue: [name _ '??'].	name = 'String' ifTrue: [^ (self stringOf: oop) printString].	name = 'Symbol' ifTrue: [^ '#' , (self stringOf: oop)].	name = 'Character' ifTrue: [^ '=' , (Character value: (self integerValueOf: 				(self fetchPointer: 0 ofObject: oop))) printString].	name = 'UndefinedObject' ifTrue: [^ 'nil'].	name = 'False' ifTrue: [^ 'false'].	name = 'True' ifTrue: [^ 'true'].	name = 'Float' ifTrue: [^ '=' , (self floatValueOf: oop) printString].	name = 'Association' ifTrue: [^ '(' ,				(self shortPrint: (self longAt: oop + BaseHeaderSize)) ,				' -> ' ,				(self longAt: oop + BaseHeaderSize + 4) hex8 , ')'].	('AEIOU' includes: name first)		ifTrue: [^ 'an ' , name]		ifFalse: [^ 'a ' , name]! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'tk 9/17/1999 21:24'!primitiveBeep	self beep.! !!MethodDictionary commentStamp: 'tk 9/21/1999 13:49' prior: 0!I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instances of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.!!Project methodsFor: 'menu messages' stamp: 'tk 9/21/1999 14:02'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case."	| showZoom recorderOrNil same old |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	CurrentProject makeThumbnail.	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue:[displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	showZoom _ Preferences showProjectZoom		and: ["Only show zoom if there is room for the both displays plus a megabyte"			Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+1000000)].	showZoom ifTrue:[self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	(same _ CurrentProject topIsolated == self topIsolated) ifFalse: [		CurrentProject revoke].	old _ CurrentProject.	CurrentProject _ self.	same ifFalse: [CurrentProject invoke].	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [				(PluckedSound pitch: 261.625*2 dur: 0.25 loudness: 0.1) play.				old storeSegment.	"Send its morphs to disk"				(PluckedSound pitch: 261.625*4 dur: 1 loudness: 0.1) play].			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts.			self spawnNewProcessAndTerminateOld: true]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world.			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project class methodsFor: 'utilities' stamp: 'tk 9/21/1999 14:03'!storeAllInSegments	"Write out all Projects in this Image.	Project storeAllInSegments.		"	| all |all _ Project allInstances.Transcript show: 'Initial Space Left: ', Smalltalk garbageCollect printString; cr.all do: [:proj |	Transcript show: proj name; cr.	proj storeSegment  "storeSegmentNoFile"].Transcript show: 'After writing all: ', Smalltalk garbageCollect printString; cr."some will come back in"! !