'From Squeak3.1alpha of 28 February 2001 [latest update: #4207] on 25 July 2001 at 6:32:19 pm'!"Change Set:		UniTile2-tkDate:			25 July 2001Author:			Ted KaehlerFurther adjustments to highlighting and dropzones for UniTiles.  A user can now tell when he is about to replace a line of tiles.Made the world safe for (aMorph layoutInset) to be a Point instead of a number.Fixed bug on BookPageThumbnailMorph."!!MethodInterface commentStamp: 'tk 7/24/2001 08:49' prior: 0!A MethodInterface describes the interface for a single method.  The most generic form is not bound to any particular class or object but rather describes an idealized interface.	selector					A symbol - the selector being described	argumentSpecifications	A list of specifications for the formal arguments of the method	resultSpecification 		A characterization of the return value of the method	userLevel					attributeKeywords		A list of symbols, comprising keywords that the user wishes to								see on the screen for this method	defaultStatus			The status to apply to new instances of the class by default							(#ticking, #paused, #normal, etc.)!!SyntaxMorph commentStamp: 'tk 7/24/2001 10:39' prior: 0!A single class of morph that holds any piece of Smalltalk, and allows it to be a tile.  Tiles can be dragged in or out of a method. In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.  Clicking multiple times selects enclosing phrases of code.  Dragging lets you take away a copy.  Any tile may be replaced by dropping on it.  Shift-click to edit the text of any tile.  Change variable and message names, but do not change the part-of-speech (objects to selector).Each SyntaxMorph holds a ParseNode.  After editing, the parseNode is only good as a part-of-speech indicator.  Only the Class of a parseNode is important.  It's state is not kept up to date with the tile edits (but maybe it should be).  (For MessageNodes, whether the receiver slot is nil is significant.)The correspondence between SyntaxMorphs and parseNodes in the real parse tree is not one-to-one.  Several extra levels of SyntaxMorph were added as aligners to make the horizontal and vertical layout right.  These sometimes have nil for the parseNode.When accept the method, we pass over the tree of SyntaxMorphs, gathering their printStrings and inserting punctuation.  See (SyntaxMorph>>printOn:indent:).  We send the result to the compiler.  (We do not use the parse tree we already have.)To turn on type checking: Preferences enable: #eToyFriendlyor for testing:     World project projectParameters at: #fullCheck put: true.Colors of tiles:  Each tile has a current color (inst car color) and a deselectedColor (a property).  The deselectedColor may be governed by the part of speech, or not.  (translateColor: is only used when a tile is created, to set deselectedColor.)  From deselectedColor (set by #setDeselectedColor), the color changes to:	lightBrown when selected (not the submorphs) in #select	translucent when held in the hand (allMorphs) in #lookTranslucent	green when a drop target (allMorphs) (change the owners back) #dropColor, 		#trackDropZones deselectedColor is moderated by the darkness setting, #scaleColorByUserPref:.  (as it is put into color in #color:)!!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/25/2001 18:09'!mouseDown: event	"turn the book to that page"	"May need to lie to it so mouseUp won't go to menu that may come up during fetch of a page in doPageFlip.  (Is this really true? --tk)"	self doPageFlip.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/25/2001 17:40'!rebuild	| row filler fudge people maxPerRow insetY |	updateCounter _ self class updateCounter.	self removeAllMorphs.	(self addARow: {		filler _ Morph new color: Color transparent; extent: 4@4.	}) vResizing: #shrinkWrap.	self addARow: {		(StringMorph contents: 'the Fridge') lock.		self groupToggleButton.	}.	row _ self addARow: {}.	people _ self class fridgeRecipients.	maxPerRow _ people size < 7 ifTrue: [2] ifFalse: [3].			"how big can this get before we need a different approach?"	people do: [ :each |		row submorphCount >= maxPerRow ifTrue: [row _ self addARow: {}].		row addMorphBack: (			groupMode ifTrue: [				(each userPicture scaledToSize: 35@35) asMorph lock			] ifFalse: [				each veryDeepCopy killExistingChat			]		)	].	fullBounds _ nil.	self fullBounds.	"htsBefore _ submorphs collect: [ :each | each height]."	fudge _ 20.	insetY _ self layoutInset.	insetY isPoint ifTrue: [insetY _ insetY y].	filler extent: 		4 @ (self height - filler height * 0.37 - insetY - borderWidth - fudge) truncated.	"self fixLayout.	htsAfter _ submorphs collect: [ :each | each height].	{htsBefore. htsAfter} explore."! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 7/23/2001 18:04'!receiverNode	"If I am (have) a MessageNode, return the node of the receiver.  Watch out for foolish noise words."	parseNode class == MessageNode ifFalse: [^ nil].	parseNode receiver ifNil: [^ nil].	submorphs do: [:ss | 		ss isSyntaxMorph ifTrue: [			ss parseNode ifNotNil: ["not noise word"				ss isNoun ifTrue: [^ ss] 					ifFalse: [^ nil "found selector"]]]].	^ nil! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 7/25/2001 10:09'!mouseEnterDragging: evt	"Highlight this level as a potential drop target""self isBlockNode ifTrue: [Transcript cr; print: self; show: ' enterDragging']."	self rootTile isMethodNode ifFalse: [^ self]. 	"not in a script"	evt hand hasSubmorphs ifFalse: [^ self].  "Don't react to empty hand"	self unhighlightOwnerBorder.	self isBlockNode ifFalse: [self highlightForDrop: evt.		(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m color = self dropColor]])			ifNotNilDo: [:m | m unhighlight]].	self isBlockNode ifTrue:		[(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])			ifNotNilDo: [:m | "Suspend outer block."						m stopStepping; removeDropZones].		self startStepping]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 7/25/2001 10:21'!mouseMove: evt	| dup selection |	owner isSyntaxMorph ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		mouseDownLoc ifNotNil: [			(evt cursorPoint dist: mouseDownLoc) > 4 ifTrue:				["If drag 5 pixels, then tear off a copy of outer selection."				selection _ outerMorph ifNil: [self].				selection deletePopup.				evt hand attachMorph: (dup _ selection duplicate).				Preferences tileTranslucentDrag					ifTrue: [dup lookTranslucent]					ifFalse: [dup align: dup topLeft								with: evt hand position + self cursorBaseOffset].				self setSelection: nil.	"Why doesn't this deselect?"				(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])					ifNotNilDo: [:m | "Activate enclosing block."								m startStepping]]]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 7/25/2001 11:26'!step	super step.	self isBlockNode ifTrue: [self trackDropZones].! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'tk 7/23/2001 18:28'!grabColor	"Not the select color, but the mouseOver border color.  Means it could be grabbed"	^ Color paleOrange mixed: 0.5 with: Color brown! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 7/23/2001 18:31'!select	self deselect.	"Outer block is not colored and has no popup"	(owner isSyntaxMorph and: [owner nodeClassIs: MethodNode]) 		ifTrue: [self setDeselectedColor "normal"]		ifFalse: [self color: Color lightBrown].	self borderColor: #raised.	self offerPopUp.! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'tk 7/25/2001 17:42'!trackDropZones	| hand i localPt insertion insHt ii prevBot nxtHt d c1 c2 ht2 spacer1 spacer2 wid ht1 dc each |	hand _ self primaryHand.	(hand lastEvent redButtonPressed & hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifFalse: [^ self].	insertion _ hand firstSubmorph renderedMorph.	insertion isSyntaxMorph ifFalse: [^ self].	insertion isNoun ifFalse: [^ self].	localPt _ self globalPointToLocal: hand position.	insHt _ insertion height.  "**just use standard line height here"	self removeDropZones.  "Maybe first check if in right place, then just tweak heights."	i _ (ii _ self indexOfMorphAbove: localPt) min: submorphs size-1.	prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].	nxtHt _ (submorphs isEmpty		ifTrue: [insertion]		ifFalse: [self submorphs at: i+1]) height.	d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]			ifFalse: [0 max: (localPt y - prevBot min: nxtHt)].	"Top and bottom spacer heights cause continuous motion..."	c1 _ Color transparent.  c2 _ Color transparent.	ht2 _ d*insHt//nxtHt.  ht1 _ insHt - ht2.	wid _ self width - (2*borderWidth) - (2*self layoutInset).	wid isPoint ifTrue: [wid _ wid x].	(spacer1 _ BorderedMorph newBounds: (0@0 extent: wid@ht1)				color: (ht1 > (insHt//2) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer1 color.	self privateAddMorph: spacer1 atIndex: (i+1 max: 1).	(spacer2 _ BorderedMorph newBounds: (0@0 extent: wid@ht2)				color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer2 color.	spacer1 setProperty: #dropZone toValue: true.	spacer2 setProperty: #dropZone toValue: true.	self privateAddMorph: spacer2 atIndex: (i+3 min: submorphs size+1).	self fullBounds.  "Force layout prior to testing for cursor containment"	"Maintain the drop target highlight -- highlight spacer if hand is in it."	{spacer1. spacer2} do:		[:spacer | (spacer containsPoint: localPt) ifTrue:			[spacer color: self dropColor.			"Ignore border color.  Maybe do it later.			self borderColor = self dropColor				ifTrue: [self borderColor: self stdBorderColor]"]].	"If no submorph (incl spacers) highlighted, then re-highlight the block."	"Ignore border color.  Maybe do it later.	((self wantsDroppedMorph: insertion event: hand lastEvent) and:		[(self submorphs anySatisfy: [:m | m containsPoint: localPt]) not])			ifTrue: [self borderColor: self dropColor].	"	"Dragging a tile within a Block, if beside a tile, color it a dropzone"	"Transcript show: localPt y printString; space; show: submorphs first top 		printString; space; show: submorphs last top printString; cr."	dc _ self dropColor.	1 to: ((ii+4 min: submorphs size) max: 1) do: [:ind | 		each _ submorphs at: ind.		each isSyntaxMorph ifTrue: [			localPt y >= each top 				ifTrue: ["in this one or beyond"					(localPt y < each bottom) 						ifTrue: [(each submorphs anySatisfy: [:m | 								m containsPoint: localPt])							ifTrue: [each setDeselectedColor]							ifFalse: [each color: dc]]						ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]				ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 7/25/2001 10:01'!addToBlock: aMorph event: evt	"Insert a new line of code.  Figure out who it goes before.  If evt Y is within an existing line (to the right of a tile), then replace that tile."	| whereDropped dropBefore replace |	whereDropped _ "self pointFromWorld:" evt cursorPoint.	dropBefore _ self submorphs 		detect: [:each | each isSyntaxMorph ifTrue: [			whereDropped y < each top ifTrue: [true]	"before this one"				ifFalse: [whereDropped y < each bottom 							ifTrue: [replace _ true]	"replace this one"							ifFalse: [false]]]] "try next line"		ifNone: [nil].	(aMorph nodeClassIs: ReturnNode) ifTrue: [dropBefore _ nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [			replace ifNotNil: [aMorph deselect.				self replaceSubmorph: dropBefore by: aMorph.	"replace it!!"				^ dropBefore cleanupAfterItDroppedOnMe].	"now owned by no one"			self addMorph: aMorph inFrontOf: dropBefore].	self cleanupAfterItDroppedOnMe.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/23/2001 18:16'!extend	| messageNodeMorph first |	"replace this noun with a new message like (arg + 1).  If type is not known, ask the user to type in a selector.  Use nil as arg.  Let user drag something to it afterwards."	"Later do evaluation of self to see what type and offer right selector"	self deselect.	messageNodeMorph _ (MessageSend receiver: 1 selector: #+ arguments: #(1))								asTilesIn: Player.	owner replaceSubmorph: self by: messageNodeMorph.	first _ messageNodeMorph submorphs detect: [:mm | mm isSyntaxMorph].	messageNodeMorph replaceSubmorph: first by: self.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/23/2001 18:09'!extendArrow	"Return the extend arrow button.  It replaces the argument with a new message.	I am a number or getter messageNode."	| patch |		self isNoun ifFalse: [^ nil].	patch _ (ImageMorph new image: (TileMorph classPool at: #SuffixPicture)).	patch on: #mouseDown send: #extend to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 22:30'!setSelector: stringLike in: stringMorph	| aSymbol myType str |	"store the new selector and accept method"	aSymbol _ stringLike asSymbol.	self setBalloonText: (ScriptingSystem helpStringForOperator: aSymbol).	myType _ stringMorph valueOfProperty: #syntacticReformatting ifAbsent: [#none].	str _ (self shouldBeBrokenIntoWords: myType) 		ifTrue: [self substituteKeywordFor: aSymbol]		ifFalse: [aSymbol].	stringMorph contents: str.	"parseNode key: aSymbol code: nil."	stringMorph setProperty: #syntacticallyCorrectContents toValue: aSymbol.	self acceptSilently.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 18:00'!upDown: delta event: evt arrow: arrowMorph	| st |	st _ submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: LiteralNode) ifTrue:		[ "+/- 1"		st contents: (self decompile asNumber + delta) printString.		^ self acceptUnlogged].	(self nodeClassIs: VariableNode) ifTrue:		[ "true/false"		st contents: (self decompile asString = 'true') not printString.		^ self acceptSilently.	"maybe set parseNode's key"].	(self upDownArithOp: delta) ifTrue: [^ self].	"+ - // *   < > <= =   beep:"	(self upDownAssignment: delta) ifTrue: [^ self].		"Handle assignment --  increaseBy:  <-   multiplyBy:"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 17:54'!upDownArithOp: delta	"Change a + into a -.  Also do sounds (change the arg to the beep:)."	| aList index st |	st _ submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: SelectorNode) ifTrue:		[aList _ #(+ - * / // \\ min: max:).		(index _ aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		aList _ #(= ~= > >= isDivisibleBy: < <=).		(index _ aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		aList _ #(== ~~).		(index _ aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		'beep:' = self decompile asString ifTrue:			["replace sound arg"			self changeSound: delta.			self acceptSilently.  ^ true].		].	^ false! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 11:14'!upDownArrows	"Return an array of two up/down arrow buttons.	It replaces the selector or arg with a new one.	I am a number or boolean or a selector (beep:, +,-,*,//,\\, or setX: incX: decX: for any X."	| patch sel any ok |	any _ (self nodeClassIs: LiteralNode) and: [parseNode key isNumber].	any _ any or: [(self nodeClassIs: VariableNode) and:						[(#('true' 'false') includes: self decompile asString)]].	any _ any or: [self nodeClassIs: SelectorNode].	"code below is redundant"	any _ any or: [(self nodeClassIs: SelectorNode) and:				[ok _ #(beep: + - * // \\) includes: (sel _ parseNode key).				ok _ ok or: [(sel beginsWith: 'set') and: [(sel atWrap: 4) isUppercase]].				ok _ ok or: [sel size > 11 and:						[#('IncreaseBy:' 'DecreaseBy:' 'MultiplyBy:') includes: (sel last: 11)]].				ok]].	any _ any or: [(self nodeClassIs: SelectorNode) and:				[ok _ #(= ~= == ~~) includes: (sel _ parseNode key).				ok]].	any ifFalse: [^ nil].	patch _ {(ImageMorph new image: TileMorph upPicture)				on: #mouseDown send: #upDown:event:arrow: to: self withValue: 1;				on: #mouseStillDown send: #upDownMore:event:arrow: to: self withValue: 1;				on: #mouseUp send: #upDownDone to: self.			(ImageMorph new image: TileMorph downPicture)				on: #mouseDown send: #upDown:event:arrow: to: self withValue: -1;				on: #mouseStillDown send: #upDownMore:event:arrow: to: self withValue: -1;				on: #mouseUp send: #upDownDone to: self}.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 17:59'!upDownAssignment: delta	"Handle increaseBy:  <-   multiplyBy:"	| st now want instVar |	st _ submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: SelectorNode) ifTrue:		["kinds of assignment"		((now _ self decompile asString) beginsWith: 'set') ifTrue:			["a setX: 3"			want _ 1+delta.  instVar _ (now allButFirst: 3) allButLast].		(now endsWith: 'IncreaseBy:') ifTrue:			["a xIncreaseBy: 3 a setX: (a getX +3)."			want _ 2+delta.  instVar _ now allButLast: 11].		(now endsWith: 'DecreaseBy:') ifTrue:			["a xDecreaseBy: 3 a setX: (a getX -3)."			want _ 3+delta.  instVar _ now allButLast: 11].		(now endsWith: 'MultiplyBy:') ifTrue:			["a xMultiplyBy: 3 a setX: (a getX *3)."			want _ 4+delta.  instVar _ now allButLast: 11].		want ifNil: [^ false].		instVar _ instVar asLowercase.		want _ #(1 2 3 4) atWrap: want.		want = 1 ifTrue:			["setter method is present"			self setSelector: ('set', instVar capitalized, ':') in: st.  ^ true].		want = 2 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'IncreaseBy:' in: st.  ^ true].		want = 3 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'DecreaseBy:' in: st.  ^ true].		want = 4 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'MultiplyBy:' in: st.  ^ true].		].	^ false! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 7/25/2001 17:58'!finalAppearanceTweaks	| deletes lw |	SizeScaleFactor ifNil: [SizeScaleFactor _ 0.15]. 	SizeScaleFactor _ 0.0.	"disable this feature.  Default was for giant tiles"	self usingClassicTiles ifTrue: [		self allMorphsDo: [:each | 			(each isKindOf: SyntaxMorph) ifTrue: [each lookClassic]		].		^self	].	deletes _ OrderedCollection new.	self allMorphsDo: [ :each |		(each respondsTo: #setDeselectedColor) ifTrue: [each setDeselectedColor].		"(each hasProperty: #variableInsetSize) ifTrue: [			each layoutInset: 				((each valueOfProperty: #variableInsetSize) * SizeScaleFactor) rounded]."		(each isKindOf: SyntaxMorph) ifTrue: [			lw _ each layoutInset.			lw isPoint ifTrue: [lw _ lw x].			each layoutInset: lw@0 "(6 * SizeScaleFactor) rounded"].	].	deletes do: [ :each | each delete].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/24/2001 22:13'!alanKwdSetter2: aNode isAConditional: template key: key args: args	"translates		foo setHeading: 0	to		foo's heading _ 0	"	| kwdHolder |	kwdHolder _ self		addToken: key		type: #keywordSetter		on: (SelectorNode new key: key code: nil "fill this in?").	kwdHolder firstSubmorph 		setProperty: #syntacticReformatting toValue: #keywordSetter;		setProperty: #syntacticallyCorrectContents toValue: key asString;		contents: ('''s ', (self splitAtCapsAndDownshifted: 			(key asString allButFirst: 3) allButLast withFirstCharacterDownshifted), ' _');		emphasis: 1.	(args first asMorphicSyntaxIn: self) setConditionalPartStyle			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/24/2001 21:59'!alanUnaryGetter: aNode key: key	"I am a MessageNode.  Fill me with a SelectorNode {getX} whose string is {'s x}.  All on one level."	| selSyn usm say |	selSyn _ self		addToken: key		type: #unaryGetter		on: (SelectorNode new key: key code: nil "fill this in?").	usm _ selSyn firstSubmorph.	usm setProperty: #syntacticReformatting toValue: #unaryGetter;		setProperty: #syntacticallyCorrectContents toValue: key asString.	say _ '''s ', (self splitAtCapsAndDownshifted:			(key asString allButFirst: 3) withFirstCharacterDownshifted).	usm contents: say; emphasis: 1.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/25/2001 17:53'!blockNode: aNode arguments: arguments statements: statements	| row column |	column _ self addColumn: #block on: aNode.	self alansTest1 ifFalse: [column layoutInset: 5@-1].	self alansTest1 ifTrue: [column setProperty: #deselectedBorderColor toValue: self lighterColor].	aNode addCommentToMorph: column.	arguments size > 0 ifTrue: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		row addNoiseString: self noiseBeforeBlockArg.		arguments do: [:arg | 			row addToken: arg name type: #blockarg2 on: arg		]	].	statements do: [ :each | 		(row _ each asMorphicSyntaxIn: column) borderWidth: 1.		self alansTest1 ifTrue: [			row setSpecialOuterTestFormat.		].		each addCommentToMorph: column	].	^ column! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/25/2001 17:34'!blockNodeCollect: aNode arguments: arguments statements: statements	| row column c2 r2 r3 |	column _ self addColumn: #blockCollectOnly on: aNode.	self alansTest1 ifFalse: [column layoutInset: 5@-1].	aNode addCommentToMorph: column.	arguments size > 0 ifTrue: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		row addNoiseString: 'collect using' emphasis: 1.		r3 _ row addRow: #blockarg1b on: nil "aNode".		r3 setConditionalPartStyle.		arguments do: [:arg | 			r3 addToken: arg name type: #blockarg2 on: arg		]	].	r2 _ column addRow: #block on: aNode.	r2 setProperty: #ignoreNodeWhenPrinting toValue: true.	r2 addNoiseString: 'from' emphasis: 1.	c2 _ r2 addColumn: #block on: aNode.	c2 setProperty: #ignoreNodeWhenPrinting toValue: true.	statements do: [ :each | 		(each asMorphicSyntaxIn: c2) borderWidth: 1.		each addCommentToMorph: c2	].	^ column! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'tk 7/25/2001 17:33'!standardInset	parseNode class == BlockNode ifTrue: [^ 5@1].		"allow pointing beside a line so can replace it"	^ self alansTest1 ifTrue: [1] ifFalse: [-1]! !ScriptEditorMorph removeSelector: #xxxminHeight!