'From Squeak3.1alpha of 28 February 2001 [latest update: #4250] on 16 August 2001 at 1:35 pm'!"Change Set:		ReadOnlyGlobalsDate:			16 August 2001Author:			Andreas Raab[NOTE: The CS is carefully re-arranged; do not file out again].Enable read-only global bindings to prevent my favourite newbie mistakes of	Object _ new.(try that in a workspace). Global bindings can be made read-write and read-only by executing:	(Smalltalk associationAt: #Object) 		beReadOnlyBinding.	(Smalltalk associationAt: #Object) 		beReadWriteBinding.WARNING: The post script of this change set makes all existing behaviors read-only."!LookupKey subclass: #ReadOnlyVariableBinding	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!VariableNode subclass: #LiteralVariableNode	instanceVariableNames: 'splNode '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!Object methodsFor: 'testing' stamp: 'ar 8/14/2001 23:19'!isVariableBinding	"Return true if I represent a literal variable binding"	^false	! !!Behavior methodsFor: 'printing' stamp: 'ar 8/16/2001 13:31'!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key _ scannedLiteral key.	value _ scannedLiteral value.	key isNil 		ifTrue: "###<metaclass soleInstance name>"			[self scopeHas: value ifTrue:				[:assoc |				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isMemberOf: Symbol)		ifTrue: "##<global var name>"			[(self scopeHas: key ifTrue: [:assoc | ^assoc])				ifFalse:					[Undeclared at: key put: nil.					 ^ Undeclared associationAt: key]].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!Behavior methodsFor: 'printing' stamp: 'ar 8/16/2001 13:31'!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key _ aCodeLiteral key.	(key isNil and: [(value _ aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	((key isMemberOf: Symbol) and: [self scopeHas: key ifTrue: [:ignore]])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 8/16/2001 11:44'!recompile: selector	"Compile the method associated with selector in the receiver's method dictionary."	^self recompile: selector from: self! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 8/16/2001 13:31'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "	| who |	who _ Set new.	self selectorsAndMethodsDo:		[:sel :method |		((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])						ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ar 8/16/2001 13:31'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ Set new.	self selectorsAndMethodsDo: 		[:sel :method |		((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])						ifTrue: [who add: sel]]].	^ who! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/16/2001 13:23'!fixSuperSendsFrom: oldClass	"The oldClass is about to be removed from the environment.	Fix all references to super so that the association is different from	the original ST association."	| newSuper nLits lastLiteral |	newSuper _ Association key: nil value: oldClass.	oldClass methodsDo:[:meth|		nLits _ meth numLiterals.		nLits > 0 			ifTrue:[lastLiteral _ meth literalAt: nLits]			ifFalse:[lastLiteral _ nil].		(lastLiteral isVariableBinding and:[meth sendsToSuper]) ifTrue:[			meth literalAt: nLits put: newSuper.		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/16/2001 13:24'!fixSuperSendsTo: newClass	"The newClass has been exported into the environment.	Fix all references to super so that the association is	the original ST association."	| newSuper nLits lastLiteral |	newSuper _ Smalltalk associationAt: newClass name ifAbsent:[nil].	newSuper == nil ifTrue:[^self].	newSuper value == newClass ifTrue:[^self].	newClass methodsDo:[:meth|		nLits _ meth numLiterals.		nLits > 0 			ifTrue:[lastLiteral _ meth literalAt: nLits]			ifFalse:[lastLiteral _ nil].		(lastLiteral isVariableBinding and:[meth sendsToSuper]) ifTrue:[			meth literalAt: nLits put: newSuper.		].	].! !!CompiledMethod methodsFor: 'comparing' stamp: 'ar 8/16/2001 13:24'!= method	| myLits otherLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(myLits _ self literals) = (otherLits _ method literals) ifFalse:		[myLits size = otherLits size ifFalse: [^ false].		"Dont bother checking FFI and named primitives"		(#(117 120) includes: self primitive) ifTrue: [^ true].		myLits with: otherLits do:			[:lit1 :lit2 | lit1 = lit2 ifFalse:			[(lit1 isVariableBinding)			ifTrue:				["Associations match if value is equal, since associations				used for super may have key = nil or name of class."				lit1 value == lit2 value ifFalse: [^ false]]			ifFalse:				[(lit1 isMemberOf: Float)				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^ false]]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]].	^ true! !!CompiledMethod methodsFor: 'literals' stamp: 'ar 8/16/2001 13:24'!literalStrings	| lits litStrs |	lits _ self literals.	litStrs _ OrderedCollection new: lits size * 3.	self literals do:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit key]			ifFalse: [(lit isMemberOf: Symbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'ar 8/16/2001 13:25'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."| pp oldPlayer newKey newAssoc oldSelList newSelList |"Uniclasses use class vars to hold onto siblings who are referred to in code"pp _ Object class instSize + 1.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+0"	"(pp+1) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+2 to: playersClass class instSize do: [:i | 		playersClass instVarAt: i put: 			((playersClass instVarAt: i) veryDeepCopyWith: self)].	]."Make new entries in References and point to them."References keys "copy" do: [:playerName |	oldPlayer _ References at: playerName.	(references includesKey: oldPlayer) ifTrue: [		newKey _ (references at: oldPlayer) "new player" uniqueNameForReference.		"now installed in References"		(references at: oldPlayer) renameTo: newKey]].uniClasses "values" do: [:newClass |	oldSelList _ OrderedCollection new.   newSelList _ OrderedCollection new.	newClass selectorsDo: [:sel | 		(newClass compiledMethodAt: sel)	 literals do: [:assoc |			assoc isVariableBinding ifTrue: [				(References associationAt: assoc key ifAbsent: [nil]) == assoc ifTrue: [					newKey _ (references at: assoc value ifAbsent: [assoc value]) 									externalName asSymbol.					(assoc key ~= newKey) & (References includesKey: newKey) ifTrue: [						newAssoc _ References associationAt: newKey.						newClass methodDictionary at: sel put: 							(newClass compiledMethodAt: sel) clone.	"were sharing it"						(newClass compiledMethodAt: sel)							literalAt: ((newClass compiledMethodAt: sel) literals indexOf: assoc)							put: newAssoc.						(oldSelList includes: assoc key) ifFalse: [							oldSelList add: assoc key.  newSelList add: newKey]]]]]].	oldSelList with: newSelList do: [:old :new |			newClass replaceSilently: old to: new]].	"This is text replacement and can be wrong"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ar 8/16/2001 13:26'!prepareToBeSaved	"Prepare objects in outPointers to be written on the disk.  They must be able to match up with existing objects in their new system.  outPointers is already a copy.	Classes are already converted to a DiskProxy.  	Associations in outPointers:1) in Smalltalk.2) in a classPool.3) in a shared pool.4) A pool dict pointed at directly"| left pool myClasses outIndexes key |myClasses _ Set new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [myClasses add: aRoot]].outIndexes _ IdentityDictionary new.outPointers withIndexDo: [:anOut :ind | 	anOut isVariableBinding ifTrue: [		(myClasses includes: anOut value)			ifFalse: [outIndexes at: anOut put: ind]			ifTrue: [(Smalltalk associationAt: anOut key ifAbsent: [3]) == anOut 				ifTrue: [outPointers at: ind put: 					(DiskProxy global: #Smalltalk selector: #associationDeclareAt: 						args: (Array with: anOut key))]				ifFalse: [outIndexes at: anOut put: ind]				]].	(anOut isKindOf: Dictionary) ifTrue: ["Pools pointed at directly"		(key _ Smalltalk keyAtIdentityValue: anOut ifAbsent: [nil]) ifNotNil: [			outPointers at: ind put: 				(DiskProxy global: key selector: #yourself args: #())]].	anOut isMorph ifTrue: [outPointers at: ind put: 		(StringMorph contents: anOut printString, ' that was not counted')]	].left _ outIndexes keys asSet.left size > 0 ifTrue: ["Globals"	(left copy) do: [:assoc |	"stay stable while delete items"		(Smalltalk associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [			outPointers at: (outIndexes at: assoc) put: 				(DiskProxy global: #Smalltalk selector: #associationAt: 					args: (Array with: assoc key)).			left remove: assoc]]].left size > 0 ifTrue: ["Class variables"	Smalltalk allClassesDo: [:cls | cls classPool size > 0 ifTrue: [		(left copy) do: [:assoc |	"stay stable while delete items"			(cls classPool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [				outPointers at: (outIndexes at: assoc) put: 					(DiskProxy new global: cls name						preSelector: #classPool						selector: #associationAt: 						args: (Array with: assoc key)).				left remove: assoc]]]]].left size > 0 ifTrue: ["Pool variables"	Smalltalk associationsDo: [:poolAssoc |		poolAssoc value class == Dictionary ifTrue: ["a pool"			pool _ poolAssoc value.			(left copy) do: [:assoc |	"stay stable while delete items"				(pool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [					outPointers at: (outIndexes at: assoc) put: 						(DiskProxy global: poolAssoc key selector: #associationAt: 							args: (Array with: assoc key)).					left remove: assoc]]]]].left size > 0 ifTrue: [	"If points to class in arrayOfRoots, must deal with it separately"	"OK to have obsolete associations that just get moved to the new system"	self inform: 'extra associations'.	left inspect].! !!LiteralNode methodsFor: 'printing' stamp: 'ar 8/16/2001 13:27'!printOn: aStream indent: level	(key isVariableBinding)		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###';					 	nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##';						nextPutAll: key key]]		ifFalse:			[aStream withStyleFor: #literal					do: [key storeOn: aStream]]! !!LiteralNode methodsFor: 'tiles' stamp: 'ar 8/16/2001 13:26'!asMorphicSyntaxIn: parent	| row |	row _ parent addColumn: #literal on: self.	(key isVariableBinding) ifFalse: [		row layoutInset: 1.		^ row addMorphBack: (row addString: key storeString special: false)].	key key isNil ifTrue: [		^ row addTextRow: ('###',key value soleInstance name)	] ifFalse: [		^ row addTextRow: ('##', key key)	].	! !!LiteralNode methodsFor: 'tiles' stamp: 'ar 8/16/2001 13:27'!explanation	(key isVariableBinding) ifFalse: [		^'Literal ', key storeString	].	key key isNil ifTrue: [		^'Literal ', ('###',key value soleInstance name) 	] ifFalse: [		^'Literal ', ('##', key key) 	].	! !!LookupKey methodsFor: 'testing' stamp: 'ar 8/14/2001 22:39'!isVariableBinding	"Return true if I represent a literal variable binding"	^true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:59'!beBindingOfType: aClass announcing: aBool	"Make the receiver a global binding of the given type"	| old new |	(Smalltalk associationAt: self key) == self		ifFalse:[^self error:'Not a global variable binding'].	self class == aClass ifTrue:[^self].	old _ self.	new _ aClass key: self key value: self value.	old become: new.	"NOTE: Now self == read-only (e.g., the new binding)"	^self recompileBindingsAnnouncing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadOnlyBinding	"Make the receiver (a global read-write binding) be a read-only binding"	^self beReadOnlyBindingAnnouncing: true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadOnlyBindingAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-only binding"	^self beBindingOfType: ReadOnlyVariableBinding announcing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadWriteBinding	"Make the receiver (a global read-only binding) be a read-write binding"	^self beReadWriteBindingAnnouncing: true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:51'!beReadWriteBindingAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-write binding"	^self beBindingOfType: Association announcing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:54'!recompileBindingsAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-only binding"	aBool ifTrue:[		Utilities informUserDuring:[:bar|			(Smalltalk allCallsOn: self) do:[:mref| 				bar value: 'Recompiling ', mref asStringOrText.				mref actualClass recompile: mref methodSymbol].		].	] ifFalse:[		(Smalltalk allCallsOn: self) do:[:mref| 			mref actualClass recompile: mref methodSymbol].	].! !!Association methodsFor: 'testing' stamp: 'ar 8/14/2001 23:06'!isSpecialWriteBinding	"Return true if this variable binding is write protected, e.g., should not be accessed primitively but rather by sending #value: messages"	^false! !!Association methodsFor: 'testing' stamp: 'ar 8/14/2001 22:39'!isVariableBinding	"Return true if I represent a literal variable binding"	^true! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/14/2001 23:09'!value	^value! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/16/2001 11:57'!value: aValue	self error:'Cannot store into read-only bindings'.! !!ReadOnlyVariableBinding methodsFor: 'testing' stamp: 'ar 8/14/2001 23:08'!isSpecialWriteBinding	"Return true if this variable binding is write protected, e.g., should not be accessed primitively but rather by sending #value: messages"	^true! !!ReadOnlyVariableBinding methodsFor: 'private' stamp: 'ar 8/14/2001 23:11'!privateSetKey: aKey value: aValue	key _ aKey.	value _ aValue! !!ReadOnlyVariableBinding class methodsFor: 'instance creation' stamp: 'ar 8/14/2001 23:11'!key: key value: aValue	^self new privateSetKey: key value: aValue! !!SyntaxMorph methodsFor: 'printing' stamp: 'ar 8/16/2001 13:29'!printVariableNodeOn: strm indent: level	"nil out any old association"	parseNode key isVariableBinding ifTrue: [		parseNode 			name: parseNode name 			key: nil 			code: parseNode code	].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].! !!SystemDictionary methodsFor: 'browsing' stamp: 'ar 8/16/2001 13:29'!browseObsoleteReferences   "Smalltalk browseObsoleteReferences"	| references |	references _ OrderedCollection new.	(LookupKey allSubInstances select:		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:		['AnOb*' match: x value class name]]) 		do: [:x | references addAll: (Smalltalk allCallsOn: x)].	Smalltalk 		browseMessageList: references 		name: 'References to Obsolete Classes'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'ar 8/16/2001 13:30'!obsoleteMethodReferences	"Smalltalk obsoleteMethodReferences"	"Smalltalk browseObsoleteMethodReferences"	"Open a browser on all referenced behaviors that are obsolete"	| obsClasses obsRefs references |	references _ WriteStream on: Array new.	obsClasses _ self obsoleteBehaviors.	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor cursorPoint		from: 1 to: obsClasses size during:[:bar|	obsClasses keysAndValuesDo:[:index :each|		bar value: index.		obsRefs _ self pointersTo: each except: obsClasses.		obsRefs do:[:ref|			"Figure out if it may be a global"			((ref isVariableBinding) and:[ref key isKindOf: String "or Symbol"]) ifTrue:[				(self pointersTo: ref) do:[:meth|					(meth isKindOf: CompiledMethod) ifTrue:[						meth methodReference ifNotNilDo:[:mref|							references nextPut: mref]]]]]].	].	^references contents! !!SystemDictionary methodsFor: 'retrieving' stamp: 'ar 8/16/2001 13:29'!allGlobalRefsWithout: classesAndMessagesPair	"Answer a set of symbols that may be refs to Global names.  In some sense we should only need the associations, but this will also catch, eg, HTML tag types.  This method computes its result in the absence of specified classes and messages."	| globalRefs absentClasses absentSelectors |	globalRefs _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	Cursor execute showWhile: 		[self classNames do: 			[:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{(self at: cName). (self at: cName) class}]) do:				[:cl | (absentSelectors isEmpty						ifTrue: [cl selectors]						ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: 					[:sel | "Include all capitalized symbols for good measure"					(cl compiledMethodAt: sel) literals do: 						[:m | 						((m isMemberOf: Symbol) and: [m size > 0 and: [m first isUppercase]]) ifTrue:							[globalRefs add: m].						(m isMemberOf: Array) ifTrue:							[m do: [:x | ((x isMemberOf: Symbol) and: [x size > 0 and: [x first isUppercase]]) ifTrue:								[globalRefs add: x]]].						(m isVariableBinding) ifTrue:							[m key ifNotNil: [globalRefs add: m key]]]]]]].	^ globalRefs! !!Environment methodsFor: 'system conversion' stamp: 'ar 8/16/2001 13:25'!browseIndirectRefs  "Smalltalk browseIndirectRefs"	| cm lits browseList foundOne allClasses n |	self flag: #mref.		"no senders at the moment. also no Environments at the moment"	browseList _ OrderedCollection new.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Locating methods with indirect global references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			{ cls. cls class } do:				[:cl | cl selectors do:					[:sel | cm _ cl compiledMethodAt: sel.					lits _ cm literals.					foundOne _ false.					lits do:						[:lit | lit isVariableBinding ifTrue:							[(lit value == cl or: [cl scopeHas: lit key ifTrue: [:ignored]])								ifFalse: [foundOne _ true]]].					foundOne ifTrue: [						browseList add: (							MethodReference new								setStandardClass: cl 								methodSymbol: sel						)					]]]]].	Smalltalk 		browseMessageList: browseList asSortedCollection		name: 'Indirect Global References'		autoSelect: nil! !!Environment methodsFor: 'system conversion' stamp: 'ar 8/16/2001 13:25'!rewriteIndirectRefs   "Smalltalk rewriteIndirectRefs"	"For all classes, identify all methods with references to globals outside their direct access path.	For each of these, call another method to rewrite the source with proper references."	| cm lits envtForVar envt foundOne allClasses n |	envtForVar _ Dictionary new.  "Dict of varName -> envt name"	Smalltalk associationsDo:		[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt size < 500])			ifTrue: [envt associationsDo:						[:a | envtForVar at: a key put: assn key]]].	"Allow compiler to compile refs to globals out of the direct reference path"	Preferences enable: #lenientScopeForGlobals.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Updating indirect global references in source code...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			{ cls. cls class } do:				[:cl | cl selectors do:					[:sel | cm _ cl compiledMethodAt: sel.					lits _ cm literals.					foundOne _ false.					lits do:						[:lit | lit isVariableBinding ifTrue:							[(lit value == cl or: [cl scopeHas: lit key ifTrue: [:ignored]])								ifFalse: [foundOne _ true]]].					foundOne ifTrue:						[self rewriteSourceForSelector: sel inClass: cl using: envtForVar]]].			]].	Preferences disable: #lenientScopeForGlobals.! !!Environment methodsFor: 'system conversion' stamp: 'ar 8/16/2001 13:25'!tallyIndirectRefs   "Smalltalk tallyIndirectRefs"	"For all classes, tally the number of references to globals outside their inherited environment.  Then determine the 'closest' environment that resolves most of them.  If the closest environment is different from the one in whick the class currently resides, then enter the class name with the tallies of its references to all other environments.	Return a triplet:	A dictionary of all classes for which this is so, with those tallies,	A dictionary giving the classes that would be happier in each of the other categories,	A list of the variable names sorted by number of occurrences."	| tallies refs cm lits envtForVar envt envtRefs allRefs newCategories cat allClasses n |	envtForVar _ Dictionary new.  "Dict of varName -> envt name"	allRefs _ Bag new.	Smalltalk associationsDo:		[:assn | (((envt _ assn value) isKindOf: Environment) and: [envt size < 500])			ifTrue: [envt associationsDo:						[:a | envtForVar at: a key put: assn key]]].	tallies _ Dictionary new.	allClasses _ OrderedCollection new.	Smalltalk allClassesAnywhereDo: [:cls | allClasses addLast: cls].	'Scanning methods with indirect global references...'		displayProgressAt: Sensor cursorPoint		from: 0 to: allClasses size		during:		[:bar | n _ 0.		allClasses do:			[:cls | bar value: (n_ n+1).			refs _ Set new.			{ cls. cls class } do:			[:cl | cl selectors do:				[:sel | cm _ cl compiledMethodAt: sel.				lits _ cm literals.				lits do:					[:lit | lit isVariableBinding ifTrue:						[(lit value == cl or: [cls canFindWithoutEnvironment: lit key])							ifFalse: [refs add: lit key]]]]].		envtRefs _ Bag new.		refs asSet do:			[:varName |			envtRefs add: (envtForVar at: varName)					withOccurrences: (refs occurrencesOf: varName).			(envtRefs sortedCounts isEmpty or: [envtRefs sortedCounts first value == (Smalltalk keyAtValue: cls environment)])				ifFalse: [allRefs add: varName withOccurrences: (refs occurrencesOf: varName).						tallies at: cls name put: envtRefs sortedCounts.						Transcript cr; print: envtRefs sortedCounts; endEntry]]]].	newCategories _ Dictionary new.	tallies associationsDo:		[:assn | cat _ assn value first value.		(newCategories includesKey: cat) ifFalse:			[newCategories at: cat put: Array new].		newCategories at: cat put: ((newCategories at: cat) copyWith: assn key)].	^ { tallies. newCategories. allRefs sortedCounts }! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'ar 8/16/2001 13:30'!isColorConstant: aParseNode	"Is this a Color constant, of the form (MessageNode (VariableNode Color->Color) (SelectorNode #r:g:b:) (LiteralNode LiteralNode LiteralNode))"	| rec |	((rec _ aParseNode receiver) isKindOf: VariableNode) ifFalse: [^ false].	rec key isVariableBinding ifFalse: [^ false].	rec key value == Color ifFalse: [^ false].	aParseNode selector key == #r:g:b: ifFalse: [^ false].	aParseNode arguments  size = 3 ifFalse: [^ false].	^ true! !!VariableNode methodsFor: 'testing' stamp: 'ar 8/14/2001 23:00'!index	"This code attempts to reconstruct the index from its encoding in code."	code < 0 ifTrue:[^nil].	code > 256 ifTrue:[^code \\ 256].	^code - self type! !!VariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2001 23:14'!emitLoad: stack on: strm	"Do nothing"! !!VariableNode methodsFor: 'tiles' stamp: 'ar 8/16/2001 13:30'!variableGetterBlockIn: aContext	| temps index ivars |	(self type = 4 and: [key isVariableBinding]) ifTrue: [		^[key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars _ aContext receiver class allInstVarNames.		index _ ivars indexOf: name ifAbsent: [^nil].		^[aContext receiver instVarAt: index]	].	self type = 2 ifTrue: [		temps _ aContext tempNames.		index _ temps indexOf: name ifAbsent: [^nil].		^[aContext tempAt: index]	].	^nil! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:12'!emitLoad: stack on: strm	splNode ifNil:[^super emitLoad: stack on: strm].	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:12'!emitStore: stack on: strm	splNode ifNil:[^super emitStore: stack on: strm].	splNode			emit: stack			args: 1			on: strm			super: false.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:12'!emitStorePop: stack on: strm	splNode ifNil:[^super emitStorePop: stack on: strm].	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:02'!sizeForStore: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStore: encoder].	index _ self index.	code _ self code: index type: LdLitType.	splNode _ encoder encodeSelector: #value:.	^(splNode size: encoder args: 1 super: false) + (super sizeForValue: encoder)! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/16/2001 12:13'!sizeForStorePop: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStorePop: encoder].	index _ self index.	code _ self code: index type: LdLitType.	splNode _ encoder encodeSelector: #value:.	^(splNode size: encoder args: 1 super: false) + (super sizeForValue: encoder) + 1! !!AssignmentNode methodsFor: 'code generation' stamp: 'ar 8/14/2001 23:15'!emitForEffect: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	variable emitStorePop: stack on: aStream! !!AssignmentNode methodsFor: 'code generation' stamp: 'ar 8/14/2001 23:15'!emitForValue: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	variable emitStore: stack on: aStream! !!Encoder methodsFor: 'private' stamp: 'ar 8/14/2001 23:12'!global: ref name: name	^self		name: name		key: ref		class: LiteralVariableNode		type: LdLitIndType		set: litIndSet! !"Postscript:Convert all behaviors to read-only variables."| readOnly readWrite |readWrite _ Array streamContents:[:s|	Smalltalk associationsDo:[:assoc| assoc value isBehavior ifTrue:[s nextPut: assoc]].	s nextPut: (Smalltalk associationAt: #Smalltalk).].readOnly _ readWrite collect:[:x| (ReadOnlyVariableBinding key: x key value: x value)].readOnly elementsExchangeIdentityWith: readWrite.!