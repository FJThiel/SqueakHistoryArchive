'From Squeak 2.4b of April 23, 1999 on 30 April 1999 at 6:49:22 am'!"Change Set:		UDPSocketsDate:			30 April 1999Author:			Andreas RaabAdds the missing image support for UDP sockets (based on the fileIn from alix.inria.fr)"!Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'System-Network'!!Socket methodsFor: 'initialize-destroy' stamp: 'ar 4/30/1999 04:23'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex |	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil	] ifFalse:[self register].! !!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!address	"Shortcut"	^self localAddress! !!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!port	"Shortcut"	^self localPort! !!Socket methodsFor: 'primitives' stamp: 'ar 4/30/1999 04:31'!primSocket: socketID setPort: port	"Set the local port associated with a UDP socket.	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but	the effects will not be what was desired.  Best solution would be to split Socket into	two subclasses, TCPSocket and UDPSocket."	<primitive: 218>	self primitiveFailed! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:28'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	self setPeer: hostAddress port: portNumber.	^self receiveDataInto: aStringOrByteArray! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:28'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	self setPeer: hostAddress port: portNumber.	^self sendData: aStringOrByteArray.! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!setPeer: hostAddress port: port	"Set the default send/recv address."	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!setPort: port	"Associate a local port number with a UDP socket.  Not applicable to TCP sockets."	self primSocket: socketHandle setPort: port.! !!Socket methodsFor: 'other' stamp: 'ar 4/30/1999 06:00'!getResponseNoLF	"Get the response to the last command."	| buf response bytesRead c lf |	(self waitForDataUntil: (Socket deadlineSecs: 20)) ifFalse: [		self error: 'getResponse timeout'].	lf _ Character lf.	buf _ String new: 1000.	response _ WriteStream on: ''.	[self dataAvailable] whileTrue: [		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.		1 to: bytesRead do: [ :i |			(c _ buf at: i) ~= lf ifTrue: [response nextPut: c]]].	^ response contents! !!Socket class methodsFor: 'class initialization' stamp: 'ar 4/30/1999 04:12'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType _ 0.	UDPSocketType _ 1.	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:15'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	"Note: The default creates a TCP socket"	^self tcpCreateIfFail: failBlock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:13'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	"Note: The default creates a TCP socket - this is also backward compatibility."	^self newTCP! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:13'!newTCP	"Create a socket and initialise it for TCP"	^ super new initialize: TCPSocketType! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:13'!newUDP	"Create a socket and initialise it for UDP"	^ super new initialize: UDPSocketType! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:14'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize: TCPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:14'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize: UDPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!wildcardAddress	"Answer a don't-care address for use with UDP sockets."	^ByteArray new: 4		"0.0.0.0"! !!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!wildcardPort	"Answer a don't-care port for use with UDP sockets.  (The system will allocate an	unused port number to the socket.)"	^0! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 04:17'!clientServerTestUDP	"Socket clientServerTestUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		client/server UDP test done; time = 2820		2500 packets, 10000000 bytes sent (3546 kBytes/sec)		2500 packets, 10000000 bytes received (3546 kBytes/sec)		4000 bytes/packet, 886 packets/sec, 0 packets dropped"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ Socket newUDP.	"the sender"	sock2 _ Socket newUDP.	"the recipient"	sock2 setPort: 54321.	sock1 setPeer: (NetNameResolver localHostAddress) port: (sock2 port).	Transcript show: 'endpoints created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)]].	Transcript show: 'closing endpoints'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	bytesReceived _ bytesReceived + sock2 discardReceivedData.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent // t) printString, ' kBytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived // t) printString, ' kBytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 04:18'!remoteTestClientTCP	"FIRST start up another image, and execute: Socket remoteTestServerTCP.	THEN come back to this image and execute:"			"Socket remoteTestClientTCP"	"Performa 6400/200, Linux-PPC 2.1.24, both images on same CPU:		remoteClient TCP test done; time = 5680		250 packets, 1000000 bytes sent (176 kBytes/sec)		60 packets, 1000000 bytes received (176 kBytes/sec)"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	socket connectTo: (NetNameResolver localHostAddress) port: 54321.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].	].	[bytesReceived < bytesToSend] whileTrue:		[packetsReceived _ packetsReceived + 1.		bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].	socket closeAndDestroy.	Transcript show: 'remoteClient TCP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent // t) printString, ' kBytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived // t) printString, ' kBytes/sec)'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 04:19'!remoteTestClientUDP	"FIRST start up another image, and execute: Socket remoteTestServerUDP.	THEN come back to this image and execute:"			"Socket remoteTestClientUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		remoteClient UDP test done; time = 4580		2500 packets, 10000000 bytes sent (2183 kBytes/sec)		180 packets, 720000 bytes received (157 kBytes/sec)		4000 bytes/packet, 39 packets/sec, 2320 packets dropped"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newUDP.	socket setPeer: (NetNameResolver localHostAddress) port: 54321.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].	].	[socket dataAvailable] whileTrue:		[packetsReceived _ packetsReceived + 1.		bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].	socket closeAndDestroy.	Transcript show: 'remoteClient UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent // t) printString, ' kBytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived // t) printString, ' kBytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 04:19'!remoteTestServerTCP	"See remoteTestClientTCP for instructions on running this method."	"Socket remoteTestServerTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	socket listenOn: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.			socket waitForSendDoneUntil: self standardDeadline.			socket sendData: buffer count: n]].	socket closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 04:19'!remoteTestServerUDP	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP"	| socket buffer |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[socket receiveDataInto: buffer.			socket sendData: buffer]].! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 05:59'!timeTest	"Socket timeTest"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: serverAddr port: 13.  "13 is the 'daytime' port number"	s waitForConnectionUntil: (self deadlineSecs: 1).	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 05:58'!timeTestUDP	"Socket timeTestUDP"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket newUDP.		"a 'random' port number will be allocated by the system"	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	"13 is the daytime service"	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Socket closed ----------'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 05:56'!timeTestUDP2	"Socket timeTestUDP2"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: 54321.	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Socket closed ----------'; cr.! !!Socket class methodsFor: 'examples' stamp: 'ar 4/30/1999 05:56'!timeTestUDP3	"Socket timeTestUDP3"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: (Socket wildcardPort).		"explicitly request a default port number"	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Socket closed ----------'; cr.! !Socket initialize!