'From Squeak 2.3 of January 14, 1999 on 14 January 1999 at 1:17:52 pm'!!BookMorph methodsFor: 'initialization' stamp: 'tk 1/14/1999 12:53'!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm |	Cursor wait showWhile: [		strm _ (ServerFile new fullPath: url) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	self fromRemoteStream: strm.	self setProperty: #url toValue: url.	^ self! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/14/1999 12:30'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL."	| holder mine sf remoteFile strm remote pageURL num pre index after sp dict allText allTextUrls |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	2 to: remote size do: [:ii | 		((remote at: ii) url findString: pageURL startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	sp _ aPage sqkPage copy.	"is there"	holder _ MorphObjectOut new xxxSetUrl: sp url page: sp.	sp contentsMorph: holder.	remote at: index put: holder.	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: aPage allStrings.		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/14/1999 12:32'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list pg holder mine sf remoteFile urlList |	pages size = 0 ifTrue: [^ self].	dict _ Dictionary new.  dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	#(color borderWidth borderColor pageSize) do: [:sel |		dict at: sel put: (self perform: sel)].	list _ pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: [:out :ind |		out isInMemory ifTrue: [  			(pg _ out valueOfProperty: #SqueakPage) ifNil: [				out saveOnURLbasic].			pg _ (out valueOfProperty: #SqueakPage) copy.			holder _ MorphObjectOut new xxxSetUrl: pg url page: pg.			pg contentsMorph: holder.			list at: ind put: holder]].	urlList _ list collect: [:ppg | ppg url].	self setProperty: #allTextUrls toValue: urlList.	dict at: #allTextUrls put: urlList.	list _ (Array with: dict), list.	mine _ self valueOfProperty: #url.	mine ifNil: [mine _ self getStemUrl, '.bo'.		self setProperty: #url toValue: mine].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: list.		"remoteFile close"].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/14/1999 11:32'!readInstance	"Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next asSymbol.	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject _ anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'conversion' stamp: 'tk 1/14/1999 13:16'!transparentColorrcc0	^ TranslucentColor! !!SqueakPage methodsFor: 'saving' stamp: 'tk 1/14/1999 12:30'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty _ dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf _ ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		lastChangeAuthor _ Utilities authorInitialsPerSe ifNil: ['*'].		lastChangeTime _ Time totalSeconds.		Cursor wait showWhile: [			remoteFile _ sf fileNamed: url.	"no notification when overwriting"			remoteFile fileOutClass: nil andObject: self.			"remoteFile close"].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty _ false].! !!TranslucentColor methodsFor: 'object fileIn' stamp: 'tk 1/13/1999 11:22'!convertrcc0: varDict rcca0: smartRefStrm	"These variables are automatically stored into the new instance ().	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('alpha' ) and deal with the information in ()"	^ Color transparent! !!URLMorph methodsFor: 'event handling' stamp: 'tk 1/14/1999 12:54'!mouseUp: evt	| pg ow newPage mm ll bookUrl bk |	"If url of a book, bring in book with first page and grab it."	book==true ifTrue: [		ll _ url findLast: [:char | char == $.].		ll = 0 ifTrue: [^ self].		bookUrl _ url copyFrom: 1 to: ll-1.	"remove .sp"		bookUrl _ (bookUrl stemAndNumericSuffix) at: 1.		"remove trailing number"		[bookUrl last == $x] whileTrue: [bookUrl _ bookUrl allButLast].		bookUrl _ bookUrl, '.bo'.		(BookMorph alreadyInFromUrl: bookUrl) ifTrue: [^ self].			"If this book is already in, we would steal the pages out of it!!"		(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self].		bk goToPageUrl: url.	"turn to the page"		^ World primaryHand attachMorph: bk].	"If inside a SqueakPage, replace it!!"	pg _ self enclosingPage.	pg ifNotNil: [		(ow _ pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage _ SqueakPageCache atURL: url.			mm _ newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page _ newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage _ SqueakPageCache atURL: url.	mm _ newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page _ newPage].! !