'From Squeak 2.3 beta of Nov 25, 1998 on 25 February 1999 at 11:05 am'!!Object methodsFor: 'objects from disk' stamp: 'tk 2/24/1999 11:08'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    ^ self! !!Class methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 11:10'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	^ DiskProxy global: self theNonMetaClass name selector: #yourself			args: #()! !!BookMorph class methodsFor: 'all' stamp: 'tk 2/24/1999 14:07'!isInWorld: aWorld withUrl: aUrl	"If a book with this url is in the that (current) world, return it.  Say if it is out or in another world."	self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]					ifFalse: [						self inform: 'Book may be open in some other project'.						^ aBook]]]].	^ #out! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 11:10'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."Smalltalk allBehaviorsDo: [:aClass | 	aClass organization == self ifTrue: [		(aClass isKindOf: Class) ifTrue: [			^ DiskProxy global: aClass name selector: #organization args: #()]]].^ self	"in desparation"! !!DataStream methodsFor: 'all' stamp: 'tk 2/24/1999 11:18'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectForDataStream:) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectForDataStream: self.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString: writeBitmap:) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DisplayScreen methodsFor: 'disk I/O' stamp: 'tk 2/24/1999 11:10'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a reference to the Display in the other system instead.  "	"A path to me"	^ DiskProxy global: #Display selector: #yourself args: #()! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'tk 2/24/1999 11:11'!objectForDataStream: refStrm    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	| objToStore |	objToStore _ self clone.	objToStore leftSamples: leftSamples asByteArray.	self isStereo		ifTrue: [objToStore rightSamples: rightSamples asByteArray]		ifFalse: [objToStore rightSamples: objToStore leftSamples].	^ objToStore! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 11:11'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	^ DiskProxy global: self theNonMetaClass name selector: #class			args: (Array new)! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 2/24/1999 11:20'!objectForDataStream: refStrm	"I am being written out on an object file"	self sqkPage ifNotNil: [		(refStrm rootObject == self) | (refStrm rootObject == self sqkPage) ifFalse: [			self url size > 0 ifTrue: [				^ self sqkPage copyForSaving]]].	"be careful touching this object!!"	self prepareToBeSaved.		"Amen"	^ self! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'tk 2/24/1999 00:01'!computeThumbnail	| f scale |	self objectsInMemory.	f _ page imageForm.	scale _ (self height / f height).  "keep height invariant""(Sensor shiftPressed) ifTrue: [scale _ scale * 1.4]."	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'tk 2/24/1999 13:24'!doPageFlip	"Flip to this page"	self objectsInMemory.	bookMorph ifNil: [^ self].	bookMorph goToPageMorph: page			transitionSpec: (self valueOfProperty: #transitionSpec).	(owner isKindOf: PasteUpMorph) ifTrue:		[owner cursor: (owner submorphs indexOf: self ifAbsent: [1])]! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 13:33'!objectForDataStream: refStrm	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph class == String) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page class == String) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph == nil) & (page url ~~ nil) ifTrue: [		^ super objectForDataStream: refStrm].		clone _ self clone.	(bookUrl _ bookMorph url)		ifNil: [bookUrl _ self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb _ RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ SqueakPage stemUrl: bookUrl.		ind _ bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	^ clone! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 15:00'!objectsInMemory	"See if page or bookMorph need to be brought in from a server."	| bookUrl bk wld try |	bookMorph ifNil: ["fetch the page"		page class == String ifFalse: [^ self].	"a morph"		try _ (SqueakPageCache atURL: page) fetchContents.		try ifNotNil: [page _ try].		^ self].	bookMorph class == String ifTrue: [		bookUrl _ bookMorph.		(wld _ self world) ifNil: [wld _ Smalltalk currentWorld].		bk _ BookMorph isInWorld: wld withUrl: bookUrl.		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project'].		bk == #out ifTrue: [			(bk _ BookMorph new fromURL: bookUrl) ifNil: [^ self]].		bookMorph _ bk].	page class == String ifTrue: [		page _ (bookMorph pages detect: [:pg | pg url = page] 					ifNone: [bookMorph pages at: 1])].! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'tk 2/25/1999 11:04'!sortPages	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self pageNumber.	"Align at bottom right of screen, but leave 20-pix margin."	self bottom + sorter height < Display height ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter topLeft with: self bottomLeft)].	self right + sorter width < Display width ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter bottomLeft with: self bottomRight)].	"Otherwise, place it at lower right of screen"	self world addMorphFront: (sorter position: Display extent - (20@20) - sorter extent).! !!BookMorph methodsFor: 'sorting' stamp: 'tk 2/24/1999 15:23'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| goodPages rejects toAdd sqPage |	goodPages _ OrderedCollection new.	rejects _ OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: PasteUpMorph) ifTrue: [toAdd _ m].		(m isKindOf: BookPageThumbnailMorph) ifTrue: [toAdd _ m page].		toAdd class == String ifTrue: ["a url"			toAdd _ pages detect: [:aPage | aPage url = toAdd] ifNone: [toAdd]].		toAdd class == String ifTrue: [			sqPage _ SqueakPageCache atURL: toAdd.			toAdd _ sqPage contentsMorph 				ifNil: [sqPage copyForSaving]	"a MorphObjectOut"				ifNotNil: [sqPage contentsMorph]].		toAdd ifNil: [rejects add: m]			ifNotNil: [goodPages add: toAdd]].	self newPages: goodPages.	goodPages size = 0 ifTrue: [self insertPage].	rejects size > 0 ifTrue: [self inform: rejects size printString, ' objects vanished in this process.']! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:26'!reserveUrls	"Save a dummy version of the book first, assign all pages URLs, write dummy files to reserve the url, and write the index.  Good when I have pages with interpointing bookmarks."| stem |(stem _ self getStemUrl) size = 0 ifTrue: [^ self].pages doWithIndex: [:pg :ind | 	"does write the current page too"	pg url ifNil: [pg reserveUrl: stem,(ind printString),'.sp']].self saveIndexOnURL.! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:37'!reserveUrlsIfNeeded	"See if this book needs to pre-allocate urls.  Harmless if have urls already.  Actually writes dummy files to reserve names."| baddies bad2 |pages size > 25 ifTrue: [^ self reserveUrls].baddies _ BookPageThumbnailMorph withAllSubclasses.bad2 _ FlexMorph withAllSubclasses.pages do: [:aPage |	aPage allMorphsDo: [:mm | 		(baddies includes: mm class) ifTrue: [^ self reserveUrls].		(bad2 includes: mm class) ifTrue: [			mm originalMorph class == aPage class ifTrue: [				^ self reserveUrls]]]].		! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:29'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime bookUrl |firstTime _ (self valueOfProperty: #url) == nil.stem _ self getStemUrl.	"user must approve"stem size = 0 ifTrue: [^ self].firstTime ifTrue: [self setProperty: #futureUrl toValue: stem, '.bo'].self reserveUrlsIfNeeded.pages doWithIndex: [:aPage :ind | 	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURL: stem,(ind printString),'.sp'.		]].list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	bookUrl _ self valueOfProperty: #url.	(SqueakPage stemUrl: bookUrl) = (SqueakPage stemUrl: currentPage url) ifTrue: [		bookUrl _ true].		"not a shared book"	(URLMorph grabURL: currentPage url) book: bookUrl.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/23/1999 12:59'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL."	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls |	mine _ self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm _ (ServerFile new fullPath: mine) asStream].	strm class == String ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	remote _ strm fileInObjectAndCode.	dict _ remote at: 1.	allText _ dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls _ dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL _ aPage url) ifNil: [self error: 'just had one!!'].	2 to: remote size do: [:ii | 		((remote at: ii) url findString: pageURL startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index _ ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num _ self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre _ (pages at: ii) url]].		pre ifNil: [after _ remote size+1]			ifNotNil: ["look for it on disk, put me after"				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after _ ii+1]]].		remote _ remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index _ after].	remote at: index put: (aPage sqkPage copyForSaving).	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/23/1999 13:02'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list mine sf remoteFile urlList |	pages size = 0 ifTrue: [^ self].	dict _ Dictionary new.  dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	#(color borderWidth borderColor pageSize) do: [:sel |		dict at: sel put: (self perform: sel)].	list _ pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: [:out :ind |		out isInMemory ifTrue: [  			(out valueOfProperty: #SqueakPage) ifNil: [				out saveOnURLbasic].			list at: ind put: (out sqkPage copyForSaving)]].	urlList _ list collect: [:ppg | ppg url].	self setProperty: #allTextUrls toValue: urlList.	dict at: #allTextUrls put: urlList.	list _ (Array with: dict), list.	mine _ self valueOfProperty: #url.	mine ifNil: [mine _ self getStemUrl, '.bo'.		self setProperty: #url toValue: mine].	sf _ ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile _ sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: list.		"remoteFile close"].! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:22'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) == nil and: [pages first url ~~ nil]) ifTrue: [		response _ (PopUpMenu labels: 'Old book\New book sharing old pages' 					withCRs)				startUpWithCaption: 'Modify the old book, or make a new\book sharing its pages?' withCRs.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand _ String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			(newPlace _ self getStemUrl) size = 0 ifTrue: [^ self].			newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.			dir _ ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem _ self getStemUrl.	"user must approve"	stem size = 0 ifTrue: [^ self].	ind _ pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?'].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:39'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.		^ self].	self getAllText.	"stored with index later"	response _ (PopUpMenu labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)\Save new book sharing old pages' withCRs)			startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' withCRs.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand _ String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		(newPlace _ self getStemUrl) size = 0 ifTrue: [^ self].		newPlace _ (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.		dir _ ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl _ self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl _ true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self]."self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURLbasic.		]].	"ask user if no url"list _ pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list _ (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime _ (self valueOfProperty: #url) == nil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	(URLMorph grabURL: (self valueOfProperty: #url)) book: true].! !!FlexMorph methodsFor: 'all' stamp: 'tk 2/25/1999 10:36'!originalMorph	^ originalMorph! !!HandMorph methodsFor: 'file in/out' stamp: 'tk 2/24/1999 11:11'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #World selector: #primaryHand args: #()	"Note, when this file is loaded in an MVC project, this will return nil.  The MenuItemMorph that has this in a field will have that item not work.  Maybe warn the user at load time?"! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 2/23/1999 15:25'!comeFullyUpOnReload	"Normally this read-in object is exactly what we want to store.  Try to dock first.  If it is here already, use that one."	| sp |	Transcript show: 'has ref to: ', url; cr.	(sp _ SqueakPageCache pageCache at: page ifAbsent: [nil]) ifNotNil: [		sp isContentsInMemory ifTrue: [^ sp contentsMorph]].	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 2/24/1999 11:14'!objectForDataStream: refStrm    "Return an object to store on a data stream (externalize myself)."    ^ self! !!ObjectOut methodsFor: 'basics' stamp: 'tk 2/24/1999 15:55'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 2/24/1999 00:08'!smallThumbnailForPageSorter	^ self sqkPage thumbnail! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 2/24/1999 00:09'!thumbnailForPageSorter	^ self sqkPage thumbnail! !!Project methodsFor: 'file in/out' stamp: 'tk 2/24/1999 11:14'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #Project selector: #named: args: (Array with: self name)! !!ScreenController methodsFor: 'file in/out' stamp: 'tk 2/24/1999 11:14'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #ScheduledControllers selector: #screenController args: #()! !!SimpleButtonMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 11:16'!objectForDataStream: refStrm	"I am about to be written on an object file.  If I send a message to a BookMorph, it would be bad to write that object out.  Create and write out a URLMorph instead."	| bb thatPage um stem ind sqPg |	(actionSelector == #goToPageMorph:fromBookmark:) | 		(actionSelector == #goToPageMorph:) ifFalse: [			^ super objectForDataStream: refStrm].	"normal case"	target url ifNil: ["Later force target book to get a url."		bb _ SimpleButtonMorph new.	"write out a dummy"		bb label: self label.		bb bounds: bounds.		^ bb].	(thatPage _ arguments first) url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem _ target getStemUrl.	"know it has one"		ind _ target pages identityIndexOf: thatPage.		thatPage reserveUrl: stem,(ind printString),'.sp'].	um _ URLMorph newForURL: thatPage url.	sqPg _ thatPage sqkPage clone.	sqPg contentsMorph: nil.	um setURL: thatPage url page: sqPg.	(SqueakPage stemUrl: target url) = (SqueakPage stemUrl: thatPage url) 		ifTrue: [um book: true]		ifFalse: [um book: target url].  	"remember which book"	um privateOwner: owner.	um bounds: bounds.	um isBookmark: true; label: self label.	um borderWidth: borderWidth; borderColor: borderColor.	um color: color.	^ um! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 2/23/1999 14:39'!copyForSaving	"Make a copy and configure me to be put out on the disk.  When it is brought in and touched, it will turn into the object at the url."	| forDisk holder |	forDisk _ self clone.	holder _ MorphObjectOut new xxxSetUrl: url page: forDisk.	forDisk contentsMorph: holder.	^ holder		"directly representing the object"! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 2/24/1999 12:06'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph _ aMorph.	n _ aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor _ authorString.		creationTime _ Time totalSeconds]."	lastChangeAuthor _ authorString.	lastChangeTime _ Time totalSeconds.	do it when actually write"	self computeThumbnail.	self postChangeNotification.! !!SqueakPage methodsFor: 'private' stamp: 'tk 2/25/1999 09:13'!computeThumbnail	"Make a thumbnail from my morph."	(contentsMorph isKindOf: PasteUpMorph) 		ifTrue: [thumbnail _ contentsMorph smallThumbnailForPageSorter]		ifFalse: [self updateThumbnail]! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 2/24/1999 11:16'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	^ DiskProxy global: #StrikeFont selector: #familyName:size:emphasized:			args: (Array with: self name   with: self height					with: self emphasis).! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 11:16'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."self == SystemOrganization ifTrue: [	^ DiskProxy global: #SystemOrganization selector: #yourself args: #()].^ self! !!TranscriptStream methodsFor: 'file in/out' stamp: 'tk 2/24/1999 11:17'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #Transcript selector: #yourself args: #()! !!URLMorph methodsFor: 'private' stamp: 'tk 2/24/1999 12:31'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	| thum |	page ifNil: [page _ SqueakPageCache atURL: url].	(thum _ page thumbnail) ifNil: [^ nil].	^ (thum isKindOf: Form) 		ifTrue: [thum]		ifFalse: [thum form]	"a BookPageThumbnailMorph"! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'tk 2/24/1999 11:17'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #World selector: #yourself args: #()	"Note, when this file is loaded in an MVC project, this will return nil.  The MenuItemMorph that has this in a field will have that item not work.  Maybe warn the user at load time?"! !Object removeSelector: #objectToStoreOnDataStream!Class removeSelector: #objectToStoreOnDataStream!ClassOrganizer removeSelector: #objectToStoreOnDataStream!DisplayScreen removeSelector: #objectToStoreOnDataStream!LoopedSampledSound removeSelector: #objectToStoreOnDataStream!Metaclass removeSelector: #objectToStoreOnDataStream!Morph removeSelector: #objectToStoreOnDataStream!BookPageThumbnailMorph removeSelector: #objectToStoreOnDataStream!BookMorph removeSelector: #savePrep!BookMorph removeSelector: #indexOfCurrentPage!HandMorph removeSelector: #objectToStoreOnDataStream!MorphThumbnail removeSelector: #objectToStoreOnDataStream!ObjectOut removeSelector: #objectToStoreOnDataStream!Project removeSelector: #objectToStoreOnDataStream!ScreenController removeSelector: #objectToStoreOnDataStream!SimpleButtonMorph removeSelector: #objectToStoreOnDataStream!StrikeFont removeSelector: #objectToStoreOnDataStream!SystemOrganizer removeSelector: #objectToStoreOnDataStream!TranscriptStream removeSelector: #objectToStoreOnDataStream!WorldMorph removeSelector: #objectToStoreOnDataStream!