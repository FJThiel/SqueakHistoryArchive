'From Squeak 2.1 of June 30, 1998 on 22 August 1998 at 11:06:07 pm'!"Change Set:		costumeRetakeEtc-swDate:			22 August 1998Author:			Scott WallaceMain point of this update is a retake on costumes, with the primary points being:*  Finally restores the ability for 'classic animation', broken since the advent of flexing, to work -- e.g. 'car look like holder's valueAtCursor'.*  Removes the costumeDictionary from Player's class, saving a Dictionary per Player.*  Adds a costumes inst var to the Player -- normally nil, but if player has worn more than one costume, holds the list.*  The next-costume and previous-costume arrows adjacent to the thumbnail in the Viewer now do what you'd expect, even in the case of a series of *  Direct inst var accesses to #costume are drastically reduced."!AlignmentMorph subclass: #PartsViewer	instanceVariableNames: 'scriptedPlayer partsBank scriptsBank '	classVariableNames: 'CaretColor ControlButtonColor '	poolDictionaries: ''	category: 'Morphic-Scripting'!Model subclass: #Player	instanceVariableNames: 'costume costumes '	classVariableNames: 'BiggestSubclassNumber TimeOfError '	poolDictionaries: ''	category: 'Morphic-Scripting'!Player class	instanceVariableNames: 'scripts slotInfo '!!DeepCopier methodsFor: 'like fullCopy' stamp: 'sw 8/22/1998 21:55'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, you MUST go the the method being checked (veryDeepCopyWith:) and update its code.  And then update the test here."	| str str2 |	str _ '|veryDeepCopyWith: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of ', str].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	Morph instVarNames = #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension') 		ifFalse: [self error: 'Morph', str].	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' 'subclasses' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].	"Any other class that implements veryDeepCopyWith: for the purpose of not doing	a veryDeepCopy on some inst var, must have a check here."! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 8/20/1998 17:32'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	newMorph arrangeToStartStepping! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/19/1998 18:14'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer _ self player) ifNil:		[self externalName.  "a default may be given if not named yet"		self player: (aPlayer _ self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/22/1998 22:00'!duplicateMorph	| newMorph aName usedNames |	newMorph _ argument veryDeepCopy.	(aName _ argument knownName) ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo:			(Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	self grabMorphFromMenu: newMorph.	newMorph player ifNotNil: [newMorph player startRunning]! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:55'!caretColor	^ CaretColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:56'!controlButtonColor	^ ControlButtonColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:08'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:09'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeScripts	| r aButton aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousScriptsBank; label: '<' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'show previous bank of scripts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextScriptsBank; label: '>' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'show next bank of scripts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'add script' font: (aFont _ StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'add inst var' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	r addMorphBack: aButton.	^ r! !!PartsViewer class reorganize!('all' includeInNewMorphMenu initialize)!!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 18:00'!initialize	"PartsViewer initialize"	CaretColor _ Color green muchLighter.	ControlButtonColor _  Color green muchLighter! !!Player methodsFor: 'card/stack commands' stamp: 'sw 8/17/1998 17:23'!deleteCard	"Still underway"	true ifTrue: [^ self beep].	self costume deleteCard! !!Player methodsFor: 'clone' stamp: 'sw 8/22/1998 21:56'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls instVarAt: 10 "scripts" put: self class scripts.	"later must duplicate this"	newCls instVarAt: 11 "slotInfo" put: self class slotInfo deepCopy.	newCls copyAddedStateFrom: self class.  "The player-ref jump table?"	^ newCls! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:42'!availableCostumesForArrows	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:39'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds _ costume bounds.		costume pasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'costume' stamp: 'sw 8/18/1998 11:47'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph _ self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes size > 0 ifTrue:  "This catches the nil and empty cases both"		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 8/21/1998 17:19'!costumesDo: aBlock	"Evaluate aBlock against every real (not flex) costume known to the receiver)"	aBlock value: costume renderedMorph.	costumes ifNotNil:		[(costumes copyWithout: costume) do:			[:aCostume | aBlock value: aCostume]]! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:46'!forgetOtherCostumes	costumes _ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:39'!getValueFromCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 16:37'!knownSketchCostumeWithSameFormAs: aSketchMorph	| itsForm rend |	itsForm _ aSketchMorph form.	(((rend _ costume renderedMorph) isKindOf: SketchMorph) and: [rend form == itsForm])		ifTrue:	[^ rend].	^ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rawCostume: aMorph	costume _ aMorph! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember _ aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes _ OrderedCollection new].	existing _ (costumeToRemember isKindOf: SketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes _ costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 23:04'!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume pasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.			aMorph player: self.			aMorph actorState: costume actorState.			aMorph setNameTo: costume knownName.			costume _ aMorph]! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:45'!setCostumeSlot: setterSelector toValue: aValue	| aCostume |	(aCostume _ self costumeRespondingTo: setterSelector) ifNotNil:		[aCostume perform: setterSelector with: aValue]! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:51'!wearCostumeOf: anotherPlayer	"Put on a costume similar to the one currently worn by anotherPlayer"	| itsCostume |	itsCostume _ anotherPlayer costume renderedMorph.	(itsCostume isKindOf: SketchMorph)		ifTrue:			[self wearSketchCostumeResembling: itsCostume]		ifFalse:			[anotherPlayer costume player: nil.			self renderedCostume: itsCostume veryDeepCopy.			anotherPlayer costume player: anotherPlayer].	costume layoutChanged! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:39'!wearCostumeOfClass: aClass	"Assume that the costume in the library has player = nil"	| newCostume |	(costume isKindOf: aClass) ifTrue: [^ self].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ self renderedCostume: aCostume]]].	newCostume _ aClass new.	self renderedCostume: newCostume! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:36'!wearSketchCostumeResembling: aSketchMorph	| newCostume itsForm |	itsForm _ aSketchMorph form.	costumes size > 0 ifTrue:		[newCostume _ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]].	newCostume ifNil:		[newCostume _ SketchMorph new player: self.		newCostume form: aSketchMorph form;		rotationCenter: aSketchMorph rotationCenter;		rotationStyle: aSketchMorph rotationStyle;		framesToDwell: aSketchMorph framesToDwell		"position: costume position"].	self renderedCostume: newCostume! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:12'!assureExternalName	| aCostume |	(aCostume _ self costume) knownName ifNil:		[aCostume setNameTo: aCostume externalName]! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:20'!renameTo: aName	self costume topRendererOrSelf renameTo: aName! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:22'!choosePenColor: evt	evt hand changeColorTarget:  self costume  selector: #penColor:! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:12'!colorUnder	^ self costume colorUnder! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/17/1998 17:14'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isKindOf: WorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(colorSees	boolean		readOnly	dummy				unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAmount	self getValueFromCostume: #amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAngle	^ self getValueFromCostume: #angle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderColor	^ self getValueFromCostume: #borderColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderWidth	^ self getValueFromCostume: #borderWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColor	^ self costume renderedMorph color! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColorUnder	^ self costume colorUnder! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getCursor	^ self getValueFromCostume: #cursor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:51'!getHeadingUnrounded	^ self costume forwardDirection asSmallAngleDegrees! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getLeftRight	^ self getValueFromCostume: #leftRight! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!getMouseX	^ self costume mouseX! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getMouseY	^ self costume mouseY! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getScaleFactor	| aCostume |	^ (aCostume _ self costume) isFlexMorph		ifTrue: [aCostume scale]		ifFalse: [1.0]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:42'!getUpDown	^ self getValueFromCostume: #upDown! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:43'!getValueAtCursor	| anObject |	anObject _ self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:23'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	| aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ 100].	^ aCostume x! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:50'!getY	^ self costume y! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderColor: aColor	self setCostumeSlot: #borderColor: toValue: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderWidth: aWidth	self setCostumeSlot: #borderWidth: toValue: aWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:24'!setColor: aColor	self costume renderedMorph color: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:16'!setCostume: someOtherMorph	^ self costume wearCostume: someOtherMorph! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:47'!setCursor: aNumber	self setCostumeSlot: #cursor: toValue: aNumber! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/19/1998 08:23'!setHeading: aNumber	| aCostume |	aCostume _ self costume.	0.0 = aNumber		ifTrue: 			[1.0 = self getScaleFactor ifTrue:				[aCostume isFlexMorph ifTrue: [aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	self costume rotationDegrees: aNumber.! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setName: aName	^ self costume renameTo: aName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/18/1998 11:53'!setScaleFactor: aNumber	| aCostume |	aCostume _ self costume.	1.0 = aNumber		ifTrue:			[0.0 = self getHeading ifTrue:				[aCostume isFlexMorph ifTrue: [aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	aCostume scale: (aNumber asFloat max: 0.125)! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!setValueAtCursor: aPlayer	| renderedMorph aCostume |	aCostume _ self costume.	((renderedMorph _ aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(aCostume respondsTo: #valueAtCursor:) ifTrue: [aCostume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setX: val	^ self costume x: val! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:22'!setY: val	^ self costume y: val! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:20'!tearOffFancyWatcherFor: aSlotName	| aWatcher aTile getSel aLine aColor aTower |	aColor _ Color r: 0.903 g: 0.903 b: 1.0.	aLine _ AlignmentMorph newRow vResizing: #shrinkWrap; color: aColor.	aLine borderWidth: 1; borderColor: aColor darker.	aLine addMorphBack: (self tileReferringToSelf borderWidth: 0; typeColor: aColor; color: aColor; bePossessive).	aLine addTransparentSpacerOfSize: (4@0).	aTower _ AlignmentMorph newColumn color: aColor.	aTower addTransparentSpacerOfSize: (0 @ 1).	aTower addMorphBack: (StringMorph contents: aSlotName, ' = ' font: ScriptingSystem fontForTiles).	aLine addMorphBack: aTower.	aTile _ NumericReadoutTile new typeColor: aColor.	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true.	aWatcher growable: true;		getSelector: (getSel _ Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName).	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: getSel) width: 30.	aLine addMorphBack: aTile.	aWatcher step; fitContents.	self costume primaryHand attachMorph: aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:23'!tearOffWatcherFor: aSlotName	| aWatcher |	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true;		getSelector: (Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName);		setNameTo: aSlotName.	aWatcher step.	self costume primaryHand attachMorph: aWatcher! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/18/1998 11:56'!infoFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aMenu slotSym reply aType |	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MVCMenuMorph new.	aType == #number "later others" ifTrue:		[aMenu add: 'simple watcher' action: #simpleWatcher.		aMenu add: 'fancier watcher' action: #fancyWatcher].	(self slotInfo includesKey: (slotSym _ aSlotName asSymbol))		ifTrue:  "User slot"			[aMenu add: 'change data type' action: #chooseSlotType.			aMenu add: 'remove "', aSlotName, '"' action: #removeSlot.			aMenu add: 'rename  "', aSlotName, '"' action: #renameSlot].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	reply _  aMenu invokeAt: self costume primaryHand position in: self costume world.	reply == nil ifTrue: [^ self].	reply == #chooseSlotType ifTrue: [^ self chooseSlotTypeFor: slotSym].	reply == #removeSlot ifTrue: [^ self removeSlotNamed:  slotSym].	reply == #renameSlot ifTrue: [^ self renameSlot: slotSym].	reply == #simpleWatcher ifTrue: [^ self tearOffWatcherFor: slotSym].	reply == #fancyWatcher ifTrue: [^ self tearOffFancyWatcherFor: slotSym]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/20/1998 17:40'!instantiatedUserScriptsDo: aBlock	| aState |	(aState _ self costume actorState) ifNotNil:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:13'!okayToDestroyScriptNamed: scriptName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:21'!okayToRemoveSlotNamed: aSlotName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunning	self costume arrangeToStartStepping.	self instantiatedUserScriptsDo:		[:aScript | aScript startRunningIfPaused]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunningScripts	self startRunning.	self costume arrangeToStartStepping.  "emergency patch, if not going already"	self costume presenter startRunningScripts! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!beep: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:22'!bounce: soundName	| box bounced aCostume |	(aCostume _ self costume) ifNil: [^ self].	(aCostume owner == nil or: [aCostume owner isHandMorph]) ifTrue: [^ self].	box _ aCostume owner bounds.	bounced _ false.	(aCostume left < box left)			ifTrue: [self headRight. bounced _ true].	(aCostume right > box right)		ifTrue: [self headLeft. bounced _ true].	(aCostume top < box top)			ifTrue: [self headDown. bounced _ true].	(aCostume bottom > box bottom)	ifTrue: [self headUp. bounced _ true].	bounced ifTrue: [^ self makeBounceSound: soundName].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!changeScript: scriptName toStatus: statusSymbol	scriptName ifNil: [^ self].	Symbol hasInterned: scriptName ifTrue:		[:sym | self instantiatedUserScriptsDo:			[:aUserScript | aUserScript selector == sym				ifTrue:					[aUserScript status: statusSymbol.					^ self costume world updateStatusForAllScriptEditors]]]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:14'!forward: dist	| rho radians delta didStray p fractionalP newP aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	rho _ (aCostume asNumber: dist) asFloat.	radians _ (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta _ (radians cos @ radians sin) * rho.	((aCostume owner isHandMorph not) and:	 [aCostume presenter fenceEnabled]) ifTrue:		[(aCostume owner bounds containsRect: aCostume bounds) ifFalse:			["If I stray out of the bounds of my owner, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray _ false.			((aCostume left < aCostume owner left and: [delta x < 0]) or:			 [aCostume right > aCostume owner right and: [delta x > 0]]) ifTrue: [				delta _ delta x negated @ delta y.				didStray _ true].			((aCostume top < aCostume owner top and: [delta y < 0]) or:			 [aCostume bottom > aCostume owner bottom and: [delta y > 0]]) ifTrue: [				delta _ delta x @ delta y negated.				didStray _ true].			didStray ifTrue: [aCostume makeFenceSound]]].	"use and record the fractional position"	p _ aCostume referencePosition asFloatPoint.	fractionalP _ aCostume actorState fractionalPosition.	(fractionalP == nil or: [(fractionalP - p) abs >= (1@1)])		ifTrue: [newP _ p + delta]		ifFalse: [newP _ p + (fractionalP - p) + delta].	aCostume actorState fractionalPosition: newP.	aCostume referencePosition: newP rounded.! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!goToRightOf: aPlayer	| hisCostume aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(hisCostume _ aPlayer costume) isInWorld ifFalse: [^ self].	((aCostume _ self costume) owner == hisCostume owner) ifFalse:		[hisCostume owner addMorphFront: aCostume].	aCostume position:		(hisCostume bounds rightCenter - (0 @ (aCostume height // 2)))! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!hide	self costume hide! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!initiatePainting	(self costume isKindOf: PasteUpMorph) ifTrue:		[self costume makeNewDrawingWithin]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!moveToward: aPlayer	| angle aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	((aCostume _ self costume) bounds intersects: aPlayer costume bounds) ifTrue: [^ self].	angle _ aCostume referencePosition bearingToPoint: aPlayer costume referencePosition.	self setHeading: angle.	self forward: self getSpeed! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!show	self costume show! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/18/1998 11:52'!standardCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>" 	self costume isWorldOrHandMorph ifTrue:		[^ #((command beep: sound)			(command stopScript: string)			(command pauseScript: string)			(command startScript: string)			(command initiatePainting))].	(aBank = 1) ifTrue:		[^ #((command forward: number)			(command turn: number)			(command wearCostumeOf: player)			(command moveToward: player)			(command beep: sound))].	(aBank = 2) ifTrue:		[^ #((command show)			(command hide)			(command bounce: sound)			(command wrap)			(command goToRightOf: player)		"	(command stopProgramatically)  "			(command stopScript: string)			(command pauseScript: string)			(command startScript: string))].	(aBank == 3 and: [self costume isKindOf: PasteUpMorph]) ifTrue:		[^ #((command liftAllPens)			(command lowerAllPens)			(command clearTurtleTrails)			(command goToNextCard)			(command goToPreviousCard)			(command newCard)			(command deleteCard)			(command initiatePainting))].	^ #()! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:13'!wrap	self costume wrap! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!actorState	^ self costume actorState! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:44'!checkCostume	| found |	costumes ifNotNil:		[found _ costumes detect: [:c | c isInWorld] ifNone: [nil].		(found ~~ nil and: [found ~~ costume renderedMorph]) ifTrue:			[self halt: 'wrong costume'.			costume _ found]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!color: myColor sees: externalColor	^ self costume color: myColor sees: externalColor! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!grabPlayerIn: aWorld	aWorld primaryHand attachMorph: self costume		! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!lastEvent	"A convenience for user scripts written in Squeak to call"	^ self costume primaryHand lastEvent! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:12'!makeBounceSound: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName].! !!Player methodsFor: 'misc' stamp: 'sw 8/18/1998 11:54'!owningPlayer	"Answer the player who wears my costume's owner as its costume.  Speculative, not currently used"	| itsOwner |	self costume ifNotNil:		[(itsOwner _ self costume owner) ifNotNil:			[^ itsOwner player]].	^ nil! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!presenter	"Convenience for calling from user scripts"	^ self costume presenter! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:14'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: (' (', self asOop printString, ')').	self costume ifNil: [aStream nextPutAll: ' (with nil costume)'.  ^ self].	aStream nextPutAll: ' named ', self externalName! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!renderedCostumeRespondsTo: aSelector	^ self costume renderedMorph respondsTo: aSelector! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:20'!standardHolder	| aCostume |	aCostume _ self costume.	^ aCostume ifNotNil: [aCostume presenter ifNotNil: [aCostume presenter standardHolder]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:25'!tearOffTileForSelf	self costume world primaryHand attachMorph: self tileReferringToSelf! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:46'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld |	aWorld _ aMorph world.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu addLine.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent"	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player class methodsFor: 'other' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ name endsWithDigit not! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:35'!anonymousUserScriptFor: aSelector player: aPlayer	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializeAnonymousScriptFor: aPlayer.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:33'!userScriptForPlayer: aPlayer selector: aSelector	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	entry _ scripts at: aSelector ifAbsent: [nil].	entry ifNil:		[entry _ UserScript new player: aPlayer selector: aSelector.		scripts at: aSelector put: entry].	^ entry! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:25'!cleansePlayersWithDamagedScripts	"Track down all Players with damaged scripts and repair their script dictionaries.  Report how many were fixed."	"Player cleansePlayersWithDamagedScripts"	| aList |	aList _ self class allSubInstances select:		[:c | c scripts ~~ nil and: [c scripts includesKey: nil]].	aList do:		[:c | c scripts removeKey: nil].	^ aList size printString, ' uniclasses fixed up'! !!Player class methodsFor: 'housekeeping' stamp: 'jm 5/20/1998 20:54'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are housekeepingwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set and from Smalltalk. Only remove classes whose name begins with 'Player' and which have not references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| newSubclasses |	subclasses _ subclasses select: [:c |		((c name asString beginsWith: 'Player') and:		 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0])			ifTrue: [Smalltalk removeKey: c name ifAbsent: []. false]			ifFalse: [true]].	Smalltalk garbageCollect.	newSubclasses _ Set new.	Metaclass allInstancesDo: [:mClass |		c _ mClass soleInstance.		((c superclass = self) and:		 [(c name beginsWith: 'AnObsolete') not]) ifTrue: [			newSubclasses add: c.			Smalltalk at: c name put: c]].	subclasses _ newSubclasses.	SystemOrganization removeMissingClasses.! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:06'!playersWithDamagedScripts	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithDamagedScripts"	^ self allSubInstances select:		[:p | p class scripts ~~ nil and: [p class scripts includesKey: nil]]! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/17/1998 08:00'!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self class allSubInstances select:		[:p | p scripts size == 0 and: [p instSize size == 0]] ! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/11/1998 13:23'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval _ candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystemUnlogged].	^ Smalltalk garbageCollect - oldFree! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 8/22/1998 21:36'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters my bounds'		'mouseLeave -- when mouse exits my bounds'		'opening -- when I am being opened'		'closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 8  "9")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!UserScript methodsFor: 'script editor' stamp: 'sw 8/21/1998 16:35'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue: ["path thought not to be reached now"								^ player costume pasteUpMorph scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ ScriptEditorMorph  new			setMorph: player costume			scriptName: selector.		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !Morph removeSelector: #usableDuplicate!PartsViewer initialize!Player removeSelector: #costumeNamed:!Player removeSelector: #costumeDictionary!Player removeSelector: #availableCostumeNamesForArrows!Player removeSelector: #instantiatedCostumeNames!Player removeSelector: #costumeAt:ifAbsent:!Player removeSelector: #owner!Player class removeSelector: #costumesDo:!Player class removeSelector: #costumeAt:ifAbsent:!Player class removeSelector: #costumeDictionary!