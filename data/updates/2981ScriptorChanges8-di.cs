'From Squeak2.9alpha of 12 June 2000 [latest update: #3022] on 17 November 2000 at 9:55:56 am'!"Change Set:		ScriptorChanges8Date:			16 November 2000Author:			Dan IngallsPrevents selecting entire method, so can't get stuck with it that way.Makes temp var spacers transparent.Makes method selector unselect properly.ParseNode for method selector is no longer the methodNode.Introduces a framework for popup literal editors.Yet to do....Make del delete current highlight or selection.Make drop replace current selection if any.Register dropped morph as selected.Keep replacee as a property for undo until deselected."!!Debugger methodsFor: 'code pane' stamp: 'di 11/16/2000 16:03'!createSyntaxMorph	| methodNode rootMorph |	methodNode _ self selectedClass compilerClass new			parse: contents			in: self selectedClass			notifying: nil.	(rootMorph _ methodNode asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: self selectedClass;		debugger: self.	self addDependent: rootMorph.	^rootMorph! !!MethodNode methodsFor: 'tiles' stamp: 'di 11/16/2000 23:35'!asMorphicSyntaxIn: morph	| header tempMorph selNode |	selNode _ selectorOrFalse class == SelectorNode 		ifTrue: [selectorOrFalse] 		ifFalse: [SelectorNode new key: selectorOrFalse code: nil].	header _ morph addRow: Color white on: selNode.	precedence = 1		ifTrue: [header addToken: self selector type: #keyword1 on: selNode]		ifFalse: [self selector keywords with: arguments do:					[:kwd :arg | 					header addToken: kwd type: #keyword2 on: selNode.					(arg asMorphicSyntaxIn: header) color: #blockarg2]].	self addCommentToMorph: morph.	temporaries size > 0 ifTrue: [		tempMorph _ morph addRow: #tempVariable on: (MethodTempsNode new).		temporaries do: [:temp | temp asMorphicSyntaxIn: tempMorph ]				separatedBy: [tempMorph addMorphBack: (tempMorph transparentSpacerOfSize: 4@4)]].	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue:		["Dont decompile <prim> for, eg, ^ self "		morph addTextRow: (String streamContents: [ :strm | self printPrimitiveOn: strm])].	block asMorphicSyntaxIn: morph.	^ morph! !!SyntaxMorph methodsFor: 'accessing' stamp: 'di 11/17/2000 08:45'!actualObject	"Who is self in these tiles?  A Player"	^ self valueOfProperty: #whoIsSelf! !!SyntaxMorph methodsFor: 'accessing' stamp: 'di 11/17/2000 08:07'!parsedInClass	^ self rootTile parseNode encoder classEncoding! !!SyntaxMorph methodsFor: 'node types' stamp: 'di 11/17/2000 08:31'!isBlockNode	^ parseNode class == BlockNode! !!SyntaxMorph methodsFor: 'node types' stamp: 'di 11/17/2000 08:31'!isMethodNode	^ parseNode class == MethodNode! !!SyntaxMorph methodsFor: 'node types' stamp: 'di 11/17/2000 08:55'!rootTile	^ self orOwnerSuchThat:		[:m | m owner == nil or: [m owner isSyntaxMorph not]]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:21'!handlesMouseDown: evt	evt yellowButtonPressed ifTrue: [^ true].	parseNode == nil ifTrue: [^ false].	owner isSyntaxMorph ifTrue:		[(owner isMethodNode and: [self isBlockNode not])			ifTrue: [^ false]].	"Can only take block out of a MethodNode"	^ true! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:21'!keyStroke: evt	"Handle a keystroke event."	| spacer |	evt keyCharacter = Character backspace ifTrue:		[(owner notNil and: [owner isSyntaxMorph]) ifTrue:			[owner isBlockNode ifTrue:				["Delete a statement."				(spacer _ self submorphAfter) class == AlignmentMorph						ifTrue: [spacer delete].				self delete].			]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:12'!mouseDown: evt 	| dup rootTile |	evt yellowButtonPressed ifTrue: [^ self showMenu: evt].	(rootTile _ self rootTile) isMethodNode ifTrue:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == outerMorph or: [self hasOwner: outerMorph]])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"Out in the world -- treat as a unit"	rootTile isPartsDonor 		ifTrue: [dup _ rootTile duplicate.				dup setProperty: #beScript toValue: true]		ifFalse: [dup _ rootTile].	evt hand attachMorph: dup.	^ dup align: dup topLeft with: evt hand position + self cursorBaseOffset.! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 09:06'!mouseEnter: evt	"Highlight this level as a potential grab target""Transcript cr; print: self; show: ' enter'."	self unhighlightOwner.	self highlightForGrab: evt.	evt hand newKeyboardFocus: self.	self offerPopUp.! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:22'!mouseEnterDragging: evt	"Highlight this level as a potential drop target""Transcript cr; print: self; show: ' enterDragging'."	self unhighlightOwner.	self highlightForDrop: evt.	self isBlockNode ifTrue:		[(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])			ifNotNilDo: [:m | "Suspend outer block."						m stopStepping; hideCaret].		self startStepping]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 09:34'!mouseLeave: evt	"Move grab highlight back out a level""Transcript cr; print: self; show: ' leave'."	self unhighlight.	self maybeDeletePopup: evt.	(owner ~~ nil and: [owner isSyntaxMorph])		ifTrue: [owner highlightForGrab: evt].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:22'!mouseLeaveDragging: evt"Transcript cr; print: self; show: ' leaveDragging'."	self isBlockNode ifTrue:		[self stopStepping; hideCaret.		(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])			ifNotNilDo: [:m | "Activate outer block."						m startStepping]].	"Move drop highlight back out a level"	self unhighlight.	(owner ~~ nil and: [owner isSyntaxMorph])		ifTrue: [owner highlightForDrop: evt].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:23'!mouseMove: evt	| dup selection |	owner isSyntaxMorph ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		(evt cursorPoint dist: mouseDownLoc) > 4 ifTrue:			["If drag 5 pixels, then tear off a copy of outer selection."			selection _ outerMorph ifNil: [self].			evt hand attachMorph: (dup _ selection duplicate).			dup align: dup topLeft with: evt hand position + self cursorBaseOffset.			self setSelection: nil.			(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])				ifNotNilDo: [:m | "Activate enclosing block."							m startStepping]]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:13'!mouseUp: evt	| newSel |	self rootTile isMethodNode ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		newSel _ outerMorph			ifNil: [self "first click"]			ifNotNil: [(outerMorph firstOwnerSuchThat:							[:m | m isSyntaxMorph and: [m isSelectable]]) ifNil: [self]].		newSel isMethodNode ifTrue: [^ self setSelection: nil].		self setSelection: {self. nil. newSel}]! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 11/17/2000 08:20'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m isBlockNode])			ifTrue: [m stopStepping; hideCaret]].	self isBlockNode & itNoun		ifTrue:			[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse:					["if already declared, start new line of code with it"					self addToBlock: aMorph event: evt]]			ifFalse:			[^ self addToBlock: aMorph event: evt]].	"If I am a BlockNode and it is a noun add it as a new line"	self isBlockNode ifTrue: [		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[((aMorph nodeClassIs: TempVariableNode)				or: [aMorph nodeClassIs: VariableNode])  ifFalse: [ ^ self]]]].	(old _ owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	old cleanupAfterItDroppedOnMe.	"now owned by no one"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 11/17/2000 08:03'!cleanupAfterItDroppedOnMe	"A tile just dropped into me.  Clean up"	self layoutChanged.	(self ownerThatIsA: ScriptEditorMorph) ifNotNil:		["Auto-accept on drop if in a scriptor"		self rootTile accept].! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'di 11/17/2000 08:26'!wantsDroppedMorph: aMorph event: evt	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks."	| meNoun itNoun |	(aMorph isKindOf: SyntaxMorph) ifFalse: [^ false].	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: MessageNode) ifFalse: [		(self nodeClassIs: aMorph parseNode class) ifTrue: [^ true]].	meNoun _ self isNoun.	itNoun _ aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ (self submorphs				detect: [:mm | ((mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode])]				ifNone: [nil]) isNil]].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'drawing' stamp: 'di 11/17/2000 08:20'!drawOn: aCanvas	super drawOn: aCanvas.	self isBlockNode ifTrue:		[owner isMethodNode		ifTrue:			[aCanvas fillRectangle: (self topLeft + (0@-1) extent: self width@1) color: Color brown]		ifFalse:			[aCanvas fillRectangle: (self topLeft + (1@1) extent: 2@(self height-2)) color: Color blue.			aCanvas fillRectangle: (self topLeft + (1@1) extent: 4@1) color: Color blue.			aCanvas fillRectangle: (self bottomLeft + (1@-1) extent: 4@1) color: Color blue].		]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/17/2000 08:10'!currentSelectionDo: blockForSelection	| rootTile |	(rootTile _ self rootTile) isMethodNode ifFalse:		 [^ blockForSelection value: nil value: nil value: nil].	rootTile valueOfProperty: #selectionSpec ifPresentDo:		[:selectionSpec | ^ blockForSelection							value: selectionSpec first							value: selectionSpec second							value: selectionSpec third].	^ blockForSelection value: nil value: nil value: nil! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/17/2000 08:11'!isSelectable	"Spacer morphs enclose other morphs with the same parseNode"	(self nodeClassIs: CascadeNode) ifTrue: [^ false].	(self nodeClassIs: SelectorNode) ifTrue: [^ false].	(self nodeClassIs: KeyWordNode) ifTrue: [^ false].	self isMethodNode ifTrue: [^ false].	^ true! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/17/2000 08:14'!setSelection: newSpec	"A selectionSpec is {Inner morph.  Where clicked.  Outer morph}.	First mouseDown starts a selection (with outerMorph == nil).	Dragging more than 4 pixels means to grab a copy of the current outer selection.		The current selection is the outerMorph, or the inner if it is nil.	Each mouseUp extends the selection to the next outer morph that is selectable.		Except if this is the first click."	| rootTile |	(rootTile _ self rootTile) valueOfProperty: #selectionSpec ifPresentDo:		[:oldSpec | oldSpec third ifNotNilDo: [:m | m deselect]].	(newSpec == nil or: [newSpec third == nil and: [self isMethodNode]])		ifTrue: [^ rootTile removeProperty: #selectionSpec].	"Select outer morph of the new selection"	newSpec third == nil		ifTrue: [self select  "first click down"]		ifFalse: [newSpec third select  "subsequent clicks"].	rootTile setProperty: #selectionSpec toValue: newSpec! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/17/2000 08:38'!addBlockArg: aMorph	"Add a temporary to a block or the method.  Return true if succeed"	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	"***NOTE: This method should be combined with addTempVar:"	| tempHolder tt var nn |	owner isMethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not inside the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph isSyntaxMorph 				ifTrue: [(tt nodeClassIs: BlockArgsNode) 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ aMorph parseNode key.	"name"	tempHolder ifNil: ["make whole row"		tempHolder _ self addRow: #blockarg1 on: (BlockArgsNode new).		self addMorphFront: tempHolder.		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		self cleanupAfterItDroppedOnMe.		^ true].	tempHolder submorphsDo:		[:m | "if present. caller adds the temp as a new line of code to be extended"		m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].			"If this variable is not present, add it"	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (StringMorph contents: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/17/2000 08:39'!addTempVar: aMorph 	"know we are a block inside a MethodNode" 	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	| tempHolder ii tt var nn |	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.						(tt isSyntaxMorph and: [tt nodeClassIs: MethodTempsNode])					 		ifTrue: [tt] ifFalse: [nil]]				ifTrue: [nil].	nn _ aMorph parseNode key.	"name"	tempHolder ifNil: [		tempHolder _ owner addRow: #tempVariable on: MethodTempsNode new.		owner addMorph: tempHolder inFrontOf: self.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	tempHolder submorphsDo:		[:m | m isSyntaxMorph and: [m parseNode key = nn ifTrue: [^ false]]].	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (StringMorph contents: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'printing' stamp: 'di 11/17/2000 08:16'!printOn: strm indent: level 	| lev nodeClass first |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $( ]].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	first _ true.	submorphs do: [:sub |		sub isSyntaxMorph ifTrue: [			nodeClass == CascadeNode & first not ifTrue: [				color = (SyntaxMorph translateColor: #cascade2) ifTrue: [strm nextPut: $;; space ]].			nodeClass == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not	& 				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not					ifTrue: [strm crtab: lev]				ifFalse: [self isMethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			first _ false].		sub class == StringMorph ifTrue: [strm nextPutAll: sub contents].		"return indent for ifTrue: ifFalse:"].	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $) ]].	nodeClass  == BlockNode ifTrue: [		owner isSyntaxMorph ifTrue: [			owner isMethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].	"erase last period"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 11/17/2000 09:44'!maybeDeletePopup: evt	"This message gets received when *either* I or my popup is exited.	Delete my popup if the cursor is *neither* in me nor in my popup."	self valueOfProperty: #myPopup ifPresentDo:		[:panel |		((self containsPoint: evt cursorPoint) or: [panel containsPoint: evt cursorPoint])			ifFalse: [panel delete. self removeProperty: #myPopup]]! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 11/17/2000 09:52'!offerPopUp	| panel |	(self nodeClassIs: LiteralNode) ifTrue:		[(self hasProperty: #myPopup) ifTrue: [^ self].  "already has one"		panel _ RectangleMorph new color: Color lightOrange; borderWidth: 1.		panel addMorph: (StringMorph contents: ' popup').		parseNode key isNumber ifTrue:			[panel addMorph:  "You get the idea..."				(PolygonMorph new on: #mouseDown send: #increment to: self)].		panel on: #mouseLeave send: #maybeDeletePopup: to: self.		panel align: panel topLeft with: self topRight.		self setProperty: #myPopup toValue: panel.		self rootTile owner addMorphFront: panel]! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/17/2000 08:10'!accept	"Turn my current state into the text of a method.  Compile it in my class."	| cls |	self isMethodNode ifFalse: [^ self rootTile accept  "always accept at the root"].	(cls _ self parsedInClass) ifNil: [^ self].	cls compile: self decompile notifying: nil.! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/17/2000 09:00'!showCode	"Turn my current state into the text of a method.  Put it in a window."	(Workspace new contents: self rootTile decompile) openLabel: self printString,' code'	! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/17/2000 08:49'!showMenu: evt	| menu |	menu _ MenuMorph new.	menu add: 'show code' target: self selector: #showCode.	menu add: 'try out' target: self selector: #try.	self rootTile isMethodNode ifTrue:		[menu addLine.		menu add: 'accept method' target: self selector: #accept].	menu popUpAt: evt hand position forHand: evt hand in: World.! !!SyntaxMorph methodsFor: 'debugging' stamp: 'di 11/17/2000 07:59'!debugger	^ self rootTile valueOfProperty: #debugger! !!SyntaxMorph methodsFor: 'debugging' stamp: 'di 11/17/2000 07:59'!debugger: x	self rootTile setProperty: #debugger toValue: x! !SyntaxMorph removeSelector: #root!!SyntaxMorph reorganize!('initialization' inAScrollPane openInWindow)('accessing' actualObject color: externalName getCurrentValue parseNode parseNode: parsedInClass parsedInClass: userScriptSelector userScriptSelector:)('node types' isBlockNode isMethodNode isNoun isSyntaxMorph nodeClassIs: rootTile)('event handling' cursorBaseOffset handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseEnterDragging:inCaret: mouseLeave: mouseLeaveDragging: mouseLeaveDragging:inCaret: mouseMove: mouseUp: step stepTime)('dropping/grabbing' acceptDroppingMorph:event: cleanupAfterItDroppedOnMe justDroppedInto:event: morphToDropInPasteUp: wantsDroppedMorph:event:)('drawing' drawOn:)('highlighting' borderColor: dropColor grabColor highlightForDrop: highlightForGrab: stdBorderColor unhighlight unhighlightOwner)('selection' currentSelectionDo: deselect isSelectable select setSelection:)('insertion caret' addCaretFront: hideCaret insertionIndexForCaret: removeCaret: showCaretAt: trackCaret)('layout' addBlockArg: addColumn:on: addRow:on: addTempVar: addTextRow: addToBlock:event: addToken:type:on: foldMessage foldMessageOneArg unfoldMessage)('printing' printOn: printOn:indent: structure)('pop ups' maybeDeletePopup: offerPopUp)('menus' accept decompile getMenuBlock showCode showMenu: try)('debugging' balloonText debugger debugger: hostContext update:)('tests' test testForNode:andDo: toDo)('copying' veryDeepCopyWith:)!