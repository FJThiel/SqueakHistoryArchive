'From Squeak2.9alpha of 17 July 2000 [latest update: #3132] on 6 December 2000 at 7:22:47 am'!"Change Set:		zoom2Date:			6 December 2000Author:			Bob Arning- more accurate placement of magnified images to reduce jitter when panning, tilting and zooming.- misceallaneous cleanup"!!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'RAA 12/5/2000 18:28'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| patchRect subCanvas pureRect biggerPatch biggerClip interForm |	self flag: #bob.		"added to Canvas in hopes it will work for Nebraska"	(aDisplayTransform isPureTranslation) ifTrue: [		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to aClipRect"	pureRect _ (aDisplayTransform globalBoundsToLocal: aClipRect).	patchRect _ pureRect rounded.	patchRect area = 0 ifTrue: [^self]. 	"oh, well!!"	biggerPatch _ patchRect expandBy: 1.	biggerClip _ (aDisplayTransform localBoundsToGlobal: biggerPatch) rounded.	"Render the submorphs visible in the clipping rectangle, as patchForm"	subCanvas _ FormCanvas extent: biggerPatch extent depth: self depth.	self isShadowDrawing ifTrue: [		subCanvas shadowColor: self shadowColor	].	"this biggerPatch/biggerClip is an attempt to improve positioning of the final image in high magnification conditions. Since we cannot grab fractional pixels from the source, take one extra and then take just the part we need from the expanded form"	subCanvas 		translateBy: biggerPatch topLeft negated rounded		during: [ :offsetCanvas | aBlock value: offsetCanvas].	interForm _ Form extent: biggerClip extent depth: self depth.	subCanvas form 		displayInterpolatedIn: interForm boundingBox		on: interForm.	self 		drawImage: interForm 		at: aClipRect origin 		sourceRect: (aClipRect origin - biggerClip origin extent: aClipRect extent)! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:27'!drawSubmorphsOn: aCanvas	| r1 fullG r2 actualCanvas newClip where deferredMorphs |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	useRegularWarpBlt == true ifTrue: [		^aCanvas 			transformBy: transform			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) rounded			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	r1 _ self innerBounds intersect: aCanvas clipRect.	r1 area = 0 ifTrue: [^self].	fullG _ (transform localBoundsToGlobal: self firstSubmorph fullBounds) rounded.	r2 _ r1 intersect: fullG.	r2 area = 0 ifTrue: [^self].	newClip _ (r2 expandBy: 1) rounded intersect: self innerBounds rounded.	deferredMorphs _ #().	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: newClip		during: [:myCanvas |			self scale > 1.0 ifTrue: [				actualCanvas _ myCanvas as: MultiResolutionCanvas.				actualCanvas deferredMorphs: (deferredMorphs _ OrderedCollection new).			] ifFalse: [				actualCanvas _ myCanvas.			].			submorphs reverseDo:[:m | actualCanvas fullDrawMorph: m].		]		smoothing: smoothing.	deferredMorphs do: [ :each |		where _ each bounds: each fullBounds in: self.		each drawHighResolutionOn: aCanvas in: where.	].! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!changeOffsetBy: aPoint	| transform rounder roundPt |	"improve behavior at high magnification by rounding change to whole source pixels"	transform _ self myTransformMorph.	rounder _ [ :val |		(val abs + (transform scale * 0.99) roundTo: transform scale) * val sign	].	roundPt _ (rounder value: aPoint x) @ (rounder value: aPoint y).	self changeOffsetTo: transform offset + roundPt.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!changeOffsetTo: aPoint	| transform trialOffset innerPasteup keepWidth keepHeight |	transform _ self myTransformMorph.	keepWidth _ transform width "// 4".	keepHeight _ transform height "// 4".	innerPasteup _ transform firstSubmorph.	trialOffset _ aPoint.	trialOffset _ 		(trialOffset x 			min: (innerPasteup width * transform scale) - keepWidth 			max: keepWidth - transform width) @ 		(trialOffset y 			min: (innerPasteup height * transform scale) - keepHeight 			max: keepHeight - transform height).	transform offset: trialOffset.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!changeScaleTo: aNumber	| transform innerPasteup min1 min2 newScale oldPoint |	transform _ self myTransformMorph.	"oldScale _ transform scale."	innerPasteup _ transform firstSubmorph.	min1 _ transform width / innerPasteup width asFloat.	min2 _ transform height / innerPasteup height asFloat.	newScale _ (aNumber max: min1) max: min2.	oldPoint _ self cameraPoint.	transform scale: newScale.	self cameraPoint: oldPoint.	"scaleR _ newScale / oldScale.	half _ transform extent // 2.	half _ 0@0.	self changeOffsetBy: scaleR * (transform offset + half) - half - transform offset.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!extent: extentPoint	super extent: extentPoint.	self myTransformMorph bounds: self innerBounds.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!scaleImageBy: pixels	| scalePerPixel steps transform factor |	transform _ self myTransformMorph.	(steps _ (pixels * self getZoomFactor * 0.2) rounded) = 0 ifTrue: [^self].	scalePerPixel _ 1.01.	factor _ scalePerPixel raisedTo: steps abs.	steps > 0 ifTrue: [		factor _ 1.0 / factor.	].	self changeScaleTo: (transform scale * factor min: 10.0 max: 0.1).! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!step	| innerPasteUp overlap |	innerPasteUp _ self myTransformMorph firstSubmorph.	overlap _ (innerPasteUp submorphs 		inject: 0@0 		into: [ :min :each | min min: each position]) rounded.	overlap = (0@0) ifFalse: [		innerPasteUp submorphs do: [ :each | each position: each position - overlap].		innerPasteUp layoutChanged.	].! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:30'!cameraPoint	^(self myTransformMorph transform globalPointToLocal: self innerBounds center) rounded! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:31'!cameraPoint: newPt	| transform |	transform _ self myTransformMorph.	self changeOffsetTo: newPt * transform scale - (transform innerBounds extent // 2) ! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:30'!myTransformMorph	^self firstSubmorph! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:33'!offsetX	^self myTransformMorph offset x! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:31'!offsetX: aNumber	| transform |	transform _ self myTransformMorph.	transform offset: aNumber @ transform offset y! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:33'!offsetY	^self myTransformMorph offset y! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:31'!offsetY: aNumber	| transform |	transform _ self myTransformMorph.	transform offset: transform offset x @ aNumber! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:33'!scale	^self myTransformMorph scale! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:33'!scale: aValue	self myTransformMorph scale: aValue.! !