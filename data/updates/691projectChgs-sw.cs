'From Squeak 2.3 of January 14, 1999 on 25 February 1999 at 4:44:40 pm'!"Change Set:		projecChgs-swDate:			24 February 1999Author:			Scott Wallace* Adds a next-project instance variable to Project,, making feasible the reversal of an immediate go-to-previous-project.  Used in jump-to-project menu where applicable.* Allow current project to be in the project-list menus.* In make-project-thumbnail menu, show the current project first.* In the make-project-link menu, show the items alphabetically.* In the jump-to-project menu, show the appropriate number of recent-history items, and without duplication.* Move facility for making new project link from the open... menu to the new morph.. menu."!Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail nextProject '	classVariableNames: 'CurrentProject NavList '	poolDictionaries: ''	category: 'Interface-Projects'!!HandMorph methodsFor: 'world menu' stamp: 'sw 2/15/1999 18:28'!newMorph	| menu subMenu catDict shortCat class |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'from a file...' target: self action: #readMorphFromAFile.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu add: 'make new drawing' target: self action: #newDrawingFromMenu.	menu add: 'make link to project...' target: self action: #projectThumbnail.	menu addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'sw 2/15/1999 18:30'!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 2/15/1999 18:04'!jumpToProject	(Project buildJumpToMenu: (MenuMorph new defaultTarget: Project; addTitle: 'Projects'))		popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 2/15/1999 17:52'!projectThumbnail	"Offer the user a menu of project names. Attach to the hand a thumbnail of the project the user selects."	| menu projName |	menu _ MVCMenuMorph entitled: 'Select Project'.	menu add: (Project current name, ' (current)') action: Project current name.	menu addLine.	Project allNames do: [:n | menu add: n action: n].	projName _ menu invokeAt: self position in: self world.	projName ifNotNil:		[self attachMorph:			(ProjectViewMorph on: (Project named: projName))]! !!Project methodsFor: 'accessing' stamp: 'sw 2/15/1999 12:12'!nextProject	^ nextProject! !!Project methodsFor: 'menu messages' stamp: 'sw 2/24/1999 12:07'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom priorProject |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag		ifTrue:			[nextProject _ CurrentProject]		ifFalse:			["record link to previous project unless we're returning via that link"			previousProject _ CurrentProject].	priorProject _ CurrentProject.	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: ["Only show zoom if there is room for the both displays plus a megabyte"			Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+1000000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				entering					ifTrue: [vanishingPoint _ Sensor cursorPoint]					ifFalse: [vanishingPoint _ self viewLocFor: priorProject].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0].				newDisplay _ nil "release space before starting the new world"].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'release' stamp: 'sw 2/15/1999 12:15'!deletingProject: aProject	"Clear my previousProject link if it points at the given Project, which is being deleted."	previousProject == aProject		ifTrue: [previousProject _ nil].	nextProject == aProject		ifTrue:	[nextProject _ nil]! !!Project class methodsFor: 'utilities' stamp: 'sw 2/25/1999 16:23'!addItem: item toMenu: menu selection: action project: aProject	| aColor |	aColor _ aProject world isMorph ifTrue: [Color red darker] ifFalse: [Color veryVeryDarkGray].	(menu isKindOf: MenuMorph)		ifTrue:			[menu add: item selector: #jumpToSelection: argument: action.			menu items last color: aColor]		ifFalse:			[menu add: item action: action]! !!Project class methodsFor: 'utilities' stamp: 'sw 2/22/1999 12:47'!advanceToNextProject	| nextProj |	(nextProj _ CurrentProject nextProject) ifNotNil:		 [nextProj enter: true]! !!Project class methodsFor: 'utilities' stamp: 'sw 2/15/1999 17:54'!allNames	^ (self allInstances collect: [:p | p name]) asSortedCollection: [:n1 :n2 | n1 asLowercase < n2 asLowercase]! !!Project class methodsFor: 'utilities' stamp: 'sw 2/22/1999 11:08'!allNamesAndProjects	^ (self allInstances asSortedCollection: [:p1 :p2 | p1 name asLowercase < p2 name asLowercase]) collect:		[:aProject | Array with: aProject name with: aProject]! !!Project class methodsFor: 'utilities' stamp: 'sw 2/22/1999 12:47'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, alphabetically"	| prev listed i next  |	listed _ OrderedCollection with: CurrentProject.	i _ 0.	prev _ CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:		[i _ i + 1.		listed add: prev.		self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: ('%back' , i printString) project: prev.				prev _ prev previousProject].	(((next _ CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self addItem: (next name, ' (forward 1)') toMenu: menu selection: next name project: next]. 	(i > 0 or: [next ~~ nil]) ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent project: CurrentProject parent.		menu addLine].	"Finally all the projects, in alphabetical order"	Project allNamesAndProjects do: [:aPair | self addItem: aPair first toMenu: menu selection: aPair first project: aPair last].	^ menu! !