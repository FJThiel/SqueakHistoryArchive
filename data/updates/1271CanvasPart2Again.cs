'From Squeak 2.4b of April 23, 1999 on 25 June 1999 at 5:52:14 pm'!"Change Set:		CanvasPart2-arDate:			22 June 1999Author:			Andreas RaabThis is the second part of the Canvas changes. It introduces two new canvases: a ColorPatchCanvas used to replace the #fullDrawOn:without:andStopThere: methods and a ShadowDrawingCanvas which can (and eventually will) replace the shadow drawing in FormCanvas. Right now, shadow drawing is still part of the FormCanvas itself (see it as an 'optimization' ;-) but we might get rid of it for a cleaner structure.Also, this change set reshapes class Canvas and FormCanvas by moving down the instance variables from Canvas"Smalltalk isMorphic ifTrue:[self inform:'NOTE: For this update to work correctly,I will close all open Transcripts.'.SystemWindow allInstancesDo:[:sysWindow|	(sysWindow world == World and:[sysWindow model class == TranscriptStream]) 		ifTrue:[sysWindow delete]].].!Object subclass: #Canvas	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Canvas subclass: #FormCanvas	instanceVariableNames: 'origin clipRect shadowDrawing form port shadowStipple '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!FormCanvas subclass: #ColorPatchCanvas	instanceVariableNames: 'stopMorph foundMorph doStop '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!Canvas subclass: #ShadowDrawingCanvas	instanceVariableNames: 'myCanvas shadowColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!Canvas commentStamp: '<historical>' prior: 0!A canvas is a two-dimensional medium on which morphs are drawn in a device-independent manner. Canvases keep track of the origin and clipping rectangle, as well as the underlying drawing medium (such as a window, pixmap, or postscript script).Subclasses must implement (at least) the following methods:	* Accessing:		#origin		#extent		#clipRect	* Drawing:		#fillOval:color:borderWidth:borderColor:		#frameAndFillRectangle:fillColor:borderWidth:borderColor:		#image:at:sourceRect:rule:		#stencil:at:sourceRect:color:		#line:to:width:color:		#paragraph:bounds:color:		#text:bounds:font:color:	* Support		#clipBy:during:		#translateBy:during:		#translateBy:clippingTo:during:		#transformBy:clippingTo:during:!!Canvas methodsFor: 'testing' stamp: 'ar 6/22/1999 19:03'!isShadowDrawing	^false! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/24/1999 18:37'!stencil: stencilForm at: aPoint color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self stencil: stencilForm		at: aPoint		sourceRect: stencilForm boundingBox		color: aColor! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/24/1999 18:37'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self subclassResponsibility! !!Canvas methodsFor: 'converting' stamp: 'ar 6/24/1999 17:46'!asShadowDrawingCanvas	^self asShadowDrawingCanvas: (Color black alpha: 0.5).! !!Canvas methodsFor: 'converting' stamp: 'ar 6/22/1999 18:59'!asShadowDrawingCanvas: aColor	^(ShadowDrawingCanvas on: self) shadowColor: aColor! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 6/24/1999 17:44'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	port colorMap: (Color maskingMap: stencilForm depth).	port stencil: stencilForm		at: aPoint + origin		sourceRect: sourceRect		fillColor: (self drawColor: aColor)		rule: (self drawRule: Form paint color: aColor)! !!FormCanvas methodsFor: 'converting' stamp: 'ar 6/24/1999 18:00'!asShadowDrawingCanvas: aColor	"Note: This is sort of an optimization here since since the logic is all there"	^self copy setShadowDrawing; stipple: aColor! !!ColorPatchCanvas commentStamp: '<historical>' prior: 0!I generate patches of Morphic worlds that views below certain Morphs. This facility is used for the end-user scripting system.!!ColorPatchCanvas methodsFor: 'initialize-release' stamp: 'ar 6/22/1999 16:18'!reset	"Initialize the receiver to act just as a FormCanvas"	super reset.	foundMorph _ false.	doStop _ false.	stopMorph _ nil.! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:15'!doStop	^doStop! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:15'!doStop: aBoolean	doStop _ aBoolean! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:15'!foundMorph	^foundMorph! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:38'!foundMorph: aBoolean	foundMorph _ aBoolean! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:14'!stopMorph	^stopMorph! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:14'!stopMorph: aMorph	stopMorph _ aMorph! !!ColorPatchCanvas methodsFor: 'drawing-general' stamp: 'ar 6/22/1999 16:14'!fullDrawMorph: aMorph	(foundMorph and:[doStop]) ifTrue:[^self]. "Found it and should stop"	aMorph == stopMorph ifTrue:[		"Never draw the stopMorph"		foundMorph _ true.		^self].	^super fullDrawMorph: aMorph.! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:34'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	| tempCanvas |	tempCanvas _ (self copyClipRect: aRectangle).	aBlock value: tempCanvas.	foundMorph _ tempCanvas foundMorph.! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:42'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock.	Note: This does *not* include the state in the receiver (e.g., foundMorph)."	| tempCanvas |	tempCanvas _ self copy.	aBlock value: tempCanvas.	foundMorph _ tempCanvas foundMorph.! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:37'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		subCanvas _ self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect.		aBlock value: subCanvas.		foundMorph _ subCanvas foundMorph.		^self	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal:					(self clipRect intersect: innerRect).	sourceQuad _ (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ ColorPatchCanvas extent: patchRect extent depth: self depth.		subCanvas stopMorph: stopMorph.		subCanvas foundMorph: foundMorph.		subCanvas doStop: doStop.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: self stipple].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		i = 2 ifTrue:[foundMorph _ subCanvas foundMorph].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:39'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	| tempCanvas |	tempCanvas _ self copyOffset: delta clipRect: aRectangle.	aBlock value: tempCanvas.	foundMorph _ tempCanvas foundMorph.! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:39'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	| tempCanvas |	tempCanvas _ self copyOffset: delta.	aBlock value: tempCanvas.	foundMorph _ tempCanvas foundMorph.! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:40'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	| tempCanvas |	tempCanvas _ self copyOrigin: newOrigin clipRect: aRectangle.	aBlock value: tempCanvas.	foundMorph _ tempCanvas foundMorph.! !!ColorPatchCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 16:18'!setForm: aForm	"Initialize the receiver to act just as a FormCanvas"	super setForm: aForm.	stopMorph _ nil.	doStop _ false.	foundMorph _ false.! !!GrafPort methodsFor: 'as yet unclassified' stamp: 'ar 6/24/1999 17:45'!stencil: stencilForm at: aPoint sourceRect: aRect fillColor: aColor rule: rule	"Paint using aColor wherever stencilForm has non-zero pixels, and using the given combination rule"	self sourceForm: stencilForm;		fillColor: aColor;		combinationRule: rule;		destOrigin: aPoint;		sourceRect: aRect.	self copyBits! !!Morph methodsFor: 'drawing' stamp: 'ar 6/22/1999 16:32'!imageFormWithout: stopMorph andStopThere: stopThere	"Like imageForm, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns a pair of the imageForm and a boolean that is true		if it has hit stopMorph, and display should stop."	| canvas rect |	rect _ self fullBounds.	canvas _ ColorPatchCanvas extent: rect extent depth: Display depth.	canvas stopMorph: stopMorph.	canvas doStop: stopThere.	canvas translateBy: rect topLeft negated during:[:tempCanvas| self fullDrawOn: tempCanvas].	^ Array with: (canvas form offset: rect topLeft)			with: canvas foundMorph! !!Morph methodsFor: 'drawing' stamp: 'ar 6/22/1999 19:01'!shadowForm	| canvas |	canvas _ (FormCanvas extent: bounds extent depth: 1)				asShadowDrawingCanvas: Color black.	canvas translateBy: bounds topLeft negated		during:[:tempCanvas| self fullDrawOn: tempCanvas].	^ canvas form offset: bounds topLeft! !!DropShadowMorph methodsFor: 'drawing' stamp: 'ar 6/22/1999 19:02'!drawOn: aCanvas	"Draw my submorphs as a shadow, then fullDrawOn will droaw them normally."	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	(aCanvas asShadowDrawingCanvas: self color) 		translateBy: shadowOffset during:[:shadowCanvas|		self drawSubmorphsOn: shadowCanvas].! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/24/1999 17:55'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvasDepth: aCanvas depth.	(cacheCanvas == nil or: [aCanvas depth = 1]) ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles == true "bulletproofing against nil value, which can happen"			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas image: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: subBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/24/1999 17:54'!nonCachingFullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	| shadowForm |	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		shadowForm _ self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."		shadowCanvas image: shadowForm at: shadowForm offset.  "draw shadows"	].	"draw morphs in front of shadows"	self drawSubmorphsOn: aCanvas.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/22/1999 19:01'!shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m bounds]).	canvas _ (FormCanvas extent: bnds extent depth: 1) 				asShadowDrawingCanvas: Color black.	canvas translateBy: bnds topLeft negated		during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].	^ canvas form offset: bnds topLeft! !!HandMorph methodsFor: 'private' stamp: 'ar 6/24/1999 18:15'!releaseCachedState	super releaseCachedState.	cacheCanvas _ nil.! !!PasteUpMorph methodsFor: 'project' stamp: 'ar 6/22/1999 16:31'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c _ ColorPatchCanvas extent: patchRect extent depth: Display depth.	c stopMorph: stopMorph.	c doStop: stopThere.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	self drawSubmorphsOn: c.	self hands reverseDo: [:h | h drawSubmorphsOn: c].	^c form! !!ShadowDrawingCanvas methodsFor: 'initialization' stamp: 'ar 6/22/1999 18:24'!flush	myCanvas flush.! !!ShadowDrawingCanvas methodsFor: 'initialization' stamp: 'ar 6/22/1999 17:38'!on: aCanvas	myCanvas _ aCanvas.	shadowColor _ Color black.! !!ShadowDrawingCanvas methodsFor: 'initialization' stamp: 'ar 6/22/1999 18:23'!reset	myCanvas reset.! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 17:40'!clipRect	^myCanvas clipRect! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 17:39'!depth	^myCanvas depth! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 17:39'!extent	^myCanvas extent! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/24/1999 17:54'!form	^myCanvas form! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 17:39'!origin	^myCanvas origin! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 17:38'!shadowColor	^shadowColor! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 17:39'!shadowColor: aColor	shadowColor _ aColor! !!ShadowDrawingCanvas methodsFor: 'testing' stamp: 'ar 6/22/1999 19:03'!isShadowDrawing	"Always"	^true! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/22/1999 17:59'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Fill the given oval."	myCanvas		fillOval: r		color: (self mapColor: c)		borderWidth: borderWidth		borderColor: (self mapColor: borderColor)! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/22/1999 17:59'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	myCanvas		frameAndFillRectangle: r		fillColor: (self mapColor: fillColor)		borderWidth: borderWidth		borderColor: (self mapColor: borderColor)! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/22/1999 18:01'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw the rectangle using the given attributes"	myCanvas		frameAndFillRectangle: r 		fillColor: (self mapColor: fillColor) 		borderWidth: borderWidth 		topLeftColor: (self mapColor: topLeftColor)		bottomRightColor: (self mapColor: bottomRightColor)! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/24/1999 18:39'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the given form. For the 'paint' combination rule use stenciling otherwise simply fill the source rectangle."	rule = Form paint ifTrue:[		^myCanvas			stencil: aForm			at: aPoint			sourceRect: sourceRect			color: shadowColor	] ifFalse:[		^myCanvas			fillRectangle: (sourceRect translateBy: aPoint)			color: shadowColor	].! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/22/1999 18:15'!line: pt1 to: pt2 width: w color: c	"Draw a line using the given width and color"	myCanvas		line: pt1		to: pt2		width: w		color: (self mapColor: c).! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/22/1999 18:16'!paragraph: paragraph bounds: bounds color: c	"Draw the given paragraph"	myCanvas		paragraph: paragraph		bounds: bounds		color: (self mapColor: c)! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/24/1999 18:26'!stencil: aForm at: aPoint color: aColor	myCanvas		stencil: aForm		at: aPoint		color: (self mapColor: aColor)! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/24/1999 18:26'!stencil: aForm at: aPoint sourceRect: aRect color: aColor	myCanvas		stencil: aForm		at: aPoint		sourceRect: aRect		color: (self mapColor: aColor)! !!ShadowDrawingCanvas methodsFor: 'drawing' stamp: 'ar 6/22/1999 18:16'!text: s bounds: boundsRect font: fontOrNil color: c	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used."	myCanvas		text: s		bounds: boundsRect		font: fontOrNil		color: (self mapColor: c)! !!ShadowDrawingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:19'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	| oldCanvas |	oldCanvas _ myCanvas.	myCanvas clipBy: aRectangle during:[:newCanvas|		myCanvas _ newCanvas.		aBlock value: self].	myCanvas _ oldCanvas! !!ShadowDrawingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:19'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock"	| oldCanvas |	oldCanvas _ myCanvas.	myCanvas preserveStateDuring:[:newCanvas|		myCanvas _ newCanvas.		aBlock value: self].	myCanvas _ oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:20'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	"Transform the receiver by the given display transformation during the execution of aBlock. The given clip rectangle defines the *global* (e.g., outer) rectangle against which the receiver should clip (which would be equivalent to 'self clipRect: aClipRect; transformBy: aDisplayTransform')."	| oldCanvas |	oldCanvas _ myCanvas.	myCanvas transformBy: aDisplayTransform clippingTo: aClipRect during:[:newCanvas|		myCanvas _ newCanvas.		aBlock value: self].	myCanvas _ oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:21'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	| oldCanvas |	oldCanvas _ myCanvas.	myCanvas translateBy: delta clippingTo: aRectangle during:[:newCanvas|		myCanvas _ newCanvas.		aBlock value: self].	myCanvas _ oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:22'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	| oldCanvas |	oldCanvas _ myCanvas.	myCanvas translateBy: delta during:[:newCanvas|		myCanvas _ newCanvas.		aBlock value: self].	myCanvas _ oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:22'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	| oldCanvas |	oldCanvas _ myCanvas.	myCanvas translateTo: newOrigin clippingTo: aRectangle during:[:newCanvas|		myCanvas _ newCanvas.		aBlock value: self].	myCanvas _ oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 18:36'!mapColor: aColor	aColor isColor ifFalse:[^aColor]. "Should not happen but who knows..."	^aColor isTransparent		ifTrue:[aColor]		ifFalse:[shadowColor]! !!ShadowDrawingCanvas class methodsFor: 'instance creation' stamp: 'ar 6/22/1999 18:23'!on: aCanvas	^self new on: aCanvas! !Morph removeSelector: #fullDrawOn:without:andStopThere:!TransformMorph removeSelector: #fullDrawOn:without:andStopThere:!"Postscript:Cleanup all old Canvases (which may have nil in some slots) and also Undeclared"MorphicProject allSubInstancesDo:[:prj| prj canvas: nil].CachingMorph allSubInstancesDo:[:m| m releaseCachedState].HandMorph allSubInstancesDo:[:m| m releaseCachedState].Undeclared removeUnreferencedKeys.!