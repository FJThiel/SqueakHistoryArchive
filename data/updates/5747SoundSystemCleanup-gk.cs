'From Squeak3.7alpha of 11 September 2003 [latest update: #5707] on 26 February 2004 at 10:04:56 am'!"Change Set:		SoundSystemsExtra-gkDate:			23 February 2004Author:			Adam Spitz, Gšran KrampeThis is the first changeset intended for the update stream that comes out of Adam's monster work Cleanup.sar. I am working through it alphabetically.This update is comprised of Adam's first two changesets:- AAAMultipleSoundSystems.3.cs- DSASoundCleanup.1.cs...rewritten quite a lot:- Renamed SoundSystem to SoundService- Renamed BadSoundSystem to DummySoundSystem.- Renamed GoodSoundSystem to BaseSoundSystem.- Move DummySoundSystem and AbstractSoundSystem to System-Support- Kept references to the recently introduced Beeper as is, Beeper is now integrated on top of SoundService.- Tweaked Beeper with simplifications and more comments etc.- Moved  general checks of Preferences soundsEnabled into Dummy/BaseSoundSystem, seems smart!!- Added a playSoundNamedOrBeep: method- Added a base class AbstractSoundSystem- Added class comments for all new classes.- Threw in the DSASoundCleanup into this changeset since it also has to do with sound, preamble below.- Plus probably a bunch more little things.Lets get this one in because cleaning code rot isn't fun. :)/GšranHere follows original preambles:Preamble from AAAMultipleSoundSystems::There are lots of places in the image that play sounds but shouldn't really depend on the sound system; if sound support isn't present, they should still be able to do their jobs (just a little more quietly :). This changeset adds a class called SoundSystem, so that we can say things like:SoundSystem default playSoundNamed: 'croak'.Preamble from AAAMultipleSoundSystems::The DigitalSignatureAlgorithm class uses the sound system for some sort of randomness-generating thingy. This changeset is a half-assed attempt to remove this dependency, so that we can eventually create images without sound support."!Object subclass: #AbstractSoundSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!AbstractSoundSystem commentStamp: 'gk 2/24/2004 08:34' prior: 0!This is the abstract base class for a sound system. A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in the application registry SoundService and can be accessed by "SoundService default" like for example:SoundService default playSoundNamed: 'croak'The idea is that as much sound playing as possible should go through this facade. This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.Two basic subclasses exist at the time of this writing, the BaseSoundSystem which represents the standard Squeak sound system, and the DummySoundSystem which is a dummy implementation that can be used when there is no sound card available, or when the base sound system isn't in the image, or when you simply don't want to use the available sound card.!AbstractSoundSystem subclass: #BaseSoundSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!BaseSoundSystem commentStamp: 'gk 2/24/2004 08:35' prior: 0!This is the normal sound system in Squeak and is registered in SoundService - an AppRegistry - so that a small highlevel protocol for playing sounds can be used in a pluggable fashion.More information available in superclass.!!Beeper commentStamp: 'gk 2/26/2004 22:44' prior: 0!Beeper provides simple audio (or in some other way) feedback to the user.The recommended use is "Beeper beep" to give the user the equivalence of a beep. If you want to force the beep to use the primitive in the VM for beeping, then use "Beeper beepPrimitive". In either case, if sounds are disabled there will be no beep.The actual beeping, when you use "Beeper beep", is done by sending a #play message to a registered playable object. You can register your own playable object by invoking the class side method #setDefault: passing in an object that responds to the #play message.The default playable object is an instance of Beeper itself which implements #play on the instance side. That implementation delegates the playing of the beep to the default SoundService.Note that #play is introduced as a common interface between AbstractSound and Beeper.This way we can register instances of AbstractSound as playable entities, for example:	Beeper setDefault: (SampledSound new						setSamples: self coffeeCupClink						samplingRate: 12000).Then "Beeper beep" will play the coffeeCup sound.!AbstractSoundSystem subclass: #DummySoundSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!DummySoundSystem commentStamp: 'gk 2/24/2004 23:14' prior: 0!This is a dummy sound system registered in SoundService to absorb all sound playing and to use the primitive beep instead of sampled sounds when playing a beep.!AppRegistry subclass: #SoundService	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Applications'!!SoundService commentStamp: 'gk 2/24/2004 23:14' prior: 0!This is the AppRegistry class for the sound system.A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in this registry and can be accessed by "SoundService default". This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.!!Object methodsFor: 'deprecated' stamp: 'gk 2/24/2004 08:50'!beepPrimitive	"Deprecated. Beep in the absence of sound support."		self deprecated: 'Use Beeper class>>beep or Beeper class>>beepPrimitive instead.'.	Beeper beepPrimitive! !!Object methodsFor: 'macpal' stamp: 'gk 2/23/2004 20:51'!playSoundNamed: soundName	"Deprecated.	Play the sound with the given name."	self deprecated: 'Use "SoundService default playSoundNamed: aName" instead.'.	SoundService default playSoundNamed: soundName! !!Object methodsFor: 'user interface' stamp: 'gk 2/24/2004 08:49'!beep	"Deprecated."		self deprecated: 'Use Beeper class>>beep instead.'.	Beeper beep! !!AbstractSound methodsFor: 'playing' stamp: 'gk 2/24/2004 22:23'!play	"Play this sound to the sound output port in real time."	SoundPlayer playSound: self.! !!AbstractSoundSystem methodsFor: 'playing' stamp: 'gk 2/24/2004 23:27'!beep	"Make a primitive beep."	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:47'!playSampledSound: samples rate: rate	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:50'!playSoundNamed: soundName	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:51'!playSoundNamed: soundName ifAbsentReadFrom: aifFileName	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:51'!playSoundNamedOrBeep: soundName	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:52'!randomBitsFromSoundInput: bitCount	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:52'!sampledSoundChoices	self subclassResponsibility! !!AbstractSoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:53'!shutDown	"Default is to do nothing."! !!AbstractSoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:56'!soundNamed: soundName	self subclassResponsibility! !!BaseSoundSystem methodsFor: 'misc' stamp: 'gk 2/24/2004 23:13'!randomBitsFromSoundInput: bitCount
	"Answer a positive integer with the given number of random bits of 'noise' from a sound input source. Typically, one would use a microphone or line input as the sound source, although many sound cards have enough thermal noise that you get random low-order sample bits even with no microphone connected. Only the least signficant bit of the samples is used. Since not all sound cards support 16-bits of sample resolution, we use the lowest bit that changes."
	"(1 to: 10) collect: [:i | BaseSoundSystem new randomBitsFromSoundInput: 512]"

	| recorder buf mid samples bitMask randomBits bit |
	"collect some sound data"
	recorder _ SoundRecorder new clearRecordedSound.
	recorder resumeRecording.
	(Delay forSeconds: 1) wait.
	recorder stopRecording.
	buf _ recorder condensedSamples.

	"grab bitCount samples from the middle"
	mid _ buf monoSampleCount // 2.
	samples _ buf copyFrom: mid to: mid + bitCount - 1.

	"find the least significant bit that varies"
	bitMask _ 1.
	[bitMask < 16r10000 and:
	 [(samples collect: [:s | s bitAnd: bitMask]) asSet size < 2]]
		whileTrue: [bitMask _ bitMask bitShift: 1].
	bitMask = 16r10000 ifTrue: [^ self error: 'sound samples do not vary'].

	"pack the random bits into a positive integer"
	randomBits _ 0.
	1 to: samples size do: [:i |
		bit _ ((samples at: i) bitAnd: bitMask) = 0 ifTrue: [0] ifFalse: [1].
		randomBits _ (randomBits bitShift: 1) + bit].

	^ randomBits	
! !!BaseSoundSystem methodsFor: 'misc' stamp: 'ads 7/30/2003 22:18'!sampledSoundChoices	^ SampledSound soundNames! !!BaseSoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:53'!shutDown	SoundPlayer shutDown! !!BaseSoundSystem methodsFor: 'misc' stamp: 'ads 7/30/2003 23:17'!soundNamed: soundName	^ SampledSound soundNamed: soundName! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:20'!beep	"There is sound support, so we use the default	sampled sound for a beep."	Preferences soundsEnabled ifTrue: [		SampledSound beep]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:20'!playSampledSound: samples rate: rate	Preferences soundsEnabled ifTrue: [		(SampledSound samples: samples samplingRate: rate) play]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:23'!playSoundNamed: soundName	"There is sound support, so we play the given sound."	Preferences soundsEnabled ifTrue: [		SampledSound playSoundNamed: soundName asString]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:22'!playSoundNamed: soundName ifAbsentReadFrom: aifFileName	Preferences soundsEnabled ifTrue: [		(SampledSound soundNames includes: soundName) ifFalse: [			(FileDirectory default fileExists: aifFileName) ifTrue: [				SampledSound					addLibrarySoundNamed: soundName					fromAIFFfileNamed: aifFileName]].		(SampledSound soundNames includes: soundName) ifTrue: [			SampledSound playSoundNamed: soundName]]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:23'!playSoundNamedOrBeep: soundName	"There is sound support, so we play the given sound	instead of beeping."	Preferences soundsEnabled ifTrue: [		^self playSoundNamed: soundName]! !!BaseSoundSystem class methodsFor: 'class initialization' stamp: 'gk 2/23/2004 21:08'!initialize	SoundService register: self new.! !!BaseSoundSystem class methodsFor: 'class initialization' stamp: 'gk 2/23/2004 21:08'!unload	SoundService registeredClasses do: [:ss |		(ss isKindOf: self) ifTrue: [SoundService unregister: ss]].! !!Beeper methodsFor: 'play interface' stamp: 'gk 2/24/2004 23:25'!play	"This is how the default Beeper makes a beep,	by sending beep to the default sound service.	The sound system will check if sounds are enabled."	SoundService default beep! !!Beeper class methodsFor: 'customize' stamp: 'gk 2/22/2004 17:51'!clearDefault	"Clear the default playable.	Will be lazily initialized in Beeper class >>default."	default := nil! !!Beeper class methodsFor: 'customize' stamp: 'gk 2/22/2004 17:55'!default	"When the default is not defined it is	initialized using #newDefault."	default isNil 		ifTrue: [default := self newDefault ].	^ default! !!Beeper class methodsFor: 'customize' stamp: 'gk 2/24/2004 22:12'!newDefault	"Subclasses may override me to provide a default beep.	This base implementation returns an instance of Beeper	which uses the pluggable sound service."	^ self new! !!Beeper class methodsFor: 'customize' stamp: 'gk 2/22/2004 17:54'!setDefault: aPlayableEntity	"Set the playable entity used when making a beep.	The playable entity should implement the message #play."	default := aPlayableEntity! !!Beeper class methodsFor: 'beeping' stamp: 'gk 2/24/2004 08:38'!beep	"The preferred way of producing an audible feedback.	The default playable entity (an instance of Beeper)	also uses the pluggable SoundService	mechanism, so it will use the primitive beep only	if there is no other sound mechanism available."	self default play! !!Beeper class methodsFor: 'beeping' stamp: 'gk 2/24/2004 08:38'!beepPrimitive	"Make a primitive beep. Only use this if	you want to force this to be a primitive beep.	Otherwise use Beeper class>>beep	since this method bypasses the current	registered playable entity."	Preferences soundsEnabled ifTrue: [		self primitiveBeep]! !!Beeper class methodsFor: 'private' stamp: 'gk 2/24/2004 23:51'!primitiveBeep	"Make a primitive beep. Not to be called directly.	It is much better to use Beeper class>>beep	or Beeper class>>beepPrimitive	since this method bypasses the current	registered playable entity and does not	check Preferences class>>soundsEnabled."	<primitive: 140>	self primitiveFailed! !!CodeLoader class methodsFor: 'utilities' stamp: 'ads 7/31/2003 14:00'!signFilesFrom: sourceNames to: destNames key: privateKey
	"Sign all the given files using the private key.
	This will add an 's' to the extension of the file."
	"| fd oldNames newNames |
	fd _ FileDirectory default directoryNamed:'unsigned'.
	oldNames _ fd fileNames.
	newNames _ oldNames collect:[:name| 'signed', FileDirectory slash, name].
	oldNames _ oldNames collect:[:name| 'unsigned', FileDirectory slash, name].
	CodeLoader
		signFilesFrom: oldNames
		to: newNames
		key: DOLPrivateKey."
	| dsa |
	dsa _ DigitalSignatureAlgorithm new.
	dsa initRandomNonInteractively.
	'Signing files...' displayProgressAt: Sensor cursorPoint
		from: 1 to: sourceNames size during:[:bar|
			1 to: sourceNames size do:[:i|
				bar value: i.
				self signFile: (sourceNames at: i) renameAs: (destNames at: i) key: privateKey dsa: dsa]].
! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'gk 2/26/2004 09:52'!initRandomNonInteractively
	[self initRandom: (SoundService default randomBitsFromSoundInput: 512)]
		ifError: [self initRandomFromString: 
			Time millisecondClockValue printString, 
			Date today printString, 
			SmalltalkImage current platformName printString].! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'ads 7/31/2003 14:01'!generateKeySet
	"Generate and answer a key set for code signing. The result is a pair (<private key><public key>). Each key is an array of four large integers. The signer must be sure to record this keys set and must keep the private key secret to prevent someone from forging their signature."
	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"
	"Note: Unguessable random numbers are needed for key generation. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before generating a key set. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."
	"DigitalSignatureAlgorithm generateKeySet"

	| dsa |
	dsa _ DigitalSignatureAlgorithm new.
	(self confirm: 'Shall I seed the random generator from the current sound input?')
		ifTrue: [dsa initRandomNonInteractively]
		ifFalse: [dsa initRandomFromUser].
	^ dsa generateKeySet
! !!DummySoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 20:48'!randomBitsFromSoundInput: bitCount
	"I'm not sure what the right thing to do here is."
	self error: 'Can not provide random data.'! !!DummySoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:54'!sampledSoundChoices	"No choices other than this."	^ #('silence')! !!DummySoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:55'!soundNamed: soundName	"There are no sounds to look up."	^ nil! !!DummySoundSystem methodsFor: 'playing' stamp: 'gk 2/24/2004 23:53'!beep	"Make a primitive beep."	Beeper beepPrimitive! !!DummySoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:53'!playSampledSound: samples rate: rate	"Do nothing."	! !!DummySoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:54'!playSoundNamed: soundName	"Do nothing."! !!DummySoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:54'!playSoundNamed: soundName ifAbsentReadFrom: aifFileName	"Do nothing."! !!DummySoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:18'!playSoundNamedOrBeep: soundName	"There is no sound support, so we make the beep."		^self beep! !!DummySoundSystem class methodsFor: 'class initialization' stamp: 'gk 2/23/2004 21:08'!initialize	SoundService register: self new.! !!DummySoundSystem class methodsFor: 'class initialization' stamp: 'gk 2/23/2004 21:08'!unload	SoundService registeredClasses do: [:ss |		(ss isKindOf: self) ifTrue: [SoundService unregister: ss]].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'gk 2/24/2004 23:53'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols.		endMarker _ segment nextObject. 	"for enumeration of objects"		endMarker == 0 ifTrue: [endMarker _ 'End' clone]].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	state _ #inactive.	Beeper beepPrimitive! !!InputSensor methodsFor: 'user interrupts' stamp: 'gk 2/23/2004 20:51'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Display deferUpdates: false.		SoundService default shutDown.		Smalltalk handleUserInterrupt]! !!Morph methodsFor: 'WiW support' stamp: 'gk 2/23/2004 21:08'!eToyRejectDropMorph: morphToDrop event: evt	| tm am |	tm _ TextMorph new 		beAllFont: ((TextStyle named: #ComicBold) fontOfSize: 24);		contents: 'GOT IT!!'.	(am _ AlignmentMorph new)		color: Color yellow;		layoutInset: 10;		useRoundedCorners;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		addMorph: tm;		fullBounds;		position: (self bounds center - (am extent // 2));		openInWorld: self world.	SoundService default playSoundNamed: 'yum' ifAbsentReadFrom: 'yum.aif'.	morphToDrop rejectDropMorphEvent: evt.		"send it back where it came from"	am delete! !!Morph methodsFor: 'player commands' stamp: 'gk 2/23/2004 21:08'!playSoundNamed: soundName	"Play the sound with the given name.	Does nothing if this image lacks sound playing facilities."	SoundService default playSoundNamed: soundName asString! !!BooklikeMorph methodsFor: 'misc' stamp: 'gk 2/24/2004 08:27'!playPageFlipSound: soundName	self presenter ifNil: [^ self].  "Avoid failures when called too early"	PageFlipSoundOn  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: soundName].! !!BookMorph methodsFor: 'menu' stamp: 'gk 2/23/2004 21:08'!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec _ self transitionSpecFor: target.	menu _ (MenuMorph entitled: 'Choose a sound(it is now ' , tSpec first , ')') defaultTarget: target.	SoundService default sampledSoundChoices do:		[:soundName |		menu add: soundName target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copy at: 1 put: soundName; yourself))].	menu popUpEvent: evt in: self world! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'gk 2/23/2004 21:07'!playArrivalSound	"Make a sound that something has arrived."	SoundService default playSoundNamedOrBeep: 'chirp'! !!GraphMorph methodsFor: 'commands' stamp: 'gk 2/23/2004 21:08'!playOnce	| scale absV scaledData |	data isEmpty ifTrue: [^ self].  "nothing to play"	scale _ 1.	data do: [:v | (absV _ v abs) > scale ifTrue: [scale _ absV]].	scale _ 32767.0 / scale.	scaledData _ SoundBuffer newMonoSampleCount: data size.	1 to: data size do: [:i | scaledData at: i put: (scale * (data at: i)) truncated].	SoundService default playSampledSound: scaledData rate: 11025.! !!Player methodsFor: 'misc' stamp: 'gk 2/23/2004 20:51'!beep: soundName	"Play given sound or at least beep."	SoundService default playSoundNamedOrBeep: soundName! !!Player methodsFor: 'scripts-standard' stamp: 'gk 2/23/2004 20:51'!loadSound: soundName	| snd |	snd _ SoundService default soundNamed: soundName.	snd ifNotNil: [self sendMessageToCostume: #loadSound: with: snd].! !!ProjectNavigationMorph methodsFor: '*sound' stamp: 'gk 2/24/2004 23:29'!soundUpEvt: a morph: b	soundSlider ifNotNil: [soundSlider delete].	soundSlider _ nil.	Beeper beep ! !!SampledSound class methodsFor: 'instance creation' stamp: 'gk 2/24/2004 08:50'!beep	"Beep in the presence of the sound system.	Not to be used directly - use Beeper class>>beep	or Beeper class>>beepPrimitive instead."	(self new			setSamples: self coffeeCupClink			samplingRate: 12000) play			! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'gk 2/23/2004 21:08'!arrowAction: delta	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| soundChoices index |	soundChoices _ SoundService default sampledSoundChoices.	index _ soundChoices indexOf: literal.	self literal: (soundChoices atWrap: (index + delta)).	self playSoundNamed: literal	! !!SoundReadoutTile methodsFor: 'literal' stamp: 'gk 2/23/2004 21:09'!setLiteralTo: anObject width: w	"Set the literal and width of the tile as indicated"	| soundChoices index |	soundChoices _ SoundService default sampledSoundChoices.	index _ soundChoices indexOf: anObject.	self setLiteral: (soundChoices atWrap: index)! !!SoundTile methodsFor: 'access' stamp: 'gk 2/23/2004 21:08'!sound	^ SoundService default soundNamed: literal! !!SoundTile methodsFor: 'event handling' stamp: 'gk 2/23/2004 21:08'!mouseDown: evt	| aPoint index isUp soundChoices adjustment |	upArrow ifNotNil: [((isUp _ upArrow containsPoint: (aPoint _ evt cursorPoint)) or:			[downArrow containsPoint: aPoint]) ifTrue: [		soundChoices _ SoundService default sampledSoundChoices.		index _ soundChoices indexOf: literal.		index > 0 ifTrue:			[adjustment _ isUp ifTrue: [1] ifFalse: [-1].			self literal: (soundChoices atWrap: (index + adjustment))].		self playSoundNamed: literal].		^ self].	super mouseStillDown: evt.! !!SoundTile methodsFor: 'initialization' stamp: 'gk 2/23/2004 21:08'!initialize	"Initialize the state of the receiver. Pick the croak sound	if available, otherwise any sound."		| soundChoices startingSoundName |	super initialize.	soundChoices _ SoundService default sampledSoundChoices.	startingSoundName _ (soundChoices includes: 'croak')							ifTrue: ['croak']							ifFalse: [[soundChoices anyOne] ifError: ['silence']].	self addArrows; setLiteral: startingSoundName.	self labelMorph useStringFormat! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'gk 2/23/2004 21:08'!changeSound: upDown	| ind arg st soundChoices index it current |	"move in the list of sounds.  Adjust arg tile after me"	ind _ owner submorphs indexOf: self.	arg _ owner submorphs atWrap: ind+1.	arg isSyntaxMorph ifFalse: [^ self].	st _ arg submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	soundChoices _ SoundService default sampledSoundChoices.	current _ st contents copyFrom: 2 to: st contents size-1.	"remove string quotes"	index _ soundChoices indexOf: current.	index > 0 ifTrue:		[st contents: (it _ soundChoices atWrap: index + upDown) printString.		self playSoundNamed: it].! !!SyntaxMorph methodsFor: 'type checking' stamp: 'gk 2/23/2004 21:08'!resultType	"Look up my result type.  If I am a constant, use that class.  If I am a message, look up the selector."	| list value |	parseNode class == BlockNode ifTrue: [^#blockContext].	parseNode class == AssignmentNode ifTrue: [^#command].	parseNode class == ReturnNode ifTrue: [^#command].	"Need more restriction than this"	list := submorphs 				select: [:ss | ss isSyntaxMorph and: [ss parseNode notNil]].	list size > 1 ifTrue: [^self resultTypeFor: self selector].	list size = 1 		ifTrue: 			["test for levels that are just for spacing in layout"			(list first isSyntaxMorph and: [list first nodeClassIs: MessageNode]) 				ifTrue: [^list first resultType]].	"go down one level"	value := self try.	value class == Error ifTrue: [^#unknown].	(value isNumber) ifTrue: [^#Number].	(value isKindOf: Boolean) ifTrue: [^#Boolean].	(value isForm) ifTrue: [^#Graphic].	value class == String 		ifTrue: [(SoundService default sampledSoundChoices includes: value) ifTrue: [^#Sound]].	(value isKindOf: Player) ifTrue: [^#Player].	^value class name asLowercase	"asSymbol (not needed)"! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'gk 2/23/2004 20:51'!shutDownSound	"No longer used in the release, but retained for backward compatibility."	SoundService default shutDown! !!TrashCanMorph class methodsFor: 'as yet unclassified' stamp: 'gk 2/23/2004 20:51'!playDeleteSound	"TrashCanMorph playDeleteSound"	SoundService default playSampledSound: self samplesForDelete rate: 22050! !!TrashCanMorph class methodsFor: 'as yet unclassified' stamp: 'gk 2/23/2004 20:51'!playMouseEnterSound	"TrashCanMorph playMouseEnterSound"	SoundService default playSampledSound: self samplesForMouseEnter rate: 22050! !!TrashCanMorph class methodsFor: 'as yet unclassified' stamp: 'gk 2/23/2004 20:51'!playMouseLeaveSound	"TrashCanMorph playMouseLeaveSound"	SoundService default playSampledSound: self samplesForMouseLeave rate: 22050! !!UUIDGenerator methodsFor: 'random seed' stamp: 'gk 2/23/2004 21:09'!makeSeedFromSound
	| answer |
	[answer := SoundService default randomBitsFromSoundInput: 32
	] ifError: [answer := nil].
	^answer! !DummySoundSystem initialize!!DummySoundSystem class reorganize!('class initialization' initialize unload)!DigitalSignatureAlgorithm removeSelector: #randomBitsFromSoundInput:!Beeper class removeSelector: #play!!Beeper class reorganize!('customize' clearDefault default newDefault setDefault:)('beeping' beep beepPrimitive)('private' primitiveBeep)!Beeper removeSelector: #beep!Beeper removeSelector: #beepPrimitive!BaseSoundSystem initialize!