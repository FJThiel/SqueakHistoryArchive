'From Squeak 2.5 of August 6, 1999 [latest update: #1499] on 28 September 1999 at 11:53 pm'!!EventHandler methodsFor: 'initialization' stamp: 'tk 9/26/1999 18:51'!adaptToWorld: aWorld	"If any of my recipients refer to a world or a hand, make them now refer to the corresponding items in the new world.  (instVarNamed: is slow, later use perform of two selectors.)"	| value newValue |	#(mouseDownRecipient mouseStillDownRecipient mouseUpRecipient  mouseEnterRecipient  mouseLeaveRecipient  mouseEnterDraggingRecipient  mouseLeaveDraggingRecipient  keyStrokeRecipient valueParameter) do:		[:aName |			(value _ self instVarNamed: aName asString) ifNotNil:				[newValue _ nil.				(value isMorph and: [value isWorldMorph]) ifTrue:						[newValue _ aWorld].				(value isKindOf: HandMorph) ifTrue:						[newValue _ aWorld primaryHand].				(value isKindOf: Presenter) ifTrue:						[newValue _ aWorld presenter].			(newValue notNil and: [newValue ~~ value])				ifTrue:					[self instVarNamed: aName asString put: newValue]]]! !!HandMorph methodsFor: 'initialization' stamp: 'tk 9/26/1999 16:18'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	temporaryCursor _ nil.	temporaryCursorOffset _ 0@0.! !!HandMorph methodsFor: 'private' stamp: 'tk 9/26/1999 16:23'!releaseCachedState	| svg svgon oo |	super releaseCachedState.	cacheCanvas _ nil.	svg _ grid.	svgon _ gridOn.	oo _ owner.	self removeAllMorphs.	self initialize.	"nuke everything"	self privateOwner: oo.	grid _ svg.	gridOn _ svgon.	mouseDownMorph _ nil.	argument _ nil.	formerOwner _ nil.! !!ImageSegment commentStamp: 'tk 9/28/1999 13:17' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  My segment contains outward pointers that are indices into my table of outPointers.To put out a segment that can only be read by this image.  Make PV be a ProjectViewerMorph on a thumbnail of a project (not the current project).World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].(ImageSegment new copyFromRootsLocalFileFor: 	(Array with: PV project world presenter with: PV project world))		extract; writeToFile: 'myFile.seg'.To discover why the whole project is not going out (***Destructive Test***).  This breaks lots of backpointers in the target project, and puts up an array of suspicious objects, a list of the classes of the outPointers, and a debugger."Close any transcripts in the target project"World currentHand objectToPaste ifNotNil: [	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand objectToPaste printString].PV _ Project named: 'xxxx'.(IS _ ImageSegment new) findRogueRootsImSeg: 	(Array with: PV world presenter with: PV world)."Quit without saving""After the destructive analysis, write a file with owner chains"IS findOwnersOutPtrs.To put out a segment that can be read into a different image:(ImageSegment new copyFromRootsForExport: (Array with: Baz with: Baz class))		writeForExport: 'myFile.extSeg'.To read into another image:  Select 'myFile.extSeg' in a FileList, Menu more..., fileIn.  It will install classes automatically.  If you need to see the roots array, it is temporarily stored in (SmartRefStream scannedObject).I may exist in several states...#activeCopyarrayOfRoots segment outPointers are all as created by the copyFromRoots: initialization message.  Nothing else has changed about the Squeak system.#activeEach of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only the array of outPointers remains in the image.(ImageSegment new copyFromRoots: (Array with: Baz with: Baz class))		writeToFile: 'myFile.extSeg'.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.	NOTE: All IdentitySets or dictionaries must be rehashed when being read back from this format.  The symbols are effectively internal.  (No, not if read back into same image.  If a different image, then use #imported.  -tk)#importedThe segment is on an external file or just read in from one.  The segment and outPointers are meant to be read into a foreign image.   (It is in SmartRefStream format.)  In this form the segment can be read from a URL, and installed.  A copy of the original array of root objects is constructed, with former outPointers bound to existing objects in the host system.  	(Any Class inside the segment MUST be in the arrayOfRoots.  This is so its association can be inserted into Smalltalk.  The class's metaclass must be in roots also.  Methods that are in outPointers because blocks point at them, are found and added to the roots.)	All IdentitySets and dictionaries are rehashed when being read back from exported segments.) #inactiveIn this state, the rootsArray is set, but the segment is invalid.!!ImageSegment methodsFor: 'access' stamp: 'tk 9/26/1999 22:54'!state	^ state! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/26/1999 22:53'!copyFromRoots: aRootArray	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize |	aRootArray ifNil: [self errorWrongState].	arrayOfRoots _ aRootArray.	outPointers _ nil.	"may have used this instance before"	segSize _ 50000.	["Guess a reasonable segment size"	segmentWordArray _ WordArray new: segSize.	endMarker _ 'End' clone.	"for enumeration of objects"	[outPointerArray _ Array new: segSize // 20] ifError: [		state _ #tooBig.  ^ self].	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray _ outPointerArray _ nil.			segSize _ segSize * 2].	segment _ segmentWordArray.	outPointers _ outPointerArray.	state _ #activeCopy.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/28/1999 13:14'!copyFromRootsLocalFileFor: rootArray 	"If the roots include a World, add its Player classes to the roots."	| newRoots |	arrayOfRoots _ rootArray.	[(newRoots _ self rootsIncludingPlayers) == nil] whileFalse: [		arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"	Smalltalk forgetDoIts.  	Smalltalk garbageCollect.	"zap context that holds allExtantPlayers array"	self copyFromRoots: arrayOfRoots.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 9/28/1999 23:19'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again."| extras havePresenter players morphs |extras _ OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter _ root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [havePresenter _ root presenter]].	(root isKindOf: Project) ifTrue: [havePresenter _ root world presenter]].havePresenter ifNotNil: [	havePresenter flushPlayerListCache.		"old and outside guys"	morphs _ IdentitySet new: 400.	havePresenter associatedMorph allMorphsAndBookPagesInto: morphs.	players _ (morphs select: [:m | m player ~~ nil] 				thenCollect: [:m | m player]) asSet asArray.	players _ players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	extras addAll: (players collect: [:each | each class]).	extras addAll: (players collect: [:each | each class class]).	].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/28/1999 13:13'!findRogueRootsImSeg: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) Break all owner pointers in submorphs and all scripts.2) Create the segment and look at outPointers.3) Remove those we expect.4) Remember to quit without saving -- the owner pointers are smashed."| newRoots suspects bag1 bag2 |arrayOfRoots _ rootArray.[(newRoots _ self rootsIncludingPlayers) == nil] whileFalse: [	arrayOfRoots _ newRoots].		"world, presenter, and all Player classes"self findRogueRootsPrep.	"and free that context!!"Smalltalk forgetDoIts.Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots.suspects _ outPointers select: [:oo | oo isMorph].suspects size > 0 ifTrue: [suspects inspect].bag1 _ Bag new.  bag2 _ Bag new.outPointers do: [:key | 	(key isKindOf: Class) 		ifTrue: [bag2 add: key class name]		ifFalse: [(#(Symbol Point Rectangle True False String Float Color Form ColorForm StrikeFont Metaclass UndefinedObject TranslucentColor) includes: key class name)			ifTrue: [bag2 add: key class name]			ifFalse: [bag1 add: key class name]]]."(bag sortedCounts) is the SortedCollection"(StringHolder new contents: bag1 sortedCounts printString, '', bag2 sortedCounts printString) 	openLabel: 'Objects pointed at by the outside'.self halt: 'Examine local variables pointIn and inSeg'."Use this in inspectors:	outPointers select: [:oo | oo class == <a Class>].		"! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/28/1999 20:54'!findRogueRootsPrep	"Part of the tool to track down unwanted pointers into the segment.  Break all owner pointers in submorphs, scripts, and viewers in flaps."| wld players morphs scriptEditors |wld _ arrayOfRoots detect: [:obj | 	obj isMorph ifTrue: [obj isWorldMorph] ifFalse: [false]] ifNone: [nil].wld ifNil: [wld _ arrayOfRoots detect: [:obj | obj isMorph] 				ifNone: [^ self error: 'can''t find a root morph']].morphs _ IdentitySet new: 400.wld allMorphsAndBookPagesInto: morphs.players _ wld presenter allExtantPlayers.	"just the cached list"players do: [:pp |	scriptEditors _ pp class tileScriptNames collect: [:nn | 			pp scriptEditorFor: nn].	scriptEditors do: [:se | morphs addAll: se allMorphs]].wld submorphs do: [:mm | 	"non showing flaps"	(mm isKindOf: FlapTab) ifTrue: [		mm referent allMorphsAndBookPagesInto: morphs]].morphs do: [:mm | 	"break the back pointers"	mm isInMemory ifTrue: [	(mm respondsTo: #target) ifTrue: [		mm nearestOwnerThat: [:ow | ow == mm target 			ifTrue: [mm target: nil. true]			ifFalse: [false]]].	(mm respondsTo: #arguments) ifTrue: [		mm arguments do: [:arg | arg ifNotNil: [			mm nearestOwnerThat: [:ow | ow == arg				ifTrue: [mm arguments at: (mm arguments indexOf: arg) put: nil. true]				ifFalse: [false]]]]].	mm eventHandler ifNotNil: ["recipients point back up"		(morphs includesAllOf: (mm eventHandler allRecipients)) ifTrue: [			mm eventHandler: nil]].	"temporary, until using Model for PartsBin"	(mm isKindOf: MorphicModel) ifTrue: [		(mm model isKindOf: MorphicModel) ifTrue: [			mm model breakDependents]].	(mm isKindOf: TextMorph) ifTrue: [mm setContainer: nil]]].(Smalltalk includesKey: #Owners) ifTrue: [Smalltalk at: #Owners put: nil].	"in case findOwnerMap: is commented out""self findOwnerMap: morphs."morphs do: [:mm | 	"break the back pointers"	mm isInMemory ifTrue: [mm privateOwner: nil]]."more in extensions?"! !!PasteUpMorph methodsFor: 'flaps' stamp: 'tk 9/26/1999 20:24'!addGlobalFlaps	"Must make global flaps adapt to world.  Do this even if not shown, so the old world will not be pointed at by the flaps."	| use thisWorld |	use _ true.	(Preferences valueOfFlag: #useGlobalFlaps) ifFalse: [use _ false].	Project current flapsSuppressed ifTrue: [use _ false].	Smalltalk isMorphic ifFalse: [use _ false].	thisWorld _ use 		ifTrue: [self]		ifFalse: [(PasteUpMorph new) initForProject:  "fake to be flap owner"						WorldState new initForWorld;					bounds: (0@0 extent: 4000@4000)].		Utilities globalFlapTabs do: [:aFlapTab |		(aFlapTab world == thisWorld) ifFalse:			[thisWorld addMorphFront: aFlapTab.			aFlapTab adaptToWorld: thisWorld].	"always do"		use ifTrue: [			aFlapTab spanWorld.			aFlapTab adjustPositionAfterHidingFlap.			aFlapTab flapShowing ifTrue: [aFlapTab showFlap]]]."	Utilities clobberFlapTabList.	Utilities initializeStandardFlaps.	self currentWorld deleteAllFlapArtifacts.	self currentWorld addGlobalFlaps."! !!Project methodsFor: 'file in/out' stamp: 'tk 9/26/1999 22:54'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is response |world == World ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].		"keep the Menu flap from pointing at my project.  Already done by enter?"	"Preferences setPreference: #useGlobalFlaps toValue: false."	"Utilities globalFlapTabsIfAny do:		[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].	Utilities clobberFlapTabList.	"	"project world deleteAllFlapArtifacts."	"self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World currentHand objectToPaste ifNotNil: [	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand objectToPaste printString.	response = 1 ifTrue: [World currentHand clearPasteBuffer]].is _ ImageSegment new copyFromRootsLocalFileFor: 	(Array with: world presenter with: world).	"world, and all Players"is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' not enough objects for a Segment.'; cr.	^ false].is extract; writeToFile: (ImageSegment uniqueFileNameFor: self name).^ true! !!Project methodsFor: 'file in/out' stamp: 'tk 9/26/1999 22:03'!storeSomeSegment	| cnt pList start proj |	"Try all projects to see if any is ready to go out.  Send at most three of them.  Previous one has to wait for a garbage collection before it can go out."	cnt _ 0.	pList _ Project allInstances.	start _ pList size atRandom.	"start in a random place"	start to: pList size + start do: [:ii | 		proj _ pList atWrap: ii.		proj storeSegment ifTrue: ["Yes, did send its morphs to the disk"			self beep.			"(PluckedSound pitch: 261.625*4 dur: 1 loudness: 0.1) play."			(cnt _ cnt + 1) >= 2 ifTrue: [				"(PluckedSound pitch: 261.625*2 dur: 0.25 loudness: 0.1) play."				^ self]]].	(PluckedSound pitch: 261.625*4 dur: 0.35 loudness: 0.1) play.	"high = none"! !!SystemDictionary methodsFor: 'retrieving' stamp: 'tk 9/26/1999 14:54'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		anObj isInMemory ifTrue: [			(anObj pointsTo: anObject) ifTrue: [				"exclude the results collector and contexts in call chain"				((anObj ~~ results collector) and:				 [(anObj ~~ objectsToExclude) and:				 [(anObj ~~ thisContext) and:				 [(anObj ~~ thisContext sender) and:				 [anObj ~~ thisContext sender sender]]]])					 ifTrue: [ results add: anObj ].			]].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !!SystemDictionary methodsFor: 'class names' stamp: 'di 9/26/1999 11:16'!classNames	"Answer a SortedCollection of all class names."	| names |	CachedClassNames == nil ifTrue:		[names _ OrderedCollection new: self size.		self do: 			[:cl | (cl isInMemory and: [(cl isKindOf: Class) and: [(cl name beginsWith: 'AnObsolete') not]])				ifTrue: [names add: cl name]].		CachedClassNames _ names asSortedCollection].	^ CachedClassNames! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/26/1999 11:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x basicSize*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold or: [s fourth > (totalInstSpace // 500)]])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 14 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ );		nextPutAll: ((totalPercent roundTo: 0.1) printString padded: #left to: 8 with: $ ).	f close! !!TextMorph methodsFor: 'containment' stamp: 'tk 9/28/1999 16:50'!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [		newOwner ifNotNil: [			newOwner isWorldOrHandMorph ifTrue: [self setContainer: nil]]]! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/26/1999 23:11'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	(wordingProvider isMorph and: [wordingProvider isWorldMorph]) ifTrue: [		wordingProvider _ aWorld].	(wordingProvider isKindOf: HandMorph) ifTrue: [		wordingProvider _ aWorld primaryHand].	(wordingProvider isKindOf: Presenter) ifTrue: [		wordingProvider _ aWorld presenter]! !"Postscript:Project allInstances do: [:pp | pp breakDependents].AbstractSound unloadSampledTimbres.Project storeAllInSegments.Project allInstances do: [:pp | pp isMorphic ifTrue: [pp world submorphs]]."!