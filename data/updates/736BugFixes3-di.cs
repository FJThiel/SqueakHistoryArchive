'From Squeak 2.3 of January 14, 1999 on 15 March 1999 at 5:07:35 pm'!"Change Set:		BugFixes3Date:			15 March 1999Author:			Dan Ingalls1.  Renamed the message add:beforeIndex: to add:afterIndex in OrderedCollection, since that is what it does. (Suggested by Andres Valloud)2.  Included Leandro Caniglia's fix for prettyPrint in a ChangeSorter.3.  Added Tim Olson's suggestion for Form>>printOn:.4.  Leandro Caniglia's fix for BalloonMorph>>string:for:corner:5.  Tim Rowledge's fix for IntegerArray>>at:6.  Fixed behavior of SelectionMenus with no items (suggested by Chris Norton)."!!BalloonMorph class methodsFor: 'all'!string: str for: morph corner: cornerName	"Make up and return a balloon for morph.  Find the quadrant thatclips the text the least, using cornerName as a tie-breaker.  tk 9/12/97"	| txt tm corners p1 p2 vertices c r maxArea aa verts mp dir mbc pref rectCorner morphPoint balloonColor |	BalloonFont		ifNil: [txt _ str]		ifNotNil: [txt _ Text string: str attribute: (TextFontReference toFont: BalloonFont)].	tm _ (TextMorph new contents: txt) centered.	"Construct vertices for a balloon below and to left of anchor"	corners _ tm bounds corners atAll: #(1 4 3 2).	p1 _ (corners at: 1) + ((0 - tm width//3)@0).	p2 _ (corners at: 1) + ((0 - tm width//6)@(tm height//2)).	vertices _ (Array with: p1 with: p2) , corners.	r _ p1 rect: (corners at: 3).	corners _ #(bottomRight bottomLeft topLeft topRight).	pref _ corners indexOf: cornerName.	c _ tm center.	maxArea _ 0.	(0 to: 3) do:		[:i | "Try four rel locations of the balloon for greatest unclipped area"		rectCorner _ corners atWrap: i+pref+2.		morphPoint _ (#(bottomRight bottomLeft) includes: rectCorner)						ifTrue: [#topCenter] ifFalse: [#bottomCenter].		aa _ ((r align: (r perform: rectCorner)				with: (mbc _ morph fullBoundsInWorld perform: morphPoint))			intersect: (0@0 extent: morph world viewBox extent)) area.		aa > maxArea ifTrue: [maxArea _ aa].		verts _ vertices.		mp _ mbc.		dir _ (i+pref) odd ifTrue: [#horizontal] ifFalse: [#vertical].		vertices _ vertices collect: [:p | p flipBy: dir centerAt: c]].	balloonColor _ Display depth <= 2					ifTrue: [Color white]					ifFalse: [Color r: 1.0 g: 1.0 b: 0.6].	^ self new color: balloonColor;			setBorderWidth: 1 borderColor: Color black;			setVertices: verts;			addMorph: tm;			align: verts first with: mp;			setTarget: morph! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'LC 2/14/1999 14:52'!prettyPrint	"Reformat the selected method"	| class | 	currentSelector notNil & self okToChange ifFalse: [^ self changed: #flash].	class _ self selectedClassOrMetaClass.	contents _ (class compilerClass new				format: contents				in: class				notifying: nil) asText makeSelectorBoldIn: class.	self changed: #contents! !!Color methodsFor: 'private' stamp: 'SqR!!!!!!!! 2/25/1999 23:10'!privateGreen	"Private!! Return the internal representation of my green component.	Replaced >> by bitShift: 0 -. SqR!! 2/25/1999 23:08"	^ (rgb bitShift: 0 - GreenShift) bitAnd: ComponentMask! !!FileList methodsFor: 'file list menu' stamp: 'di 3/15/1999 16:47'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = 'sp') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'bo') | (suffix = '*') ifTrue:[		labels add: 'load as book'.		selectors add: #openBookFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels addAll: #('view decompressed' 'decompress to file').		selectors addAll: #(viewGZipContents saveGZipContents)].	(suffix = '3ds') | (suffix = '*') ifTrue:[		labels add: 'Open 3DS file'.		selectors add: #open3DSFile].	(suffix = 'tape') | (suffix = '*') ifTrue:		[labels add: 'open for playback'.		selectors add: #openTapeFromFile].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!Form methodsFor: 'fileIn/Out' stamp: 'di 3/15/1999 14:50'!printOn: aStream    aStream        nextPutAll: self class name;        nextPut: $(; print: width;        nextPut: $x; print: height;        nextPut: $x; print: depth;        nextPut: $).! !!IntegerArray methodsFor: 'accessing' stamp: 'TPR 3/9/1999 13:37'!at: index	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 ) negated +1]		ifFalse:[word]! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 3/15/1999 01:52'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ selectedItem! !!OrderedCollection methodsFor: 'adding' stamp: 'di 3/15/1999 14:01'!add: newObject afterIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just after index. Answer newObject."	self insert: newObject before: firstIndex + index.	^ newObject! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 3/15/1999 14:42'!list: listOfStrings	| morphList handler h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [self setScrollDeltas.  ^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ list collect: [:item | StringMorph contents: item font: font].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'di 3/15/1999 16:27'!labelList: labelList lines: lines selections: selections 	^ self labels: (String streamContents:			[:strm |  "Concatenate labels with CRs"			labelList do: [:each | strm nextPutAll: each; cr].			labelList isEmpty ifFalse: [strm skip: -1]])  "No CR at end"		lines: lines selections: selections! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'di 3/15/1999 14:01'!incorporateAddsInto: aPatchSequence	"Incorporate adds"	| lastMatch lastIndex index |	added ifNil:[^self].	added := added sortBy:[:a1 :a2| a1 key < a2 key].	lastMatch := 1.	lastIndex := 0.	1 to: added size do:[:i|		index := (added at: i) key.		[index > lastMatch] whileTrue:[			[lastIndex := lastIndex + 1.			(aPatchSequence at: lastIndex) key == #match] whileFalse.			lastMatch := lastMatch + 1.		].		aPatchSequence add: #insert->(added at: i) value afterIndex: lastIndex.		lastIndex := lastIndex + 1.		lastMatch := lastMatch + 1.	].! !OrderedCollection removeSelector: #add:beforeIndex:!