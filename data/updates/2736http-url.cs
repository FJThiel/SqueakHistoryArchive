'From Squeak2.8 of 18 June 2000 [latest update: #2348] on 26 July 2000 at 1:17:36 pm'!"Change Set:		http-urlDate:			26 July 2000Author:			Michael RuegerCleans up some minor inconsistencies.Adds methods to specify the mimeType in the getResponse calls.Setting a proxy in Squeak usually keeps you from connecting to local hosts within your domain. This change set adds a list of exempt host or domain names to HTTPSocket, which should not be contacted through the proxy.Adds a method to build a list of URL args without encoding the arguments. Usefull if you have args already containing special characters.Add also a class URLArgumentList which does not change the order of arguments."!SimpleClientSocket subclass: #HTTPSocket	instanceVariableNames: 'headerTokens headers responseCode '	classVariableNames: 'HTTPBlabEmail HTTPPort HTTPProxyExceptions HTTPProxyPort HTTPProxyServer ParamDelimiters '	poolDictionaries: ''	category: 'Network-Protocols'!Url subclass: #HierarchicalUrl	instanceVariableNames: 'schemeName authority path query port '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!OrderedCollection subclass: #UrlArgumentList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Url'!UrlArgumentList class	instanceVariableNames: ''!!HTTPSocket class methodsFor: 'get the page' stamp: 'mir 7/26/2000 12:59'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| httpUrl page sock list header firstData aStream length type newUrl |	Socket initializeNetwork.	httpUrl _ Url absoluteFromText: url.	page _ httpUrl toText.	"add arguments"	args ifNotNil: [page _ page, (self argString: args) ].3 timesRepeat: [	sock _ self initHTTPSocket: httpUrl ifError: [:errorString | ^errorString].	"Transcript cr; cr; show: url."	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['ACCEPT: */* ']),		" 'ACCEPT: text/html', CrLf, "	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', httpUrl authority, ':', httpUrl port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode first > $3				ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	^aStream"	aStream = 'server aborted early' ifFalse: [		self halt.		^aStream]"	].! !!HTTPSocket class methodsFor: 'get the page' stamp: 'mir 7/26/2000 13:10'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| s header length page list firstData aStream argsStream first type newUrl httpUrl |	Socket initializeNetwork.	httpUrl _ Url absoluteFromText: url.	page _ httpUrl toText.	"add arguments"	argsDict ifNotNil: [page _ page, (self argString: argsDict) ].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].	s _ HTTPSocket new. 	s _ self initHTTPSocket: httpUrl wait: (self deadlineSecs: 30) ifError: [:errorString | ^errorString].	Transcript cr; show: url; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', httpUrl authority, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'Response: ' , s responseCode.			Transcript show: ' redirecting to: ', newUrl; cr.			s destroy.			"^self httpPostDocument: newUrl  args: argsDict  accept: mimeType"			^self httpGetDocument: newUrl accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'mir 7/30/1999 16:08'!addProxyException: domainName	"Add a (partial, wildcard) domain name to the list of proxy exceptions"	"HTTPSocket addProxyException: '*.online.disney.com'"	self httpProxyExceptions add: domainName! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'mir 7/30/1999 15:03'!httpProxyExceptions	HTTPProxyExceptions ifNil: [HTTPProxyExceptions _ OrderedCollection new].	^HTTPProxyExceptions! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'mir 7/30/1999 15:03'!removeProxyException: domainName	"Remove a (partial, wildcard) domain name from the list of proxy exceptions"	self httpProxyExceptions remove: domainName ifAbsent: []! !!HTTPSocket class methodsFor: 'utilities' stamp: 'mir 7/28/1999 15:52'!argStringUnencoded: args	"Return the args in a long string, as encoded in a url"	| argsString first |	args class == String ifTrue: ["sent in as a string, not a dictionary"		^ (args first = $? ifTrue: [''] ifFalse: ['?']), args].	argsString _ WriteStream on: String new.	argsString nextPut: $?.	first _ true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key.			argsString nextPut: $=.			argsString nextPutAll: value. ] ].	^ argsString contents! !!HTTPSocket class methodsFor: 'utilities' stamp: 'mir 7/30/1999 15:46'!initHTTPSocket: httpUrl ifError: aBlock	"Retrieve the server and port information from the URL, match it to the proxy settings and open a http socket for the request."	^self initHTTPSocket: httpUrl wait: self standardDeadline ifError: aBlock! !!HTTPSocket class methodsFor: 'utilities' stamp: 'mir 7/30/1999 15:43'!initHTTPSocket: httpUrl wait: timeout ifError: aBlock	"Retrieve the server and port information from the URL, match it to the proxy settings and open a http socket for the request."	| serverName port serverAddr s |	Socket initializeNetwork.	serverName _ httpUrl authority.	port _ httpUrl port ifNil: [self defaultPort].	(self shouldUseProxy: serverName) ifTrue: [ 		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [aBlock value: 'Error: Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	(s waitForConnectionUntil: timeout) ifFalse: [		Socket deadServer: httpUrl authority.		s destroy.		^aBlock value: 'Error: Server ',httpUrl authority,' is not responding'].	^s! !!HTTPSocket class methodsFor: 'utilities' stamp: 'mir 7/30/1999 13:33'!shouldUseProxy: serverName	"Retrieve the server and port information from the URL, match it to the proxy settings and open a http socket for the request."	HTTPProxyServer ifNotNil: [		self httpProxyExceptions			detect: [:domainName | domainName match: serverName]			ifNone: [^true]].	^false! !!Url methodsFor: 'accessing' stamp: 'mir 2/22/2000 18:05'!authority	^''! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'mir 7/30/1999 13:05'!privateInitializeFromText: aString	| remainder ind nextTok s specifiedSchemeName |	remainder _ aString.	schemeName ifNil: [ 		specifiedSchemeName _ Url schemeNameForString: remainder.		specifiedSchemeName ifNotNil: [ 			schemeName _ specifiedSchemeName.			remainder _ remainder copyFrom: (schemeName size+2) to: remainder size ].		schemeName ifNil: [ "assume HTTP"  schemeName _ 'http' ] ].	"remove leading // if it's there"	(remainder beginsWith: '//') ifTrue: [		remainder _ remainder copyFrom: 3 to: remainder size ].	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ].	"get the authority"	ind _ remainder indexOf: $/.	ind > 0 ifTrue: [		ind = 1 ifTrue: [ authority _ '' ] ifFalse: [			authority _ remainder copyFrom: 1 to: ind-1.			remainder _ remainder copyFrom: ind+1 to: remainder size. ] ]	ifFalse: [		authority _ remainder.		remainder _ ''. ].	"Extract the port"	(authority includes: $:)		ifTrue: [			port _ (authority copyFrom: (authority indexOf: $:) + 1 to: authority size) asNumber.			authority _ authority copyUpTo: $:].	"get the path"	path _ OrderedCollection new.	s _ ReadStream on: remainder.	[ 		s peek = $/ ifTrue: [ s next ].		nextTok _ WriteStream on: String new.		[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].		nextTok _ nextTok contents unescapePercents.		nextTok = '..' 			ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]			ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].		s atEnd 	] whileFalse.	path isEmpty ifTrue: [ path add: '' ].! !!HierarchicalUrl methodsFor: 'access' stamp: 'mir 7/30/1999 13:05'!port	^port! !!HttpUrl methodsFor: 'downloading' stamp: 'mir 7/25/2000 17:10'!postFormArgs: args	| contents request |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, String crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostDocument: self toText args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^ self postFormArgs: args].	^self normalizeContents: contents! !!HttpUrl methodsFor: 'downloading' stamp: 'mir 7/25/2000 17:10'!postMultipartFormArgs: args	| contents request |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, String crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostMultipart: self toText args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^ self postMultipartFormArgs: args].	^self normalizeContents: contents! !!HttpUrl methodsFor: 'downloading'!retrieveContentsAccept: mimeType	^ self retrieveContentsArgs: nil accept: mimeType! !!HttpUrl methodsFor: 'downloading' stamp: 'mir 7/26/2000 12:56'!retrieveContentsArgs: args	^self retrieveContentsArgs: args accept: 'application/octet-stream'! !!HttpUrl methodsFor: 'downloading' stamp: 'mir 7/26/2000 12:55'!retrieveContentsArgs: args accept: mimeType	| contents request |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']] ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ' , request , String crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket		httpGetDocument: self withoutFragment toText		args: args		accept: mimeType		request: request).	self checkAuthorization: contents retry: [^ self retrieveContentsArgs: args].	^ self normalizeContents: contents! !!UrlArgumentList methodsFor: 'enumerating' stamp: 'mir 7/27/1999 16:01'!associationsDo: aBlock	self do: [:each | 		aBlock value: each]! !!UrlArgumentList methodsFor: 'private' stamp: 'mir 7/27/1999 16:20'!argumentNamed: argName	^self		detect: [:each | each key = argName]		ifNone: [nil]! !!UrlArgumentList methodsFor: 'adding' stamp: 'mir 7/27/1999 16:19'!add: argName value: argValue	| argAssociation |	argAssociation _ self argumentNamed: argName.	argAssociation isNil		ifTrue: [self add: (argName -> (OrderedCollection with: argValue))]		ifFalse: [argAssociation value add: argValue]! !!UrlArgumentList class methodsFor: 'instance creation' stamp: 'mir 7/27/1999 16:25'!with: argAssoc	| argList |	argList _ self new.	argList add: argAssoc key value: argAssoc value.	^argList! !!UrlArgumentList class methodsFor: 'instance creation' stamp: 'mir 7/27/1999 16:26'!with: firstArgAssoc with: secondArgAssoc	| argList |	argList _ self with: firstArgAssoc.	argList add: secondArgAssoc key value: secondArgAssoc value.	^argList! !!UrlArgumentList class methodsFor: 'instance creation' stamp: 'mir 7/27/1999 16:26'!with: firstArgAssoc with: secondArgAssoc with: thirdArgAssoc	| argList |	argList _ self with: firstArgAssoc with: secondArgAssoc.	argList add: thirdArgAssoc key value: thirdArgAssoc value.	^argList! !