'From Squeak2.8alpha of 16 February 2000 [latest update: #2158] on 17 May 2000 at 4:41:57 pm'!"Change Set:		LargeIntegersPluginDate:			9 April 2000Author:			Stephan Rudlof (sr@evolgo.de)Special thanks to:	Andrew C. GreenbergSpeeds up LargeInteger arithmetics.Note: If you just want to use the LargeIntegersPlugin as an enduser,	you do not need this change set!!	-> Look for a 'LargeIntegers' module (platform specific compiled plugin) and the 'Install_LargeIntegers_module' change set then.Preconditions:- VM 2.7 or later.ToDo:File in this change set and generate the module as library according the 'Short Guide for Compiling the LargeIntegersPlugin'.Then you will need the corresponding 'Install_LargeIntegers_module' changeset for installing the module.If you have generated this module for your platform, because you haven't found it over	http://www.evolgo.com/Squeak/please eMail it to (me)	sr@evolgo.dewith a description of your platform. I will put it onto the corresponding web side then.Implementation note:There are some extensions of Andrew's TestCodeGenerator and TestInterpreterPlugin in this changeset, Object changes belong to this, too. This could lead to conflicts with other changesets, especially TestCodeGenerator>>initializeCTranslationDictionary  could lead to - easily solvable - problems."!TestInterpreterPlugin subclass: #LargeIntegersPlugin	instanceVariableNames: 'andOpIndex orOpIndex xorOpIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!LargeIntegersPlugin commentStamp: '<historical>' prior: 0!LargeIntegersPlugin provides functions for speeding up LargeInteger arithmetics.Protocol 'debug' on the class side could be interesting for developers.For ST simulation you have to use methods here, in addition to them in Integer class.Inst vars:	forceFailInCFlag		can be set by Integer class>>usePlugin:, default false (plugin in use).	debugFlag			can be set by LargeIntegersPlugin class>>debug:, default false.	andOpIndex			C constant	orOpIndex			C constant	xorOpIndex 			C constantUsed like an enum, in ST one would use symbols instead.Class vars:	DebugFlag			corresponds to inst var 'debugFlag': It isn't necessarily in sync with 'debugFlag' in module after starting squeak, so set them both explicitly by class method in 'debug' protocol if you want to simulate in ST.!Object subclass: #LargeIntegersTest	instanceVariableNames: 'oc1 oc2 ocShift ocShift2 stream '	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-Plugins'!!LargeIntegersTest commentStamp: '<historical>' prior: 0!Some tests for LargeIntegersPlugin functions and their binding to Integer methods.Evaluate...without module:	LargeIntegersTest doItInFile: '/tmp/withoutModule.txt' withModule: false.with module:	LargeIntegersTest doItInFile: '/tmp/withModule.txt' withModule: true..After these computations both files have to be the same contents!!Speed:	[LargeIntegersTest bigFactorial: 3 depth: 3] timeToRunor	[10000 factorial] timeToRun!PluggableCodeGenerator subclass: #TestCodeGenerator	instanceVariableNames: 'debugFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'VMConstruction-TestPlugins'!!Object methodsFor: 'translation support' stamp: 'acg 1/1/2000 12:45'!remapOop: oopOrList in: aBlock	"For translation only; noop when running in Smalltalk."	^aBlock value! !!Object methodsFor: 'translation support' stamp: 'acg 1/1/2000 12:46'!stAt: index	^self at: index! !!Object methodsFor: 'translation support' stamp: 'acg 1/1/2000 12:46'!stAt: index put: value	^self at: index put: value! !!Object methodsFor: 'translation support' stamp: 'acg 1/1/2000 22:42'!stSize	^self size! !!Interpreter class methodsFor: 'translation' stamp: 'ar 5/17/2000 16:31'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	"Interpreter patchInterp: 'Squeak VM PPC'"	| cg exports |	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	"Get all the named prims from the VM.	Note: the format of exports is:		pluginName -> Array of: primitiveName.	so we can generate a nice table from it."	exports _ Array with: '' -> cg exportedPrimitiveNames asArray.	cg storeCodeOnFile: fileName doInlining: inlineFlag.	"Add our plugins"	{		"Graphics"			"Note: BitBltSimulation should go first, 			because three of it's entries might be 			looked up quite often (due to refs from 			InterpreterProxy). This will go away at			some point but for now it's a good idea			to have those entries early in the table."		BitBltSimulation.			BalloonEnginePlugin. 		"I/O subsystems"		FilePlugin.		SocketPlugin. 		SoundPlugin. 		MIDIPlugin. 		SerialPlugin. 		JoystickTabletPlugin. 		AsynchFilePlugin. 	 	"Numerics"		LargeIntegersPlugin.		FFTPlugin. 		FloatArrayPlugin. 		Matrix2x3Plugin. 		"Compression"		DeflatePlugin.		"Note: Optionally, you can translate the following as builtins.		As of Squeak 2.7 they are not builtins by default:			DSAPlugin.			KlattSynthesizerPlugin.			SoundCodecPlugin.			B3DEnginePlugin.			FFIPlugin.		"	} do:[:plugin|		cg _ plugin translate: plugin moduleName, '.c'					doInlining: inlineFlag					locally: true.		exports _ exports copyWith: 			(plugin moduleName -> cg exportedPrimitiveNames asArray).	].	self storeExports: exports on: 'sqNamedPrims.h'.! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:06'!primDigitAdd: secondInteger 	""	| firstLarge secondLarge firstInteger |	self debugCode: [self msg: 'primDigitAdd: secondInteger'].	firstInteger _ self				primitive: 'primDigitAdd'				parameters: #(Integer )				receiver: #Integer.	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondLarge _ secondInteger].	^ self digitAddLarge: firstLarge with: secondLarge! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:07'!primDigitBitAnd: secondInteger 	"Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails."	| firstInteger |	self debugCode: [self msg: 'primDigitBitAnd: secondInteger'].	firstInteger _ self				primitive: 'primDigitBitAnd'				parameters: #(Integer )				receiver: #Integer.	^ self		digitBitLogic: firstInteger		with: secondInteger		opIndex: andOpIndex! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:07'!primDigitBitOr: secondInteger 	"Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails."	| firstInteger |	self debugCode: [self msg: 'primDigitBitOr: secondInteger'].	firstInteger _ self				primitive: 'primDigitBitOr'				parameters: #(Integer )				receiver: #Integer.	^ self		digitBitLogic: firstInteger		with: secondInteger		opIndex: orOpIndex! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:08'!primDigitBitShift: shiftCount 	| rShift aLarge anInteger |	self debugCode: [self msg: 'primDigitBitShift: shiftCount'].	anInteger _ self				primitive: 'primDigitBitShift'				parameters: #(SmallInteger )				receiver: #Integer.	(interpreterProxy isIntegerObject: anInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			aLarge _ self createLargeFromSmallInteger: anInteger]		ifFalse: [aLarge _ anInteger].	shiftCount >= 0		ifTrue: [^ self bytes: aLarge Lshift: shiftCount]		ifFalse: 			[rShift _ 0 - shiftCount.			^ self normalize: (self					bytes: aLarge					Rshift: (rShift bitAnd: 7)					bytes: (rShift bitShift: -3)					lookfirst: (self byteSizeOfBytes: aLarge))]! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:08'!primDigitBitXor: secondInteger 	"Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails."	| firstInteger |	self debugCode: [self msg: 'primDigitBitXor: secondInteger'].	firstInteger _ self				primitive: 'primDigitBitXor'				parameters: #(Integer )				receiver: #Integer.	^ self		digitBitLogic: firstInteger		with: secondInteger		opIndex: xorOpIndex! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:08'!primDigitCompare: secondInteger 	| firstVal secondVal firstInteger |	self debugCode: [self msg: 'primDigitCompare: secondInteger'].	firstInteger _ self		primitive: 'primDigitCompare'		parameters: #(Integer  )		receiver: #Integer.	"shortcut: aSmallInteger has to be smaller in Magnitude as aLargeInteger"	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["first"			(interpreterProxy isIntegerObject: secondInteger)				ifTrue: ["second"					(firstVal _ interpreterProxy integerValueOf: firstInteger) > (secondVal _ interpreterProxy integerValueOf: secondInteger)						ifTrue: [^ 1 asOop: SmallInteger"first > second"]						ifFalse: [firstVal < secondVal								ifTrue: [^ -1 asOop: SmallInteger"first < second"]								ifFalse: [^ 0 asOop: SmallInteger"first = second"]]]				ifFalse: ["SECOND"					^ -1 asOop: SmallInteger"first < SECOND"]]		ifFalse: ["FIRST"			(interpreterProxy isIntegerObject: secondInteger)				ifTrue: ["second"					^ 1 asOop: SmallInteger"FIRST > second"]				ifFalse: ["SECOND"					^ self digitCompareLarge: firstInteger with: secondInteger]]! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:09'!primDigitDiv: secondInteger negative: neg 	"Answer the result of dividing firstInteger by secondInteger.  Fail if      	parameters are not integers or secondInteger is zero."	| firstAsLargeInteger secondAsLargeInteger firstInteger |	self debugCode: [self msg: 'primDigitDiv: secondInteger negative: neg'].	firstInteger _ self				primitive: 'primDigitDivNegative'				parameters: #(Integer Boolean )				receiver: #Integer.	"Coerce SmallIntegers to corresponding (not normalized) large integers    	  and check for zerodivide."	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert to LargeInteger"			self remapOop: secondInteger in: [firstAsLargeInteger _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstAsLargeInteger _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: 			["check for zerodivide and convert to LargeInteger"			(interpreterProxy integerValueOf: secondInteger)				= 0 ifTrue: [^ interpreterProxy primitiveFail].			self remapOop: firstAsLargeInteger in: [secondAsLargeInteger _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondAsLargeInteger _ secondInteger].	^ self		digitDivLarge: firstAsLargeInteger		with: secondAsLargeInteger		negative: neg! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:09'!primDigitMultiply: secondInteger negative: neg 	""	| firstLarge secondLarge firstInteger |	self debugCode: [self msg: 'primDigitMultiply: secondInteger negative: neg'].	firstInteger _ self		primitive: 'primDigitMultiplyNegative'		parameters: #( Integer Boolean )		receiver: #Integer.	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondLarge _ secondInteger].	^ self		digitMultiplyLarge: firstLarge		with: secondLarge		negative: neg! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:10'!primDigitSubtract: secondInteger 	""	| firstLarge secondLarge firstInteger |	self debugCode: [self msg: 'primDigitSubtract: secondInteger'].	firstInteger _ self		primitive: 'primDigitSubtract'		parameters: #( Integer )		receiver: #Integer.	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondLarge _ secondInteger].	^ self digitSubLarge: firstLarge with: secondLarge! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:11'!primNormalizeNegative	""	| rcvr |	self debugCode: [self msg: 'primNormalizeNegative'].	rcvr _ self				primitive: 'primNormalizeNegative'				parameters: #()				receiver: #LargeNegativeInteger.	^ self normalizeNegative: rcvr! !!LargeIntegersPlugin methodsFor: 'Integer primitives' stamp: 'sr 4/8/2000 02:11'!primNormalizePositive	| rcvr |	""	self debugCode: [self msg: 'primNormalizePositive'].	rcvr _ self		primitive: 'primNormalizePositive'		parameters: #()		receiver: #LargePositiveInteger.	^ self normalizePositive: rcvr! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:05'!primDigit: anInteger bitShift: shiftCount 	| rShift aLarge |	self debugCode: [self msg: 'primDigit: anInteger bitShift: shiftCount'].	self		primitive: '_primDigitBitShift'		parameters: #(Integer SmallInteger )		receiver: #Oop.	(interpreterProxy isIntegerObject: anInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			aLarge _ self createLargeFromSmallInteger: anInteger]		ifFalse: [aLarge _ anInteger].	shiftCount >= 0		ifTrue: [^ self bytes: aLarge Lshift: shiftCount]		ifFalse: 			[rShift _ 0 - shiftCount.			^ self normalize: (self					bytes: aLarge					Rshift: (rShift bitAnd: 7)					bytes: (rShift bitShift: -3)					lookfirst: (self byteSizeOfBytes: aLarge))]! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:06'!primDigitAdd: firstInteger with: secondInteger 	""	| firstLarge secondLarge |	self debugCode: [self msg: 'primDigitAdd: firstInteger with: secondInteger'].	self		primitive: 'primDigitAddWith'		parameters: #(Integer Integer )		receiver: #Oop.	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondLarge _ secondInteger].	^ self digitAddLarge: firstLarge with: secondLarge! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:07'!primDigitBitLogic: firstInteger with: secondInteger op: opIndex 	"Bit logic here is only implemented for positive integers or Zero; if any arg is negative, it fails."	self debugCode: [self msg: 'primDigitBitLogic: firstInteger with: secondInteger op: opIndex'].	self		primitive: 'primDigitBitLogicWithOp'		parameters: #(Integer Integer SmallInteger )		receiver: #Oop.	^ self		digitBitLogic: firstInteger		with: secondInteger		opIndex: opIndex! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:08'!primDigitCompare: firstInteger with: secondInteger 	| firstVal secondVal |	self debugCode: [self msg: 'primDigitCompare: firstInteger with: secondInteger'].	self		primitive: 'primDigitCompareWith'		parameters: #(Integer Integer )		receiver: #Oop.	"shortcut: aSmallInteger has to be smaller in Magnitude as aLargeInteger"	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["first"			(interpreterProxy isIntegerObject: secondInteger)				ifTrue: ["second"					(firstVal _ interpreterProxy integerValueOf: firstInteger) > (secondVal _ interpreterProxy integerValueOf: secondInteger)						ifTrue: [^ 1 asOop: SmallInteger"first > second"]						ifFalse: [firstVal < secondVal								ifTrue: [^ -1 asOop: SmallInteger"first < second"]								ifFalse: [^ 0 asOop: SmallInteger"first = second"]]]				ifFalse: ["SECOND" ^ -1 asOop: SmallInteger"first < SECOND"]]		ifFalse: ["FIRST"			(interpreterProxy isIntegerObject: secondInteger)				ifTrue: ["second" ^ 1 asOop: SmallInteger"FIRST > second"]				ifFalse: ["SECOND"					^ self digitCompareLarge: firstInteger with: secondInteger]]! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:09'!primDigitDiv: firstInteger with: secondInteger negative: neg 	"Answer the result of dividing firstInteger by secondInteger.  Fail if     	parameters are not integers or secondInteger is zero."	| firstAsLargeInteger secondAsLargeInteger |	self debugCode: [self msg: 'primDigitDiv: firstInteger with: secondInteger negative: neg'].	self		primitive: 'primDigitDivWithNegative'		parameters: #(Integer Integer Boolean )		receiver: #Oop.	"Coerce SmallIntegers to corresponding (not normalized) large integers    	 and check for zerodivide."	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert to LargeInteger"			self remapOop: secondInteger in: [firstAsLargeInteger _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstAsLargeInteger _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: 			["check for zerodivide and convert to LargeInteger"			(interpreterProxy integerValueOf: secondInteger)				= 0 ifTrue: [^ interpreterProxy primitiveFail].			self remapOop: firstAsLargeInteger in: [secondAsLargeInteger _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondAsLargeInteger _ secondInteger].	^ self		digitDivLarge: firstAsLargeInteger		with: secondAsLargeInteger		negative: neg! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:10'!primDigitMultiply: firstInteger with: secondInteger negative: neg	""	| firstLarge secondLarge |	self debugCode: [self msg: 'primDigitMultiply: firstInteger with: secondInteger negative: neg'].	self		primitive: 'primDigitMultiplyWithNegative'		parameters: #(Integer Integer Boolean )		receiver: #Oop.	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondLarge _ secondInteger].	^ self		digitMultiplyLarge: firstLarge		with: secondLarge		negative: neg! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:11'!primDigitSubtract: firstInteger with: secondInteger	""	| firstLarge secondLarge |	self debugCode: [self msg: 'primDigitSubtract: firstInteger with: secondInteger'].	self		primitive: 'primDigitSubtractWith'		parameters: #(Integer Integer )		receiver: #Oop.	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: [firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: ["convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: [secondLarge _ secondInteger].	^ self digitSubLarge: firstLarge with: secondLarge! !!LargeIntegersPlugin methodsFor: 'development primitives' stamp: 'sr 4/8/2000 02:11'!primNormalize: anInteger "Parameter specification #(Integer) doesn't convert!!"	self debugCode: [self msg: 'primNormalize: anInteger'].	self		primitive: 'primNormalize'		parameters: #(Integer )		receiver: #Oop.	(interpreterProxy isIntegerObject: anInteger)		ifTrue: [^ anInteger].	^ self normalize: anInteger! !!LargeIntegersPlugin methodsFor: 'control & support primitives' stamp: 'sr 4/8/2000 02:13'!primAsLargeInteger: anInteger	"Converts a SmallInteger into a - non normalized!! - LargeInteger;          	 aLargeInteger will be returned unchanged."	"Do not check for forced fail, because we need this conversion to test the 	plugin in ST during forced fail, too."	self debugCode: [self msg: 'primAsLargeInteger: anInteger'].	self		primitive: 'primAsLargeInteger'		parameters: #(Integer )		receiver: #Oop.	(interpreterProxy isIntegerObject: anInteger)		ifTrue: [^ self createLargeFromSmallInteger: anInteger]		ifFalse: [^ anInteger]! !!LargeIntegersPlugin methodsFor: 'control & support primitives' stamp: 'sr 12/27/1999 19:00'!primCheckIfCModuleExists	"If calling this primitive fails, then C module does not exist. Do not check for forced fail, because we want to know if module exists during forced fail, too."	self		primitive: 'primCheckIfCModuleExists'		parameters: #()		receiver: #Oop.	^ true asOop: Boolean! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:43'!bytes: aBytesOop Lshift: shiftCount 	"Attention: this method invalidates all oop's!! Only newBytes is valid at    	       return."	"Does not normalize."	| newBytes highBit newLen oldLen |	oldLen _ self byteSizeOfBytes: aBytesOop.	(highBit _ self cBytesHighBit: (interpreterProxy firstIndexableField: aBytesOop)				len: oldLen) = 0 ifTrue: [^ 0 asOop: SmallInteger].	newLen _ highBit + shiftCount + 7 // 8.	self remapOop: aBytesOop in: [newBytes _ interpreterProxy instantiateClass: (interpreterProxy fetchClassOf: aBytesOop)					indexableSize: newLen].	self		cBytesLshift: shiftCount		from: (interpreterProxy firstIndexableField: aBytesOop)		len: oldLen		to: (interpreterProxy firstIndexableField: newBytes)		len: newLen.	^ newBytes! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:44'!bytes: aBytesOop Rshift: anInteger bytes: b lookfirst: a 	"Attention: this method invalidates all oop's!! Only newBytes is valid at    	  return."	"Shift right 8*b+anInteger bits, 0<=n<8.         	Discard all digits beyond a, and all zeroes at or below a."	"Does not normalize."	| n x f m digit i oldLen newLen newBytes |	n _ 0 - anInteger.	x _ 0.	f _ n + 8.	i _ a.	m _ 255 bitShift: 0 - f.	digit _ self digitOfBytes: aBytesOop at: i.	[((digit bitShift: n)		bitOr: x)		= 0 and: [i ~= 1]]		whileTrue: 			[x _ digit bitShift: f.			"Can't exceed 8 bits"			i _ i - 1.			digit _ self digitOfBytes: aBytesOop at: i].	i <= b ifTrue: [^ interpreterProxy instantiateClass: (interpreterProxy fetchClassOf: aBytesOop)			indexableSize: 0"Integer new: 0 neg: self negative"].	"All bits lost"	oldLen _ self byteSizeOfBytes: aBytesOop.	newLen _ i - b.	self remapOop: aBytesOop in: [newBytes _ interpreterProxy instantiateClass: (interpreterProxy fetchClassOf: aBytesOop)					indexableSize: newLen].	"r _ Integer new: i - b neg: self negative."	"	count _ i.       	"	self		cCoreBytesRshiftCount: i		n: n		m: m		f: f		bytes: b		from: (interpreterProxy firstIndexableField: aBytesOop)		len: oldLen		to: (interpreterProxy firstIndexableField: newBytes)		len: newLen.	^ newBytes! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:45'!digitAddLarge: firstInteger with: secondInteger 	"Does not need to normalize!!"	| over firstLen secondLen shortInt shortLen longInt longLen sum newSum resClass |	self var: #over declareC: 'unsigned char  over'.	firstLen _ self byteSizeOfBytes: firstInteger.	secondLen _ self byteSizeOfBytes: secondInteger.	resClass _ interpreterProxy fetchClassOf: firstInteger.	firstLen <= secondLen		ifTrue: 			[shortInt _ firstInteger.			shortLen _ firstLen.			longInt _ secondInteger.			longLen _ secondLen]		ifFalse: 			[shortInt _ secondInteger.			shortLen _ secondLen.			longInt _ firstInteger.			longLen _ firstLen].	"	sum _ Integer new: len neg: firstInteger negative."	self remapOop: #(shortInt longInt ) in: [sum _ interpreterProxy instantiateClass: resClass indexableSize: longLen].	over _ self				cDigitAdd: (interpreterProxy firstIndexableField: shortInt)				len: shortLen				with: (interpreterProxy firstIndexableField: longInt)				len: longLen				into: (interpreterProxy firstIndexableField: sum).	over > 0		ifTrue: 			["sum _ sum growby: 1."			interpreterProxy remapOop: sum in: [newSum _ interpreterProxy instantiateClass: resClass indexableSize: longLen + 1].			self				cBytesCopyFrom: (interpreterProxy firstIndexableField: sum)				to: (interpreterProxy firstIndexableField: newSum)				len: longLen.			sum _ newSum.			"C index!!"			(self cCoerce: (interpreterProxy firstIndexableField: sum)				to: 'unsigned char *')				at: longLen put: over].	^ sum! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/13/2000 19:24'!digitBitLogic: firstInteger with: secondInteger opIndex: opIx 	"Bit logic here is only implemented for positive integers or Zero; if rec 	or arg is negative, it fails."	| firstLarge secondLarge firstLen secondLen shortLen shortLarge longLen longLarge result |	(interpreterProxy isIntegerObject: firstInteger)		ifTrue: 			[(interpreterProxy integerValueOf: firstInteger)				< 0 ifTrue: [^ interpreterProxy primitiveFail].			"convert it to a not normalized LargeInteger"			self remapOop: secondInteger in: [firstLarge _ self createLargeFromSmallInteger: firstInteger]]		ifFalse: 			[(interpreterProxy fetchClassOf: firstInteger)				= interpreterProxy classLargeNegativeInteger ifTrue: [^ interpreterProxy primitiveFail].			firstLarge _ firstInteger].	(interpreterProxy isIntegerObject: secondInteger)		ifTrue: 			[(interpreterProxy integerValueOf: secondInteger)				< 0 ifTrue: [^ interpreterProxy primitiveFail].			"convert it to a not normalized LargeInteger"			self remapOop: firstLarge in: [secondLarge _ self createLargeFromSmallInteger: secondInteger]]		ifFalse: 			[(interpreterProxy fetchClassOf: secondInteger)				= interpreterProxy classLargeNegativeInteger ifTrue: [^ interpreterProxy primitiveFail].			secondLarge _ secondInteger].	firstLen _ self byteSizeOfBytes: firstLarge.	secondLen _ self byteSizeOfBytes: secondLarge.	firstLen < secondLen		ifTrue: 			[shortLen _ firstLen.			shortLarge _ firstLarge.			longLen _ secondLen.			longLarge _ secondLarge]		ifFalse: 			[shortLen _ secondLen.			shortLarge _ secondLarge.			longLen _ firstLen.			longLarge _ firstLarge].	self remapOop: #(shortLarge longLarge ) in: [result _ interpreterProxy instantiateClass: interpreterProxy classLargePositiveInteger indexableSize: longLen].	self		cByteOp: opIx		short: (interpreterProxy firstIndexableField: shortLarge)		len: shortLen		long: (interpreterProxy firstIndexableField: longLarge)		len: longLen		into: (interpreterProxy firstIndexableField: result).	interpreterProxy failed ifTrue: [^ 0].	^ self normalizePositive: result! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:45'!digitCompareLarge: firstInteger with: secondInteger 	"Compare the magnitude of firstInteger with that of secondInteger.      	Return a code of 1, 0, -1 for firstInteger >, = , < secondInteger"	| firstLen secondLen |	firstLen _ self byteSizeOfBytes: firstInteger.	secondLen _ self byteSizeOfBytes: secondInteger.	secondLen ~= firstLen		ifTrue: [secondLen > firstLen				ifTrue: [^ -1 asOop: SmallInteger]				ifFalse: [^ 1 asOop: SmallInteger]].	^ (self		cDigitCompare: (interpreterProxy firstIndexableField: firstInteger)		with: (interpreterProxy firstIndexableField: secondInteger)		len: firstLen)		asOop: SmallInteger! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:45'!digitDivLarge: firstInteger with: secondInteger negative: neg 	"Does not normalize."	"Division by zero has to be checked in caller."	| firstLen secondLen resultClass l d div rem quo result |	firstLen _ self byteSizeOfBytes: firstInteger.	secondLen _ self byteSizeOfBytes: secondInteger.	neg		ifTrue: [resultClass _ interpreterProxy classLargeNegativeInteger]		ifFalse: [resultClass _ interpreterProxy classLargePositiveInteger].	l _ firstLen - secondLen + 1.	l <= 0		ifTrue: 			[self remapOop: firstInteger in: [result _ interpreterProxy instantiateClass: interpreterProxy classArray indexableSize: 2].			result stAt: 1 put: (0 asOop: SmallInteger).			result stAt: 2 put: firstInteger.			^ result].	"set rem and div to copies of firstInteger and secondInteger, respectively. 	  However,  	 to facilitate use of Knuth's algorithm, multiply rem and div by 2 (that 	 is, shift)   	 until the high byte of div is >=128"	d _ 8 - (self cHighBit: (self unsafeByteOf: secondInteger at: secondLen)).	self remapOop: firstInteger		in: 			[div _ self bytes: secondInteger Lshift: d.			div _ self bytesOrInt: div growTo: (self digitLength: div)							+ 1].	self remapOop: div		in: 			[rem _ self bytes: firstInteger Lshift: d.			(self digitLength: rem)				= firstLen ifTrue: [rem _ self bytesOrInt: rem growTo: firstLen + 1]].	self remapOop: #(div rem ) in: [quo _ interpreterProxy instantiateClass: resultClass indexableSize: l].	self		cCoreDigitDivDiv: (interpreterProxy firstIndexableField: div)		len: (self digitLength: div)		rem: (interpreterProxy firstIndexableField: rem)		len: (self digitLength: rem)		quo: (interpreterProxy firstIndexableField: quo)		len: (self digitLength: quo).	self remapOop: #(quo ) in: [rem _ self					bytes: rem					Rshift: d					bytes: 0					lookfirst: (self digitLength: div)							- 1].	"^ Array with: quo with: rem"	self remapOop: #(quo rem ) in: [result _ interpreterProxy instantiateClass: interpreterProxy classArray indexableSize: 2].	result stAt: 1 put: quo.	result stAt: 2 put: rem.	^ result! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:46'!digitMultiplyLarge: firstInteger with: secondInteger negative: neg 	"Normalizes."	| firstLen secondLen shortInt shortLen longInt longLen prod resultClass |	firstLen _ self byteSizeOfBytes: firstInteger.	secondLen _ self byteSizeOfBytes: secondInteger.	firstLen <= secondLen		ifTrue: 			[shortInt _ firstInteger.			shortLen _ firstLen.			longInt _ secondInteger.			longLen _ secondLen]		ifFalse: 			[shortInt _ secondInteger.			shortLen _ secondLen.			longInt _ firstInteger.			longLen _ firstLen].	neg		ifTrue: [resultClass _ interpreterProxy classLargeNegativeInteger]		ifFalse: [resultClass _ interpreterProxy classLargePositiveInteger].	self remapOop: #(shortInt longInt ) in: [prod _ interpreterProxy instantiateClass: resultClass indexableSize: longLen + shortLen].	self		cDigitMultiply: (interpreterProxy firstIndexableField: shortInt)		len: shortLen		with: (interpreterProxy firstIndexableField: longInt)		len: longLen		into: (interpreterProxy firstIndexableField: prod).	^ self normalize: prod! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 3/11/2000 19:47'!digitSubLarge: firstInteger with: secondInteger 	"Normalizes."	| firstLen secondLen class larger largerLen smaller smallerLen neg resLen res firstNeg |	firstNeg _ (interpreterProxy fetchClassOf: firstInteger)				= interpreterProxy classLargeNegativeInteger.	firstLen _ self byteSizeOfBytes: firstInteger.	secondLen _ self byteSizeOfBytes: secondInteger.	firstLen = secondLen		ifTrue: 			[[(self digitOfBytes: firstInteger at: firstLen)				= (self digitOfBytes: secondInteger at: firstLen) and: [firstLen > 1]]				whileTrue: [firstLen _ firstLen - 1].			secondLen _ firstLen].	(firstLen < secondLen		or: [firstLen = secondLen and: [(self digitOfBytes: firstInteger at: firstLen)					< (self digitOfBytes: secondInteger at: firstLen)]])		ifTrue: 			[larger _ secondInteger.			largerLen _ secondLen.			smaller _ firstInteger.			smallerLen _ firstLen.			neg _ firstNeg == false]		ifFalse: 			[larger _ firstInteger.			largerLen _ firstLen.			smaller _ secondInteger.			smallerLen _ secondLen.			neg _ firstNeg].	resLen _ largerLen.	neg		ifTrue: [class _ interpreterProxy classLargeNegativeInteger]		ifFalse: [class _ interpreterProxy classLargePositiveInteger].	self remapOop: #(smaller larger ) in: [res _ interpreterProxy instantiateClass: class indexableSize: resLen].	self		cDigitSub: (interpreterProxy firstIndexableField: smaller)		len: smallerLen		with: (interpreterProxy firstIndexableField: larger)		len: largerLen		into: (interpreterProxy firstIndexableField: res).	^ self normalize: res! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 12/22/1999 14:34'!normalize: aLargeInteger 	"Check for leading zeroes and return shortened copy if so."	(interpreterProxy fetchClassOf: aLargeInteger)		= interpreterProxy classLargePositiveInteger		ifTrue: [^ self normalizePositive: aLargeInteger]		ifFalse: [^ self normalizeNegative: aLargeInteger]! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 1/23/2000 18:14'!normalizeNegative: aLargeNegativeInteger 	"Check for leading zeroes and return shortened copy if so"	"First establish len = significant length"	| sLen val len oldLen minVal |	len _ oldLen _ self digitLength: aLargeNegativeInteger.	[len ~= 0 and: [(self unsafeByteOf: aLargeNegativeInteger at: len)			= 0]]		whileTrue: [len _ len - 1].	len = 0 ifTrue: [^ 0 asOop: SmallInteger].	"Now check if in SmallInteger range"	sLen _ 4.	"SmallInteger minVal digitLength"	len <= sLen		ifTrue: 			["SmallInteger minVal"			minVal _ -1073741824.			(len < sLen or: [(self digitOfBytes: aLargeNegativeInteger at: sLen)					< (self cDigitOfCSI: minVal at: sLen)				"minVal lastDigit"])				ifTrue: 					["If high digit less, then can be small"					val _ 0.					len						to: 1						by: -1						do: [:i | val _ val * 256 - (self unsafeByteOf: aLargeNegativeInteger at: i)].					^ val asOop: SmallInteger].			1 to: sLen do: [:i | "If all digits same, then = minVal (sr: minVal digits 1 to 3 are 				          0)"				(self digitOfBytes: aLargeNegativeInteger at: i)					= (self cDigitOfCSI: minVal at: i)					ifFalse: ["Not so; return self shortened"						len < oldLen							ifTrue: ["^ self growto: len"								^ self bytes: aLargeNegativeInteger growTo: len]							ifFalse: [^ aLargeNegativeInteger]]].			^ minVal asOop: SmallInteger].	"Return self, or a shortened copy"	len < oldLen		ifTrue: ["^ self growto: len"			^ self bytes: aLargeNegativeInteger growTo: len]		ifFalse: [^ aLargeNegativeInteger]! !!LargeIntegersPlugin methodsFor: 'oop functions' stamp: 'sr 1/23/2000 18:14'!normalizePositive: aLargePositiveInteger 	"Check for leading zeroes and return shortened copy if so"	"First establish len = significant length"	| sLen val len oldLen |	len _ oldLen _ self digitLength: aLargePositiveInteger.	[len ~= 0 and: [(self unsafeByteOf: aLargePositiveInteger at: len)			= 0]]		whileTrue: [len _ len - 1].	len = 0 ifTrue: [^ 0 asOop: SmallInteger].	"Now check if in SmallInteger range"	sLen _ 4.	"SmallInteger maxVal digitLength."	(len <= sLen and: [(self digitOfBytes: aLargePositiveInteger at: sLen)			<= (self cDigitOfCSI: 1073741823 at: sLen)		"SmallInteger maxVal"])		ifTrue: 			["If so, return its SmallInt value"			val _ 0.			len				to: 1				by: -1				do: [:i | val _ val * 256 + (self unsafeByteOf: aLargePositiveInteger at: i)].			^ val asOop: SmallInteger].	"Return self, or a shortened copy"	len < oldLen		ifTrue: ["^ self growto: len"			^ self bytes: aLargePositiveInteger growTo: len]		ifFalse: [^ aLargePositiveInteger]! !!LargeIntegersPlugin methodsFor: 'oop util' stamp: 'sr 3/11/2000 19:44'!bytes: aBytesObject growTo: newLen 	"Attention: this method invalidates all oop's!! Only newBytes is valid at    	     return."	"Does not normalize."	| newBytes oldLen copyLen |	self remapOop: aBytesObject in: [newBytes _ interpreterProxy instantiateClass: (interpreterProxy fetchClassOf: aBytesObject)					indexableSize: newLen].	oldLen _ self byteSizeOfBytes: aBytesObject.	oldLen < newLen		ifTrue: [copyLen _ oldLen]		ifFalse: [copyLen _ newLen].	self		cBytesCopyFrom: (interpreterProxy firstIndexableField: aBytesObject)		to: (interpreterProxy firstIndexableField: newBytes)		len: copyLen.	^ newBytes! !!LargeIntegersPlugin methodsFor: 'oop util' stamp: 'sr 1/23/2000 04:52'!bytesOrInt: oop growTo: len 	"Attention: this method invalidates all oop's!! Only newBytes is valid at    	          return."	| newBytes val class |	(interpreterProxy isIntegerObject: oop)		ifTrue: 			[val _ interpreterProxy integerValueOf: oop.			val < 0				ifTrue: [class _ interpreterProxy classLargeNegativeInteger]				ifFalse: [class _ interpreterProxy classLargePositiveInteger].			newBytes _ interpreterProxy instantiateClass: class indexableSize: len.			self cCopyIntVal: val toBytes: newBytes]		ifFalse: [newBytes _ self bytes: oop growTo: len].	^ newBytes! !!LargeIntegersPlugin methodsFor: 'oop util' stamp: 'sr 1/23/2000 04:53'!createLargeFromSmallInteger: anOop 	"anOop has to be a SmallInteger!!"	| val class size res pByte |	self var: #pByte declareC: 'unsigned char *  pByte'.	val _ interpreterProxy integerValueOf: anOop.	val < 0		ifTrue: [class _ interpreterProxy classLargeNegativeInteger]		ifFalse: [class _ interpreterProxy classLargePositiveInteger].	size _ self cDigitLengthOfCSI: val.	res _ interpreterProxy instantiateClass: class indexableSize: size.	pByte _ interpreterProxy firstIndexableField: res.	1 to: size do: [:ix | pByte at: ix - 1 put: (self cDigitOfCSI: val at: ix)].	^ res! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 3/11/2000 19:42'!byteSizeOfBytes: bytesOop 	"Precondition: bytesOop is not anInteger and a bytes object."	"Function #byteSizeOf: is used by the interpreter, be careful with name  	     clashes..."	^ interpreterProxy slotSizeOf: bytesOop! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 3/11/2000 19:46'!digitLength: oop 	(interpreterProxy isIntegerObject: oop)		ifTrue: [^ self cDigitLengthOfCSI: (interpreterProxy integerValueOf: oop)]		ifFalse: [^ self byteSizeOfBytes: oop]! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 1/23/2000 18:10'!digitOf: oop at: ix 	(interpreterProxy isIntegerObject: oop)		ifTrue: [^ self cDigitOfCSI: (interpreterProxy integerValueOf: oop)				at: ix]		ifFalse: [^ self digitOfBytes: oop at: ix]! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 3/11/2000 19:46'!digitOfBytes: aBytesOop at: ix 	"Argument has to be aLargeInteger!!"	ix > (self byteSizeOfBytes: aBytesOop)		ifTrue: [^ 0]		ifFalse: [^ self unsafeByteOf: aBytesOop at: ix]! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 12/27/1999 22:01'!unsafeByteOf: bytesOop at: ix "Argument bytesOop must not be aSmallInteger!!"	^ interpreterProxy integerValueOf: (interpreterProxy stObject: bytesOop at: ix)! !!LargeIntegersPlugin methodsFor: 'debugging' stamp: 'sr 4/8/2000 02:30'!assert: aBool 	self		debugCode: 			[aBool				ifFalse: 					[self msg: 'Assertion failed!!'.					self cCode: 'exit(1)'						inSmalltalk: 							[interpreterProxy primitiveFail.							self halt]].			^ true]! !!LargeIntegersPlugin methodsFor: 'debugging' stamp: 'sr 3/14/2000 23:43'!msg: s 	self var: #s declareC: 'char *s'.	self cCode: 'fprintf(stderr, "\n%s: %s", moduleName, s)' inSmalltalk: [Transcript cr; show: self class moduleName , ': ' , s; endEntry]! !!LargeIntegersPlugin methodsFor: 'debugging' stamp: 'sr 3/14/2000 23:01'!think	"Flag for marking methods for later thinking."	^ self msg: '#think should not be called'! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 3/13/2000 17:04'!cByteOp: opIndex short: pByteShort len: shortLen long: pByteLong len: longLen into: pByteRes 	"pByteRes len = longLen."	| limit |	self var: #pByteShort declareC: 'unsigned char * pByteShort'.	self var: #pByteLong declareC: 'unsigned char * pByteLong'.	self var: #pByteRes declareC: 'unsigned char * pByteRes'.	self var: #shortLen declareC: 'int shortLen'.	self var: #longLen declareC: 'int longLen'.	self var: #limit declareC: 'int limit'.	limit _ shortLen - 1.	opIndex = andOpIndex		ifTrue: 			[0 to: limit do: [:i | pByteRes at: i put: ((pByteShort at: i)						bitAnd: (pByteLong at: i))].			limit _ longLen - 1.			shortLen to: limit do: [:i | pByteRes at: i put: 0].			^ 0].	opIndex = orOpIndex		ifTrue: 			[0 to: limit do: [:i | pByteRes at: i put: ((pByteShort at: i)						bitOr: (pByteLong at: i))].			limit _ longLen - 1.			shortLen to: limit do: [:i | pByteRes at: i put: (pByteLong at: i)].			^ 0].	opIndex = xorOpIndex		ifTrue: 			[0 to: limit do: [:i | pByteRes at: i put: ((pByteShort at: i)						bitXor: (pByteLong at: i))].			limit _ longLen - 1.			shortLen to: limit do: [:i | pByteRes at: i put: (pByteLong at: i)].			^ 0].	^ interpreterProxy primitiveFail! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/24/1999 05:57'!cBytesLshift: shiftCount from: pFrom len: lenFrom to: pTo len: lenTo 	"C indexed!!"	| byteShift bitShift carry rShift mask limit digit lastIx |	self returnTypeC: 'int'.	self var: #pTo declareC: 'unsigned char * pTo'.	self var: #pFrom declareC: 'unsigned char * pFrom'.	self var: #lenFrom declareC: 'int lenFrom'.	self var: #lenTo declareC: 'int lenTo'.	byteShift _ shiftCount // 8.	bitShift _ shiftCount \\ 8.	bitShift = 0 ifTrue: ["Fast version for byte-aligned shifts"		"C indexed!!"		^ self			cBytesReplace: pTo			from: byteShift			to: lenTo - 1			with: pFrom			startingAt: 0].	carry _ 0.	rShift _ bitShift - 8.	mask _ 255 bitShift: 0 - bitShift.	limit _ byteShift - 1.	0 to: limit do: [:i | pTo at: i put: 0].	limit _ lenTo - byteShift - 2.	self assert: limit < lenFrom.	0 to: limit do: 		[:i | 		digit _ pFrom at: i.		pTo at: i + byteShift put: (((digit bitAnd: mask)				bitShift: bitShift)				bitOr: carry).		carry _ digit bitShift: rShift].	lastIx _ limit + 1.	lastIx > (lenFrom - 1)		ifTrue: [digit _ 0]		ifFalse: [digit _ pFrom at: lastIx].	pTo at: lastIx + byteShift put: (((digit bitAnd: mask)			bitShift: bitShift)			bitOr: carry).	carry _ digit bitShift: rShift.	self assert: carry = 0! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/23/1999 18:46'!cCoreBytesRshiftCount: count n: n m: m f: f bytes: b from: pFrom len: fromLen to: pTo len: toLen 	| x digit |	self var: #pTo declareC: 'unsigned char * pTo'.	self var: #pFrom declareC: 'unsigned char * pFrom'.	self assert: b < fromLen.	x _ (pFrom at: b)				bitShift: n.	self assert: count - 1 < fromLen.	b + 1 to: count - 1 do: 		[:j | 		digit _ pFrom at: j.		pTo at: j - b - 1 put: (((digit bitAnd: m)				bitShift: f)				bitOr: x).		"Avoid values > 8 bits"		x _ digit bitShift: n].	count = fromLen				ifTrue: [digit _ 0]				ifFalse: [digit _ pFrom at: count].	pTo at: count - b - 1 put: (((digit bitAnd: m)			bitShift: f)			bitOr: x)! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/27/1999 23:13'!cCoreDigitDivDiv: pDiv len: divLen rem: pRem len: remLen quo: pQuo len: quoLen 	| dl ql dh dnh j qhi qlo t hi lo r3 l a cond |	self var: #pDiv declareC: 'unsigned char * pDiv'.	self var: #pRem declareC: 'unsigned char * pRem'.	self var: #pQuo declareC: 'unsigned char * pQuo'.	dl _ divLen - 1.	"Last actual byte of data"	ql _ quoLen.	dh _ pDiv at: dl - 1.	dl = 1		ifTrue: [dnh _ 0]		ifFalse: [dnh _ pDiv at: dl - 2].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ remLen + 1 - k.		"r1 _ rem digitAt: j."		(pRem at: j - 1)			= dh			ifTrue: [qhi _ qlo _ 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.            				Note that r1,r2 are bytes, not nibbles.            				Be careful not to generate intermediate results exceeding 13  				        bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((pRem at: j - 1)							bitShift: 4)							+ ((pRem at: j - 2)									bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4)							+ ((pRem at: j - 2)									bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi _ (hi bitShift: -4)							+ (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.            				Max of 2 iterations through loop -- see Knuth vol. 2"				j < 3					ifTrue: [r3 _ 0]					ifFalse: [r3 _ pRem at: j - 3].								[(t < hi					or: [t = hi and: [r3 < lo]])					ifTrue: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						cond _ hi >= dh]					ifFalse: [cond _ false].				cond]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: divLen do: 			[:i | 			hi _ (pDiv at: i - 1)						* qhi.			lo _ a + (pRem at: l - 1) - ((hi bitAnd: 15)							bitShift: 4) - ((pDiv at: i - 1)							* qlo).			pRem at: l - 1 put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a _ lo // 256 - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: divLen do: 					[:i | 					a _ (a bitShift: -8)								+ (pRem at: l - 1) + (pDiv at: i - 1).					pRem at: l - 1 put: (a bitAnd: 255).					l _ l + 1]].		pQuo at: quoLen - k put: (qhi bitShift: 4)				+ qlo]! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/17/1999 09:48'!cDigitAdd: pByteShort len: shortLen with: pByteLong len: longLen into: pByteRes 	"pByteRes len = longLen; returns over.."	| accum limit |	self returnTypeC: 'unsigned char'.	self var: #pByteShort declareC: 'unsigned char * pByteShort'.	self var: #pByteLong declareC: 'unsigned char * pByteLong'.	self var: #pByteRes declareC: 'unsigned char * pByteRes'.	self var: #shortLen declareC: 'int shortLen'.	self var: #longLen declareC: 'int longLen'.	self var: #accum declareC: 'int accum'.	self var: #limit declareC: 'int limit'.	accum _ 0.	limit _ shortLen - 1.	0 to: limit do: 		[:i | 		accum _ (accum bitShift: -8)					+ (pByteShort at: i) + (pByteLong at: i).		pByteRes at: i put: (accum bitAnd: 255)].	limit _ longLen - 1.	shortLen to: limit do: 		[:i | 		accum _ (accum bitShift: -8)					+ (pByteLong at: i).		pByteRes at: i put: (accum bitAnd: 255)].	^ accum bitShift: -8! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/27/1999 21:24'!cDigitCompare: pFirst with: pSecond len: len 	"Precondition: pFirst len = pSecond len."	| secondDigit ix firstDigit |	self var: #pFirst declareC: 'unsigned char * pFirst'.	self var: #pSecond declareC: 'unsigned char * pSecond'.	ix _ len - 1.	[ix >= 0]		whileTrue: 			[(secondDigit _ pSecond at: ix) ~= (firstDigit _ pFirst at: ix)				ifTrue: [secondDigit < firstDigit						ifTrue: [^ 1]						ifFalse: [^ -1]].			ix _ ix - 1].	^ 0! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/21/1999 09:56'!cDigitMultiply: pByteShort len: shortLen with: pByteLong len: longLen into: pByteRes 	"pByteRes len = longLen * shortLen"	| limitLong digit k carry limitShort ab |	self returnTypeC: 'unsigned char'.	self var: #pByteShort declareC: 'unsigned char * pByteShort'.	self var: #pByteLong declareC: 'unsigned char * pByteLong'.	self var: #pByteRes declareC: 'unsigned char * pByteRes'.	self var: #shortLen declareC: 'int shortLen'.	self var: #longLen declareC: 'int longLen'.	self var: #carry declareC: 'int carry'.	self var: #limitLong declareC: 'int limitLong'.	self var: #limitShort declareC: 'int limitShort'.	self var: #digit declareC: 'int digit'.	self var: #ab declareC: 'int ab'.	self var: #k declareC: 'int k'.	(shortLen = 1 and: [(pByteShort at: 0)			= 0])		ifTrue: [^ 0].	(longLen = 1 and: [(pByteLong at: 0)			= 0])		ifTrue: [^ 0].	"prod starts out all zero"	limitShort _ shortLen - 1.	0 to: limitShort do: [:i | (digit _ pByteShort at: i) ~= 0			ifTrue: 				[k _ i.				carry _ 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1 (ST)"				"-> Loop invariant: 0<=carry<=0377, k=i+j (C) (?)"				limitLong _ longLen - 1.				0 to: limitLong do: 					[:j | 					ab _ (pByteLong at: j)								* digit + carry + (pByteRes at: k).					carry _ ab bitShift: -8.					pByteRes at: k put: (ab bitAnd: 255).					k _ k + 1].				pByteRes at: k put: carry]].	^ 0! !!LargeIntegersPlugin methodsFor: 'C core' stamp: 'sr 12/22/1999 07:47'!cDigitSub: pByteSmall		len: smallLen		with: pByteLarge		len: largeLen		into: pByteRes	| z limit |	self var: #pByteSmall declareC: 'unsigned char * pByteSmall'.	self var: #pByteLarge declareC: 'unsigned char * pByteLarge'.	self var: #pByteRes declareC: 'unsigned char * pByteRes'.	self var: #smallLen declareC: 'int smallLen'.	self var: #largeLen declareC: 'int largeLen'.	z _ 0.	"Loop invariant is -1<=z<=1"	limit _ smallLen - 1.	0 to: limit do: 		[:i | 		z _ z + (pByteLarge at: i) - (pByteSmall at: i).		pByteRes at: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z _ z // 256].	limit _ largeLen - 1.	smallLen to: limit do: 		[:i | 		z _ z + (pByteLarge at: i) .		pByteRes at: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z _ z // 256].! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'sr 12/21/1999 01:26'!cBytesCopyFrom: pFrom to: pTo len: len 	""	| limit |	self returnTypeC: 'int'.	self var: #pFrom declareC: 'unsigned char * pFrom'.	self var: #pTo declareC: 'unsigned char * pTo'.	self var: #len declareC: 'int len'.	self var: #limit declareC: 'int limit'.	limit _ len - 1.	0 to: limit do: [:i | pTo at: i put: (pFrom at: i)].	^ 0! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'acg 1/1/2000 15:25'!cBytesHighBit: pByte len: len 	"Answer the index (in bits) of the high order bit of the receiver, or zero if the    	 receiver is zero. This method is allowed (and needed) for     	LargeNegativeIntegers as well, since Squeak's LargeIntegers are     	sign/magnitude."	| realLength lastDigit |	self var: #pByte declareC: 'unsigned char *  pByte'.	realLength _ len.	[(lastDigit _ pByte at: realLength - 1) = 0]		whileTrue: [(realLength _ realLength - 1) = 0 ifTrue: [^ 0]].	^  (self cHighBit: lastDigit) + (8 * (realLength - 1))! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'sr 12/23/1999 14:44'!cBytesReplace: pTo from: start to: stop with: pFrom startingAt: repStart 	"C indexed!!"	self returnTypeC: 'int'.	self var: #pTo declareC: 'unsigned char * pTo'.	self var: #pFrom declareC: 'unsigned char * pFrom'.	self var: #start declareC: 'int start'.	self var: #stop declareC: 'int stop'.	self var: #repStart declareC: 'int repStart'.	^ self		cBytesCopyFrom: pFrom + repStart		to: pTo + start		len: stop - start + 1! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'sr 12/27/1999 11:38'!cCopyIntVal: val toBytes: bytes 	| pByte |	self var: #pByte declareC: 'unsigned char *  pByte'.	pByte _ interpreterProxy firstIndexableField: bytes.	1 to: (self cDigitLengthOfCSI: val)		do: [:ix | pByte at: ix - 1 put: (self cDigitOfCSI: val at: ix)]! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'sr 12/12/1999 05:53'!cDigitLengthOfCSI: csi 	"Answer the number of indexable fields of a CSmallInteger. This value is 	   the same as the largest legal subscript."	self returnTypeC: 'int'.	self var: #csi declareC: 'int csi'.	(csi < 256 and: [csi > -256])		ifTrue: [^ 1].	(csi < 65536 and: [csi > -65536])		ifTrue: [^ 2].	(csi < 16777216 and: [csi > -16777216])		ifTrue: [^ 3].	^ 4! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'sr 12/23/1999 15:12'!cDigitOfCSI: csi at: ix 	"Answer the value of an indexable field in the receiver.              	LargePositiveInteger uses bytes of base two number, and each is a       	      'digit' base 256."	"ST indexed!!"	ix < 0 ifTrue: [interpreterProxy primitiveFail].	ix > 4 ifTrue: [^ 0].	csi < 0		ifTrue: 			[self cCode: ''				inSmalltalk: [csi = -1073741824 ifTrue: ["SmallInteger minVal"						"Can't negate minVal -- treat specially"						^ #(0 0 0 64 ) at: ix]].			^ (0 - csi bitShift: 1 - ix * 8)				bitAnd: 255]		ifFalse: [^ (csi bitShift: 1 - ix * 8)				bitAnd: 255]! !!LargeIntegersPlugin methodsFor: 'C core util' stamp: 'sr 12/22/1999 11:53'!cHighBit: uint 	"Answer the index of the high order bit of the argument, or zero if the  	argument is zero."	| shifted bitNo |	self var: #shifted declareC: 'unsigned int  shifted'.	shifted _ uint.	bitNo _ 0.	[shifted < 16]		whileFalse: 			[shifted _ shifted bitShift: -4.			bitNo _ bitNo + 4].	[shifted = 0]		whileFalse: 			[shifted _ shifted bitShift: -1.			bitNo _ bitNo + 1].	^ bitNo! !!LargeIntegersPlugin methodsFor: 'ST initialize' stamp: 'sr 3/15/2000 00:57'!initialize	"Initializes ST constants; C's are set by class>>declareCVarsIn:."	self returnTypeC: 'void'.	self cCode: '"nothing to do here"'		inSmalltalk: 			[andOpIndex _ 0.			orOpIndex _ 1.			xorOpIndex _ 2]! !!LargeIntegersPlugin class methodsFor: 'translation' stamp: 'sr 4/8/2000 05:40'!declareCVarsIn: cg 	cg var: 'andOpIndex' declareC: 'const int  andOpIndex = 0'.	cg var: 'orOpIndex' declareC: 'const int  orOpIndex = 1'.	cg var: 'xorOpIndex' declareC: 'const int  xorOpIndex = 2'! !!LargeIntegersPlugin class methodsFor: 'translation' stamp: 'ar 5/17/2000 16:39'!moduleName	^'LargeIntegers'! !!LargeIntegersPlugin class methodsFor: 'instance creation' stamp: 'sr 3/15/2000 01:08'!new	^super new initialize! !!LargeIntegersTest methodsFor: 'as yet unclassified' stamp: 'sr 4/8/2000 22:25'!computeOp: anOpSymbol with: arg1 with: arg2 	| res |	stream cr; print: anOpSymbol; cr.	stream nextPutAll: 'arg1: ';	 print: arg1;	 cr;	 nextPutAll: 'arg2: ';	 print: arg2.	res _ arg1 perform: anOpSymbol with: arg2.	stream cr; nextPutAll: 'res: '; print: res! !!LargeIntegersTest methodsFor: 'as yet unclassified' stamp: 'sr 12/30/1999 12:07'!createTestData	| tmpPos1 tmpPos2 tmpNeg1 tmpNeg2 |	tmpPos1 _ OrderedCollection new.	tmpPos2 _ OrderedCollection new.	tmpPos1 add: 0.	tmpPos2 add: 0.	tmpPos1 add: 1.	tmpPos2 add: 1.	tmpPos1 add: SmallInteger maxVal + 1 * 1000.	tmpPos2 add: SmallInteger maxVal.	tmpPos1 add: SmallInteger maxVal.	tmpPos2 add: 77.	tmpPos1 add: (2 raisedTo: 7).	tmpPos2 add: (2 raisedTo: 7).	tmpPos1 add: (2 raisedTo: 31).	tmpPos2 add: (2 raisedTo: 31).	tmpPos1 add: (2 raisedTo: 7).	tmpPos2 add: (2 raisedTo: 31).	tmpPos1 add: (2 raisedTo: 31).	tmpPos2 add: (2 raisedTo: 7).	tmpPos1 add: (2 raisedTo: 100).	tmpPos2 add: (2 raisedTo: 100)			- 1.	tmpPos1 add: (2 raisedTo: 1000).	tmpPos2 add: (2 raisedTo: 1000)			- 1.	tmpPos1 add: 65535.	tmpPos2 add: 3.	tmpPos1 add: 3.	tmpPos2 add: 65535.	tmpNeg1 _ tmpPos1 collect: [:e | e negated].	tmpNeg2 _ tmpPos2 collect: [:e | e negated].	oc1 _ tmpPos1 , tmpPos1 , tmpNeg1 , tmpNeg1.	oc2 _ tmpPos2 , tmpNeg2 , tmpNeg2 , tmpPos2.	ocShift _ (tmpPos1 collect: [:e | e])				, (tmpPos2 collect: [:e | e]) , (tmpPos1 collect: [:e | e + (2 raisedTo: 32)]) , (tmpPos2 collect: [:e | e + (2 raisedTo: 32)]).	ocShift2 _ OrderedCollection new.	0 to: ocShift size - 1 do: [:ix | ocShift2 add: ix].	ocShift _ ocShift , ocShift.	ocShift2 addAll: (ocShift2 collect: [:e | e negated]).! !!LargeIntegersTest methodsFor: 'as yet unclassified' stamp: 'sr 4/8/2000 23:24'!test	| n |	stream cr; cr; nextPutAll: 'Testing LargeIntegers computations...'.	stream cr; tab; nextPutAll: 'operation symbols shown; ''0'' stands for (avoided) division by ''0'''; cr.	self class name , ': performing arithmetic operations...'		displayProgressAt: Sensor cursorPoint		from: 0		to: oc1 size		during: 			[:bar | 			n _ 0.			oc1 with: oc2 do: 				[:e1 :e2 | 				bar value: (n _ n + 1).				self					computeOp: #+					with: e1					with: e2.				self					computeOp: #-					with: e1					with: e2.				self					computeOp: #*					with: e1					with: e2.				self					computeOp: #bitAnd:					with: e1					with: e2.				self					computeOp: #bitOr:					with: e1					with: e2.				self					computeOp: #bitXor:					with: e1					with: e2.				e2 ~= 0					ifTrue: [self							computeOp: #/							with: e1							with: e2]					ifFalse: [stream nextPutAll: ' 0 ']]].	self class name , ': performing shift operations...'		displayProgressAt: Sensor cursorPoint		from: 0		to: ocShift size		during: 			[:bar | 			n _ 0.			ocShift with: ocShift2 do: 				[:e1 :e2 | 				bar value: (n _ n + 1).				self					computeOp: #bitShift:					with: e1					with: e2]]! !!LargeIntegersTest methodsFor: 'accessing' stamp: 'sr 4/8/2000 22:51'!stream	^stream! !!LargeIntegersTest methodsFor: 'accessing' stamp: 'sr 4/8/2000 22:51'!stream: anObject	stream _ anObject! !!LargeIntegersTest class methodsFor: 'private' stamp: 'ar 5/17/2000 16:06'!doItOn: stream withModule: withModuleFlag 	"Make LargeIntegers computations with logging onto stream."	| tester |	withModuleFlag		ifTrue: [self checkIfCModuleExists				ifFalse: 					[self inform: self name , ': Test *with* module impossible!!' , Character cr asString , self moduleName , ' plugin module isn''t installed properly.'.					^ false]]		ifFalse: [self checkIfCModuleExists				ifTrue: 					[self inform: self name , ': Test *without* module impossible!!' , Character cr asString , self moduleName , ' plugin module has to be renamed or removed from reachable modules path.'.					^ false]].	tester _ self new.	tester stream: (stream notNil			ifTrue: [stream]			ifFalse: [Transcript]).	tester stream cr; nextPutAll: self class name , ': creating test data...'.	tester createTestData.	tester test.	^ true! !!LargeIntegersTest class methodsFor: 'user interface' stamp: 'sr 4/9/2000 00:24'!bigFactorial: anInteger depth: depth 	"Computationally very expensive!!"	depth > 1		ifTrue: [^ (self bigFactorial: anInteger depth: depth - 1) factorial]		ifFalse: [^ anInteger factorial]! !!LargeIntegersTest class methodsFor: 'user interface' stamp: 'sr 4/9/2000 00:23'!doItInFile: fileName withModule: withModuleFlag 	"Stores output in a new file named 'filename'.	Param 'withModuleFlag' has to be true, if there is a reachable module, false otherwise."	| stream |	stream _ FileStream newFileNamed: fileName.	LargeIntegersTest doItOn: stream withModule: withModuleFlag.	stream close! !!TestCodeGenerator methodsFor: 'initialize' stamp: 'sr 4/8/2000 00:53'!initialize	super initialize.	debugFlag _ false! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'sr 4/8/2000 02:38'!generateDebugCode: aNode on: aStream indent: level 	"Generate the C debug code for this message onto the given stream, if  	compiled in debugMode."	self generateDebugCode		ifTrue: 			[aStream nextPutAll: '/* DebugCode... */';			 cr.			aNode args first				emitCCodeOn: aStream				level: level				generator: self.			aStream tab: level.			aStream nextPutAll: '/* ...DebugCode */']		ifFalse: [aStream nextPutAll: '/* missing DebugCode */']! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'acg 12/31/1999 16:37'!generateRemapOopIn: aNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| idList |	idList _ aNode args first nameOrValue.	idList class == Array ifFalse: [idList _ Array with: idList].	idList do:		[:each | 		 aStream 			nextPutAll: 'interpreterProxy->pushRemappableOop(';			nextPutAll: each asString;			nextPutAll: ');']		separatedBy: [aStream crtab: level].	aStream cr.	aNode args second emitCCodeOn: aStream level: level generator: self.	level timesRepeat: [aStream tab].	idList reversed do:		[:each |		 aStream 			nextPutAll: each asString;			nextPutAll: ' = interpreterProxy->popRemappableOop()']		separatedBy: [aStream nextPut: $;; crtab: level].! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'acg 1/1/2000 22:41'!generateStSize: aNode on: aStream indent: anInteger	aStream nextPutAll: 'interpreterProxy->stSizeOf('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'sr 4/8/2000 00:59'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	super initializeCTranslationDictionary.	pairs _ #(		#asCInt						#generateAsCInt:on:indent:		#asCUnsigned				#generateAsCUnsigned:on:indent:		#asCBoolean					#generateAsCBoolean:on:indent:		#asCDouble					#generateAsCDouble		#asSmallIntegerObj			#generateAsSmallIntegerObj:on:indent:		#asPositiveIntegerObj		#generateAsPositiveIntegerObj:on:indent:		#asBooleanObj				#generateAsBooleanObj:on:indent:		#asFloatObj					#generateAsFloatObj:on:indent:		#asIf:var:					#generateAsIfVar:on:indent:		#asIf:var:asValue:			#generateAsIfVarAsValue:on:indent:		#asIf:var:put:				#generateAsIfVarPut:on:indent:		#field:						#generateField:on:indent:		#field:put:					#generateFieldPut:on:indent:				#class						#generateClass:on:indent:		#stSize						#generateStSize:on:indent:		#stAt:						#generateStAt:on:indent:		#stAt:put:					#generateStAtPut:on:indent:		#asCharPtr					#generateAsCharPtr:on:indent:		#asIntPtr					#generateAsIntPtr:on:indent:		#cPtrAsOop					#generateCPtrAsOop:on:indent:		#next						#generateNext:on:indent:		#asOop:						#generateAsOop:on:indent:		#asValue:					#generateAsValue:on:indent:		#isFloat						#generateIsFloat:on:indent:		#isIndexable					#generateIsIndexable:on:indent:		#isIntegerOop				#generateIsIntegerOop:on:indent:		#isIntegerValue				#generateIsIntegerValue:on:indent:		#FloatOop					#generateIsFloatValue:on:indent:		#isWords					#generateIsWords:on:indent:		#isWordsOrBytes				#generateIsWordsOrBytes:on:indent:		#isPointers					#generateIsPointers:on:indent:		#isNil						#generateIsNil:on:indent:		#isMemberOf:				#generateIsMemberOf:on:indent:		#isKindOf:					#generateIsKindOf:on:indent:		#fromStack:					#generateFromStack:on:indent:		#clone						#generateClone:on:indent		#new						#generateNew:on:indent		#new:						#generateNewSize:on:indent		#superclass					#generateSuperclass:on:indent:		#remapOop:in:				#generateRemapOopIn:on:indent:		#debugCode:					#generateDebugCode:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!TestCodeGenerator methodsFor: 'debug code' stamp: 'sr 4/8/2000 00:52'!generateDebugCode	^ debugFlag! !!TestCodeGenerator methodsFor: 'debug code' stamp: 'sr 4/8/2000 00:52'!generateDebugCode: aBool 	debugFlag _ aBool! !!WriteStream methodsFor: 'character writing' stamp: 'sr 4/8/2000 01:49'!tab: anInteger 	"Append anInteger tab characters to the receiver."	anInteger timesRepeat: [self nextPut: Character tab]! !!TestCodeGenerator reorganize!('initialize' initialize)('building/generating')('transforming' var:as:)('linking' emitLoad:asBooleanValueFrom:on: emitLoad:asCharPtrFrom:on: emitLoad:asFloatPtrFrom:on: emitLoad:asFloatValueFrom:on: emitLoad:asIntPtrFrom:on: emitLoad:asIntegerValueFrom:on: emitLoad:asKindOf:from:on: emitLoad:asMemberOf:from:on: emitLoad:asNakedOopFrom:on: emitLoad:asNonIntegerValueFrom:on: emitLoad:asUnsignedValueFrom:on:)('coercing' ccgLoad:expr:asBooleanValueFrom: ccgLoad:expr:asCharPtrFrom: ccgLoad:expr:asCharPtrFrom:andThen: ccgLoad:expr:asFloatValueFrom: ccgLoad:expr:asIntPtrFrom: ccgLoad:expr:asIntPtrFrom:andThen: ccgLoad:expr:asIntegerValueFrom: ccgLoad:expr:asKindOf:from: ccgLoad:expr:asMemberOf:from: ccgLoad:expr:asNamedPtr:from: ccgLoad:expr:asNamedPtr:from:andThen: ccgLoad:expr:asNonIntegerValueFrom: ccgLoad:expr:asRawOopFrom: ccgLoad:expr:asUnsignedPtrFrom:andThen: ccgLoad:expr:asUnsignedValueFrom: ccgLoad:expr:asWBCharPtrFrom: ccgLoad:expr:asWBFloatPtrFrom: ccgLoad:expr:asWBIntPtrFrom: ccgSetBlock: ccgTVarBlock: ccgValBlock:)('asOop:/asValue:' generateCoerceToBooleanObjectFrom:on: generateCoerceToBooleanValueFrom:on: generateCoerceToFloatObjectFrom:on: generateCoerceToFloatValueFrom:on: generateCoerceToObjectFromPtr:on: generateCoerceToPtr:fromObject:on: generateCoerceToSmallIntegerObjectFrom:on: generateCoerceToSmallIntegerValueFrom:on: generateCoerceToUnsignedObjectFrom:on: generateCoerceToUnsignedValueFrom:on:)('translating builtins' generateAsBooleanObj:on:indent: generateAsCBoolean:on:indent: generateAsCDouble:on:indent: generateAsCInt:on:indent: generateAsCUnsigned:on:indent: generateAsCharPtr:on:indent: generateAsFloatObj:on:indent: generateAsIfVar:on:indent: generateAsIfVarAsValue:on:indent: generateAsIfVarPut:on:indent: generateAsIntPtr:on:indent: generateAsOop:on:indent: generateAsPositiveIntegerObj:on:indent: generateAsSmallIntegerObj:on:indent: generateAsValue:on:indent: generateCPtrAsOop:on:indent: generateClass:on:indent: generateDebugCode:on:indent: generateField:on:indent: generateFieldPut:on:indent: generateFromStack:on:indent: generateIsBytes:on:indent: generateIsFloat:on:indent: generateIsIndexable:on:indent: generateIsInteger:on:indent: generateIsIntegerOop:on:indent: generateIsIntegerValue:on:indent: generateIsKindOf:on:indent: generateIsMemberOf:on:indent: generateIsPointers:on:indent: generateIsWords:on:indent: generateIsWordsOrBytes:on:indent: generateNext:on:indent: generateRemapOopIn:on:indent: generateStAt:on:indent: generateStAtPut:on:indent: generateStSize:on:indent: initializeCTranslationDictionary)('debug code' generateDebugCode generateDebugCode:)('as yet unclassified' translationMethodClass)!!LargeIntegersPlugin class reorganize!('translation' declareCVarsIn: moduleName)('instance creation' new)!!LargeIntegersPlugin reorganize!('Integer primitives' primDigitAdd: primDigitBitAnd: primDigitBitOr: primDigitBitShift: primDigitBitXor: primDigitCompare: primDigitDiv:negative: primDigitMultiply:negative: primDigitSubtract: primNormalizeNegative primNormalizePositive)('development primitives' primDigit:bitShift: primDigitAdd:with: primDigitBitLogic:with:op: primDigitCompare:with: primDigitDiv:with:negative: primDigitMultiply:with:negative: primDigitSubtract:with: primNormalize:)('control & support primitives' primAsLargeInteger: primCheckIfCModuleExists)('oop functions' bytes:Lshift: bytes:Rshift:bytes:lookfirst: digitAddLarge:with: digitBitLogic:with:opIndex: digitCompareLarge:with: digitDivLarge:with:negative: digitMultiplyLarge:with:negative: digitSubLarge:with: normalize: normalizeNegative: normalizePositive:)('oop util' bytes:growTo: bytesOrInt:growTo: createLargeFromSmallInteger:)('util' byteSizeOfBytes: digitLength: digitOf:at: digitOfBytes:at: unsafeByteOf:at:)('debugging' assert: msg: think)('C core' cByteOp:short:len:long:len:into: cBytesLshift:from:len:to:len: cCoreBytesRshiftCount:n:m:f:bytes:from:len:to:len: cCoreDigitDivDiv:len:rem:len:quo:len: cDigitAdd:len:with:len:into: cDigitCompare:with:len: cDigitMultiply:len:with:len:into: cDigitSub:len:with:len:into:)('C core util' cBytesCopyFrom:to:len: cBytesHighBit:len: cBytesReplace:from:to:with:startingAt: cCopyIntVal:toBytes: cDigitLengthOfCSI: cDigitOfCSI:at: cHighBit:)('ST initialize' initialize)!