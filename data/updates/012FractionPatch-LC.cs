'From Squeak 1.31 of Feb 4, 1998 on 11 May 1998 at 2:09:28 am'!"Change Set:		FractionPatchDate:			11 May 1998Author:			Leandro CanigliaFraction|+ and Fraction|*----------------------------My previous versions of Fraction|+ and Fraction|* had a problem:When the result was an Integer, they returned a Fraction withdenominator = 1. For instance: (1/2) + (1/2) answered (1/1) not 1 and(1/2) * 2 answered (1/1) not 1.I've fixed these problems in this change set. Also I've eliminateda temporary in Fraction|+.Integer|gcd:-------------The change set also includes an implementation of #gcd: forLargeIntegers. It's from Knuthand I've used the notation and comments found in the book.email: caniglia@sugarweb.com"!!Fraction methodsFor: 'arithmetic' stamp: 'LC 5/11/98 01:29'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction		ifTrue: 			[d1 _ numerator gcd: aNumber denominator.			d2 _ denominator gcd: aNumber numerator.			(d2 = denominator and: [d1 = aNumber denominator])				ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].			^ Fraction numerator: numerator // d1 * (aNumber numerator // d2) denominator: denominator // d2 * (aNumber denominator // d1)]		ifFalse: [^ (aNumber adaptFraction: self)				* aNumber adaptToFraction]! !!Fraction methodsFor: 'arithmetic' stamp: 'LC 5/11/98 01:30'!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction		ifTrue: 			[d _ denominator gcd: aNumber denominator.			n _ numerator * (d1 _ aNumber denominator // d) + (aNumber numerator * (d2 _ denominator // d)).			d1 _ d1 * d2.			n _ n // (d2 _ n gcd: d).			(d _ d1 * (d // d2)) = 1 ifTrue: [^ n].			^ Fraction numerator: n denominator: d]		ifFalse: [^ (aNumber adaptFraction: self)				+ aNumber adaptToFraction]! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 4/25/98 13:46'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[u class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ u gcd: v! !