'From Squeak2.8alpha of 16 February 2000 [latest update: #2213] on 25 May 2000 at 9:15:00 pm'!"Change Set:		MiscFXFixesDate:			25 May 2000Author:			Andreas RaabMisc improvements for better compatibility between FXBlt and BitBlt.WARNING: The change set has been manually rearranged to prevent bad things from happening (e.g., for the #isColormap test in BitBlt)"!!Bitmap methodsFor: 'testing' stamp: 'ar 5/25/2000 19:42'!isColormap	"Bitmaps were used as color maps for BitBlt.	This method allows to recognize real color maps."	^false! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/25/2000 19:41'!isColormap	^true! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:43'!colorMap: map	"See last part of BitBlt comment. 6/18/96 tk"	(map notNil and:[map isColormap])		ifTrue:[colorMap _ map colors]		ifFalse:[colorMap _ map]! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap	"Return the map used for tallying pixels"	^colorMap! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap: aBitmap	"Install the map used for tallying pixels"	colorMap _ aBitmap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap	"Return the map used for tallying pixels"	^tallyMap! !!FXBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap: aBitmap	"Install the map used for tallying pixels"	tallyMap _ aBitmap! !!FXFormCanvas methodsFor: 'drawing-images' stamp: 'ar 5/25/2000 21:06'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	port sourceKey: nil; sourceMap: nil; destMap: nil;		colorMap: (aForm colormapIfNeededFor: form).	port fillColor: nil.	port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule.! !!FXFormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 19:48'!setFillColor: aColor	"Install a new color used for filling."	| fillColor screen patternWord |	port sourceMap: nil; destMap: nil; colorMap: nil.	port sourceKey: nil.	fillColor _ self shadowColor ifNil:[aColor].	fillColor ifNil:[fillColor _ Color transparent].	fillColor isColor ifFalse:[		(aColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: aColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse:[		port combinationRule: Form over.		port fillPattern: fillColor.		self depth = 8 ifTrue:[			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (fillColor balancedPatternForDepth: 8).			^self]].	"fillColor is some translucent color"	self depth >= 8 ifTrue:[		"We can represent actual transparency"		port fillColor: (fillColor bitPatternForDepth: 32).		port destMap: form colormapToARGB.		port colorMap: form colormapFromARGB.		^port combinationRule: Form blend].	"Less than 8bit depth -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ fillColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/25/2000 19:45'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm _ Bitmap new: (1 bitShift: (depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	cm _ ColorMap colors: cm.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice _ Form extent: width@1 depth: 1.	copyBlt _ (BitBlt toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt _ (BitBlt toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top _ (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom _ (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH _ bottom - top + 1.	slice _ Form extent: 1@newH depth: 1.	copyBlt _ (BitBlt toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt _ (BitBlt toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left _ (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right _ (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/25/2000 19:46'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/25/2000 19:51'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: depth to: destDepth].	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth _ destDepth.	^ cachedColormap _ newMap.! !!ColorForm methodsFor: 'color mapping' stamp: 'ar 5/25/2000 19:50'!colormapIfNeededFor: destForm	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ super colormapIfNeededFor: destForm].	(destForm depth = cachedDepth and:[cachedColormap isColormap]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: (1 bitShift: depth).	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destForm depth)].	cachedDepth _ destForm depth.	^cachedColormap _ ColorMap shifts: nil masks: nil colors: newMap.! !!StringHolderView methodsFor: 'updating' stamp: 'ar 5/25/2000 19:52'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?') ifTrue: [model clearUserEditFlag].		^ self].	stripes _ (Form extent: 16@16 fromStipple: 16r36C9) bits.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel _ self confirm: 'Changes have not been saved.Is it OK to cancel those changes?'.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !