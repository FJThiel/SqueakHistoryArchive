'From Squeak3.1alpha of 5 February 2001 [latest update: #3830] on 14 March 2001 at 8:37:50 am'!"Change Set:		buttonProps2Date:			9 March 2001Author:			Bob ArningIntegration of button properties into:- general properties (magenta halo handle)- scripts (as alternative button to fire script)"Preferences	addPreference: #useButtonProprtiesToFire 	category: #scripting 	default: false 	balloonHelp: 'For testing - uses newer button properties code to build the button used to fire the script' !!Object methodsFor: 'scripting' stamp: 'RAA 3/9/2001 17:08'!evaluateUnloggedForSelf: aCodeString	^Compiler evaluate:		aCodeString		for: self		logged: false! !!ButtonProperties methodsFor: 'initialization' stamp: 'RAA 3/9/2001 09:47'!initialize	wantsRolloverIndicator _ false.	delayBetweenFirings _ nil.	mouseOverHaloWidth _ 10.	mouseOverHaloColor _ Color blue alpha: 0.3.	mouseDownHaloWidth _ 15.	mouseDownHaloColor _ Color blue alpha: 0.7.	arguments _ #().! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 09:43'!actWhen	^ actWhen! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 09:43'!actWhen: condition	(#(buttonDown mouseDown) includes: condition) ifTrue: [ actWhen _ #mouseDown ].	(#(buttonUp mouseUp) includes: condition) ifTrue: [ actWhen _ #mouseUp ].	(#(whilePressed mouseStillDown) includes: condition) ifTrue: [ actWhen _ #mouseStillDown ].	self setEventHandlers: true.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 11:40'!bringUpToDate	self establishEtoyLabelWording! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 11:47'!establishEtoyLabelWording	"Set the label wording, unless it has already been manually edited"	| itsName |	self isTileScriptingElement ifFalse: [^self].	itsName _ target externalName.	self addTextToButton: itsName, ' ', arguments first.	visibleMorph setBalloonText: 		'click to run the script "', 		arguments first, 		'" in player named "', 		itsName, '"'! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 11:47'!isTileScriptingElement	actionSelector == #runScript: ifFalse: [^false].	arguments isEmptyOrNil ifTrue: [^false].	^target isKindOf: Player! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/10/2001 13:57'!setEventHandlers: enabled	enabled ifTrue: [		visibleMorph on: #mouseDown send: #mouseDown: to: self.		visibleMorph on: #mouseStillDown send: #mouseStillDown: to: self.		visibleMorph on: #mouseUp send: #mouseUp: to: self.		visibleMorph on: #mouseEnter send: #mouseEnter: to: self.		visibleMorph on: #mouseLeave send: #mouseLeave: to: self.	] ifFalse: [		#(mouseDown mouseStillDown mouseUp mouseEnter mouseLeave) do: [ :sel |			visibleMorph on: sel send: nil to: nil		].	].! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/10/2001 13:59'!wantsRolloverIndicator: aBoolean	wantsRolloverIndicator _ aBoolean.	wantsRolloverIndicator ifTrue: [		self setEventHandlers: true.	].! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 08:58'!doButtonAction		self doButtonAction: nil! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 17:08'!doButtonAction: evt	| arity |	target ifNil: [^self].	actionSelector ifNil: [^self].	arguments ifNil: [arguments _ #()].	Cursor normal showWhile: [		arity _ actionSelector numArgs.		arity = arguments size ifTrue: [			target perform: actionSelector withArguments: arguments		].		arity = (arguments size + 1) ifTrue: [			target perform: actionSelector withArguments: {evt},arguments		].		arity = (arguments size + 2) ifTrue: [			target perform: actionSelector withArguments: {evt. visibleMorph},arguments		].	]! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 10:02'!mouseDown: evt	mouseDownTime _ Time millisecondClockValue.	nextTimeToFire _ nil.	delayBetweenFirings ifNotNil: [		nextTimeToFire _ mouseDownTime + delayBetweenFirings.	].	self wantsRolloverIndicator ifTrue: [		visibleMorph 			addMouseActionIndicatorsWidth: mouseDownHaloWidth 			color: mouseDownHaloColor.	].	actWhen == #mouseDown ifFalse: [^self].	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	self doButtonAction: evt."=====	aMorph .	now _ Time millisecondClockValue.	oldColor _ color. 	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [	self updateVisualState: evt; refreshWorld].	dt _ Time millisecondClockValue - now max: 0.	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	self mouseStillDown: evt.====="! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 08:57'!mouseStillDown: evt	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	nextTimeToFire ifNil: [^self].	nextTimeToFire <= Time millisecondClockValue ifTrue: [		self doButtonAction: evt.		nextTimeToFire _ Time millisecondClockValue + self delayBetweenFirings.		^self	].! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 08:57'!mouseUp: evt	visibleMorph deleteAnyMouseActionIndicators.	mouseDownTime _ nextTimeToFire _ nil.	actWhen == #mouseUp ifFalse: [^self].	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	self doButtonAction: evt.! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 12:27'!replaceVisibleMorph: aNewMorph	| old oldOwner oldText |	old _ visibleMorph.	oldText _ self currentTextInButton.	self visibleMorph: nil.	old buttonProperties: nil.	aNewMorph buttonProperties: self.	self visibleMorph: aNewMorph.	self addTextToButton: oldText.	oldOwner _ old owner ifNil: [^self].	oldOwner replaceSubmorph: old by: aNewMorph.! !!Morph methodsFor: 'scripting' stamp: 'RAA 3/9/2001 11:39'!bringUpToDate	(self buttonProperties ifNil: [^self]) bringUpToDate! !!Morph methodsFor: 'scripting' stamp: 'RAA 3/9/2001 11:47'!isTileScriptingElement	^ self hasButtonProperties and: [self buttonProperties isTileScriptingElement]! !!Morph methodsFor: 'e-toy support' stamp: 'RAA 3/9/2001 14:37'!setAsActionInButtonProperties: buttonProperties	^false	"means I don't know how to be set as a button action"! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 3/10/2001 13:54'!acceptDroppingMorph: aMorph event: evt	| handlerForDrops |	handlerForDrops _ self valueOfProperty: #handlerForDrops ifAbsent: [		^super acceptDroppingMorph: aMorph event: evt	].	(handlerForDrops acceptDroppingMorph: aMorph event: evt in: self) ifFalse: [		aMorph rejectDropMorphEvent: evt.		"send it back where it came from"	].! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 3/14/2001 08:36'!wantsDroppedMorph: aMorph event: evt	| handlerForDrops |	handlerForDrops _ self valueOfProperty: #handlerForDrops ifAbsent: [		^super wantsDroppedMorph: aMorph event: evt	].	^handlerForDrops wantsDroppedMorph: aMorph event: evt in: self! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:06'!buildFakeSlider: nameStringOrSymbol selector: aSymbol help: helpString	| col |	col _ self inAColumn: {		(nameStringOrSymbol isKindOf: Symbol) ifTrue: [	 		UpdatingStringMorph new				useStringFormat;				getSelector: nameStringOrSymbol;				target: self;				growable: true;				minimumWidth: 24;				lock.		] ifFalse: [			self lockedString: nameStringOrSymbol.		].	}.	col 		borderWidth: 2;		borderColor: color darker;		color: color muchLighter;		hResizing: #shrinkWrap;		setBalloonText: helpString;		on: #mouseMove send: #mouseAdjust:in: to: self;		on: #mouseDown send: #mouseAdjust:in: to: self;		on: #mouseUp send: #clearSliderFeedback to: self;		setProperty: #changeSelector toValue: aSymbol.	^col! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:50'!doButtonProperties	myTarget openAButtonPropertySheet.	self delete.! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:50'!doMainProperties	myTarget openAPropertySheet.	self delete.! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:27'!inARow: aCollectionOfMorphs	| row |	row _ AlignmentMorphBob1 newRow		color: Color transparent;		vResizing: #shrinkWrap;		layoutInset: 1;		wrapCentering: #center;		cellPositioning: #leftCenter.	aCollectionOfMorphs do: [ :each | row addMorphBack: each].	^row! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:22'!mouseAdjust: evt in: aMorph	| fractionalPosition feedBack testExtent |	feedBack _ self showSliderFeedback: nil.	feedBack world ifNil: [		feedBack bottomLeft: evt cursorPoint - (0@8)	].	testExtent _ 100@100.		"the real extent may change"	fractionalPosition _ (evt cursorPoint - aMorph topLeft) / testExtent.	self 		perform: (aMorph valueOfProperty: #changeSelector)		with: fractionalPosition! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 13:09'!openNearTarget	| w wb tb leftOverlap rightOverlap topOverlap bottomOverlap best |	w _ myTarget world ifNil: [World].	wb _ w bounds.	self fullBounds.	tb _ myTarget boundsInWorld.	leftOverlap _ self width - (tb left - wb left).	rightOverlap _ self width - (wb right - tb right).	topOverlap _ self height - (tb top - wb top).	bottomOverlap _ self height - (wb bottom - tb bottom).	best _ nil.	{		{leftOverlap. #topRight:. #topLeft}.		{rightOverlap. #topLeft:. #topRight}.		{topOverlap. #bottomLeft:. #topLeft}.		{bottomOverlap. #topLeft:. #bottomLeft}.	} do: [ :tuple |		(best isNil or: [tuple first < best first]) ifTrue: [best _ tuple].	].	self perform: best second with: (tb perform: best third).	self bottom: (self bottom min: wb bottom) rounded.	self right: (self right min: wb right) rounded.	self top: (self top max: wb top) rounded.	self left: (self left max: wb left) rounded.	self openInWorld: w.! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:12'!showSliderFeedback: aString	| feedBack |	feedBack _ self 		valueOfProperty: #sliderFeedback 		ifAbsent: [			feedBack _ AlignmentMorph newRow				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				color: (Color yellow" alpha: 0.6");				addMorph: (					TextMorph new 						contents: '?';						beAllFont: ((TextStyle default fontOfSize: 24) emphasized: 1)				).			self setProperty: #sliderFeedback toValue: feedBack.			feedBack		].	aString ifNotNil: [		feedBack firstSubmorph contents: aString asString.		feedBack world ifNil: [feedBack openInWorld].	].	^feedBack! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/10/2001 13:52'!acceptDroppingMorph: aMorph event: evt in: aSubmorph	| why |	aSubmorph color: Color transparent.	why _ aSubmorph valueOfProperty: #intentOfDroppedMorphs.	why == #changeTargetMorph ifTrue: [		self targetProperties replaceVisibleMorph: aMorph.		myTarget _ aMorph.		self rebuild.		^true	].	why == #changeTargetTarget ifTrue: [		(aMorph setAsActionInButtonProperties: self targetProperties) ifFalse: [			^false		].		^true	].	^false! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:08'!adjustTargetMouseDownHaloSize: aFractionalPoint	self targetProperties mouseDownHaloWidth: ((aFractionalPoint x * 10) rounded max: 0).! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:08'!adjustTargetMouseOverHaloSize: aFractionalPoint	self targetProperties mouseOverHaloWidth: ((aFractionalPoint x * 10) rounded max: 0).! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:14'!adjustTargetRepeatingInterval: aFractionalPoint	| n |	n _ 2 raisedTo: ((aFractionalPoint x * 12) rounded max: 1).	self targetProperties delayBetweenFirings: n.! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 13:03'!attachMorphOfClass: aClass to: aHand	aHand attachMorph: aClass new! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/10/2001 13:36'!doRemoveProperties	myTarget buttonProperties: nil.	self delete.! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:21'!initialize	super initialize.	myTarget ifNil: [myTarget _ RectangleMorph new openInWorld].	self borderWidth: 4.	self layoutInset: 4.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self color: (Color r: 0.935 g: 0.839 b: 0.452).	self borderColor: self color darker.	self useRoundedCorners.	thingsToRevert _ Dictionary new.	thingsToRevert at: #buttonProperties: put: myTarget buttonProperties.	self rebuild.! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 13:02'!mouseDownEvent: evt for: aSubmorph	| why aMenu |	why _ aSubmorph valueOfProperty: #intentOfDroppedMorphs.	why == #changeTargetMorph ifTrue: [		aMenu _ MenuMorph new			defaultTarget: self.		{			{'Rectangle'. RectangleMorph}.			{'Ellipse'. EllipseMorph}		} do: [ :pair |			aMenu					add: pair first 				target: self 				selector: #attachMorphOfClass:to: 				argumentList: {pair second. evt hand}.		].		aMenu popUpEvent: evt in: self world.		^self	].! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:33'!mouseEnterDraggingEvt: evt morph: aMorph	aMorph color: (Color red alpha: 0.5)! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:33'!mouseLeaveDraggingEvt: evt morph: aMorph	aMorph color: Color transparent.! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 09:56'!paneForButtonSelectorReport	^self inARow: {		self lockedString: 'Action: '. 		UpdatingStringMorph new			useStringFormat;			getSelector: #actionSelector;			target: self targetProperties;			growable: true;			minimumWidth: 24;			lock.	}! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/10/2001 13:43'!paneForButtonTargetReport	| r |	r _ self inARow: {		self lockedString: 'Target: '. 		UpdatingStringMorph new			useStringFormat;			getSelector: #target;			target: self targetProperties;			growable: true;			minimumWidth: 24;			lock.	}.	r hResizing: #shrinkWrap.	r on: #mouseEnterDragging send: #mouseEnterDraggingEvt:morph: to: self.	r on: #mouseLeaveDragging send: #mouseLeaveDraggingEvt:morph: to: self.	r setProperty: #handlerForDrops toValue: self.	r setProperty: #intentOfDroppedMorphs toValue: #changeTargetTarget.	r setBalloonText: 'Drop another morph here to change the target and action of this button. (Only some morphs will work)'.	^self inARow: {r}! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:56'!paneForChangeVisibleMorph	| r |	r _ self inARow: {		self lockedString: ' Change morph '.	}.	r on: #mouseDown send: #mouseDownEvent:for: to: self.	r on: #mouseEnterDragging send: #mouseEnterDraggingEvt:morph: to: self.	r on: #mouseLeaveDragging send: #mouseLeaveDraggingEvt:morph: to: self.	r setProperty: #handlerForDrops toValue: self.	r setProperty: #intentOfDroppedMorphs toValue: #changeTargetMorph.	r setBalloonText: 'Drop another morph here to change the visual appearance of this button. Or click here to get a menu of possible replacement morphs.'.	^r! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:07'!paneForMouseDownHaloWidth	^(self inARow: {		self			buildFakeSlider: #valueForMouseDownHaloWidth 			selector: #adjustTargetMouseDownHaloSize:			help: 'Drag in here to change the halo width'	}) hResizing: #shrinkWrap! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:09'!paneForMouseOverHaloWidth	^(self inARow: {		self			buildFakeSlider: #valueForMouseOverHaloWidth			selector: #adjustTargetMouseOverHaloSize:			help: 'Drag in here to change the halo width'	}) hResizing: #shrinkWrap! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:16'!paneForRepeatingInterval	^(self 		inAColumn: {			self				buildFakeSlider: #valueForRepeatingInterval				selector: #adjustTargetRepeatingInterval:				help: 'Drag in here to change how often the button repeats while the mouse is down'		}		 named: #paneForRepeatingInterval	) hResizing: #shrinkWrap! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:19'!paneForWantsFiringWhileDownToggle	^self inARow: {		self			directToggleButtonFor: self 			getter: #targetRepeatingWhileDown			setter: #toggleTargetRepeatingWhileDown			help: 'Turn repeating while mouse is held down on or off'.		self lockedString: ' Mouse-down repeating '.	}! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/10/2001 13:39'!rebuild	| buttonColor |	myTarget ensuredButtonProperties.	self removeAllMorphs.	self addAColumn: {		self lockedString: 'Button Properties for ',myTarget name.	}.	self addAColumn: {		self paneForButtonTargetReport.	}.	self addAColumn: {		self paneForButtonSelectorReport.	}.	self addAColumn: {		(self inAColumn: {			self paneForWantsRolloverToggle.		}) hResizing: #shrinkWrap.	}.	self addARow: {		self paneForMouseOverColorPicker.		self paneForMouseDownColorPicker.	}.	self addAColumn: {		(self inARow: {			self paneForActsOnMouseDownToggle.			self paneForActsOnMouseUpToggle.		})  hResizing: #shrinkWrap.	}.	self addAColumn: {		self inARow: {			(self paneForWantsFiringWhileDownToggle) hResizing: #shrinkWrap.			self paneForRepeatingInterval.		}.	}.	buttonColor _ color lighter.	self addARow: {		self inAColumn: {			self addARow: {				self 					buttonNamed: 'Add label' action: #addTextToTarget color: buttonColor					help: 'add some text to the button'.				self 					buttonNamed: 'Remove label' action: #removeTextFromTarget color: buttonColor					help: 'remove text from the button'.			}.			self addARow: {				self 					buttonNamed: 'Accept' action: #doAccept color: buttonColor					help: 'keep changes made and close panel'.				self 					buttonNamed: 'Cancel' action: #doCancel color: buttonColor					help: 'cancel changes made and close panel'.				self transparentSpacerOfSize: 10@3.				self 					buttonNamed: 'Main' action: #doMainProperties color: color lighter 					help: 'open a main properties panel for the morph'.				self 					buttonNamed: 'Remove' action: #doRemoveProperties color: color lighter 					help: 'remove the button properties of this morph'.			}.		}.		self inAColumn: {			self paneForChangeVisibleMorph		}.	}.! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:08'!valueForMouseDownHaloWidth	^'mouse-down halo width: ',self targetProperties mouseDownHaloWidth printString! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:09'!valueForMouseOverHaloWidth	^'mouse-over halo width: ',self targetProperties mouseOverHaloWidth printString! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:16'!valueForRepeatingInterval	| n s |	n _ self targetProperties delayBetweenFirings.	s _ n ifNil: [		'*none*'	] ifNotNil: [		n < 1000 ifTrue: [n printString,' ms'] ifFalse: [(n // 1000) printString,' secs']	].	^'repeating interval: ',s! !!ButtonPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:31'!wantsDroppedMorph: aMorph event: evt in: aSubmorph	| why |	why _ aSubmorph valueOfProperty: #intentOfDroppedMorphs.	^why notNil" toValue: #changeTargetMorph.	^true"! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:39'!rebuild	self removeAllMorphs.	self addARow: {		self lockedString: 'Properties for ',myTarget name.	}.	self addARow: {		self inAColumn: {			self paneForCornerRoundingToggle.			self paneForStickinessToggle.			self paneForLockedToggle.		}.	}.	self addARow: {		self paneForMainColorPicker.		self paneFor2ndGradientColorPicker.	}.	self addARow: {		self paneForBorderColorPicker.		self paneForShadowColorPicker.	}.	self addARow: {		self 			buttonNamed: 'Accept' action: #doAccept color: color lighter 			help: 'keep changes made and close panel'.		self 			buttonNamed: 'Cancel' action: #doCancel color: color lighter 			help: 'cancel changes made and close panel'.		self transparentSpacerOfSize: 20@3.		self 			buttonNamed: 'Button' action: #doButtonProperties color: color lighter 			help: 'open a button properties panel for the morph'.	}.	thingsToRevert _ Dictionary new.	"thingsToRevert at: #fillStyle: put: myTarget fillStyle."	(myTarget isKindOf: SystemWindow) ifTrue: [		thingsToRevert at: #setWindowColor: put: myTarget paneColorToUse	].	thingsToRevert at: #hasDropShadow: put: myTarget hasDropShadow.	thingsToRevert at: #shadowColor: put: myTarget shadowColor.	(myTarget respondsTo: #borderColor:) ifTrue: [		thingsToRevert at: #borderColor: put: myTarget borderColor.	].	thingsToRevert at: #borderWidth: put: myTarget borderWidth.	thingsToRevert at: #cornerStyle: put: myTarget cornerStyle.	thingsToRevert at: #cornerStyle: put: myTarget cornerStyle.	thingsToRevert at: #sticky: put: myTarget isSticky.	thingsToRevert at: #lock: put: myTarget isLocked.! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'RAA 3/9/2001 18:26'!setAsActionInButtonProperties: buttonProperties	| tempEditor |	tempEditor _ self morphToDropInPasteUp: nil.	userScriptSelector ifNil: [		buttonProperties			target: self associatedPlayer;			actionSelector: #evaluateUnloggedForSelf:;			arguments: {self codeString}.		^true	].	buttonProperties		target: self objectViewed player;		actionSelector: #perform:;		arguments: {userScriptSelector}.	^true"==== or 	buttonProperties		target: (self morphToDropInPasteUp: nil);		actionSelector: #tryMe;		arguments: #().	^true	==="! !!Player methodsFor: 'scripts-kernel' stamp: 'RAA 3/9/2001 11:44'!tearOffButtonToFireScriptForSelector: aSelector	"Tear off a button to fire the script for the given selector"	| aButton props |	Preferences useButtonProprtiesToFire ifFalse: [		aButton _ ScriptActivationButton new target: self.		aButton actionSelector: #runScript:.		aButton arguments: (Array with: aSelector).		aButton establishLabelWording.		self currentHand attachMorph: aButton.		^self	].	aButton _ EllipseMorph new.	props _ aButton ensuredButtonProperties.	props		target: self;		actionSelector: #runScript:;		arguments: {aSelector};		delayBetweenFirings: 128;		actWhen: #mouseUp;		wantsRolloverIndicator: true;		establishEtoyLabelWording.	self currentHand attachMorph: aButton.! !ButtonProperties removeSelector: #extent:!ButtonProperties removeSelector: #fitContents!ButtonProperties removeSelector: #handlesMouseDown:!ButtonProperties removeSelector: #label!ButtonProperties removeSelector: #label:!ButtonProperties removeSelector: #label:font:!ButtonProperties removeSelector: #labelString:!ButtonProperties removeSelector: #objectForDataStream:!