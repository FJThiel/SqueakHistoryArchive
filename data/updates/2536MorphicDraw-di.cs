'From Squeak2.9alpha of 12 June 2000 [latest update: #2535] on 29 August 2000 at 11:16:29 pm'!"Change Set:		MorphicDrawDate:			29 August 2000Author:			Dan IngallsSundry changes to make Morphic a more useful environment for graphical ccomposition.	Ability to make synthetic bold for fonts with chars that have 0 leading.	Introduces LineMorph as a macro for degenerate polygons.	Introduces shift-click for showing and hiding handles of curves and polygons	Shift-click near a hidden vertex shows vertices, and starts drag, then hides vertices.	Introduces a menu item to mutate a polygon to a curve and back again.	Fixes resize so that it no longer clips a pixel when extending the bounds.	Introduces a selection morph for deletion, moving, duplication, color change, etc.		Use by dragging in an empty place in the world,		or choose 'make a selection' from a PasteUpMorph's menu.	Replicate feature:  duplicate/move/duplicate of a selection repeats the same spacing.[Note: the changed order of #layoutChanged and #changed in Morph>>extent: and Morph>>position: is fundamental, and could cause strange behavior almost anywhere.  It should only be an improvement -- it fixes a long-standing bug that would clip pixels while extending morphs with either the resize command or by the halo -- but it could break dependent code]."!BorderedMorph subclass: #PasteUpMorph	instanceVariableNames: 'presenter model cursor padding backgroundMorph turtleTrailsForm turtlePen lastTurtlePositions isPartsBin autoLineLayout indicateCursor resizeToFit fileName isStackLike dataInstances currentDataInstance userFrameRectangle wantsMouseOverHalos worldState griddingOn '	classVariableNames: 'DisableDeferredUpdates MinCycleLapse StillAlive '	poolDictionaries: ''	category: 'Morphic-Worlds'!PolygonMorph subclass: #LineMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!StrikeFont methodsFor: 'character shapes' stamp: 'di 7/16/2000 10:27'!ensureCleanBold 	"This ensures that all character glyphs have at least one pixel of white space on the right	so as not to cause artifacts in neighboring characters in bold or italic."	| wider glyph |	emphasis = 0 ifFalse: [^ self].	minAscii to: maxAscii do:		[:i | glyph _ self characterFormAt: (Character value: i).		(glyph copy: (glyph boundingBox topRight - (1@0)					corner: glyph boundingBox bottomRight)) isAllWhite ifFalse:			[wider _ Form extent: (glyph width + 1)@glyph height.			glyph displayOn: wider at: 0@0.			self characterFormAt: (Character value: i) put: wider]]."StrikeFont allInstancesDo: [:f | f ensureCleanBold].(StrikeFont familyName: 'NewYork' size: 21) ensureCleanBold.StrikeFont shutDown.  'Flush synthetic fonts'."! !!LineMorph commentStamp: 'di 8/20/2000 12:13' prior: 0!This is really only a shell for creating single-segment polygons.!BorderedMorph subclass: #SelectionMorph	instanceVariableNames: 'selectedItems slippage dupLoc dupDelta '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!SelectionMorph commentStamp: 'di 8/28/2000 21:13' prior: 0!A selectionMorph supports the selection of multiple objects in a morphic world or pasteUp.Structure:	selectedItems	an OrderedCollection of Morphs					These are the morphs that have been selected	slippage		a Point					Keeps track of actual movement between the 					steps of gridded movement	dupLoc		a Point					Notes the position when first duplicate request occurs from halo	dupDelta	a Point					Holds the final delta of the first duplicate plus subsequent moves.!!Morph methodsFor: 'copying' stamp: 'di 8/23/2000 22:33'!duplicate	"Make and return a duplicate of the receiver"	| newMorph aName |	aName _ self world nameForCopyIfAlreadyNamed: self.	newMorph _ self veryDeepCopy.	aName ifNotNil: [newMorph setNameTo: aName].	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!Morph methodsFor: 'geometry' stamp: 'di 8/22/2000 07:45'!extent: aPoint	bounds extent = aPoint ifTrue: [^ self].	self changed.	bounds _ bounds topLeft extent: aPoint.	self layoutChanged.	self changed.! !!Morph methodsFor: 'menus' stamp: 'di 8/29/2000 22:02'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	(self isKindOf: PasteUpMorph) ifTrue:		[aMenu add: 'make a selection' action: #makeSelection].	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' action: #makeNewPlayerInstance.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!HaloMorph methodsFor: 'private' stamp: 'di 8/28/2000 15:54'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	(target isKindOf: SelectionMorph) ifTrue:		[^ target doDup: evt fromHalo: self handle: dupHandle].	evt hand setArgument: target.	self setTarget: evt hand duplicateMorph.	self removeAllHandlesBut: dupHandle.! !!HandMorph methodsFor: 'event handling' stamp: 'di 8/29/2000 21:59'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown: evt."Transcript show: m printString; cr."	m ifNotNil:		[aHalo _ m world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [m world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown					ifTrue: [clickClient click: firstClickEvent]					ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab					ifNotNil:						[self grabMorph: rootForGrab]					ifNil:						[self newMouseFocus: m   "trigger automatic viewing, for example"]].		mouseOverTimes removeKey: m ifAbsent: []]! !!HandMorph methodsFor: 'event handling' stamp: 'di 8/23/2000 23:35'!testEvent: evt ifQuickClick: quickClickBlock ifMoved: movedBlock	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	(Delay forMilliseconds: 200) wait.	Sensor anyButtonPressed ifFalse: [^ quickClickBlock value].	((Sensor cursorPoint - evt cursorPoint) abs < (3@3)) ifFalse: [^ movedBlock value]! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 8/29/2000 22:31'!dropMorphsEvent: evt 	"Drop all the morphs this hand is currently holding in response to the 	given event."	"Details: All submorphs of the front-most composite morph under the 	hand are given an opportunity to accept the dropping morph. If none 	of these accepts it, or if there is no morph under the hand, then the 	morph drops into the world."	| newOwner morphToDrop localPt grabbedMorph pos worldUnderCursor |	worldUnderCursor _ self worldUnderCursor.	worldUnderCursor		ifNil: [^ self].	self changed.	self		submorphsReverseDo: [:m | 			"drop in reverse order to maintain back-to-front ordering"			addedFlexAtGrab == true				ifTrue: [pos _ m firstSubmorph position.					grabbedMorph _ m removeFlexShell.					self privateRemoveMorph: grabbedMorph.					grabbedMorph position: pos					"undo offset from removeFlexShell"]				ifFalse: [grabbedMorph _ m].			newOwner _ self dropTargetFor: grabbedMorph event: evt.			newOwner				ifNil: ["Drop not allowed"					self rejectDropMorph: grabbedMorph event: evt.					addedFlexAtGrab == true						ifTrue: [self privateRemoveMorph: m.							addedFlexAtGrab _ false].					^ self].			"Transcript show: newOwner printString; cr."			morphToDrop _ newOwner morphToDropFrom: grabbedMorph.			morphToDrop == grabbedMorph				ifFalse: [submorphs size == 1						ifTrue: [self privateRemoveMorph: m.							m privateOwner: nil.							addedFlexAtGrab _ false]].			"the above says: the thing to drop is not what I was carrying; 			silently vaporize what I was carrying lest it cause trouble 			later; keep the owner/submorph relationship invariant, but 			don't go through the standard delete protocol"			localPt _ newOwner globalPointToLocal: self position.			addedFlexAtGrab == true				ifTrue: [morphToDrop position: (localPt + (morphToDrop position								- (m transform globalPointToLocal: self position))) rounded.					self privateRemoveMorph: m.					addedFlexAtGrab _ false]				ifFalse: [morphToDrop position:							(newOwner gridPoint:								(newOwner globalPointToLocal: morphToDrop position) rounded)].			newOwner acceptDroppingMorph: morphToDrop event: evt.			morphToDrop justDroppedInto: newOwner event: evt.			morphToDrop owner = self				ifTrue: [self world addMorphFront: m]].	currentCommand ifNotNil:		[Command rememberCommand: currentCommand.		currentCommand _ nil].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/29/2000 21:25'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	(argument isKindOf: PasteUpMorph) ifTrue:		[menu add: 'make a selection' action: #makeSelection].	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'delete' action: #dismissMorph.	menu addLine.	menu add: 'copy Postscript' target: argMorph action: #clipPostscript.	menu add: 'print PS to file...' target: argMorph action: #printPSToFile.	menu addLine.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	"Give the argument control over what should be done about fill styles"	argMorph addFillStyleMenuItems: menu hand: self.	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	Smalltalk isMorphic		ifTrue: [menu add: 'inspect' action: #inspectMorph]		ifFalse: [menu add: 'inspect (in MVC)' action: #inspectMorph.				menu add: 'inspect' action: #inspectMorphInMorphic].	menu add: 'explore' target: argument action: #explore.	menu add: 'browse hierarchy' target: argument action: #browseHierarchy.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	(argMorph hasProperty: #resourceFilePath)		ifTrue: [((argMorph valueOfProperty: #resourceFilePath) endsWith: '.morph')				ifTrue: [menu add: 'save as resource' target: argMorph action: #saveAsResource].				menu add: 'update from resource' target: argMorph action: #updateFromResource]		ifFalse: [menu add: 'attach to resource' target: argMorph action: #attachToResource].	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/23/2000 22:17'!duplicateMorph	"Make and return a duplicate of the receiver's argument"	| newMorph |	newMorph _ argument duplicate.	self grabMorphFromMenu: newMorph.	^ newMorph! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/29/2000 22:11'!makeSelection	"Make and grab a new selection"	self attachMorph: (SelectionMorph newBounds: (0@0 extent: 16@16)).	self world abandonAllHalos! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 8/29/2000 21:58'!abandonAllHalos	self haloMorphs do:		[:m | (m target isKindOf: SelectionMorph) ifTrue: [m target delete].		m delete].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 8/29/2000 21:44'!dragThroughOnDesktop: evt	"Draw out a selection rectangle"	| selection |	selection _ SelectionMorph newBounds: (evt cursorPoint extent: 8@8).	self world addMorph: selection.	^ selection extendByHand: evt hand! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 8/23/2000 23:35'!mouseDown: evt	"Handle a mouse down event."	self isWorldMorph		ifTrue:			[evt hand newKeyboardFocus: self.			evt hand testEvent: evt				ifQuickClick: [^ self quickClickOnDesktop: evt]				ifMoved: [^ self dragThroughOnDesktop: evt].			evt hand invokeMetaMenu: evt]		ifFalse:			[^ super mouseDown: evt]! !!PolygonMorph methodsFor: 'access' stamp: 'di 8/28/2000 22:53'!openOrClosePhrase	| curveName |	curveName _ (self isKindOf: CurveMorph) ifTrue: ['curve'] ifFalse: ['polygon'].	^ closed		ifTrue: ['make open ' , curveName]		ifFalse: ['make closed ' , curveName]! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 8/20/2000 14:33'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[^ (self filledForm pixelValueAt: aPoint - bounds topLeft + 1) > 0].	self lineSegmentsDo:		[:p1 :p2 |		(aPoint onLineFrom: p1 to: p2 within: (3 max: borderWidth+1//2) asFloat)				ifTrue: [^ true]].	self arrowForms do:		[:f | (f pixelValueAt: aPoint - f offset) > 0 ifTrue: [^ true]].	^ false! !!PolygonMorph methodsFor: 'editing' stamp: 'di 8/28/2000 15:08'!dropVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ vertices at: ix.	(((vertices atWrap: ix-1) dist: p) < 3 or:		[((vertices atWrap: ix+1) dist: p) < 3])		ifTrue: ["Drag a vertex onto its neighbor means delete"				self setVertices: (vertices copyReplaceFrom: ix to: ix with: Array new)].	evt shiftPressed		ifTrue: [self removeHandles]		ifFalse: [self addHandles "remove then add to recreate"]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 8/20/2000 14:29'!handlesMouseDown: evt	^ (super handlesMouseDown: evt) or: [evt shiftPressed]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 8/29/2000 22:47'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: PasteUpMorph) ifTrue:		["Compensate for border width so that gridded drop			is consistent with gridded drag of handles."		self position: (newOwner gridPoint: self position) - (borderWidth+1//2)].	^ super justDroppedInto: newOwner event: evt! !!PolygonMorph methodsFor: 'editing' stamp: 'di 8/28/2000 15:09'!mouseDown: evt	^ evt shiftPressed		ifTrue: [self toggleHandles.				handles ifNil: [^ self].				vertices withIndexDo:  "Check for click-to-drag at handle site"					[:vertPt :vertIndex |					((handles at: vertIndex*2-1) containsPoint: evt cursorPoint) ifTrue:						["If clicked near a vertex, jump into drag-vertex action"						evt hand newMouseFocus: (handles at: vertIndex*2-1)]]]		ifFalse: [super mouseDown: evt]! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/28/2000 22:50'!addCustomMenuItems: aMenu hand: aHandMorph	| lineName |	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #handlesShowingPhrase target: self action: #showOrHideHandles.	aMenu addUpdating: #openOrClosePhrase target: self action: #makeOpenOrClosed.	lineName _ closed ifTrue: ['outline'] ifFalse: ['line'].	(self isKindOf: CurveMorph)		ifTrue: [aMenu add: 'make segmented ', lineName action: #toggleSmoothing]		ifFalse: [aMenu add: 'make smooth ', lineName action: #toggleSmoothing]. 	aMenu addUpdating: #fillPhrase enablementSelector: #isClosed target: self selector: #toggleFill argumentList: (Array with: quickFill not).	aMenu addLine.	aMenu addWithLabel: '---' enablement: #enableRemoveArrows action:  #makeNoArrows.	aMenu addWithLabel: '-->' enablement: #enableForwardArrow action:  #makeForwardArrow.	aMenu addWithLabel: '<--' enablement: #enableBackArrow action:  #makeBackArrow.	aMenu addWithLabel: '<->' enablement: #enableBothArrows action:  #makeBothArrows.! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/20/2000 14:27'!makeClosed	closed _ true.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/20/2000 14:27'!makeOpen	closed _ false.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/20/2000 14:31'!toggleHandles	handles ifNil: [self addHandles] ifNotNil: [self removeHandles].! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/20/2000 14:08'!toggleSmoothing	| newMorph hadHandles |	hadHandles _ handles ifNil: [false] ifNotNil: [self removeHandles. true].	newMorph _ self as:			((self isKindOf: CurveMorph)					ifTrue: [PolygonMorph]					ifFalse: [CurveMorph]).	owner replaceSubmorph: self by: newMorph.	hadHandles ifTrue: [newMorph addHandles].	newMorph computeBounds.! !!LineMorph class methodsFor: 'as yet unclassified' stamp: 'di 8/20/2000 12:18'!from: startPoint to: endPoint color: lineColor width: lineWidth	^ PolygonMorph vertices: {startPoint. endPoint}			color: Color black borderWidth: lineWidth borderColor: lineColor! !!LineMorph class methodsFor: 'as yet unclassified' stamp: 'di 8/20/2000 12:16'!new	^ self from: 0@0 to: 50@50 color: Color black width: 2! !!RemoteControlledHandMorph methodsFor: 'as yet unclassified' stamp: 'di 8/23/2000 23:35'!testEvent: evt ifQuickClick: quickClickBlock ifMoved: movedBlock	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	self flag: #bob.		"Don't know how to do this for remote hands yet"! !!SelectionMorph methodsFor: 'initialization' stamp: 'di 8/29/2000 22:07'!extendByHand: aHand	"Assumes selection has just been created and added to some pasteUp or world"	| startPoint handle |	startPoint _ self position.	handle _ NewHandleMorph new followHand: aHand		forEachPointDo: [:newPoint | self bounds: (startPoint rect: newPoint)]		lastPointDo: [:newPoint | selectedItems isEmpty ifTrue: [self delete]													ifFalse: [self addHalo]].	aHand attachMorph: handle.	handle startStepping.! !!SelectionMorph methodsFor: 'initialization' stamp: 'di 8/25/2000 15:48'!initialize	super initialize.	color _ Color transparent.	borderWidth _ 1.	selectedItems _ OrderedCollection new.	slippage _ 0@0.! !!SelectionMorph methodsFor: 'geometry' stamp: 'di 8/28/2000 21:40'!bounds: newBounds	selectedItems _ OrderedCollection new.  "Avoid repostioning items during super position:"	super bounds: newBounds! !!SelectionMorph methodsFor: 'geometry' stamp: 'di 8/23/2000 15:35'!extent: newExtent	super extent: newExtent.	selectedItems _ OrderedCollection new.	self selectSubmorphsOf: self world! !!SelectionMorph methodsFor: 'geometry' stamp: 'di 8/23/2000 17:19'!fullBounds	fullBounds ifNotNil: [^ fullBounds].	fullBounds _ super fullBounds.	selectedItems do: [:m | fullBounds _ fullBounds merge: m fullBounds].	fullBounds _ fullBounds expandBy: 1.	^ fullBounds! !!SelectionMorph methodsFor: 'geometry' stamp: 'di 8/28/2000 22:10'!privateFullMoveBy: delta	| griddedDelta griddingMorph |	selectedItems isEmpty ifTrue: [^ super privateFullMoveBy: delta].	griddingMorph _ self pasteUpMorph.	griddingMorph ifNil: [^ super privateFullMoveBy: delta].	griddedDelta _ (griddingMorph gridPoint: self position + delta + slippage) -					(griddingMorph gridPoint: self position).	slippage _ slippage + (delta - griddedDelta).  "keep track of how we lag the true movement."	griddedDelta = (0@0) ifTrue: [^ self].	super privateFullMoveBy: griddedDelta.	selectedItems do:		[:m | m privateFullMoveBy: griddedDelta]! !!SelectionMorph methodsFor: 'drawing' stamp: 'di 8/23/2000 17:12'!drawOn: aCanvas	| canvas form1 form2 box |	super drawOn: aCanvas.	box _ self bounds.	selectedItems do: [:m | box _ box merge: m fullBounds].	box _ box expandBy: 1.	canvas _ Display defaultCanvasClass extent: box extent depth: 8.	canvas translateBy: box topLeft negated		during: [:tempCanvas | selectedItems do: [:m | m fullDrawOn: tempCanvas]].	form1 _ (Form extent: box extent) copyBits: (0@0 extent: box extent) from: canvas form at: 0@0 colorMap: (Color maskingMap: 8).	form2 _ Form extent: box extent.	(0@0) fourNeighbors do: [:d | form1 displayOn: form2 at: d rule: Form under].	form1 displayOn: form2 at: 0@0 rule: Form erase.	aCanvas stencil: form2		at: box topLeft		sourceRect: form2 boundingBox		color: Color blue! !!SelectionMorph methodsFor: 'drag and drop' stamp: 'di 8/29/2000 21:54'!justDroppedInto: newOwner event: evt	selectedItems isEmpty ifTrue: [^ self extendByHand: evt hand].	dupLoc ifNotNil: [dupDelta _ self position - dupLoc].	^ super justDroppedInto: newOwner event: evt! !!SelectionMorph methodsFor: 'halo commands' stamp: 'di 8/23/2000 23:42'!borderColor: aColor	selectedItems do: [:m | (m isKindOf: BorderedMorph) ifTrue: [m borderColor: aColor]]! !!SelectionMorph methodsFor: 'halo commands' stamp: 'di 8/23/2000 23:42'!borderWidth: aColor	selectedItems do: [:m | (m isKindOf: BorderedMorph) ifTrue: [m borderWidth: aColor]]! !!SelectionMorph methodsFor: 'halo commands' stamp: 'di 8/29/2000 23:14'!color: aColor	selectedItems do:		[:m | ((m isKindOf: PolygonMorph) and: [m isOpen])				ifTrue: [m borderColor: aColor  "we aim to please"]				ifFalse: [m color: aColor]]! !!SelectionMorph methodsFor: 'halo commands' stamp: 'di 8/23/2000 17:06'!dismissViaHalo	super dismissViaHalo.	selectedItems do: [:m | m dismissViaHalo]! !!SelectionMorph methodsFor: 'halo commands' stamp: 'di 8/29/2000 22:08'!doDup: evt fromHalo: halo handle: dupHandle.	selectedItems _ selectedItems collect: [:m | m duplicate].	selectedItems do: [:m | self owner addMorph: m].	dupDelta == nil		ifTrue: ["First duplicate operation -- note starting location"				dupLoc _ self position.				evt hand grabMorph: self.				halo removeAllHandlesBut: dupHandle]		ifFalse: ["Subsequent duplicate does not grab, but only moves me and my morphs"				dupLoc _ nil.				self position: self position + dupDelta]! !!SelectionMorph methodsFor: 'private' stamp: 'di 8/23/2000 15:53'!selectSubmorphsOf: aMorph	aMorph submorphsDo:		[:m | (bounds intersects: m fullBounds) ifTrue:			[((bounds containsRect: m fullBounds)					and: [m~~self					and: [(m isKindOf: HaloMorph) not]])				ifTrue: [selectedItems add: m]				ifFalse: [self selectSubmorphsOf: m]]]! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 8/20/2000 11:00'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy ensureCleanBold name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy ensureCleanBold name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !SelectionMorph removeSelector: #dismissOrAddHalo!SelectionMorph removeSelector: #doDup:!SelectionMorph removeSelector: #position:!SelectionMorph removeSelector: #xposition:!SelectionMorph removeSelector: #xprivateFullMoveBy:!!SelectionMorph reorganize!('initialization' extendByHand: initialize)('geometry' bounds: extent: fullBounds privateFullMoveBy:)('drawing' drawOn:)('drag and drop' aboutToBeGrabbedBy: justDroppedInto:event:)('halo commands' borderColor: borderWidth: color: dismissViaHalo doDup:fromHalo:handle:)('private' selectSubmorphsOf:)!RemoteControlledHandMorph removeSelector: #escapeIfQuickClick:ifMoved:!PolygonMorph removeSelector: #boundsWithoutBorder!PasteUpMorph removeSelector: #abandonSelection!PasteUpMorph removeSelector: #defaultGrid!HandMorph removeSelector: #duplicateMorphInWorld!HandMorph removeSelector: #escapeIfQuickClick:ifMoved:!Morph removeSelector: #duplicateInWorld!InputSensor removeSelector: #escapeIfQuickClick:ifMoved:!