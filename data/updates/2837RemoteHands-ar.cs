'From Squeak2.9alpha of 13 June 2000 [latest update: #2884] on 24 October 2000 at 5:51:25 pm'!"Change Set:		RemoteHands-arDate:			24 October 2000Author:			Andreas RaabRemoves telemorphic's event handling from HandMorph. RemoteHandMorphs receive their events by registering themselves as event listeners with the hand."!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent lastEvent targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset remoteConnections transmitBuffer hasChanged savedPatch userInitials lastEventBuffer '	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!HandMorph subclass: #RemoteHandMorph	instanceVariableNames: 'remoteWorldExtent socket waitingForConnection receiveBuffer sendSocket sendBuffer remoteAddress sendState '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/24/2000 14:04'!startTelemorphic	self world 		connectRemoteUserWithName: self userName 		picture: (userPicture ifNotNil: [userPicture scaledToSize: 16@20]) 		andIPAddress: self ipAddress! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/24/2000 14:33'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	cachedCanvasHasHoles _ false.	temporaryCursor _ temporaryCursorOffset _ nil! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/24/2000 16:41'!handleEvent: anEvent	| evt prevEvt ofs |	anEvent isMorphicEvent 		ifTrue:[evt _ anEvent]		ifFalse:[			prevEvt _ lastEvent.			lastEvent _ anEvent.			evt _ anEvent asNewEventFrom: prevEvt].	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseFocus].ShowEvents == true ifTrue:[	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendEvent: evt focus: mouseFocus].	].	ShowEvents == true ifTrue:[mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/24/2000 14:35'!processEvents	"Process user input events from the local input devices.	An interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized."	| evt evtBuf type hadMouse hadAny |	hadMouse _ hadAny _ false.	[(evtBuf _ Sensor nextEvent) == nil] whileFalse:[		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt _ self generateMouseEvent: evtBuf. hadMouse _ true].		(type = EventTypeKeyboard) 			ifTrue:[evt _ self generateKeyboardEvent: evtBuf].		"All other events are ignored"		evt == nil ifFalse:[			"Finally, handle it"			self handleEvent: evt.			hadAny _ true].		"See the note on running a World in MVC in the method comment"		(evt isMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].	].	(mouseClickState notNil and:[hadMouse not]) ifTrue:[		"No mouse events during this cycle. Make sure click states time out accordingly"		mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny ifFalse:[		"No pending events. Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent.	].! !!NewMorphicEvent methodsFor: 'initialize' stamp: 'ar 10/24/2000 16:21'!type: eventType readFrom: aStream	"Read a MorphicEvent from the given stream."! !!NewMorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/24/2000 16:21'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| typeString c |	typeString _ String streamContents:		[:s |   [(c _ aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove' ifTrue:[^MouseMoveEvent type: #mouseMove readFrom: aStream].	typeString = 'mouseDown' ifTrue:[^MouseButtonEvent type: #mouseDown readFrom: aStream].	typeString = 'mouseUp' ifTrue:[^MouseButtonEvent type: #mouseUp readFrom: aStream].	typeString = 'keystroke' ifTrue:[^KeyboardEvent type: #keystroke readFrom: aStream].	typeString = 'keyDown' ifTrue:[^KeyboardEvent type: #keyDown readFrom: aStream].	typeString = 'keyUp' ifTrue:[^KeyboardEvent type: #keyUp readFrom: aStream].	typeString = 'mouseOver' ifTrue:[^MouseEvent type: #mouseOver readFrom: aStream].	typeString = 'mouseEnter' ifTrue:[^MouseEvent type: #mouseEnter readFrom: aStream].	typeString = 'mouseLeave' ifTrue:[^MouseEvent type: #mouseLeave readFrom: aStream].	^nil! !!NewMorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/24/2000 16:32'!type: eventType readFrom: aStream	^self new type: eventType readFrom: aStream! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 14:03'!connectRemoteUser		^self		connectRemoteUserWithName: nil 		picture: nil 		andIPAddress: nil! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 15:59'!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials _ nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr _ 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr _ NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr _ NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	Socket ensureNetworkConnected.	h _ RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self addHand: h.	h changed.	h startListening.	h startTransmittingEventsTo: addr.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 14:07'!disconnectAllRemoteUsers	"Disconnect all remote hands and stop transmitting events."	self world handsDo: [:h |		(h isKindOf: RemoteHandMorph) 			ifTrue: [h withdrawFromWorld]].! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 14:09'!disconnectRemoteUser	"Prompt for the initials of the remote user, then remove the remote hand with those initials, breaking its connection."	"select hand to remove"	| initials handToRemove |	initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	initials isEmpty ifTrue: [^ self].  "abort"	handToRemove _ nil.	self handsDo: [:h |		h userInitials = initials ifTrue: [handToRemove _ h]].	handToRemove ifNil: [^ self].  "no hand with those initials"	handToRemove withdrawFromWorld.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 14:40'!reportLocalAddress	"Report the local host address of this computer."	| addrString m s |	Socket initializeNetwork.	addrString _ NetNameResolver localAddressString.	m _ RectangleMorph new		color: (Color r: 0.6 g: 0.8 b: 0.6);		extent: 118@36;		borderWidth: 1.	s _ StringMorph contents: 'Local Host Address:'.	s position: m position + (5@4).	m addMorph: s.	s _ StringMorph contents: addrString.	s position: m position + (5@19).	m addMorph: s.	self primaryHand attachMorph: m.! !!RemoteHandMorph methodsFor: 'initialization' stamp: 'ar 10/24/2000 14:38'!initialize	super initialize.	remoteWorldExtent _ 100@100.  "initial guess"	socket _ nil.	waitingForConnection _ false.	receiveBuffer _ ''.	sendState _ #unconnected.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 14:10'!lastEventTransmitted	^self valueOfProperty: #lastEventTransmitted! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 14:10'!lastEventTransmitted: anEvent	^self setProperty: #lastEventTransmitted toValue: anEvent! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 14:10'!lastWorldExtent	^self valueOfProperty: #lastWorldExtent! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 14:10'!lastWorldExtent: extent	^self setProperty: #lastWorldExtent toValue: extent! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 16:50'!readyToTransmit	"Return true if the receiver is ready to send."	(sendState == #connected) ifTrue:[		 sendSocket sendDone ifFalse:[^false].		^true].	sendState == #opening ifTrue:[		sendSocket isConnected ifTrue:[^true].		sendSocket isWaitingForConnection ifFalse:[			Transcript show: 'trying connection again...'; cr.			sendSocket destroy.			sendSocket _ Socket new.			sendSocket connectTo: self remoteHostAddress port: 54323]].	sendState == #closing ifTrue:[		sendSocket isUnconnectedOrInvalid ifTrue:[			sendSocket destroy.			sendState _ #unconnected]].	^false! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 15:59'!remoteHostAddress	"Return the address of the remote host or zero if not connected."	^remoteAddress ifNil:[0]! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 15:57'!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket _ SimpleClientSocket new.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState _ #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 15:59'!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress _ remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket _ SimpleClientSocket new.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState _ #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 14:34'!stopTransmittingEvents	"Stop broadcasting events from this world's cursor to a remote cursor on the host with the given address. This method issues a 'close' but does not destroy the socket; it will be destroyed when the other end reads the last data and closes the connection."	(sendSocket isUnconnectedOrInvalid) ifFalse:[		sendSocket close.		sendState _ #closing].	owner primaryHand removeEventListener: self.! !!RemoteHandMorph methodsFor: 'other' stamp: 'ar 10/24/2000 14:34'!withdrawFromWorld	"Close the socket, if any, and remove this hand from the world."	| addr |	addr _ self remoteHostAddress.	addr = 0 ifFalse: [self stopTransmittingEvents].	self stopListening.	Transcript show: 'Remote hand ', self userInitials, ' closed'; cr.	owner ifNotNil: [owner removeHand: self].! !!RemoteHandMorph methodsFor: 'private' stamp: 'ar 10/24/2000 17:03'!getNextRemoteEvent	"Return the next remote event, or nil if the receive buffer does not contain a full event record. An event record is the storeString for a MorphicEvent terminated by a <CR> character."	| i s evt |	self receiveData.	receiveBuffer isEmpty ifTrue: [^ nil].	i _ receiveBuffer indexOf: Character cr ifAbsent: [^ nil].	s _ receiveBuffer copyFrom: 1 to: i - 1.	receiveBuffer _ receiveBuffer copyFrom: i + 1 to: receiveBuffer size.	evt _ (NewMorphicEvent readFromString: s).	evt ifNil:[^nil].	evt setHand: self.	evt isKeyboard ifTrue:[evt setPosition: self position].	^evt resetHandlerFields! !!RemoteHandMorph methodsFor: 'event handling' stamp: 'ar 10/24/2000 16:49'!handleListenEvent: anEvent	"Transmit the event to interested listeners"	"| currentExtent |	currentExtent _ self worldBounds extent.	self lastWorldExtent ~= currentExtent ifTrue: [		self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).		self lastWorldExtent: currentExtent]."	self transmitEvent: anEvent.! !!RemoteHandMorph methodsFor: 'event handling' stamp: 'ar 10/24/2000 16:39'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		self handleEvent: evt.		evt _ self getNextRemoteEvent]! !!RemoteHandMorph methodsFor: 'event handling' stamp: 'ar 10/24/2000 16:50'!transmitEvent: aMorphicEvent	"Transmit the given event to all remote connections."	| firstEvt |	self readyToTransmit ifFalse: [^ self].	self lastEventTransmitted = aMorphicEvent ifTrue: [^ self].	sendBuffer ifNil: [sendBuffer _ WriteStream on: (String new: 10000)].	sendBuffer nextPutAll: aMorphicEvent storeString; cr.	self lastEventTransmitted: aMorphicEvent.	sendSocket isConnected ifTrue:[		sendState = #opening ifTrue: [			"connection established; disable TCP delays on sends"			sendSocket setOption: 'TCP_NODELAY' value: true.			"send worldExtent as first event"			firstEvt _ MorphicEvent newWorldExtent: self worldBounds extent.			sendSocket sendData: firstEvt storeString, (String with: Character cr).			Transcript				show: 'Connection established with remote WorldMorph at ';				show: (NetNameResolver stringFromAddress: sendSocket remoteAddress); cr.			sendState _ #connected].		sendSocket sendData: sendBuffer contents.	] ifFalse: [		owner primaryHand removeEventListener: self.		sendState = #connected ifTrue: [			"other end has closed; close our end"			Transcript				show: 'Closing connection with remote WorldMorph at ';				show: (NetNameResolver stringFromAddress: sendSocket remoteAddress); cr.			sendSocket close.		sendState _ #closing]].	sendBuffer reset.! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/24/2000 14:08'!remoteMenu        "Build the Telemorphic menu for the world."        ^self fillIn: (self menu: 'Telemorphic') from: {                { 'local host address' . { #myWorld . #reportLocalAddress } }.                { 'connect remote user' . { #myWorld . #connectRemoteUser } }.                { 'disconnect remote user' . { #myWorld . #disconnectRemoteUser } }.                { 'disconnect all remote users' . { #myWorld . #disconnectAllRemoteUsers } }.        }! !!UserInputEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:33'!setHand: aHand	source _ aHand! !!UserInputEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:33'!setPosition: aPoint	position _ aPoint! !!KeyboardEvent methodsFor: 'comparing' stamp: 'ar 10/24/2000 17:44'!= aMorphicEvent	super = aMorphicEvent ifFalse:[^false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	keyValue = aMorphicEvent keyValue ifFalse: [^ false].	^ true! !!KeyboardEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:25'!type: eventType readFrom: aStream	type _ eventType.	buttons _ Integer readFrom: aStream.	aStream skip: 1.	keyValue _ Integer readFrom: aStream.! !!MouseEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:27'!type: eventType readFrom: aStream	| x y |	type _ eventType.	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	position _ x@y.! !!MouseButtonEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:29'!type: eventType readFrom: aStream	super type: eventType readFrom: aStream.	aStream skip: 1.	whichButton _ Integer readFrom: aStream.! !!MouseButtonEvent methodsFor: 'printing' stamp: 'ar 10/24/2000 16:29'!storeOn: aStream	super storeOn: aStream.	aStream space.	whichButton storeOn: aStream.! !!MouseMoveEvent methodsFor: 'accessing' stamp: 'ar 10/24/2000 16:33'!trail	"Return any immediate points that have been assembled along the move"	^trail ifNil:[#()]! !!MouseMoveEvent methodsFor: 'printing' stamp: 'ar 10/24/2000 16:30'!storeOn: aStream	super storeOn: aStream.	aStream space.	self startPoint x storeOn: aStream.	aStream space.	self startPoint y storeOn: aStream.	aStream space.	"trail storeOn: aStream."! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:31'!type: eventType readFrom: aStream	| x y |	super type: eventType readFrom: aStream.	aStream skip: 1.	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	startPoint _ x@y.! !HandMorph subclass: #RemoteHandMorph	instanceVariableNames: 'remoteWorldExtent remoteAddress sendSocket sendBuffer sendState socket waitingForConnection receiveBuffer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!HandMorph removeSelector: #cleanupDeadConnections!HandMorph removeSelector: #connectRemoteUser!HandMorph removeSelector: #connectRemoteUserWithName:picture:andIPAddress:!HandMorph removeSelector: #disconnectAllRemoteUsers!HandMorph removeSelector: #disconnectRemoteUser!HandMorph removeSelector: #lastEventTransmitted!HandMorph removeSelector: #lastEventTransmitted:!HandMorph removeSelector: #lastWorldExtent!HandMorph removeSelector: #lastWorldExtent:!HandMorph removeSelector: #readyToTransmit!HandMorph removeSelector: #reportLocalAddress!HandMorph removeSelector: #startTransmittingEventsTo:!HandMorph removeSelector: #stopTransmittingEventsTo:!HandMorph removeSelector: #transmitEvent:!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent lastEvent targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer '	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!!HandMorph reorganize!('initialization' initForEvents initialize)('accessing' lastEvent mouseOverHandler targetOffset userInitials)('classification' isHandMorph)('cursor' cursorBounds showTemporaryCursor: showTemporaryCursor:hotSpotOffset:)('geometry' changed fullBounds invalidRect: position position: userInitials:andPicture:)('drawing' colorForInsets drawOn: fullDrawOn: hasChanged hasUserInformation needsToBeDrawn nonCachingFullDrawOn: restoreSavedPatchOn: savePatchFrom: shadowForm shadowOffset trailMorph updateCacheCanvas:)('event handling' checkForMoreKeyboard flushEvents handleEvent: noticeMouseOver:event: pauseEventRecorderIn: processEvents)('focus handling' keyboardFocus mouseFocus newKeyboardFocus: newMouseFocus: newMouseFocus:event: releaseAllFoci releaseKeyboardFocus releaseKeyboardFocus: releaseMouseFocus releaseMouseFocus:)('double click support' resetClickState waitForClicksOrDrag:event: waitForClicksOrDrag:event:selectors:threshold:)('grabbing/dropping' attachMorph: dropMorph:event: dropMorphs dropMorphs: grabMorph:)('listeners' addEventListener: addKeyboardListener: addMouseListener: removeEventListener: removeKeyboardListener: removeMouseListener:)('balloon help' balloonHelp balloonHelp: deleteBalloonTarget: removePendingBalloonFor: spawnBalloonFor: triggerBalloonFor:after:)('halo handling' halo halo: removeHaloFromClick:on: removePendingHaloFor: spawnHaloFor: triggerHaloFor:after:)('paste buffer' copyToPasteBuffer: objectToPaste pasteBuffer pasteBuffer: pasteMorph)('private events' generateKeyboardEvent: generateMouseEvent: mouseTrailFrom: moveToEvent: sendEvent:focus: sendFocusEvent:to: sendListenEvent:to:)('object fileIn' convertbosfceekmmmdccffuleatdccttggrtllmhssffa0:bosfceekmmmdccffuleatdccttggrtllmhssffac0: convertbosfceekmmmdccffuleatdccttggrtllmhssffa0:bosfceekmmmdccffuleatdccttggrtllmhssffacw0: convertbosfceekmmmdccffuleatdccttggrtllmhssffac0:bosfceekmmmdccffuleatdccttggrtllmhssffacw0:)('private' objectForDataStream: releaseCachedState veryDeepCopyWith:)!