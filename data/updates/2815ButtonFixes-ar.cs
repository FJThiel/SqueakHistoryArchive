'From Squeak2.9alpha of 13 June 2000 [latest update: #2861] on 11 October 2000 at 2:19:49 pm'!"Change Set:		ButtonFixes-arDate:			11 October 2000Author:			Andreas RaabAn attempy to make the 'mouse still down' buttons work exactly once on a click. A *quick* click. Also fixes the problem of reissuing some event after a drop operation occured."!!HandMorph methodsFor: 'event handling' stamp: 'ar 10/11/2000 12:34'!handleEvent: anEvent	| evt prevEvt |	anEvent isMorphicEvent 		ifTrue:[evt _ anEvent]		ifFalse:[			prevEvt _ lastEvent.			lastEvent _ anEvent.			evt _ anEvent asNewEventFrom: prevEvt].	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseFocus].ShowEvents == true ifTrue:[	evt printString displayAt: (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: 0@45.].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendEvent: evt focus: mouseFocus].	].	ShowEvents == true ifTrue:[mouseFocus printString displayAt: 0@15].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/11/2000 12:42'!mouseUp: evt	oldColor ifNotNil:		["if oldColor nil, it signals that mouse had not gone DOWN		inside me, e.g. because of a cmd-drag; in this case we want		to avoid triggering the action!!"		self color: oldColor.		oldColor _ nil.		(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])			ifTrue: [self doButtonAction]].	(actWhen == #whilePressed) ifTrue:[		self stopStepping.		self removeProperty: #doesButtonAction.		(self hasProperty: #didButtonAction) "fell inbetween cycle"			ifFalse:[self doButtonAction].		self removeProperty: #didButtonAction.	].! !!SimpleButtonMorph methodsFor: 'stepping' stamp: 'ar 10/11/2000 12:42'!step	(self hasProperty: #doesButtonAction) ifTrue:[		self doButtonAction.		self setProperty: #didButtonAction toValue: true.	].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/11/2000 14:06'!mouseDown: evt	| now dt w |	self state: #pressed.	actWhen == #buttonDown		ifTrue:			[self doButtonAction]		ifFalse:			[now _ Time millisecondClockValue.			super mouseDown: evt.			"Allow on:send:to: to set the response to events other than actWhen"			dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"			dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait]].	(actWhen == #whilePressed) ifTrue:[		self setProperty: #doesButtonAction toValue: true.		w _ self world.		w ifNotNil:[w startStepping: self]].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/11/2000 14:07'!mouseMove: evt(self containsPoint: evt cursorPoint)	ifTrue: [self state: #pressed.			super mouseMove: evt]			"Allow on:send:to: to set the response to events other than actWhen"	ifFalse: [self state: #off].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/11/2000 14:15'!mouseUp: evt	(actWhen == #whilePressed) ifTrue:[		self stopStepping.		self removeProperty: #doesButtonAction.		(self hasProperty: #didButtonAction) "fell inbetween cycle"			ifFalse:[self doButtonAction].		self removeProperty: #didButtonAction.	].		"Allow on:send:to: to set the response to events other than actWhen"	actWhen == #buttonUp ifFalse: [^super mouseUp: evt].	(self containsPoint: evt cursorPoint) ifTrue: [		self state: #on.		self doButtonAction: evt	] ifFalse: [		self state: #off.		target ifNotNil: [target mouseUpBalk: evt]	].	"Allow owner to keep it selected for radio buttons"! !!ThreePhaseButtonMorph methodsFor: 'stepping' stamp: 'ar 10/11/2000 14:05'!step	(self hasProperty: #doesButtonAction) ifTrue:[		self doButtonAction.		self setProperty: #didButtonAction toValue: true.	].! !!ThreePhaseButtonMorph methodsFor: 'stepping' stamp: 'ar 10/11/2000 14:05'!stepTime	(self hasProperty: #doesButtonAction) ifTrue:[^1].	^super stepTime! !!ThreePhaseButtonMorph methodsFor: 'stepping' stamp: 'ar 10/11/2000 14:06'!wantsSteps	^(self hasProperty: #doesButtonAction) or:[super wantsSteps]! !!ThreePhaseButtonMorph reorganize!('initialize-release' adaptToWorld: initialize)('accessing' actWhen: actionSelector actionSelector: arguments arguments: authorModeOwner: dragIfAuthoring: offImage offImage: onImage onImage: pressedImage pressedImage: state: target target:)('testing' isOn)('drawing' drawOn:)('geometry' extent extent:)('copying' updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('event handling' doButtonAction doButtonAction: handlesMouseDown: mouseDown: mouseMove: mouseUp:)('stepping' step stepTime wantsSteps)('printing' printOn:)!