'From Squeak3.6beta of ''4 July 2003'' [latest update: #5411] on 8 September 2003 at 5:36:26 pm'!"Change Set:		NetNameResolverFix-muDate:			8 September 2003Author:			Masashi Umezawa-NetNameResolver>>addressForName:timeout: should raise NameLookupFailure if it fails to resolve hostName. But it raises Error whose messageText is 'NameLookupFailure'. Now the method correctly raises true NameLookupFailure.A simple test code:[NetNameResolver addressForName: 'foo.bar.notExistHost' timeout: 10] on: NameLookupFailure do: [:ex | Transcript cr; show: 'Caught here!!'].-NetNameResolver>>promptUserForHostAddressDefault: expects NetNameResolver>>addressForName:timeout: returns nil in failure. But it actually raises NameLookupFailure. Now the method ignore the nil return value.Ned Konz added the related fix for nameForAddress:timeout: that he posted in his NameResolverErrorFix-nk on 27 June 2003.'"!!NetNameResolver class methodsFor: 'lookups' stamp: 'mu 9/7/2003 22:53'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline result |	self initializeNetwork.	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result _ self addressFromString: hostName.	result isNil ifFalse: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline _ Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			(self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfName: hostName.					(self waitForCompletionUntil: deadline)						ifTrue: [result _ self primNameLookupResult]						ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]]				ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]].	^result! !!NetNameResolver class methodsFor: 'lookups' stamp: 'nk 6/27/2003 10:51'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.2')		timeout: 30"	| deadline result |	self initializeNetwork.	deadline _ Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			result _ (self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfAddress: hostAddress.					(self waitForCompletionUntil: deadline)						ifTrue: [self primAddressLookupResult]						ifFalse: [nil]]				ifFalse: [nil]].	^result! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mu 9/8/2003 14:24'!promptUserForHostAddressDefault: defaultName	"Ask the user for a host name and return its address. If the default name is the empty string, use the last host name as the default."	"NetNameResolver promptUserForHostAddressDefault: ''"	| default hostName serverAddr |	defaultName isEmpty		ifTrue: [default _ DefaultHostName]		ifFalse: [default _ defaultName].	hostName _ FillInTheBlank		request: 'Host name or address?'		initialAnswer: default.	hostName isEmpty ifTrue: [^ 0].	serverAddr _ NetNameResolver addressForName: hostName timeout: 15.	hostName size > 0 ifTrue: [DefaultHostName _ hostName].	^ serverAddr! !