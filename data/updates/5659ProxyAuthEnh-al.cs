'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 8 January 2004 at 1:33:20 pm'!"Change Set:		ProxyAuthEnhDate:			8 January 2004Author:			Adrian LienhardAdds proxy authentication for squeak version 3.6 to HTTPSocket by encoding to base64. Username and password is stored in the image. Code is mainly from http://minnow.cc.gatech.edu/squeak/uploads/23/HTTP-proxy-Mar02.cs. See http://minnow.cc.gatech.edu/squeak/23 for discussion about being behind a firewall.Note: Monticello fixes a bug in HTTPSocket>>httpGetDocument: url args: args accept: mimeType request: requestString. This fix is also included. The method should be removed from monticello when this enhancement gets into the main image because loading monticello will remoev the proxy auth again."!OldSimpleClientSocket subclass: #HTTPSocket	instanceVariableNames: 'headerTokens headers responseCode '	classVariableNames: 'HTTPBlabEmail HTTPPort HTTPProxyCredentials HTTPProxyExceptions HTTPProxyPort HTTPProxyServer LogToTranscript ParamDelimiters '	poolDictionaries: ''	category: 'Network-Protocols'!!HTTPSocket class methodsFor: 'class initialization' stamp: 'al 1/8/2004 12:21'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxyServer _ nil.	HTTPBlabEmail _ ''.  "	'From: somebody@no.where', CrLf	"	HTTPProxyCredentials _ ''.	ExternalSettings registerClient: self! !!HTTPSocket class methodsFor: 'get the page' stamp: 'al 1/8/2004 12:50'!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server"	| bare serverName specifiedServer port page serverAddr authorization s list header firstData length aStream command |	Socket initializeNetwork. 	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	(self shouldUseProxy: serverName) ifTrue: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].  	"make the request"		serverAddr _ NetNameResolver addressForName: serverName timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', serverName].	authorization _ (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	command _ 		'PUT ', page, ' HTTP/1.0', CrLf, 		self userAgentString, CrLf,		'Host: ', specifiedServer, CrLf, 		'ACCEPT: */*', CrLf,		HTTPProxyCredentials,		'Authorization: Basic ' , authorization , CrLf , 		'Content-length: ', contents size printString, CrLf , CrLf , 		contents.	s sendCommand: command.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ header, aStream contents! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'al 1/8/2004 12:27'!proxyUser: userName password: password	"Store  HTTP 1.0 basic authentication credentials	Note: this is an ugly hack that stores your password	in your image.  It's just enought to get you going	if you use a firewall that requires authentication"    | stream encodedStream |	stream _ ReadWriteStream on: (String new: 16).	stream nextPutAll: userName ,':' , password.	encodedStream _ Base64MimeConverter mimeEncode: stream.	HTTPProxyCredentials _ 'Proxy-Authorization: Basic ' , (encodedStream contents) , String crlf! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'al 1/8/2004 12:27'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxyServer _ nil.	HTTPProxyPort _ 80.	HTTPProxyCredentials _ ''! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'al 1/8/2004 12:54'!useProxyServerNamed: proxyServerName port: portNum proxyUser: aString password: anotherString	self useProxyServerNamed: proxyServerName port: portNum.	self proxyUser: aString password: anotherString! !!HTTPSocket class methodsFor: '*monticello' stamp: 'al 1/8/2004 12:44'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, (self argString: args) ].	(self shouldUseProxy: serverName)		ifFalse: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifTrue:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	"Transcript cr;show: url; cr.	Transcript show: page; cr."	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPProxyCredentials,		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					newUrl _ self expandUrl: newUrl ip: serverAddr port: connectToPort.					^self httpGetDocument: newUrl args: args  accept: mimeType request: requestString] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			"a 400-series error"			sock responseCode first = $4 ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !HTTPSocket initialize!