'From Squeak3.2alpha of 2 October 2001 [latest update: #4424] on 6 October 2001 at 7:35:10 pm'!"Change Set:		LargePrimes-arDate:			6 October 2001Author:			Andreas RaabI just happened to need some reasonably large primes (in the range of SmallInteger maxVal...) unfortunately Integer>>primesUpTo: has a space overhead of 4 bytes per number (which means that for computing all the primes up to SmallInteger>>maxVal we'd ned roughly 4 *GIGA*byte of memory). Fortunately I ran across a much more efficient (in terms of space that is) variant which requires exactly 1/154th the space of the former method.Thus, for computing all the primes up to SmallInteger>>maxVal we only need roughly 27MB of memory - actually computing them took roughly half an hour (not bad and could make for a nice benchmark)."!!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:34'!largePrimesUpTo: maxValue	"Compute and return all the prime numbers up to maxValue"	^Array streamContents:[:s| self largePrimesUpTo: maxValue do:[:prime| s nextPut: prime]]! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 02:38'!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require 4 *GIGA*bytes).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit |	limit _ max asInteger - 1.	indexLimit _ max sqrt truncated + 1.	"Create the array of flags."	flags _ ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 _ self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex _ Array new: 2310.	bitIndex _ -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex _ bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex _ bitIndex + 1).	1 to: 5 do:[:i| aBlock value: (primesUpTo2310 at: i)].	index _ 6.	2 to: 2309 do:[:n|		[(primesUpTo2310 at: index) < n] 			whileTrue:[index _ index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex _ bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex _ bitIndex + 1)].		].	].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by 2 for odd numbers only."	13 to: limit by: 2 do:[:n|		(maskBit _ maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex _ n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex _ 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * i to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index _ n * n.					(index bitAnd: 1) = 0 ifTrue:[index _ index + n].					[index <= limit] whileTrue:[						(maskBit _ maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex _ (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit _ 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index _ index + (2 * n)].				].			].		].	].! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!primesUpTo: max	"Return a list of prime integers up to the given integer."	"Integer primesUpTo: 100"	^Array streamContents:[:s| self primesUpTo: max do:[:prime| s nextPut: prime]]! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| limit flags prime k |	limit _ max asInteger - 1.	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 1/154th of the amount we need here and is almost as fast."	limit > 25000 ifTrue:[^self largePrimesUpTo: max do: aBlock].	flags _ (Array new: limit) atAllPut: true.	1 to: limit do: [:i |		(flags at: i) ifTrue: [			prime _ i + 1.			k _ i + prime.			[k <= limit] whileTrue: [				flags at: k put: false.				k _ k + prime].			aBlock value: prime]].! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!verbosePrimesUpTo: max	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"	"Compute primes up to max, but be verbose about it"	^Array streamContents:[:s| self verbosePrimesUpTo: max do:[:prime| s nextPut: prime]].! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!verbosePrimesUpTo: max do: aBlock	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"	"Compute primes up to max, but be verbose about it"	| lastTime nowTime |	lastTime _ Time millisecondClockValue.	Utilities informUserDuring:[:bar|		bar value:'Computing primes...'.		self primesUpTo: max do:[:prime|			aBlock value: prime.			nowTime _ Time millisecondClockValue.			(nowTime - lastTime > 1000) ifTrue:[				lastTime _ nowTime.				bar value:'Last prime found: ', prime printString]]].! !