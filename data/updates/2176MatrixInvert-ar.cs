'From Squeak2.8alpha of 16 February 2000 [latest update: #2174] on 22 May 2000 at 5:16:49 pm'!"Change Set:		MatrixInvert-arDate:			22 May 2000Author:			Andreas RaabMake 4x4 matrix inversion a primitive."!!B3DMatrix4x4 methodsFor: 'transforming' stamp: 'ar 5/21/2000 16:34'!inverseTransformation	"Return the inverse matrix of the receiver."	^self clone inplaceHouseHolderInvert.! !!B3DMatrix4x4 methodsFor: 'solving' stamp: 'ar 5/22/2000 17:13'!inplaceHouseHolderInvert	"Solve the linear equation self * aVector = x by using HouseHolder's transformation.	Note: This scheme is numerically better than using gaussian elimination even though it takes	somewhat longer"	| d x sigma beta sum s|	<primitive:'b3dInplaceHouseHolderInvert' module:'Squeak3D'>	x _ B3DMatrix4x4 identity.	d _ B3DMatrix4x4 new.	1 to: 4 do:[:j|		sigma := 0.0.		j to: 4 do:[:i| sigma := sigma + ((self at: i at: j) squared)].		sigma isZero ifTrue:[^nil]. "matrix is singular"		((self at: j at: j) < 0.0) 			ifTrue:[ s:= sigma sqrt]			ifFalse:[ s:= sigma sqrt negated].		1 to: 4 do:[:r| d at: j at: r put: s].		beta := 1.0 / ( s * (self at: j at: j) - sigma).		self at: j at: j put: ((self at: j at: j) - s).		"update remaining columns"		j+1 to: 4 do:[:k|			sum := 0.0.			j to: 4 do:[:i| sum := sum + ((self at: i at: j) * (self at: i at: k))].			sum := sum * beta.			j to: 4 do:[:i| 				self at: i at: k put: ((self at: i at: k) + ((self at: i at: j) * sum))]].		"update vector"		1 to: 4 do:[:r|			sum := nil.			j to: 4 do:[:i| 				sum := sum isNil 					ifTrue:[(x at: i at: r) * (self at: i at: j)] 					ifFalse:[sum + ((x at: i at: r) * (self at: i at: j))]].			sum := sum * beta.			j to: 4 do:[:i| 				x at: i at: r put:((x at: i at: r) + (sum * (self at: i at: j)))].		].	].	"Now calculate result"	1 to: 4 do:[:r|		4 to: 1 by: -1 do:[:i|			i+1 to: 4 do:[:j|				x at: i at: r put: ((x at: i at: r) - ((x at: j at: r) * (self at: i at: j))) ].			x at: i at: r put: ((x at: i at: r) / (d at: i at: r))].	].	self loadFrom: x.	"Return receiver"! !!B3DTransformerPlugin methodsFor: 'primitives' stamp: 'ar 5/22/2000 17:12'!b3dInplaceHouseHolderInvert	"Primitive. Perform an inplace house holder matrix inversion"	| rcvr d x sigma beta sum s m |	self export: true.	self var: #rcvr declareC:'float *rcvr'.	self var: #m declareC:'double m[4][4]'.	self var: #x declareC:'double x[4][4] = { {1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1} }'.	self var: #d declareC:'double d[4][4]'.	self var: #sigma declareC:'double sigma'.	self var: #beta declareC:'double beta'.	self var: #sum declareC:'double sum'.	self var: #s declareC:'double s'.	self cCode:'' inSmalltalk:[		m _ CArrayAccessor on: 				((1 to: 4) collect:[:i| CArrayAccessor on: (Array new: 4)]).		x _ CArrayAccessor on: (Array				with: (CArrayAccessor on: #(1.0 0.0 0.0 0.0) copy)				with: (CArrayAccessor on: #(0.0 1.0 0.0 0.0) copy)				with: (CArrayAccessor on: #(0.0 0.0 1.0 0.0) copy)				with: (CArrayAccessor on: #(0.0 0.0 0.0 1.0) copy)).		d _ CArrayAccessor on: 				((1 to: 4) collect:[:i| CArrayAccessor on: (Array new: 4)]).	].	rcvr _ self stackMatrix: 0.	0 to: 3 do:[:i| 0 to: 3 do:[:j|		(m at: i) at: j put: (rcvr at: i*4+j)]].	0 to: 3 do:[:j|		sigma := 0.0.		j to: 3 do:[:i| sigma := sigma + (((m at: i) at: j)  * ((m at: i) at: j))].		sigma < 1.0e-10 ifTrue:[^interpreterProxy primitiveFail]. "matrix is singular"		(((m at: j) at: j) < 0.0) 			ifTrue:[ s:= sigma sqrt]			ifFalse:[ s:= 0.0 - sigma sqrt].		0 to: 3 do:[:r| (d at: j) at: r put: s].		beta := 1.0 / ( s * ((m at: j) at: j) - sigma).		(m at: j) at: j put: (((m at: j) at: j) - s).		"update remaining columns"		j+1 to: 3 do:[:k|			sum := 0.0.			j to: 3 do:[:i| sum := sum + (((m at: i) at: j) * ((m at: i) at: k))].			sum := sum * beta.			j to: 3 do:[:i| 				(m at: i) at: k put: (((m at: i) at: k) + (((m at: i) at: j) * sum))]].		"update vector"		0 to: 3 do:[:r|			sum := 0.0.			j to: 3 do:[:i| 				sum _ sum + (((x at: i) at: r) * ((m at: i) at: j))].			sum := sum * beta.			j to: 3 do:[:i| 				(x at: i) at: r put:(((x at: i) at: r) + (sum * ((m at: i) at: j)))].		].	].	"Now calculate result"	0 to: 3 do:[:r|		3 to: 0 by: -1 do:[:i|			i+1 to: 3 do:[:j|				(x at: i) at: r put: (((x at: i) at: r) - (((x at: j) at: r) * ((m at: i) at: j))) ].			(x at: i) at: r put: (((x at: i) at: r) / ((d at: i) at: r))].	].	0 to: 3 do:[:i| 0 to: 3 do:[:j|		rcvr at: i*4+j put: (self cCoerce: ((x at: i) at: j) to:'float')]].	"Return receiver"! !