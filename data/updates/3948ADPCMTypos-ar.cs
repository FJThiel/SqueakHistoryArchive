'From Squeak3.1alpha [latest update: #''Squeak3.1alpha'' of 28 February 2001 update 3945] on 23 April 2001 at 3:12:56 pm'!"Change Set:		ADPCMTypos-arDate:			23 April 2001Author:			Andreas RaabFixes typos from converting some indexed to named primitives."!!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'ar 4/23/2001 15:11'!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted _ self nextBits: 16.				predicted > 32767 ifTrue: [predicted _ predicted - 65536].				index _ self nextBits: 6.				samples at: (sampleIndex _ sampleIndex + 1) put: predicted]			ifFalse: [				delta _ self nextBits: bitsPerSample.				step _ stepSizeTable at: index + 1.				predictedDelta _ 0.				bit _ deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta _ predictedDelta + step].					step _ step bitShift: -1.					bit _ bit bitShift: -1].				predictedDelta _ predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted _ predicted - predictedDelta]					ifFalse: [predicted _ predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted _ 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted _ -32768]].				index _ index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index _ 0]					ifFalse: [index > 88 ifTrue: [index _ 88]].				samples at: (sampleIndex _ sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'ar 4/23/2001 15:11'!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	self var: #rightSamples declareC: 'short int *rightSamples'.	self var: #predicted declareC: 'short int *predicted'.	self var: #index declareC: 'short int *index'.	"make local copies of decoder state variables"	predictedLeft _ predicted at: 1.	predictedRight _ predicted at: 2.	indexLeft _ index at: 1.	indexRight _ index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft _ self nextBits: 16.				indexLeft _ self nextBits: 6.				predictedRight _ self nextBits: 16.				indexRight _ self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft _ predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight _ predictedRight - 65536].				samples at: (sampleIndex _ sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft _ self nextBits: bitsPerSample.				deltaRight _ self nextBits: bitsPerSample.				stepLeft _ stepSizeTable at: indexLeft + 1.				stepRight _ stepSizeTable at: indexRight + 1.				predictedDeltaLeft _ predictedDeltaRight _ 0.				bit _ deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft _ predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight _ predictedDeltaRight + stepRight].					stepLeft _ stepLeft bitShift: -1.					stepRight _ stepRight bitShift: -1.					bit _ bit bitShift: -1].				predictedDeltaLeft _ predictedDeltaLeft + stepLeft.				predictedDeltaRight _ predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft _ predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft _ predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight _ predictedRight - predictedDeltaRight]					ifFalse: [predictedRight _ predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft _ 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft _ -32768]].				predictedRight > 32767					ifTrue: [predictedRight _ 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight _ -32768]].				indexLeft _ indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft _ 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft _ 88]].				indexRight _ indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight _ 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight _ 88]].				samples at: (sampleIndex _ sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'ar 4/23/2001 15:11'!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	step _ stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted _ samples at: (sampleIndex _ sampleIndex + 1).			(p _ predicted) < 0 ifTrue: [p _ p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index _ self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign _ 0.			diff _ (samples at: (sampleIndex _ sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign _ deltaSignMask.				diff _ 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta _ (4 * diff) / step.				predictedDelta _ ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta _ 0.			predictedDelta _ 0.			bit _ deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta _ delta + bit.					predictedDelta _ predictedDelta + step.					diff _ diff - step].				step _ step bitShift: -1.				bit _ bit bitShift: -1].			predictedDelta _ predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted _ predicted - predictedDelta]				ifFalse: [predicted _ predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted _ 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted _ -32768]].			"compute new index and step values"			index _ index + (indexTable at: delta + 1).			index < 0				ifTrue: [index _ 0]				ifFalse: [index > 88 ifTrue: [index _ 88]].			step _ stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex _ byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'ar 4/23/2001 15:12'!privateEncodeStereo: count	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	"not yet implemented"	self inline: false.	self success: false.! !