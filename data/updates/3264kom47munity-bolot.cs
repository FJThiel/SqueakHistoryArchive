'From Squeak2.8 of 13 June 2000 [latest update: #2359] on 29 January 2001 at 7:36:37 pm'!"Change Set:		kom47munityDate:			29 January 2001Author:			Bolot KerimbaevSome fixes made while developing Comanche.- multipart form posting (the bug made its way from Comanche to the Squeak client-side) -- in HTTPSocket class>>httpPostMultipart...- (ibid) make the mime border more unique (idea from 2.9 super swiki method)- 'get' request -- on errors returned HTTPSocket class, rather than a String or MIMEDocument -- in HTTPSocket>>httpGetDocument...- HttpUrl>>normalizeContents: now checks if webDocument is a String before it sends it #contentType message -- Strings don't understand it- MIMEDocument>>printOn: checks if there's content, and if so, prints size, otherwise, says the size is unknown"!!HTTPSocket class methodsFor: 'get the page' stamp: 'bolot 1/29/2001 19:20'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, (self argString: args) ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; cr; show: url; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !!HTTPSocket class methodsFor: 'get the page' stamp: 'bolot 1/29/2001 19:35'!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	" by Bolot Kerimbaev, 1998 "	" this version is a memory hog: puts the whole file in memory "	"bolot 12/14/2000 18:28 -- minor fixes to make it comply with RFC 1867"	| serverName serverAddr s header length bare page list firstData aStream port argsStream specifiedServer type newUrl mimeBorder fieldValue |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	mimeBorder _ '----squeak-georgia-tech-', Time millisecondClockValue printString, '-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, CrLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue _ value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', CrLf, 'Content-Type: ', value contentType.				fieldValue _ (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: CrLf, CrLf, fieldValue, CrLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName, ':', port asString; cr.	s sendCommand: 'POST ', page, ' HTTP/1.1', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: multipart/form-data; boundary=', mimeBorder, CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		"redirected - don't re-post automatically"		"for now, just do a GET, without discriminating between 301/302 codes"		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			(newUrl beginsWith: 'http://')				ifFalse: [					(newUrl beginsWith: '/')						ifTrue: [newUrl _ (bare copyUpTo: $/), newUrl]						ifFalse: [newUrl _ url, newUrl. self flag: #todo							"should do a relative URL"]				].			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpGetDocument: newUrl			"for some codes, may do:			^self httpPostMultipart: newUrl args: argsDict  accept: mimeType request: requestString"] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HttpUrl methodsFor: 'downloading' stamp: 'bolot 12/14/2000 18:26'!normalizeContents: webDocument	(webDocument isKindOf: String) ifTrue: [		^MIMEDocument			contentType: 'text/plain'			content: 'error occured retrieving ', self toText, ': ', webDocument			url: (Url absoluteFromText: '')].	webDocument contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: webDocument content url: webDocument url ].	^webDocument! !!MIMEDocument methodsFor: 'printing' stamp: 'bolot 12/14/2000 17:56'!printOn: aStream	aStream nextPutAll: self class name;		nextPutAll: ' (';		nextPutAll: self contentType;		nextPutAll: ', '.	self content		ifNotNil: [aStream			nextPutAll: self content size printString;			nextPutAll: ' bytes)']		ifNil: [aStream nextPutAll: 'unknown size)'].! !