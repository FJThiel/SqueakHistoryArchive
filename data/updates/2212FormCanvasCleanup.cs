'From Squeak2.8alpha of 16 February 2000 [latest update: #2211] on 25 May 2000 at 6:26:11 pm'!"Change Set:		FormCanvasCleanupDate:			25 May 2000Author:			Andreas RaabThe change set removes all the explicit references to FormCanvas and replaces them by either querying the form about an appropriate canvas or (where a scratch canvas is used) asking Display about it's preferred canvas class." !!Form methodsFor: 'accessing' stamp: 'ar 5/25/2000 17:57'!defaultCanvasClass	"Return the default canvas used for drawing onto the receiver"	^FormCanvas! !!Form methodsFor: 'accessing' stamp: 'ar 5/25/2000 17:57'!getCanvas	"Return a Canvas that can be used to draw onto the receiver"	^self defaultCanvasClass on: self! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 5/25/2000 17:57'!debugDraw	| entry minY maxY lX lY canvas |	entry _ BalloonEdgeData new.	canvas _ Display getCanvas.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	self stepToFirstScanLineAt: minY in: entry.	lX _ entry xValue.	lY _ entry yValue.	minY+1 to: maxY do:[:y|		self stepToNextScanLineAt: y in: entry.		canvas line: lX@lY to: entry xValue @ y width: 2 color: Color black.		lX _ entry xValue.		lY _ y.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 5/25/2000 17:57'!debugDraw2	| canvas last max t next |	canvas _ Display getCanvas.	max _ 100.	last _ nil.	0 to: max do:[:i|		t _ i asFloat / max asFloat.		next _ self valueAt: t.		last ifNotNil:[			canvas line: last to: next rounded width: 2 color: Color blue.		].		last _ next rounded.	].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'ar 5/25/2000 17:57'!debugDrawWide: n	| entry minY maxY canvas curve p1 p2 entry2 y |	curve _ self class new.	curve start: start + (0@n).	curve via: via + (0@n).	curve end: end + (0@n).	entry _ BalloonEdgeData new.	entry2 _ BalloonEdgeData new.	canvas _ Display getCanvas.	minY _ (start y min: end y) min: via y.	maxY _ (start y max: end y) max: via y.	entry yValue: minY.	entry2 yValue: minY + n.	self stepToFirstScanLineAt: minY in: entry.	curve stepToFirstScanLineAt: minY+n in: entry2.	y _ minY.	1 to: n do:[:i|		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p1 _ entry xValue @ y.		canvas line: p1 to: p1 + (n@0) width: 1 color: Color black.	].	[y < maxY] whileTrue:[		y _ y + 1.		self stepToNextScanLineAt: y in: entry.		p2 _ (entry xValue + n) @ y.		curve stepToNextScanLineAt: y in: entry2.		p1 _ entry2 xValue @ y.		canvas line: p1 to: p2 width: 1 color: Color black.	].! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 5/25/2000 17:58'!debugDrawBezier: line	| canvas p1 p2 p3 |	self assert:(self isBezier: line).	p1 _ (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet.	p2 _ (self bezierViaXOf: line) @ (self bezierViaYOf: line) // self aaLevelGet.	p3 _ (self bezierEndXOf: line) @ (self bezierEndYOf: line) // self aaLevelGet.	canvas _ Display getCanvas.	canvas		line: p1 to: p2 width: 2 color: Color blue;		line: p2 to: p3 width: 2 color: Color blue.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 5/25/2000 17:58'!debugDrawHLine: yValue	| canvas |	canvas _ Display getCanvas.	canvas		line: 0 @ (yValue // self aaLevelGet)		to: Display extent x @ (yValue // self aaLevelGet)		width: 2		color: Color green.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 5/25/2000 17:58'!debugDrawLine: line	| canvas |	self assert: (self isLine: line).	canvas _ Display getCanvas.	canvas		line: (self edgeXValueOf: line) @ (self edgeYValueOf: line) // self aaLevelGet		to: (self lineEndXOf: line) @ (self lineEndYOf: line) // self aaLevelGet		width: 2		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 5/25/2000 17:58'!debugDrawLineFrom: pt1 to: pt2	| canvas |	canvas _ Display getCanvas.	canvas		line: (pt1 at: 0) @ (pt1 at: 1) // self aaLevelGet		to: (pt2 at: 0) @ (pt2 at: 1) // self aaLevelGet		width: 1		color: Color red.! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 5/25/2000 17:58'!debugDrawPt: pt	| canvas |	canvas _ Display getCanvas.	canvas		fillRectangle:((pt-2) corner: pt+2) color: Color red! !!BalloonEngineSimulation methodsFor: 'debug support' stamp: 'ar 5/25/2000 17:58'!debugDrawPtLineFrom: pt1 to: pt2	| canvas |	canvas _ Display getCanvas.	canvas		line: pt1		to: pt2		width: 1		color: Color red.! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/25/2000 17:58'!benchmark		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log _ WriteStream on: String new.	destRect _ 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest _ nil.			dest _ Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source _ nil. bb _ nil.				source _ Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb _ WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededForDepth: dest depth).				bb combinationRule: rule.				"Measure speed of copyBits"				t _ Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 5/25/2000 18:04'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	sourceQuad _ (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!LineSegment methodsFor: 'private' stamp: 'ar 5/25/2000 17:59'!debugDraw	| canvas |	canvas _ Display getCanvas.	self lineSegmentsDo:[:p1 :p2|		canvas line: p1 rounded to: p2 rounded width: 1 color: Color black.	].! !!Morph methodsFor: 'drawing' stamp: 'ar 5/25/2000 18:04'!imageForm: depth forRectangle: rect	| canvas |	canvas _ Display defaultCanvasClass extent: rect extent depth: depth.	canvas translateBy: rect topLeft negated		during:[:tempCanvas| self fullDrawOn: tempCanvas].	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'ar 5/25/2000 18:04'!shadowForm	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."	| canvas |	canvas _ (Display defaultCanvasClass extent: bounds extent depth: 1)				asShadowDrawingCanvas: Color black. "Color black represents one for 1bpp"	canvas translateBy: bounds topLeft negated		during:[:tempCanvas| self fullDrawOn: tempCanvas].	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'texture support' stamp: 'ar 5/25/2000 18:00'!asTexture	"Represent the receiver as a Wonderland texture."	| canvas texture dirty |	dirty _ self valueOfProperty: #textureIsDirty ifAbsent:[false].	texture _ self valueOfProperty: #wonderlandTexture.	(texture == nil or:[texture extent ~= self extent]) ifTrue:[		self removeProperty: #wonderlandTexture.		texture _ nil. "Clean up for GC"		texture _ B3DTexture extent: self extent depth: 32.		texture interpolate: false.		texture wrap: false.		texture envMode: 0.		dirty _ true].	dirty ifTrue:[		canvas _ texture getCanvas.		canvas translateBy: self topLeft negated			during:[:tempCanvas| self fullDrawOn: tempCanvas].		self removeProperty: #textureIsDirty.	].	self setProperty: #wonderlandTexture toValue: texture.	^ texture! !!B3DSceneMorph methodsFor: 'drawing' stamp: 'ar 5/25/2000 17:57'!debugDraw	self fullDrawOn: (Display getCanvas).	Display forceToScreen: bounds.! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/25/2000 18:03'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList |	myBnds _ self fullBounds.	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ Display defaultCanvasClass extent: myBnds extent depth: depth.		cacheCanvas translateBy: myBnds origin negated			during:[:tempCanvas| super fullDrawOn: tempCanvas].		^self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: myBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			super fullDrawOn: c]].! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 5/25/2000 17:58'!debugDraw	self fullDrawOn: (Display getCanvas)! !!FlashPlayerMorph methodsFor: 'project transition' stamp: 'ar 5/25/2000 17:59'!playProjectTransitionFrom: oldProject to: newProject entering: aBoolean	"Play the transition from the old to the new project."	Smalltalk isMorphic ifFalse: [^ self]. "Not in MVC"	self stopPlaying.	owner ifNotNil:[		self stopStepping.		owner privateRemoveMorph: self.		owner _ nil].	aBoolean ifTrue:[		self updateProjectFillsFrom: newProject.	] ifFalse:[		self updateProjectFillsFrom: oldProject.		self setProperty: #transitionBackground toValue: newProject imageForm.	].	self frameNumber: 1.	self loopFrames: false.	(self valueOfProperty: #fullScreenTransition ifAbsent:[false])		ifTrue:[self bounds: self world bounds].	self comeToFront.	self startStepping.	self startPlaying.	[playing] whileTrue:[World doOneCycleNow].	self stopPlaying.	self stopStepping.	owner privateRemoveMorph: self.	owner _ nil.	self removeProperty: #transitionBackground.	Display deferUpdates: true.	World fullDrawOn: (Display getCanvas).	Display deferUpdates: false.! !!GraphMorph methodsFor: 'drawing' stamp: 'ar 5/25/2000 18:04'!drawOn: aCanvas	| c |	cachedForm = nil ifTrue:  [		c _ Display defaultCanvasClass extent: bounds extent.		c translateBy: bounds origin negated			during:[:tempCanvas| self drawDataOn: tempCanvas].		cachedForm _ c form].	aCanvas cache: bounds			using: cachedForm			during:[:cachingCanvas| self drawDataOn: cachingCanvas].	self drawCursorOn: aCanvas.! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/25/2000 18:04'!shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m bounds]).	canvas _ (Display defaultCanvasClass extent: bnds extent depth: 1) 		asShadowDrawingCanvas: Color black.	canvas translateBy: bnds topLeft negated		during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].	^ canvas form offset: bnds topLeft! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/25/2000 18:04'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| subBnds rectList |	"Always check for real translucency -- can't be cached in a form"	self allMorphsDo: [:m |		m hasTranslucentColor ifTrue: [			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ Display defaultCanvasClass extent: subBnds extent depth: depth.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !!InterpolatingImageMorph methodsFor: 'drawing' stamp: 'ar 5/25/2000 17:59'!cachedImageForDepth: aDepth	(cachedImage ~~ nil and:[cachedImage depth = aDepth])		ifTrue:[^cachedImage].	cachedImage _ nil. "In case we need some space"	cachedImage _ Form extent: self bounds extent depth: aDepth.	self drawImage: image on: (cachedImage getCanvas).	^cachedImage! !!PaintBoxMorph methodsFor: 'actions' stamp: 'ar 5/25/2000 18:00'!actionCursor	"Return the cursor to use with this painting action/tool. Offset of the form must be set."	| ff width co larger c box |action == #paint: ifTrue: ["Make a cursor from the brush and the color"		width _ self getNib width.		c _ self ringColor.		co _ (currentCursor offset - ((width//4)@34-(width//6))) min: (0@0).				larger _ width negated + 10@0 extent: currentCursor extent + (width@width).		ff _ currentCursor copy: larger.		ff colors at: 1 put: Color transparent.         	ff colors at: 2 put: Color transparent.	          ff offset: co - (width@width //2).            (ff getCanvas) fillOval: (Rectangle center: ff offset negated						extent: width@width)                        color: Color transparent                        borderWidth: 1                        borderColor: c.	 	 ^ ff].		action == #erase: ifTrue: ["Make a cursor from the cursor and the color"		width _ self getNib width.		co _ (currentCursor offset + (width//2@4)) min: (0@0).		larger _ 0@0 extent: currentCursor extent + (width@width).		ff _ currentCursor copy: larger.		ff offset: co - (width@width //2).		ff fill: (box _ co negated extent: (width@width)) 					fillColor: (Color r: 0.5 g: 0.5 b: 1.0).		ff fill: (box insetBy: 1@1) fillColor: Color transparent.				^ ff].	^ currentCursor! !!PaintBoxMorph class methodsFor: 'as yet unclassified' stamp: 'ar 5/25/2000 18:00'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb findButton: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ button onImage getCanvas.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/25/2000 18:04'!assuredCanvas	(self canvas == nil or:	 [(self canvas extent ~= self viewBox extent)		or: [self canvas form depth ~= Display depth]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (Display defaultCanvasClass extent: self viewBox extent)].	^ self canvas! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/25/2000 18:00'!displayWorldAsTwoTone	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f _ ColorForm extent: self viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: (f getCanvas).	"force the entire canvas to be redrawn"	self fullRepaintNeeded.	self drawInvalidAreasOn: self canvas.  "redraw on offscreen canvas"	self canvas showAt: self viewBox origin.  "copy redrawn areas to Display"	Display forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/25/2000 18:04'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(self canvas == nil or:	 [(self canvas extent ~= self viewBox extent) or:	 [self canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (Display defaultCanvasClass extent: self viewBox extent)].	self canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: self canvas].	self hands reverseDo: [:h | h fullDrawOn: self canvas].	self canvas form displayOn: Display at: self viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Display forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/25/2000 18:03'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false].	DisableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self == World		ifTrue: [  "this world fills the entire Display"			((self canvas == nil) or: [self canvas form ~~ Display]) ifTrue: [				self canvas: (Display getCanvas).				self viewBox: Display boundingBox]]		ifFalse: [  "this world is inside an MVC window"			((self canvas == nil) or:			 [(self canvas form ~~ Display) or:			 [(self canvas origin ~= self viewBox origin)]]) ifTrue: [				self canvas:					((Display getCanvas)						copyOffset: self viewBox origin clipRect: self viewBox)]].	^ true! !!PolygonMorph methodsFor: 'private' stamp: 'ar 5/25/2000 18:04'!borderForm	"A form must be created for drawing the border whenever the borderColor is translucent."	| borderCanvas |	borderForm ifNotNil: [^ borderForm].	borderCanvas _ (Display defaultCanvasClass extent: bounds extent depth: 1)		shadowColor: Color black.	borderCanvas translateBy: bounds topLeft negated		during:[:tempCanvas| self drawBorderOn: tempCanvas].	borderForm _ borderCanvas form.	self arrowForms do:		[:f |  "Eliminate overlap between line and arrowheads if transparent."		borderForm copy: f boundingBox from: f to: f offset - self position rule: Form erase].	^ borderForm! !!Project methodsFor: 'displaying' stamp: 'ar 5/25/2000 18:01'!imageFormOfSize: extentPoint depth: d	| newDisplay |	newDisplay _ DisplayScreen extent: extentPoint depth: d.	Display replacedBy: newDisplay do:[		world isMorph 			ifTrue:[world fullDrawOn: (Display getCanvas)] "Morphic"			ifFalse:[world restore]. "MVC"	].	^newDisplay! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 5/25/2000 18:01'!prepareToPaint	"Figure out what the current brush, fill, etc is.  Return an action to take every mouseMove.  Set up instance variable and pens.  Prep for normal painting is inlined here.  tk 6/14/97 21:11"	| specialMode |	"Install the brush, color, (replace mode), and cursor."	specialMode _ palette getSpecial. 	currentColor  _ palette getColor.	brush _ currentNib _ palette getNib.	paintingFormPen _ Pen newOnForm: paintingForm.	stampForm _ nil.	"let go of stamp"	formCanvas _ paintingForm getCanvas.	"remember to change when undo"	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	specialMode == #paint: ifTrue: [		"get it to one bit depth.  For speed, instead of going through a colorMap every time ."		brush _ Form extent: brush extent depth: 1.		brush offset: (0@0) - (brush extent // 2).		currentNib displayOn: brush at: (0@0 - currentNib offset).		paintingFormPen sourceForm: brush.		paintingFormPen combinationRule: Form paint.		paintingFormPen color: currentColor.		currentColor isTransparent ifTrue: [			paintingFormPen combinationRule: Form erase1bitShape.			paintingFormPen color: Color black].		^ #paint:].	specialMode == #erase: ifTrue: [		self erasePrep.		^ #erase:].	specialMode == #stamp: ifTrue: [		stampForm _ palette stampForm.	"keep it"		^ #stamp:].	(self respondsTo: specialMode) 		ifTrue: [^ specialMode]	"fill: areaFill: pickup: (in mouseUp:) 				rect: ellipse: line: polygon: star:"		ifFalse: ["Don't recognise the command"			palette setAction: #paint:.	"set it to Paint"			^ self prepareToPaint].! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 5/25/2000 18:01'!undo	"revert to a previous state.  "	| temp poly |	undoBuffer ifNil: [^ self beep].	"nothing to go back to"	(poly _ self valueOfProperty: #polygon) ifNotNil:		[poly delete.		self setProperty: #polygon toValue: nil.		^ self].	temp _ paintingForm.	paintingForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had byundoing again"	paintingFormPen setDestForm: paintingForm.	formCanvas _ paintingForm getCanvas.	"used for lines,ovals, etc."	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	self render: bounds.! !!TTGlyph methodsFor: 'private' stamp: 'ar 5/25/2000 18:01'!display	| canvas |	canvas _ Display getCanvas.	self contours do:[:ptArray|		1 to: ptArray size by: 3 do:[:i|			canvas line: (ptArray at: i) // 10					to: (ptArray at: i+2) // 10					width: 1 color: Color black.		].	].! !!TextContainer methodsFor: 'private' stamp: 'ar 5/25/2000 18:04'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (Display defaultCanvasClass extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: tempCanvas]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back _ tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [m fullDrawOn: tempCanvas]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'ar 5/25/2000 18:01'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| maxExtent lineForm leftInRun lineRect warp sourceQuad backgroundColor lineCanvas |	warp _ nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may hot have to display at all."				maxExtent _ lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm _ Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect _ lineForm boundingBox.				leftInRun _ 0.				backgroundColor _ (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp _ (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas _ lineForm getCanvas].			sourceQuad _ destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun _ displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !!ThreePhaseButtonMorph class methodsFor: 'class initialization' stamp: 'ar 5/25/2000 18:01'!initialize	"ThreePhaseButtonMorph initialize"	| extent inset |	extent _ 12@12.	inset _ 3.	#('CheckBoxOff' 'CheckBoxOn' 'CheckBoxPressed') do: [:button |		| f r |		f _ ColorForm extent: extent depth: 1.		f colors: {Color transparent. Color black}.		f borderWidth: 1.		r _ f boundingBox insetBy: inset.		button = 'CheckBoxPressed' ifTrue: [f border: r width: 1].		button = 'CheckBoxOn' ifTrue: [f fillBlack: r].		ScriptingSystem saveForm: f atKey: button].	#('RadioButtonOff' 'RadioButtonOn' 'RadioButtonPressed') do: [:button |		| f r c |		f _ ColorForm extent: extent depth: 1.		f colors: {Color transparent. Color black}.		r _ f boundingBox.		c _ f getCanvas.		c frameOval: r color: Color black.		r _ r insetBy: inset.		button = 'RadioButtonPressed' ifTrue:			[c frameOval: r color: Color black].		button = 'RadioButtonOn' ifTrue:			[c fillOval: r color: Color black].		ScriptingSystem saveForm: f atKey: button]! !!ThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/25/2000 18:04'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee viewedMorphBox myBox scale c shrunkForm aWorld |	super drawOn: aCanvas.	((((actualViewee _ self actualViewee) ~~ nil and: [(aWorld _ actualViewee world) ~~ nil])			and: [aWorld ~~ actualViewee or: [lastFormShown == nil]]) and: [RecursionDepth + 1 < RecursionMax])		ifTrue:			[RecursionDepth _ RecursionDepth + 1.			viewedMorphBox _ actualViewee fullBounds.			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ Display defaultCanvasClass extent: viewedMorphBox extent depth: aCanvas depth.			c translateBy: viewedMorphBox topLeft negated 				"recursion happens here"				during:[:tempCanvas| actualViewee fullDrawOn: tempCanvas].			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:  "This branch used if we've recurred, or if the thumbnail views a World that's already been rendered once, or if the referent is not in a world at the moment"			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas paintImage: shrunkForm at: self center - shrunkForm boundingBoxcenter]	"sw 12/20/1999 13:35 special-case code for SketchMorph commented out, since it seems to have done more harm than good: 			((actualViewee isKindOf: SketchMorph) and: [false])				ifTrue:					[diag _ actualViewee form extent  asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds]."! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'ar 5/25/2000 18:02'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip _ self viewBox intersect: parentWorld viewBox.	self canvas: (		(Display getCanvas)			copyOffset:  0@0			clipRect: newClip	)! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'ar 5/25/2000 17:59'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip _ self viewBox "intersect: parentWorld viewBox".	self canvas: (		(Display getCanvas)			copyOffset:  0@0			clipRect: newClip	)! !!WonderlandCameraMorph methodsFor: 'debug' stamp: 'ar 5/25/2000 18:02'!debugDraw	Display deferUpdates: false.	self fullDrawOn: (Display getCanvas).	Display deferUpdates: false.	Display forceToScreen: bounds.! !!WonderlandCameraMorph methodsFor: 'pooh-actions' stamp: 'ar 5/25/2000 18:02'!prepareAction: newEvent	|  range  |	currentColor _ palette getColor.	currentNib _ palette getNib.	currentActor _ newEvent getActor.	currentCanvas _ (currentActor getTexturePointer getCanvas).	range _ currentCanvas extent.	currentPosition _ newEvent getVertex texCoords * range - (currentNib extent // 2).! !ThreePhaseButtonMorph initialize!