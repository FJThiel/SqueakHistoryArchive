SystemOrganization addCategory: #'FlexibleVocabularies-Info'!!EToyVocabulary class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 7/3/2003 20:07'!morphClassesDeclaringViewerAdditions	"Answer a list of actual morph classes that either implement #additionsToViewerCategories,	or that have methods that match #additionToViewerCategory* ."	^(Morph class allSubInstances select: [ :ea | ea hasAdditionsToViewerCategories ])! !!SyntaxMorph class methodsFor: '*flexiblevocabularies-accessing' stamp: 'nk 8/29/2004 16:52'!allSpecs	"Return all specs that the Viewer knows about. Cache them."	"SyntaxMorph allSpecs"	^AllSpecs ifNil: [		AllSpecs _ Dictionary new.		(EToyVocabulary morphClassesDeclaringViewerAdditions)			do: [:cls | cls allAdditionsToViewerCategories keysAndValuesDo: [ :k :v | 				(AllSpecs at: k ifAbsentPut: [ OrderedCollection new ]) addAll: v ] ].		AllSpecs	]! !!SyntaxMorph class methodsFor: '*flexiblevocabularies-accessing' stamp: 'nk 4/22/2004 20:39'!clearAllSpecs	"Clear the specs that the Viewer knows about."	"SyntaxMorph clearAllSpecs"	AllSpecs _ nil.! !!TheWorldMenu methodsFor: '*flexibleVocabularies-construction' stamp: 'nk 8/21/2004 13:36'!scriptingMenu	"Build the authoring-tools menu for the world."	^ self fillIn: (self menu: 'authoring tools...') from: { 		{ 'objects (o)' . { #myWorld . #activateObjectsTool }. 'A searchable source of new objects.'}.		nil.  "----------" 		{ 'view trash contents' . { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.'}. 		{ 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.		nil.  "----------"			{ 'new scripting area' . { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.		nil.  "----------"					{ 'status of scripts' . {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.'}.		{ 'summary of scripts' . {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.'}.		{ 'browser for scripts' . {#myWorld . #browseAllScriptsTextually}. 'Allows you to view all the scripts in the project in a traditional programmers'' "browser" format'}.		nil.		{ 'gallery of players' . {#myWorld . #galleryOfPlayers}. 'A tool that lets you find out about all the players used in this project'}."		{ 'gallery of scripts' . {#myWorld . #galleryOfScripts}. 'Allows you to view all the scripts in the project'}."		{ 'EToy vocabulary summary' . {#myWorld . #printVocabularySummary }. 'Displays a summary of all the pre-defined commands and properties in the pre-defined EToy vocabulary.'}.		{ 'attempt misc repairs' . {#myWorld . #attemptCleanup}. 'Take measures that may help fix up some things about a faulty or problematical project.'}.		{ 'remove all viewers' . {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.'}.		nil.  "----------" 		{ 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.		{ 'unhide hidden objects' . { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!Morph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/21/2004 13:28'!filterViewerCategoryDictionary: dict	"dict has keys of categories and values of priority.	You can re-order or remove categories here."	Preferences eToyFriendly		ifTrue: [dict removeKey: #layout].! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/29/2004 16:35'!additionsToViewerCategory: aCategoryName	"Answer a list of viewer specs for items to be added to the given category on behalf of the receiver.  Each class in a morph's superclass chain is given the opportunity to add more things"	aCategoryName == #vector ifTrue:		[^ self vectorAdditions].	^self allAdditionsToViewerCategories at: aCategoryName ifAbsent: [ #() ].! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/11/2003 17:48'!noteCompilationOf: aSelector meta: isMeta 	"Any change to an additionsToViewer... method can invalidate existing etoy vocabularies.	The #respondsTo: test is to allow loading the FlexibleVocabularies change set without having to worry about method ordering."	(isMeta			and: [(aSelector beginsWith: 'additionsToViewer')					and: [self respondsTo: #hasAdditionsToViewerCategories]])		ifTrue: [Vocabulary changeMadeToViewerAdditions].	super noteCompilationOf: aSelector meta: isMeta! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/29/2004 16:36'!allAdditionsToViewerCategories	"Answer a Dictionary of (<categoryName> <list of category specs>) that characterizes the	phrases this kind of morph wishes to add to various Viewer categories.	This version factors each category definition into a separate method.	Subclasses that have additions can either:		- override #additionsToViewerCategories, or		- (preferably) define one or more additionToViewerCategory* methods.	The advantage of the latter technique is that class extensions may be added	by external packages without having to re-define additionsToViewerCategories.	"	"Morph allAdditionsToViewerCategories size"	| dict |	dict _ IdentityDictionary new.	(self class includesSelector: #additionsToViewerCategories)		ifTrue: [self additionsToViewerCategories				do: [:group | group pairsDo: [:key :list |					(dict at: key ifAbsentPut: [OrderedCollection new])						addAll: list]]].	self additionToViewerCategorySelectors do: [ :aSelector |		(self perform: aSelector) pairsDo: [ :key :list |			(dict at: key ifAbsentPut: [ OrderedCollection new ]) addAll: list ]].	^dict! !!Morph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/29/2004 16:33'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	| aClass aList dict n additions |	aClass _ self renderedMorph class.	dict _ IdentityDictionary new.	n _ 3.	[aClass == Morph superclass ] whileFalse:		[(aClass hasAdditionsToViewerCategories) ifTrue: [			additions _ aClass allAdditionsToViewerCategories keys.			additions asOrderedCollection do: [:categorySpec |				dict at: categorySpec put: n. n _ n + 0.001 ]		].		aClass _ aClass superclass.		n _ aClass == Morph ifTrue: [ 2 ] ifFalse: [ n + 1 ].	]. 	n _ 1.	#(basic #'color & border' geometry motion #'pen use' tests layout #'drag & drop' scripting observation button search miscellaneous) do: [ :ea |		(dict includesKey: ea) ifTrue: [ dict at: ea put: n. n _ n + 0.001 ]	].	self filterViewerCategoryDictionary: dict.	aList _ SortedCollection sortBlock: [ :a :b | a value < b value ].	dict associationsDo: [ :assoc | aList add: assoc ].	^aList collect: [ :ea | ea key ]! !!Morph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/29/2004 17:09'!selectorsForViewer	"Answer a list of symbols representing all the selectors available in all my viewer categories"	| aClass aList itsAdditions added addBlock |	aClass := self renderedMorph class.	aList := OrderedCollection new.	added := Set new.	addBlock := [ :sym | (added includes: sym) ifFalse: [ added add: sym. aList add: sym ]].	[aClass == Morph superclass] whileFalse: 			[(aClass hasAdditionsToViewerCategories) 				ifTrue: 					[itsAdditions := aClass allAdditionsToViewerCategories.					itsAdditions do: [ :add | add do: [:aSpec |									"the spec list"									aSpec first == #command ifTrue: [ addBlock value: aSpec second].									aSpec first == #slot 										ifTrue: 											[ addBlock value: (aSpec seventh).											 addBlock value: aSpec ninth]]]].			aClass := aClass superclass].	^aList copyWithoutAll: #(#unused #dummy)	"SimpleSliderMorph basicNew selectorsForViewer"! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 4/22/2004 19:46'!hasAdditionsToViewerCategories	"Answer true if I have defined additionsToViewerCategories or methods with names matching additionsToViewerCategory*"	^self class selectors anySatisfy: [ :ea |			ea == #additionsToViewerCategories or: [				(ea beginsWith: 'additionsToViewerCategory')					and: [ (ea at: 26 ifAbsent: []) ~= $: ]]]! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/11/2003 18:06'!additionToViewerCategorySelectors	"Answer the list of my selectors matching additionsToViewerCategory*"	^self class organization allMethodSelectors select: [ :ea |		(ea beginsWith: 'additionsToViewerCategory')					and: [ (ea at: 26 ifAbsent: []) ~= $: ]]! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/11/2003 18:17'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the	phrases this kind of morph wishes to add to various Viewer categories.	This version factors each category definition into a separate method.	Subclasses that have additions can either:		- override this method, or		- (preferably) define one or more additionToViewerCategory* methods.	The advantage of the latter technique is that class extensions may be added	by external packages without having to re-define additionsToViewerCategories.	"	^#()! !!Morph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/29/2004 17:14'!selectorsForViewerIn: aCollection	"Answer a list of symbols representing all the selectors available in all my viewer categories, selecting only the ones in aCollection"	| aClass aList itsAdditions added addBlock |	aClass := self renderedMorph class.	aList := OrderedCollection new.	added := Set new.	addBlock := [ :sym |		(added includes: sym) ifFalse: [ (aCollection includes: sym)			ifTrue: [ added add: sym. aList add: sym ]]].	[aClass == Morph superclass] whileFalse: 			[(aClass hasAdditionsToViewerCategories) 				ifTrue: 					[itsAdditions := aClass allAdditionsToViewerCategories.					itsAdditions do: [ :add | add do: [:aSpec |									"the spec list"									aSpec first == #command ifTrue: [ addBlock value: aSpec second].									aSpec first == #slot 										ifTrue: 											[ addBlock value: (aSpec seventh).											 addBlock value: aSpec ninth]]]].			aClass := aClass superclass].	^aList copyWithoutAll: #(#unused #dummy)	"SimpleSliderMorph basicNew selectorsForViewerIn: 	#(setTruncate: getColor setColor: getKnobColor setKnobColor: getWidth setWidth: getHeight setHeight: getDropEnabled setDropEnabled:)	"! !!EToyVocabulary methodsFor: '*flexiblevocabularies-initialization' stamp: 'nk 8/31/2004 16:10'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	|   classes aMethodCategory selector selectors categorySymbols aMethodInterface |	super initialize.	self vocabularyName: #eToy.	self documentation: '"EToy" is a vocabulary that provides the equivalent of the 1997-2000 etoy prototype'.	categorySymbols _ Set new.	classes _ self class morphClassesDeclaringViewerAdditions.	classes do:		[:aMorphClass | categorySymbols addAll: aMorphClass basicNew categoriesForViewer].	self addCustomCategoriesTo: categorySymbols.  "For benefit, e.g., of EToyVectorVocabulary"	categorySymbols asOrderedCollection do:		[:aCategorySymbol |			aMethodCategory _ ElementCategory new categoryName: aCategorySymbol.			selectors _ Set new.			classes do:				[:aMorphClass |					 (aMorphClass additionsToViewerCategory: aCategorySymbol) do:						[:anElement |						aMethodInterface _ self methodInterfaceFrom: anElement.						selectors add: (selector _ aMethodInterface selector).						(methodInterfaces includesKey: selector) ifFalse:							[methodInterfaces at: selector put: aMethodInterface].						self flag: #deffered.						"NB at present, the *setter* does not get its own method interface.  Need to revisit"].			(selectors copyWithout: #unused) asSortedArray do:				[:aSelector |					aMethodCategory elementAt: aSelector put: (methodInterfaces at: aSelector)]].				 			self addCategory: aMethodCategory].	self addCategoryNamed: ScriptingSystem nameForInstanceVariablesCategory.	self addCategoryNamed: ScriptingSystem nameForScriptsCategory.	self setCategoryDocumentationStrings.	(self respondsTo: #applyMasterOrdering)		ifTrue: [ self applyMasterOrdering ].! !!EToyVocabulary class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/29/2004 16:54'!vocabularySummary	"Answer a string describing all the vocabulary defined anywhere in the 	system."	"	(StringHolder new contents: EToyVocabulary vocabularySummary)  	openLabel: 'EToy Vocabulary' translated 	"	| etoyVocab rt interfaces |	etoyVocab := Vocabulary eToyVocabulary.	^ String		streamContents: [:s | self morphClassesDeclaringViewerAdditions				do: [:cl | 					s nextPutAll: cl name;						 cr.					cl allAdditionsToViewerCategories						keysAndValuesDo: [:cat :additions | 							interfaces := (etoyVocab categoryAt: cat) elementsInOrder.							interfaces := interfaces										select: [:ea | additions												anySatisfy: [:tuple | (tuple first = #slot														ifTrue: [tuple at: 7]														ifFalse: [tuple at: 2])														= ea selector]].							s tab; nextPutAll: cat translated; cr.							interfaces								do: [:if | 									s tab: 2.									rt := if resultType.									rt = #unknown										ifTrue: [s nextPutAll: 'command' translated]										ifFalse: [s nextPutAll: 'property' translated;												 nextPut: $(;												 nextPutAll: (if companionSetterSelector													ifNil: ['RO']													ifNotNil: ['RW']) translated;												 space;												 nextPutAll: rt translated;												 nextPutAll: ') '].									s tab; print: if wording; space.									if argumentVariables										do: [:av | s nextPutAll: av variableName;												 nextPut: $(;												 nextPutAll: av variableType asString;												 nextPut: $)]										separatedBy: [s space].									s tab; nextPutAll: if helpMessage; cr]]]]! !PackageInfo subclass: #FlexibleVocabulariesInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FlexibleVocabularies-Info'!!FlexibleVocabulariesInfo commentStamp: 'nk 3/11/2004 16:38' prior: 0!Package:		FlexibleVocabularies-nkDate:			12 October 2003Author:			Ned KonzThis makes it possible for packages to extend Morph class vocabularies.Previously, you'd have to edit #additionsToViewerCategories, which would result in potential conflicts between different packages that all wanted to (for instance) extend Morph's vocabulary.Subclasses that have additions can do one or both of:	- override #additionsToViewerCategories (as before)	- define one or more additionToViewerCategory* methods.The advantage of the latter technique is that class extensions may be addedby external packages without having to re-define additionsToViewerCategories.So, for instance, package A could add a method named #additionsToViewerCategoryPackageABasicand its methods would be added to the vocabulary automatically.NOTE: this change set is hand-rearranged to avoid problems on file-in.Specifically, Morph>>hasAdditionsToViewerCategories must come before Morph class>>additionsToViewerCategories!!FlexibleVocabulariesInfo class methodsFor: 'class initialization' stamp: 'nk 5/3/2004 15:48'!initialize	[self new register] on: MessageNotUnderstood do: [].	SyntaxMorph class removeSelector: #initialize.	SyntaxMorph removeSelector: #allSpecs.	EToyVocabulary removeSelector: #morphClassesDeclaringViewerAdditions.	SyntaxMorph clearAllSpecs.	Vocabulary initialize.! !!PasteUpMorph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/21/2004 13:35'!printVocabularySummary	"Put up a window with summaries of all Morph vocabularies."		(StringHolder new contents: EToyVocabulary vocabularySummary) 	openLabel: 'EToy Vocabulary' 	"self currentWorld printVocabularySummary"! !!StandardScriptingSystem class methodsFor: '*flexibleVocabularies-class initialization' stamp: 'nk 9/29/2003 12:07'!noteCompilationOf: aSelector meta: isMeta	aSelector == #wordingForOperator: ifTrue:		[Vocabulary changeMadeToViewerAdditions].	super noteCompilationOf: aSelector meta: isMeta! !FlexibleVocabulariesInfo initialize!