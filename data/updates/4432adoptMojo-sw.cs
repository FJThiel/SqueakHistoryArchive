'From Squeak3.2alpha of 2 October 2001 [latest update: #4431] on 16 October 2001 at 12:49:33 pm'!"Change Set:		adoptMojo-swDate:			16 October 2001Author:			Scott WallaceMakes it possible to retrofit into an object the player code/data structures (user-defined scripts and user-defined instance variables) preexisting in another object.  Three ways to request this:(1)  From the halo menu of any *scripted* SketchMorph, choose 'impart scripts to...', then click the ensuing cross-hair cursor onto any unscripted SketchMorph.(2)  From the halo menu of any *unscripted* SketchMorph, choose 'adopt scripts from...', then click the ensuing cross-hair cursor onto any *scripted* SketchMorph.(3)  From the Viewer menu of any scripted SketchMorph, choose 'impart scripts to...', then click the ensuing cross-hair cursor onto any unscripted SkechMorph.At the moment this facility only works between SketchMorphs.There are almost unbelievable complexities relating to rotation here.  As long as the *recipient* is unflexed, everything is cool, but if the recipient is flexed when the operation is requested, a slight shift in the position of the recipient can result.I invite any eager (or unemployed) soul to try to fix this."!!Player methodsFor: 'pen' stamp: 'sw 10/16/2001 08:01'!addPlayerMenuItemsTo: aMenu hand: aHandMorph	"Note that these items are primarily available in another way in an object's Viewer"	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	self getPenDown		ifTrue: [subMenu add: 'lift pen' action: #liftPen]		ifFalse: [subMenu add: 'lower pen' action: #lowerPen].	subMenu add: 'choose pen size...' action: #choosePenSize.	subMenu add: 'choose pen color...' action: #choosePenColor:.	aMenu add: 'pen...' subMenu: subMenu.	(costume renderedMorph isKindOf: SketchMorph) ifTrue:		[self belongsToUniClass			ifFalse: 				[aMenu add: 'adopt scripts from...' target: self action: #adoptScriptsFrom]			ifTrue:				[aMenu add: 'impart scripts to...' target: self action: #impartSketchScripts]]! !!Player methodsFor: 'misc' stamp: 'sw 10/15/2001 17:21'!adoptScriptsFrom	"Let the user click on another object form which the receiver should obtain scripts and code"	| aMorph |	Sensor waitNoButton.	aMorph _ ActiveWorld chooseClickTarget.	aMorph ifNil: [^ self beep].	(((aMorph isKindOf: SketchMorph) and: [aMorph player belongsToUniClass]) and: [self belongsToUniClass not])		ifTrue:			[costume acquirePlayerSimilarTo: aMorph player]		ifFalse:			[self beep]! !!Player methodsFor: 'misc' stamp: 'sw 10/16/2001 07:54'!impartSketchScripts	"Let the user designate another object to which my scripts and code should be imparted"	| aMorph |	Sensor waitNoButton.	aMorph _ ActiveWorld chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph renderedMorph isKindOf: SketchMorph) ifTrue:		[aMorph acquirePlayerSimilarTo: self]! !!Player methodsFor: 'misc' stamp: 'sw 10/16/2001 07:54'!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld _ aViewer world.	aMenu _ MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.'.	aMenu add: 'choose limit class...' target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.'.	aMenu add: 'open standard lexicon' target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format'.	aMenu add: 'open lexicon with search pane' target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)'.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect].	aMenu add: 'inspect this Viewer' target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' target: aViewer action: #relaunchViewer.	aMenu add: 'view morph directly' target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.'.	(costume renderedMorph isKindOf: SketchMorph) ifTrue:		[aMenu addLine.		aMenu add: 'impart scripts to...' target: self action: #impartSketchScripts].	aMenu popUpEvent: evt in: aWorld! !!SketchMorph methodsFor: 'e-toy support' stamp: 'sw 10/16/2001 12:37'!acquirePlayerSimilarTo: aSketchMorphsPlayer	"Retrofit into the receiver a player derived from the existing scripted player of a different morph.  Works only between SketchMorphs. Maddeningly complicated, as usual, by the TransformationMorph architecture.  There are still cases where this operation results in a slight shift in the position of the recipient -- consult the preamble to the adoptMojo update for details.  Fixes invited!!"	| myName myTop itsTop newTop newSketch |	myTop _ self topRendererOrSelf.	aSketchMorphsPlayer belongsToUniClass ifFalse: [^ self beep].	itsTop _ aSketchMorphsPlayer costume.	(itsTop renderedMorph isKindOf: SketchMorph)		ifFalse:	[^ self beep].	newTop _ itsTop veryDeepCopy.  "May be a sketch or a tranformation"	myName _ myTop externalName.  "Snag before the replacement is added to the world, because otherwise that could affect this"	newSketch _ newTop renderedMorph.	newSketch form: self form.	newSketch scalePoint: self scalePoint.	newSketch extent: self extent.	myTop owner addMorph: newTop after: myTop.	newTop heading ~= myTop heading ifTrue:		"avoids annoying round-off error in what follows"			[newTop player setHeading: myTop heading]. 	(newTop isFlexMorph and: [myTop == self])		ifTrue:			[newTop removeFlexShell].	newTop _ newSketch topRendererOrSelf.	newTop position: myTop position.	newTop extent: myTop extent.	newTop setNameTo: myName.	myTop delete! !