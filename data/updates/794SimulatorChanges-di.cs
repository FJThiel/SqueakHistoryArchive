'From Squeak 2.3 of January 14, 1999 on 5 April 1999 at 12:30:37 pm'!"Change Set:		SimulatorChangesDate:			3 April 1999Author:			Dan IngallsBy editing Interpreter methods to include Smalltalk (cCode:inSmalltalk:), many methods can be removed from the InterpreterSimulator.  That's what this changeSet does.  It reduces the number of lines of code in the InterpreterSimulator from 1010 to 790 lines.Also fixes a bug in inlining related to the new cCode:inSmalltalk: facility."!!CCodeGenerator methodsFor: 'inlining' stamp: 'di 4/5/1999 12:16'!collectInlineList	"Make a list of methods that should be inlined."	"Details: The method must not include any inline C, since the translator cannot currently map variable names in inlined C code. Methods to be inlined must be small or called from only one place."	| methodsNotToInline callsOf inlineIt hasCCode nodeCount senderCount |	methodsNotToInline _ Set new: methods size.	"build dictionary to record the number of calls to each method"	callsOf _ Dictionary new: methods size * 2.	methods keys do: [ :sel | callsOf at: sel put: 0 ].	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	inlineList _ Set new: methods size * 2.	methods do: [ :m |		inlineIt _ #dontCare.		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel _ node selector.					(sel = #cCode: or: [sel = #cCode:inSmalltalk:])						ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: sel ifAbsent: [ nil ].					nil = senderCount ifFalse: [						callsOf at: sel put: senderCount + 1.					].				].				nodeCount _ nodeCount + 1.			].			inlineIt _ m extractInlineDirective.  "may be true, false, or #dontCare"		].		(hasCCode or: [inlineIt = false]) ifTrue: [			"don't inline if method has C code and is contains negative inline directive"			methodsNotToInline add: m selector.		] ifFalse: [			((nodeCount < 40) or: [inlineIt = true]) ifTrue: [				"inline if method has no C code and is either small or contains inline directive"				inlineList add: m selector.			].		].	].	callsOf associationsDo: [ :assoc |		((assoc value = 1) and: [(methodsNotToInline includes: assoc key) not]) ifTrue: [			inlineList add: assoc key.		].	].! !!Interpreter methodsFor: 'utilities' stamp: 'di 4/3/1999 21:29'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	"Note: May be called by translated primitive code."	| intOrFloat floatVal frac trunc |	self inline: false.	self var: #floatVal declareC: 'double floatVal'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	intOrFloat _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOrFloat) ifTrue: [^ self integerValueOf: intOrFloat].	self assertClassOf: intOrFloat is: (self splObj: ClassFloat).	successFlag ifTrue: [		self cCode: '' inSmalltalk: [floatVal _ Float new: 2].		self fetchFloatAt: intOrFloat + BaseHeaderSize into: floatVal.		self cCode: 'frac = modf(floatVal, &trunc)'.		"the following range check is for C ints, with range -2^31..2^31-1"		self cCode: 'success((-2147483648.0 <= trunc) && (trunc <= 2147483647.0))'].	successFlag		ifTrue: [^ self cCode: '((int) trunc)' inSmalltalk: [floatVal truncated]]		ifFalse: [^ 0].! !!Interpreter methodsFor: 'utilities' stamp: 'di 4/3/1999 17:05'!floatValueOf: oop	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	self assertClassOf: oop is: (self splObj: ClassFloat).	successFlag		ifTrue: [self cCode: '' inSmalltalk: [result _ Float new: 2].				self fetchFloatAt: oop + BaseHeaderSize into: result]		ifFalse: [result _ 0.0].	^ result! !!Interpreter methodsFor: 'utilities' stamp: 'di 4/4/1999 00:00'!loadFloatOrIntFrom: floatOrInt	"If floatOrInt is an integer, then convert it to a C double float and return it.	If it is a Float, then load its value and return it.	Otherwise fail -- ie return with successFlag set to false."	self inline: true.	self returnTypeC: 'double'.	(self isIntegerObject: floatOrInt) ifTrue:		[^ self cCode: '((double) (floatOrInt >> 1))'				inSmalltalk: [(self integerValueOf: floatOrInt) asFloat]].	(self fetchClassOfNonInt: floatOrInt) = (self splObj: ClassFloat)		ifTrue: [^ self floatValueOf: floatOrInt].	successFlag _ false! !!Interpreter methodsFor: 'contexts' stamp: 'di 4/3/1999 21:26'!stackFloatValue: offset	"Note: May be called by translated primitive code."	| result floatPointer |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	floatPointer _ self longAt: stackPointer - (offset*4).	(self fetchClassOf: floatPointer) = (self splObj: ClassFloat) 		ifFalse:[self primitiveFail. ^0.0].	self cCode: '' inSmalltalk: [result _ Float new: 2].	self fetchFloatAt: floatPointer + BaseHeaderSize into: result.	^ result! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 4/3/1999 21:37'!bytecodePrimGreaterOrEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[self cCode: '' inSmalltalk:			[^ self booleanCheat:					(self integerValueOf: rcvr) >= (self integerValueOf: arg)].		^ self booleanCheat: rcvr >= arg].	successFlag _ true.	bool _ self primitiveFloatLess: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 5.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 4/3/1999 21:40'!bytecodePrimGreaterThan	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[self cCode: '' inSmalltalk:			[^ self booleanCheat:				(self integerValueOf: rcvr) > (self integerValueOf: arg)].		^ self booleanCheat: rcvr > arg].	successFlag _ true.	bool _ self primitiveFloatGreater: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 3.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 4/3/1999 21:41'!bytecodePrimLessOrEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[self cCode: '' inSmalltalk:			[^ self booleanCheat:				(self integerValueOf: rcvr) <= (self integerValueOf: arg)].		^ self booleanCheat: rcvr <= arg].	successFlag _ true.	bool _ self primitiveFloatGreater: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 4.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 4/3/1999 21:42'!bytecodePrimLessThan	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[self cCode: '' inSmalltalk: 			[^ self booleanCheat:				(self integerValueOf: rcvr) < (self integerValueOf: arg)].		^ self booleanCheat: rcvr < arg].	successFlag _ true.	bool _ self primitiveFloatLess: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 2.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 21:24'!popFloat	"Note: May be called by translated primitive code."	| top result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	top _ self popStack.	self assertClassOf: top is: (self splObj: ClassFloat).	successFlag ifTrue:		[self cCode: '' inSmalltalk: [result _ Float new: 2].		self fetchFloatAt: top + BaseHeaderSize into: result].	^ result! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:36'!primitiveArctan	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'atan(rcvr)'									inSmalltalk: [rcvr arcTan])]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:35'!primitiveAsFloat	| arg |	arg _ self popInteger.	successFlag		ifTrue: [ self pushFloat: (self cCode: '((double) arg)'									inSmalltalk: [arg asFloat]) ]		ifFalse: [ self unPop: 1 ].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:37'!primitiveExp	"Computes E raised to the receiver power."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'exp(rcvr)'									inSmalltalk: [rcvr exp])]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:38'!primitiveExponent	"Exponent part of this float."	| rcvr frac pwr |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	rcvr _ self popFloat.	successFlag		ifTrue: [  "rcvr = frac * 2^pwr, where frac is in [0.5..1.0)"			self cCode: 'frac = frexp(rcvr, &pwr)'					inSmalltalk: [rcvr exponent].			self pushInteger: pwr - 1]		ifFalse: [self unPop: 1].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:53'!primitiveFloatAdd: rcvrOop toArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushFloat: rcvr + arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:55'!primitiveFloatDivide: rcvrOop byArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self pushFloat: (self cCode: 'rcvr / arg'							inSmalltalk: [rcvr / arg])]].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:56'!primitiveFloatMultiply: rcvrOop byArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushFloat: rcvr * arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:56'!primitiveFloatSubtract: rcvrOop fromArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self pushFloat: rcvr - arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:27'!primitiveFractionalPart	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag		ifTrue: [self cCode: 'frac = modf(rcvr, &trunc)'					inSmalltalk: [frac _ rcvr fractionPart].				self pushFloat: frac]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:44'!primitiveLogN	"Natural log."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'log(rcvr)'									inSmalltalk: [rcvr ln])]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:45'!primitiveSine	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sin(rcvr)'									inSmalltalk: [rcvr sin])]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:45'!primitiveSquareRoot	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	self success: rcvr >= 0.0.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sqrt(rcvr)'									inSmalltalk: [rcvr sqrt])]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:47'!primitiveTimesTwoPower	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)'									inSmalltalk: [rcvr timesTwoPower: arg]) ]		ifFalse: [ self unPop: 2 ].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:49'!primitiveTruncated 	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag ifTrue: [		self cCode: 'frac = modf(rcvr, &trunc)'.		self cCode: 'success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0))'.	].	successFlag		ifTrue: [self cCode: 'pushInteger((int) trunc)'					inSmalltalk: [self pushInteger: rcvr truncated]]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 4/3/1999 16:52'!pushFloat: f	self var: #f declareC: 'double f'.	self push: (self floatObjectOf: f).! !!Interpreter methodsFor: 'I/O primitives' stamp: 'di 4/3/1999 22:05'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex ourCursor |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].		self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize.		self cCode: '' inSmalltalk:			[ourCursor _ Cursor				extent: extentX @ extentY				fromArray: ((1 to: 16) collect: [:i |					((self fetchWord: i-1 ofObject: bitsObj) >> 16) bitAnd: 16rFFFF])				offset: offsetX  @ offsetY]].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)'						inSmalltalk: [ourCursor show]]			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'						inSmalltalk: [ourCursor show]].		self pop: argumentCount].! !!Interpreter methodsFor: 'file primitives' stamp: 'di 4/3/1999 21:46'!asciiDirectoryDelimiter	^ self cCode: 'dir_Delimitor()' inSmalltalk: [FileDirectory pathNameDelimiter asciiValue]! !!Interpreter methodsFor: 'sound primitives' stamp: 'di 4/3/1999 21:33'!primitiveShortAt	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	index _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		value _ self cCode: '*((short int *) addr)' inSmalltalk: [self halfWordAt: addr].		self pop: 2.  "pop rcvr, index"		self pushInteger: value.  "push element value"	].! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 4/3/1999 15:45'!validOop: oop	" Return true if oop appears to be valid "	(oop bitAnd: 1) = 1 ifTrue: [^ true].  "Integer"	(oop bitAnd: 3) = 0 ifFalse: [^ false].  "Uneven address"	oop >= endOfMemory ifTrue: [^ false].  "Out of range"	"could test if within the first large freeblock"	(self longAt: oop) = 4 ifTrue: [^ false].	(self headerType: oop) = 2 ifTrue: [^ false].	"Free object"	^ true! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 4/3/1999 15:46'!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		(self validOop: former) ifFalse: [self halt].		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: CompactClassMask) = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: AllButTypeMask.		(self validOop: former) ifFalse: [self halt]].! !!InterpreterSimulator methodsFor: 'debug support' stamp: 'di 4/3/1999 15:47'!longPrint: oop	| lastPtr val lastLong hdrType prevVal |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		lastPtr _ 256 min: (self lastPointerOf: oop).		hdrType _ self headerType: oop.		hdrType = 2 ifTrue: [lastPtr _ 0].		prevVal _ 0.		(self headerStart: oop) to: lastPtr by: 4 do:			[:a | val _ self longAt: oop+a.			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])			ifTrue:			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]			ifFalse:			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8; space; space.			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].			prevVal _ val].		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.		hdrType = 2			ifTrue:			["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;			space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]			ifFalse:			[(self formatOf: oop) = 3			ifTrue:				[strm cr; tab; nextPutAll: '/ next 3 fields are above SP... /'.				lastPtr+4 to: lastPtr+12 by: 4 do:					[:a | val _ self longAt: oop+a.					strm cr; nextPutAll: a hex; 						space; space; space; nextPutAll: val hex8; space; space.					(self validOop: val) ifTrue: [strm nextPutAll: (self shortPrint: val)]]]			ifFalse:			[lastPtr+4 to: lastLong by: 4 do:				[:a | val _ self longAt: oop+a.				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 					space; space; space.				strm nextPutAll: val hex8; space; space;						nextPutAll: (self charsOfLong: val)]]].	]! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 4/3/1999 17:07'!fetchFloatAt: floatBitsAddress into: aFloat	aFloat at: 1 put: (self longAt: floatBitsAddress).	aFloat at: 2 put: (self longAt: floatBitsAddress+4).! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 4/3/1999 15:56'!storeFloatAt: floatBitsAddress from: aFloat.	self longAt: floatBitsAddress put: (aFloat at: 1).	self longAt: floatBitsAddress+4 put: (aFloat at: 2).! !InterpreterSimulator removeSelector: #bytecodePrimLessThan!InterpreterSimulator removeSelector: #primitiveAsFloat!InterpreterSimulator removeSelector: #floatValueOf:!InterpreterSimulator removeSelector: #primitiveShortAt!InterpreterSimulator removeSelector: #primitiveArctan!InterpreterSimulator removeSelector: #primitiveBeCursor!InterpreterSimulator removeSelector: #isValidOop:!InterpreterSimulator removeSelector: #primitiveSine!InterpreterSimulator removeSelector: #primitiveExp!InterpreterSimulator removeSelector: #primitiveFloatDivide:byArg:!InterpreterSimulator removeSelector: #primitiveTimesTwoPower!InterpreterSimulator removeSelector: #primitiveFractionalPart!InterpreterSimulator removeSelector: #popFloatOnly!InterpreterSimulator removeSelector: #primitiveLogN!InterpreterSimulator removeSelector: #pushFloat:!InterpreterSimulator removeSelector: #bytecodePrimGreaterThan!InterpreterSimulator removeSelector: #primitiveExponent!InterpreterSimulator removeSelector: #asciiDirectoryDelimiter!InterpreterSimulator removeSelector: #fetchIntegerOrTruncFloat:ofObject:!InterpreterSimulator removeSelector: #floatObjectOf:!InterpreterSimulator removeSelector: #primitiveSquareRoot!InterpreterSimulator removeSelector: #bytecodePrimGreaterOrEqual!InterpreterSimulator removeSelector: #popFloat!InterpreterSimulator removeSelector: #primitiveTruncated!InterpreterSimulator removeSelector: #loadFloatOrIntFrom:!InterpreterSimulator removeSelector: #bytecodePrimLessOrEqual!