'From Squeak2.6 of 12 October 1999 [latest update: #1559] on 23 October 1999 at 7:03:38 pm'!"Change Set:		BigContextsDate:			20 October 1999Author:			Dan IngallsThis changeSet tweaks the VM (you must rebuild it though) so that contexts now have two sizes:  16 and 56 indexable fieds, instead of the former 32 words.  These are the only two sizes used.It also relaxes the former limits on compilation so that many more temps and deeper call nesting can be accomodated.This changeSet also includes a few tweaks to better close the loophole of raw context creation, and to better document how proper context creation works.The resulting VM should be able to run old images (back thru 2.0), but an old VM could crash if running a new image after some method gets compiled that requires more than the old max context size."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts freeLargeContexts interruptCheckCounter displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize BlockContextProto CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextBit LargeContextSize MarkBit MethodContextProto MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotInterpret SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallContextSize SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:55'!newForMethod: aMethod	"This is the only method for creating new contexts, other than primitive cloning.	Any other attempts, such as inherited methods like shallowCopy, should be	avoided or must at least be rewritten to determine the proper size from the	method being activated.  This is because asking a context its size (even basicSize!!)	will not return the real object size but only the number of fields currently	accessible, as determined by stackp."	^ super basicNew: aMethod frameSize! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'di 10/22/1999 09:56'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame _ 16.	"Context range for temps+stack"	LargeFrame _ 56.! !CompiledMethod initialize!!CompiledMethod methodsFor: 'initialize-release' stamp: 'di 10/22/1999 13:14'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"	| largeFrameBit header |	largeFrameBit _ 16r20000.	(self numTemps + newFrameSize) > LargeFrame ifTrue:		[^ self error: 'Cannot compile -- stack including temps is too deep'].	header _ self objectAt: 1.	(header bitAnd: largeFrameBit) ~= 0		ifTrue: [header _ header - largeFrameBit].	self objectAt: 1 put: header			+ ((self numTemps + newFrameSize) > SmallFrame					ifTrue: [largeFrameBit]					ifFalse: [0])! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 10/22/1999 08:06'!newBytes: numberOfBytes nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits |	nTemps > 64 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		largeBit _ (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits _ primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high 2 bits of primitive no. are in high bits of header"				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r600) bitShift: 19)].	^ self newMethod: numberOfBytes + 4 	" +4 to store source code ptr" 		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits! !!ContextPart methodsFor: 'controlling' stamp: 'di 10/23/1999 17:03'!blockCopy: numArgs 	"Primitive. Distinguish a block of code from its enclosing method by 	creating a new BlockContext for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	blockCopy:. Do not use blockCopy: in code that you write!! Only the 	compiler can decide to send the message blockCopy:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 80>	^ (BlockContext newForMethod: self home method)		home: self home		startpc: pc + 2		nargs: numArgs! !!ContextPart methodsFor: 'private' stamp: 'di 10/23/1999 17:04'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: self shortStack].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!ContextPart methodsFor: 'private' stamp: 'di 10/23/1999 17:31'!stackp: newStackp	"Storing into the stack pointer is a potentially dangerous thing.	This primitive stores nil into any cells that become accessible as a result,	and it performs the entire operation atomically."	"Once this primitive is implemented, failure code should cause an error"	<primitive: 76>	self error: 'stackp store failure'."	stackp == nil ifTrue: [stackp _ 0].	newStackp > stackp  'effectively checks that it is a number'		ifTrue: [oldStackp _ stackp.				stackp _ newStackp.				'Nil any newly accessible cells'				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp _ newStackp]"! !!BlockContext commentStamp: 'di 10/23/1999 17:53' prior: 0!My instances function similarly to instances of MethodContext, but they hold the dynamic state for execution of a block in Smalltalk. They access all temporary variables and the method sender via their home pointer, so that those values are effectively shared. Their indexable part is used to store their independent value stack during execution.	My instance must hold onto its home in order to work. This can cause circularities if the home is also pointing (via a temp, perhaps) to the instance. In the rare event that this happens (as in SortedCollection sortBlock:) the message fixTemps will replace home with a copy of home, thus defeating the sharing of temps but, nonetheless, eliminating the circularity.BlockContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a BlockContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.!!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!basicNew: size	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!new	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!new: size	self error: 'Contexts must only be created with newForMethod:'! !!MethodContext commentStamp: 'di 10/23/1999 17:40' prior: 0!My instances hold all the dynamic state associated with the execution of a CompiledMethod. In addition to their inherited state, this includes the receiver, a method, and temporary space in the variable part of the context.	MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.MethodContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a MethodContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.!!MethodContext class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:06'!sender: s receiver: r method: m arguments: args 	"Answer an instance of me with attributes set to the arguments."	^(self newForMethod: m) setSender: s receiver: r method: m arguments: args! !!MethodNode methodsFor: 'code generation' stamp: 'di 10/22/1999 09:04'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs |	self generateIfQuick: 		[:method | 		1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].		method cacheTempNames: self tempNames.		^method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].	method cacheTempNames: self tempNames.	^ method! !!ObjectMemory methodsFor: 'initialization' stamp: 'di 10/22/1999 10:44'!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	self inline: false.	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeContexts _ NilContext.	freeLargeContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.	allocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	tenuringThreshold _ 2000.  "tenure all suriving objects if count is over this threshold"	"garbage collection statistics"	statFullGCs _ 0.	statFullGCMSecs _ 0.	statIncrGCs _ 0.	statIncrGCMSecs _ 0.	statTenures _ 0.	statRootTableOverflows _ 0.	displayBits _ 0.  "support for the Acorn VM; ignored if zero"! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 10/22/1999 11:52'!allocateOrRecycleContext: needsLarge	"Return a recycled context or a newly allocated one if none is available for recycling."	| cntxt |	needsLarge = 0	ifTrue: [freeContexts ~= NilContext ifTrue:				[cntxt _ freeContexts.				freeContexts _ self fetchPointer: 0 ofObject: cntxt.				^ cntxt]]	ifFalse: [freeLargeContexts ~= NilContext ifTrue:				[cntxt _ freeLargeContexts.				freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.				^ cntxt]].		needsLarge = 0		ifTrue: [cntxt _ self instantiateContext: (self splObj: ClassMethodContext)				sizeInBytes: SmallContextSize]		ifFalse: [cntxt _ self instantiateContext: (self splObj: ClassMethodContext)				sizeInBytes: LargeContextSize].	"Required init -- above does not fill w/nil.  All others get written."	self storePointerUnchecked: 4 "InitialIPIndex" ofObject: cntxt					withValue: nilObj.	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 10/22/1999 10:40'!recycleContextIfPossible: cntxOop	| header |	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss.  The recycled context lists are cleared at every garbage collect."	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue:		[header _ self baseHeader: cntxOop.		(self isMethodContextHeader: header) ifTrue:			["It's a young context, alright."			(header bitAnd: SizeMask) = SmallContextSize				ifTrue:				["Recycle small contexts"				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeContexts.				freeContexts _ cntxOop].			(header bitAnd: SizeMask) = LargeContextSize				ifTrue:				["Recycle large contexts"				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop]]]! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'di 10/22/1999 10:44'!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeContexts _ NilContext.	freeLargeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		self markAndTrace: oop.	].! !!Interpreter methodsFor: 'message sending' stamp: 'di 10/22/1999 10:38'!bytecodeActivateNewMethod	| newContext methodHeader initialIP tempCount nilOop |	methodHeader _ self headerOf: newMethod.	newContext _ self allocateOrRecycleContext: (methodHeader bitAnd: LargeContextBit).	initialIP _ ((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _ (methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	0 to: argumentCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self stackValue: argumentCount-i)].	"clear remaining temps to nil in case it has been recycled"	nilOop _ nilObj.	argumentCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: nilOop].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 10/22/1999 10:43'!internalBytecodeActivateNewMethod	| methodHeader newContext tempCount argCount needsLarge |	self inline: true.	methodHeader _ self headerOf: newMethod.	needsLarge _ methodHeader bitAnd: LargeContextBit.	(needsLarge = 0 and: [freeContexts ~= NilContext])		ifTrue: [newContext _ freeContexts.				freeContexts _ self fetchPointer: 0 ofObject: newContext]		ifFalse: ["Slower call for large contexts or empty free list"				self externalizeIPandSP.				newContext _ self allocateOrRecycleContext: needsLarge.				self internalizeIPandSP].	tempCount _ (methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	argCount _ argumentCount.	0 to: argCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argCount-i)].	"clear remaining temps to nil in case it has been recycled"	methodHeader _ nilObj.  "methodHeader here used just as faster (register?) temp"	argCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: methodHeader].	self internalPop: argCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'di 10/22/1999 10:28'!initialize	"ObjectMemory initialize"	"Translation flags (booleans that control code generation via conditional translation):"	DoAssertionChecks _ false.  "generate assertion checks"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	SmallContextSize _ 92.  "16 indexable fields"	LargeContextSize _ 252.  "56 indexable fileds.  Max with single header word."	LargeContextBit _ 16r40000.  "This bit set in method headers if large context is needed."	CtxtTempFrameStart _ 6.  "Copy of TempFrameStart in Interp"	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 2500.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !CompiledMethod initialize!ContextPart class removeSelector: #newFor:!BlockContext class removeSelector: #new:!BlockContext class removeSelector: #basicNew:!BlockContext class removeSelector: #new!MethodContext class removeSelector: #new!MethodContext class removeSelector: #new:!MethodContext class removeSelector: #basicNew:!ObjectMemory removeSelector: #allocateOrRecycleContext!ObjectMemory initialize!