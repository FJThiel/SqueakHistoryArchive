'From Squeak 2.1 of June 30, 1998 on 19 August 1998 at 3:14:43 pm'!"Change Set:		jhmSampledSoundsDate:			18 August 1998Author:			John MaloneyAdds a number of facilities related to supporting looped, sampled instrumentssimilar to a commercial sample-based synthesizer. These changes include:    1. an AIFF file reader for non-compressed AIFF files    2. a basic sound object LoopedSampledSound that can play back a recorded	  instrument at an arbitrary pitch and (if loop points are supplied)	  make it sustain indefinitely.    3. an object called SampledInstrument, which holds a collection of	  LoopedSampledSounds and uses the pitch, duration, and loudness	  of the note to be played to select the best sampled sound to use.    4. an editor for sampled sounds (WaveEditor), including support for	  semi-automatic discovery of potential loop points.    5. support viewing the frequency spectrum of a sound segment using Dan's FFT.    6. fixes to several long-outstanding bugs in envelope handling, including	  one that caused fast notes with long decay times to be cut-off before	  they sounded. You may now create envelopes with long decays.    7. support for various features needed in sound library preparation,	  including stereo-to-mono conversion, sample rate down-conversion,	  pruning the number of notes for each instrument, finding a start	  index that cuts time off slow attacks, detecting the highest significant	  frequency component in a sampled sound, etc.    8. added a record level control to the sound recording morph.    9. fixed several problems relating to volume control of sounds that prevented       full volume from being realized from the score player.    10. tweaked the default reverb parameters to reduce the probability of	   clipping on full-volume attacks."!Object subclass: #AIFFFileReader	instanceVariableNames: 'in fileType channelCount frameCount bitsPerSample samplingRate channelData markers pitch gain isLooped skipDataChunk mergeIfStereo '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!Object subclass: #AbstractSound	instanceVariableNames: 'envelopes mSecsSinceStart samplesUntilNextControl scaledVol scaledVolIncr scaledVolLimit '	classVariableNames: 'FloatScaleFactor MaxScaledValue PitchesForBottomOctave ScaleFactor Sounds TopOfBottomOctave '	poolDictionaries: ''	category: 'System-Sound'!Object subclass: #CCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations methods variablesSetCache '	classVariableNames: 'UseRightShiftForDivide '	poolDictionaries: ''	category: 'Squeak-Translation to C'!Object subclass: #Envelope	instanceVariableNames: 'points loopStartIndex loopEndIndex loopStartMSecs loopMSecs target updateSelector loopEndMSecs endMSecs scale decayScale lastValue currValue valueIncr nextRecomputeTime noChangesDuringLoop '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!AbstractSound subclass: #LoopedSampledSound	instanceVariableNames: 'initialCount count releaseCount sampleCountForRelease leftSamples rightSamples originalSamplingRate perceivedPitch gain firstSample lastSample loopEnd scaledLoopLength scaledIndex scaledIndexIncr '	classVariableNames: 'FloatLoopIndexScaleFactor LoopIndexFractionMask LoopIndexScaleFactor '	poolDictionaries: ''	category: 'System-Sound'!Morph subclass: #BouncingAtomsMorph	instanceVariableNames: 'damageReported infectionHistory transmitInfection recentTemperatures temperature '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!RectangleMorph subclass: #GraphMorph	instanceVariableNames: 'data dataColor cursor cursorColor cursorColorAtZeroCrossings startIndex minVal maxVal cachedForm lastAcceptedScript lastScriptEditor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!Envelope subclass: #RandomEnvelope	instanceVariableNames: 'rand lowLimit highLimit delta '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!AbstractSound subclass: #RepeatingSound	instanceVariableNames: 'sound iterationCount iteration samplesPerIteration '	classVariableNames: 'CarMotorSamples '	poolDictionaries: ''	category: 'System-Sound'!Object subclass: #SampledInstrument	instanceVariableNames: 'sustainedSoft sustainedLoud staccatoSoft staccatoLoud sustainedThreshold loudThreshold '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!AbstractSound subclass: #ScorePlayer	instanceVariableNames: 'score instruments overallVolume leftVols rightVols muted rate tempo secsPerTick done repeat ticksSinceStart ticksClockIncr trackEventIndex tempoMapIndex activeSounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!Object subclass: #SoundRecorder	instanceVariableNames: 'stereo samplingRate recordLevel recordedBuffers recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex '	classVariableNames: 'CanRecordWhilePlaying '	poolDictionaries: ''	category: 'System-Sound'!AlignmentMorph subclass: #WaveEditor	instanceVariableNames: 'graph samplingRate perceivedFrequency loopEnd loopLength loopCycles possibleLoopStarts '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!AIFFFileReader commentStamp: 'jm 8/19/1998 15:14' prior: 0!I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.!!AIFFFileReader reorganize!('reading' readFromFile: readFromFile:mergeIfStereo:skipDataChunk:)('accessing' bitsPerSample channelCount channelData frameCount gain isLooped isStereo leftSamples loopEnd loopLength markers pitch rightSamples samplingRate)('other' edit pitchForKey: play)('private' readChunk:size: readCommonChunk: readExtendedFloat readFrom: readInstrumentChunk: readMarkerChunk: readMergedStereoChannelDataFrom: readMonoChannelDataFrom: readMultiChannelDataFrom: readSamplesChunk: readStereoChannelDataFrom:)!!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!readFromFile: fileName	"Read the AIFF file of the given name."	"AIFFFileReader new readFromFile: 'test.aiff'"	self readFromFile: fileName		mergeIfStereo: false		skipDataChunk: false.! !!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 20:06'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| f |	mergeIfStereo _ mergeFlag.	skipDataChunk _ skipDataFlag.	f _ (FileStream readOnlyFileNamed: fileName) binary.	self readFrom: f.	f close.! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!bitsPerSample	^ bitsPerSample! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!channelCount	^ channelCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!channelData	^ channelData! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!frameCount	^ frameCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!gain	^ gain! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!isLooped	^ isLooped! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!isStereo	^ channelData size = 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!leftSamples	^ channelData at: 1! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopEnd	^ markers last last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopLength	^ markers last last - markers first last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!markers	^ markers! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!pitch	^ pitch! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!rightSamples	^ channelData at: 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!samplingRate	^ samplingRate! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/17/1998 20:36'!edit	| ed |	ed _ WaveEditor new.	ed data: channelData first.	ed loopEnd: markers last last.	ed loopLength: (markers last last - markers first last) + 1.	ed openInWorld.! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 7/12/1998 01:44'!pitchForKey: midiKey	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/2/1998 19:26'!play	"Play the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd _ SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd _ SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd _ MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	snd play.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!readChunk: chunkType size: chunkSize	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].	in skip: chunkSize.  "skip unknown chunks"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 7/12/1998 18:24'!readCommonChunk: chunkSize	"Read a COMM chunk. All AIFF files have exactly one chunk of this type."	| compressionType |	channelCount _ in nextNumber: 2.	frameCount _ in nextNumber: 4.	bitsPerSample _ in nextNumber: 2.	samplingRate _ self readExtendedFloat.	chunkSize > 18 ifTrue: [		fileType = 'AIFF'			ifTrue: [self error: 'unexpectedly long COMM chunk size for AIFF file'].		compressionType _ (in next: 4) asString.		compressionType = 'NONE' ifFalse: [self error: 'cannot read compressed AIFF files'].		in skip: (chunkSize - 22)].  "skip the reminder of AIFF-C style chunk"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 11:43'!readExtendedFloat	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| signAndExp mantissa sign exp |	signAndExp _ in nextNumber: 2.	mantissa _ in nextNumber: 8.  "scaled by (2 raisedTo: -64) below"	(signAndExp bitAnd: 16r8000) = 0		ifTrue: [sign _ 1.0]		ifFalse: [sign _ -1.0].	exp _ (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 19:58'!readFrom: aBinaryStream	"Read AIFF data from the given binary stream."	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."	| sz end chunkType chunkSize p |	in _ aBinaryStream.	"read FORM chunk"	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].	sz _ in nextNumber: 4.	end _ in position + sz.	fileType _ (in next: 4) asString.	[in atEnd not and: [in position < end]] whileTrue: [		chunkType _ (in next: 4) asString.		chunkSize _ in nextNumber: 4.		p _ in position.		self readChunk: chunkType size: chunkSize.		(in position = (p + chunkSize))			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/5/1998 17:31'!readInstrumentChunk: chunkSize	| midiKey detune lowNote highNote lowVelocity highVelocity	  sustainMode sustainStartID sustainEndID	  releaseMode releaseStartID releaseEndID |	midiKey _ in next.	detune _ in next.	lowNote _ in next.	highNote _ in next.	lowVelocity _ in next.	highVelocity _ in next.	gain _ in nextNumber: 2.	sustainMode _ in nextNumber: 2.	sustainStartID _ in nextNumber: 2.	sustainEndID _ in nextNumber: 2.	releaseMode _ in nextNumber: 2.	releaseStartID _ in nextNumber: 2.	releaseEndID _ in nextNumber: 2.	isLooped _ sustainMode = 1.	(isLooped and: [markers notNil]) ifTrue: [		((markers first last > frameCount) or:		 [markers last last > frameCount]) ifTrue: [			"bad loop data; some sample CD files claim to be looped but aren't"			isLooped _ false]].	pitch _ self pitchForKey: midiKey.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 21:22'!readMarkerChunk: chunkSize	| markerCount id position labelBytes label |	markerCount _ in nextNumber: 2.	markers _ Array new: markerCount.	1 to: markerCount do: [:i |		id _ in nextNumber: 2.		position _ in nextNumber: 4.		labelBytes _ in next.		label _ (in next: labelBytes) asString.		labelBytes even ifTrue: [in skip: 1].		markers at: i put: (Array with: id with: label with: position)].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:58'!readMergedStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream, mixing the two channels to create a single monophonic channel. Each frame contains two samples."	| buf w1 w2 |	buf _ channelData at: 1.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w1 _ s next.				w1 > 127 ifTrue: [w1 _ w1 - 256].				w2 _ s next.				w2 > 127 ifTrue: [w2 _ w2 - 256].				buf at: i put: ((w1 + w2) bitShift: 7)]]		ifFalse: [			1 to: frameCount do: [:i |				w1 _ (s next bitShift: 8) + s next.				w1 > 32767 ifTrue: [w1 _ w1 - 65536].				w2 _ (s next bitShift: 8) + s next.				w2 > 32767 ifTrue: [w2 _ w2 - 65536].				buf at: i put: ((w1 + w2) bitShift: -1)]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:53'!readMonoChannelDataFrom: s	"Read monophonic channel data from the given stream. Each frame contains a single sample."	| buf w |	buf _ channelData at: 1.  "the only buffer"	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				buf at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				buf at: i put: w]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:55'!readMultiChannelDataFrom: s	"Read multi-channel data from the given stream. Each frame contains channelCount samples."	| w |	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ s next.					w > 127 ifTrue: [w _ w - 256].					(channelData at: ch) at: i put: (w bitShift: 8)]]]		ifFalse: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ (s next bitShift: 8) + s next.					w > 32767 ifTrue: [w _ w - 65536].					(channelData at: ch) at: i put: w]]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/3/1998 14:55'!readSamplesChunk: chunkSize	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."	| offset blockSize bytesOfSamples s |	skipDataChunk ifTrue: [in skip: chunkSize. ^ self].	offset _ in nextNumber: 4.	blockSize _ in nextNumber: 4.	((offset ~= 0) or: [blockSize ~= 0])		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].	bytesOfSamples _ chunkSize - 8.	bytesOfSamples = (channelCount * frameCount * (bitsPerSample // 8))		ifFalse: [self error: 'actual sample count does not match COMM chunk'].	(mergeIfStereo and: [channelCount = 2])		ifTrue: [			channelData _ Array with: (SoundBuffer newMonoSampleCount: frameCount)]		ifFalse: [			channelData _				(1 to: channelCount) collect: [:i | SoundBuffer newMonoSampleCount: frameCount]].	(bytesOfSamples < (Smalltalk garbageCollectMost - 300000))		ifTrue: [s _ ReadStream on: (in next: bytesOfSamples)]  "bulk-read, then process"		ifFalse: [s _ in].  "not enough space to buffer; read directly from file"	"mono and stereo are special-cased for better performance"	channelCount = 1 ifTrue: [^ self readMonoChannelDataFrom: s].	channelCount = 2 ifTrue: [		mergeIfStereo			ifTrue: [channelCount _ 1. ^ self readMergedStereoChannelDataFrom: s]			ifFalse: [^ self readStereoChannelDataFrom: s]].	self readMultiChannelDataFrom: s.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:56'!readStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream. Each frame contains two samples."	| left right w |	left _ channelData at: 1.	right _ channelData at: 2.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				left at: i put: (w bitShift: 8).				w _ s next.				w > 127 ifTrue: [w _ w - 256].				right at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				left at: i put: w.				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				right at: i put: w]].! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!nameOrNumberToPitch: aStringOrNumber	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."	aStringOrNumber isNumber		ifTrue: [^ aStringOrNumber asFloat]		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/19/1998 08:45'!setPitch: pitchNameOrNumber dur: d loudness: l	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."	| p |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	envelopes do: [:e |		e volume: l.		e centerPitch: p].	self initialVolume: l.	self duration: d.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	^ self copy		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: l! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 8/18/1998 09:57'!removeAllEnvelopes	"Remove all envelopes from my envelopes list."	envelopes _ #().! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!loudness	"Answer the current volume setting for this sound."	^ scaledVol asFloat / ScaleFactor asFloat! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	self error: 'not yet implemented'.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!playAndWaitUntilDone	"Play this sound to the sound ouput port and wait until it has finished playing before returning."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!playChromaticRunFrom: startPitch to: endPitch	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 16:17'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just after the last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 7/5/1998 17:53'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| bufSize buf |	self reset.	bufSize _ self samplingRate // 10.	buf _ SoundBuffer newStereoSampleCount: bufSize.	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: bufSize into: buf startingAt: 1].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/19/1998 08:30'!viewSamples	| stereoBuf |	stereoBuf _ self computeSamplesForSeconds: self duration.	WaveEditor openOn: stereoBuf extractLeftChannel.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:34'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	| pitchModOrRatioChange |	envelopes size > 0 ifTrue: [		pitchModOrRatioChange _ false.		1 to: envelopes size do: [:i |			((envelopes at: i) updateTargetAt: mSecsSinceStart)				ifTrue: [pitchModOrRatioChange _ true]].		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:45'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart _ 0.	samplesUntilNextControl _ 0.	envelopes size > 0 ifTrue: [		1 to: envelopes size do: [:i | (envelopes at: i) reset]].! !!AbstractSound class reorganize!('class initialization' initialize scaleFactor)('instance creation' default dur: new noteSequenceOn:from: pitch:dur:loudness:)('utilities' indexOfBottomOctavePitch: midiKeyForPitch: pitchForMIDIKey: pitchForName: pitchTable)('examples' chromaticPitchesFrom: chromaticRunFrom:to:on: chromaticScale chromaticScaleOn: hiMajorScale hiMajorScaleOn: lowMajorScale lowMajorScaleOn: majorChord majorChordOn:from: majorPitchesFrom: majorScale majorScaleOn: majorScaleOn:from: scaleTest testFMInteractively)('examples-bach fugue' bachFugue bachFugueOn: bachFugueVoice1On: bachFugueVoice2On: bachFugueVoice3On: bachFugueVoice4On: stereoBachFugue)('sounds' fileInSoundLibrary fileInSoundLibraryNamed: fileOutSoundLibrary fileOutSoundLibrary: initSounds soundNamed: soundNamed:ifAbsent: soundNamed:put: soundNames sounds storeFiledInSound:named:)('primitive generation' cCodeForSoundPrimitives)!!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 8/3/1998 16:13'!initialize	"AbstractSound initialize" 	| bottomC |	ScaleFactor _ 2 raisedTo: 15.	FloatScaleFactor _ ScaleFactor asFloat.	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"	"generate pitches for c-1 through c0"	bottomC _ (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).	PitchesForBottomOctave _ (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].	TopOfBottomOctave _ PitchesForBottomOctave last.! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:00'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."	| score pitch |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				pitch _ el at: 1.				pitch isNumber ifFalse: [pitch _ self pitchForName: pitch].				score add: (					aSound						soundForPitch: pitch						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!indexOfBottomOctavePitch: p	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."	1 to: PitchesForBottomOctave size do: [:i |		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].	self error: 'implementation error: argument pitch should be below or within the bottom octave'.! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!midiKeyForPitch: pitchNameOrNumber	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."	"AbstractSound midiKeyForPitch: 440.0"	| p octave i midiKey |	pitchNameOrNumber isNumber		ifTrue: [p _ pitchNameOrNumber asFloat]		ifFalse: [p _ AbstractSound pitchForName: pitchNameOrNumber].	octave _ -1.	[p >= TopOfBottomOctave] whileTrue: [		octave _ octave + 1.		p _ p / 2.0].	i _ self indexOfBottomOctavePitch: p.	(i > 1) ifTrue: [		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)			ifTrue: [i _ i - 1]].	midiKey _ ((octave * 12) + 11 + i).	midiKey > 127 ifTrue: [midiKey _ 127].	^ midiKey! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:43'!pitchForMIDIKey: midiKey	"Answer the pitch for the given MIDI key."	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"	| indexInOctave octave |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	^ (PitchesForBottomOctave at: indexInOctave) *		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 7/6/1998 15:47'!pitchTable	"AbstractSound pitchTable"	| out note i |	out _ WriteStream on: (String new: 1000).	i _ 12.	0 to: 8 do: [:octave |		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName |			note _ noteName, octave printString.			out nextPutAll: note; tab.			out nextPutAll: i printString; tab.			out nextPutAll: (AbstractSound pitchForName: note) printString; cr.			i _ i + 1]].	^ out contents! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 6/30/1998 18:40'!chromaticPitchesFrom: aPitch	| halfStep pitch |	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	pitch _ aPitch isNumber			ifTrue: [aPitch]			ifFalse: [self pitchForName: aPitch].	pitch _ pitch / halfStep.	^ (0 to: 14) collect: [:i | pitch _ pitch * halfStep]! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/18/1998 11:32'!chromaticRunFrom: startPitch to: endPitch on: aSound	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"	| scale halfStep pEnd p |	scale _ SequentialSound new.	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	endPitch isNumber		ifTrue: [pEnd _ endPitch asFloat]		ifFalse: [pEnd _ AbstractSound pitchForName: endPitch].	startPitch isNumber		ifTrue: [p _ startPitch asFloat]		ifFalse: [p _ AbstractSound pitchForName: startPitch].	[p <= pEnd] whileTrue: [		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).		p _ p * halfStep].	^ scale! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/3/1998 17:00'!majorChordOn: aSound from: aPitch	"FMSound majorChord play"	| score majorScale leadingRest pan note |	majorScale _ self majorPitchesFrom: aPitch.	score _ MixedSound new.	leadingRest _ pan _ 0.	#(1 3 5 8) do: [:noteIndex |		note _ aSound			soundForPitch: (majorScale at: noteIndex)			dur: 2.0 - leadingRest			loudness: 0.3.		score add: (RestSound dur: leadingRest), note pan: pan.		leadingRest _ leadingRest + 0.2.		pan _ pan + 0.3].	^ score! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!majorScaleOn: aSound from: aPitch	"FMSound majorScale play"	^ self noteSequenceOn: aSound		from: ((self majorPitchesFrom: aPitch)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/19/1998 13:11'!fileInSoundLibrary	"Prompt the user for a file name and the file in the sound library with that name."	"AbstractSound fileInSoundLibrary"	| fileName |	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	(fileName endsWith: '.sounds') ifFalse: [fileName _ fileName, '.sounds'].	self fileInSoundLibraryNamed: fileName.! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/19/1998 13:47'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s _ FileStream oldFileNamed: fileName.	newSounds _ s fileInObjectAndCode.	s close.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/19/1998 12:42'!fileOutSoundLibrary	"File out the current sound library."	"AbstractSound fileOutSoundLibrary"	self fileOutSoundLibrary: Sounds.! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/19/1998 13:50'!fileOutSoundLibrary: aDictionary	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."	| fileName refStream |	(aDictionary isKindOf: Dictionary)		ifFalse: [self error: 'arg should be a dictionary of sounds'].	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	refStream _ SmartRefStream fileNamed: fileName, '.sounds'.	refStream nextPut: aDictionary.	refStream close.! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/14/1998 13:27'!initSounds	"AbstractSound initSounds"	Sounds _ Dictionary new.	(FMSound class organization listAtCategoryNamed: #instruments)		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/14/1998 13:25'!soundNamed: soundName	^ Sounds at: soundName! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/19/1998 14:11'!soundNames	^ Sounds keys asSortedCollection asArray! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/4/1998 18:26'!sounds	^ Sounds! !!AbstractSound class methodsFor: 'sounds' stamp: 'jm 8/19/1998 13:58'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu _ SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice _ menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i _ 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'primitive generation' stamp: 'jm 8/19/1998 14:22'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	"AbstractSound cCodeForSoundPrimitives"	^ CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(ReverbSound applyReverbTo:startingAt:count:)	).! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 7/5/1998 18:17'!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| rcvr arg divisor |	rcvr _ msgNode receiver.	arg _ msgNode args first.	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor _ arg value) isPowerOfTwo and:	 [divisor > 0 and:	 [divisor <= (1 bitShift: 31)]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		aStream nextPutAll: '((int) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> ', (divisor log: 2) asInteger printString.		aStream nextPutAll: ')'.	] ifFalse: [		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitCExpression: arg on: aStream].! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 8/19/1998 09:56'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!CCodeGenerator class methodsFor: 'class initialization' stamp: 'jm 8/19/1998 10:03'!initialize	"CCodeGenerator initialize"	UseRightShiftForDivide _ true.		"If UseRightShiftForDivide is true, the translator will generate a right-shift when it encounters a division by a constant that is a small power of two. For example, 'x / 8' will generate '((int) x >> 3)'. The coercion to int is done to make it clear that the C compiler should generate a signed shift."		"Note: The Kernighan and Ritchie 2nd Edition C manual, p. 49, leaves the semantics of right-shifting a negative number open to the discretion of the compiler implementor. However, it strongly suggests that most compilers should generate an arithmetic right shift (i.e., shifting in the sign bit), which is the same as dividing by a power of two. If your compiler does not generate or simulate an arithmetic shift, then make this class variable false and re-translate."! !!ChangeSorter methodsFor: 'creation' stamp: 'jm 7/5/1998 12:35'!openAsMorph	"ChangeSorter new openAsMorph"	|  window |	myChangeSet ifNil: [self myChangeSet: Smalltalk changes]. 	window _ (SystemWindow labelled: self labelString) model: self.	self openAsMorphIn: window rect: (0@0 extent: 1@1).	window openInWorld.! !!DualChangeSorter methodsFor: 'all' stamp: 'jm 7/5/1998 12:37'!openAsMorph		| window |	leftCngSorter _ ChangeSorter new myChangeSet: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	window openInWorld.! !!Envelope reorganize!('accessing' attackTime centerPitch: decayEndIndex decayTime duration duration: loopEndIndex loopStartIndex name points scale scale: target target: updateSelector updateSelector: volume:)('applying' computeValueAtMSecs: reset showOnDisplay sustainEnd: updateTargetAt: valueAtMSecs:)('storing' storeOn:)('private' checkParameters computeIncrementAt:between:and:scale: incrementalComputeValueAtMSecs: indexOfPointAfterMSecs:startingAt: interpolate:between:and: setPoints:loopStart:loopEnd:)!!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!attackTime	"Return the time taken by the attack phase."	^ (points at: loopStartIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!centerPitch: aNumber	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/19/1998 09:07'!duration: seconds	"Set the note duration to the given number of seconds."	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 	| attack decay endTime |	endMSecs _ (seconds * 1000.0) asInteger - 19.	attack _ self attackTime.	decay _ self decayTime.	endMSecs > (attack + decay)		ifTrue: [endTime _ endMSecs - decay]		ifFalse: [			endMSecs >= attack				ifTrue: [endTime _ attack]				ifFalse: [endTime _ endMSecs]].	self sustainEnd: (endTime max: 0).! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03'!name	^ self updateSelector allButLast! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!imagData	^ imagData! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!realData	^ realData! !!FFT methodsFor: 'testing' stamp: 'jm 8/16/1998 17:36'!samplesPerCycleForIndex: i	"Answer the number of samples per cycle corresponding to a power peak at the given index. Answer zero if i = 1, since an index of 1 corresponds to the D.C. component."	| windowSize |	windowSize _ 2 raisedTo: nu.	(i < 1 or: [i > (windowSize // 2)]) ifTrue: [^ self error: 'index is out of range'].	i = 1 ifTrue: [^ 0].  "the D.C. component"	^ windowSize asFloat / (i - 1)! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:44'!initialize	super initialize.	waveTable _ SineTable.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: 440.0 dur: 1.0 loudness: 0.2.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:08'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	modulation ifNil: [modulation _ 0.0].	multiplier ifNil: [multiplier _ 0.0].	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:53'!setWavetable: aSoundBuffer	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| p dur vol |	p _ self pitch.	dur _ self duration.	vol _ self loudness.	waveTable _ aSoundBuffer.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!pitch	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/6/1998 10:26'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize _ 4000.	SineTable _ SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:28'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd _ FMSound new modulation: 0 multiplier: 0.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).	^ snd setPitch: 220 dur: 1.0 loudness: 0.3! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:06'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd _ FMSound new modulation: 0 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p _ OrderedCollection new.	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:05'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute2	"FMSound flute2 play"	"(FMSound majorScaleOn: FMSound flute2) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:26'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:26'!oboe2	"FMSound oboe2 play"	"(FMSound majorScaleOn: FMSound oboe2) play"	| snd p |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:01'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 125@0.8; add: 200@1.0; add: 250@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:00'!randomWeird1	"FMSound randomWeird1 play"	| snd p |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:57'!randomWeird2	"FMSound randomWeird2 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 8/19/1998 14:54'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!LoopedSampledSound commentStamp: 'jm 8/19/1998 15:14' prior: 0!I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.!!LoopedSampledSound reorganize!('initialization' addReleaseEnvelope computeSampleCountForRelease fromAIFFFileNamed:mergeIfStereo: initialize samples:loopEnd:loopLength:pitch:samplingRate: setPitch:dur:loudness: unloopedSamples:pitch:samplingRate:)('accessing' duration duration: firstSample firstSample: gain gain: isLooped isStereo leftSamples leftSamples: loopEnd loopLength pitch pitch: rightSamples rightSamples:)('sound generation' mixSampleCount:into:startingAt:leftVol:rightVol: reset samplesRemaining)('other' copyDownSampledLowPassFiltering: edit fftAt: findStartPointForThreshold: highestSignificantFrequencyAt: indexOfFirstPointOverThreshold:)('disk i/o' comeFullyUpOnReload objectToStoreOnDataStream)('private' downSampleLowPassFiltering: fftWindowSize:startingAt: normalizedResultsFromFFT:)!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/17/1998 17:45'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 130@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 2) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:48'!computeSampleCountForRelease	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."	(scaledLoopLength > 0 and: [lastSample > loopEnd])		ifTrue: [			sampleCountForRelease _ (lastSample - loopEnd) +				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]		ifFalse: [sampleCountForRelease _ 0].	releaseCount _ sampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/2/1998 19:54'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples _ aiffFileReader rightSamples].	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 07:43'!initialize	"This default initialization creates a loop consisting of a single cycle of a sine wave."	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"	| samples |	super initialize.	samples _ FMSound sineTable.	self samples: samples		loopEnd: samples size		loopLength: samples size		pitch: 1.0		samplingRate: samples size.	self addReleaseEnvelope.	self setPitch: 440.0 dur: 1.0 loudness: 0.5.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate asFloat! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/7/1998 01:08'!duration: seconds	super duration: seconds.	initialCount _ (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample	^ firstSample! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample: aNumber	firstSample _ (aNumber asInteger max: 1) min: lastSample.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain	^ gain! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain: aNumber	gain _ aNumber asFloat.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!isLooped	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14'!isStereo	^ leftSamples ~~ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples	^ leftSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples: aSampleBuffer	leftSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!loopEnd	^ loopEnd! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!loopLength	^ scaledLoopLength / FloatLoopIndexScaleFactor! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!pitch	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /	  (originalSamplingRate * FloatLoopIndexScaleFactor)! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 11:38'!pitch: p	scaledIndexIncr _		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /		 (perceivedPitch * self samplingRate asFloat)) asInteger.	sampleCountForRelease > 0		ifTrue: [releaseCount _ (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]		ifFalse: [releaseCount _ 0].! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples	^ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples: aSampleBuffer	rightSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/19/1998 10:43'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive: 184>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #leftSamples declareC: 'short int *leftSamples'.	self var: #rightSamples declareC: 'short int *rightSamples'.	isInStereo _ leftSamples ~~ rightSamples.	compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.	compositeRightVol _  (rightVol * scaledVol) // ScaleFactor.	i _ (2 * startIndex) - 1.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex _ (scaledIndex _ scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex _ (scaledIndex _ scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex _ sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count _ 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex _ sampleIndex]				ifFalse: [nextSampleIndex _ ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m _ scaledIndex bitAnd: LoopIndexFractionMask.		rightVal _ leftVal _			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal _				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		rightVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0].			compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.			compositeRightVol _  (rightVol * scaledVol) // ScaleFactor]].	count _ count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 09:38'!reset	super reset.	count _ initialCount.	scaledIndex _ firstSample * LoopIndexScaleFactor.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31'!samplesRemaining	"Answer the number of samples remaining until the end of this sound."	^ count! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 08:19'!copyDownSampledLowPassFiltering: doFiltering	"Answer a copy of the receiver at half its sampling rate. The result consumes half the memory space, but has only half the frequency range of the original. If doFiltering is true, the original sound buffers are low-pass filtered before down-sampling. This is slower, but prevents aliasing of any high-frequency components of the original signal. (While it may be possible to avoid low-pass filtering when down-sampling from 44.1 kHz to 22.05 kHz, it is probably essential when going to lower sampling rates.)"	^ self copy downSampleLowPassFiltering: doFiltering! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:30'!edit	"Open a WaveEditor on this sound."	| loopLen ed |	loopLen _ scaledLoopLength asFloat / LoopIndexScaleFactor.	ed _ WaveEditor new		data: leftSamples;		samplingRate: originalSamplingRate;		loopEnd: loopEnd;		loopLength: loopLen;		loopCycles: (loopLen / (originalSamplingRate asFloat / perceivedPitch)) rounded.	ed openInWorld.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 07:49'!fftAt: startIndex	"Answer the Fast Fourier Transform (FFT) of my samples (only the left channel, if stereo) starting at the given index."	| availableSamples fftWinSize |	availableSamples _ (leftSamples size - startIndex) + 1.	fftWinSize _ 2 raisedTo: (((availableSamples - 1) log: 2) truncated + 1).	fftWinSize _ fftWinSize min: 4096.	fftWinSize > availableSamples ifTrue: [fftWinSize _ fftWinSize / 2].	^ self fftWindowSize: fftWinSize startingAt: startIndex! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:29'!findStartPointForThreshold: threshold	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."	| i |	i _ self indexOfFirstPointOverThreshold: threshold.	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:26'!highestSignificantFrequencyAt: startIndex	"Answer the highest significant frequency in the sample window starting at the given index. The a frequency is considered significant if it's power is at least 1/50th that of the maximum frequency component in the frequency spectrum."	| fft powerArray threshold indices |	fft _ self fftAt: startIndex.	powerArray _ self normalizedResultsFromFFT: fft.	threshold _ powerArray max / 50.0.	indices _ (1 to: powerArray size) select: [:i | (powerArray at: i) > threshold].	^ originalSamplingRate / (fft samplesPerCycleForIndex: indices last)! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/17/1998 09:22'!indexOfFirstPointOverThreshold: threshold	"Answer the index of the first sample whose absolute value exceeds the given threshold."	| s |	leftSamples == rightSamples		ifTrue: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]]		ifFalse: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i].				s _ rightSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]].	^ lastSample + 1! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:47'!comeFullyUpOnReload	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."	leftSamples == rightSamples		ifTrue: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ leftSamples]		ifFalse: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ SoundBuffer fromByteArray: self rightSamples].! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:48'!objectToStoreOnDataStream    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	| objToStore |	objToStore _ self clone.	objToStore leftSamples: leftSamples asByteArray.	self isStereo		ifTrue: [objToStore rightSamples: rightSamples asByteArray]		ifFalse: [objToStore rightSamples: objToStore leftSamples].	^ objToStore! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 08:11'!downSampleLowPassFiltering: doFiltering	"Cut my sampling rate in half. Use low-pass filtering (slower) if doFiltering is true."	"Note: This operation loses information, and modifies the receiver in place."	| stereo newLoopLength |	stereo _ self isStereo.	leftSamples _ leftSamples downSampledLowPassFiltering: doFiltering.	stereo		ifTrue: [rightSamples _ rightSamples downSampledLowPassFiltering: doFiltering]		ifFalse: [rightSamples _ leftSamples].	originalSamplingRate _ originalSamplingRate / 2.0.	loopEnd odd		ifTrue: [newLoopLength _ (self loopLength / 2.0) + 0.5]		ifFalse: [newLoopLength _ self loopLength / 2.0].	firstSample _ (firstSample + 1) // 2.	lastSample _ (lastSample + 1) // 2.	loopEnd _ (loopEnd + 1) // 2.	scaledLoopLength _ (newLoopLength * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ scaledIndexIncr // 2.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 07:48'!fftWindowSize: windowSize startingAt: startIndex	"Answer a Fast Fourier Transform (FFT) of the given number of samples starting at the given index (the left channel only, if stereo). The window size will be rounded up to the nearest power of two greater than the requested size. There must be enough samples past the given starting index to accomodate this window size."	| nu n fft |	nu _ ((windowSize - 1) log: 2) truncated + 1.	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((startIndex to: startIndex + n - 1) collect: [:i | leftSamples at: i]).	^ fft transformForward: true.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/16/1998 17:48'!normalizedResultsFromFFT: fft	"Answer an array whose size is half of the FFT window size containing power in each frequency band, normalized to the average power over the entire FFT. A value of 10.0 in this array thus means that the power at the corresponding frequences is ten times the average power across the entire FFT."	| r avg |	r _ (1 to: fft realData size // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	avg _ r sum / r size.	^ r collect: [:v | v / avg].! !!LoopedSampledSound class reorganize!('class initialization' initialize)('instance creation' samples:loopEnd:loopLength:pitch:samplingRate: unloopedSamples:pitch:samplingRate:)!!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'jm 8/13/1998 12:54'!initialize	"LoopedSampledSound initialize"	LoopIndexScaleFactor _ 512.	FloatLoopIndexScaleFactor _ LoopIndexScaleFactor asFloat.	LoopIndexFractionMask _ LoopIndexScaleFactor - 1.! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		samples: aSoundBuffer		loopEnd: loopEndIndex		loopLength: loopSampleCount		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		unloopedSamples: aSoundBuffer		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!MIDIScore methodsFor: 'all' stamp: 'jm 8/6/1998 21:16'!jitterStartAndEndTimesBy: mSecs	| r range halfRange oldEnd newEnd newStart |	r _ Random new.	range _ 2.0 * mSecs.	halfRange _ mSecs.	tracks do: [:t |		t do: [:e |			e isNoteEvent ifTrue: [				oldEnd _ e time + e duration.				newEnd _ oldEnd + ((r next * range) asInteger - halfRange).				newStart _ e time + ((r next * range) asInteger - halfRange).				e time: newStart.				e duration: (newEnd - newStart)]]].				! !!MIDIScore methodsFor: 'all' stamp: 'jm 8/3/1998 17:04'!soundForTrack: trackIndex after: eventIndex ticks: ticks instrument: soundProto secsPerTick: secsPerTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time <= ticks ifTrue: [		evt isNoteEvent ifFalse: [^ RestSound dur: 0.001].  "skip non-note event"		^ (soundProto			soundForMidiKey: evt midiKey			dur: secsPerTick * evt duration			loudness: evt velocity asFloat / 127.0)].	^ nil! !!MixedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:05'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur max: snd duration].	^ dur! !!Morph methodsFor: 'initialization' stamp: 'jm 7/5/1998 12:40'!openInMVC	MorphWorldView		openWorldWith: self		labelled: self defaultLabelForInspector.! !!AtomMorph methodsFor: 'all' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p _ self position.	vx _ velocity x.		vy _ velocity y.	px _ p x + vx.		py _ p y + vy.	bounced _ false.	px > aRect right ifTrue: [		px _ aRect right - (px - aRect right).		vx _ velocity x negated.		bounced _ true].	py > aRect bottom ifTrue: [		py _  aRect bottom - (py - aRect bottom).		vy _ velocity y negated.		bounced _ true].	px < aRect left ifTrue: [		px _ aRect left - (px - aRect left).		vx _ velocity x negated.		bounced _ true].	py < aRect top ifTrue: [		py _  aRect top - (py - aRect top).		vy _ velocity y negated.		bounced _ true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 8/10/1998 18:32'!step	"Bounce those atoms!!"	| r bounces |	bounces _ 0.	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces _ bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 8/10/1998 18:32'!updateTemperature: currentTemperature	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures == nil ifTrue: [		recentTemperatures _ OrderedCollection new.		20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature _ recentTemperatures sum asFloat / recentTemperatures size.! !!EnvelopeEditorMorph methodsFor: 'playing' stamp: 'jm 8/3/1998 17:01'!playLongNote	(sound soundForPitch: (AbstractSound pitchForName: samplePitch)		dur: 2.0		loudness: 0.4) play.	playRemaining _ 500 + 2000.! !!EnvelopeEditorMorph methodsFor: 'playing' stamp: 'jm 8/3/1998 17:02'!playShortNote	(sound soundForPitch: (AbstractSound pitchForName: samplePitch)		dur: 0.2		loudness: 0.4) play.	playRemaining _ 500 + 200.! !!EnvelopeEditorMorph methodsFor: 'playing' stamp: 'jm 8/3/1998 17:02'!playVeryLongNote	(sound soundForPitch: (AbstractSound pitchForName: samplePitch)		dur: 5.0		loudness: 0.4) play.	playRemaining _ 500 + 5000.! !!GraphMorph methodsFor: 'initialization' stamp: 'jm 7/8/1998 20:31'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursor _ 1.0.  "may be fractional"	cursorColor _ Color red.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	self data:		((0 to: 360 - 1) collect:			[:x | (10000.0 * ((4.0 * x) degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/30/1998 12:17'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w _ self width - (2 * borderWidth).	self startIndex: ((cursor - (w // 2)) max: 1).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossing	^ cursorColorAtZeroCrossings! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'private' stamp: 'jm 7/8/1998 20:32'!drawPointerOn: aCanvas	| ptr x r c |	ptr _ (cursor asInteger max: 1) min: data size.	c _ cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c _ cursorColorAtZeroCrossings]].	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 11:40'!openWorldWith: aMorph labelled: labelString	| w |	w _ WorldMorph new addMorph: aMorph.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:06'!pitch	"Convert my MIDI key number to a pitch and return it."	^ AbstractSound pitchForMIDIKey: midiKey! !!PluckedSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	| p sz |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!RandomEnvelope reorganize!('initialization' initialize)('accessing' centerPitch: delta delta: highLimit highLimit: lowLimit lowLimit: volume:)('applying' updateTargetAt:)('envelope compatibility' duration duration: name sustainEnd:)!!RandomEnvelope methodsFor: 'initialization' stamp: 'jm 8/13/1998 21:25'!initialize	rand _ Random new.	lowLimit _ 0.996.	highLimit _ 1.004.	delta _ 0.0001.	currValue _ 1.0.	scale _ 1.0.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:18'!centerPitch: aNumber	"If this envelope controls pitch, set its scale to the given number. Otherwise, do nothing."	updateSelector = #pitch: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta	^ delta! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta: aNumber	delta _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit	^ highLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit: aNumber	highLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:05'!lowLimit	^ lowLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!lowLimit: aNumber	lowLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:17'!volume: aNumber	"If this envelope controls volume, set its scale to the given number. Otherwise, do nothing."	updateSelector = #volume: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'applying' stamp: 'jm 8/13/1998 18:25'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."	| r |	r _ rand next.	r > 0.5		ifTrue: [			currValue _ currValue + delta.			currValue > highLimit ifTrue: [currValue _ highLimit]]		ifFalse: [			currValue _ currValue - delta.			currValue < lowLimit ifTrue: [currValue _ lowLimit]].	currValue = lastValue ifTrue: [^ false].	((target == nil) or: [updateSelector == nil]) ifTrue: [^ false].	target		perform: updateSelector		with: scale * currValue.	lastValue _ currValue.	^ true! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:29'!duration	^ 1.0! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!duration: seconds	"Do nothing."! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!name	^ 'random ', updateSelector! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:30'!sustainEnd: seconds	"Do nothing."! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 18:21'!for: aSelector	"Answer a random envelope for the given selector."	^ self new updateSelector: aSelector! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 17:09'!new	^ super new initialize! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:43'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 8/17/1998 20:35'!show	"Show my samples in a WaveEditor."	| ed w |	recorder pause.	ed _ WaveEditor new.	ed data: recorder condensedSamples.	ed samplingRate: recorder samplingRate.	w _ self world.	w activeHand		ifNil: [w addMorph: ed]		ifNotNil: [w activeHand attachMorph: ed].! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 7/4/1998 14:49'!addRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:28'!reset	super reset.	sound reset.	samplesPerIteration _ sound samplesRemaining.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:29'!samplesRemaining	iteration > 0		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]		ifFalse: [^ 0].! !!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!SampledInstrument commentStamp: 'jm 8/19/1998 15:14' prior: 0!I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).!!SampledInstrument reorganize!('accessing' allSampleSets: initialize loudThreshold loudThreshold: staccatoLoudAndSoftSampleSet: staccatoLoudSampleSet: staccatoSoftSampleSet: sustainedLoudSampleSet: sustainedSoftSampleSet: sustainedThreshold sustainedThreshold:)('playing' soundForMidiKey:dur:loudness: soundForPitch:dur:loudness:)('other' allNotes chooseSamplesForPitch:from: memorySpace midiKeyMapFor: playChromaticRunFrom:to: pruneNoteList:notesPerOctave: pruneToNotesPerOctave: pruneToSingleNote: readSampleSetFrom: readSampleSetInfoFrom: tempTest testAtPitch: trimAttackOf:threshold: trimAttacks:)!!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:30'!allSampleSets: sortedNotes	| keyMap |	keyMap _ self midiKeyMapFor: sortedNotes.	sustainedSoft _ keyMap.	sustainedLoud _ keyMap.	staccatoSoft _ keyMap.	staccatoLoud _ keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 19:04'!initialize	sustainedThreshold _ 0.15.	loudThreshold _ 0.5.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!loudThreshold	^ loudThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!loudThreshold: aNumber	loudThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:02'!staccatoLoudAndSoftSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.	staccatoSoft _ staccatoLoud.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoLoudSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoSoftSampleSet: sortedNotes	staccatoSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedLoudSampleSet: sortedNotes	sustainedLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedSoftSampleSet: sortedNotes	sustainedSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!sustainedThreshold	^ sustainedThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!sustainedThreshold: aNumber	sustainedThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 18:53'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	| keymap note |	l >= loudThreshold		ifTrue: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedLoud]				ifFalse: [keymap _ staccatoLoud]]		ifFalse: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedSoft]				ifFalse: [keymap _ staccatoSoft]].	keymap ifNil: [keymap _ sustainedLoud].	note _ (keymap at: midiKey) copy.	^ note		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: (l * note gain)! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)		dur: d		loudness: l! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 12:39'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r _ IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ (r asSortedCollection: [:n1 :n2 | n1 pitch < n2 pitch]) asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 12:55'!chooseSamplesForPitch: pitchInHz from: sortedNotes	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."	"Assume: the given collection is sorted in ascending pitch order."	| i lower higher |	i _ 1.	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]		whileTrue: [i _ i + 1].	i = 1 ifTrue: [^ sortedNotes at: 1].	lower _ sortedNotes at: i - 1.	higher _ sortedNotes at: i.	"note: give slight preference for down-shifting a higher-pitched sample set"	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)		ifTrue: [^ lower]		ifFalse: [^ higher].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/10/1998 14:23'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total _ 0.	self allNotes do: [:n |		total _ total + (n leftSamples size * 2).		n isStereo ifTrue: [total _ total + (n leftSamples size * 2)]].	^ total! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!midiKeyMapFor: sortedNotes	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."	^ (0 to: 127) collect: [:k |		self			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)			from: sortedNotes].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!playChromaticRunFrom: startPitch to: endPitch	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 15:52'!pruneNoteList: aNoteList notesPerOctave: notesPerOctave	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."	| r interval lastPitch |	r _ OrderedCollection new: aNoteList size.	interval _ (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.	lastPitch _ 0.0.	aNoteList do: [:n |		n pitch > (lastPitch * interval) ifTrue: [			r addLast: n.			lastPitch _ n pitch]].	^ r! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/6/1998 00:39'!pruneToNotesPerOctave: notesPerOctave	"Prune all my keymaps to the given number of notes per octave."	sustainedLoud _ self midiKeyMapFor:		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).	sustainedSoft _ self midiKeyMapFor:		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).	staccatoLoud _ self midiKeyMapFor:		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).	staccatoSoft _ self midiKeyMapFor:		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 14:44'!pruneToSingleNote: aNote	"Fill all my keymaps with the given note."	| oneNoteMap |	oneNoteMap _ Array new: 128 withAll: aNote.	sustainedLoud _ oneNoteMap.	sustainedSoft _ oneNoteMap.	staccatoLoud _ oneNoteMap.	staccatoSoft _ oneNoteMap.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 18:22'!readSampleSetFrom: dirName	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."	| all dir fullName snd |	all _ SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		Utilities			informUser: 'Reading AIFF file ', n			during:				[snd _ LoopedSampledSound new					fromAIFFFileNamed: fullName					mergeIfStereo: true].		all add: snd].	^ all asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 20:32'!readSampleSetInfoFrom: dirName	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"	| all dir fullName info |	all _ OrderedCollection new.	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		info _ AIFFFileReader new readFromFile: fullName			mergeIfStereo: false			skipDataChunk: true.		all add: n -> info].	^ all! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 17:15'!tempTest	(AbstractSound bachFugueVoice1On: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 23:13'!testAtPitch: aPitch	"SampledInstrument testAtPitch: 'c4'"	| pattern |	pattern _ (#(		(c4 0.64 100) 		(c4 0.64 200) 		(c4 0.64 400) 		(c4 0.64 600) 		(c4 0.64 800) 		(c4 1.28 1000) 		(c4 1.28 400) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.64 500))			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).	(AbstractSound noteSequenceOn: self from: pattern) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!trimAttackOf: sampleBuffer threshold: threshold	"Trim 'silence' off the initial attacks of the given sound buffer."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!trimAttacks: threshold	"Trim 'silence' off the initial attacks all my samples."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument class reorganize!('instance creation' new readLoudAndStaccatoInstrument:fromDirectory: readPizzInstrument:fromDirectory: readSimpleInstrument:fromDirectory:)!!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:27'!new	^ super new initialize! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readLoudAndStaccatoInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter loud short snd |	sampleSetDir _ orchestraDir, ':', instName.	memBefore _ Smalltalk garbageCollect.	loud _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.	short _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f&stacc' put:		(snd _ SampledInstrument new			allSampleSets: loud;			staccatoLoudAndSoftSampleSet: short).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new			allSampleSets: loud).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readPizzInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readPizzInstrument: 'violin'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' pizz'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-pizz' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 18:06'!readSimpleInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readSimpleInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' f'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:10'!setPitch: pitchNameOrNumber dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	| p |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	samples _ DefaultSampleTable.	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self setLoudness: vol.	self reset.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 08:38'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	overallVolume _ 0.5.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 09:54'!onScore: aMIDIScore	| trackCount totalVol incr curr pan |	score _ aMIDIScore.	trackCount _ score tracks size.	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].	leftVols _ Array new: trackCount.	rightVols _ Array new: trackCount.	muted  _ Array new: trackCount withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	trackCount = 0 ifTrue: [^ self].	1 to: trackCount do: [:i |		leftVols at: i put: ScaleFactor // 4.		rightVols at: i put: ScaleFactor // 4].	"distribute inital panning of tracks left-to-right"	totalVol _ 1.0.	incr _ totalVol / (((trackCount // 2) + 1) * 2).	curr _ 0.	1 to: trackCount do: [:t |		t even			ifTrue: [pan _ curr]			ifFalse: [				curr _ curr + incr.				pan _ totalVol - curr].		self panForTrack: t put: pan].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 7/4/1998 08:21'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| myLeftVol myRightVol someSoundIsDone pair snd trk left right |	myLeftVol _ (leftVol * overallVolume) asInteger.	myRightVol _ (rightVol * overallVolume) asInteger.	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (myLeftVol * (leftVols at: trk)) // ScaleFactor.		right _ (myRightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 8/19/1998 11:45'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	score resetFrom: self.	overallVolume ifNil: [overallVolume _ 0.5].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:17'!overallVolume	^ overallVolume! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:18'!overallVolume: aNumber	"Set the overally playback volume to a value between 0.0 (off) and 1.0 (full blast)."	overallVolume _ (aNumber asFloat min: 1.0) max: 0.0.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:32'!panForTrack: i	| left right fullVol pan |	left _ leftVols at: i.	right _ rightVols at: i.	left = right ifTrue: [^ 0.5].  "centered"	fullVol _ left max: right.	left < fullVol		ifTrue: [pan _ left asFloat / (2.0 * fullVol)]		ifFalse: [pan _ 1.0 - (right asFloat / (2.0 * fullVol))].	^ pan roundTo: 0.001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:58'!panForTrack: i put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| fullVol pan left right |	fullVol _ (leftVols at: i) max: (rightVols at: i).	pan _ (aNumber asFloat min: 1.0) max: 0.0.	pan <= 0.5		ifTrue: [  "attenuate right channel"			left _ fullVol.			right _ 2.0 * pan * fullVol]		ifFalse: [  "attenuate left channel"			left _ 2.0 * (1.0 - pan) * fullVol.			right _ fullVol].	rightVols at: i put: right asInteger.	leftVols at: i put: left asInteger.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:16'!volumeForTrack: i	| vol |	vol _ (leftVols at: i) max: (rightVols at: i).	^ (vol asFloat / ScaleFactor) roundTo: 0.0001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/30/1998 20:22'!volumeForTrack: i put: aNumber	| newVol oldLeft oldRight oldFullVol left right |	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.	oldLeft _ leftVols at: i.	oldRight _ rightVols at: i.	oldFullVol _ oldLeft max: oldRight.	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].	oldLeft < oldFullVol		ifTrue: [			left _ newVol * oldLeft / oldFullVol.			right _ newVol]		ifFalse: [			left _ newVol.			right _ newVol * oldRight / oldFullVol].	leftVols at: i put: left asInteger.	rightVols at: i put: right asInteger.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 8/19/1998 11:43'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	score pauseFrom: self.	super pause.	activeSounds _ activeSounds species new.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:32'!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer reset.	self addMorph: self makeControls.	instrumentSelector _ Array new: scorePlayer score tracks size.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:29'!panAndVolControlsFor: trackIndex	| volSlider panSlider c r middleLine |	volSlider _ SimpleSliderMorph new		color: color;		extent: 101@2;		target: scorePlayer;		arguments: (Array with: trackIndex);		actionSelector: #volumeForTrack:put:;		minVal: 0.0;		maxVal: 1.0;		adjustToValue: (scorePlayer volumeForTrack: trackIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForTrack:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (scorePlayer panForTrack: trackIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:04'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur + snd duration].	^ dur! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/15/1998 13:03'!asByteArray	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."	| sampleCount bytes dst s |	sampleCount _ self monoSampleCount.	bytes _ ByteArray new: 2 * sampleCount.	dst _ 0.	1 to: sampleCount do: [:src |		s _ self at: src.		bytes at: (dst _ dst + 1) put: ((s bitShift: -8) bitAnd: 255).		bytes at: (dst _ dst + 1) put: (s bitAnd: 255)].	^ bytes	! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:49'!downSampledLowPassFiltering: doFiltering	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	doFiltering		ifTrue: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put:					(((self at: i) + (self at: i + 1)) bitShift: -1)]]		ifFalse: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put: (self at: i)]].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:52'!extractLeftChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:53'!extractRightChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	2 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 8/15/1998 14:35'!fromByteArray: aByteArray	"Convert the given ByteArray (stored with the most significant byte first) into 16-bit sample buffer."	| n buf src w |	n _ aByteArray size // 2.	buf _ SoundBuffer newMonoSampleCount: n.	src _ 1.	1 to: n do: [:i |		w _ ((aByteArray at: src) bitShift: 8) + (aByteArray at: src + 1).		w > 32767 ifTrue: [w _ w - 65536].		buf at: i put: w.		src _ src + 2].	^ buf! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!bufferMSecs	^ BufferMSecs! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 8/19/1998 08:11'!startReverb	UseReverb _ true.	ReverbState _ ReverbSound new		tapDelays: #(1601 7919) gains: #(0.12 0.07).! !!SoundRecorder methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:32'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordLevel _ 0.5.	recordedBuffers _ OrderedCollection new: 1000.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!recordLevel	^ recordLevel! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:04'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 	recordLevel _ (level asFloat min: 1.0) max: 0.0.	recordProcess ifNotNil: [		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 7/4/1998 14:35'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: (SoundPlayer samplingRate)		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 17:29'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			targetVol _ points last y * decayScale.			mSecsForChange _ 0.			nextRecomputeTime _ mSecs + 1000000.			^ self].		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		((loopEndMSecs ~~ nil) and: [nextRecomputeTime > loopEndMSecs])			ifTrue: [nextRecomputeTime _ loopEndMSecs].		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol _ (points at: loopEndIndex) y.		mSecsForChange _ 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime _ mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime _ loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 4.	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 08:00'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope."	scale _ aNumber asFloat.! !!WaveEditor commentStamp: 'jm 8/19/1998 15:14' prior: 0!This tool was created to aid in the preparation of LoopedSampledSound objects. It includes support for finding good loop points with a little help from the user.  Namely, the user must identify a good ending point for the loop (typically just before the decay phase begins) and identify one cycle of the waveform. After that, the  "choose loop point" menu command can be invoked to search backwards to find and rank all possible loop starting points. Some experimentation is usually required to find a loop that "breaths" in a natural way.This tool can also be used as a general viewer of numerical sequences of any kind, such as time-varying functions, FFT data, etc.!!WaveEditor reorganize!('initialization' addControls addLoopPointControls initialize)('menu' chooseLoopStart invokeMenu jumpToLoopEnd jumpToLoopStart play playAfterCursor playBeforeCursor playFrom:to: playLoop playTestNote saveInstrument setLoopEnd setLoopStart setOneCycle setUnlooped setUnpitched showEnvelope showFFTAtCursor trimAfterCursor trimBeforeCursor)('accessing' data: graph loopCycles loopCycles: loopEnd loopEnd: loopLength loopLength: loopStart loopStart: perceivedFrequency perceivedFrequency: samplingRate samplingRate:)('other' autoCorrolationBetween:and:length: errorBetween:and: findPossibleLoopStartsFrom: fractionalLoopStartAt: interpolatedWindowAt:width: scrollTime: zeroCrossingAfter:)!!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 09:16'!addControls	| slider b r m |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'X';					actionSelector: #delete).	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;															actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Play';				actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Play Before';		actionSelector: #playBeforeCursor).	r addMorphBack: (b fullCopy label: 'Play After';			actionSelector: #playAfterCursor).	r addMorphBack: (b fullCopy label: 'Play Loop';			actionSelector: #playLoop).	r addMorphBack: (b fullCopy label: 'Test';				actionSelector: #playTestNote).	r addMorphBack: (b fullCopy label: 'Save';				actionSelector: #saveInstrument).	r addMorphBack: (b fullCopy label: 'Set Loop End';		actionSelector: #setLoopEnd).	r addMorphBack: (b fullCopy label: 'One Cycle';			actionSelector: #setOneCycle).	r addMorphBack: (b fullCopy label: 'Set Loop Start';		actionSelector: #setLoopStart).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Index: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 71; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	slider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	m _ Morph new color: r color; extent: 10@5.  "spacer"	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #startIndex; putSelector: #startIndex:;		width: 40; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 8/17/1998 20:31'!addLoopPointControls	| r m |	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Loop end: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopEnd; putSelector: #loopEnd:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop length: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopLength; putSelector: #loopLength:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop cycles: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopCycles; putSelector: #loopCycles:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Frequency: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #perceivedFrequency; putSelector: #perceivedFrequency:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 08:27'!initialize	super initialize.	samplingRate _ SoundPlayer samplingRate.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.  "zero means unknown"	self extent: 5@5;		orientation: #vertical;		centering: #topLeft;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	graph _ GraphMorph new extent: 450@100.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:43'!chooseLoopStart	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...'			during: [possibleLoopStarts _ self findPossibleLoopStartsFrom: graph cursor]].	bestLoops _ possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	menu _ CustomMenu new.	bestLoops do: [:entry |		secs _ ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		menu add: secs printString, ' secs' action: entry].	choice _ menu startUp.	choice ifNil: [^ self].	loopCycles _ choice at: 3.	start _ self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:04'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('play straight through'		play)		('play before cursor'		playBeforeCursor)		('play after cursor'			playAfterCursor)		('play test note'				playTestNote)		('play loop'					playLoop)		('trim before cursor'		trimBeforeCursor)		('trim after cursor'			trimAfterCursor)		('choose loop start'			chooseLoopStart)		('jump to loop start'			jumpToLoopStart)		('jump to loop end'			jumpToLoopEnd)		('make unlooped'			setUnlooped)		('make unpitched'			setUnpitched)		('show envelope'			showEnvelope)		('show FFT'					showFFTAtCursor)).	aMenu invokeOn: self defaultSelection: nil.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:42'!jumpToLoopEnd	graph cursor: loopEnd; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 10:09'!jumpToLoopStart	graph cursor: (loopEnd - loopLength) truncated; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 09:23'!play	graph data size < 2 ifTrue: [^ self].	(SampledSound samples: graph data samplingRate: samplingRate) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:40'!playAfterCursor	self playFrom: graph cursor to: graph data size.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:39'!playBeforeCursor	self playFrom: 1 to: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:02'!playFrom: start to: end	| sz i1 i2 snd |	sz _ graph data size.	i1 _ ((start + 1) min: sz) max: 1.	i2 _ ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd _ SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:39'!playLoop	| sz i1 i2 snd len |	sz _ graph data size.	i1 _ ((loopEnd - loopLength) truncated min: sz) max: 1.	i2 _ (loopEnd min: sz) max: i1.	len _ (i2 - i1) + 1.	len < 2 ifTrue: [^ self].	snd _ LoopedSampledSound new		samples: (graph data copyFrom: i1 to: i2)		loopEnd: len		loopLength: loopLength		pitch: 100.0		samplingRate: samplingRate.	"sustain for the longer of four loops or two seconds"	snd setPitch: 100.0		dur: (((4.0 * loopLength) / samplingRate) max: 2.0)		loudness: 0.5.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:38'!playTestNote	| data end snd loopDur dur |	(loopEnd = 0 or: [loopLength = 0]) ifTrue: [^ self].	data _ graph data.	end _ (loopEnd min: data size) max: 1.	snd _ LoopedSampledSound new		samples: data loopEnd: end loopLength: loopLength		pitch: 100.0 samplingRate: samplingRate.	loopDur _ (4.0 * loopLength / samplingRate) max: 2.0.  "longer of 4 loops or 2 seconds"	dur _ (data size / samplingRate) + loopDur.	(snd		addReleaseEnvelope;		setPitch: 100.0 dur: dur loudness: 0.5) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 14:24'!saveInstrument	| name data end snd basePitch |	name _ FillInTheBlank request: 'Instrument name?'.	name isEmpty ifTrue: [^ self].	data _ graph data.	((loopEnd = 0) or: [loopLength = 0])		ifTrue: [  "save as unlooped"			loopLength * loopCycles = 0				ifTrue: [basePitch _ 100.0]				ifFalse: [basePitch _ (samplingRate * loopCycles) / loopLength].			snd _ LoopedSampledSound new				unloopedSamples: data pitch: basePitch samplingRate: samplingRate]		ifFalse: [			end _ (loopEnd min: data size) max: 1.			basePitch _ (samplingRate * loopCycles) / loopLength.			snd _ LoopedSampledSound new				samples: data loopEnd: end loopLength: loopLength				pitch: basePitch samplingRate: samplingRate].	snd addReleaseEnvelope.	AbstractSound soundNamed: name put: snd.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 11:06'!setLoopEnd	graph cursor: (self zeroCrossingAfter: graph cursor) - 1.	self loopEnd: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 08:21'!setLoopStart	"Assuming that the loop end and approximate frequency have been set, this method uses the current cursor position to determine the loop length and the number of cycles."	| start len |	start _ graph cursor.	((start >= loopEnd) or: [perceivedFrequency = 0]) ifTrue: [		^ self inform:'Please set the loop end and the approximate frequencyfirst, then position the cursor one or more cyclesbefore the loop end and try this again.'].	len _ (loopEnd - start) + 1.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setOneCycle	"Set the approximate frequency based on a single cycle specified by the user. To use this, first set the loop end, then place the cursor one full cycle before the loop end and invoke this method."	| len |	len _ loopEnd - graph cursor.	len > 0 ifTrue: [		loopCycles _ 1.		self loopLength: len].! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnlooped	"Make this sound play straight through without looping."	loopLength _ 0.	loopCycles _ 1.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnpitched	"Make this instrument be unpitched and unlooped. Suitable for percussive sounds that should not be pitch-shifted when played. By convention, such sounds are played at a pitch of 100.0 to obtain their original pitch."	loopLength _ 0.	loopCycles _ 0.	perceivedFrequency _ 100.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!showEnvelope	"Show an envelope wave constructed by collecting the maximum absolute value of the samples in fixed-size time windows of mSecsPerQuanta."	| data mSecsPerQuanta samplesPerQuanta result endOfQuanta maxThisQuanta s |	data _ graph data.	mSecsPerQuanta _ 10.	samplesPerQuanta _ (mSecsPerQuanta / 1000.0) * self samplingRate.	result _ WriteStream on: (Array new: data size // samplesPerQuanta).	endOfQuanta _ samplesPerQuanta.	maxThisQuanta _ 0.	1 to: data monoSampleCount do: [:i |		i asFloat > endOfQuanta ifTrue: [			result nextPut: maxThisQuanta.			maxThisQuanta _ 0.			endOfQuanta _ endOfQuanta + samplesPerQuanta].		s _ data at: i.		s < 0 ifTrue: [s _ 0 - s].		s > maxThisQuanta ifTrue: [maxThisQuanta _ s]].	WaveEditor openOn: result contents.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:21'!showFFTAtCursor	| data start availableSamples nu n fft r |	data _ graph data.	start _ graph cursor max: 1.	availableSamples _ (data size - start) + 1.	nu _ 12.	nu > (availableSamples highBit - 1) ifTrue:		[^ self inform: 'Too few samples after the cursor to take an FFT.'].	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((start to: start + n - 1) collect: [:i | data at: i]).	fft transformForward: true.	r _ (1 to: n // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	WaveEditor openOn: r.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:48'!trimAfterCursor	graph data: (graph data copyFrom: 1 to: graph cursor).! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:52'!trimBeforeCursor	graph data: (graph data copyFrom: graph cursor to: graph data size).	graph cursor: 1.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/5/1998 12:43'!data: newData	graph data: newData.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/3/2004 18:16'!graph	^ graph! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 09:48'!loopCycles	^ loopCycles! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:21'!loopCycles: aNumber	loopCycles _ aNumber.	self loopLength: loopLength.  "updates frequency"! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 6/30/1998 17:20'!loopEnd	^ loopEnd! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/31/1998 14:01'!loopEnd: aNumber	loopEnd _ (aNumber asInteger max: 1) min: graph data size.	possibleLoopStarts _ nil.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 08:38'!loopLength	^ loopLength! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 21:03'!loopLength: aNumber	loopLength _ aNumber.	((loopCycles > 0) and: [loopLength > 0]) ifTrue: [		perceivedFrequency _ samplingRate asFloat * loopCycles / loopLength].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 10:08'!loopStart	^ (loopEnd - loopLength) truncated + 1! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:46'!loopStart: index	| start len |	start _ self fractionalLoopStartAt: index.	len _ (loopEnd asFloat - start) + 1.0.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:31'!perceivedFrequency	^ perceivedFrequency! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:32'!perceivedFrequency: aNumber	perceivedFrequency _ aNumber.	(loopCycles > 0) ifTrue: [		loopLength _ samplingRate asFloat * loopCycles / perceivedFrequency].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate	^ samplingRate! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate: samplesPerSecond	samplingRate _ samplesPerSecond.! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/30/1998 18:51'!autoCorrolationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| data error i1 e |	data _ graph data.	error _ 0.	i1 _ index1.	index2 to: (index2 + length - 1) do: [:i2 |		e _ (data at: i1) - (data at: i2).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e.		i1 _ i1 + 1].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/28/1998 02:29'!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error _ 0.	1 to: sampleArray1 size do: [:i |		e _ (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:25'!findPossibleLoopStartsFrom: index	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r _ OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart _ loopEnd + 1.  "Assumed to be a zero-crossing."	i _ self zeroCrossingAfter: postLoopCycleStart + (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength _ i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i _ self zeroCrossingAfter: postLoopCycleStart - (1.1 * postLoopCycleLength) asInteger.	cycleLength _ postLoopCycleStart - i.	cycleCount _ 1.	[cycleLength > 0] whileTrue: [		err _ self autoCorrolationBetween: i and: postLoopCycleStart length: postLoopCycleLength.		r add: (Array				with: i				with: err				with: cycleCount				with: (((loopEnd - i) asFloat / self samplingRate) roundTo: 0.01)).		oldI _ i.		i _ self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.		cycleLength _ oldI - i.  "will be zero when start of data is encountered"		cycleCount _ cycleCount + 1].	r _ r asSortedCollection: [:e1 :e2 | (e1 at: 2) < (e2 at: 2)].	^ r asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:27'!fractionalLoopStartAt: index	"Answer the fractional index starting point near the given integral index that results in the closest match with the cycle following the loop end."	"Note: could do this more efficiently by sliding downhill on the error curve to find lowest error."	| oneCycle w1 minErr w2 err bestIndex |	oneCycle _ (samplingRate / perceivedFrequency) rounded.	w1 _ self interpolatedWindowAt: loopEnd + 1 width: oneCycle.	minErr _ SmallInteger maxVal.	((index - 2) max: 1) to: ((index + 2) min: graph data size) by: 0.01 do: [:i |		w2 _ self interpolatedWindowAt: i width: oneCycle.		err _ self errorBetween: w1 and: w2.		err < minErr ifTrue: [			bestIndex _ i.			minErr _ err]].	^ bestIndex! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/31/1998 11:54'!interpolatedWindowAt: index width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale data baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale _ 10000.	data _ graph data.	index isInteger		ifTrue: [^ (index to: index + nSamples - 1) collect: [:i | data at: i]].	baseIndex _ index truncated.	scaledFrac _ ((index asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac _ scale - scaledFrac.	prevSample _ data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample _ data at: i.		v _ ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample _ nextSample.		v].! !!WaveEditor methodsFor: 'other' stamp: 'jm 6/30/1998 16:11'!scrollTime: relativeValue	graph startIndex: relativeValue * (graph data size - (graph width // 2)).! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/10/1998 15:08'!zeroCrossingAfter: index	"Find the index of the next negative-to-non-negative transition at or after the current index. The result is the index, i, of a zero crossing such that the sample at i-1 is negative and the sample at i is zero or positive. Answer the index of the last sample if the end of the array is encountered before finding a zero crossing."	| data end i |	data _ graph data.	end _ data size.	index <= 1 ifTrue: [^ 1].	i _ index - 1.	[(i <= end) and: [(data at: i) >= 0]] whileTrue: [i _ i + 1].  "find next negative sample"	i >= end ifTrue: [^ end].	i _ i + 1.	[(i <= end) and: [(data at: i) < 0]] whileTrue: [i _ i + 1].  "find next non-negative sample"	^ i! !!WaveEditor class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 21:04'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	(self new data: dataCollection) openInWorld.! !!DataStream methodsFor: 'all' stamp: 'jm 8/19/1998 17:00'!readByteArray	"PRIVATE -- Read the contents of a ByteArray."	| count |	count _ byteStream nextNumber: 4.	^ byteStream next: count  "assume stream is in binary mode"! !!FileStream methodsFor: 'fileIn/Out' stamp: 'jm 8/19/1998 16:59'!fileInObjectAndCode	"Optimization: If the file is small, read the entire file into memory before processing."	| s |	self text.	((self size < 1000000) and: [Smalltalk garbageCollectMost > 3000000])		ifTrue: [			s _ RWBinaryOrTextStream with: (self contentsOfEntireFile).			s position: 0.			^ s fileInObjectAndCode]		ifFalse: [^ super fileInObjectAndCode].! !AbstractSound initialize!AbstractSound class removeSelector: #halfStep!CCodeGenerator initialize!FMSound initialize!LoopedSampledSound initialize!ScorePlayerMorph removeSelector: #instrumentNames!