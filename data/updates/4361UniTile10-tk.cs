'From Squeak3.1alpha of 28 February 2001 [latest update: #4356] on 1 October 2001 at 10:33:03 am'!"Change Set:		UniTile10-tkDate:			1 October 2001Author:			Ted KaehlerAllow Detailed variable watchers and ordinary variable watchers to be numeric fields in stacks.CardPlayer classes now do have source code recorded.  To keep the names of temps and the comments in scripts.Viewers for CardPlayers have 'self' instead of 'Card1' as the first part of tiles.  This is so a script written for one card works for the rest of the cards of that background.  Make drag out a tile to start a script work with 'self' in a tile.Renaming a script is kept in the scripts category.If a holds-separate-data object is embedded in a simple morph (Rectangle), it is still recognised and has its data changed when you go to the next card.  The holding morph must be in the background also.Changing a script name finds and changes all buttons that fire that script."!AlignmentMorph subclass: #SyntaxMorph	instanceVariableNames: 'parseNode markerMorph '	classVariableNames: 'AllSpecs ContrastFactor DownRightArrow SelfTile SizeScaleFactor '	poolDictionaries: ''	category: 'Morphic-Tile Scriptors'!StringMorph subclass: #UpdatingStringMorph	instanceVariableNames: 'format target lastValue getSelector putSelector floatPrecision growable stepTime autoAcceptOnFocusLoss minimumWidth maximumWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!Object methodsFor: 'scripts-kernel' stamp: 'tk 9/28/2001 13:30'!universalTilesForGetterOf: aMethodInterface	"Return universal tiles for a getter on the given method interface."	| ms argTile argArray itsSelector |	itsSelector _ aMethodInterface selector.	argArray _ #().	"Three gratuituous special cases..."	(itsSelector == #color:sees:) ifTrue:		[argTile _ ScriptingSystem tileForArgType: #Color.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy].	itsSelector == #seesColor: ifTrue:		[argTile _ ScriptingSystem tileForArgType: #Color.		argArray _  Array with: argTile colorSwatch color].	itsSelector == #touchesA: ifTrue:		[argTile _ ScriptingSystem tileForArgType: #Player.		argArray _ Array with: argTile actualObject].	ms _ MessageSend receiver: self selector: itsSelector arguments: argArray.	^ ms asTilesIn: self class globalNames: (self class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!Object methodsFor: 'scripts-kernel' stamp: 'tk 9/28/2001 13:30'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList |	itsSelector _ aMethodInterface selector.	argList _ OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile _ ScriptingSystem tileForArgType: (aType _ aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #Player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms _ MessageSend receiver: self selector: itsSelector arguments: argList asArray.	^ ms asTilesIn: self class globalNames: (self class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 9/27/2001 13:29'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |	aDocString _ aMethodInterface documentationOrNil.	names _ scriptedPlayer class namedTileScriptSelectors.	resultType _ aMethodInterface resultType.	cmd _ aMethodInterface selector.	(universal _ scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase _ scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase _ PhraseTileMorph new vocabulary: self currentVocabulary..				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType _ aMethodInterface typeForArgumentNumber: 1.				aPhrase _ PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player					argType: argType.				argTile _ ScriptingSystem tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector _ #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString ifNil:				[aDocString _ (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentationOrNil].			aDocString ifNil:				[balloonTextSelector _ #userScript]].	tileBearingHelp _ universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 	aDocString		ifNotNil:			[tileBearingHelp setBalloonText: aDocString]		ifNil:			[balloonTextSelector ifNil:				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.				balloonTextSelector _ #methodComment].			tileBearingHelp balloonTextSelector: balloonTextSelector].	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script'].	universal ifFalse:		[selfTile _ self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow _ ViewerRow newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		aPhrase beTransparent.		aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.		aRow addMorphBack: (stat _ (inst _ scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).		inst updateStatusMorph: stat].	aRow beSticky; disableDragNDrop.	^ aRow! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 9/28/2001 13:28'!newGetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a getter on this property.  Record who self is."	| ms argTile argArray |	ms _ MessageSend receiver: aPlayer selector: aMethodInterface selector arguments: #().	"Handle three idiosyncratic cases..."	aMethodInterface selector == #color:sees: ifTrue:		[argTile _ ScriptingSystem tileForArgType: #Color.		argArray _ Array with: argTile colorSwatch color with: argTile colorSwatch color copy. 		ms arguments: argArray].	aMethodInterface selector == #seesColor: ifTrue:		[argTile _ ScriptingSystem tileForArgType: #Color.		ms arguments: (Array with: argTile colorSwatch color)].	aMethodInterface selector == #touchesA: ifTrue:		[argTile _ ScriptingSystem tileForArgType: #Player.		ms arguments: (Array with: argTile actualObject)].	^ ms asTilesIn: aPlayer class globalNames: (aPlayer class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 9/30/2001 11:20'!newSetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a setter on this property.  Record who self is."	| ms argValue makeSelfGlobal phrase |	argValue _ aPlayer perform: aMethodInterface selector.	ms _ MessageSend receiver: aPlayer 		selector: aMethodInterface companionSetterSelector 		arguments: (Array with: argValue).	makeSelfGlobal _ aPlayer class officialClass ~~ CardPlayer.	phrase _ ms asTilesIn: aPlayer class globalNames: makeSelfGlobal.			"For CardPlayers, use 'self'.  For others, name it, and use its name."	makeSelfGlobal ifFalse: [phrase setProperty: #scriptedPlayer toValue: aPlayer].	^ phrase! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 9/28/2001 13:28'!newTilesFor: aPlayer setter: aSpec	| ms  argValue |	"Return universal tiles for a getter on this property.  Record who self is."	argValue _ aPlayer perform: (ScriptingSystem getterSelectorFor: aSpec second asSymbol).	ms _ MessageSend receiver: aPlayer selector: aSpec ninth arguments: (Array with: argValue).	^ ms asTilesIn: aPlayer class globalNames: (aPlayer class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!MessageSend methodsFor: 'tiles' stamp: 'tk 9/28/2001 13:41'!asTilesIn: playerClass globalNames: makeSelfGlobal	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me.  If makeSelfGlobal is true, name the receiver and use that name, else use 'self'.  (Note that this smashes 'self' into the receiver, regardless of what it was.)"	"This is really cheating!!  Make a true parse tree later. -tk"	code _ String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: 			(makeSelfGlobal ifTrue: [self stringFor: receiver] ifFalse: ['self']).		keywords _ selector keywords.		strm space; nextPutAll: keywords first.		(num _ selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree _ Compiler new 		parse: code 		in: playerClass		notifying: nil.	syn _ tree asMorphicSyntaxUsing: SyntaxMorph.	block _ syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase _ block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'tk 9/29/2001 10:44'!reassessBackgroundShape	"A change has been made which may affect the instance structure of the Card uniclass that holds the instance state, which can also be thought of as the 'card data'."	| takenNames uniqueName requestedName  variableDocks docks sepDataMorphs sorted |	"Caution: still to be done: the mechanism so that when a new instance variable is added, it gets initialized in all subinstances of the receiver's player, which are the cards of this shape.  One needs to take into account here the instance variable names coming in; those that are unchanged should keep their values, but those that have newly arrived should obtain their default values from the morphs on whose behalf they are being maintained in the model"Cursor wait showWhile:	[variableDocks _ OrderedCollection new.  "This will be stored in the uniclass's 			class-side inst var #variableDocks"	takenNames _ OrderedCollection new.	sepDataMorphs _ OrderedCollection new.	"fields, holders of per-card data"	self submorphs do: [:aMorph | 		aMorph renderedMorph holdsSeparateDataForEachInstance			ifTrue: [sepDataMorphs add: aMorph renderedMorph]			ifFalse: ["look for buried fields, inside a frame"				aMorph renderedMorph isShared ifTrue: [					aMorph allMorphs do: [:mm |						mm renderedMorph holdsSeparateDataForEachInstance ifTrue: [							sepDataMorphs add: mm renderedMorph]]]]].	sorted _ (SortedCollection new) sortBlock: 				[:a :b | (a valueOfProperty: #cardInstance) ~~ nil].	"puts existing ones first"	sorted addAll: sepDataMorphs.	sorted do: [:aMorph |			docks _ aMorph variableDocks.  	"Each morph can request multiple variables.  	This complicates matters somewhat but creates a generality for Fabrk-like uses.	Each spec is an instance of VariableDock, and it provides a point of departure	for the negotiation between the PasteUp and its constitutent morphs"			docks do:				[:aVariableDock |					uniqueName _ self player uniqueInstanceVariableNameLike: 						(requestedName _ aVariableDock variableName) excluding: takenNames.					uniqueName ~= requestedName ifTrue:						[aVariableDock variableName: uniqueName.						aMorph noteNegotiatedName: uniqueName for: requestedName].					takenNames add: uniqueName].			variableDocks addAll: docks].	self player class setNewInstVarNames: 		(variableDocks collect: [:info | info variableName asString]).  "NB: sets up accessors, and removes obsolete ones"	self player class newVariableDocks: variableDocks]! !!Player methodsFor: 'slots-user' stamp: 'tk 9/28/2001 13:33'!tearOffFancyWatcherFor: aGetter	"Create 'Player3 heading = 43' as in independent entity.  It keeps up with the truth, and may be edited to change the variable."	| aWatcher aTile aLine aColor aTower precision ms slotMsg info isNumeric anInterface watcherWording |	info _ self slotInfoForGetter: aGetter.	info ifNotNil:			[isNumeric _ info type == #Number.			watcherWording _ Utilities inherentSelectorForGetter: aGetter]		ifNil:			[anInterface _Vocabulary eToyVocabulary methodInterfaceAt: aGetter ifAbsent: [nil].			isNumeric _ anInterface notNil and: [anInterface resultType == #Number].			watcherWording _ anInterface elementWording].	aColor _ Color r: 0.387 g: 0.581 b: 1.0.	isNumeric		ifTrue:	[aTile _ NumericReadoutTile new typeColor: aColor].	aWatcher _ UpdatingStringMorph new.	isNumeric ifTrue: [(precision _ self defaultFloatPrecisionFor: aGetter) ~= 1 			ifTrue: [aWatcher floatPrecision: precision]].	aWatcher growable: true;		getSelector: aGetter;		putSelector: (info notNil			ifTrue:				[ScriptingSystem setterSelectorForGetter: aGetter]			ifFalse:				[anInterface companionSetterSelector]).	aWatcher target: self.	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: aGetter) width: 30.Preferences universalTiles 	ifTrue: [		ms _ MessageSend receiver: self selector: aGetter asSymbol arguments: #().		slotMsg _ ms asTilesIn: self class globalNames: (self class officialClass ~~ CardPlayer).			"For CardPlayers, use 'self'.  For others, name it, and use its name."		ms _ MessageSend receiver: 3 selector: #= asSymbol arguments: #(5).		aLine _ ms asTilesIn: self class globalNames: false.		aLine firstSubmorph delete.		aLine addMorphFront: slotMsg.		aLine lastSubmorph delete.		aLine lastSubmorph delete.		aLine color: aColor.		aLine addMorphBack: aTile.		aLine cellPositioning: #leftCenter]	ifFalse: [		aLine _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; color: aColor.		aLine layoutInset: -1.		aLine borderWidth: 1; borderColor: aColor darker.		aLine addMorphBack: 			(self tileReferringToSelf borderWidth: 0; typeColor: aColor; 				color: aColor; bePossessive).		aLine addTransparentSpacerOfSize: (4@0).		aTower _ AlignmentMorph newColumn color: aColor.		aTower addTransparentSpacerOfSize: (0 @ 1).		aTower addMorphBack: 			(StringMorph contents: watcherWording, ' = ' font: ScriptingSystem fontForTiles).		aLine addMorphBack: aTower.		aLine addMorphBack: aTile].	aWatcher step; fitContents.	self currentHand attachMorph: aLine.! !!Player methodsFor: 'scripts-kernel' stamp: 'tk 10/1/2001 09:51'!slotInfoButtonHitFor: aGetterSymbol inViewer: aViewer	"The user made a gesture asking for slot menu for the given getter symbol in a viewer; put up the menu."	| aMenu slotSym aType typeVocab |	slotSym _ Utilities inherentSelectorForGetter: aGetterSymbol.	aType _ self typeForSlotWithGetter: aGetterSymbol asSymbol.	aMenu _ MenuMorph new defaultTarget: self.	(#(copy getNewClone newClone) includes: slotSym) ifTrue:		[aMenu add: 'give me a copy now' action: #handTheUserACopy].	(typeVocab _ Vocabulary vocabularyForType: aType) addWatcherItemsToMenu: aMenu forGetter: aGetterSymbol.	(self slotInfo includesKey: slotSym)		ifTrue:			[aMenu add: 'change data type' selector: #chooseSlotTypeFor: argument: aGetterSymbol.			typeVocab addUserSlotItemsTo: aMenu slotSymbol: slotSym.  "e.g. decimal places"			aMenu add: 'remove "', slotSym, '"' selector: #removeSlotNamed: argument: slotSym.			aMenu add: 'rename  "', slotSym, '"' selector: #renameSlot: argument: slotSym].	typeVocab addExtraItemsToMenu: aMenu forSlotSymbol: slotSym.  "e.g. Player type adds hand-me-tiles"	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: #yourself].	aMenu addTitle: (aGetterSymbol asString, ' (', aType, ')').	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!Player methodsFor: 'scripts-kernel' stamp: 'tk 9/29/2001 22:20'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList makeSelfGlobal phrase |	itsSelector _ aMethodInterface selector.	argList _ OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile _ ScriptingSystem tileForArgType: (aType _ aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #Player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms _ MessageSend receiver: self selector: itsSelector arguments: argList asArray.	"For CardPlayers, use 'self'.  For others, name me, and use my global name."	makeSelfGlobal _ self class officialClass ~~ CardPlayer.	phrase _ ms asTilesIn: self class globalNames: makeSelfGlobal.	makeSelfGlobal ifFalse: [phrase setProperty: #scriptedPlayer toValue: self].	^ phrase! !!CardPlayer methodsFor: 'slots-kernel' stamp: 'tk 9/28/2001 13:00'!tileReferringToSelf	"answer a tile that refers to the receiver.  For CardPlayer, want 'self', not the specific name of this card.  Script needs to work for any card of the background."	| aTile  tile |	Preferences universalTiles ifTrue:		[tile _ SyntaxMorph new parseNode: 			(VariableNode new name: 'self' key: 'self' code: 112).		tile layoutInset: 1; addMorph: (tile addString: 'self' special: false).			"translate to wordy variant here..."		tile color: (SyntaxMorph translateColor: #variable).		tile extent: tile firstSubmorph extent + (2@2).		^ tile].	aTile _ TileMorph new setToReferTo: self.	^ aTile! !!CardPlayer methodsFor: 'scripts-kernel' stamp: 'tk 9/29/2001 10:29'!renameScript: oldSelector newSelector: newSelector	"Find all buttons that fire this script and tell them the new name"	super renameScript: oldSelector newSelector: newSelector.	costume allMorphsDo: [:mm |		self retargetButton: mm oldSelector: oldSelector newSelector: newSelector].	(costume valueOfProperty: #myStack) cards do: [:cc |		cc privateMorphs do: [:pp | 			pp allMorphsDo: [:mm |				self retargetButton: mm oldSelector: oldSelector newSelector: newSelector]]].! !!CardPlayer methodsFor: 'scripts-kernel' stamp: 'tk 9/29/2001 10:27'!retargetButton: mm oldSelector: oldSelector newSelector: newSelector	"changing the name of a script -- tell any buttons that fire it"	(mm respondsTo: #scriptSelector) ifTrue: [		mm scriptSelector == oldSelector ifTrue: [			mm scriptSelector: newSelector.			mm setNameTo: newSelector]].	(mm respondsTo: #actionSelector) ifTrue: [		mm actionSelector == oldSelector ifTrue: [			mm target class == self class ifTrue: [				mm actionSelector: newSelector.				mm setNameTo: newSelector]]].! !!Player class methodsFor: 'other' stamp: 'tk 9/28/2001 11:43'!wantsChangeSetLogging	"Log changes for Player itself, but not for automatically-created subclasses like Player1, Player2, but *do* log it for uniclasses that have been manually renamed."	^ (self == Player or:		[(self name beginsWith: 'Player') not]) or:			[Preferences universalTiles]! !!CardPlayer class methodsFor: 'logging' stamp: 'tk 9/28/2001 11:42'!wantsChangeSetLogging	"Log changes for CardPlayer itself, but not for automatically-created subclasses like CardPlayer1, CardPlayer2, but *do* log it for uniclasses that have been manually renamed."	^ (self == CardPlayer or:		[(self name beginsWith: 'CardPlayer') not]) or:			[Preferences universalTiles]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 9/28/2001 13:35'!addYesNoToHand	"Place a test/yes/no complex in the hand of the beloved user"	| ms messageNodeMorph |	Preferences universalTiles		ifTrue:			[ms _ MessageSend receiver: true selector: #ifTrue:ifFalse: 						arguments: {['do nothing']. ['do nothing']}.			messageNodeMorph _ ms asTilesIn: playerScripted class globalNames: true.			self primaryHand attachMorph: messageNodeMorph]		ifFalse:			[self primaryHand attachMorph: CompoundTileMorph new]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 9/27/2001 17:16'!renameScriptTo: newSelector	"Rename the receiver's script so that it has given new selector"	| aMethodNodeMorph |	scriptName _ newSelector.	self updateHeader.	Preferences universalTiles		ifFalse:			[self install]		ifTrue:			[(aMethodNodeMorph _ self methodNodeMorph) ifNotNil: [				aMethodNodeMorph acceptInCategory: 'scripts']]! !!ScriptableButton methodsFor: 'script' stamp: 'tk 10/1/2001 10:13'!editButtonsScript	"The user has touched my Scriptor halo-handle.  Bring up a Scriptor on the script of the button."	| cardsPasteUp cardsPlayer anEditor |	cardsPasteUp _ self pasteUpMorph.	(cardsPlayer _ cardsPasteUp assuredPlayer) assureUniClass.	anEditor _ scriptSelector			ifNil:				[scriptSelector _ cardsPasteUp scriptSelectorToTriggerFor: self.				(scriptSelector beginsWith: 'script') 					ifTrue: [cardsPlayer newTextualScriptorFor: scriptSelector.	"create, textual"						cardsPlayer scriptEditorFor: scriptSelector]	"as tiles"					ifFalse: [cardsPlayer newTextualScriptorFor: scriptSelector]]	"never happens?"			ifNotNil:				[(cardsPlayer class selectors includes: scriptSelector)					ifTrue:						[cardsPlayer scriptEditorFor: scriptSelector]					ifFalse:						["Method somehow got removed; I guess we start afresh"						scriptSelector _ nil.						^ self editButtonsScript]].	self currentHand attachMorph: anEditor.! !!ScriptableButton methodsFor: 'accessing' stamp: 'tk 9/28/2001 21:09'!scriptSelector	^ scriptSelector! !!ScriptableButton methodsFor: 'accessing' stamp: 'tk 9/28/2001 21:09'!scriptSelector: aSymbol	scriptSelector _ aSymbol! !!StackMorph methodsFor: 'card access' stamp: 'tk 10/1/2001 10:28'!goToCard: destinationCard	"Install the indicated destinationCard as the current card in the receiver.  Any viewer currently open on the current card will get retargeted to look at the new one."	| aBackground existingCard oldViewers |	aBackground _ self backgroundWithCard: destinationCard.	existingCard _ aBackground currentDataInstance.	oldViewers _ existingCard ifNil: [#()] ifNotNil: [existingCard allOpenViewers].	aBackground installAsCurrent: destinationCard.	aBackground ~~ currentPage ifTrue:		["concern that need to run opening/closing scripts even when we're not going to a different background"		self goToPageMorph: aBackground.		aBackground setProperty: #myStack toValue: self].	"way to get back"	oldViewers do: [:aViewer | aViewer retargetFrom: existingCard to: destinationCard]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/25/2001 11:28'!readOut	"Find and return an UpdatingStringMorph, possibly in a NumericReadoutTile"	^ ((self findA: NumericReadoutTile) ifNil: [^ nil]) findA: UpdatingStringMorph! !!SyntaxMorph methodsFor: 'node types' stamp: 'tk 9/26/2001 05:50'!isDeclaration	"Return true if I am a TempVarNode inside a declaration of some kind, including a method arg"	| opc |	owner isSyntaxMorph ifFalse: [^ false].	opc _ owner parseNode class.	opc == BlockArgsNode ifTrue: [^ true].	opc == MethodTempsNode ifTrue: [^ true].	opc == SelectorNode ifTrue: [^ true].	^ false! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 9/26/2001 05:56'!mouseDown: evt 	| dup rootTile |	evt yellowButtonPressed ifTrue: [^ self showMenu: evt].	(rootTile _ self rootTile) isMethodNode ifTrue:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == innerMorph])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"Out in the world -- treat as a unit"	rootTile isSticky ifTrue: [^ self].	"later may allow to be selected"	rootTile isPartsDonor 		ifTrue: [dup _ rootTile duplicate.				dup setProperty: #beScript toValue: true]		ifFalse: [dup _ rootTile].	evt hand attachMorph: dup.	Preferences tileTranslucentDrag		ifTrue: [^ dup lookTranslucent]		ifFalse: [^ dup align: dup topLeft with: evt hand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/30/2001 11:09'!morphToDropInPasteUp: aPasteUp	"If property #beScript is true, create a scriptor around me."	| actualObject itsSelector aScriptor adjustment handy tw blk |	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	actualObject _ self actualObject ifNil: [					self valueOfProperty: #scriptedPlayer ifAbsent: [nil]].	actualObject ifNil: [^ self].	self removeProperty: #scriptedPlayer.	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ itsSelector isEmptyOrNil		ifFalse:			[adjustment _ 0@0.			actualObject scriptEditorFor: itsSelector]		ifTrue:			[adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	aScriptor ifNil: [^self].	handy _ aPasteUp primaryHand.	aScriptor position: handy position - adjustment.	aPasteUp addMorphFront: aScriptor.	"do this early so can find World"	aScriptor showingMethodPane ifFalse: [		"(tw _ aScriptor findA: TwoWayScrollPane) ifNil:			[itsSelector ifNil: ['blank script'.				tw _ aScriptor findA: TwoWayScrollPane.				blk _ (tw scroller findA:  SyntaxMorph ""MethodNode"") findA: BlockNode.				blk addMorphFront: self]].		"		SyntaxMorph setSize: nil andMakeResizable: aScriptor.		].	^ aScriptor! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/24/2001 10:04'!structureMatchWith: aMorph	| meNoun itNoun |	"Return true if the node types would allow aMorph to replace me.  This tests the gross structure of the method only."	meNoun _ self isNoun.	itNoun _ aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ (self submorphs				detect: [:mm | ((mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode])]				ifNone: [nil]) isNil].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"		(aMorph nodeClassIs: CommentNode) ifTrue: [^ true]].	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	(self nodeClassIs: ReturnNode) & (aMorph parseNode class == MessageNode) 		ifTrue: [^ true].		"Command replace Return"	(self nodeClassIs: MessageNode) & (aMorph parseNode class == ReturnNode) ifTrue: [		(owner submorphs select: [:ss | ss isSyntaxMorph]) last == self			ifTrue: [^ true]].	"Return replace last command"	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			^ self isAVariable & self isDeclaration not]].	"only assign to a variable"	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: aMorph parseNode class) ifTrue: [		(self nodeClassIs: MessageNode) 				ifFalse: [^ true]	"normal match"				ifTrue: [^ self receiverNode == aMorph receiverNode]].	"both nil"	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:36'!colorChangedForSubmorph: colorPatch	| sel newSel cc ms phrase completeMsg |	"reporting a color change"	(self nodeClassIs: MessageNode) ifFalse: [^ nil].	(sel _ self selector) ifNil: [^ nil].	(Color colorNames includes: sel) | (sel == #r:g:b:) ifFalse: [^ nil].		"a standard color name"	"replace self with new tiles from the color"	(newSel _ (cc _ colorPatch color) name) 		ifNil: [ms _ MessageSend receiver: Color selector: #r:g:b: arguments: 				(Array with: cc red with: cc green with: cc blue).			phrase _ ms asTilesIn: Color globalNames: true]		ifNotNil: [ms _ MessageSend receiver: Color selector: newSel arguments: #().			phrase _ ms asTilesIn: Color globalNames: true].	self deletePopup.	completeMsg _ self isNoun ifTrue: [self] ifFalse: [owner].	completeMsg owner replaceSubmorph: completeMsg by: phrase.	"rec setSelection: {rec. nil. rec}."	phrase acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:38'!extend	| messageNodeMorph first |	"replace this noun with a new message like (arg + 1).  If type is not known, ask the user to type in a selector.  Use nil as arg.  Let user drag something to it afterwards."	"Later do evaluation of self to see what type and offer right selector"	self deselect.	messageNodeMorph _ (MessageSend receiver: 1 selector: #+ arguments: #(1))								asTilesIn: Player globalNames: false.	owner replaceSubmorph: self by: messageNodeMorph.	first _ messageNodeMorph submorphs detect: [:mm | mm isSyntaxMorph].	messageNodeMorph replaceSubmorph: first by: self.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 11:35'!newAssignment	"I am a variableNode.  Place me inside an assignment statement."	| new old |	parseNode name: self decompile.	"in case user changed name"	new _ owner assignmentNode: AssignmentNode new variable: parseNode 					value: parseNode copy.	self deselect.	(old _ owner) replaceSubmorph: self by: new.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:39'!replaceKeyWord: evt menuItem: stringMorph	"Replace my entire message (which may be multi-part) with the one specified.  Preserve all argument tiles, either in the new message or in the world outside the scriptor.  I am a SelectorNode or KeyWordNode."	| menu new news newSel mm newTree newRec newArgs top oldArgNodes share ctrY |	(menu _ stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new _ stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news _ String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: #(' 5' $ )) do: [:part | strm nextPutAll: part]].	newSel _ stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel _ news].	mm _ MessageSend receiver: 5 selector: newSel 			arguments: ((Array new: newSel numArgs) atAllPut: 5).	newTree _ mm asTilesIn: Object globalNames: false.	newRec _ newTree receiverNode.	newArgs _ newTree argumentNodes.	ctrY _ self fullBoundsInWorld center y.	top _ self messageNode.	newRec owner replaceSubmorph: newRec by: top receiverNode.	oldArgNodes _ top argumentNodes.	share _ newArgs size min: oldArgNodes size.	(newArgs first: share) with: (oldArgNodes first: share) do: [:newNode :oldNode | 		newNode owner replaceSubmorph: newNode by: oldNode].	"later get nodes for objects of the right type for new extra args"	top owner replaceSubmorph: top by: newTree.	"Deposit extra args in the World"	(oldArgNodes copyFrom: share+1 to: oldArgNodes size) do: [:leftOver |		(leftOver parseNode class == LiteralNode and: [leftOver decompile asString = '5']) 			ifFalse: [newTree pasteUpMorph addMorphFront: leftOver.				leftOver position: newTree enclosingPane fullBoundsInWorld right - 20 @ ctrY.				ctrY _ ctrY + 26]			ifTrue: [leftOver delete]].	newTree acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 10:06'!retract	"replace this message with its receiver.  I am the message node."	| rec cascade msg |	(self nodeClassIs: CascadeNode) ifTrue:		["This is a piece of a cascaded message -- just delete it"		self deletePopup.		cascade _ owner.		self delete.		cascade setSelection: {cascade. nil. cascade}.		^ cascade acceptIfInScriptor].	self deletePopup.	(rec _ self receiverNode)		ifNil: [msg _ owner.			rec _ owner receiverNode.			msg owner replaceSubmorph: msg by: rec]		ifNotNil: [owner replaceSubmorph: self by: rec].	rec setSelection: {rec. nil. rec}.	rec acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 19:09'!accept	"Turn my current state into the text of a method.  Compile it in my class."	^ self acceptInCategory: ClassOrganizer default! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 17:15'!acceptInCategory: categoryString	"Turn my current state into the text of a method.  Compile it in my class."	| cls sc sel |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile accept  "always accept at the root"].	(cls _ self parsedInClass) ifNil: [^ self].	sel _ cls compile: self decompile classified: categoryString.	(sc _ self firstOwnerSuchThat: [:mm | mm class == ScriptEditorMorph]) 		ifNotNil: [sc hibernate; unhibernate].	"rebuild the tiles"	^ sel! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 19:12'!acceptSilently	"Turn my current state into the text of a method.	Compile it in my class.  Don't rebuild the tiles."	| cls |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ false].  "not in a script"		^ self rootTile acceptSilently  "always accept at the root"].	(self ownerThatIsA: ScriptEditorMorph) ifNil: [^ false].	(cls _ self parsedInClass) ifNil: [^ false].	cls compile: self decompile classified: 'scripts'.	^ true! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/26/2001 06:01'!tearOffTile	"For a SyntaxMorph, this means give a copy of me"	| dup |	dup _ self duplicate.	ActiveHand attachMorph: dup.	Preferences tileTranslucentDrag		ifTrue: [^ dup lookTranslucent]		ifFalse: [^ dup align: dup topLeft with: ActiveHand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 9/25/2001 11:46'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')"	^ true! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 9/26/2001 06:05'!currentDataValue	"Answer the current data value held by the receiver"	^ self readOut valueFromContents! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 9/25/2001 13:07'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	self readOut ifNotNil: ["If has a place to put per-card data, set that up."		self setProperty: #holdsSeparateDataForEachInstance toValue: true].	super putOnBackground.! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 9/25/2001 11:41'!setNewContentsFrom: stringOrNumberOrNil	"Using stringOrNumberOrNil as a guide, set the receiver's contents afresh.  If the input parameter is nil, the a default value stored in a property of the receiver, if any, will supply the new initial content.  This method is only called when a VariableDock is attempting to put a new value."	(self readOut ifNil: [^ self]) setNewContentsFrom: stringOrNumberOrNil.! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 9/26/2001 05:30'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield.  For a numeric-readout tile."	"Is CardPlayer class holding my variableDock, or should I be using the caching mechanism in Morph>>variableDocks?"	| rr |	(rr _ self readOut) ifNil: [^ #()].	^ Array with: (VariableDock new 			variableName: (rr getSelector allButFirst: 3) withFirstCharacterDownshifted 			type: #number 			definingMorph: rr 			morphGetSelector: #valueFromContents 			morphPutSelector: #acceptValue:)! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'tk 9/26/2001 05:09'!initialize	"Initialie the receiver to have default values in its instance variables"	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _  nil.	floatPrecision _ 1.	growable _ true.	stepTime _ 50.	autoAcceptOnFocusLoss _ true.	minimumWidth _ 8.	maximumWidth _ 300.! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'tk 9/26/2001 05:32'!acceptValue: aValue	"If target is a CardPlayer, and its costume is one of my owners, change target to its current CardPlayer"	target class superclass == CardPlayer ifTrue: [		(self hasOwner: target costume) ifTrue: [				self target: target costume player]].	self updateContentsFrom: (self acceptValueFromTarget: aValue).! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'tk 9/26/2001 05:09'!checkTarget	""! !!UpdatingStringMorph methodsFor: 'copying' stamp: 'tk 9/26/2001 05:09'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared."	super veryDeepInner: deepCopier.	format _ format veryDeepCopyWith: deepCopier.	target _ target.					"Weakly copied"	lastValue _ lastValue veryDeepCopyWith: deepCopier.	getSelector _ getSelector.			"Symbol"	putSelector _ putSelector.		"Symbol"	floatPrecision _ floatPrecision veryDeepCopyWith: deepCopier.	growable _ growable veryDeepCopyWith: deepCopier.	stepTime _ stepTime veryDeepCopyWith: deepCopier.	autoAcceptOnFocusLoss _ autoAcceptOnFocusLoss veryDeepCopyWith: deepCopier.	minimumWidth _ minimumWidth veryDeepCopyWith: deepCopier.	maximumWidth _ maximumWidth veryDeepCopyWith: deepCopier.! !!UpdatingStringMorph methodsFor: 'card & stack' stamp: 'tk 9/26/2001 06:04'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')"	^ true! !!UpdatingStringMorph methodsFor: 'card & stack' stamp: 'tk 9/26/2001 06:06'!currentDataValue	"Answer the current data value held by the receiver"	^ self valueFromContents! !!UpdatingStringMorph methodsFor: 'card & stack' stamp: 'tk 9/26/2001 06:08'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	"If I seem to have per-card data, then set that up."	target class superclass == CardPlayer ifTrue: [		(self hasOwner: target costume) ifTrue: [				self setProperty: #holdsSeparateDataForEachInstance toValue: true]].	super putOnBackground.! !!UpdatingStringMorph methodsFor: 'card & stack' stamp: 'tk 9/25/2001 11:43'!setNewContentsFrom: stringOrNumberOrNil	self acceptValue: stringOrNumberOrNil! !!UpdatingStringMorph methodsFor: 'card & stack' stamp: 'tk 9/26/2001 06:10'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield.  For a numeric-readout tile."	"Is CardPlayer class holding my variableDock, or should I be using the caching mechanism in Morph>>variableDocks?"	^ Array with: (VariableDock new 			variableName: (getSelector allButFirst: 3) withFirstCharacterDownshifted 			type: #number 			definingMorph: self 			morphGetSelector: #valueFromContents 			morphPutSelector: #acceptValue:)! !!VariableNode methodsFor: 'initialize-release' stamp: 'tk 9/28/2001 11:33'!name: string	"Change name"	name _ string.! !UpdatingStringMorph removeSelector: #initWithContents:font:emphasis:!!TextFieldMorph reorganize!('just like textMorph' append: contents contents: fit fontName:size: initialize lineCount)('card & stack' couldHoldSeparateDataForEachInstance currentDataValue setNewContentsFrom: variableDocks)!SyntaxMorph removeSelector: #isCascadePart!!SyntaxMorph reorganize!('initialization' inAPluggableScrollPane inAScrollPane openInWindow returnNode:expression: sample:)('accessing' actualObject argumentNodes cleanUpString: color: dissectMessage editor enclosingPane externalName fillStyle: getCurrentValue messageNode parseNode parseNode: parsedInClass parsedInClass: readOut receiverNode receiverObject rename: selector unSpaceAndUpShift:appending: userScriptSelector userScriptSelector:)('node types' findA: immediatelyBelowTheMethodNode isAVariable isBlockNode isDeclaration isLeafTile isMethodNode isNoun isSelfTile isSyntaxMorph nodeClassIs: rootTile)('event handling' cursorBaseOffset handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: step stepTime wantsSteps)('dropping/grabbing' acceptDroppingMorph:event: cleanupAfterItDroppedOnMe justDroppedInto:event: morphToDropInPasteUp: structureMatchWith: wantsDroppedMorph:event:)('drawing' drawOn: lookTranslucent)('highlighting' borderColor: compoundBorderColor dropColor grabColor highlightForDrop: highlightForGrab: stdBorderColor unhighlight unhighlightBorder unhighlightOwner unhighlightOwnerBorder)('selection' currentSelectionDo: deselect isSelectable scaleColorByUserPref: select setDeselectedColor setSelection: wantsKeyboardFocusFor:)('insertion drop zones' removeDropZones trackDropZones)('layout' addBlockArg: addColumn:on: addMorphBack: addNoiseString: addNoiseString:emphasis: addRow:on: addSingleKeywordRow: addString:special: addTempVar: addTextRow: addToBlock:event: addToken:type:on: addTokenSpecialCase:type:on: addUnaryRow:style: foldMessage foldMessageOneArg isKnownVarName: removeReturnNode tempVarNodesDo: try unfoldMessage)('printing' getHeader: ownerPrecedence printAssignmentNodeOn:indent: printBlockArgsNodeOn:indent: printBlockNodeOn:indent: printCascadeNodeOn:indent: printMessageNodeOn:indent: printMethodNodeOn:indent: printMethodTempsNodeOn:indent: printOn: printOn:indent: printSimpleStringMorph:on: printStatementsOn:indent: printVariableNodeOn:indent: structure submorphsDoIfSyntax:ifString: submorphsDoIfSyntax:ifString:otherwise:)('pop ups' addArg: assignmentArrow changeSound: colorChangedForSubmorph: colorPatch deleteLine deletePopup dismisser event:arrow:upDown: extend extendArrow newAssignment offerPopUp replaceKeyWord:menuItem: replaceSel:menuItem: retract retractArrow selectorMenu selectorMenuAsk: setSelector:in: tossOutArg: upDown:event:arrow: upDownArithOp: upDownArrows upDownAssignment: upDownDone upDownMore:event:arrow:)('new tiles' attachTileForCode:nodeType: attachToHand instVarTile: string:toTilesIn:)('menus' accept acceptIfInScriptor acceptIgnoring: acceptInCategory: acceptSilently acceptUnlogged decompile getMenuBlock offerTilesMenuFor:in: offerVarsMenuFor:in: showCode showMenu: tearOffTile)('debugging' balloonText debugger debugger: hostContext update:)('tests' changed test testForNode:andDo: toDo)('type checking' allSpecs argTypeFor: currentVocabulary okToBeReplacedBy: receiverOrArgType receiverOrArgTypeAbove receiverTypeFor: resultType resultTypeFor:)('node to morph' addTemporaries: addTemporaryControls alanBinaryPostRcvr:key:args: alanKeywordMessage:isAConditional:key:args: alanKwdCollect:isAConditional:key:args: alanKwdIfDo:isAConditional:key:args: alanKwdRepeatForDoing:isAConditional:key:args: alanKwdSetter2:isAConditional:key:args: alanKwdSetter:isAConditional:key:args: alanUnaryGetter:key: alanUnaryPostRcvr:key:selector: alansMessageNode:receiver:selector:keywords:arguments: assignmentNode:variable:value: blockNode:arguments:statements: blockNodeCollect:arguments:statements: cascadeNode:receiver:messages: changeBasicStyle finalAppearanceTweaks isStandardGetterSelector: isStandardSetterKeyword: messageNode:receiver:selector:keywords:arguments: messageOneArg:receiver:selector:args: methodNodeInner:selectorOrFalse:precedence:arguments:temporaries:primitive:block: methodNodeOuter: vanillaMessageNode:receiver:selector:arguments:)('formatting options' alansTest1 controlContrast2: controlContrast: controlSpacing2: controlSpacing: lookClassic usingClassicTiles)('alans styles' aSimpleStringMorphWith: alansCurrentFontPreference alansTemplateStyleFor: anUpdatingStringMorphWith:special: constructSelfVariant:and: darkerColor fontToUseForSpecialWord: lighterColor noiseBeforeBlockArg noiseStringMorph: noiseWordBeforeVariableNode:string: setConditionalPartStyle setSpecialOuterTestFormat setSpecialTempDeclarationFormat1 setSpecialTempDeclarationFormat2 shouldBeBrokenIntoWords: specialColor:andBorder: splitAtCapsAndDownshifted: standardCellPositioning standardInset substituteKeywordFor: tokenVerticalSeparator translateFromWordySelfVariant: translateToWordyGetter: translateToWordySelfVariant: translateToWordySetter:)('vocabulary' limitClassToUseWith:vocabulary: vocabularyToUseWith:)('card & stack' couldHoldSeparateDataForEachInstance currentDataValue putOnBackground setNewContentsFrom: variableDocks)!!ImageMorph reorganize!('initialization' initialize)('menu commands' grabFromScreen readFromFile)('accessing' color: form image image: isOpaque isOpaque: setNewImageFrom:)('card & stack' couldHoldSeparateDataForEachInstance currentDataValue variableDocks)('other' extent: newForm: releaseCachedState wearCostume:)('drawing' drawOn: drawPostscriptOn: wantsRoundedCorners)('menu' addCustomMenuItems:hand: changeOpacity opacityString)('parts bin' initializeToStandAlone)!