'From Squeak2.9alpha of 5 August 2000 [latest update: #2616] on 15 September 2000 at 8:59:43 am'!"Change Set:		coll-swDate:			15 September 2000Author:			Scott WallaceRefinements to the scripting access to text and collections, including:¥	Assure that morphs added with the #append: scripting operation are placed within view even if parent is not doing auto-line-layout.¥	Add #firstElement to the scripting vocabulary for PasteUpMorphs.¥	Add #allButFirst to the scripting vocabulary for TextMorphs¥	Fixed *many* bugs that showed up when you looked at the 'text' viewer category for a TextMorph that was rotated."!!Morph methodsFor: 'initialization' stamp: 'sw 3/21/2000 14:46'!openInHand	"Attach the receiver to the current hand in the current morphic world"	self currentHand attachMorph: self! !!Morph methodsFor: 'scripting' stamp: 'sw 9/15/2000 05:19'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	"Answer a readout tile representing the given part's value, given the putter, getter, and type information"	| aColor aTile displayer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:			[NumericReadoutTile new typeColor: aColor]		ifFalse:				[typeSymbol == #sound				ifTrue:					[SoundReadoutTile new typeColor: aColor]				ifFalse:					[StringReadoutTile new typeColor: aColor]]. 	displayer _ UpdatingStringMorph new		getSelector: getSelector;		target: self player;		growable: true;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	(typeSymbol == #number)		ifTrue:			 [((#(cursor  "etc...") includes: partName) and: [self isKindOf: GraphMorph])				ifTrue:					[displayer floatPrecision: 0.1]				ifFalse:					[(self player slotInfo includesKey: partName)  "i.e., a user-defined numeric slot"						ifTrue:							[displayer floatPrecision: (self player slotInfoAt: partName) floatPrecision]]].	typeSymbol == #string		ifTrue:			[displayer useStringFormat.			displayer growable: true]		ifFalse:			[(typeSymbol == #sound)				ifTrue: 	[displayer useStringFormat]				ifFalse:	[displayer useDefaultFormat]].	aTile addMorphBack: displayer.	((putSelector ~~ #unused) and: [#(number sound boolean) includes: typeSymbol])  ifTrue: [aTile addArrows].	aTile setLiteralInitially: (self scriptPerformer perform: getSelector).	^ aTile! !!Morph methodsFor: 'e-toy support' stamp: 'sw 9/15/2000 06:26'!setNumericValue: aValue	"Set the receiver's contents to reflect the given numeric value.  Only certain kinds of morphs know what to do with this, the rest, for now, stash the number in a property, where it may not be visible but at least it won't be lost, and can be retrieved by the companion getter.  This code is never reached under normal circumstances, because the #numericValue slot is not shown in Viewers for most kinds of morphs, and those kinds of morphs that do show it also reimplement this method.  However, this code *could* be reached via a user script which sends #setNumericValue: but whose receiver has been changed, via tile-scripting drag and drop for example, to one that doesn't directly handle numbers"	ScriptingSystem informScriptingUser: 'an unusual setNumericValue: call was made'.	self renderedMorph setProperty: #numericValue toValue: aValue! !!PasteUpMorph class methodsFor: 'scripting' stamp: 'sw 9/14/2000 06:43'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((playfield ((command initiatePainting 'Initiate painting of a new object in the standard playfield.')(slot mouseX 'The x coordinate of the mouse pointer' number readWrite player getMouseX  unused unused)(slot mouseY 'The y coordinate of the mouse pointer' number readWrite player getMouseY  unused unused)(command roundUpStrays 'Bring all out-of-container subparts back into view.')(slot numberAtCursor 'the number at the cursor' number readWrite player getNumberAtCursor player setNumberAtCursor: )(slot playerAtCursor 'the object currently at the cursor' player readWrite player getValueAtCursor  unused unused)(command unhideHiddenObjects 'Unhide all hidden objects.')))(collections ((slot cursor 'The index of the chosen element' number readWrite player getCursor player setCursorWrapped:)(slot playerAtCursor 'the object currently at the cursor' player readWrite player getValueAtCursor  unused unused)(slot firstElement  'The first object in my contents' player  readWrite player getFirstElement  player  setFirstElement:)(slot numberAtCursor 'the number at the cursor' number readWrite player getNumberAtCursor player setNumberAtCursor: )(command removeAll 'Remove all elements from the playfield')(command shuffleContents 'Shuffle the contents of the playfield')(command append: 'Add the object to my content' player)))(#'card/stack' ((command goToNextCard 'Go to the next card')(command goToPreviousCard  'Go to the previous card')(command deleteCard 'Delete the current card')(command newCard 'Create a new card')))(#'pen trails' ((command liftAllPens 'Lift the pens on all the objects in my interior.')(command lowerAllPens  'Lower the pens on all the objects in my interior.')(command clearTurtleTrails 'Clear all the pen trails in the interior.'))))! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/15/2000 06:11'!getAllButFirstCharacter 	"Answer a string consisting of all but the first character in its string"	^ costume renderedMorph getAllButFirstCharacter! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/14/2000 11:26'!getCharacters	"Answer the characters in my costume, likely a TextMorph"	^ costume renderedMorph getCharacters! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/14/2000 11:26'!getFirstCharacter	"Answer a string consisting of the first character in my costume, likely itself a TextMorph"	^ costume renderedMorph getFirstCharacter! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/15/2000 06:12'!getFirstElement	"Answer a player representing the receiver's costume's first submorph"	| itsMorphs |	^ (itsMorphs _ costume submorphs) size > 0		ifFalse:			[self standardPlayer]		ifTrue:			[itsMorphs first assuredPlayer]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/14/2000 11:39'!getNumericValue	"Answer the numeric value contained in my costume"	^ costume renderedMorph getNumericValue! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/14/2000 11:29'!setAllButFirstCharacter: aString	"Set my costume's all-but-first characters to be aString"	costume renderedMorph setAllButFirstCharacter: aString! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/14/2000 11:28'!setCharacters: amt	"Set my costume's characters as indicated"	costume renderedMorph setCharacters: amt! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/14/2000 11:29'!setFirstCharacter: aChar	"Set my costume's first character to the indicated one"	costume renderedMorph setFirstCharacter: aChar! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/15/2000 06:15'!setFirstElement: aPlayer	"Caution - this is a replacement operation!!  Replace the receiver's costume's first element with the morph represented by aPlayer"	| aCostume |	(aPlayer == self or: [(aCostume _ self costume) submorphs size == 0]) ifTrue: [^ self].	costume replaceSubmorph: aCostume submorphs first by: aPlayer costume! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/15/2000 06:12'!setNumericValue: amt	"Set the receiver's numeric value to the amount.  This is passed on to the costume"	costume renderedMorph setNumericValue: amt! !!Player methodsFor: 'scripts-execution' stamp: 'sw 9/14/2000 06:49'!standardPlayer	"Answer the standard player for the receiver's costume's presenter"	^  self presenter standardPlayer costume! !!Player methodsFor: 'scripts-standard' stamp: 'sw 9/15/2000 06:14'!append: aPlayer	"Add aPlayer to the list of objects logically 'within' me.  This is visually represented by its morph becoming my costume's last submorph"	| aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(aCostume _ self costume topRendererOrSelf) addMorphNearBack:  aPlayer costume.	aPlayer costume goHome.  "assure it's in view"	(aCostume isKindOf: PasteUpMorph) ifTrue:		[self setCursor: (aCostume submorphs indexOf: aPlayer costume)]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/15/2000 06:24'!informScriptingUser: aString	"This provides a hook for logging messages that the user or the developer may wish to see; at present it simply logs the message to the Transcript, with a standard prefix to signal their provenance.  Such messages will fall on the floor if there is no Transcript window open"	Transcript cr; show: 'SCRIPT NOTE: ', aString! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 9/15/2000 06:14'!getAllButFirstCharacter	"Obtain all but the first character from the receiver; if that would be empty, return a black dot"	| aString |	^ (aString _ text string) size > 1 ifTrue: [aString copyFrom: 2 to: aString size] ifFalse: ['¥']! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 9/15/2000 06:14'!getNumericValue	"Obtain a numeric value from the receiver; if no digits, return zero"	| aString |	^ [(aString _ text string) asNumber] ifError: [:a :b | ^ aString asInteger ifNil: [0]]! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 9/14/2000 08:55'!setAllButFirstCharacter: source	"Set all but the first char of the receiver to the source"	| aChar chars |	aChar _ source asCharacter.	(chars _ self getCharacters) size > 0 		ifFalse:			[self newContents: ('¥', source asString)]		ifTrue:			[(chars first = aChar) ifFalse:				[self newContents: (String streamContents:					[:aStream |						aStream nextPut: chars first.						aStream nextPutAll: source])]]! !!TextMorph class methodsFor: 'scripting' stamp: 'sw 9/15/2000 06:16'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((text ((slot characters	'The characters in my contents' string	readWrite player getCharacters player setCharacters:)(slot firstCharacter  'The first character in my contents' string  readWrite player getFirstCharacter  player  setFirstCharacter:)(slot allButFirst 'All my characters except the first one' string readWrite player getAllButFirstCharacter player  setAllButFirstCharacter:)(slot numericValue 'The number represented by my contents' number readWrite player getNumericValue player  setNumericValue:)))(basic ((slot characters	'The characters in my contents' string	readWrite player getCharacters player setCharacters:))))! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/15/2000 06:00'!setLiteralInitially: anObject	"Establish the initial literal.  Get the label correct, but do *not* send the value back to the target via the setter (unlike #literal:)"	literal _ anObject.	self updateLiteralLabel! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/15/2000 06:02'!setLiteral: anObject	"Set the receiver's literal to be anObject.  Create a readout morph and add it to the receiver, deleting any existing one that may be there."	| m already |	already _ submorphs detect: [:aSubMorph  | aSubMorph isKindOf: UpdatingStringMorph] ifNone: [nil].	already ifNotNil: [already delete].	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String) ifTrue: [m useStringFormat].	self addMorphBack: m.	self setLiteralInitially: anObject.! !NumericReadoutTile removeSelector: #setLiteralInitially:!"Postscript:"StandardScriptingSystem initialize.!