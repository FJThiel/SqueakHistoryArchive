'From Squeak3.4 of 1 March 2003 [latest update: #5170] on 7 April 2003 at 9:02:49 pm'!"Change Set:		KCP-0043-rmWhichClassIncludesDate:			7 April 2003Author:			stephane ducasseThe methods Behavior>>whichClassIncludesSelector: and Behavior>>classThatUnderstands: are terribly similar. I choose the keep the name whichClassIncludesSelector: because they were others methods with a similar name. However from a design point of view, classThatUnderstands was better because it used includesSelector: and not methodDict includeKey: so subclasses could specialize the includesSelector: if needed."!!Behavior methodsFor: 'accessing method dictionary'!precodeCommentOrInheritedCommentFor: selector 	"Answer a string representing the first comment in the method associated 	with selector, considering however only comments that occur before the 	beginning of the actual code. If the version recorded in the receiver is 	uncommented, look up the inheritance chain. Return nil if none found."	| aSuper aComment |	^ (aComment _ self firstPrecodeCommentFor: selector) isEmptyOrNil		ifTrue: [(self == Behavior					or: [superclass == nil							or: [(aSuper _ superclass whichClassIncludesSelector: selector) == nil]])				ifFalse: [aSuper precodeCommentOrInheritedCommentFor: selector]			"ActorState precodeCommentOrInheritedCommentFor: #printOn:"]		ifFalse: [aComment]! !!Behavior methodsFor: 'accessing method dictionary'!supermostPrecodeCommentFor: selector 	"Answer a string representing the precode comment in the most distant 	superclass's implementation of the selector. Return nil if none found."	| aSuper superComment |	(self == Behavior			or: [superclass == nil					or: [(aSuper _ superclass whichClassIncludesSelector: selector) == nil]])		ifFalse: ["There is a super implementor"			superComment _ aSuper supermostPrecodeCommentFor: selector].	^ superComment		ifNil: [self firstPrecodeCommentFor: selector			"ActorState supermostPrecodeCommentFor: #printOn:"]! !!Behavior methodsFor: 'testing method dictionary'!whichClassIncludesSelector: aSymbol 	"Answer the class on the receiver's superclass chain where the 	argument, aSymbol (a message selector), will be found. Answer nil if none found."	"Rectangle whichClassIncludesSelector: #inspect."	(self includesSelector: aSymbol)		ifTrue: [^ self].	superclass == nil		ifTrue: [^ nil].	^ superclass whichClassIncludesSelector: aSymbol! !!Behavior methodsFor: 'deprecated'!classThatUnderstands: selector 	self flag: #deprecated.	self error: 'Method Deprecated: Use Behavior>>whichClassIncludesSelector: instead'! !!CodeHolder methodsFor: 'tiles'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow _ self containingWindow)		ifNil: [self error: 'hamna dirisha'].	tileScriptor _ ((aSelector _ self selectedMessageName) isNil					or: [(aClass _ self selectedClassOrMetaClass whichClassIncludesSelector: aSelector) isNil])				ifTrue: [PluggableTileScriptorMorph new]				ifFalse: [source _ aClass sourceCodeAt: aSelector.					tree _ Compiler new								parse: source								in: aClass								notifying: nil.					(syn _ tree asMorphicSyntaxUsing: SyntaxMorph) parsedInClass: aClass.					syn inAPluggableScrollPane].	codePane _ aWindow				findDeepSubmorphThat: [:m | (m isKindOf: PluggableTextMorph)						and: [m getTextSelector == #contents]]				ifAbsent: [].	codePane		ifNotNil: [codePane hideScrollBar].	codePane		ifNil: [codePane _ aWindow						findDeepSubmorphThat: [:m | m isKindOf: PluggableTileScriptorMorph]						ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		 setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod _ aClass				ifNotNil: [aClass compiledMethodAt: aSelector].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent! !!EventHandler methodsFor: 'access'!messageList	"Return a list of 'Class selector' for each message I can send. tk 	9/13/97"	| list |	self flag: #mref.	"is this still needed? I replaced the one use that I could spot with 	#methodRefList "	list _ SortedCollection new.	mouseDownRecipient		ifNotNil: [list add: (mouseDownRecipient class whichClassIncludesSelector: mouseDownSelector) name , ' ' , mouseDownSelector].	mouseMoveRecipient		ifNotNil: [list add: (mouseMoveRecipient class whichClassIncludesSelector: mouseMoveSelector) name , ' ' , mouseMoveSelector].	mouseStillDownRecipient		ifNotNil: [list add: (mouseStillDownRecipient class whichClassIncludesSelector: mouseStillDownSelector) name , ' ' , mouseStillDownSelector].	mouseUpRecipient		ifNotNil: [list add: (mouseUpRecipient class whichClassIncludesSelector: mouseUpSelector) name , ' ' , mouseUpSelector].	mouseEnterRecipient		ifNotNil: [list add: (mouseEnterRecipient class whichClassIncludesSelector: mouseEnterSelector) name , ' ' , mouseEnterSelector].	mouseLeaveRecipient		ifNotNil: [list add: (mouseLeaveRecipient class whichClassIncludesSelector: mouseLeaveSelector) name , ' ' , mouseLeaveSelector].	mouseEnterDraggingRecipient		ifNotNil: [list add: (mouseEnterDraggingRecipient class whichClassIncludesSelector: mouseEnterDraggingSelector) name , ' ' , mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient		ifNotNil: [list add: (mouseLeaveDraggingRecipient class whichClassIncludesSelector: mouseLeaveDraggingSelector) name , ' ' , mouseLeaveDraggingSelector].	doubleClickRecipient		ifNotNil: [list add: (doubleClickRecipient class whichClassIncludesSelector: doubleClickSelector) name , ' ' , doubleClickSelector].	keyStrokeRecipient		ifNotNil: [list add: (keyStrokeRecipient class whichClassIncludesSelector: keyStrokeSelector) name , ' ' , keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access'!methodRefList	"Return a MethodReference for each message I can send. tk 9/13/97, raa 	5/29/01 "	| list adder |	list _ SortedCollection new.	adder _ [:recip :sel | recip				ifNotNil: [list						add: (MethodReference new								setStandardClass: (recip class whichClassIncludesSelector: sel)								methodSymbol: sel)]].	adder value: mouseDownRecipient value: mouseDownSelector.	adder value: mouseMoveRecipient value: mouseMoveSelector.	adder value: mouseStillDownRecipient value: mouseStillDownSelector.	adder value: mouseUpRecipient value: mouseUpSelector.	adder value: mouseEnterRecipient value: mouseEnterSelector.	adder value: mouseLeaveRecipient value: mouseLeaveSelector.	adder value: mouseEnterDraggingRecipient value: mouseEnterDraggingSelector.	adder value: mouseLeaveDraggingRecipient value: mouseLeaveDraggingSelector.	adder value: doubleClickRecipient value: doubleClickSelector.	adder value: keyStrokeRecipient value: keyStrokeSelector.	^ list! !!Lexicon methodsFor: 'selection'!categoryOfSelector: aSelector 	"Answer the name of the defining category for aSelector, or nil if none"	| classDefiningSelector |	classDefiningSelector _ targetClass whichClassIncludesSelector: aSelector.	classDefiningSelector		ifNil: [^ nil].	"can happen for example if one issues this from a change-sorter for a 	message that is recorded as having been removed"	^ classDefiningSelector whichCategoryIncludesSelector: aSelector! !!Lexicon methodsFor: 'within-tool queries'!selectorsChanged	"Return a list of methods in the current change set (or satisfying some 	other such criterion) that are in the protocol of this object"	| aList aClass targetedClass |	targetedClass _ self targetObject				ifNil: [targetClass]				ifNotNil: [self targetObject class].	aList _ OrderedCollection new.	Smalltalk changes methodChanges		associationsDo: [:classChgAssoc | classChgAssoc value				associationsDo: [:methodChgAssoc | (methodChgAssoc value == #change							or: [methodChgAssoc value == #add])						ifTrue: [(aClass _ targetedClass whichClassIncludesSelector: methodChgAssoc key)								ifNotNil: [aClass name = classChgAssoc key										ifTrue: [aList add: methodChgAssoc key]]]]].	^ aList! !!Lexicon methodsFor: 'tiles'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow _ self containingWindow)		ifNil: [self error: 'hamna dirisha'].	aSelector _ self selectedMessageName.	aClass _ self selectedClassOrMetaClass				ifNil: [targetClass].	aClass		ifNotNil: [aSelector				ifNil: [source _ SyntaxMorph sourceCodeTemplate]				ifNotNil: [aClass _ self selectedClassOrMetaClass whichClassIncludesSelector: aSelector.					source _ aClass sourceCodeAt: aSelector].			tree _ Compiler new						parse: source						in: aClass						notifying: nil.			(syn _ tree asMorphicSyntaxUsing: SyntaxMorph) parsedInClass: aClass.			tileScriptor _ syn inAPluggableScrollPane].	codePane _ aWindow				findDeepSubmorphThat: [:m | (m isKindOf: PluggableTextMorph)						and: [m getTextSelector == #contents]]				ifAbsent: [].	codePane		ifNotNil: [codePane hideScrollBar].	codePane		ifNil: [codePane _ aWindow						findDeepSubmorphThat: [:m | m isKindOf: PluggableTileScriptorMorph]						ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		 setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod _ aClass				ifNotNil: [aClass						compiledMethodAt: aSelector						ifAbsent: []].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent! !!MethodCall methodsFor: 'method interface'!ephemeralMethodInterface	"Answer a methodInterface for me. If I have one stored, answer it; if 	not, conjure up an interface and answer it but do NOT store it 	internally. You can call this directly if you need a method interface 	for me but do not want any conjured-up interface to persist."	^ methodInterface		ifNil: [MethodInterface new				conjuredUpFor: selector				class: (self receiver class whichClassIncludesSelector: selector)]! !!Morph methodsFor: 'meta-actions'!showActions	"Put up a message list browser of all the code that this morph  	would run for mouseUp, mouseDown, mouseMove, mouseEnter,  	mouseLeave, and  	mouseLinger. tk 9/13/97"	| list cls selector adder |	list _ SortedCollection new.	adder _ [:mrClass :mrSel | list				add: (MethodReference new setStandardClass: mrClass methodSymbol: mrSel)].	"the eventHandler"	self eventHandler		ifNotNil: [list _ self eventHandler methodRefList.			(self eventHandler handlesMouseDown: nil)				ifFalse: [adder value: HandMorph value: #grabMorph:]].	"If not those, then non-default raw events"	#(#keyStroke: #mouseDown: #mouseEnter: #mouseLeave: #mouseMove: #mouseUp: #doButtonAction )		do: [:sel | 			cls _ self class whichClassIncludesSelector: sel.			cls				ifNotNil: ["want more than default behavior"					cls == Morph						ifFalse: [adder value: cls value: sel]]].	"The mechanism on a Button"	(self respondsTo: #actionSelector)		ifTrue: ["A button"			selector _ self actionSelector.			cls _ self target class whichClassIncludesSelector: selector.			cls				ifNotNil: ["want more than default behavior"					cls == Morph						ifFalse: [adder value: cls value: selector]]].	MessageSet openMessageList: list name: 'Actions of ' , self printString! !!Viewer methodsFor: 'queries'!aboutMethod: aSelector 	"Give the user documentation for the selector"	| aClass help |	aClass _ scriptedPlayer class whichClassIncludesSelector: aSelector.	help _ aClass firstCommentAt: aSelector.	help		ifNotNil: [self				inform: (help string withNoLineLongerThan: 25)]! !!Viewer methodsFor: 'queries'!browseMethodFull: aSelector 	"Open a traditional browser on aSelector, in whatever class implements 	aSelector "	| aClass |	aClass _ scriptedPlayer class whichClassIncludesSelector: aSelector.	Browser fullOnClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries'!browseMethodInheritance: aSelector 	"Open an inheritance browser on aSelector"	| aClass |	aClass _ scriptedPlayer class whichClassIncludesSelector: aSelector.	Utilities methodHierarchyBrowserForClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries'!browseVersionsOf: aSelector 	"Open a browser on versions of aSelector"	| aClass |	aClass _ scriptedPlayer class whichClassIncludesSelector: aSelector.	Utilities browseVersionsForClass: aClass selector: aSelector! !!Vocabulary methodsFor: 'queries'!categoryList	"Answer the category list considering only code implemented in my 	limitClass and lower. This variant is used when the limitClass and 	targetObjct are known"	| classToUse foundAMethod classThatImplements |	classToUse _ object class.	^ categories		select: [:aCategory | 			foundAMethod _ false.			aCategory elementsInOrder				do: [:aSpec | 					classThatImplements _ classToUse whichClassIncludesSelector: aSpec selector.					(classThatImplements notNil							and: [classThatImplements includesBehavior: limitClass])						ifTrue: [foundAMethod _ true]].			foundAMethod]		thenCollect: [:aCategory | aCategory categoryName]! !!Vocabulary methodsFor: 'queries'!categoryListForInstance: targetObject ofClass: aClass limitClass: mostGenericClass 	"Answer the category list for the given instance (may be nil) of the 	given class, considering only code implemented in mostGenericClass and 	lower "	| classToUse foundAMethod classThatImplements |	classToUse _ targetObject				ifNil: [aClass]				ifNotNil: [targetObject class].	^ categories		select: [:aCategory | 			foundAMethod _ false.			aCategory elementsInOrder				do: [:aSpec | 					classThatImplements _ classToUse whichClassIncludesSelector: aSpec selector.					(classThatImplements notNil							and: [classThatImplements includesBehavior: mostGenericClass])						ifTrue: [foundAMethod _ true]].			foundAMethod]		thenCollect: [:aCategory | aCategory categoryName]! !!FullVocabulary methodsFor: 'queries'!categoriesContaining: aSelector forClass: aTargetClass 	"Answer a list of category names (all symbols) of categories that contain 	the given selector for the target object. Initially, this just returns one."	| classDefiningSelector catName |	classDefiningSelector _ aTargetClass whichClassIncludesSelector: aSelector.	classDefiningSelector		ifNil: [^ OrderedCollection new].	catName _ classDefiningSelector whichCategoryIncludesSelector: aSelector.	^ OrderedCollection with: catName! !!FullVocabulary methodsFor: 'queries'!categoryWithNameIn: categoryNames thatIncludesSelector: aSelector forInstance: targetInstance ofClass: targetClass 	"Answer the name of a category, from among the provided 	categoryNames, which defines the selector for the given class. Here, if 	the category designated by the implementing class is acceptable it is the 	one returned"	| aClass catName result |	(aClass _ targetClass whichClassIncludesSelector: aSelector)		ifNotNil: [(categoryNames includes: (catName _ aClass whichCategoryIncludesSelector: aSelector))				ifTrue: [catName ~~ #'as yet unclassified'						ifTrue: [^ catName]]].	result _ super				categoryWithNameIn: categoryNames				thatIncludesSelector: aSelector				forInstance: targetInstance				ofClass: aClass.	^ result		ifNil: [#'as yet unclassified']! !