'From Squeak3.1alpha of 5 February 2001 [latest update: #3823] on 9 March 2001 at 8:17:27 am'!"Change Set:		softerFailuresDate:			9 March 2001Author:			Bob Arningsmoothing out some of the bumps in the road of resource loading:- use an exception when FTP errors occur to avoid posting OK/Debug choice to naive user.- skip writing to Transcript since this may be running in the background"!Error subclass: #FTPConnectionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!Object methodsFor: 'logging' stamp: 'RAA 3/9/2001 08:13'!flag: aFlagString log: aString	"since this is now being called from other processes by project resource loading, we need something a bit more thread-safe"	"Transcript show: aString; cr"	! !!FTPConnectionException methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 07:47'!defaultAction	self resume! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 19:12'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."	| resp what all |	(readAhead ~~ nil and: [readAhead size > 0])		ifTrue: [resp _ readAhead removeFirst]  "response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.       "150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	resp size > 0 		ifTrue: [			resp first isDigit ifFalse: [ ^self lookFor: beginning ].				"we're in the middle of a line, not the end." #XXX. "this should be fixed..."			(resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"			(resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"			]		ifFalse: [resp _ '[timeout]'].	what _ self sayWhat:  resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 19:12'!lookSoftlyFor: beginning        "Get the response from the server.  Return true the string in beginning is at the front of what came back.  Don't kill the socket if we fail.  Users wants to try another password."	| resp what all |	(readAhead ~~ nil and: [readAhead size > 0])		ifTrue: [resp _ readAhead removeFirst]  "response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.       "150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	resp size > 0 		ifTrue: [			resp first isDigit ifFalse: [ ^self lookFor: beginning ].				"we're in the middle of a line, not the end." #XXX. "this should be fixed..."			(resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"			(resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"			]		ifFalse: [resp _ '[timeout]'].	what _ self sayWhat:  resp.	what = 2 ifTrue: [self halt].	^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 19:12'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ self sayWhat:  resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 08:10'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx,success.  If 3xx, intermediate point successful.  4xx, transient error.5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Returntrue if OK, the error string if not."	| resp what all |	readAhead isNil ifTrue: [readAhead _ ''].	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	"Transcript show: resp; cr."	resp size > 0		ifTrue: [((resp at: 1) == $5) | ((resp at: 1) == $4) ifFalse: [^ true]]  "All is well"		ifFalse: [resp _ '[timeout]'].	what _ self sayWhat: resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 07:48'!sayWhat: resp		FTPConnectionException signal: resp.	^(PopUpMenu labels: 'OK\ debug ' withCRs)		startUpWithCaption: 'Server reported this error:\' withCRs,resp.! !!HTTPLoader methodsFor: 'private' stamp: 'RAA 3/9/2001 08:04'!startDownload	| newDownloadProcess |		downloads size >= self maxNrOfConnections ifTrue: [^self].	requests size <= 0 ifTrue: [^self].	newDownloadProcess _ [		self flag: #httpLoader log: 'Starting download'.		[			self nextRequest startRetrieval		] on: FTPConnectionException do: [ :ex | 			Cursor normal show.			self removeProcess: Processor activeProcess.			self startDownload		].		self flag: #httpLoader log: 'Download done'.		self removeProcess: Processor activeProcess.		self startDownload	] newProcess.	downloads add: newDownloadProcess.	newDownloadProcess resume! !