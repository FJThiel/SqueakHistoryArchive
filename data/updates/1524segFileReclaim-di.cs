'From Squeak 2.5 of August 6, 1999 [latest update: #1506] on 29 September 1999 at 4:51 pm'!"Change Set:		segFileReclaimDate:			29 September 1999Author:			Dan IngallsDeletes all segment files that are no longer in use immediately following any save operation."!!ImageSegment methodsFor: 'read/write segment' stamp: 'di 9/29/1999 16:24'!segmentName	"Return the local file name for this segment."	^ FileDirectory localNameFor: fileName! !!ImageSegment methodsFor: 'testing' stamp: 'di 9/29/1999 16:50'!isOnFile	^ state == #onFile! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'di 9/29/1999 16:51'!reclaimObsoleteSegmentFiles  "ImageSegment reclaimObsoleteSegmentFiles"	"Delete segment files that can't be used after this image is saved.	Note that this is never necessary -- it just saves file space."	| segDir segFiles |	segDir _ self segmentDirectory.	segFiles _ (segDir fileNames select: [:fn | fn endsWith: '.seg']) asSet.	ImageSegment allInstancesDo:		[:is | is isOnFile ifTrue:			[segFiles remove: is segmentName ifAbsent: [self error: 'Can''t find file']]].	segFiles do: [:fn | segDir deleteFileNamed: fn]! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'di 9/29/1999 15:45'!segmentDirectory	"Return a directory object for the folder of segments.	Create such a folder if none exists."	| dir folderName |	dir _ FileDirectory default.	folderName _ dir class localNameFor: self folder. "imageName_segs"	(dir includesKey: folderName) ifFalse:		[dir createDirectory: folderName].	"create the folder if necess"	^ dir directoryNamed: folderName! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'di 9/29/1999 15:44'!uniqueFileNameFor: segName	"Choose a unique file name for the segment with this name."	| segDir fileName listOfFiles |	segDir _ self segmentDirectory.	listOfFiles _ segDir fileNames.	BiggestFileNumber ifNil: [BiggestFileNumber _ 1].	BiggestFileNumber > 99 ifTrue: [BiggestFileNumber _ 1].	"wrap"	[fileName _ segName, BiggestFileNumber printString, '.seg'.	 (listOfFiles includes: fileName)] whileTrue: [		BiggestFileNumber _ BiggestFileNumber + 1].	"force a unique file name"	^ segDir pathName, FileDirectory slash, fileName! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 9/29/1999 16:41'!snapshot: save andQuit: quit	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString.		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		self assureStartupStampLogged.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList.	Cursor write show.	save ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"		ifFalse: [resuming _ false].	resuming		ifFalse: [ImageSegment reclaimObsoleteSegmentFiles.				quit ifTrue: [self quitPrimitive]].	Cursor normal show.	self setGCParameters.	resuming ifTrue: [self clearExternalObjects].	self processStartUpList.	resuming ifTrue: [self readDocumentFile].	^resuming! !