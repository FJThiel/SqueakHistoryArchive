'From Squeak 2.3 of January 14, 1999 on 16 February 1999 at 7:14:30 pm'!"Change Set:		B3D-3DS-ParserDate:			16 February 1999Author:			Andreas RaabThis change set contains a parser for Autodesk 3D Studio files.It is derived from work done by Bert Freudenberg - thanks forallowing us to include it in Squeak.Note: The 3DS parser does NOT read files created for 3D-Studio MAX (e.g., MAX-files)."!Object subclass: #ThreeDSChunkDescription	instanceVariableNames: 'id name comment '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Import'!Object subclass: #ThreeDSParser	instanceVariableNames: 'source chunkPos chunkID chunkLen indent log informer classSpec '	classVariableNames: 'ChunkDescriptions DefaultSpec '	poolDictionaries: ''	category: 'Balloon-3D-Import'!!FileList methodsFor: 'file list menu' stamp: 'ar 2/6/1999 01:24'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = 'sp') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'bo') | (suffix = '*') ifTrue:[		labels add: 'load as book'.		selectors add: #openBookFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels add: 'view decompressed'.		selectors add: #viewGZipContents].	(suffix = '3ds') | (suffix = '*') ifTrue:[		labels add: 'Open 3DS file'.		selectors add: #open3DSFile].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'ar 2/12/1999 17:52'!open3DSFile	"Open a MoviePlayerMorph on the given file (must be in .movie format)."	(ThreeDSParser parseFileNamed: self fullName) inspect! !!ThreeDSChunkDescription commentStamp: '<historical>' prior: 0!This is a Class supporting debugging the ThreeDSParser. It's not needed for the actual parsing process. Instances are automatically created from the chunk documentation for each chunk (see ThreeDSParser class  'utilities' protocol) and stored in the Dictionary ChunkDescriptions. They act as Associations by itself.Instance Variables:	id			<Integer>  the chunk id	name		<String>  an identifier	comment	<String>  a comment, if available	The printOn: method is sensitive to the Shift key -- only if pressed, the comment is shown.!!ThreeDSChunkDescription methodsFor: 'accessing'!comment	^comment! !!ThreeDSChunkDescription methodsFor: 'accessing'!id	^id! !!ThreeDSChunkDescription methodsFor: 'accessing'!name	^name! !!ThreeDSChunkDescription methodsFor: 'comparing'!= aChunk	^id = aChunk id! !!ThreeDSChunkDescription methodsFor: 'comparing'!hash	^id hash! !!ThreeDSChunkDescription methodsFor: 'private'!removeSeparators: aString	"Remove leading and trailing separators"	| start end |	start := 1.	end := aString size.	[start <= end and: [(aString at: start) isSeparator]] whileTrue: [start := start + 1].	[start < end and: [(aString at: end) isSeparator]] whileTrue: [end := end - 1].	(start = 1 and: [end = aString size]) ifTrue: [^aString].	start = end ifTrue: [^''].	^aString copyFrom: start to: end! !!ThreeDSChunkDescription methodsFor: 'private'!setId: anID name: aName comment: aComment	"Initialize receiver"	id := anID.	name := aName.	comment := self removeSeparators: aComment.! !!ThreeDSChunkDescription methodsFor: 'association'!key	^id! !!ThreeDSChunkDescription methodsFor: 'association'!value	^self! !!ThreeDSChunkDescription methodsFor: 'printing' stamp: 'ar 2/6/1999 01:18'!printOn: aStream	aStream nextPutAll: 'Chunk('.	id printOn: aStream base: 16 digitsToPad: 4 highDigit: 4.	aStream 		nextPut: $h;		space;		nextPutAll: name.	Sensor commandKeyPressed ifTrue: [		aStream space; nextPut: $<; nextPutAll: comment; nextPut: $>].	aStream nextPut: $)! !!ThreeDSChunkDescription class methodsFor: 'instance creation'!id: anID name: aName comment: aComment	^self new setId: anID name: aName comment: aComment! !!ThreeDSParser commentStamp: 'ar 2/15/1999 05:18' prior: 0!(c) 1996-97 Bert Freudenberg, neé Schönwälder, (bert@isg.cs.uni-magdeburg.de) University of Magdeburg, Germany.Modified 1998 by Andreas Raab (Andreas.Raab@disney.com) for Squeak.Class ThreeDSParser reads a 3DS File (AutoDesk 3D Studio's native format). It isn't a real parser at all, I chose this name for consistency with the other scene parser classes. For description of 3DS format I used "The Unofficial 3DStudio 3DS File Format v1.0" by Jeff Lewis and the "3ds_bin" by Jim Pitts et. al., see #chunkDocumentation on the Class side.Instance Variables:	source		<Stream>	binary stream on source file	chunkPos	<Integer>	File position of current chunk	chunkID	<Integer>	ID of current cunk	chunkLen	<Integer>	Length of current chunk	indent		<Integer | nil>	If nil, no log is written. Otherwise the current nesting level.	informer	<Block>		A block taking the progress value while reading	classSpec	<Dictionary | nil> Specification of the classes to construct.Class Variables:	ChunkDescriptions	<Dictionary of: ThreeDSChunkDescription>		For debugging only. ChunkDescriptions generated from the documentation	DefaultSpec	<Dictionary | nil>		The default class specification to use.!!ThreeDSParser reorganize!('initialize-release' classSpec: parse: parse:using: parseFileNamed: parseFileNamed:using: parseStream:)('accessing' informer informer:)('reading' scene)('reading-mesh' camera light meshData namedObject smoothList spot triList triMesh vertexList)('reading-material' materialColor materialEntry textureMap textureVertices verticalGradient)('reading-keyframe' keyframeData keyframeHeader node nodeHeader trackCString trackCollect: trackColor trackFlag trackFloat trackRotation trackVector)('reading-primitives' cString color24 colorFloat container flag float long matrix percentageChunk short twoFloats twoLongs twoShorts twoVector3 uLong uShort vector3)('executing' indexed:do:do: indexed:do:do:do: indexed:doBlocks:)('dispatching' recognize: recognize:as: recognize:do: recognize:do:inChunksUpTo:)('private' chunkHeader logUnreadBytes: printChunkInfo)('private-dispatching' dispatchID:in: findID:in: getSelectorFor:in: makeResult:for:in:)('private-util' chunkDescriptionFor:)('construction classes' cameraClass materialClass meshObjectClass pointLightClass sceneClass specAt: specAt:ifAbsent: splineVertexClass spotLightClass textureArrayClass vertexArrayClass)!!ThreeDSParser methodsFor: 'initialize-release' stamp: 'ar 2/6/1999 20:34'!classSpec: aDictionary	classSpec _ aDictionary! !!ThreeDSParser methodsFor: 'initialize-release' stamp: 'ar 2/6/1999 01:21'!parse: aStream	"Read the 3DS file from the given stream"	| s |	'Reading 3DS file' displayProgressAt: Sensor cursorPoint		from: 0 to: aStream size during:[:bar|			self informer: bar.			s _ self parseStream: aStream.	].	^s! !!ThreeDSParser methodsFor: 'initialize-release' stamp: 'ar 2/15/1999 05:16'!parse: aStream using: spec	"Read the 3DS file from the given stream"	self classSpec: spec.	^self parse: aStream! !!ThreeDSParser methodsFor: 'initialize-release' stamp: 'ar 2/6/1999 01:28'!parseFileNamed: aString	"Read the 3DS file from the given stream"	| s f |	f _ FileStream readOnlyFileNamed: aString.	f binary.	'Reading 3DS file ', aString  displayProgressAt: Sensor cursorPoint		from: 0 to: f size during:[:bar|			self informer: bar.			s _ self parseStream: f.		].	f close.	^s! !!ThreeDSParser methodsFor: 'initialize-release' stamp: 'ar 2/6/1999 20:50'!parseFileNamed: aString using: spec	"Read the 3DS file from the given stream"	self classSpec: spec.	^self parseFileNamed: aString! !!ThreeDSParser methodsFor: 'initialize-release' stamp: 'ar 2/15/1999 05:30'!parseStream: aStream	"Read the 3DS file from the given stream"	| sceneSpec |	source := aStream.	source binary.	indent := 0.	log := Sensor leftShiftDown ifTrue: [		Sensor controlKeyPressed			ifTrue: [FileStream fileNamed: (FillInTheBlank request: 'Parser log file:' initialAnswer: 'parser.log')]			ifFalse: [Transcript]].	log == Transcript ifTrue: [log clear].	sceneSpec := self scene.	log == nil ifFalse: [log == Transcript ifTrue: [log flush] ifFalse: [log close]].	^self sceneClass from3DS: sceneSpec! !!ThreeDSParser methodsFor: 'accessing' stamp: 'ar 2/6/1999 01:22'!informer	^informer! !!ThreeDSParser methodsFor: 'accessing' stamp: 'ar 2/6/1999 01:22'!informer: anObject	informer _ anObject! !!ThreeDSParser methodsFor: 'reading' stamp: 'ar 2/6/1999 20:53'!scene	"Whole file"	| renderObjects |	self chunkHeader.	chunkID == 16r3D3D ifTrue: [^self meshData].	chunkID == 16r4D4D ifFalse: [^nil].	self recognize: #(		(16r3D3D meshData 1)		(16rB000 keyframeData 2)		) do: [:item | self indexed: item			do: [:data | renderObjects := data]			do: [:data | (renderObjects at: #globals) at: #keyframes put: data]].	^renderObjects! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 19:55'!camera	"Subchunk of namedObject"	| cameraSpec |	cameraSpec _ Dictionary new.	cameraSpec at: #position put: self vector3.	cameraSpec at: #target put: self vector3.	cameraSpec at: #roll put: self float.	cameraSpec at: #focal put: self float.	"May be followed by near/far range"	self recognize: #((16r4720 twoFloats)) do: [:item | 		cameraSpec at: #near put: item first.		cameraSpec at: #far put: item second].	^self cameraClass from3DS: cameraSpec! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 20:02'!light	"Subchunk of namedObject"	| pos lightSpec |	pos := self vector3.	lightSpec := self recognize: #(		(16r0010 colorFloat color)		"Color of light source"		(16r0011 color24 color)		"Color of light source"		(16r4610 spot ->)				"Spot light specs, see #spot"		(16r4620 flag off)			"Light off flag (default on)"		(16r4659 float innerRange)	"Attenuation min range"		(16r465A float outerRange)	"Attenuation max range"		(16r465B float multiplier))	"Intensity multiplier (default 1.0)"		as: Dictionary.	lightSpec at: #position put: pos.	^(lightSpec includesKey: #spot )		ifTrue: [self spotLightClass from3DS: lightSpec]		ifFalse:[self pointLightClass from3DS: lightSpec]! !!ThreeDSParser methodsFor: 'reading-mesh'!meshData	"Subchunk of scene"	| renderObjects globals |	globals := Dictionary 				with: (#constants -> Dictionary new) 				with: (#cameras -> Dictionary new) 				with: (#lights -> Dictionary new)				with: (#materials -> Dictionary new).	renderObjects := Dictionary with: (#globals -> globals).					self recognize: #(		(16r4000 namedObject)		(16r2100 materialColor ambientColor)		(16r1100 cString bgBitmap)		(16rAFFF materialEntry ->)		(16r1200 materialColor backgroundColor)		(16r1300 verticalGradient ->)		) do: [:item | 			item key == #verticalGradient				ifTrue:[globals add: item].			item key == #materialEntry				ifTrue:[(globals at: #materials) add: item value].			item key == #backgroundColor				ifTrue: [(globals at: #constants) at: item key asString put: item value].			item key == #ambientColor				ifTrue: [(globals at: #constants) at: item key asString put: item value] ifFalse:[			item key == #bgBitmap				ifTrue: [(globals at: #constants) at: item key asString put: item value] ifFalse:[			item key == #triMesh 				ifTrue: [renderObjects add: item value] ifFalse: [			item key == #light 				ifTrue: [(globals at: #lights) add: item value] ifFalse: [			item key == #camera 				ifTrue: [(globals at: #cameras) add: item value]]]]]].	^renderObjects! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 01:14'!namedObject	"Subchunk of meshData"	"Contains triMesh, light, or camera. Answer association"	| name |	name := self cString.	self recognize: #(		(16r4100 triMesh ->)		(16r4600 light ->)		(16r4700 camera ->))		do: [:item | ^item key -> (name -> item value)].	^nil! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 21:46'!smoothList	"Optional subchunk of faceList"	| count smooth |	count := chunkLen - 6 // 4.	smooth := Array new: count.	1 to: count do: [:i | smooth at: i put: self uLong].	^smooth! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 01:00'!spot	"Subchunk of light"	| spot result |	spot := Dictionary new.	spot 		at: #target put: self vector3;		at: #hotspotAngle put: self float;		at: #falloffAngle put: self float.	result := self recognize: #(		(16r4651 flag rectangular)		(16r4652 flag overshoot)		(16r4653 flag projector)) as: Dictionary.	spot at: #rectangular put:(result at: #rectangular ifAbsent: [false]).	spot at: #overshoot put: (result at: #overshoot ifAbsent: [false]).	spot at: #projector put: (result at: #projector ifAbsent: [false]).	^spot! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 01:03'!triList	"Subchunk of triMesh"	| count triList triangle vertices flags smoothList matGroup |	count := self uShort.	triList := Array new: count.	1 to: count do: [ :i |		vertices := #(A B C) collect: [:j | self uShort + 1].		flags := self uShort bitAnd: 7.		triangle := vertices -> flags.		triList at: i put: triangle].	"May be followed by smoothlist"	self recognize: #(		(16r4150 smoothList ->) 		(16r4130 cString materialGroup))	do:[:item|		#smoothList == item key			ifTrue:[smoothList := item value].		#materialGroup == item key			ifTrue:[matGroup := item value].	].	^Array with: triList with: smoothList with: matGroup.! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 20:13'!triMesh	"Subchunk of namedObject"	| objSpec |	"Read vertex coordinates and indexed triangles"	objSpec _ self recognize: #(		(16r4110 vertexList ->)		"List of vertices"		(16r4140 textureVertices ->)	"List of texture coords (per vertex)"		(16r4160 matrix ->)			"Transformation of mesh object"		(16r4120 triList ->)) 			"Triangle information (see #triList)"			as: Dictionary.	^self meshObjectClass from3DS: objSpec! !!ThreeDSParser methodsFor: 'reading-mesh' stamp: 'ar 2/6/1999 22:56'!vertexList	"Subchunk of triMesh"	| count vertices |	count := self uShort.	vertices := self vertexArrayClass new: count.	1 to: count do: [:i |		vertices at: i put: self vector3].	^vertices! !!ThreeDSParser methodsFor: 'reading-material'!materialColor	^self recognize: #(		(16r0010 colorFloat)		(16r0011 color24))! !!ThreeDSParser methodsFor: 'reading-material' stamp: 'ar 2/6/1999 20:25'!materialEntry	"Globally defined materials"	| name materialSpec |	name := 'unknown'.	materialSpec := Dictionary new.	self recognize: #(		(16rA000 cString name)		(16rA010 materialColor ambient)		(16rA020 materialColor diffuse)		(16rA030 materialColor specular)		(16rA200 textureMap texture)		(16rA040 percentageChunk shininessHighlight)		(16rA041 percentageChunk shininessColorScale)		) do: [:item | 			item key == #name ifTrue:[				log == nil ifFalse: [log crtab: indent+1; print: item value].				name := item value.			] ifFalse:[				item key == #texture ifTrue:[materialSpec addAll: item value]				ifFalse:[materialSpec at: item key put: item value]]].	materialSpec at: #name put: name.	^name -> (self materialClass from3DS: materialSpec)! !!ThreeDSParser methodsFor: 'reading-material'!textureMap	| name percent |	name := nil.	percent := 1.0.	self recognize:#(		(16rA300 cString texName)		(16r0030 short texPercent)		(16r0031 float texPercent))	do:[:item|		item key == #texName ifTrue:[name := item value].		item key == #texPercent ifTrue:[percent := item value / 100.0]].	^Array 	with:(#textureName -> name)			with: (#texturePercentage -> percent).! !!ThreeDSParser methodsFor: 'reading-material' stamp: 'ar 2/6/1999 23:29'!textureVertices	"Subchunk of tri object"	| nVerts texCoords u v |	nVerts := self uShort.	texCoords := self textureArrayClass new: nVerts.	1 to: nVerts do:[:i|		u := self float.		v := self float.		texCoords at: i put: (u@v).	].	^texCoords.! !!ThreeDSParser methodsFor: 'reading-material'!verticalGradient	| midPt start mid stop|	midPt := self float.	self recognize:#( (16r0010 colorFloat) )		do:[:color|			start isNil ifTrue:[start := color] ifFalse:[			mid isNil ifTrue:[mid := color] ifFalse:[			stop isNil ifTrue:[stop := color]]]].	^Array with: start with: mid with: stop! !!ThreeDSParser methodsFor: 'reading-keyframe'!keyframeData	"Subchunk of scene"		| data info|	data := Dictionary new.	data at: #info put: (info := Dictionary new).	self recognize: #(		(16rB00A keyframeHeader header)		(16rB008 twoLongs segments)		(16rB009 long current)		(16rB001 node ambientLight)		(16rB002 node objects)		(16rB003 node cameras)		(16rB004 node targets)		(16rB005 node lights)		(16rB006 node lightTargets)		(16rB007 node spotlights)		)		do: [:item |			#header == item key ifTrue: [				info addAll: item value] ifFalse: [			#segments == item key ifTrue: [				info add: item.				log == nil ifFalse: [log crtab: indent+1; print: item value]] ifFalse: [			#current == item key ifTrue: [				info add: item.				log == nil ifFalse: [log crtab: indent+1; print: item value]] ifFalse: [			(data at: item key ifAbsentPut: [Dictionary new]) 				add: item value]]]].	^data! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 01:15'!keyframeHeader	"Subchunk of keyframeData"		| name len revision |	revision := self short.	name := self cString.	len := self long.	log == nil ifFalse: [log crtab: indent; 		nextPutAll: 'File: '; print: name; nextPutAll: ' frames: '; print: len; nextPutAll: ' revision: '; print: revision].	^Array 		with: (#frames->len)		with: (#file->name)! !!ThreeDSParser methodsFor: 'reading-keyframe'!node	"Subchunk of keyframeData"		| nodeData |	nodeData := Dictionary new.	self recognize: #(		(16rB030 short id)		(16rB010 nodeHeader header)		(16rB011 cString instanceName)		(16rB013 vector3 pivot)		(16rB014 twoVector3 boundingBox)		(16rB015 float smoothAngle)		(16rB020 trackVector positionTrack)		(16rB021 trackRotation rotationTrack)		(16rB022 trackVector scaleTrack)		(16rB023 trackFloat fovTrack)		(16rB024 trackFloat rollTrack)		(16rB025 trackColor colorTrack)		(16rB026 trackCString morphTrack)		(16rB027 trackFloat hotspotTrack)		(16rB028 trackFloat falloffTrack)		(16rB029 trackFlag hideTrack)		) do: [:item |			item key == #header 				ifTrue: [nodeData addAll: item value]				ifFalse: [nodeData add: item].			log == nil ifFalse: [(#(id pivot boundingBox instanceName) includes: item key) ifTrue: [				log crtab: indent+1; print: item value]]].	^(nodeData at: #id ifAbsent:[^nil]) -> nodeData! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 01:00'!nodeHeader	"Subchunk of node"	| name hierarchy unknown isHidden |	name := self cString.	unknown := (1 to: 4) collect: [:i | source next].	hierarchy := self short.	isHidden := (unknown at: 2) anyMask: 8.	log ==nil ifFalse: [log crtab: indent; 		nextPutAll: 'Name: '; print: name; nextPutAll: ' Hierarchy: '; print: hierarchy; 		nextPutAll: ' Unknown: '; print: unknown.		(isHidden) ifTrue:[log nextPutAll:' hidden'.]].	^Array with: (#name->name)		with: (#hierarchy->hierarchy)		with:(#hidden -> isHidden)! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 18:18'!trackCString	"Read keyframes defining a string (morph)"		| string |	^self trackCollect: [:params|		"@@: Still to do ..."		"params == nil ifFalse:[self halt]."		string := self cString.		log == nil ifFalse: [log print: string].		string].! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 18:18'!trackCollect: aBlock	"Read keyframes, return Array with values of aBlock "		| flags keys frame unknown1 paramFlags params paramMask param |	"Track header"	flags := self short.	unknown1 := (1 to: 2) collect: [:i | self long].	keys := self long.	"Log"	log == nil ifFalse: [log crtab: indent; nextPutAll: 'Flags: '; print: flags; 		nextPutAll: ' {',(flags printStringRadix:16), 'h}';		nextPutAll: ' Unknown: '; print: unknown1].	"Keys"	^(1 to: keys) collect: [:i |		params := nil.		"Key header"		frame := self long.		paramFlags := self short.		"Log"		log == nil ifFalse: [log crtab: indent; print: frame; nextPutAll: ':	['; print: paramFlags; nextPutAll: ']	'].		"Params, if not default"		paramFlags = 0 ifFalse: [			params := Dictionary new.			paramMask := 1.			#(tension: continuity: bias: easeTo: easeFrom:) with: 			#(true true true false false) do: [:what :symmetric |				param := (paramFlags bitAnd: paramMask) ~= 0					ifTrue: [self float]					ifFalse: [0.0].				log == nil ifFalse: [log crtab: indent+1; print: param; space; nextPutAll: what; space;					print: (symmetric ifTrue: [25 * (1 + param)] ifFalse: [param * 50]) rounded].				params at: what put: param.				paramMask := paramMask bitShift: 1].			log == nil ifFalse: [log crtab: indent+1]].		log == nil ifFalse: [log nextPutAll: 'Data: '].		"Data"		frame -> (aBlock value: params)]! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 18:18'!trackColor	"Read keyframes interpolating a color"		| color |	^self trackCollect: [:params|		"@@: Still to do ..."		"params == nil ifFalse:[self halt]."		color := self colorFloat.		log == nil ifFalse: [log print: color].		color].! !!ThreeDSParser methodsFor: 'reading-keyframe'!trackFlag	"Read keyframes for a flag (hide)"		| flag |	flag := false.	^self trackCollect: [:params|		"@@: Still to do ..."		"params == nil ifFalse:[self halt]."		flag := flag not.		log == nil ifFalse: [log print: flag].		flag].! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 18:18'!trackFloat	"Read keyframes interpolating a float (hotspot, falloff, roll, etc.)"		| float |	^self trackCollect: [:params|		"@@: Still to do ..."		"params == nil ifFalse:[self halt]."		float := self float.		log == nil ifFalse: [log print: float].		float].! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 18:19'!trackRotation	"Read keyframes interpolating a rotation"		| angle axis |	^self trackCollect: [:params|		"@@: Still to do ..."		"params == nil ifFalse:[self halt]."		angle := self float.		axis := self vector3.		log == nil ifFalse: [log print: axis; space; print: angle radiansToDegrees].		B3DRotation radiansAngle: angle negated axis: axis].! !!ThreeDSParser methodsFor: 'reading-keyframe' stamp: 'ar 2/6/1999 20:59'!trackVector	"Read keyframes interpolating a vector (position, scale)"	| vector spec splClass |	^self trackCollect: [:params|		params ifNil:[spec _ Dictionary new] ifNotNil:[spec _ params].		vector := self vector3.		spec at: #position put: vector.		log == nil ifFalse: [log print: vector].		splClass _ self splineVertexClass.		splClass			ifNil:[vector]			ifNotNil:[splClass from3DS: spec]].! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:53'!cString	"Generic Subchunk containing a cstring"	| s c |	s := WriteStream on: (String new: 128).	[(c := source next) ~= 0] whileTrue: 		[s nextPut: c asCharacter].	^s contents! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 19:51'!color24	"Color from 3 bytes"	| red green blue |	red := source next.	green := source next.	blue := source next.	^Color		r: red / 255.0 		g: green / 255.0		b: blue / 255.0! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 19:51'!colorFloat	"Color from 3 floats"	| red green blue |	red := self float.	green := self float.	blue := self float.	^Color r: red g: green b: blue! !!ThreeDSParser methodsFor: 'reading-primitives'!container	"Generic container chunk"		self recognize: #()! !!ThreeDSParser methodsFor: 'reading-primitives'!flag	"Generic Subchunk -- if found, answer true"	^true! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:55'!float	"Generic Subchunk containing a float"	| fltArray |	fltArray _ FloatArray new: 1.	fltArray basicAt: 1 put: self uLong.	^fltArray at: 1.! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:55'!long	"Generic Subchunk containing a long"	^(source next: 4) longAt: 1 bigEndian: false.! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 02:08'!matrix	"float matrix[4][3]"		| m |	m := B3DMatrix4x4 identity.	1 to: 4 do: [:column |		1 to: 3 do: [:row |			m basicAt: row-1*4+column put: self uLong.			"m row: row column: column put: source readFloat"]].	^m! !!ThreeDSParser methodsFor: 'reading-primitives'!percentageChunk	^(self recognize: #((16r0030 short) (16r0031 float))) / 100.0.! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:57'!short	"Generic Subchunk containing a short"	^(source next: 2) shortAt: 1 bigEndian: false! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:57'!twoFloats	"Generic Subchunk containing two floats"	^Array with: self float with: self float! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:58'!twoLongs	"Generic Subchunk containing two longs"	^Array with: self long with: self long! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:58'!twoShorts	"Generic Subchunk containing two shorts"	^Array with: self short with: self short! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:58'!twoVector3	"Generic Subchunk containing two points"	^Array with: self vector3 with: self vector3! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:56'!uLong	"Generic Subchunk containing a long"	^(source next: 4) unsignedLongAt: 1 bigEndian: false.! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:57'!uShort	"Generic Subchunk containing a short"	^(source next: 2) unsignedShortAt: 1 bigEndian: false! !!ThreeDSParser methodsFor: 'reading-primitives' stamp: 'ar 2/6/1999 00:59'!vector3	"Generic Subchunk containing a vector"	| x y z |	x _ self float.	y _ self float.	z _ self float.	^B3DVector3 x: x y: y z: z! !!ThreeDSParser methodsFor: 'executing'!indexed: item do: firstBlock do: secondBlock 	"According to item's key evaluate one of the blocks with item's value"	self indexed: item doBlocks: (Array with: firstBlock with: secondBlock)! !!ThreeDSParser methodsFor: 'executing'!indexed: item do: firstBlock do: secondBlock do: thirdBlock	"According to item's key evaluate one of the blocks with item's value"	self indexed: item doBlocks: 		(Array with: firstBlock with: secondBlock with: thirdBlock)! !!ThreeDSParser methodsFor: 'executing'!indexed: item doBlocks: blocks	"According to item's key evaluate one of the blocks with item's value"	(blocks at: item key) value: item value! !!ThreeDSParser methodsFor: 'dispatching'!recognize: dispatcherArray	"Answer first item found"	| first |	first := nil.	self recognize: dispatcherArray do: [:item |		first == nil ifTrue: [first := item]].	^first! !!ThreeDSParser methodsFor: 'dispatching'!recognize: dispatcherArray as: resultCollectionClass 	"Collect all items in a new resultCollectionClass"	| resultCollection |	resultCollection := resultCollectionClass new.	self recognize: dispatcherArray do: [:item | resultCollection add: item].	^resultCollection! !!ThreeDSParser methodsFor: 'dispatching'!recognize: dispatcherArray do: aBlock	"Provide default end position"	self recognize: dispatcherArray do: aBlock inChunksUpTo: chunkPos + chunkLen! !!ThreeDSParser methodsFor: 'dispatching'!recognize: dispatcherArray do: aBlock inChunksUpTo: endPos	"Scan chunks up to endPos, process those mentioned in dispatcherArray"	| nextChunkPos item |	nextChunkPos := source position.	[nextChunkPos < endPos] whileTrue: [		"Read header"		self chunkHeader.		nextChunkPos := chunkPos + chunkLen.		"Dispatch"		(item := self dispatchID: chunkID in: dispatcherArray) notNil			ifTrue: [aBlock value: item].		"Skip to next chunk"		source position = nextChunkPos ifFalse: [			self logUnreadBytes: nextChunkPos.			source position: nextChunkPos]].! !!ThreeDSParser methodsFor: 'private' stamp: 'ar 2/6/1999 01:16'!chunkHeader	"Read header of a chunk, store in instance variables"	chunkPos := source position.	chunkID := self uShort.	chunkLen := self long.	self informer value: chunkPos.	self printChunkInfo! !!ThreeDSParser methodsFor: 'private' stamp: 'ar 2/6/1999 18:18'!logUnreadBytes: nextChunkPos	| pos |	log isNil ifFalse: [		pos := source position.		pos = (chunkPos + 6)			ifFalse: [log crtab: indent + 1; print: nextChunkPos - pos;				nextPutAll: ' Byte'].		log nextPutAll: ' unread 		***']! !!ThreeDSParser methodsFor: 'private'!printChunkInfo	log == nil ifFalse: [		log	crtab: indent; 			print: (self chunkDescriptionFor: chunkID);			space;			print: (chunkLen - 6);			nextPutAll: ' Byte'.		log == Transcript ifTrue: [log flush].	].! !!ThreeDSParser methodsFor: 'private-dispatching'!dispatchID: id in: dispatcher	"Look for id in dispatcher, and process it, if found"	| index sel result |	(index := self findID: id in: dispatcher) isNil ifTrue: [^nil].	sel := self getSelectorFor: index in: dispatcher.	indent := indent + 1.	result := self perform: sel. 	indent := indent - 1.	result == nil ifTrue: [^nil].	^self makeResult: result for: index in: dispatcher.! !!ThreeDSParser methodsFor: 'private-dispatching'!findID: id in: dispatcher	"Return index of id in dispatcher, nil if not found"	1 to: dispatcher size do: [:i |		((dispatcher at: i) at: 1) = id ifTrue: [^i]].	^nil! !!ThreeDSParser methodsFor: 'private-dispatching'!getSelectorFor: index in: dispatcher	"Return method selector"	^(dispatcher at: index) at: 2! !!ThreeDSParser methodsFor: 'private-dispatching'!makeResult: result for: index in: dispatcher	"Answer Association if needed"	| disp sym |	disp := dispatcher at: index.	disp size < 3 		"return result itself"		ifTrue: [^result].	sym := disp at: 3.	sym = #->		"return selector -> result"		 ifTrue: [^(disp at: 2) -> result].	"return symbol -> result"	^sym -> result! !!ThreeDSParser methodsFor: 'private-util'!chunkDescriptionFor: id	"Answer chunk description for id"		^self class chunkDescriptionFor: id! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:31'!cameraClass	^self specAt: #camera! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:31'!materialClass	^self specAt: #material! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:31'!meshObjectClass	^self specAt: #meshObject! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:31'!pointLightClass	^self specAt: #pointLight! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:32'!sceneClass	^self specAt: #scene! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:33'!specAt: aSymbol	^self specAt: aSymbol ifAbsent:[nil]! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:36'!specAt: aSymbol ifAbsent: aBlock	| classSymbol |	classSpec ifNil:[^aBlock value].	classSymbol _ classSpec at: aSymbol ifAbsent:[^aBlock value].	classSymbol ifNil:[^aBlock value].	^Smalltalk at: classSymbol ifAbsent: aBlock	! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:59'!splineVertexClass	^self specAt: #splineVertex! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:32'!spotLightClass	^self specAt: #spotLight! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:33'!textureArrayClass	^self specAt: #textureArray ifAbsent:[Array]! !!ThreeDSParser methodsFor: 'construction classes' stamp: 'ar 2/6/1999 20:33'!vertexArrayClass	^self specAt: #vertexArray ifAbsent:[Array]! !!ThreeDSParser class methodsFor: 'utilities'!chunkDescriptionFor: id	"Answer chunk description for id"		^self chunkDescriptions at: id ifAbsent: []! !!ThreeDSParser class methodsFor: 'utilities'!chunkDescriptions	ChunkDescriptions == nil ifTrue: [self initializeChunkDescriptions].	^ChunkDescriptions! !!ThreeDSParser class methodsFor: 'utilities'!chunkDocumentation	"From: The Unofficial 3DStudio 3DS File Format v1.0 by Jeff Lewis"	"http://www.leo.org/pub/comp/graphics/3d/viewpoint/format_specs/3DS_details.rtf.gz"		^'0000H	NULL_CHUNK0001H	UnknownChunk0002H	M3D_VERSION	short version;0005H	M3D_KFVERSION0010H	COLOR_F	float red, grn, blu;0011H	COLOR_24	char red, grn, blu;0012H	LIN_COLOR_24	char red, grn, blu;0013H	LIN_COLOR_F	float red, grn, blu;0030H	INT_PERCENTAGE	short percentage;0031H	FLOAT_PERCENTAGE	float percentage;0100H	MASTER_SCALE	float scale;0995H	ChunkType0996H	ChunkUnique0997H	NotChunk0998H	Container0999H	IsChunk0c3cH	C_SXP_SELFI_MASKDATA1100H	BIT_MAP	cstr filename;1101H	USE_BIT_MAP1200H	SOLID_BGND	followed by color_f1201H	USE_SOLID_BGND1300H	V_GRADIENT	followed by three color_f: start, mid, end	float midpoint;1301H	USE_V_GRADIENT1400H	LO_SHADOW_BIAS	float bias;1410H	HI_SHADOW_BIAS1420H	SHADOW_MAP_SIZE	short size;1430H	SHADOW_SAMPLES1440H	SHADOW_RANGE1450H	SHADOW_FILTER	float filter;1460H	RAY_BIAS	float bias;1500H	O_CONSTS	float plane_x, plane_y, plane_z;2100H	AMBIENT_LIGHT2200H	FOG		followed by color_f, fog_bgnd	float near_plane, near_density;	float far_plane, far_density;2201H	USE_FOG2210H	FOG_BGND2300H	DISTANCE_CUE	followed by dcue_bgnd	float near_plane, near_density;	float far_plane, far_density;2301H	USE_DISTANCE_CUE2302H	LAYER_FOG	float fog_z_from, fog_z_to;	float fog_density;	short fog_type;2303H	USE_LAYER_FOG2310H	DCUE_BGND2d2dH	SMAGIC2d3dH	LMAGIC3000H	DEFAULT_VIEW3010H	VIEW_TOP	float targe_x, target_y, target_z;	float view_width;3020H	VIEW_BOTTOM	float targe_x, target_y, target_z;	float view_width;3030H	VIEW_LEFT	float targe_x, target_y, target_z;	float view_width;3040H	VIEW_RIGHT	float targe_x, target_y, target_z;	float view_width;3050H	VIEW_FRONT	float targe_x, target_y, target_z;	float view_width;3060H	VIEW_BACK	float targe_x, target_y, target_z;	float view_width;3070H	VIEW_USER	float targe_x, target_y, target_z;	float view_width;3080H	VIEW_CAMERA	cstr camera_name;3090H	VIEW_WINDOW3d3dH	MDATA	Mesh Data Magic Number (.3DS files sub of 4d4d)3d3eH	MESH_VERSION3daaH	MLIBMAGIC	Material Library Magic Number (.MLI files)3dc2H	PRJMAGIC	3dS Project Magic Number (.PRJ files)3dffH	MATMAGIC	Material File Magic Number (.MAT files)4000H	NAMED_OBJECT	cstr name;4010H	OBJ_HIDDEN4011H	OBJ_VIS_LOFTER4012H	OBJ_DOESNT_CAST4013H	OBJ_MATTE4014H	OBJ_FAST4015H	OBJ_PROCEDURAL4016H	OBJ_FROZEN4017H	OBJ_DONT_RCVSHADOW4100H	N_TRI_OBJECT	named triangle object			followed by point_array, point_flag_array, mesh_matrix,			face_array4110H	POINT_ARRAY	short npoints;	struct {		float x, y, z;		} points[npoints];4111H	POINT_FLAG_ARRAY	short nflags;	short flags[nflags];4120H	FACE_ARRAY	may be followed by smooth_group	short nfaces;	struct {		short vertex1, vertex2, vertex3;		short flags;		} facearray[nfaces];4130H	MSH_MAT_GROUP	mesh_material_group	cstr material_name;	short nfaces;	short facenum[nfaces];4131H	OLD_MAT_GROUP4140H	TEX_VERTS	short nverts;	struct {		float x, y;		} vertices[nverts];4150H	SMOOTH_GROUP	short grouplist[n]	determined by length, seems to be 4 per face4160H	MESH_MATRIX	float matrix[4][3];4165H	MESH_COLOR	short color_index;4170H	MESH_TEXTURE_INFO	short map_type;	float x_tiling, y_tiling;	float icon_x, icon_y, icon_z;	float matrix[4][3];	float scaling, plan_icon_w, plan_icon_h, cyl_icon_h;4181H	PROC_NAME4182H	PROC_DATA4190H	MSH_BOXMAP4400H	N_D_L_OLD4500H	N_CAM_OLD4600H	N_DIRECT_LIGHT	followed by color_f	float x, y, z;4610H	DL_SPOTLIGHT	float target_x, target_y, target_z;	float hotspot_ang;	float falloff_ang;4620H	DL_OFF4625H	DL_ATTENUATE4627H	DL_RAYSHAD4630H	DL_SHADOWED4640H	DL_LOCAL_SHADOW4641H	DL_LOCAL_SHADOW24650H	DL_SEE_CONE4651H	DL_SPOT_RECTANGULAR4652H	DL_SPOT_OVERSHOOT4653H	DL_SPOT_PROJECTOR4654H	DL_EXCLUDE4655H	DL_RANGE4656H	DL_SPOT_ROLL	float roll_ang;4657H	DL_SPOT_ASPECT4658H	DL_RAY_BIAS	float bias;4659H	DL_INNER_RANGE	float range;465aH	DL_OUTER_RANGE	float range;465bH	DL_MULTIPLIER	float multiple;4680H	N_AMBIENT_LIGHT4700H	N_CAMERA	float camera_x, camera_y, camera_z;	float target_x, target_y, target_z;	float bank_angle;	float focus;4710H	CAM_SEE_CONE4720H	CAM_RANGES	float near_range, far_range;4d4dH	M3DMAGIC	3DS Magic Number (.3DS file)4f00H	HIERARCHY4f10H	PARENT_OBJECT4f20H	PIVOT_OBJECT4f30H	PIVOT_LIMITS4f40H	PIVOT_ORDER4f50H	XLATE_RANGE5000H	POLY_2D5010H	SHAPE_OK5011H	SHAPE_NOT_OK5020H	SHAPE_HOOK6000H	PATH_3D6005H	PATH_MATRIX6010H	SHAPE_2D6020H	M_SCALE6030H	M_TWIST6040H	M_TEETER6050H	M_FIT6060H	M_BEVEL6070H	XZ_CURVE6080H	YZ_CURVE6090H	INTERPCT60a0H	DEFORM_LIMIT6100H	USE_CONTOUR6110H	USE_TWEEN6120H	USE_SCALE6130H	USE_TWIST6140H	USE_TEETER6150H	USE_FIT6160H	USE_BEVEL7000H	VIEWPORT_LAYOUT_OLD7001H	VIEWPORT_LAYOUT	followed by viewport_size, viewport_data	short form, top, ready, wstate, swapws, swapport, swapcur;7010H	VIEWPORT_DATA_OLD7011H	VIEWPORT_DATA	short flags, axis_lockout;	short win_x, win_y, win_w, winh_, win_view;	float zoom;	float worldcenter_x, worldcenter_y, worldcenter_z;	float horiz_ang, vert_ang;	cstr camera_name;7012H	VIEWPORT_DATA_3	short flags, axis_lockout;	short win_x, win_y, win_w, winh_, win_view;	float zoom;	float worldcenter_x, worldcenter_y, worldcenter_z;	float horiz_ang, vert_ang;	cstr camera_name;7020H	VIEWPORT_SIZE	short x, y, w, h;7030H	NETWORK_VIEW8000H	XDATA_SECTION8001H	XDATA_ENTRY8002H	XDATA_APPNAME8003H	XDATA_STRING8004H	XDATA_FLOAT8005H	XDATA_DOUBLE8006H	XDATA_SHORT8007H	XDATA_LONG8008H	XDATA_VOID8009H	XDATA_GROUP800aH	XDATA_RFU6800bH	XDATA_RFU5800cH	XDATA_RFU4800dH	XDATA_RFU3800eH	XDATA_RFU2800fH	XDATA_RFU180f0H	PARENT_NAMEa000H	MAT_NAME	cstr material_name;a010H	MAT_AMBIENT	followed by color chunka020H	MAT_DIFFUSE	followed by color chunka030H	MAT_SPECULAR	followed by color chunka040H	MAT_SHININESS	followed by percentage chunka041H	MAT_SHIN2PCT	followed by percentage chunka042H	MAT_SHIN3PCT	followed by percentage chunka050H	MAT_TRANSPARENCY	followed by percentage chunka052H	MAT_XPFALL	followed by percentage chunka053H	MAT_REFBLUR	followed by percentage chunka080H	MAT_SELF_ILLUMa081H	MAT_TWO_SIDEa082H	MAT_DECALa083H	MAT_ADDITIVEa084H	MAT_SELF_ILPCT	followed by percentage chunka085H	MAT_WIREa086H	MAT_SUPERSMPa087H	MAT_WIRESIZE	float wire_size;a088H	MAT_FACEMAPa08aH	MAT_XPFALLINa08cH	MAT_PHONGSOFTa08eH	MAT_WIREABSa100H	MAT_SHADING	short shading_value;a200H	MAT_TEXMAP	followed by percentage chunk, mat_mapname,			mat_map_tiling, mat_map_texblur...a204H	MAT_SPECMAP	followed by percentage_chunk, mat_mapnamea210H	MAT_OPACMAP	followed by percentage_chunk, mat_mapnamea220H	MAT_REFLMAP	followed by percentage_chunk, mat_mapnamea230H	MAT_BUMPMAP	followed by percentage_chunk, mat_mapnamea240H	MAT_USE_XPFALLa250H	MAT_USE_REFBLURa252H	MAT_BUMP_PERCENTa300H	MAT_MAPNAME	cstr filename;a310H	MAT_ACUBICa320H	MAT_SXP_TEXT_DATAa321H	MAT_SXP_TEXT2_DATAa322H	MAT_SXP_OPAC_DATAa324H	MAT_SXP_BUMP_DATAa325H	MAT_SXP_SPEC_DATAa326H	MAT_SXP_SHIN_DATAa328H	MAT_SXP_SELFI_DATAa32aH	MAT_SXP_TEXT_MASKDATAa32cH	MAT_SXP_TEXT2_MASKDATAa32eH	MAT_SXP_OPAC_MASKDATAa330H	MAT_SXP_BUMP_MASKDATAa332H	MAT_SXP_SPEC_MASKDATAa334H	MAT_SXP_SHIN_MASKDATAa336H	MAT_SXP_SELFI_MASKDATAa338H	MAT_SXP_REFL_MASKDATAa33aH	MAT_TEX2MAPa33cH	MAT_SHINMAPa33dH	MAT_SELFIMAPa33eH	MAT_TEXMASKa340H	MAT_TEX2MASKa342H	MAT_OPACMASKa344H	MAT_BUMPMASKa346H	MAT_SHINMASKa348H	MAT_SPECMASKa34aH	MAT_SELFIMASKa34cH	MAT_REFLMASKa350H	MAT_MAP_TILINGOLDa351H	MAT_MAP_TILING	short flags;a352H	MAT_MAP_TEXBLUR_OLDa353H	MAT_MAP_TEXBLUR	float blurring;a354H	MAT_MAP_USCALEa356H	MAT_MAP_VSCALEa358H	MAT_MAP_UOFFSETa35aH	MAT_MAP_VOFFSETa35cH	MAT_MAP_ANGa360H	MAT_MAP_COL1a362H	MAT_MAP_COL2a364H	MAT_MAP_RCOLa366H	MAT_MAP_GCOLa368H	MAT_MAP_BCOLafffH	MAT_ENTRYb000H	KFDATA	followed by kfhdrb001H	AMBIENT_NODE_TAGb002H	OBJECT_NODE_TAG	followed by node_hdr, pivot, pos_track_tag,			rot_track_tag, scl_track_tag, morph_smooth...b003H	CAMERA_NODE_TAG	followed by node_hdr, pos_track_tag, fov_track_tag,			roll_track_tag...b004H	TARGET_NODE_TAG	followed by node_hdr, pos_track_tag...b005H	LIGHT_NODE_TAG	followed by node_hdr, pos_track_tag, col_track_tag...b006H	L_TARGET_NODE_TAG	followed by node_id, node_hdr, pos_track_tagb007H	SPOTLIGHT_NODE_TAG followed by node_id, node_hdr, pos_track_tag,					hot_track_tag, fall_track_tag, roll_track_tag,			col_track_tag...b008H	KFSEG	long start, end;b009H	KFCURTIME	long curframe;b00aH	KFHDR	followed by viewport_layout, kfseg, kfcurtime,			object_node_tag, light_node_tag, target_node_tag,			camera_node_tag, l_target_node_tag, spotlight_node_tag			ambient_node_tag...	short revision;	cstr filename;	short animlen;b010H	NODE_HDR	cstr objname;	short flags1;	short flags2;	short heirarchy;	?b011H	INSTANCE_NAMEb012H	PRESCALEb013H	PIVOT	float pivot_x, pivot_y, pivot_z;b014H	BOUNDBOXb015H	MORPH_SMOOTH	float morph_smoothing_angle_rad;b020H	POS_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float pos_x, pos_y, pos_z;		} pos[keys];b021H	ROT_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float rotation_rad;		float axis_x, axis_y, axis_z;		} rot[keys];b022H	SCL_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float scale_x, scale_y, scale_z;		} scale[keys];b023H	FOV_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float camera_field_of_view;		} fov[keys]b024H	ROLL_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float camera_roll;		} roll[keys];b025H	COL_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float red, rgn, blu;		} color[keys];b026H	MORPH_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		cstr obj_name;		} morph[keys];b027H	HOT_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float hotspot_ang;		} hotspot[keys];b028H	FALL_TRACK_TAG	short flags;	short unknown[4];	short keys;	short unknown;	struct {		short framenum;		long unknown;		float falloff_ang;		} falloff[keys];b029H	HIDE_TRACK_TAGb030H	NODE_ID	short id;c010H	C_MDRAWERc020H	C_TDRAWERc030H	C_SHPDRAWERc040H	C_MODDRAWERc050H	C_RIPDRAWERc060H	C_TXDRAWERc062H	C_PDRAWERc064H	C_MTLDRAWERc066H	C_FLIDRAWERc067H	C_CUBDRAWERc070H	C_MFILEc080H	C_SHPFILEc090H	C_MODFILEc0a0H	C_RIPFILEc0b0H	C_TXFILEc0b2H	C_PFILEc0b4H	C_MTLFILEc0b6H	C_FLIFILEc0b8H	C_PALFILEc0c0H	C_TX_STRINGc0d0H	C_CONSTSc0e0H	C_SNAPSc0f0H	C_GRIDSc100H	C_ASNAPSc110H	C_GRID_RANGEc120H	C_RENDTYPEc130H	C_PROGMODEc140H	C_PREVMODEc150H	C_MODWMODEc160H	C_MODMODELc170H	C_ALL_LINESc180H	C_BACK_TYPEc190H	C_MD_CSc1a0H	C_MD_CEc1b0H	C_MD_SMLc1c0H	C_MD_SMWc1c3H	C_LOFT_WITH_TEXTUREc1c4H	C_LOFT_L_REPEATc1c5H	C_LOFT_W_REPEATc1c6H	C_LOFT_UV_NORMALIZEc1c7H	C_WELD_LOFTc1d0H	C_MD_PDETc1e0H	C_MD_SDETc1f0H	C_RGB_RMODEc200H	C_RGB_HIDEc202H	C_RGB_MAPSWc204H	C_RGB_TWOSIDEc208H	C_RGB_SHADOWc210H	C_RGB_AAc220H	C_RGB_OVWc230H	C_RGB_OVHc23dH	CMAGICc240H	C_RGB_PICTYPEc250H	C_RGB_OUTPUTc253H	C_RGB_TODISKc254H	C_RGB_COMPRESSc255H	C_JPEG_COMPRESSIONc256H	C_RGB_DISPDEVc259H	C_RGB_HARDDEVc25aH	C_RGB_PATHc25bH	C_BITMAP_DRAWERc260H	C_RGB_FILEc270H	C_RGB_OVASPECTc271H	C_RGB_ANIMTYPEc272H	C_RENDER_ALLc273H	C_REND_FROMc274H	C_REND_TOc275H	C_REND_NTHc276H	C_PAL_TYPEc277H	C_RND_TURBOc278H	C_RND_MIPc279H	C_BGND_METHODc27aH	C_AUTO_REFLECTc27bH	C_VP_FROMc27cH	C_VP_TOc27dH	C_VP_NTHc27eH	C_REND_TSTEPc27fH	C_VP_TSTEPc280H	C_SRDIAMc290H	C_SRDEGc2a0H	C_SRSEGc2b0H	C_SRDIRc2c0H	C_HETOPc2d0H	C_HEBOTc2e0H	C_HEHTc2f0H	C_HETURNSc300H	C_HEDEGc310H	C_HESEGc320H	C_HEDIRc330H	C_QUIKSTUFFc340H	C_SEE_LIGHTSc350H	C_SEE_CAMERASc360H	C_SEE_3Dc370H	C_MESHSELc380H	C_MESHUNSELc390H	C_POLYSELc3a0H	C_POLYUNSELc3a2H	C_SHPLOCALc3a4H	C_MSHLOCALc3b0H	C_NUM_FORMATc3c0H	C_ARCH_DENOMc3d0H	C_IN_DEVICEc3e0H	C_MSCALEc3f0H	C_COMM_PORTc400H	C_TAB_BASESc410H	C_TAB_DIVSc420H	C_MASTER_SCALESc430H	C_SHOW_1STVERTc440H	C_SHAPER_OKc450H	C_LOFTER_OKc460H	C_EDITOR_OKc470H	C_KEYFRAMER_OKc480H	C_PICKSIZEc490H	C_MAPTYPEc4a0H	C_MAP_DISPLAYc4b0H	C_TILE_XYc4c0H	C_MAP_XYZc4d0H	C_MAP_SCALEc4e0H	C_MAP_MATRIX_OLDc4e1H	C_MAP_MATRIXc4f0H	C_MAP_WID_HTc500H	C_OBNAMEc510H	C_CAMNAMEc520H	C_LTNAMEc525H	C_CUR_MNAMEc526H	C_CURMTL_FROM_MESHc527H	C_GET_SHAPE_MAKE_FACESc530H	C_DETAILc540H	C_VERTMARKc550H	C_MSHAXc560H	C_MSHCPc570H	C_USERAXc580H	C_SHOOKc590H	C_RAXc5a0H	C_STAPEc5b0H	C_LTAPEc5c0H	C_ETAPEc5c8H	C_KTAPEc5d0H	C_SPHSEGSc5e0H	C_GEOSMOOTHc5f0H	C_HEMISEGSc600H	C_PRISMSEGSc610H	C_PRISMSIDESc620H	C_TUBESEGSc630H	C_TUBESIDESc640H	C_TORSEGSc650H	C_TORSIDESc660H	C_CONESIDESc661H	C_CONESEGSc670H	C_NGPARMSc680H	C_PTHLEVELc690H	C_MSCSYMc6a0H	C_MFTSYMc6b0H	C_MTTSYMc6c0H	C_SMOOTHINGc6d0H	C_MODICOUNTc6e0H	C_FONTSELc6f0H	C_TESS_TYPEc6f1H	C_TESS_TENSIONc700H	C_SEG_STARTc705H	C_SEG_ENDc710H	C_CURTIMEc715H	C_ANIMLENGTHc720H	C_PV_FROMc725H	C_PV_TOc730H	C_PV_DOFNUMc735H	C_PV_RNGc740H	C_PV_NTHc745H	C_PV_TYPEc750H	C_PV_METHODc755H	C_PV_FPSc765H	C_VTR_FRAMESc770H	C_VTR_HDTLc771H	C_VTR_HDc772H	C_VTR_TLc775H	C_VTR_INc780H	C_VTR_PKc785H	C_VTR_SHc790H	C_WORK_MTLSc792H	C_WORK_MTLS_2c793H	C_WORK_MTLS_3c794H	C_WORK_MTLS_4c7a1H	C_BGTYPEc7b0H	C_MEDTILEc7d0H	C_LO_CONTRASTc7d1H	C_HI_CONTRASTc7e0H	C_FROZ_DISPLAYc7f0H	C_BOOLWELDc7f1H	C_BOOLTYPEc900H	C_ANG_THRESHc901H	C_SS_THRESHc903H	C_TEXTURE_BLUR_DEFAULTca00H	C_MAPDRAWERca01H	C_MAPDRAWER1ca02H	C_MAPDRAWER2ca03H	C_MAPDRAWER3ca04H	C_MAPDRAWER4ca05H	C_MAPDRAWER5ca06H	C_MAPDRAWER6ca07H	C_MAPDRAWER7ca08H	C_MAPDRAWER8ca09H	C_MAPDRAWER9ca10H	C_MAPDRAWER_ENTRYca20H	C_BACKUP_FILEca21H	C_DITHER_256ca22H	C_SAVE_LASTca23H	C_USE_ALPHAca24H	C_TGA_DEPTHca25H	C_REND_FIELDSca26H	C_REFLIPca27H	C_SEL_ITEMTOGca28H	C_SEL_RESETca29H	C_STICKY_KEYINFca2aH	C_WELD_THRESHOLDca2bH	C_ZCLIP_POINTca2cH	C_ALPHA_SPLITca30H	C_KF_SHOW_BACKFACEca40H	C_OPTIMIZE_LOFTca42H	C_TENS_DEFAULTca44H	C_CONT_DEFAULTca46H	C_BIAS_DEFAULTca50H	C_DXFNAME_SRCca60H	C_AUTO_WELDca70H	C_AUTO_UNIFYca80H	C_AUTO_SMOOTHca90H	C_DXF_SMOOTH_ANGcaa0H	C_SMOOTH_ANGcb00H	C_WORK_MTLS_5cb01H	C_WORK_MTLS_6cb02H	C_WORK_MTLS_7cb03H	C_WORK_MTLS_8cb04H	C_WORKMTLcb10H	C_SXP_TEXT_DATAcb11H	C_SXP_OPAC_DATAcb12H	C_SXP_BUMP_DATAcb13H	C_SXP_SHIN_DATAcb20H	C_SXP_TEXT2_DATAcb24H	C_SXP_SPEC_DATAcb28H	C_SXP_SELFI_DATAcb30H	C_SXP_TEXT_MASKDATAcb32H	C_SXP_TEXT2_MASKDATAcb34H	C_SXP_OPAC_MASKDATAcb36H	C_SXP_BUMP_MASKDATAcb38H	C_SXP_SPEC_MASKDATAcb3aH	C_SXP_SHIN_MASKDATAcb3eH	C_SXP_REFL_MASKDATAcc00H	C_NET_USE_VPOSTcc10H	C_NET_USE_GAMMAcc20H	C_NET_FIELD_ORDERcd00H	C_BLUR_FRAMEScd10H	C_BLUR_SAMPLEScd20H	C_BLUR_DURcd30H	C_HOT_METHODcd40H	C_HOT_CHECKcd50H	C_PIXEL_SIZEcd60H	C_DISP_GAMMAcd70H	C_FBUF_GAMMAcd80H	C_FILE_OUT_GAMMAcd82H	C_FILE_IN_GAMMAcd84H	C_GAMMA_CORRECTcd90H	C_APPLY_DISP_GAMMAcda0H	C_APPLY_FBUF_GAMMAcdb0H	C_APPLY_FILE_GAMMAcdc0H	C_FORCE_WIREcdd0H	C_RAY_SHADOWScde0H	C_MASTER_AMBIENTcdf0H	C_SUPER_SAMPLEce00H	C_OBJECT_MBLURce10H	C_MBLUR_DITHERce20H	C_DITHER_24ce30H	C_SUPER_BLACKce40H	C_SAFE_FRAMEce50H	C_VIEW_PRES_RATIOce60H	C_BGND_PRES_RATIOce70H	C_NTH_SERIAL_NUMd000H	VPDATAd100H	P_QUEUE_ENTRYd110H	P_QUEUE_IMAGEd114H	P_QUEUE_USEIGAMMAd120H	P_QUEUE_PROCd130H	P_QUEUE_SOLIDd140H	P_QUEUE_GRADIENTd150H	P_QUEUE_KFd152H	P_QUEUE_MOTBLURd153H	P_QUEUE_MB_REPEATd160H	P_QUEUE_NONEd180H	P_QUEUE_RESIZEd185H	P_QUEUE_OFFSETd190H	P_QUEUE_ALIGNd1a0H	P_CUSTOM_SIZEd210H	P_ALPH_NONEd220H	P_ALPH_PSEUDOd221H	P_ALPH_OP_PSEUDOd222H	P_ALPH_BLURd225H	P_ALPH_PCOLd230H	P_ALPH_C0d231H	P_ALPH_OP_KEYd235H	P_ALPH_KCOLd238H	P_ALPH_OP_NOCONVd240H	P_ALPH_IMAGEd250H	P_ALPH_ALPHAd260H	P_ALPH_QUESd265H	P_ALPH_QUEIMGd270H	P_ALPH_CUTOFFd280H	P_ALPHANEGd300H	P_TRAN_NONEd310H	P_TRAN_IMAGEd312H	P_TRAN_FRAMESd320H	P_TRAN_FADEINd330H	P_TRAN_FADEOUTd340H	P_TRANNEGd400H	P_RANGESd500H	P_PROC_DATAf020H	POS_TRACK_TAG_KEYf021H	ROT_TRACK_TAG_KEYf022H	SCL_TRACK_TAG_KEYf023H	FOV_TRACK_TAG_KEYf024H	ROLL_TRACK_TAG_KEYf025H	COL_TRACK_TAG_KEYf026H	MORPH_TRACK_TAG_KEYf027H	HOT_TRACK_TAG_KEYf028H	FALL_TRACK_TAG_KEYf110H	POINT_ARRAY_ENTRYf111H	POINT_FLAG_ARRAY_ENTRYf120H	FACE_ARRAY_ENTRYf130H	MSH_MAT_GROUP_ENTRYf140H	TEX_VERTS_ENTRYf150H	SMOOTH_GROUP_ENTRYffffH	DUMMY'! !!ThreeDSParser class methodsFor: 'utilities'!clearChunkDescriptions	"Reset Class variable ChunkDescriptions"	ChunkDescriptions := nil.! !!ThreeDSParser class methodsFor: 'utilities' stamp: 'ar 2/12/1999 17:52'!initializeChunkDescriptions	"Initialize Class variable ChunkDescriptions from the documentation"	"ThreeDSParser initializeChunkDescriptions "	| s id tag comment sl c |	s := ReadStream on: self chunkDocumentation.	ChunkDescriptions := Dictionary new: 100.	id := tag := comment := nil.	[s atEnd] whileFalse: [		s peek = Character tab			ifFalse: [				id isNil ifFalse: [					ChunkDescriptions add: (ThreeDSChunkDescription						id: id name: tag comment: comment contents)].				id := Integer readFrom: s radix: 16.				s skip: 2.				sl := ReadStream on: (s through: Character cr).				tag := OrderedCollection new.				[(c := sl next) isNil or: [c isSeparator]] whileFalse: [tag add: c].				tag := String withAll: tag.				sl skipSeparators.				comment := WriteStream on: String new]			ifTrue: [comment nextPutAll: (s through: Character cr)]		].	ChunkDescriptions add: (ThreeDSChunkDescription						id: id name: tag comment: comment contents)! !!ThreeDSParser class methodsFor: 'class initialization' stamp: 'ar 2/6/1999 21:00'!defaultSpec	"The default spec is a dictionary with		#camera -> CameraClassName (e.g., #B3DCamera3DS)		#material -> MaterialClassName (e.g., #B3DMaterial3DS)		#meshObject -> MeshObjectClassName (e.g., #B3DObject3DS)		#pointLight -> PointLightClassName (e.g., #B3DPositionalLight)		#spotLight -> SpotLightClassName (e.g., #B3DSpotLight)		#scene -> SceneClassName (e.g., #B3DScene3DS)		#splineVertex -> SplineVertexClass (e.g., B3DSplineVertex3DS)	all responding to #from3DS: aDictionary and		#vertexArray -> VertexArrayClassName (e.g., #B3DVector3Array)		#textureArray -> TextureArrayClassName (e.g., #B3DTexture2Array)	for constructing large arrays of vertex / texture coordinates	(responding to the standard array messages #new: #at: and #at:put:)	"	"ThreeDSParser defaultSpec"	^DefaultSpec! !!ThreeDSParser class methodsFor: 'class initialization' stamp: 'ar 2/6/1999 20:45'!defaultSpec: aDictionary	"ThreeDSParser defaultSpec"	DefaultSpec _ aDictionary! !!ThreeDSParser class methodsFor: 'class initialization' stamp: 'ar 2/12/1999 17:53'!initialize	"ThreeDSParser initialize"	self defaultSpec: nil. "Reset the default spec"! !!ThreeDSParser class methodsFor: 'class initialization' stamp: 'ar 2/8/1999 01:14'!initializeB3D		"ThreeDSParser initializeB3D"	"Initialize the 3DS Parser to use the Balloon 3D standard representations"	| spec |	spec _ Dictionary new.	#(	(#camera 		#B3DCamera)		(#material  		#B3DMaterial)		(#meshObject 	#B3DSceneObject)		(#pointLight 	#B3DPositionalLight)		(#spotLight 		#B3DSpotLight)		(#splineVertex	nil "#B3DSplineVertex3DS")		(#scene 		#B3DScene)		(#vertexArray 	#B3DVector3Array)		(#textureArray 	#B3DTexture2Array)	) do:[:array| spec at: array first put: array last].	self defaultSpec: spec.! !!ThreeDSParser class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 05:17'!parse: aStream	"Answer a dictionary of name->RenderObject associations"	^self parse: aStream using: self defaultSpec.! !!ThreeDSParser class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 05:17'!parse: aStream using: aSpec	"Answer a dictionary of name->RenderObject associations"	^self new parse: aStream using: aSpec! !!ThreeDSParser class methodsFor: 'instance creation' stamp: 'ar 2/6/1999 20:26'!parseFileNamed: aString	"Answer a dictionary of name->RenderObject associations"	^self parseFileNamed: aString using: self defaultSpec.! !!ThreeDSParser class methodsFor: 'instance creation' stamp: 'ar 2/15/1999 05:17'!parseFileNamed: aString using: aSpec	"Answer a dictionary of name->RenderObject associations"	^self new parseFileNamed: aString using: aSpec.! !!UndefinedObject methodsFor: '3ds parser support' stamp: 'ar 2/6/1999 20:18'!from3DS: aDictionary	^aDictionary! !ThreeDSParser removeSelector: #meshClass!ThreeDSParser removeSelector: #vector3Class!ThreeDSParser removeSelector: #postProcess:!ThreeDSParser removeSelector: #objectClass!ThreeDSParser removeSelector: #color3Class!ThreeDSParser initialize!ThreeDSParser class removeSelector: #example!ThreeDSParser class removeSelector: #new!ThreeDSParser class removeSelector: #pattern:!"Postscript:Initialize the balloon representations."ThreeDSParser initializeB3D.!