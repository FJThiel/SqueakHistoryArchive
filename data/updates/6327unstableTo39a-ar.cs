
"Change Set:		unstableTo39a-arDate:			25 October 2004Author:			Andreas RaabThis CS contains all differences to make the 3.8a unstable image be equivalent to the stable 3.8beta image (except for Diego's UI enhancemens and the RB additions which are already in unstable and will be added to 3.9a stable)"!Scanner initialize!SymbolListType subclass: #UserCustomEventNameType	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CustomEvents'!!UserCustomEventNameType commentStamp: 'nk 6/12/2004 14:09'!This is a data type that enumerates user-defined custom event names.You can turn off the display of such events in the script status popups by turning off the	allowEtoyUserCustomEvents	Preference.!UserCustomEventNameType class	instanceVariableNames: ''!PackageInfo subclass: #FlexibleVocabulariesInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FlexibleVocabularies-Info'!!FlexibleVocabulariesInfo commentStamp: 'nk 3/11/2004 16:38'!Package:		FlexibleVocabularies-nkDate:			12 October 2003Author:			Ned KonzThis makes it possible for packages to extend Morph class vocabularies.Previously, you'd have to edit #additionsToViewerCategories, which would result in potential conflicts between different packages that all wanted to (for instance) extend Morph's vocabulary.Subclasses that have additions can do one or both of:	- override #additionsToViewerCategories (as before)	- define one or more additionToViewerCategory* methods.The advantage of the latter technique is that class extensions may be addedby external packages without having to re-define additionsToViewerCategories.So, for instance, package A could add a method named #additionsToViewerCategoryPackageABasicand its methods would be added to the vocabulary automatically.NOTE: this change set is hand-rearranged to avoid problems on file-in.Specifically, Morph>>hasAdditionsToViewerCategories must come before Morph class>>additionsToViewerCategories!FlexibleVocabulariesInfo class	instanceVariableNames: ''!Morph subclass: #HaloMorph	instanceVariableNames: 'target innerTarget positionOffset angleOffset minExtent growingOrRotating directionArrowAnchor haloBox simpleMode originalExtent'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!SimpleButtonMorph subclass: #SimpleButtonDelayedMenuMorph	instanceVariableNames: 'didMenu'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!RectangleMorph subclass: #SimpleButtonMorph	instanceVariableNames: 'target actionSelector arguments actWhen oldColor mouseDownTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase'	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag'	poolDictionaries: ''	category: 'System-Compiler'!!Decompiler commentStamp: 'ls 1/28/2004 13:31'!I decompile a method in three phases:	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)	Parser: prefix symbolic codes -> node tree (same as the compiler)	Printer: node tree -> text (done by the nodes)	instance vars:	constructor	method	instVars	tempVars	constTable	stack	statements	lastPc	exit	caseExits	- stack of exit addresses that have been seen in the branches of caseOf:'s	lastJumpPc	lastReturnPc	limit	hasValue	blockStackBase!!ScriptInstantiation methodsFor: 'status control' stamp: 'nk 8/21/2004 12:08'!fireOnce	"Run this script once"	player triggerScript: selector! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 6/12/2004 14:23'!explainStatusAlternatives	"Open a little window that explains the various status 	alternatives "	(StringHolder new contents: ScriptingSystem statusHelpString)		openLabel: 'Script Status' translated! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 7/21/2003 20:07'!defineNewEvent	| newEventName newEventHelp |	"Prompt the user for the name of a new event and install it into the custom event table"	newEventName _ FillInTheBlankMorph request: 'What is the name of your new event?'.	newEventName isEmpty ifTrue: [ ^self ].	newEventName _ newEventName asSymbol.	(ScriptingSystem customEventStati includes: newEventName) ifTrue: [		self inform: 'That event is already defined.'. ^self ].	newEventHelp _ FillInTheBlankMorph request: 'Please describe this event:'.	ScriptingSystem addUserCustomEventNamed: newEventName help: newEventHelp.! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 7/21/2003 20:32'!deleteCustomEvent	| userEvents eventName |	userEvents _  ScriptingSystem userCustomEventNames.	eventName _ (SelectionMenu selections: userEvents) startUpWithCaption: 'Remove which event?' at: ActiveHand position allowKeyboard: true.	eventName ifNotNil: [ ScriptingSystem removeUserCustomEventNamed: eventName ].	self class allSubInstancesDo: [ :ea | ea status = eventName ifTrue: [ ea status: #normal ]]! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 6/30/2004 19:00'!addStatusChoices: choices toMenu: menu	choices isEmpty ifFalse: [		choices	 do: [ :choice || label sym |			(choice isKindOf: Array) 				ifTrue: [ label := choice first translated. sym := choice second ]				ifFalse: [ label := choice translated. sym := choice ].			menu add: label target: menu selector: #modalSelection: argument: sym ].		menu addLine. ].	^menu.! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 7/17/2004 09:01'!addStatusChoices: choices toSubMenu: submenu forMenu: menu	choices isEmpty ifFalse: [		choices	 do: [ :choice || label sym |			(choice isKindOf: Array) 				ifTrue: [ label := choice first translated. sym := choice second ]				ifFalse: [ label := choice translated. sym := choice ].			submenu add: label target: menu selector: #modalSelection: argument: sym ].		menu addLine. ].	^menu.! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 9/25/2003 11:35'!removeEventTriggersForMorph: actualMorph 	"user custom events are triggered at the World, while system custom events are triggered on individual Morphs."	actualMorph removeActionsSatisfying: 			[:action | 			action receiver == player and: 					[(#(#doScript: #triggerScript:) includes: action selector) 						and: [action arguments first == selector]]]		forEvent: status.	self currentWorld removeActionsSatisfying: 			[:action | 			action receiver == player and: 					[(#(#doScript: #triggerScript:) includes: action selector) 						and: [action arguments first == selector]]]		forEvent: status! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 9/25/2003 11:38'!status: newStatus 	"Set the receiver's status as indicated"	| stati actualMorph |	actualMorph := player costume renderedMorph.	"standard (EventHandler) events"	stati := ScriptingSystem standardEventStati.	(stati includes: status) 		ifTrue: 			[actualMorph 				on: status				send: nil				to: nil			"remove old link in event handler"].	(stati includes: newStatus) 		ifTrue: 			[actualMorph 				on: newStatus				send: selector				to: player.			"establish new link in evt handler"			player assureNoScriptOtherThan: self hasStatus: newStatus].	"user custom events are triggered at the World, while system custom events are triggered on individual Morphs."	self removeEventTriggersForMorph: actualMorph.	stati := ScriptingSystem customEventStati.	(stati includes: newStatus) 		ifTrue: 			[(ScriptingSystem userCustomEventNames includes: newStatus) 				ifTrue: 					[self currentWorld 						when: newStatus						send: #triggerScript:						to: player						withArguments: { 								selector}]				ifFalse: 					[actualMorph when: newStatus						evaluate: (MessageSend 								receiver: player								selector: #triggerScript:								arguments: { 										selector})]].	status := newStatus.	self pausedOrTicking ifTrue: [lastTick := nil].	self flag: #arNote.	"this from fall 2000"	self flag: #workaround.	"Code below was in #chooseTriggerFrom: which did not reflect status changes from other places (e.g., the stepping/pause buttons). It is not clear why this is necessary though - theoretically, any morph should step when it has a player but alas!! something is broken and I have no idea why and where."	"14 feb 2001 - bob - I reinstated this after alan noticed that a newly drawn car would not go until you picked it up and dropped it. The reason is that unscripted players have #wantSteps ^false. If a morph enters the world with an unscripted player and then acquires a scripted player, that would be a good time to change, but this will work too"	status == #ticking 		ifTrue: 			[player costume isStepping ifFalse: [player costume arrangeToStartStepping]]! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 8/18/2004 18:01'!presentScriptStatusPopUp	"Put up a menu of status alternatives and carry out the request"	| reply  m menu submenu |	menu _ MenuMorph new.	self addStatusChoices: #( normal " -- run when called" ) toMenu: menu.	self addStatusChoices: 		#(	paused 		"ready to run all the time"			ticking			"run all the time" )		toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati copyFrom: 1 to: 3) toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati allButFirst: 3) toMenu: menu.	self addStatusChoices: 		#(opening			"when I am being opened"			closing			"when I am being closed" )		toMenu: menu.		submenu _ MenuMorph new.	self addStatusChoices: ScriptingSystem globalCustomEventNames toSubMenu: submenu forMenu: menu.	menu add: 'more... ' translated subMenu: submenu.	(Preferences allowEtoyUserCustomEvents) ifTrue: [		submenu addLine.		self addStatusChoices: ScriptingSystem userCustomEventNames toSubMenu: submenu forMenu: menu.		submenu addLine.		self addStatusChoices:			(Array streamContents: [ :s | s nextPut: { 'define a new custom event'. #defineNewEvent }.			ScriptingSystem userCustomEventNames isEmpty				ifFalse: [ s nextPut: { 'delete a custom event'. #deleteCustomEvent } ]])			toSubMenu: submenu forMenu: menu ].		menu addLine.	self addStatusChoices: #(		('what do these mean?'explainStatusAlternatives)		('apply my status to all siblings' assignStatusToAllSiblings) ) toMenu: menu.	menu addTitle: 'When should this script run?' translated.	menu submorphs last delete.	menu invokeModal.		reply := menu modalSelection.	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply == #assignStatusToAllSiblings ifTrue: [^ self assignStatusToAllSiblings].	reply == #defineNewEvent ifTrue: [ ^self defineNewEvent ].	reply == #deleteCustomEvent ifTrue: [ ^self deleteCustomEvent ].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m _ player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:08'!runIfClosing	| result |	(result _ status == #closing) ifTrue:		[player triggerScript: selector].	^ result! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:07'!runIfTicking: nowTick 	| ticks rate |	status == #ticking ifFalse: [^self].	rate := self tickingRate.	ticks := (lastTick isNil or: [nowTick < lastTick]) 				ifTrue: 					[lastTick := nowTick.					1]				ifFalse: [((nowTick - lastTick) * rate / 1000) asInteger].	ticks <= 0 ifTrue: [^self].	"Scripts which have been out of the world and then return can have a huge number of ticks accumulated. A better fix would be to reset <lastTick> when a script leaves/enters the world. Also, if the system is falling behind, this attempt to catch up can result in falling further behind, leading to sluggish behavior and termination of ticking status. Whether the user really wants this catch up behavior needs to be determined (often she will not, I suspect) and better ways of doing it need to be found"	ticks := 1.	1 to: ticks * self frequency do: [:i | player triggerScript: selector].	lastTick := nowTick.	ticks > 10 		ifTrue: 			["check if we're lagging behind"			ticks <= ((Time millisecondClockValue - lastTick) * rate / 1000) asInteger 				ifTrue: 					["e.g., time to run script is higher than number of ticks"					self status: #paused.					self updateAllStatusMorphs]]! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:08'!runIfOpening	| result |	(result _ status == #opening) ifTrue:		[player triggerScript: selector].	^ result! !!BooklikeMorph methodsFor: 'page controls' stamp: 'dgd 9/19/2003 11:34'!fullControlSpecs	^ {		#spacer.		#variableSpacer.		{'-'.		#deletePage.				'Delete this page'}.		#spacer.		{'¬¨¬¥'.		#firstPage.				'First page'}.		#spacer.		{'<'. 		#previousPage.			'Previous page'}.		#spacer.		{'¬¨¬è'.		#invokeBookMenu. 		'Click here to get a menu of options for this book.'}.		#spacer.		{'>'.		#nextPage.				'Next page'}.		#spacer.		{ '¬¨¬'.		#lastPage.				'Final page'}.		#spacer.		{'+'.		#insertPage.				'Add a new page after this one'}.		#variableSpacer.		{'¬¨¬ç'.		#fewerPageControls.	'Fewer controls'}}! !!BooklikeMorph methodsFor: 'page controls' stamp: 'dgd 9/19/2003 11:35'!shortControlSpecs^ {		#spacer.		#variableSpacer.		{'<'. 		#previousPage.			'Previous page' translated}.		#spacer.		{'¬¨¬è'.		#invokeBookMenu. 		'Click here to get a menu of options for this book.' translated}.		#spacer.		{'>'.		#nextPage.				'Next page' translated}.		#spacer.		#variableSpacer.		{'¬¨¬ç'.		#showMoreControls.		'More controls' translated}}! !!Object methodsFor: 'testing' stamp: 'nk 6/14/2004 16:49'!isSketchMorph	^false! !!Object methodsFor: 'viewer' stamp: 'nk 9/11/2004 16:53'!methodInterfacesInPresentationOrderFrom: interfaceList forCategory: aCategory 	"Answer the interface list sorted in desired presentation order, using a 	static master-ordering list, q.v. The category parameter allows an 	escape in case one wants to apply different order strategies in different 	categories, but for now a single master-priority-ordering is used -- see 	the comment in method EToyVocabulary.masterOrderingOfPhraseSymbols"	| masterOrder ordered unordered index |	masterOrder := Vocabulary eToyVocabulary masterOrderingOfPhraseSymbols.	ordered := SortedCollection sortBlock: [:a :b | a key < b key].	unordered := SortedCollection sortBlock: [:a :b | a wording < b wording].	interfaceList do: [:interface | 		index := masterOrder indexOf: interface elementSymbol.		index isZero			ifTrue: [unordered add: interface]			ifFalse: [ordered add: index -> interface]].	^ Array		streamContents: [:stream | 			ordered do: [:assoc | stream nextPut: assoc value].			stream nextPutAll: unordered]! !!Decompiler methodsFor: 'control' stamp: 'ls 1/28/2004 13:29'!statementsForCaseTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end.	Note that stack initially contains a CaseFlag which will be removed by	a subsequent Pop instruction, so adjust the StackPos accordingly."	| blockPos stackPos |	blockPos _ statements size.	stackPos _ stack size - 1. "Adjust for CaseFlag"	[pc < end]		whileTrue:			[lastPc _ pc.  limit _ end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue _ stack size > stackPos)		ifTrue:			[stack last == CaseFlag				ifFalse: [ statements addLast: stack removeLast] ].	lastJumpPc = lastPc ifFalse: [exit _ pc].	caseExits add: exit.	^self popTo: blockPos! !!Decompiler methodsFor: 'private' stamp: 'ls 1/28/2004 13:11'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor _ aConstructor.	method _ aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block _ self quickMethod]		ifFalse: 			[stack _ OrderedCollection new: method frameSize.			caseExits _ OrderedCollection new.			statements _ OrderedCollection new: 20.			super method: method pc: method initialPC.			block _ self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^constructor		codeMethod: aSelector		block: block		tempVars: tempVars		primitive: method primitive		class: aClass! !!Decompiler methodsFor: 'instruction decoding' stamp: 'ls 1/28/2004 13:27'!case: dist	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |	nextCase _ pc + dist.	"Now add CascadeFlag & keyValueBlock to statements"	statements addLast: stack removeLast.	stack addLast: CaseFlag. "set for next pop"	statements addLast: (self blockForCaseTo: nextCase).	stack last == CaseFlag		ifTrue: "Last case"			["ensure jump is within block (in case thenExpr returns wierdly I guess)"			stack removeLast. "get rid of CaseFlag"			stmtStream _ ReadStream on: (self popTo: stack removeLast).						elements _ OrderedCollection new.			b _ OrderedCollection new.			[stmtStream atEnd] whileFalse:				[(node _ stmtStream next) == CascadeFlag					ifTrue:						[elements addLast: (constructor							codeMessage: (constructor codeBlock: b returns: false)							selector: (constructor codeSelector: #-> code: #macro)							arguments: (Array with: stmtStream next)).						 b _ OrderedCollection new]					ifFalse: [b addLast: node]].			b size > 0 ifTrue: [self error: 'Bad cases'].			cases _ constructor codeBrace: elements.						"try find the end of the case"			myExits := caseExits removeLast: elements size.			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method size ] ] ].			myExits isEmpty				ifTrue: [ thenJump := nextCase ]				ifFalse: [ thenJump := myExits min ].						otherBlock _ self blockTo: thenJump.			stack addLast:				(constructor					codeMessage: stack removeLast					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)					arguments: (Array with: cases with: otherBlock)).								myExits isEmpty ifTrue:[				"all branches returned; pop off the statement"				statements addLast: stack removeLast. ] ].! !!Decompiler methodsFor: 'public access' stamp: 'ls 1/28/2004 13:10'!decompileBlock: aBlock 	"Original version timestamp: sn 1/26/98 18:27	(Don't know who's sn?) "	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode tempNames home source |	(home _ aBlock home) ifNil: [^ nil].	method _ home method.	(homeClass _ home who first) == #unknown ifTrue: [^ nil].	constructor _ DecompilerConstructor new.	method fileIndex ~~ 0		ifTrue: ["got any source code?"			source _ [method getSourceFromFile]						on: Error						do: [:ex | ^ nil].			tempNames _ ([homeClass compilerClass new						parse: source						in: homeClass						notifying: nil]						on: (Smalltalk classNamed: 'SyntaxErrorNotification')						do: [:ex | ^ nil]) tempNames.			self withTempNames: tempNames].	self initSymbols: homeClass.	startpc _ aBlock startpc.	end _ (method at: startpc - 2)				\\ 16 - 4 * 256				+ (method at: startpc - 1) + startpc - 1.	stack _ OrderedCollection new: method frameSize.	caseExits _ OrderedCollection new.	statements _ OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode _ self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^ blockNode statements first! !!Decompiler class methodsFor: 'testing' stamp: 'ls 1/29/2004 23:54'!recompileAllTest	"[Decompiler recompileAllTest]"	"decompile every method and compile it back; if the decompiler is correct then the system should keep running.  :)"		| decompiled ast compiled |	SystemNavigation default allBehaviorsDo: [ :behavior |		Utilities informUser: (behavior printString) during: [			behavior selectors do: [ :sel |				decompiled := Decompiler new decompile: sel in: behavior.				ast := Compiler new compile: decompiled in: behavior notifying: nil ifFail: [ self error: 'failed' ].				compiled := ast generate: (behavior compiledMethodAt: sel) trailer.				behavior addSelector: sel withMethod: compiled. ] ] ]! !!ISOLanguageDefinition class methodsFor: 'private' stamp: 'mir 7/1/2004 18:18'!isoLanguages	"ISO 639: 3-letter codes"	^'abk	ab	Abkhazianace		Achineseach		Acoliada		Adangmeaar	aa	Afarafh		Afrihiliafr	af	Afrikaansafa		Afro-Asiatic (Other)aka		Akanakk		Akkadianalb/sqi	sq	Albanianale		Aleutalg		Algonquian languagestut		Altaic (Other)amh	am	Amharicapa		Apache languagesara	ar	Arabicarc		Aramaicarp		Arapahoarn		Araucanianarw		Arawakarm/hye	hy	Armenianart		Artificial (Other)asm	as	Assameseath		Athapascan languagesmap		Austronesian (Other)ava		Avaricave		Avestanawa		Awadhiaym	ay	Aymaraaze	az	Azerbaijaninah		Aztecban		Balinesebat		Baltic (Other)bal		Baluchibam		Bambarabai		Bamileke languagesbad		Bandabnt		Bantu (Other)bas		Basabak	ba	Bashkirbaq/eus	eu	Basquebej		Bejabem		Bembaben	bn	Bengaliber		Berber (Other)bho		Bhojpuribih	bh	Biharibik		Bikolbin		Binibis	bi	Bislamabra		Brajbre	be	Bretonbug		Buginesebul	bg	Bulgarianbua		Buriatbur/mya	my	Burmesebel	be	Byelorussiancad		Caddocar		Caribcat	ca	Catalancau		Caucasian (Other)ceb		Cebuanocel		Celtic (Other)cai		Central American Indian (Other)chg		Chagataicha		Chamorroche		Chechenchr		Cherokeechy		Cheyennechb		Chibchachi/zho	zh	Chinesechn		Chinook jargoncho		Choctawchu		Church Slavicchv		Chuvashcop		Copticcor		Cornishcos	co	Corsicancre		Creemus		Creekcrp		Creoles and Pidgins (Other)cpe		Creoles and Pidgins, English-based (Other)cpf		Creoles and Pidgins, French-based (Other)cpp		Creoles and Pidgins, Portuguese-based (Other)cus		Cushitic (Other)	hr	Croatiances/cze	cs	Czechdak		Dakotadan	da	Danishdel		Delawaredin		Dinkadiv		Divehidoi		Dogridra		Dravidian (Other)dua		Dualadut/nla	nl	Dutchdum		Dutch, Middle (ca. 1050-1350)dyu		Dyuladzo	dz	Dzongkhaefi		Efikegy		Egyptian (Ancient)eka		Ekajukelx		Elamiteeng	en	Englishenm		English, Middle (ca. 1100-1500)ang		English, Old (ca. 450-1100)esk		Eskimo (Other)epo	eo	Esperantoest	et	Estonianewe		Eweewo		Ewondofan		Fangfat		Fantifao	fo	Faroesefij	fj	Fijianfin	fi	Finnishfiu		Finno-Ugrian (Other)fon		Fonfra/fre	fr	Frenchfrm		French, Middle (ca. 1400-1600)fro		French, Old (842- ca. 1400)fry	fy	Frisianful		Fulahgaa		Gagae/gdh		Gaelic (Scots)glg	gl	Galleganlug		Gandagay		Gayogez		Geezgeo/kat	ka	Georgiandeu/ger	de	Germangmh		German, Middle High (ca. 1050-1500)goh		German, Old High (ca. 750-1050)gem		Germanic (Other)gil		Gilbertesegon		Gondigot		Gothicgrb		Grebogrc		Greek, Ancient (to 1453)ell/gre	el	Greek, Modern (1453-)kal	kl	Greenlandicgrn	gn	Guaraniguj	gu	Gujaratihai		Haidahau	ha	Hausahaw		Hawaiianheb	he	Hebrewher		Hererohil		Hiligaynonhim		Himachalihin	hi	Hindihmo		Hiri Motuhun	hu	Hungarianhup		Hupaiba		Ibanice/isl	is	Icelandicibo		Igboijo		Ijoilo		Ilokoinc		Indic (Other)ine		Indo-European (Other)ind	id	Indonesianina	ia	Interlingua (International Auxiliary language Association)ine		 Interlingueiku	iu	Inuktitutipk	ik	Inupiakira		Iranian (Other)gai/iri	ga	Irishsga		Irish, Old (to 900)mga		Irish, Middle (900 - 1200)iro		Iroquoian languagesita	it	Italianjpn	ja	Japanesejav/jaw	jv/jw Javanesejrb		Judeo-Arabicjpr		Judeo-Persiankab		Kabylekac		Kachinkam		Kambakan	kn	Kannadakau		Kanurikaa		Kara-Kalpakkar		Karenkas	ks	Kashmirikaw		Kawikaz	kk	Kazakhkha		Khasikhm	km	Khmerkhi		Khoisan (Other)kho		Khotanesekik		Kikuyukin	rw	Kinyarwandakir	ky	Kirghizkom		Komikon		Kongokok		Konkanikor	ko	Koreankpe		Kpellekro		Krukua		Kuanyamakum		Kumykkur	ku	Kurdishkru		Kurukhkus		Kusaiekut		Kutenailad		Ladinolah		Lahndalam		Lambaoci	oc	Langue d''Oc (post 1500)lao	lo	Laolat	la	Latinlav	lv	Latvianltz		Letzeburgeschlez		Lezghianlin	ln	Lingalalit	lt	Lithuanianloz		Lozilub		Luba-Katangalui		Luisenolun		Lundaluo		Luo (Kenya and Tanzania)mac/mak	mk	Macedonianmad		Maduresemag		Magahimai		Maithilimak		Makasarmlg	mg	Malagasymay/msa	ms	Malaymal		Malayalammlt	ml	Malteseman		Mandingomni		Manipurimno		Manobo languagesmax		Manxmao/mri	mi	Maorimar	mr	Marathichm		Marimah		Marshallmwr		Marwarimas		Masaimyn		Mayan languagesmen		Mendemic		Micmacmin		Minangkabaumis		Miscellaneous (Other)moh		Mohawkmol	mo	Moldavianmkh		Mon-Kmer (Other)lol		Mongomon	mn	Mongolianmos		Mossimul		Multiple languagesmun		Munda languagesnau	na	Naurunav		Navajonde		Ndebele, Northnbl		Ndebele, Southndo		Ndongonep	ne	Nepalinew		Newarinic		Niger-Kordofanian (Other)ssa		Nilo-Saharan (Other)niu		Niueannon		Norse, Oldnai		North American Indian (Other)nor	no	Norwegiannno		Norwegian (Nynorsk)nub		Nubian languagesnym		Nyamwezinya		Nyanjanyn		Nyankolenyo		Nyoronzi		Nzimaoji		Ojibwaori	or	Oriyaorm	om	Oromoosa		Osageoss		Osseticoto		Otomian languagespal		Pahlavipau		Palauanpli		Palipam		Pampangapag		Pangasinanpan	pa	Panjabipap		Papiamentopaa		Papuan-Australian (Other)fas/per	fa	Persianpeo		Persian, Old (ca 600 - 400 B.C.)phn		Phoenicianpol	pl	Polishpon		Ponapepor	pt	Portuguesepra		Prakrit languagespro		Provencal, Old (to 1500)pus	ps	Pushtoque	qu	Quechuaroh	rm	Rhaeto-Romanceraj		Rajasthanirar		Rarotonganroa		Romance (Other)ron/rum	ro	Romanianrom		Romanyrun	rn	Rundirus	ru	Russiansal		Salishan languagessam		Samaritan Aramaicsmi		Sami languagessmo	sm	Samoansad		Sandawesag	sg	Sangosan	sa	Sanskritsrd		Sardiniansco		Scotssel		Selkupsem		Semitic (Other)	sr	Serbianscr	sh	Serbo-Croatiansrr		Serershn		Shansna	sn	Shonasid		Sidamobla		Siksikasnd	sd	Sindhisin	si	Singhalesesit		Sino-Tibetan (Other)sio		Siouan languagessla		Slavic (Other)ssw	ss	Siswantslk/slo	sk	Slovakslv	sl	Sloveniansog		Sogdiansom	so	Somalison		Songhaiwen		Sorbian languagesnso		Sotho, Northernsot	st	Sotho, Southernsai		South American Indian (Other)esl/spa	es	Spanishsuk		Sukumasux		Sumeriansun	su	Sudanesesus		Sususwa	sw	Swahilissw		Swazisve/swe	sv	Swedishsyr		Syriactgl	tl	Tagalogtah		Tahitiantgk	tg	Tajiktmh		Tamashektam	ta	Tamiltat	tt	Tatartel	te	Teluguter		Terenotha	th	Thaibod/tib	bo	Tibetantig		Tigretir	ti	Tigrinyatem		Timnetiv		Tivitli		Tlingittog	to	Tonga (Nyasa)ton		Tonga (Tonga Islands)tru		Truktsi		Tsimshiantso	ts	Tsongatsn	tn	Tswanatum		Tumbukatur	tr	Turkishota		Turkish, Ottoman (1500 - 1928)tuk	tk	Turkmentyv		Tuviniantwi	tw	Twiuga		Ugariticuig	ug	Uighurukr	uk	Ukrainianumb		Umbunduund		Undeterminedurd	ur	Urduuzb	uz	Uzbekvai		Vaiven		Vendavie	vi	Vietnamesevol	vo	Volap¬¨¬®¬¶¬kvot		Voticwak		Wakashan languageswal		Walamowar		Waraywas		Washocym/wel	cy	Welshwol	wo	Wolofxho	xh	Xhosasah		Yakutyao		Yaoyap		Yapyid	yi	Yiddishyor	yo	Yorubazap		Zapoteczen		Zenagazha	za	Zhuangzul	zu	Zuluzun		Zuni'! !!ISOLanguageDefinition class methodsFor: 'private' stamp: 'mir 7/15/2004 18:10'!isoCountryString	"This list states the country names (official short names in English) in alphabetical order as given in ISO 3166-1 and the corresponding ISO 3166-1-alpha-2 code elements. The list is updated whenever a change to the official code list in ISO 3166-1 is effected by the ISO 3166/MA. It lists 240 official short names and code elements. One line of text contains one entry. A country name and its code element are separated by a semicolon (;)."	^'AF	AFGHANISTANAX	¬¨¬®¬¶¦ñLAND ISLANDSAL	ALBANIADZ	ALGERIAAS	AMERICAN SAMOAAD	ANDORRAAO	ANGOLAAI	ANGUILLAAQ	ANTARCTICAAG	ANTIGUA AND BARBUDAAR	ARGENTINAAM	ARMENIAAW	ARUBAAU	AUSTRALIAAT	AUSTRIAAZ	AZERBAIJANBS	BAHAMASBH	BAHRAINBD	BANGLADESHBB	BARBADOSBY	BELARUSBE	BELGIUMBZ	BELIZEBJ	BENINBM	BERMUDABT	BHUTANBO	BOLIVIABA	BOSNIA AND HERZEGOVINABW	BOTSWANABV	BOUVET ISLANDBR	BRAZILIO	BRITISH INDIAN OCEAN TERRITORYBN	BRUNEI DARUSSALAMBG	BULGARIABF	BURKINA FASOBI	BURUNDIKH	CAMBODIACM	CAMEROONCA	CANADACV	CAPE VERDEKY	CAYMAN ISLANDSCF	CENTRAL AFRICAN REPUBLICTD	CHADCL	CHILECN	CHINACX	CHRISTMAS ISLANDCC	COCOS (KEELING) ISLANDSCO	COLOMBIAKM	COMOROSCG	CONGOCD	CONGO, THE DEMOCRATIC REPUBLIC OF THECK	COOK ISLANDSCR	COSTA RICACI	COTE D''IVOIREHR	CROATIACU	CUBACY	CYPRUSCZ	CZECH REPUBLICDK	DENMARKDJ	DJIBOUTIDM	DOMINICADO	DOMINICAN REPUBLICEC	ECUADOREG	EGYPTSV	EL SALVADORGQ	EQUATORIAL GUINEAER	ERITREAEE	ESTONIAET	ETHIOPIAFK	FALKLAND ISLANDS (MALVINAS)FO	FAROE ISLANDSFJ	FIJIFI	FINLANDFR	FRANCEGF	FRENCH GUIANAPF	FRENCH POLYNESIATF	FRENCH SOUTHERN TERRITORIESGA	GABONGM	GAMBIAGE	GEORGIADE	GERMANYGH	GHANAGI	GIBRALTARGR	GREECEGL	GREENLANDGD	GRENADAGP	GUADELOUPEGU	GUAMGT	GUATEMALAGN	GUINEAGW	GUINEA-BISSAUGY	GUYANAHT	HAITIHM	HEARD ISLAND AND MCDONALD ISLANDSVA	HOLY SEE (VATICAN CITY STATE)HN	HONDURASHK	HONG KONGHU	HUNGARYIS	ICELANDIN	INDIAID	INDONESIAIR	IRAN, ISLAMIC REPUBLIC OFIQ	IRAQIE	IRELANDIL	ISRAELIT	ITALYJM	JAMAICAJP	JAPANJO	JORDANKZ	KAZAKHSTANKE	KENYAKI	KIRIBATIKP	KOREA, DEMOCRATIC PEOPLE''S REPUBLIC OFKR	KOREA, REPUBLIC OFKW	KUWAITKG	KYRGYZSTANLA	LAO PEOPLE''S DEMOCRATIC REPUBLICLV	LATVIALB	LEBANONLS	LESOTHOLR	LIBERIALY	LIBYAN ARAB JAMAHIRIYALI	LIECHTENSTEINLT	LITHUANIALU	LUXEMBOURGMO	MACAOMK	MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OFMG	MADAGASCARMW	MALAWIMY	MALAYSIAMV	MALDIVESML	MALIMT	MALTAMH	MARSHALL ISLANDSMQ	MARTINIQUEMR	MAURITANIAMU	MAURITIUSYT	MAYOTTEMX	MEXICOFM	MICRONESIA, FEDERATED STATES OFMD	MOLDOVA, REPUBLIC OFMC	MONACOMN	MONGOLIAMS	MONTSERRATMA	MOROCCOMZ	MOZAMBIQUEMM	MYANMARNA	NAMIBIANR	NAURUNP	NEPALNL	NETHERLANDSAN	NETHERLANDS ANTILLESNC	NEW CALEDONIANZ	NEW ZEALANDNI	NICARAGUANE	NIGERNG	NIGERIANU	NIUENF	NORFOLK ISLANDMP	NORTHERN MARIANA ISLANDSNO	NORWAYOM	OMANPK	PAKISTANPW	PALAUPS	PALESTINIAN TERRITORY, OCCUPIEDPA	PANAMAPG	PAPUA NEW GUINEAPY	PARAGUAYPE	PERUPH	PHILIPPINESPN	PITCAIRNPL	POLANDPT	PORTUGALPR	PUERTO RICOQA	QATARRE	REUNIONRO	ROMANIARU	RUSSIAN FEDERATIONRW	RWANDASH	SAINT HELENAKN	SAINT KITTS AND NEVISLC	SAINT LUCIAPM	SAINT PIERRE AND MIQUELONVC	SAINT VINCENT AND THE GRENADINESWS	SAMOASM	SAN MARINOST	SAO TOME AND PRINCIPESA	SAUDI ARABIASN	SENEGALCS	SERBIA AND MONTENEGROSC	SEYCHELLESSL	SIERRA LEONESG	SINGAPORESK	SLOVAKIASI	SLOVENIASB	SOLOMON ISLANDSSO	SOMALIAZA	SOUTH AFRICAGS	SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDSES	SPAINLK	SRI LANKASD	SUDANSR	SURINAMESJ	SVALBARD AND JAN MAYENSZ	SWAZILANDSE	SWEDENCH	SWITZERLANDSY	SYRIAN ARAB REPUBLICTW	TAIWAN, PROVINCE OF CHINATJ	TAJIKISTANTZ	TANZANIA, UNITED REPUBLIC OFTH	THAILANDTL	TIMOR-LESTETG	TOGOTK	TOKELAUTO	TONGATT	TRINIDAD AND TOBAGOTN	TUNISIATR	TURKEYTM	TURKMENISTANTC	TURKS AND CAICOS ISLANDSTV	TUVALUUG	UGANDAUA	UKRAINEAE	UNITED ARAB EMIRATESGB	UNITED KINGDOMUS	UNITED STATESUM	UNITED STATES MINOR OUTLYING ISLANDSUY	URUGUAYUZ	UZBEKISTANVU	VANUATUVE	VENEZUELAVN	VIET NAMVG	VIRGIN ISLANDS, BRITISHVI	VIRGIN ISLANDS, U.S.WF	WALLIS AND FUTUNAEH	WESTERN SAHARAYE	YEMENZM	ZAMBIAZW	ZIMBABWE'! !!DataStream methodsFor: 'write and read' stamp: ''!readFloatString	"PRIVATE -- Read the contents of a Float string.	 This is the slow way to read a Float--via its string rep¬¨¦n.	 It's here for compatibility with old data files."	^ Float readFrom: (byteStream next: (byteStream nextNumber: 4))! !!DataStream methodsFor: 'write and read' stamp: ''!tryToPutReference: anObject typeID: typeID    "PRIVATE -- If we support references for type typeID, and if       anObject already appears in my output stream, then put a       reference to the place where anObject already appears. If we       support references for typeID but didn¬¨¦t already put anObject,       then associate the current stream position with anObject in       case one wants to nextPut: it again.     Return true after putting a reference; false if the object still       needs to be put.     For DataStream this is trivial. ReferenceStream overrides this."    ^ false! !!DataStream methodsFor: 'write and read' stamp: ''!writeFloatString: aFloat    "PRIVATE -- Write the contents of a Float string.     This is the slow way to write a Float--via its string rep¬¨¦n."    self writeByteArray: (aFloat printString)! !!DataStream methodsFor: 'write and read' stamp: ''!noteCurrentReference: typeID    "PRIVATE -- If we support references for type typeID, remember     the current byteStream position so we can add the next object to     the ¬¨¦´objects¬¨¦ dictionary, and return true. Else return false.     This method is here to be overridden by ReferenceStream"    ^ false! !!DataStream methodsFor: 'write and read' stamp: ''!beginReference: anObject    "We¬¨¦re starting to read anObject. Remember it and its reference     position (if we care; ReferenceStream cares). Answer the     reference position."    ^ 0! !!DataStream methodsFor: 'other' stamp: ''!errorWriteReference: anInteger    "PRIVATE -- Raise an error because this case of nextPut:¬¨¦s perform:     shouldn't be called. -- 11/15/92 jhm"    self error: 'This should never be called'! !!AutoStart class methodsFor: 'class initialization' stamp: 'mir 9/30/2004 15:08'!startUp: resuming	"The image is either being newly started (resuming is true), or it's just been snapshotted.	If this has just been a snapshot, skip all the startup stuff."	| startupParameters launchers |	self active ifTrue: [^self].	self active: true.	resuming ifFalse: [^self].	HTTPClient determineIfRunningInBrowser.	startupParameters _ AbstractLauncher extractParameters.	(startupParameters includesKey: 'apiSupported' asUppercase )		ifTrue: [			HTTPClient browserSupportsAPI: ((startupParameters at: 'apiSupported' asUppercase) asUppercase = 'TRUE').			HTTPClient isRunningInBrowser				ifFalse: [HTTPClient isRunningInBrowser: true]].	self checkForUpdates		ifTrue: [^self].	self checkForPluginUpdate.	launchers _ self installedLaunchers collect: [:launcher |		launcher new].	launchers do: [:launcher |		launcher parameters: startupParameters].	launchers do: [:launcher |		Smalltalk at: #WorldState ifPresent: [ :ws | ws addDeferredUIMessage: [launcher startUp]]].! !!AutoStart class methodsFor: 'class initialization' stamp: 'mir 9/30/2004 15:05'!initialize	"AutoStart initialize"	"Order: ExternalSettings, SecurityManager, AutoStart"	Smalltalk addToStartUpList: AutoStart after: SecurityManager.	Smalltalk addToShutDownList: AutoStart after: SecurityManager.! !!AutoStart class methodsFor: 'class initialization' stamp: 'mir 9/30/2004 15:06'!shutDown: quitting	self active: false! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nk 8/21/2004 14:51'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse internalStream |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	(Preferences warningForMacOSFileNameLength			and: [nameToUse size > 30])		ifTrue: [nameToUse := FillInTheBlank						request: (nameToUse , '\has ' , nameToUse size asString , ' letters - too long for Mac OS.\Suggested replacement is:') withCRs						initialAnswer: (nameToUse contractTo: 30).			nameToUse = ''				ifTrue: [^ self]].	nameToUse := self defaultChangeSetDirectory fullNameFor: nameToUse.	Cursor write showWhile: [			internalStream _ WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!CompoundTileMorph methodsFor: 'access' stamp: 'nk 10/14/2004 11:37'!myMorph	^nil! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'nk 10/8/2004 11:56'!updateWordingToMatchVocabulary	| labels |	labels _ OrderedCollection new.	self submorphs do: [:submorph |		submorph submorphs do: [:subsubmorph |			subsubmorph class == StringMorph ifTrue: [labels add: subsubmorph]]].	labels do: [:label | label knownName ifNotNilDo: [ :nm | label acceptValue: nm translated ]]! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'nk 7/18/2003 16:35'!firstColor: aColor forMorph: aMorph hand: aHand	colorRamp first value: aColor.	isTranslucent _ nil.	pixelRamp _ nil.	aMorph changed.! !!GradientFillStyle methodsFor: 'Morphic menu' stamp: 'nk 7/18/2003 16:35'!lastColor: aColor forMorph: aMorph hand: aHand	colorRamp last value: aColor.	isTranslucent _ nil.	pixelRamp _ nil.	aMorph changed.! !!ScriptableButton methodsFor: 'button' stamp: 'bf 9/20/2004 11:10'!doButtonAction	"The user has pressed the button.  Dispatch to the actual user script, if any."	scriptSelector ifNil: [^ super doButtonAction].	self pasteUpMorph player performScriptIfCan: scriptSelector! !!SpeakerMorph methodsFor: 'initialization' stamp: 'nk 6/12/2004 10:05'!addGraphic	| graphic |	graphic _ World drawingClass withForm: self speakerGraphic.	graphic position: bounds center - (graphic extent // 2).	self addMorph: graphic.! !!UserCustomEventNameType methodsFor: 'initialization' stamp: 'nk 7/21/2003 20:42'!initialize	"Initialize the CustomEvents vocabulary"	super initialize.	self vocabularyName: #CustomEvents! !!UserCustomEventNameType methodsFor: 'tiles' stamp: 'nk 8/18/2004 17:48'!representsAType	"Answer whether this vocabulary represents an end-user-sensible data type"	^true! !!UserCustomEventNameType methodsFor: 'queries' stamp: 'nk 9/26/2003 23:36'!choices	"Answer an alphabetized list of known user custom event selectors"	| choices |	choices _ ScriptingSystem userCustomEventNames.	^choices isEmpty ifTrue: [ #('no event') ] ifFalse: [ choices ]! !!UserCustomEventNameType class methodsFor: 'class initialization' stamp: 'nk 8/18/2004 18:02'!initialize	Vocabulary embraceAddedTypeVocabularies.	Preferences		addPreference: #allowEtoyUserCustomEvents		categories:  #('scripting')		default: false		balloonHelp: 'If true, you can define your own events that can trigger scripts within a World.'		projectLocal:  false		changeInformee:  self		changeSelector: #allowEtoyUserCustomEventsPreferenceChanged! !!UserCustomEventNameType class methodsFor: 'class initialization' stamp: 'nk 6/12/2004 14:18'!allowEtoyUserCustomEventsPreferenceChanged	Cursor wait showWhile: [ Vocabulary changeMadeToViewerAdditions ]! !!Debugger methodsFor: 'private' stamp: 'jm 5/1/1998 16:20'!lowSpaceChoices	"Return a notifier message string to be presented when space is running low."	^ 'Warning!! Squeak is almost out of memory!!Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.Here are some suggestions:¬¨¦â If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem.¬¨¦â If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...   > Close any windows that are not needed.   > Get rid of some large objects (e.g., images).   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window.¬¨¦â If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep. (Trying to show the full stack will definitely use up all remaining memory if the low-space problem is caused by an infinite recursion!!).'! !!LocaleID methodsFor: 'accessing' stamp: 'dgd 10/7/2004 21:16'!displayName	"Answer a proper name to represent the receiver in GUI. 	 	The wording is provided by translations of the magic value 	'<language display name>'. 	 	'English' -> 'English'  	'German' -> 'Deutsch'  	"	| magicPhrase translatedMagicPhrase |	magicPhrase := '<language display name>'.	translatedMagicPhrase := magicPhrase translatedTo: self.	^ translatedMagicPhrase = magicPhrase		ifTrue: [self displayLanguage]		ifFalse: [translatedMagicPhrase]! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'nk 8/18/2004 16:43'!addProgressDecoration: extraParam 	| f m |	targetMorph ifNil: [^self].	(extraParam isForm) 		ifTrue: 			[targetMorph 				submorphsDo: [:mm | (mm isSketchMorph) ifTrue: [mm delete]].			f := Form extent: extraParam extent depth: extraParam depth.			extraParam displayOn: f.			m := SketchMorph withForm: f.			m align: m fullBounds leftCenter				with: targetMorph fullBounds leftCenter + (2 @ 0).			targetMorph addMorph: m.			^self].	(extraParam isString) 		ifTrue: 			[targetMorph 				submorphsDo: [:mm | (mm isKindOf: StringMorph) ifTrue: [mm delete]].			m := StringMorph contents: extraParam translated.			m align: m fullBounds bottomCenter + (0 @ 8)				with: targetMorph bounds bottomCenter.			targetMorph addMorph: m.			^self]! !!SyntaxError methodsFor: 'initialization' stamp: 'tk 5/6/1999 13:28'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Scanner classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,¬¨¬è¬¨¬£¬¨¬¢¬¨¦ü¬¨¬é¬¨¬ô¬¨¬ù¬¨¦±¬¨¦¬¨¦¨¬¨¦´¬¨¦Æ¬¨¦¬¨¦ñ¬¶¦¬¶¬¬¶¦¬¨¦ò¬¶¦¬¨¦¬¨¬¥¬¨¬`~`' asSet.	badChar _ aString detect: [:aChar | (types at: aChar asciiValue) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents _ badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SketchMorph methodsFor: 'menu' stamp: 'nk 6/12/2004 10:04'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue: [		aTarget _ aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!SketchMorph methodsFor: 'accessing' stamp: 'nk 1/24/2004 23:46'!useInterpolation: aBool	(aBool == true and: [ Smalltalk includesKey: #B3DRenderEngine ])		ifTrue:[self setProperty: #useInterpolation toValue: aBool]		ifFalse:[self removeProperty: #useInterpolation].	self layoutChanged. "to regenerate the form"! !!SketchMorph methodsFor: 'accessing' stamp: 'nk 6/12/2004 09:32'!wantsSimpleSketchMorphHandles	"Answer true if my halo's simple handles should include the simple sketch morph handles."	^self isMemberOf: SketchMorph! !!SketchMorph methodsFor: 'geometry' stamp: 'nk 1/10/2004 14:51'!extent: newExtent	"Change my scale to fit myself into the given extent.	Avoid extents where X or Y is zero."	(newExtent y = 0 or: [ newExtent x = 0 ]) ifTrue: [ ^self ].	self extent = newExtent ifTrue:[^self].	scalePoint _ newExtent asFloatPoint / (originalForm extent max: 1@1).	self layoutChanged.! !!SketchMorph methodsFor: 'e-toy support' stamp: 'nk 6/12/2004 10:04'!asWearableCostume	"Return a wearable costume for some player"	^(World drawingClass withForm: originalForm) copyCostumeStateFrom: self! !!SketchMorph methodsFor: 'e-toy support' stamp: 'nk 6/12/2004 10:04'!acquirePlayerSimilarTo: aSketchMorphsPlayer	"Retrofit into the receiver a player derived from the existing scripted player of a different morph.  Works only between SketchMorphs. Maddeningly complicated by potential for transformations or native sketch-morph scaling in donor or receiver or both"	| myName myTop itsTop newTop newSketch |	myTop _ self topRendererOrSelf.	aSketchMorphsPlayer belongsToUniClass ifFalse: [^ Beeper beep].	itsTop _ aSketchMorphsPlayer costume.	(itsTop renderedMorph isSketchMorph)		ifFalse:	[^ Beeper beep].	newTop _ itsTop veryDeepCopy.  "May be a sketch or a tranformation"	myName _ myTop externalName.  "Snag before the replacement is added to the world, because otherwise that could affect this"	newSketch _ newTop renderedMorph.	newSketch form: self form.	newSketch scalePoint: self scalePoint.	newSketch bounds: self bounds.	myTop owner addMorph: newTop after: myTop.	newTop heading ~= myTop heading ifTrue:		"avoids annoying round-off error in what follows"			[newTop player setHeading: myTop heading]. 	(newTop isFlexMorph and: [myTop == self])		ifTrue:			[newTop removeFlexShell].	newTop _ newSketch topRendererOrSelf.	newTop bounds: self bounds.	(newTop isFlexMorph and:[myTop isFlexMorph]) ifTrue:[		"Note: This completely dumps the above #bounds: information.		We need to recompute the bounds based on the transform."		newTop transform: myTop transform copy.		newTop computeBounds].	newTop setNameTo: myName.	newTop player class bringScriptsUpToDate.	myTop delete! !!SketchMorph class methodsFor: 'testing' stamp: 'nk 6/12/2004 09:16'!isSketchMorphClass	^true! !!String methodsFor: 'converting' stamp: 'sw 9/1/2000 10:39'!asCharacter	"Answer the receiver's first character, or '¬¨¬è' if none.  Idiosyncratic, provisional."	^ self size > 0 ifTrue: [self first] ifFalse: [$¬¨¬è]! !!String methodsFor: 'converting' stamp: 'tk 4/13/2002 09:13'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in _ ReadStream on: self.	out _ WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char _ in next) = $&						ifTrue: [rest _ in upTo: $;.								did _ out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								rest = 'deg' ifTrue: [out nextPut: $¬¨¬Å].								rest = 'quot' ifTrue: [out nextPut: $"].								did = out position ifTrue: [									self error: 'unknown encoded HTML char'.									"Please add it to this method"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'bf 10/6/2004 19:13'!clipboardInterpreterClass	^ MacRomanClipboardInterpreter! !!SimpleHierarchicalListMorph methodsFor: 'geometry' stamp: 'nk 7/11/2004 20:07'!extent: newExtent	bounds extent = newExtent ifTrue: [^ self].	super extent: newExtent.	self setScrollDeltas ! !!TileLikeMorph methodsFor: 'user interface' stamp: 'nk 10/8/2004 15:11'!fixLayout	"Having just been loaded from a project, do repairs as needed."	self minCellSize: 0 @ (Preferences standardEToysFont height rounded + 10).	self allMorphsDo: [:m | (m isKindOf: StringMorph)				ifTrue: [m font: Preferences standardEToysFont;						 fitContents].		(m respondsTo: #fixLayout)			ifTrue: [ m ~~ self ifTrue: [ m fixLayout ] ]			ifFalse: [ m layoutChanged ] ].	self layoutChanged; fullBounds! !!TileLikeMorph methodsFor: 'user interface' stamp: 'nk 10/8/2004 15:13'!unhibernate	self fixLayout.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 10/8/2004 09:43'!deliverPainting: result evt: evt	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm ans |	palette ifNotNil: "nil happens" [palette setAction: #paint: evt: evt].	"Get out of odd modes"	"rot _ palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [		ans _ PopUpMenu withCaption: 'Do you really want to throw away what you just painted?' translated 				chooseFrom: 'throw it away\keep painting it' translated.		^ ans = 1 ifTrue: [self cancelOutOfPainting]				ifFalse: [nil]].	"for Morphic"	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox _ paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.	registrationPoint ifNotNil:		[registrationPoint _ registrationPoint - newBox origin]. "relative to newForm origin"	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	newForm fixAlpha. "so alpha channel stays intact for 32bpp"	self delete.	"so won't find me again"	dimForm ifNotNil: [dimForm delete].	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).! !!RectangleMorph class methodsFor: 'as yet unclassified' stamp: 'nk 9/7/2004 11:44'!roundRectPrototype	^ self authoringPrototype useRoundedCorners 		color: ((Color r: 1.0 g: 0.3 b: 0.6) alpha: 0.5); 		borderWidth: 1;		setNameTo: 'RoundRect'! !!TextMorph methodsFor: 'scripting access' stamp: 'dgd 2/21/2003 22:31'!setAllButFirstCharacter: source 	"Set all but the first char of the receiver to the source"	| aChar chars |	aChar _ source asCharacter.	(chars _ self getCharacters) isEmpty		ifTrue: [self newContents: '¬¨¬è' , source asString]		ifFalse: [chars first = aChar				ifFalse: [""					self						newContents: (String								streamContents: [:aStream | 									aStream nextPut: chars first.									aStream nextPutAll: source])]] ! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 9/15/2000 06:14'!getAllButFirstCharacter	"Obtain all but the first character from the receiver; if that would be empty, return a black dot"	| aString |	^ (aString _ text string) size > 1 ifTrue: [aString copyFrom: 2 to: aString size] ifFalse: ['¬¨¬è']! !!TextMorph methodsFor: 'accessing' stamp: 'sw 8/10/2004 00:53'!getLastCharacter	"obtain the last character from the receiver if it is empty, return a black dot"	| aString |	^ (aString _ text string) size > 0 ifTrue: [aString last asString] ifFalse: ['¬¨¬è']! !!TextMorph methodsFor: 'accessing' stamp: 'kfr 9/21/2003 21:47'!getFirstCharacter	"obtain the first character from the receiver if it is empty, return a  	black dot"	| aString |	^ (aString _ text string) isEmpty		ifTrue: ['¬¨¬è']		ifFalse: [aString first asString] ! !!TextMorph methodsFor: 'menu' stamp: 'nk 3/10/2004 12:09'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'text color...' translated action: #changeTextColor.	aCustomMenu addUpdating: #autoFitString target: self action: #autoFitOnOff.	aCustomMenu addUpdating: #wrapString target: self action: #wrapOnOff.	aCustomMenu add: 'text margins...' translated action: #changeMargins:.	aCustomMenu add: 'add predecessor' translated action: #addPredecessor:.	aCustomMenu add: 'add successor' translated action: #addSuccessor:.	(Preferences noviceMode			or: [Preferences simpleMenus])		ifFalse: [aCustomMenu add: 'code pane menu...' translated action: #yellowButtonActivity.			aCustomMenu add: 'code pane shift menu...' translated action: #shiftedYellowButtonActivity].	outer _ self owner.	outer isLineMorph ifTrue:		[container isNil			ifTrue: [aCustomMenu add: 'follow owner''s curve' translated action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' translated action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' translated action: #setCurveBaseline:]]		ifFalse:		[(container isNil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' translated action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangular bounds' translated action: #fillingOnOff].		(container isNil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' translated action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' translated action: #occlusionsOnOff]].	aCustomMenu addLine.	aCustomMenu add: 'holder for characters' translated action: #holderForCharacters! !!TextMorph methodsFor: 'geometry' stamp: 'nk 7/11/2004 20:07'!extent: aPoint 	| newExtent priorEditor |	bounds extent = aPoint ifTrue: [^ self].	priorEditor _ editor.	self isAutoFit		ifTrue: [wrapFlag ifFalse: [^ self].  "full autofit can't change"				newExtent _ aPoint truncated max: self minimumExtent.				newExtent x = self extent x ifTrue: [^ self].  "No change of wrap width"				self releaseParagraphReally.  "invalidate the paragraph cache"				super extent: newExtent.				priorEditor					ifNil: [self fit]  "since the width has changed..."					ifNotNil: [self installEditorToReplace: priorEditor]]		ifFalse: [super extent: (aPoint truncated max: self minimumExtent).				wrapFlag ifFalse: [^ self].  "no effect on composition"				self composeToBounds]! !!PortugueseLexiconServer methodsFor: 'as yet unclassified' stamp: 'tk 6/30/2000 12:02'!parts	| divider |	"return the parts of speech this word can be.  Keep the streams for each"	parts _ OrderedCollection new.	partStreams _ OrderedCollection new.	rwStream ifNil: [self stream].	rwStream reset.	rwStream match: 'Palavra desconhecida pelo Dicion¬¨¬èrio.'.	rwStream atEnd ifFalse: [^ #()].	"not in dictionary"	rwStream reset.	rwStream match: (divider _ '<li>').	"stemming a complex word"	rwStream atEnd ifTrue: [rwStream reset.		rwStream match: (divider _ '<dd>')].	"base word in dict"	[rwStream atEnd] whileFalse: [		partStreams add: (ReadStream on: (rwStream upToAll: divider))].	partStreams do: [:pp |		parts add: (pp upToAll: '</b>')].	parts size = 0 ifTrue: [^ parts].	parts last = '' ifTrue: [parts removeLast.  partStreams removeLast].		"May want to remove all after </dl>"	^ parts ! !!Locale class methodsFor: 'accessing' stamp: 'dgd 10/7/2004 20:50'!stringForLanguageNameIs: localeID 	"Answer a string for a menu determining whether the given  	symbol is the project's natural language"	^ (self current localeID = localeID		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, localeID displayName! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 9/26/2003 23:22'!userCustomEventNames	^ self currentWorld userCustomEventNames! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 9/26/2003 23:26'!removeUserCustomEventNamed: eventName	| retval |	retval _ self currentWorld removeUserCustomEventNamed: eventName.	"Vocabulary addStandardVocabulary: UserCustomEventNameType new."	Vocabulary customEventsVocabulary.	SymbolListTile updateAllTilesForVocabularyNamed: #CustomEvents.	^retval! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 9/26/2003 23:30'!globalCustomEventNames	^self customEventsRegistry keys asArray sort! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 7/20/2003 12:33'!addCustomEventFor: registrant named: aSymbol help: helpString	| registration |	registration _ self customEventsRegistry at: aSymbol ifAbsentPut: [ IdentityDictionary new ].	registration at: registrant put: helpString.! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 9/26/2003 23:31'!customEventStati	^self globalCustomEventNames,	self userCustomEventNames! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 9/26/2003 23:23'!addUserCustomEventNamed: aSymbol help: helpString	self currentWorld addUserCustomEventNamed: aSymbol help: helpString.	"Vocabulary addStandardVocabulary: UserCustomEventNameType new."	Vocabulary customEventsVocabulary.	SymbolListTile updateAllTilesForVocabularyNamed: #CustomEvents! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 7/20/2003 12:37'!removeCustomEventNamed: aSymbol for: registrant	| registration helpString |	registration _ self customEventsRegistry at: aSymbol ifAbsent: [ ^nil ].	helpString _ registration removeKey: registrant ifAbsent: [].	registration isEmpty ifTrue: [ self customEventsRegistry removeKey: aSymbol ].	^helpString! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 10/12/2003 13:14'!customEventsRegistry	^Smalltalk at: #CustomEventsRegistry ifAbsentPut: [ IdentityDictionary new ].! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 6/30/2004 18:16'!standardEventStati	"Answer the events that can be directed to a particular morph by its event handler."	^ #(mouseDown	"run when mouse goes down on me"		mouseStillDown	"while mouse still down"		mouseUp		"when mouse comes back up"		mouseEnter	"when mouse enters my bounds, button up"		mouseLeave	"when mouse exits my bounds, button up"		mouseEnterDragging	"when mouse enters my bounds, button down"		mouseLeaveDragging	"when mouse exits my bounds, button down"		"keyStroke"		"gesture"	)! !!StandardScriptingSystem methodsFor: '*customevents-help dictionary' stamp: 'nk 8/18/2004 18:02'!statusHelpString	^String streamContents: [ :stream |		stream nextPutAll: 'normal -- run when calledpaused -- ready to run all the timeticking -- run all the timemouseDown -- run when mouse goes down on memouseStillDown -- while mouse still downmouseUp -- when mouse comes back upmouseEnter -- when mouse enters my bounds, button upmouseLeave -- when mouse exits my bounds, button upmouseEnterDragging -- when mouse enters my bounds, button downmouseLeaveDragging -- when mouse exits my bounds, button downopening -- when I am being openedclosing -- when I am being closed' translated."'keyStroke -- run when user hits a key' "	stream cr; cr; nextPutAll: 'Global events:' translated; cr.	self customEventsRegistry keysAndValuesDo: [ :key :value |		stream cr;		nextPutAll: key;		nextPutAll: ' -- '.		value do: [ :help | stream nextPutAll: help translated ]			separatedBy: [ stream nextPutAll: ' or ' translated ]].	(Preferences allowEtoyUserCustomEvents) ifTrue: [	self userCustomEventNames isEmpty ifFalse: [		stream cr; cr; nextPutAll: 'User custom events:' translated; cr.		self currentWorld userCustomEventsRegistry keysAndValuesDo: [ :key :value |			stream cr; nextPutAll: key; nextPutAll: ' -- '; nextPutAll: value ]]].]! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'nk 7/11/2004 20:08'!extent: newExtent	bounds extent = newExtent ifTrue: [^ self].	super extent: (newExtent max: 36@32).	self resizeScrollBar; resizeScroller; setScrollDeltas.! !!TwoWayScrollPane methodsFor: '*standardyellowbuttonmenus-menu' stamp: 'nk 1/23/2004 15:29'!hasYellowButtonMenu	^getMenuSelector notNil! !!HTTPSocket class methodsFor: 'utilities' stamp: 'nk 6/12/2004 09:24'!showImage: image named: imageName	Smalltalk isMorphic		ifTrue: [HandMorph attach: (World drawingClass withForm: image)]		ifFalse: [FormView open: image named: imageName]! !!WaveEditor methodsFor: 'menu' stamp: 'nk 6/22/2004 18:34'!makeLoopedSampledSound	| data end snd basePitch |	data := graph data.	snd := (loopEnd = 0 or: [loopLength = 0]) 				ifTrue: 					["save as unlooped"					basePitch := perceivedFrequency = 0 						ifTrue: [100.0]						ifFalse: [perceivedFrequency].					LoopedSampledSound new 						unloopedSamples: data						pitch: basePitch						samplingRate: samplingRate]				ifFalse: 					[end := (loopEnd min: data size) max: 1.					basePitch := samplingRate * loopCycles / loopLength.					LoopedSampledSound new 						samples: data						loopEnd: end						loopLength: end						pitch: basePitch						samplingRate: samplingRate].	snd addReleaseEnvelope.	^snd! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'bf 10/8/2004 13:21'!currentNavigatorVersion	^29		"since these guys get saved, we fix them up if they are older versions"! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'bf 10/8/2004 13:32'!buttonLanguage	"Answer a button for changing the language"	| myButton m |	myButton _ self makeButton: ''		balloonText:  'Click here to choose your language.'		for: #chooseLanguage.	myButton addMorph: (m _ self languageIcon asMorph lock).	myButton extent: m extent + (myButton borderWidth + 6).	m position: myButton center - (m extent // 2).	^ myButton! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'bf 10/8/2004 12:47'!languageIcon	^ (ColorForm	extent: 19@18	depth: 4	fromArray: #( 4294967295 4294967295 4293918720 4294967206 2183331839 4293918720 4294946286 3972145919 4293918720 4294631150 3430031919 4293918720 4289588973 3396477476 4293918720 4292799965 3399692836 4293918720 4208913868 724784466 804257792 4141735107 858993445 804257792 4140616899 1127429205 804257792 4174171340 3006481493 804257792 4174171340 3274982741 804257792 4170435788 3409204562 804257792 4280497100 1429493074 4293918720 4280431429 1429558562 4293918720 4294059093 1431654959 4293918720 4294919237 1431446271 4293918720 4294967074 572719103 4293918720 4294967295 4294967295 4293918720)	offset: 0@0)	colorsFromArray: #(#(0.0 0.0 0.0) #(1.0 1.0 1.0) #(0.376 0.376 0.784) #(0.357 0.357 0.733) #(0.231 0.231 0.474) #(0.494 0.494 0.964) #(0.498 0.498 0.933) #(0.376 0.376 0.706) #(0.419 0.419 0.78) #(0.415 0.415 0.776) #(0.595 0.595 0.972) #(0.638 0.638 0.968) #(0.654 0.654 0.96) #(0.686 0.686 0.96) #(0.71 0.71 0.964) #( )  )! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 22:46'!browseMethodsWhoseNamesContain: aString	"Launch a tool which shows all methods whose names contain the given string; case-insensitive.¬¨¬è	1/16/1996 sw, at the dawn of Squeak: this was the classic implementation that provided the underpinning for the 'method names containing it' (cmd-shift-W) feature that has always been in Squeak -- the feature that later inspired the MethodFinder (aka SelectorBrowser).¬¨¬è	sw 7/27/2001:	Switched to showing a MessageNames tool rather than a message-list browser, if in Morphic."	| aList |	Smalltalk isMorphic		ifFalse:			[aList _ Symbol selectorsContaining: aString.			aList size > 0 ifTrue:				[self browseAllImplementorsOfList: aList asSortedCollection title: 'Methods whose names contain ''', aString, '''']]		ifTrue:			[(MessageNames methodBrowserSearchingFor: aString) openInWorld]	! !!NaturalLanguageTranslator methodsFor: 'accessing' stamp: 'dgd 10/7/2004 20:50'!displayName	^ id displayName! !!NaturalLanguageTranslator class methodsFor: 'private loading' stamp: 'nk 8/21/2004 13:00'!loadExternalTranslationsFor: translator	"Try to load translations from external external files.	The files are located in the <prefs>/locale/<language>{/<country>} folder.	There can be more than one file for each location, so applications can install their own partial translation tables. All files in the specific folder are loaded."	| translationDir |	translationDir := self directoryForLocaleID: translator localeID create: false.	translationDir ifNil: [ ^nil ]. 	(translationDir fileNamesMatching: '*.' , self translationSuffix)		do: [:fileName | translator loadFromFileNamed: (translationDir fullNameFor: fileName)]! !!NaturalLanguageTranslator class methodsFor: 'private loading' stamp: 'nk 8/21/2004 13:03'!directoryForLanguage: isoLanguage country: isoCountry create: createDir	"Try to locate the <prefs>/locale/<language>{/<country>} folder.	If createDir is set, create the path down to country or language, depending on wether it's specified..	Return the directory for country or language depending on specification.	If neither exists, nil"	"NaturalLanguageTranslator directoryForLanguage: 'es' country: nil create: true"	"NaturalLanguageTranslator directoryForLanguage: 'de' country: 'DE' create: true"	"NaturalLanguageTranslator directoryForLanguage: 'en' country: 'US' create: false"	"NaturalLanguageTranslator directoryForLanguage: 'en' country: nil create: true"	"If this fails, there is nothing we can do about it here"	| localeDir  countryDir languageDir |	localeDir := self localeDirCreate: createDir.	localeDir ifNil: [^nil].	isoCountry ifNil: [		languageDir := localeDir directoryNamed: isoLanguage.		createDir			ifTrue: [languageDir assureExistence].		^languageDir exists			ifTrue: [languageDir]			ifFalse: [nil]].	countryDir := languageDir directoryNamed: isoCountry.	createDir		ifTrue: [countryDir assureExistence].	^countryDir exists		ifTrue: [countryDir]		ifFalse: [nil]! !!TheWorldMenu methodsFor: '*flexibleVocabularies-construction' stamp: 'nk 8/21/2004 13:36'!scriptingMenu	"Build the authoring-tools menu for the world."	^ self fillIn: (self menu: 'authoring tools...') from: { 		{ 'objects (o)' . { #myWorld . #activateObjectsTool }. 'A searchable source of new objects.'}.		nil.  "----------" 		{ 'view trash contents' . { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.'}. 		{ 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.		nil.  "----------"			{ 'new scripting area' . { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.		nil.  "----------"					{ 'status of scripts' . {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.'}.		{ 'summary of scripts' . {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.'}.		{ 'browser for scripts' . {#myWorld . #browseAllScriptsTextually}. 'Allows you to view all the scripts in the project in a traditional programmers'' "browser" format'}.		nil.		{ 'gallery of players' . {#myWorld . #galleryOfPlayers}. 'A tool that lets you find out about all the players used in this project'}."		{ 'gallery of scripts' . {#myWorld . #galleryOfScripts}. 'Allows you to view all the scripts in the project'}."		{ 'EToy vocabulary summary' . {#myWorld . #printVocabularySummary }. 'Displays a summary of all the pre-defined commands and properties in the pre-defined EToy vocabulary.'}.		{ 'attempt misc repairs' . {#myWorld . #attemptCleanup}. 'Take measures that may help fix up some things about a faulty or problematical project.'}.		{ 'remove all viewers' . {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.'}.		nil.  "----------" 		{ 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.		{ 'unhide hidden objects' . { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!IconicButton methodsFor: 'initialization' stamp: 'nk 9/7/2004 11:43'!initializeWithThumbnail: aThumbnail withLabel: aLabel andColor: aColor andSend: aSelector to: aReceiver 		"Initialize the receiver to show aThumbnail on its face, giving it the label supplied and arranging for it, when the button goes down on it, to obtain a new morph by sending the supplied selector to the supplied receiver"	| labeledItem nonTranslucent |	nonTranslucent := aColor asNontranslucentColor.	labeledItem _ AlignmentMorph newColumn.	labeledItem color: nonTranslucent.	labeledItem borderWidth: 0.	labeledItem		layoutInset: 4@0;		cellPositioning: #center.	labeledItem addMorph: aThumbnail.	labeledItem addMorphBack: (Morph new extent: (4@4)) beTransparent.	labeledItem addMorphBack: (TextMorph new		backgroundColor: nonTranslucent;		contentsAsIs: aLabel;		beAllFont: Preferences standardEToysFont;		centered).	self		beTransparent;		labelGraphic: ((labeledItem imageForm: 32 backgroundColor: nonTranslucent forRectangle: labeledItem fullBounds) replaceColor: nonTranslucent withColor: Color transparent);		borderWidth: 0;		target: aReceiver;		actionSelector: #launchPartVia:label:;		arguments: {aSelector. aLabel};		actWhen: #buttonDown.	self stationarySetup.! !!MessageSet methodsFor: 'private' stamp: 'sw 7/25/2004 03:37'!initializeMessageList: anArray	"Initialize my messageList from the given list of MethodReference or string objects.  NB¬¨¬®¬¨¬Æ¬¨¬®¬¨¦Ü¬¨¬®¬¨¬Æ¬¨¬®¬¨¬±: special handling for uniclasses."	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil:					[class isUniClass						ifTrue:							[s _ class typicalInstanceName, ' ', sel]						ifFalse:							[s _ class name , ' ' , sel , ' {' , 								((class organization categoryOfElement: sel) ifNil: ['']) , '}'].					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s)]]].	messageListIndex _ messageList isEmpty ifTrue: [0] ifFalse: [1].	contents _ ''! !!UnscriptedPlayer methodsFor: 'error handling' stamp: 'nk 8/21/2004 11:44'!doesNotUnderstand: aMessage	"I do not attempt the special setters that Player does.	I merely ignore not-understood messages."	^nil! !!SyntaxUpdatingStringMorph methodsFor: 'drawing' stamp: 'tk 1/31/2002 09:53'!drawOn: aCanvas	| tempForm strm where chars wid spaceWidth putLigature topOfLigature sizeOfLigature colorOfLigature dots charZero canvas f |	tempForm _ Form extent: self extent depth: aCanvas depth.	canvas _ tempForm getCanvas.	f _ self fontToUse.	spaceWidth _ f widthOf: Character space.	strm _ ReadStream on: contents.	charZero _ Character value: 0.	"a marker for center dot ¬¨¬è"	where _ 0@0.	topOfLigature _ self height // 2 - 1.	sizeOfLigature _ (spaceWidth-2)@(spaceWidth-2).	colorOfLigature _ Color black alpha: 0.45	"veryLightGray".	dots _ OrderedCollection new.	putLigature _ [		dots add: ((where x + 1) @ topOfLigature extent: sizeOfLigature).		where _ where + (spaceWidth@0)].	strm peek = charZero ifTrue: [		strm next.		putLigature value].	[strm peek = charZero] whileTrue: [strm next].	[strm atEnd] whileFalse: [		chars _ strm upTo: charZero.		wid _ f widthOfString: chars.		canvas drawString: chars at: where.		where _ where + (wid@0).		strm atEnd ifFalse: [putLigature value.			[strm peek = charZero] whileTrue: [strm next]].	].	aCanvas paintImage: tempForm at: self topLeft.	dots do: [ :each |		aCanvas 			fillRectangle: (each translateBy: self topLeft) 			fillStyle: colorOfLigature.	].! !!FlashPlayerMorph methodsFor: 'e-toy support' stamp: 'nk 1/6/2004 12:36'!asWearableCostumeOfExtent: extent	"Return a wearable costume for some player"	| image oldExtent |	oldExtent _ self extent.	self extent: extent.	image _ self imageForm.	self extent: oldExtent.	image mapColor: self color to: Color transparent.	^(World drawingClass withForm: image) copyCostumeStateFrom: self! !!MethodWithInterface methodsFor: 'initialization' stamp: 'nk 7/2/2004 07:18'!status	^defaultStatus! !!EToyVocabulary methodsFor: '*flexiblevocabularies-method list' stamp: 'nk 9/11/2004 15:41'!masterOrderingOfPhraseSymbols	"Answer a dictatorially-imposed presentation list of phrase-symbols.	This governs the order in which suitable phrases are presented in etoy viewers using the etoy vocabulary.	For any given category, the default implementation is that any items that are in this list will occur first, in the order specified here; after that, all other items will come, in alphabetic order by their translated wording."	^ #(beep: forward: turn: getX getY  getHeading getScaleFactor		getLeft getRight getTop getBottom  		getLength getWidth 		getTheta getDistance getHeadingTheta		startScript: pauseScript: stopScript: startAll: pauseAll: stopAll: tellAllSiblings: doScript:		getColor getUseGradientFill getSecondColor  getRadialGradientFill  getBorderWidth getBorderColor getBorderStyle getRoundedCorners getDropShadow getShadowColor 		getGraphic getBaseGraphic)! !!EToyVocabulary methodsFor: '*flexiblevocabularies-initialization' stamp: 'nk 9/11/2004 18:04'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	|   classes aMethodCategory selector selectors categorySymbols aMethodInterface |	super initialize.	self vocabularyName: #eToy.	self documentation: '"EToy" is a vocabulary that provides the equivalent of the 1997-2000 etoy prototype'.	categorySymbols _ Set new.	classes _ self class morphClassesDeclaringViewerAdditions.	classes do:		[:aMorphClass | categorySymbols addAll: aMorphClass unfilteredCategoriesForViewer].	self addCustomCategoriesTo: categorySymbols.  "For benefit, e.g., of EToyVectorVocabulary"	categorySymbols asOrderedCollection do:		[:aCategorySymbol |			aMethodCategory _ ElementCategory new categoryName: aCategorySymbol.			selectors _ Set new.			classes do:				[:aMorphClass |					 (aMorphClass additionsToViewerCategory: aCategorySymbol) do:						[:anElement |						aMethodInterface _ self methodInterfaceFrom: anElement.						selectors add: (selector _ aMethodInterface selector).						(methodInterfaces includesKey: selector) ifFalse:							[methodInterfaces at: selector put: aMethodInterface].						self flag: #deferred.						"NB at present, the *setter* does not get its own method interface.  Need to revisit"].			(selectors copyWithout: #unused) asSortedArray do:				[:aSelector |					aMethodCategory elementAt: aSelector put: (methodInterfaces at: aSelector)]].				 			self addCategory: aMethodCategory].	self addCategoryNamed: ScriptingSystem nameForInstanceVariablesCategory.	self addCategoryNamed: ScriptingSystem nameForScriptsCategory.	self setCategoryDocumentationStrings.	(self respondsTo: #applyMasterOrdering)		ifTrue: [ self applyMasterOrdering ].! !!EToyVocabulary methodsFor: 'initialization' stamp: 'nk 10/6/2004 11:56'!setCategoryDocumentationStrings	"Initialize the documentation strings associated with the old etoy categories, in English"	self setCategoryStrings: #((basic					'basic'					'a few important things')(#'book navigation'		'book navigation'		'relating to book, stacks, etc')(button					'button'					'for thinking of this object as a push-button control')(collections				'collections'				'for thinking of this object as a collection')(fog					'fog'					'3D fog')(geometry				'geometry' 				'measurements and coordinates')(#'color & border'		'color & border'			'matters concerning the colors and borders of objects')(graphics				'graphics'				'for thinking of this object as a picture')(variables				'variables'				'variables added by this object')(joystick				'joystick'				'the object as a Joystick')(miscellaneous			'miscellaneous' 			'various commands')(motion					'motion' 				'matters relating to moving and turning')(paintbox				'paintbox'				'the painting palette')(#'pen trails'			'pen trails'				'relating to trails put down by pens')(#'pen use'				'pen use' 				'use of an object''s "pen"')(playfield				'playfield'				'the object as a container for other visible objects')(sampling				'sampling'				'sampling')(scripting				'scripting'				'commands to start and stop scripts')(scripts					'scripts'					'methods added by this object')(slider					'slider'					'functions useful to sliders')(speaker				'speaker'				'the object as an audio Speaker')(#'stack navigation'		'stack navigation'		'navigation within a stck')(storyboard				'storyboard'				'storyboard')(tests					'tests'					'yes/no tests, to use in "Test" panes of scripts')(text					'text'					'The object as text')(vector					'vector'					'The object as a vector')(viewing				'viewing'				'matters relating to viewing') ) ! !!EToyVocabulary class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 7/3/2003 20:07'!morphClassesDeclaringViewerAdditions	"Answer a list of actual morph classes that either implement #additionsToViewerCategories,	or that have methods that match #additionToViewerCategory* ."	^(Morph class allSubInstances select: [ :ea | ea hasAdditionsToViewerCategories ])! !!EToyVocabulary class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/8/2004 16:21'!masterOrderingOfCategorySymbols	"Answer a dictatorially-imposed presentation list of category symbols.	This governs the order in which available vocabulary categories are presented in etoy viewers using the etoy vocabulary.	The default implementation is that any items that are in this list will occur first, in the order specified here; after that, all other items will come, in alphabetic order by their translated wording."	^#(basic #'color & border' geometry motion #'pen use' tests layout #'drag & drop' scripting observation button search miscellaneous)! !!EToyVocabulary class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 9/11/2004 18:00'!vocabularySummary	"Answer a string describing all the vocabulary defined anywhere in the 	system."	"	(StringHolder new contents: EToyVocabulary vocabularySummary)  	openLabel: 'EToy Vocabulary' translated 	"	| etoyVocab rt interfaces allAdditions |	etoyVocab := Vocabulary eToyVocabulary.	etoyVocab initialize.		"just to make sure that it's unfiltered."	^ String streamContents: [:s |		self morphClassesDeclaringViewerAdditions do: [:cl | 			s nextPutAll: cl name; cr.			allAdditions := cl allAdditionsToViewerCategories.			cl unfilteredCategoriesForViewer do: [ :cat |				allAdditions at: cat ifPresent: [ :additions |					interfaces := ((etoyVocab categoryAt: cat) ifNil: [ ElementCategory new ]) elementsInOrder.					interfaces := interfaces								select: [:ea | additions										anySatisfy: [:tuple | (tuple first = #slot												ifTrue: [tuple at: 7]												ifFalse: [tuple at: 2])												= ea selector]].					s tab; nextPutAll: cat translated; cr.					interfaces						do: [:if | 							s tab: 2.							rt := if resultType.							rt = #unknown								ifTrue: [s nextPutAll: 'command' translated]								ifFalse: [s nextPutAll: 'property' translated;										 nextPut: $(;										 nextPutAll: (if companionSetterSelector											ifNil: ['RO']											ifNotNil: ['RW']) translated;										 space;										 nextPutAll: rt translated;										 nextPutAll: ') '].							s tab; print: if wording; space.							if argumentVariables								do: [:av | s nextPutAll: av variableName;										 nextPut: $(;										 nextPutAll: av variableType asString;										 nextPut: $)]								separatedBy: [s space].							s tab; nextPutAll: if helpMessage; cr]]]]]! !!CodeHolder methodsFor: 'annotation' stamp: 'sw 2/22/2001 10:02'!annotationSeparator	"Answer the separator to be used between annotations"	^ ' ¬¨¬è '! !!CodeHolder methodsFor: 'contents' stamp: 'sw 12/11/2000 10:42'!commentContents	"documentation for the selected method"	| poss aClass aSelector |	^ (poss _ (aClass _ self selectedClassOrMetaClass)						ifNil:							['----']						ifNotNil:							[(aSelector _ self selectedMessageName)								ifNil:									['---']								ifNotNil:									[(aClass precodeCommentOrInheritedCommentFor: aSelector)", String cr, String cr, self timeStamp""which however misses comments that are between the temps  declaration and the body of the method; those are picked up by ¬¨¬èaClass commentOrInheritedCommentFor: aSelector¬¨¬è but that method will get false positives from comments *anywhere* in the method source"]])		isEmptyOrNil			ifTrue:				[aSelector					ifNotNil:						[((aClass methodHeaderFor: aSelector), 'Has no comment') asText makeSelectorBoldIn: aClass]					ifNil:						['Hamna']]			ifFalse:	[aSelector				ifNotNil: [((aClass methodHeaderFor: aSelector), '', poss) asText makeSelectorBoldIn: aClass]				ifNil: [poss]]! !!Project methodsFor: 'language' stamp: 'dgd 10/7/2004 20:51'!naturalLanguage	"Answer the natural language for the project"	^ self localeID displayName! !!Project methodsFor: 'language' stamp: 'dgd 10/7/2004 21:05'!chooseNaturalLanguage	"Put up a menu allowing the user to choose the natural language for the project"	| aMenu availableLanguages |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'choose language' translated.	aMenu lastItem setBalloonText: 'This controls the human language in which tiles should be viewed.  It is potentially extensible to be a true localization mechanism, but initially it only works in the classic tile scripting system.  Each project has its own private language choice' translated.	Preferences noviceMode		ifFalse:[aMenu addStayUpItem].	availableLanguages := NaturalLanguageTranslator availableLanguageLocaleIDs										asSortedCollection:[:x :y | x displayName < y displayName].	availableLanguages do:		[:localeID |			aMenu addUpdating: #stringForLanguageNameIs: target: Locale selector:  #switchToID: argumentList: {localeID}].	aMenu popUpInWorld"Project current chooseNaturalLanguage"! !!TileMorph methodsFor: 'as yet unclassified' stamp: 'nk 10/8/2004 15:14'!unhibernate	self fixLayout.! !!TileMorph methodsFor: 'as yet unclassified' stamp: 'nk 10/8/2004 15:11'!fixLayout	"Having just been loaded from a project, do repairs as needed."	self allMorphsDo: [:m | (m isKindOf: StringMorph)				ifTrue: [m font: Preferences standardEToysFont;						 fitContents].		(m respondsTo: #fixLayout)			ifTrue: [ m ~~ self ifTrue: [ m fixLayout ] ]			ifFalse: [ m layoutChanged ] ].	self layoutChanged; fullBounds! !!FileList2 methodsFor: 'own services' stamp: 'nk 1/6/2004 12:36'!openImageInWindow	"Handle five file formats: GIF, JPG, PNG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream _ (directory readOnlyFileNamed: fileName) binary.	image _ Form fromBinaryStream: myStream.	myStream close.	Smalltalk isMorphic		ifTrue: [(World drawingClass withForm: image) openInWorld]		ifFalse: [FormView open: image named: fileName]! !!ScrollPane methodsFor: '*StandardYellowButtonMenus-scroll bar events' stamp: 'nk 1/23/2004 14:22'!hasYellowButtonMenu	^getMenuSelector notNil! !!StackMorph methodsFor: 'page controls' stamp: 'tk 11/5/2001 08:21'!fullControlSpecs	"Answer specifications for the long form of iconic stack/book controls"	^ #(		spacer		variableSpacer		('-'			deleteCard					'Delete this card')		spacer		( '¬¨¬¥'		goToFirstCardOfStack			'First card')		spacer		( '<' 		goToPreviousCardInStack		'Previous card')		spacer		('¬¨¬è'			invokeBookMenu 			'Click here to get a menu of options for this stack.')		"spacer	('¬¨¬é'			reshapeBackground  		'Reshape')	"		spacer		('¬¨¦ü'			showDesignationsOfObjects 	'Show designations')		spacer		('>'			goToNextCardInStack			'Next card')		spacer		( '¬¨¬'		goToLastCardOfStack			'Final card')		spacer		('+'			insertCard					'Add a new card after this one')		variableSpacer		('¬¨¬ç'			fewerPageControls			'Fewer controls(if shift key pressed,deletes controls)'))! !!StackMorph methodsFor: 'page controls' stamp: 'sw 10/30/2000 10:09'!shortControlSpecs	"Answer specficiations for the shorter form of stack controls"	^ #(		spacer		variableSpacer		( '<'		goToPreviousCardInStack		'Previous card')		spacer		('¬¨¬è'		invokeBookMenu 			'Click here to get a menu for this stack.')		spacer		('>'		goToNextCardInStack			'Next card')		variableSpacer		('¬¨¬ç'	showMoreControls				'More controls(if shift key pressed,deletes controls)'))! !!TabbedPalette methodsFor: 'palette menu' stamp: 'nk 6/12/2004 10:05'!addMenuTab	"Add the menu tab.  This is ancient code, not much in the spirit of anything current"	| aMenu aTab aGraphic sk |	aMenu _ MenuMorph new defaultTarget: self.	aMenu stayUp: true.	"aMenu add:  'clear' translated action: #showNoPalette."	aMenu add:  'sort tabs' translated action: #sortTabs:.	aMenu add:  'choose new colors for tabs' translated action: #recolorTabs.	aMenu setProperty: #paletteMenu toValue: true.	"aMenu add:  'make me the Standard palette' translated action: #becomeStandardPalette."	aTab _ self addTabForBook: aMenu  withBalloonText: 'a menu of palette-related controls' translated.	aTab highlightColor: tabsMorph highlightColor; regularColor: tabsMorph regularColor.	tabsMorph laySubpartsOutInOneRow; layoutChanged.	aGraphic _ ScriptingSystem formAtKey: 'TinyMenu'.	aGraphic ifNotNil:		[aTab removeAllMorphs.		aTab addMorph: (sk _ World drawingClass withForm: aGraphic).		sk position: aTab position.		sk lock.		aTab fitContents].	self layoutChanged! !!TabbedPalette class methodsFor: 'scripting' stamp: 'nk 6/12/2004 10:05'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 200 @ 300.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: (World drawingClass withForm: ScriptingSystem squeakyMouseForm).	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	aTabbedPalette tabsMorph hResizing: #spaceFill.	^ aTabbedPalette! !!Morph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 9/11/2004 17:12'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the 	viewer, in order"	| dict aList |	dict := Dictionary new.	self unfilteredCategoriesForViewer		withIndexDo: [:cat :index | dict at: cat put: index].	self filterViewerCategoryDictionary: dict.	aList := SortedCollection				sortBlock: [:a :b | (dict at: a)						< (dict at: b)].	aList addAll: dict keys.	^ aList asArray! !!Morph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 9/11/2004 17:31'!unfilteredCategoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order of:	- masterOrderingOfCategorySymbols first	- others last in order by translated wording"	"	Morph basicNew unfilteredCategoriesForViewer	"	^self renderedMorph class unfilteredCategoriesForViewer.! !!Morph methodsFor: 'menus' stamp: 'nk 1/6/2004 12:53'!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsOfColor:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsOfColor:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetOffset) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'nk 6/12/2004 09:58'!chooseNewGraphicCoexisting: aBoolean 	"Allow the user to choose a different form for her form-based morph"	| replacee aGraphicalMenu |	aGraphicalMenu := GraphicalMenu new				initializeFor: self				withForms: self reasonableForms				coexist: aBoolean.	aBoolean		ifTrue: [self primaryHand attachMorph: aGraphicalMenu]		ifFalse: [replacee := self topRendererOrSelf.			replacee owner replaceSubmorph: replacee by: aGraphicalMenu]! !!Morph methodsFor: 'menus' stamp: 'nk 6/12/2004 09:55'!reasonableForms	"Answer an OrderedCollection of forms that could be used to replace my form, with my current form first."	| reasonableForms myGraphic |	reasonableForms := self class allSketchMorphForms.	reasonableForms addAll: Imports default images.	reasonableForms		remove: (myGraphic := self form)		ifAbsent: [].	reasonableForms := reasonableForms asOrderedCollection.	reasonableForms addFirst: myGraphic.	^reasonableForms! !!Morph methodsFor: 'menus' stamp: 'nk 6/12/2004 22:42'!reasonableBitmapFillForms	"Answer an OrderedCollection of forms that could be used to replace my bitmap fill, with my current form first."	| reasonableForms myGraphic |	reasonableForms := self class allSketchMorphForms.	reasonableForms addAll: Imports default images.	reasonableForms addAll: (BitmapFillStyle allSubInstances collect:[:f| f form]).	reasonableForms		remove: (myGraphic := self fillStyle form)		ifAbsent: [].	reasonableForms := reasonableForms asOrderedCollection.	reasonableForms addFirst: myGraphic.	^reasonableForms! !!Morph methodsFor: 'scripting-override' stamp: 'nk 8/21/2004 13:28'!filterViewerCategoryDictionary: dict	"dict has keys of categories and values of priority.	You can re-order or remove categories here."	Preferences eToyFriendly		ifTrue: [dict removeKey: #layout].! !!Morph methodsFor: 'halos and balloon help' stamp: 'nk 6/12/2004 09:32'!wantsSimpleSketchMorphHandles	"Answer true if my halo's simple handles should include the simple sketch morph handles."	^false! !!Morph methodsFor: 'events-processing' stamp: 'nk 6/13/2004 09:16'!handleMouseMove: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	"Rules say that by default a morph gets #mouseMove iff		* the hand is not dragging anything,			+ and some button is down,			+ and the receiver is the current mouse focus."	(anEvent hand hasSubmorphs) ifTrue:[^self].	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: '*connectors-scripting' stamp: 'nk 8/21/2004 08:39'!wantsConnectionVocabulary	submorphs ifNil: [ ^true ].	"called from EToyVocabulary>>initialize after basicNew"	^ (Preferences valueOfFlag: #alwaysShowConnectionVocabulary)		or: [ self connections isEmpty not ]! !!Morph methodsFor: '*connectors-scripting' stamp: 'nk 9/10/2004 11:37'!wantsConnectorVocabulary	"Answer true if I want to show a 'connector' vocabulary"	^false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 9/11/2004 16:23'!referencePlayfield	"Answer the PasteUpMorph to be used for cartesian-coordinate reference"	| former |	owner ifNotNil:		[(self topRendererOrSelf owner isHandMorph and: [(former _ self formerOwner) notNil])			ifTrue:				[former _ former renderedMorph.				^ former isPlayfieldLike 					ifTrue: [former]					ifFalse: [former referencePlayfield]]].	self allOwnersDo: [:o | o isPlayfieldLike ifTrue: [^ o]].	^ ActiveWorld! !!Morph methodsFor: 'e-toy support' stamp: 'nk 1/6/2004 12:37'!asWearableCostume	"Return a wearable costume for some player"	^(World drawingClass withForm: self imageForm) copyCostumeStateFrom: self! !!Morph methodsFor: 'testing' stamp: 'nk 6/12/2004 09:17'!isSketchMorph	^self class isSketchMorphClass! !!Morph methodsFor: '*connectors-testing' stamp: 'nk 10/13/2003 18:36'!isLineMorph	^false! !!Morph methodsFor: '*customevents-scripting' stamp: 'nk 9/25/2003 11:37'!triggerCustomEvent: aSymbol	"Trigger whatever scripts may be connected to the custom event named aSymbol"	self currentWorld triggerEvent: aSymbol! !!Morph methodsFor: '*customevents-scripting' stamp: 'nk 9/25/2003 11:11'!renameScriptActionsFor: aPlayer from: oldSelector to: newSelector	self updateableActionMap keysAndValuesDo: [ :event :sequence |		sequence asActionSequence do: [ :action |			((action receiver == aPlayer)				and: [ (#(doScript: triggerScript:) includes: action selector)					and: [ action arguments first == oldSelector ]])						ifTrue: [ action arguments at: 1 put: newSelector ]]]! !!Morph methodsFor: '*customevents-scripting' stamp: 'nk 9/25/2003 11:37'!removeEventTrigger: aSymbol	"Remove all the event registrations for my Player that are triggered by aSymbol.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	| player |	(player _ self player) ifNil: [ ^self ].	self removeEventTrigger: aSymbol for: player.	self currentWorld removeEventTrigger: aSymbol for: player.! !!Morph methodsFor: '*customevents-scripting' stamp: 'nk 9/24/2003 17:46'!removeAllEventTriggersFor: aPlayer	"Remove all the event registrations for aPlayer.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	self removeActionsSatisfying: 			[:action | action receiver == aPlayer and: [(#(#doScript: #triggerScript:) includes: action selector) ]].! !!Morph methodsFor: '*customevents-scripting' stamp: 'nk 9/25/2003 11:24'!removeEventTrigger: aSymbol for: aPlayer 	"Remove all the event registrations for aPlayer that are triggered by 	aSymbol. User custom events are triggered at the World, 	while system custom events are triggered on individual Morphs."	self removeActionsSatisfying: [:action | action receiver == aPlayer				and: [(#(#doScript: #triggerScript: ) includes: action selector)						and: [action arguments first == aSymbol]]]! !!Morph methodsFor: '*customevents-scripting' stamp: 'nk 9/25/2003 11:36'!removeAllEventTriggers	"Remove all the event registrations for my Player.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	| player |	(player _ self player) ifNil: [ ^self ].	self removeAllEventTriggersFor: player.	self currentWorld removeAllEventTriggersFor: player.! !!Morph methodsFor: 'fileIn/out' stamp: 'nk 1/6/2004 12:38'!updateFromResource	| pathName newMorph f |	(pathName := self valueOfProperty: #resourceFilePath) ifNil: [^self].	(pathName asLowercase endsWith: '.morph') 		ifTrue: 			[newMorph := (FileStream readOnlyFileNamed: pathName) fileInObjectAndCode.			(newMorph isMorph) 				ifFalse: [^self error: 'Resource not a single morph']]		ifFalse: 			[f := Form fromFileNamed: pathName.			f ifNil: [^self error: 'unrecognized image file format'].			newMorph := World drawingClass withForm: f].	newMorph setProperty: #resourceFilePath toValue: pathName.	self owner replaceSubmorph: self by: newMorph! !!Morph methodsFor: 'scripting' stamp: 'nk 8/21/2004 12:17'!triggerScript: aSymbol	"Have my player perform the script of the given name, which is guaranteed to exist."	^self assuredPlayer triggerScript: aSymbol! !!Morph methodsFor: 'scripting' stamp: 'nk 9/24/2003 17:31'!instantiatedUserScriptsDo: aBlock	self actorStateOrNil ifNotNilDo: [ :aState | aState instantiatedUserScriptsDictionary do: aBlock]! !!Morph methodsFor: 'naming' stamp: 'dgd 2/22/2003 14:35'!setNameTo: aName 	| nameToUse nameString |	nameToUse := aName ifNotNil: 					[(nameString := aName asString) notEmpty ifTrue: [nameString] ifFalse: ['¬¨¦ñ']].	self setNamePropertyTo: nameToUse	"no Texts here!!"! !!Morph class methodsFor: 'testing' stamp: 'nk 6/12/2004 09:20'!allSketchMorphClasses	"Morph allSketchMorphClasses"	^ Array		streamContents: [:s | self				withAllSubclassesDo: [:cls | cls isSketchMorphClass						ifTrue: [s nextPut: cls ]]]! !!Morph class methodsFor: 'testing' stamp: 'nk 6/12/2004 09:17'!isSketchMorphClass	^false! !!Morph class methodsFor: 'testing' stamp: 'nk 6/12/2004 09:45'!allSketchMorphForms	"Answer a Set of forms of SketchMorph (sub) instances, except those 	used as button images or ones being edited."	| reasonableForms |	reasonableForms := Set new.	Morph allSketchMorphClasses		do: [:cls | cls allInstances				do: [:m | ((m owner isKindOf: SketchEditorMorph)							or: [m owner isKindOf: IconicButton])						ifFalse: [reasonableForms add: m form]]].	^ reasonableForms! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/11/2003 18:06'!additionToViewerCategorySelectors	"Answer the list of my selectors matching additionsToViewerCategory*"	^self class organization allMethodSelectors select: [ :ea |		(ea beginsWith: 'additionsToViewerCategory')					and: [ (ea at: 26 ifAbsent: []) ~= $: ]]! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 9/11/2004 16:56'!allAdditionsToViewerCategories	"Answer a Dictionary of (<categoryName> <list of category specs>) that 	defines the phrases this kind of morph wishes to add to various Viewer categories. 	 	This version allows each category definition to be defined in one or more separate methods. 	 	Subclasses that have additions can either:	- override #additionsToViewerCategories, or	- (preferably) define one or more additionToViewerCategory* methods.	The advantage of the latter technique is that class extensions may be added by	external packages without having to re-define additionsToViewerCategories."	"	Morph allAdditionsToViewerCategories	"	| dict |	dict := IdentityDictionary new.	(self class includesSelector: #additionsToViewerCategories)		ifTrue: [self additionsToViewerCategories				do: [:group | group						pairsDo: [:key :list | (dict								at: key								ifAbsentPut: [OrderedCollection new])								addAll: list]]].	self class selectors		do: [:aSelector | ((aSelector beginsWith: 'additionsToViewerCategory')					and: [(aSelector at: 26 ifAbsent: []) ~= $:])				ifTrue: [(self perform: aSelector)						pairsDo: [:key :list | (dict								at: key								ifAbsentPut: [OrderedCollection new])								addAll: list]]].	^ dict! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/8/2004 16:21'!unfilteredCategoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer for one of my instances, in order of:	- masterOrderingOfCategorySymbols first	- others last in order by translated wording"	"	Morph unfilteredCategoriesForViewer	"	| aClass additions masterOrder |	aClass _ self.	additions _ OrderedCollection new.	[aClass == Morph superclass ] whileFalse: [		additions addAll: (aClass allAdditionsToViewerCategories keys			asSortedCollection: [ :a :b | a translated < b translated ]).		aClass _ aClass superclass ]. 	masterOrder := EToyVocabulary masterOrderingOfCategorySymbols.	^(masterOrder intersection: additions), (additions difference: masterOrder).! !!Morph class methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 10/11/2003 18:17'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the	phrases this kind of morph wishes to add to various Viewer categories.	This version factors each category definition into a separate method.	Subclasses that have additions can either:		- override this method, or		- (preferably) define one or more additionToViewerCategory* methods.	The advantage of the latter technique is that class extensions may be added	by external packages without having to re-define additionsToViewerCategories.	"	^#()! !!Morph class methodsFor: '*connectors-scripting' stamp: 'nk 9/10/2004 11:34'!additionsToViewerCategoryConnection	"Answer viewer additions for the 'connection' category"	"Vocabulary initialize"	^{		#'connections to me'.		#(		(command tellAllPredecessors: 'Send a message to all graph predecessors' ScriptName)		(command tellAllSuccessors: 'Send a message to all graph predecessors' ScriptName)		(command tellAllIncomingConnections: 'Send a message to all the connectors whose destination end is connected to me' ScriptName)		(command tellAllOutgoingConnections: 'Send a message to all the connectors whose source end is connected to me' ScriptName)		(slot incomingConnectionCount 'The number of connectors whose destination end is connected to me' Number readOnly Player getIncomingConnectionCount unused unused)		(slot outgoingConnectionCount 'The number of connectors whose source end is connected to me' Number readOnly Player getOutgoingConnectionCount unused unused)		)	}! !!Morph class methodsFor: '*customevents-user events' stamp: 'nk 8/18/2004 18:02'!additionsToViewerCategoryUserEvents	"Answer viewer additions relating to user-defined events for the 'scripting' category"	^(Preferences allowEtoyUserCustomEvents)		ifTrue: [ #(scripting ((command triggerCustomEvent: 'trigger a user-defined (global) event' CustomEvents))) ]		ifFalse: [  #(scripting ())  ]! !!MczInstaller class methodsFor: 'services' stamp: 'nk 6/8/2004 17:29'!fileReaderServicesForFile: fileName suffix: suffix	^({ self extension. '*' } includes: suffix)		ifTrue: [ self services ]		ifFalse: [#()].! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/27/1999 17:24'!test2: anArray	"look for bad association"	anArray do: [:sub |		sub class == Association ifTrue: [			(#('true' '$a' '2' 'false') includes: sub value printString) ifFalse: [				self error: 'bad assn'].			(#('3' '5.6' 'x' '''abcd''') includes: sub key printString) ifFalse: [				self error: 'bad assn'].	"			sub value class == Association ifTrue: [					self error: 'bad assn'].				(sub value isKindOf: Class) ifTrue: [					self error: 'class in assn'].				sub value class == Symbol ifTrue: [sub value asciiValue = 204 '$¬¶¦â' ifTrue: [					self error: 'Write into char']].				sub value == $¬¶¦â ifTrue: [					self error: 'Write into char']	"].		sub class == Array ifTrue: [			sub do: [:element | 				element class == String ifTrue: [element first asciiValue < 32 ifTrue: [						self error: 'store into string in data']].				element class == Association ifTrue: [					element value class == Association ifTrue: [						self error: 'bad assn']]]].		sub class == Date ifTrue: [sub year isInteger ifFalse: [				self error: 'stored into input date!!!!']].		sub class == Dictionary ifTrue: [				sub size > 0 ifTrue: [					self error: 'store into dictionary']].		sub class == OrderedCollection ifTrue: [				sub size > 4 ifTrue: [					self error: 'store into OC']].		].! !!BitmapFillStyle methodsFor: 'Morphic menu' stamp: 'nk 6/12/2004 09:59'!chooseNewGraphicIn: aMorph event: evt 	"Used by any morph that can be represented by a graphic"	| aGraphicalMenu |	aGraphicalMenu := GraphicalMenu new				initializeFor: self				withForms: aMorph reasonableBitmapFillForms				coexist: true.	aGraphicalMenu selector: #newForm:forMorph:;		 argument: aMorph.	evt hand attachMorph: aGraphicalMenu! !!GeeMailMorph methodsFor: '*customevents-access' stamp: 'nk 10/12/2003 13:22'!visibleMorphs	"Answer a collection of morphs that were visible as of the last step"	^Array withAll: (self valueOfProperty: #visibleMorphs ifAbsentPut: [ WeakArray new ]).! !!GeeMailMorph methodsFor: '*customevents-access' stamp: 'nk 10/12/2003 13:22'!visibleMorphs: morphs	"Answer a collection of morphs that were visible as of the last step"	self setProperty: #visibleMorphs toValue: (WeakArray withAll: morphs)! !!GeeMailMorph methodsFor: '*customevents-stepping and presenter' stamp: 'nk 10/12/2003 13:23'!step	"For each submorph of thePasteUp that has just been scrolled into view, fire the script named #scrolledIntoView, if any.	For each submorph of thePasteUp that has just been scrolled out of view, fire the script named #scrolledOutOfView, if any."	| lastVisible nowVisible newlyVisible newlyInvisible |	super step.	lastVisible _ self visibleMorphs.	nowVisible _ (thePasteUp submorphs copyWithoutAll: (self allTextPlusMorphs))		select: [ :m | self bounds intersects: (m boundsIn: self world) ].	newlyInvisible _ lastVisible difference: nowVisible.	newlyInvisible do: [ :ea | ea triggerEvent: #scrolledOutOfView ].	newlyVisible _ nowVisible difference: lastVisible.	newlyVisible do: [ :ea | ea triggerEvent: #scrolledIntoView ].	self visibleMorphs: nowVisible.	! !!GeeMailMorph methodsFor: '*customevents' stamp: 'nk 10/12/2003 13:23'!releaseCachedState	super releaseCachedState.	self removeProperty: #visibleMorphs! !!GeeMailMorph class methodsFor: '*customevents-class initialization' stamp: 'nk 7/20/2003 12:36'!unload	ScriptingSystem removeCustomEventNamed: #scrolledIntoView for: self.	ScriptingSystem removeCustomEventNamed: #scrolledOutOfView for: self.! !!GeeMailMorph class methodsFor: '*customevents-class initialization' stamp: 'nk 7/20/2003 12:34'!initialize	"AlansTextPlusMorph initialize"	ScriptingSystem addCustomEventFor: self named: #scrolledIntoView help: 'when I am scrolled into view in a GeeMailMorph'.	ScriptingSystem addCustomEventFor: self named: #scrolledOutOfView help: 'when I am scrolled out of view in a GeeMailMorph'.! !!SymbolListTile methodsFor: '*customevents-accessing' stamp: 'nk 7/21/2003 22:02'!dataType	^dataType! !!SymbolListTile methodsFor: '*customevents-initialization' stamp: 'nk 7/21/2003 22:14'!updateChoices	choices _ (Vocabulary vocabularyNamed: dataType) choices.	(choices includes: literal) ifFalse: [ literal _ choices first. self changed ]! !!SymbolListTile class methodsFor: '*customevents-updating' stamp: 'nk 7/21/2003 22:16'!updateAllTilesForVocabularyNamed: aVocabularyName	"The choices in the Vocabulary named aVocabularyName may have changed.	Update my subinstances if necessary to reflect the changes."	 (self allSubInstances select: [ :ea | ea dataType = aVocabularyName ])		do: [ :ea | ea updateChoices ] ! !!PaintBoxMorph methodsFor: 'other' stamp: 'bf 10/11/2004 13:37'!addLabels	"translate button labels"	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		| button |		button _ submorphs detect: [:m | m externalName = extName] ifNone: [nil].		button ifNotNil: [			button removeAllMorphs.			button addMorph: (TextMorph new 				contentsWrapped: (Text string: label translated					attributes: {						TextAlignment centered. 						TextEmphasis bold.						TextFontReference toFont:							((TextStyle named: #BitstreamVeraSans) fontOfSize: 9)});				bounds: (button bounds translateBy: 0@3);				lock)]]! !!PaintBoxMorph class methodsFor: 'instance creation' stamp: 'bf 10/11/2004 13:37'!new	| pb button dualUse formCanvas rect |	pb _ Prototype veryDeepCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb submorphNamed: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ button onImage getCanvas.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	pb fixUpRecentColors.	pb addLabels.	^ pb! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nk 1/6/2004 12:39'!grabFloodFromScreen: evt	"Allow the user to plant a flood seed on the Display, and create a new drawing morph from the resulting region. Attach the result to the hand."	| screenForm exterior p1 box |	Cursor crossHair showWhile: [p1 _ Sensor waitButton].	box _ Display floodFill: Color transparent at: p1.	exterior _ ((Display copy: box) makeBWForm: Color transparent) reverse.	self world invalidRect: box; displayWorldSafely.	(box area > (Display boundingBox area // 2))		ifTrue: [^ PopUpMenu notify: 'Sorry, the region was too big'].	(exterior deepCopy reverse anyShapeFill reverse)  "save interior bits"		displayOn: exterior at: 0@0 rule: Form and.	screenForm _ Form fromDisplay: box.	screenForm eraseShape: exterior.	screenForm isAllWhite ifFalse:		[evt hand attachMorph: (self drawingClass withForm: screenForm)]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nk 1/6/2004 12:38'!extractScreenRegion: poly andPutSketchInHand: hand	"The user has specified a polygonal area of the Display.	Now capture the pixels from that region, and put in the hand as a Sketch."	| screenForm outline topLeft innerForm exterior |	outline _ poly shadowForm.	topLeft _ outline offset.	exterior _ (outline offset: 0@0) anyShapeFill reverse.	screenForm _ Form fromDisplay: (topLeft extent: outline extent).	screenForm eraseShape: exterior.	innerForm _ screenForm trimBordersOfColor: Color transparent.	innerForm isAllWhite ifFalse:		[hand attachMorph: (self drawingClass withForm: innerForm)]! !!PasteUpMorph methodsFor: 'painting' stamp: 'nk 1/6/2004 12:39'!backgroundForm: aForm	self backgroundSketch: (self drawingClass new		center: self center;		form: aForm)! !!PasteUpMorph methodsFor: '*standardyellowbuttonmenus-event handling' stamp: 'nk 1/23/2004 16:29'!hasYellowButtonMenu	^self isWorldMorph ! !!PasteUpMorph methodsFor: '*customevents-scripting' stamp: 'nk 9/26/2003 23:24'!addUserCustomEventNamed: aSymbol help: helpString	self userCustomEventsRegistry at: aSymbol put: helpString.! !!PasteUpMorph methodsFor: '*customevents-scripting' stamp: 'nk 9/26/2003 23:20'!userCustomEventNames	| reg |	reg _ self valueOfProperty: #userCustomEventsRegistry ifAbsent: [ ^#() ].	^reg keys asArray sort! !!PasteUpMorph methodsFor: '*customevents-scripting' stamp: 'nk 9/26/2003 23:26'!removeUserCustomEventNamed: aSymbol	^self userCustomEventsRegistry removeKey: aSymbol ifAbsent: [].! !!PasteUpMorph methodsFor: '*customevents-scripting' stamp: 'nk 9/26/2003 23:18'!userCustomEventsRegistry	^self valueOfProperty: #userCustomEventsRegistry ifAbsentPut: [ IdentityDictionary new ].! !!PasteUpMorph methodsFor: '*flexiblevocabularies-scripting' stamp: 'nk 8/21/2004 13:35'!printVocabularySummary	"Put up a window with summaries of all Morph vocabularies."		(StringHolder new contents: EToyVocabulary vocabularySummary) 	openLabel: 'EToy Vocabulary' 	"self currentWorld printVocabularySummary"! !!FileDirectory methodsFor: 'file operations' stamp: 'mir 10/8/2004 08:51'!upLoadProject: projectFile named: destinationFileName resourceUrl: resUrl retry: aBool	"Copy the contents of the existing fileStream into the file destinationFileName in this directory.  fileStream can be anywhere in the fileSystem.  No retrying for local file systems."	| result |	result _ self putFile: projectFile named: destinationFileName.	[self		setMacFileNamed: destinationFileName		type: 'SOBJ'		creator: 'FAST']		on: Error		do: [ "ignore" ].	^result! !!Preferences class methodsFor: 'add preferences' stamp: 'ar 10/23/2004 14:02'!addPreference: prefSymbol categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol changeSelector: aChangeSelector 	"Add or replace a preference as indicated. Reuses the	preexisting Preference object for this symbol, if there is one,	so that UI artifacts that interact with it will remain valid."	^ self		addPreference: prefSymbol		categories: categoryList		default: aValue		balloonHelp: helpString		projectLocal: localBoolean		changeInformee: informeeSymbol		changeSelector: aChangeSelector		viewRegistry: PreferenceViewRegistry ofBooleanPreferences! !!HaloMorph methodsFor: 'handles' stamp: 'nk 6/12/2004 09:24'!addChooseGraphicHandle: haloSpec	"If the target is a sketch morph, and if the governing preference is set, add a halo handle allowing the user to select a new graphic"	(Preferences showChooseGraphicHaloHandle and: [innerTarget isSketchMorph]) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #chooseNewGraphicFromHalo to: innerTarget]! !!HaloMorph methodsFor: 'handles' stamp: 'nk 6/12/2004 09:24'!addRepaintHandle: haloSpec	(innerTarget isSketchMorph) ifTrue:		[self addHandle: haloSpec				on: #mouseDown send: #editDrawing to: innerTarget]! !!HaloMorph methodsFor: 'halos and balloon help' stamp: 'nk 6/12/2004 09:34'!addSimpleHandlesTo: aHaloMorph box: aBox	| aHandle |	simpleMode _ true.	target isWorldMorph ifTrue: [^ self addSimpleHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"		self bounds: target renderedMorph worldBoundsForHalo.  "update my size"		self addHandleAt: (((aBox topLeft + aBox leftCenter) // 2) + self simpleFudgeOffset) color: Color paleBuff icon: 'Halo-MoreHandles'		on: #mouseDown send: #addFullHandles to: self.	aHandle _ self addGraphicalHandle: #Rotate at: aBox bottomLeft on: #mouseDown send: #startRot:with: to: self.	aHandle on: #mouseMove send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addGraphicalHandle: #Scale at: aBox bottomRight  on: #mouseDown send: #startScale:with: to: self)				on: #mouseMove send: #doScale:with: to: self]		ifFalse: [(self addGraphicalHandle: #Scale at: aBox bottomRight on: #mouseDown send: #startGrow:with: to: self)				on: #mouseMove send: #doGrow:with: to: self].	innerTarget wantsSimpleSketchMorphHandles ifTrue:		[self addSimpleSketchMorphHandlesInBox: aBox].	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'st 9/14/2004 12:51'!startGrow: evt with: growHandle	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	| botRt |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.	botRt _ target point: target bottomRight in: owner.	positionOffset _ (self world viewBox containsPoint: botRt)		ifTrue: [evt cursorPoint - botRt]		ifFalse: [0@0].	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: 'resizing' translated;			undoTarget: target selector: #setExtentFromHalo: argument: target extent).	originalExtent _ target extent! !!HaloMorph methodsFor: 'private' stamp: 'st 9/14/2004 12:54'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse scale |	evt hand obtainHalo: self.	newExtent _ (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [		scale _ (newExtent x / (originalExtent x max: 1)) min:					(newExtent y / (originalExtent y max: 1)).		newExtent _ (originalExtent x * scale) asInteger @ (originalExtent y * scale) asInteger	].	(newExtent x < 1 or: [newExtent y < 1 ]) ifTrue: [^ self].	target renderedMorph setExtentFromHalo: (extentToUse _ newExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) ifNotNilDo:  		[:cmd | "Update the final extent"		cmd redoTarget: target selector: #setExtentFromHalo: argument: extentToUse]! !!HaloMorph methodsFor: 'copying' stamp: 'st 9/14/2004 13:03'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	"target _ target.		Weakly copied"	"innerTarget _ innerTarget.		Weakly copied"	positionOffset _ positionOffset veryDeepCopyWith: deepCopier.	angleOffset _ angleOffset veryDeepCopyWith: deepCopier.	growingOrRotating _ growingOrRotating veryDeepCopyWith: deepCopier.	directionArrowAnchor _ directionArrowAnchor.	simpleMode _ simpleMode.	haloBox _ haloBox.	originalExtent _ originalExtent! !!ProcessBrowser methodsFor: 'process list' stamp: 'nk 6/30/2004 07:00'!prettyNameForProcess: aProcess 	| nameAndRules |	aProcess ifNil: [ ^'<nil>' ].	nameAndRules _ self nameAndRulesFor: aProcess.	^ aProcess browserPrintStringWith: nameAndRules first! !!Vocabulary class methodsFor: 'standard vocabulary access' stamp: 'nk 8/22/2004 09:24'!vocabularyNamed: aName	"Answer the standard vocabulary of the given name, or nil if none found"	^ self allStandardVocabularies at: aName asSymbol ifAbsent: []! !!Vocabulary class methodsFor: '*customevents-custom events' stamp: 'nk 8/18/2004 17:57'!addCustomEventsVocabulary	| vocab |	self addStandardVocabulary: (vocab := self newCustomEventsVocabulary).	SymbolListTile updateAllTilesForVocabularyNamed: #CustomEvents.	^vocab! !!Vocabulary class methodsFor: '*customevents-custom events' stamp: 'nk 8/21/2004 19:58'!customEventsVocabulary	"Vocabulary customEventsVocabulary"	^(self vocabularyNamed: #CustomEvents)		ifNil: [ self addCustomEventsVocabulary ]! !!Vocabulary class methodsFor: '*customevents-custom events' stamp: 'nk 8/18/2004 17:56'!newCustomEventsVocabulary	^UserCustomEventNameType new.! !!ThumbnailMorph methodsFor: 'stepping and presenter' stamp: 'nk 6/14/2004 16:47'!step	"Optimization: Don't redraw if we're viewing some kind of SketchMorph and its rotated Form hasn't changed."	| viewee f |	viewee _ self actualViewee.	viewee ifNil: [ self stopStepping. ^self ].	(viewee isSketchMorph) ifTrue: [		f _ viewee rotatedForm.		f == lastSketchForm ifTrue: [^ self].		lastSketchForm _ f].	self changed.! !!BookMorph methodsFor: 'menu' stamp: 'nk 6/12/2004 09:23'!loadImagesIntoBook	"PowerPoint stores GIF presentations as individual slides named Slide1, Slide2, etc.	Load these into the book.  mjg 9/99"	| directory filenumber form newpage |	directory := ((StandardFileMenu oldFileFrom: FileDirectory default) 				ifNil: [^nil]) directory.	directory isNil ifTrue: [^nil].	"Start loading 'em up!!"	filenumber := 1.	[directory fileExists: 'Slide' , filenumber asString] whileTrue: 			[Transcript				show: 'Slide' , filenumber asString;				cr.			Smalltalk bytesLeft < 1000000 				ifTrue: 					["Make some room"					(self valueOfProperty: #url) isNil 						ifTrue: [self savePagesOnURL]						ifFalse: [self saveAsNumberedURLs]].			form := Form 						fromFileNamed: (directory fullNameFor: 'Slide' , filenumber asString).			newpage := PasteUpMorph new extent: form extent.			newpage addMorph: (World drawingClass withForm: form).			self pages addLast: newpage.			filenumber := filenumber + 1].	"After adding all, delete the first page."	self goToPage: 1.	self deletePageBasic.	"Save the book"	(self valueOfProperty: #url) isNil 		ifTrue: [self savePagesOnURL]		ifFalse: [self saveAsNumberedURLs]! !!MoviePlayerMorph methodsFor: 'page controls' stamp: 'di 10/16/2000 13:20'!fullControlSpecs	^ #(				( '¬¨¬è'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			( '->'		nextPage		'Forward one frame')			( '>>'		playForward	'Play forward')			( '-->'		lastPage			'Go to final page')			( '<->'		scanBySlider	'Scan by slider'  'menu')		"Note extra spec 'menu' causes mousedown activation -- see makePageControlsFrom:"	)! !!MoviePlayerMorph class methodsFor: 'fileIn/Out' stamp: 'sw 9/7/2004 18:21'!services	"Formerly: answer a service for opening as a movie.  Nowadays... no services"	^ #()."	^ Array with: self serviceOpenAsMovie"	! !!SimpleButtonMorph methodsFor: 'event handling' stamp: 'nk 1/11/2004 12:37'!mouseDown: evt	super mouseDown: evt.	mouseDownTime _ Time millisecondClockValue.	oldColor _ self fillStyle. 	actWhen == #buttonDown		ifTrue: [ self doButtonAction]		ifFalse: [ self updateVisualState: evt ].	self mouseStillDown: evt.! !!SimpleButtonMorph methodsFor: 'submorphs-add/remove' stamp: 'nk 6/13/2004 13:46'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed, #startDrag"	actWhen _ condition.	actWhen == #startDrag		ifFalse: [self on: #startDrag send: nil to: nil ]		ifTrue:[self on: #startDrag send: #doButtonAction to: self].! !!SimpleButtonMorph methodsFor: 'events-processing' stamp: 'nk 1/11/2004 13:25'!mouseStillDownStepRate	"Answer how often I want the #handleMouseStillDown: stepped"	^200! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'nk 1/11/2004 12:40'!setActWhen	actWhen := (SelectionMenu 				selections: #(#buttonDown #buttonUp #whilePressed #startDrag)) 					startUpWithCaption: 'Choose one of the following conditions'! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'nk 1/23/2004 17:14'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""actionSelector _ actionSelector.		a Symbol""arguments _ arguments.		All weakly copied"actWhen _ actWhen veryDeepCopyWith: deepCopier.oldColor _ oldColor veryDeepCopyWith: deepCopier.mouseDownTime _ nil.! !!ReferenceMorph methodsFor: 'accessing' stamp: 'nk 6/12/2004 10:03'!isCurrentlyGraphical	"Answer whether the receiver is currently showing a graphical face"	| first |	^submorphs notEmpty and: 			[((first := submorphs first) isKindOf: ImageMorph) 				or: [first isSketchMorph]]! !!PartsWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:46'!initialize	"initialize the state of the receiver"	| aFont aForm |	super initialize.	""		openForEditing _ false.	aFont _ Preferences standardButtonFont.	self addMorph: (prevButton _ SimpleButtonMorph new borderWidth: 0;					 label: '<' font: aFont;					 color: Color transparent;					 setBalloonText: 'previous page';					 actionSelector: #previousPage;					 target: self;					 extent: 16 @ 16).	self addMorph: (nextButton _ SimpleButtonMorph new borderWidth: 0;					 label: '>' font: aFont;					 color: Color transparent;					 setBalloonText: 'next page';					 actionSelector: #nextPage;					 target: self;					 extent: 16 @ 16).	menuButton _ ThreePhaseButtonMorph new onImage: (aForm _ ScriptingSystem formAtKey: 'OfferToUnlock');								offImage: (ScriptingSystem formAtKey: 'OfferToLock');								pressedImage: (ScriptingSystem formAtKey: 'OfferToLock');				 extent: aForm extent;				 state: #on.	menuButton target: self;		 actionSelector: #toggleStatus;		 actWhen: #buttonUp.	menuButton setBalloonText: 'open for editing'.	self addMorph: menuButton.	" 	self addMorph: (menuButton _ SimpleButtonMorph new  	borderWidth: 0;  	label: '¬¨¬è' font: aFont; color: Color transparent;  	actWhen: #buttonDown;  	actionSelector: #invokePartsWindowMenu; target: self; extent:  	16@16)."	self adjustBookControls! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'nk 1/6/2004 12:36'!handMeOne	self currentHand attachMorph: (World drawingClass new form: (formChoices at: currentIndex))! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'nk 1/6/2004 12:37'!repaintEntry	"Let the user enter into painting mode to repaint the item and save it back."	| aWorld bnds sketchEditor aPaintBox formToEdit |		(aWorld _ self world) assureNotPaintingElse: [^ self].	aWorld prepareToPaint.	aWorld displayWorld.	formToEdit _ formChoices at: currentIndex.	bnds _ (submorphs second boundsInWorld origin extent: formToEdit extent) intersect: aWorld bounds.	bnds _ (aWorld paintingBoundsAround: bnds center) merge: bnds.	sketchEditor _ SketchEditorMorph new.	aWorld addMorphFront: sketchEditor.	sketchEditor initializeFor: ((World drawingClass withForm: formToEdit) position: submorphs second positionInWorld)  inBounds: bnds pasteUpMorph: aWorld paintBoxPosition: bnds topRight.	sketchEditor		afterNewPicDo: [:aForm :aRect |			formChoices at: currentIndex put: aForm.			baseDictionary at: (entryNames at: currentIndex) put: aForm.			self updateThumbnail.			(aPaintBox _ aWorld paintBoxOrNil) ifNotNil: [aPaintBox delete]] 		ifNoBits:			[(aPaintBox _ aWorld paintBoxOrNil) ifNotNil: [aPaintBox delete]].	! !!GraphicalDictionaryMenu methodsFor: 'private' stamp: 'nk 1/11/2004 15:14'!updateThumbnail	super updateThumbnail.	(self findA: UpdatingStringMorph)		doneWithEdits;		contents: (entryNames at: currentIndex)! !!GraphicalDictionaryMenu methodsFor: 'initialization' stamp: 'nk 1/11/2004 16:22'!initializeFor: aTarget fromDictionary: aDictionary 	"Initialize me for a target and a dictionary."	| anIndex aButton |	self baseDictionary: aDictionary.	target := aTarget.	coexistWithOriginal := true.	self extent: 210 @ 210.	self clipSubmorphs: true.	self layoutPolicy: ProportionalLayout new.	aButton := (IconicButton new)				borderWidth: 0;				labelGraphic: (ScriptingSystem formAtKey: 'TinyMenu');				color: Color transparent;				actWhen: #buttonDown;				actionSelector: #showMenu;				target: self;				setBalloonText: 'menu'.	self addMorph: aButton		fullFrame: (LayoutFrame fractions: (0.5 @ 0 extent: 0 @ 0)				offsets: (-50 @ 6 extent: aButton extent)).	aButton := (SimpleButtonMorph new)				target: self;				borderColor: Color black;				label: 'Prev';				actionSelector: #downArrowHit;				actWhen: #whilePressed;				setBalloonText: 'show previous picture';				yourself.	self addMorph: aButton		fullFrame: (LayoutFrame fractions: (0.5 @ 0 extent: 0 @ 0)				offsets: (-24 @ 4 extent: aButton extent)).	aButton := (SimpleButtonMorph new)				target: self;				borderColor: Color black;				label: 'Next';				actionSelector: #upArrowHit;				actWhen: #whilePressed;				setBalloonText: 'show next pictutre'.	self addMorph: aButton		fullFrame: (LayoutFrame fractions: (0.5 @ 0 extent: 0 @ 0)				offsets: (24 @ 4 extent: aButton extent)).	self addMorph: ((UpdatingStringMorph new)				contents: ' ';				target: self;				putSelector: #renameGraphicTo:;				getSelector: #truncatedNameOfGraphic;				useStringFormat;				setBalloonText: 'The name of the current graphic';				yourself)		fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 1 @ 0)				offsets: (10 @ 40 corner: -10 @ 60)).	self addMorph: ((Morph new)				extent: 100 @ 4;				color: Color black)		fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 1 @ 0)				offsets: (0 @ 60 corner: 0 @ 64)).	formDisplayMorph := (Thumbnail new)				extent: 100 @ 100;				useInterpolation: true;				maxWidth: 3000 minHeight: 100;				yourself.	self addMorph: formDisplayMorph		fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 0@0)				offsets: (8 @ 72 corner:  108 @ 172)).	self minimumExtent: 116@180.	target ifNotNil: 			[(anIndex := formChoices indexOf: target form ifAbsent: []) 				ifNotNil: [currentIndex := anIndex]].	self updateThumbnail! !!GraphicalDictionaryMenu class methodsFor: 'instance creation' stamp: 'nk 1/11/2004 15:50'!openOn: aFormDictionary withLabel: aLabel	"open a graphical dictionary in a window having the label aLabel.      aFormDictionary should be a dictionary containing as value a form."	| inst aWindow |	aFormDictionary size isZero ifTrue: [^ self inform: 'Empty!!'].		inst := self new initializeFor: nil fromDictionary: aFormDictionary.	aWindow _ (SystemWindow labelled: aLabel) model: inst.	aWindow addMorph: inst frame: (0@0 extent: 1@1).	aWindow extent: inst fullBounds extent + (3 @ aWindow labelHeight + 3);		minimumExtent: inst minimumExtent + (3 @ aWindow labelHeight + 3).	     HandMorph attach: aWindow.	^ inst! !!PolygonMorph methodsFor: '*connectors-testing' stamp: 'nk 10/13/2003 18:36'!isLineMorph	^closed not! !!GraphicalMenu methodsFor: 'event handling' stamp: 'nk 1/11/2004 14:44'!updateThumbnail	| f |	f _ formChoices at: currentIndex.	formDisplayMorph 		makeThumbnailFromForm: f.! !!GraphicalMenu methodsFor: 'initialization' stamp: 'nk 1/11/2004 15:09'!initializeFor: aTarget withForms: formList coexist: aBoolean 	"World primaryHand attachMorph:		(GraphicalMenu new initializeFor: nil  		withForms: Form allInstances coexist: true)"	| buttons bb anIndex buttonCage |	target := aTarget.	coexistWithOriginal := aBoolean.	formChoices := formList.	currentIndex := 1.	self borderWidth: 1;		 cellPositioning: #center;		 color: Color white;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	buttons := AlignmentMorph newRow.	buttons borderWidth: 0;		 layoutInset: 0.	buttons hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 extent: 5 @ 5.	buttons wrapCentering: #topLeft.	buttonCage := AlignmentMorph newColumn.	buttonCage hResizing: #shrinkWrap;		 vResizing: #spaceFill.	buttonCage addTransparentSpacerOfSize: 0 @ 10.	bb := SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'Prev';			 actionSelector: #downArrowHit;			 actWhen: #whilePressed).	buttons addTransparentSpacerOfSize: 9 @ 0.	bb := SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'Next';			 actionSelector: #upArrowHit;			 actWhen: #whilePressed).	buttons addTransparentSpacerOfSize: 5 @ 0.	buttons submorphs last color: Color white.	buttonCage addMorphBack: buttons.	buttonCage addTransparentSpacerOfSize: 0 @ 12.	buttons := AlignmentMorph newRow.	bb := SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'OK';			 actionSelector: #okay).	buttons addTransparentSpacerOfSize: 5 @ 0.	bb := SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'Cancel';			 actionSelector: #cancel).	buttonCage addMorphBack: buttons.	buttonCage addTransparentSpacerOfSize: 0 @ 10.	self addMorphFront: buttonCage.	formDisplayMorph := Thumbnail new extent: 100 @ 100;				 maxWidth: 100 minHeight: 30;				 yourself.	self addMorphBack: (Morph new color: Color white;			 layoutPolicy: TableLayout new;			 layoutInset: 4 @ 4;			 hResizing: #spaceFill;			 vResizing: #spaceFill;			 listCentering: #center;			 addMorphBack: formDisplayMorph;			 yourself).	target		ifNotNil: [(anIndex := formList						indexOf: target form						ifAbsent: [])				ifNotNil: [currentIndex := anIndex]].	self updateThumbnail! !!SimpleButtonDelayedMenuMorph methodsFor: 'event handling' stamp: 'nk 1/11/2004 12:35'!mouseDown: evt	didMenu _ nil.	super mouseDown: evt.! !!MovieMorph methodsFor: 'menu' stamp: 'nk 6/12/2004 09:59'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu _ MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' translated action: #editDrawing.		subMenu add: 'set rotation center' translated action: #setRotationCenter.		subMenu add: 'play once' translated action: #playOnce.		subMenu add: 'play loop' translated action: #playLoop.		subMenu add: 'stop playing' translated action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' translated action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' translated action: #nextFrame]].	subMenu add: 'extract this frame' translated action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aCustomMenu add: 'movie...' translated subMenu: subMenu! !!MovieMorph methodsFor: 'menu' stamp: 'nk 6/12/2004 09:59'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue:		[aTarget _ aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!SequenceableCollection methodsFor: 'accessing' stamp: 'nk 6/12/2004 17:06'!atLast: indexFromEnd	"Return element at indexFromEnd from the last position.	 atLast: 1, returns the last element"	^ self atLast: indexFromEnd ifAbsent: [self error: 'index out of range']! !!ParseNode methodsFor: 'testing' stamp: 'ls 1/29/2004 21:11'!isJust: node	^false! !!ParseNode methodsFor: 'private' stamp: 'ls 1/29/2004 21:17'!ifNilReceiver	"assuming this object is the receiver of an ifNil:, what object is being asked about?"	^self! !!AllScriptsTool methodsFor: 'toggles' stamp: 'dgd 9/19/2003 14:37'!openUpButton	"Answer a button whose action would be to open up the receiver or snap it back closed"	| aButton |	aButton _ SimpleButtonMorph new.	aButton		target: self topRendererOrSelf;		color: (Color r: 0.452 g: 0.839 b: 0.935);		label: '¬¨¬ù' font: Preferences standardButtonFont;		actionSelector: #toggleWhetherShowingOnlyTopControls;		setBalloonText: 'open or close the lower portion that shows individual scripts' translated.	^ aButton! !!ExternalDropHandler class methodsFor: 'private' stamp: 'nk 6/12/2004 09:24'!defaultImageHandler	| image sketch |	^ExternalDropHandler		type: 'image/'		extension: nil		action: [:stream :pasteUp :event |			stream binary.			image _ Form fromBinaryStream: ((RWBinaryOrTextStream with: stream contents) reset).			Project current resourceManager 				addResource: image 				url: (FileDirectory urlForFileNamed: stream name) asString.			sketch _ World drawingClass withForm: image.			pasteUp addMorph: sketch centeredNear: event position] fixTemps! !!ColorPickerMorph methodsFor: 'submorphs-add/remove' stamp: 'nk 4/17/2004 19:34'!delete	"The moment of departure has come.	If the receiver has an affiliated command, finalize it and have the system remember it.	In any case, delete the receiver"	(selector isNil or: [ target isNil ]) ifFalse: [		self rememberCommand: 			(Command new				cmdWording: 'color change' translated;				undoTarget: target selector: selector arguments: (self argumentsWith: originalColor);				redoTarget: target selector: selector arguments: (self argumentsWith: selectedColor)).	].	super delete! !!StringMorphEditor methodsFor: 'event handling' stamp: 'nk 6/12/2004 22:07'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor newSel |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	self editor selectFrom: newSel first to: newSel last.! !!Player methodsFor: '*customevents-costume' stamp: 'nk 9/24/2003 17:33'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds _ costume bounds.		(costume ownerThatIsA: HandMorph orA: PasteUpMorph) replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorStateOrNil.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: '*customevents-custom events' stamp: 'nk 8/21/2004 12:51'!triggerScript: aSymbol 	"Perform the script of the given name,	which is guaranteed to exist.	However, it's possible that the script may still result in a DNU,	which will be swallowed and reported to the Transcript."	^ [self perform: aSymbol]		on: MessageNotUnderstood		do: [:ex | 			ScriptingSystem				reportToUser: (String						streamContents: [:s | s nextPutAll: self externalName;								 nextPutAll: ': exception in script ';								 print: aSymbol;								 nextPutAll: ' : ';								 print: ex]).			ex return: self			"ex pass"]! !!Player methodsFor: '*customevents-custom events' stamp: 'nk 8/26/2003 10:50'!triggerCustomEvent: aSymbol	"Trigger whatever scripts may be connected to the custom event named aSymbol"	self costume renderedMorph triggerCustomEvent: aSymbol! !!Player methodsFor: 'pen' stamp: 'nk 6/12/2004 10:00'!addPlayerMenuItemsTo: aMenu hand: aHandMorph	"Note that these items are primarily available in another way in an object's Viewer"	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	self getPenDown		ifTrue: [subMenu add: 'lift pen' action: #liftPen]		ifFalse: [subMenu add: 'lower pen' action: #lowerPen].	subMenu add: 'choose pen size...' action: #choosePenSize.	subMenu add: 'choose pen color...' action: #choosePenColor:.	aMenu add: 'pen...' subMenu: subMenu.	(costume renderedMorph isSketchMorph) ifTrue:		[self belongsToUniClass			ifFalse: 				[aMenu add: 'adopt scripts from...' target: self action: #adoptScriptsFrom]			ifTrue:				[aMenu add: 'impart scripts to...' target: self action: #impartSketchScripts]]! !!Player methodsFor: '*customevents-misc' stamp: 'nk 9/24/2003 18:26'!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors viewerFlaps |	viewers _ OrderedCollection new.	viewerFlaps _ OrderedCollection new.	scriptors _ OrderedCollection new.	aWorld allMorphs do:		[:m | m isAViewer ifTrue: [viewers add: m].			((m isKindOf: ViewerFlapTab) and: [m scriptedPlayer == self])				ifTrue:					[viewerFlaps add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	aMorph  removeAllEventTriggersFor: self.	aWorld removeAllEventTriggersFor: self.	viewers do: [:v |  v noteDeletionOf: aMorph].	viewerFlaps do: [:v  | v dismissViaHalo].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: '*customevents-misc' stamp: 'nk 9/24/2003 17:32'!actorState	"Answer the receiver's actorState, creating one if necessary."	^ self costume actorState! !!Player methodsFor: 'misc' stamp: 'nk 6/12/2004 10:01'!impartSketchScripts	"Let the user designate another object to which my scripts and code should be imparted"	| aMorph |	Sensor waitNoButton.	aMorph _ ActiveWorld chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph renderedMorph isSketchMorph) ifTrue:		[aMorph acquirePlayerSimilarTo: self]! !!Player methodsFor: 'misc' stamp: 'nk 8/18/2004 16:43'!adoptScriptsFrom	"Let the user click on another object form which the receiver should obtain scripts and code"	| aMorph |	Sensor waitNoButton.	aMorph _ ActiveWorld chooseClickTarget.	aMorph ifNil: [^ Beeper beep].	(((aMorph isSketchMorph) and: [aMorph player belongsToUniClass]) and: [self belongsToUniClass not])		ifTrue:			[costume acquirePlayerSimilarTo: aMorph player]		ifFalse:			[Beeper beep]! !!Player methodsFor: 'misc' stamp: 'nk 6/12/2004 10:01'!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld _ aViewer world.	aMenu _ MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' translated target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' translated target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' translated target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.' translated.	aMenu add: 'choose limit class...' translated target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.' translated.	aMenu add: 'open standard lexicon' translated target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format' translated.	aMenu add: 'open lexicon with search pane' translated target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: costume selector: #inspect.	aMenu add: 'inspect player' translated target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' translated target: self action: #browsePlayerClass.		aMenu add: 'inspect class' translated target: self class action: #inspect].	aMenu add: 'inspect this Viewer' translated target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' translated target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' translated target: aViewer action: #relaunchViewer.	aMenu add: 'view morph directly' translated target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.' translated.	(costume renderedMorph isSketchMorph) ifTrue:		[aMenu addLine.		aMenu add: 'impart scripts to...' translated target: self action: #impartSketchScripts].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: '*customevents-scripts-kernel' stamp: 'nk 8/18/2004 17:40'!pacifyScript: aSymbol	"Make sure the script represented by the symbol doesn't do damage by lingering in related structures on the morph side"	| aHandler aUserScript |	aUserScript _ self class userScriptForPlayer: self selector: aSymbol.	aUserScript ifNil: [self flag: #deferred.  ^ Beeper beep].  	"Maddeningly, without this line here the thing IS nil and the debugger is in a bad state	(the above note dates from 1/12/99 ?!!"	self class allInstancesDo:		[:aPlayer | | itsCostume |		aPlayer actorState instantiatedUserScriptsDictionary removeKey: aSymbol ifAbsent: [].		itsCostume _ aPlayer costume renderedMorph.		(aHandler _ itsCostume eventHandler) ifNotNil:			[aHandler forgetDispatchesTo: aSymbol].		itsCostume removeEventTrigger: aSymbol ]! !!Player methodsFor: '*customevents-scripts-kernel' stamp: 'nk 9/25/2003 11:53'!existingScriptInstantiationForSelector: scriptName	"Answer the existing script instantiation for the given selector, or nil if none"	scriptName ifNil: [^ nil].	Symbol hasInterned: scriptName		ifTrue: [ :sym |			self costume actorStateOrNil ifNotNilDo: [ :actorState |				^actorState instantiatedUserScriptsDictionary at: sym ifAbsent: [nil]]].	^ nil! !!Player methodsFor: '*customevents-scripts-kernel' stamp: 'nk 9/25/2003 11:38'!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	|  aUserScript anInstantiation aDict |	oldSelector = newSelector ifTrue: [^ self].	oldSelector numArgs == 0		ifTrue:			[self class allSubInstancesDo:				[:aPlayer | | itsCostume |					anInstantiation _ aPlayer scriptInstantiationForSelector: oldSelector.					newSelector numArgs == 0						ifTrue:							[anInstantiation changeSelectorTo: newSelector].					aDict _ aPlayer costume actorState instantiatedUserScriptsDictionary.					itsCostume _ aPlayer costume renderedMorph.					itsCostume renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.					self currentWorld renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.					aDict removeKey: oldSelector.					newSelector numArgs  == 0 ifTrue:						[aDict at: newSelector put: anInstantiation.						anInstantiation assureEventHandlerRepresentsStatus]]]		ifFalse:			[newSelector numArgs == 0 ifTrue:				[self class allSubInstancesDo:					[:aPlayer |						anInstantiation _ aPlayer scriptInstantiationForSelector: newSelector.						anInstantiation assureEventHandlerRepresentsStatus]]].	aUserScript _ self class userScriptForPlayer: self selector: oldSelector.	aUserScript renameScript: newSelector fromPlayer: self.		"updates all script editors, and inserts the new script in my scripts directory"	self class removeScriptNamed: oldSelector.	((self existingScriptInstantiationForSelector: newSelector) notNil and:		[newSelector numArgs > 0]) ifTrue: [self error: 'ouch'].			self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: '*customevents-scripts-kernel' stamp: 'nk 9/24/2003 17:36'!instantiatedUserScriptsDo: aBlock	"Evaluate aBlock on behalf of all the instantiated user scripts in the receiver"	| aState aCostume |	((aCostume _ self costume) notNil and: [(aState _ aCostume actorStateOrNil) notNil]) ifTrue:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:01'!recaptureUniqueCostumes	"Recapture all unique sketch-like costumes. Debugging only."	| unique |	costumes ifNil:[^self].	unique := PluggableSet new 				equalBlock:[:s1 :s2| s1 form == s2 form];				hashBlock:[:s| s form identityHash].	unique addAll: (costumes select:[:c| c isSketchMorph]).	unique := unique asIdentitySet.	costumes := costumes select:[:c|		(c isSketchMorph) not or:[unique includes: c]].! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:02'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember _ aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes _ OrderedCollection new].	existing _ (costumeToRemember isSketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes _ costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:01'!knownSketchCostumeWithSameFormAs: aSketchMorph 	| itsForm |	itsForm := aSketchMorph form.	^ costumes		ifNotNil: [costumes				detect: [:c | c isSketchMorph						and: [c form == itsForm]]				ifNone: []]! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:02'!restoreBaseGraphic	"Restore my base graphic"	| cos |	((cos _ self costume renderedMorph) isSketchMorph)		ifTrue:			[cos restoreBaseGraphic]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 18:09'!getCharacterAtCursor	"Answer the value of the text cursor"	| aLoc aTextMorph aString |	aLoc _ (aTextMorph _ self costume renderedMorph) cursor.	aString _ aTextMorph text string.	^ (aString at: aLoc ifAbsent: ['¬¨¬è']) asString! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setGraphic: aForm	"Set the receiver's graphic as indicated"	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			[aMorph isPlayfieldLike				ifTrue: 					[aMorph backgroundForm: aForm]				ifFalse:					["what to do?"]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getGraphicAtCursor	"Answer the form representing the object at the current cursor"	| anObject aMorph |		anObject _ self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[ScriptingSystem formAtKey: #Paint]		ifFalse:			[((aMorph _ anObject renderedMorph) isSketchMorph)				ifTrue:					[aMorph form]				ifFalse:					[aMorph isPlayfieldLike						ifTrue:							[aMorph backgroundForm]						ifFalse:							[aMorph imageForm]]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getCostume	"Answer a form representing the receiver's primary graphic.  An earlier wording, disused but may persist in preexisting scripts."	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!setLength: aLength	"Set the length of the receiver."	| cost lengthToUse |	((cost _ self costume) isLineMorph)		ifTrue:			[^ cost unrotatedLength: aLength].	lengthToUse _ cost isRenderer		ifTrue:			[aLength / cost scaleFactor]		ifFalse:			[aLength].	cost renderedMorph height: lengthToUse! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setCostume: aForm	"Set the receiver's graphic as indicated.  An earlier wording, disused but may persist in preexisting scripts."	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			["what to do?"]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getCostumeAtCursor	"Answer the form representing the object at the current cursor.  An earlier wording, disused but may persist in preexisting scripts"	| anObject aMorph |		anObject _ self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[ScriptingSystem formAtKey: #Paint]		ifFalse:			[((aMorph _ anObject renderedMorph) isSketchMorph)				ifTrue:					[aMorph form]				ifFalse:					[anObject imageForm]]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 17:35'!setCharacterAtCursor: aCharOrString	"Insert the given character at my cursor position"	| aLoc aTextMorph aString charToUse |	aLoc _ (aTextMorph _ self costume renderedMorph) cursor.	charToUse _ (aString _ aCharOrString asString) size > 0		ifTrue:			[aString first]		ifFalse:			['¬¨¬è'].	aTextMorph paragraph replaceFrom: aLoc to: aLoc with: charToUse asString asText displaying: true.	aTextMorph updateFromParagraph  ! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setBaseGraphic: aGraphic	"Set the base graphic"	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph baseGraphic: aGraphic]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!getLength	"Answer the length of the object"	| aLength cost |	((cost  _ self costume) isLineMorph) "annoying special case"		ifTrue:			[^ cost unrotatedLength].	aLength _ cost renderedMorph height.  "facing upward when unrotated"	cost isRenderer		ifTrue:			[aLength _ aLength * cost scaleFactor].	^ aLength! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getGraphic	"Answer a form representing the receiver's primary graphic"	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form]		ifFalse:			[aMorph isPlayfieldLike				ifTrue:					[aMorph backgroundForm]				ifFalse:					[aMorph imageForm]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!getWidth	"Answer the width of the object"	| aWidth cost |	((cost _ self costume) isLineMorph) "annoying special case"		ifTrue:			[^ cost unrotatedWidth].	aWidth _ cost renderedMorph width.  "facing upward when unrotated"	cost isRenderer		ifTrue:			[aWidth _ aWidth * cost scaleFactor].	^ aWidth! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!setWidth: aWidth	"Set the width"	| cost widthToUse |	((cost _ self costume) isLineMorph)		ifTrue:			[^ cost unrotatedWidth: aWidth].	widthToUse _ cost isRenderer		ifTrue:			[aWidth / cost scaleFactor]		ifFalse:			[aWidth].	cost renderedMorph width: widthToUse! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getBaseGraphic	"Answer a form representing the receiver's base graphic"	| aMorph |	^ ((aMorph _ costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph baseGraphic]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slots-user' stamp: 'nk 8/21/2004 11:32'!tearOffFancyWatcherFor: aGetter	"Hand the user a labeled readout for viewing a numeric value"	| aWatcher aTile aLine aColor ms slotMsg info isNumeric anInterface watcherWording delta |	info _ self slotInfoForGetter: aGetter.	info ifNotNil:			[isNumeric _ info type == #Number.			watcherWording _ Utilities inherentSelectorForGetter: aGetter]		ifNil:			[anInterface _Vocabulary eToyVocabulary methodInterfaceAt: aGetter ifAbsent: [nil].			isNumeric _ anInterface notNil and: [anInterface resultType == #Number].			watcherWording _ anInterface wording].	aColor _ Color r: 0.387 g: 0.581 b: 1.0.		aWatcher _ UpdatingStringMorph new.	aWatcher growable: true;		getSelector: aGetter;		putSelector: (info notNil			ifTrue:				[ScriptingSystem setterSelectorForGetter: aGetter]			ifFalse:				[anInterface companionSetterSelector]).	aWatcher target: self.	isNumeric ifTrue:  "at the moment, actually, only numeric is allowed"		[aTile _ NumericReadoutTile new typeColor: aColor.		self setFloatPrecisionFor: aWatcher.		(delta _ self arrowDeltaFor: aGetter) ~= 1 ifTrue:			[aTile setProperty: #arrowDelta toValue: delta]].	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: aGetter) width: 30.Preferences universalTiles 	ifTrue: [		ms _ MessageSend receiver: self selector: aGetter asSymbol arguments: #().		slotMsg _ ms asTilesIn: self class globalNames: (self class officialClass ~~ CardPlayer).			"For CardPlayers, use 'self'.  For others, name it, and use its name."		ms _ MessageSend receiver: 3 selector: #= asSymbol arguments: #(5).		aLine _ ms asTilesIn: self class globalNames: false.		aLine firstSubmorph delete.		aLine addMorphFront: slotMsg.		aLine lastSubmorph delete.		aLine lastSubmorph delete.		aLine color: aColor.		aLine addMorphBack: aTile.		aLine cellPositioning: #leftCenter]	ifFalse: [		aLine _ AlignmentMorph newRow			hResizing: #shrinkWrap;			vResizing: #shrinkWrap; 			color: aColor;			layoutInset: -1;			borderWidth: 1;			borderColor: aColor darker;			listCentering: #center.		aLine addMorphBack: (self tileReferringToSelf				borderWidth: 0; layoutInset: 4@0;				typeColor: aColor; 				color: aColor; bePossessive).		aLine addMorphBack: (StringMorph contents: watcherWording, ' = ' font: ScriptingSystem fontForTiles).		aLine addMorphBack: aTile].	aWatcher step; fitContents.	aLine openInHand! !!Player methodsFor: 'scripts-standard' stamp: 'nk 8/21/2004 12:39'!tellAllSiblings: aMessageSelector	"Send the given message selector to all my sibling instances, but not to myself"	Symbol hasInterned: aMessageSelector		ifTrue: [ :sel |	self belongsToUniClass		ifTrue: [self class allSubInstancesDo:				[:anInstance | anInstance ~~ self ifTrue: [ anInstance triggerScript: sel ]]]		ifFalse:			[(sel ~~ #emptyScript) ifTrue:				[ScriptingSystem reportToUser: ('Cannot "tell" ', aMessageSelector, ' to ', self externalName) ]]]! !!Player methodsFor: 'scripts-standard' stamp: 'nk 8/21/2004 12:15'!performScriptIfCan: scriptNameString 	"If I understand the given script name, perform it now"	^Symbol		hasInterned: scriptNameString		ifTrue: [:sym | (self class includesSelector: sym)				ifTrue: [self triggerScript: sym]]! !!Player methodsFor: 'scripts-standard' stamp: 'nk 8/21/2004 12:42'!tellSelfAndAllSiblings: aMessageSelector	"Send the given message selector to all my sibling instances, including myself"	Symbol hasInterned: aMessageSelector		ifTrue: [ :sel |	self belongsToUniClass		ifTrue: [self class allSubInstancesDo:				[:anInstance | anInstance triggerScript: sel ]]		ifFalse:			[(sel ~~ #emptyScript) ifTrue:				[ScriptingSystem reportToUser: ('Cannot "tell" ', aMessageSelector, ' to ', self externalName) ]]]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'nk 1/11/2004 15:29'!doneWithEdits	"If in a SyntaxMorph, shrink min width after editing"	| editor |	super doneWithEdits.	(owner respondsTo: #parseNode) ifTrue: [minimumWidth _ 8].	editor _ (submorphs detect: [ :sm | sm isKindOf: StringMorphEditor ] ifNone: [ ^self ]).	editor delete.! !!Form class methodsFor: 'file list services' stamp: 'nk 1/6/2004 12:36'!openImageInWindow: fullName	"Handle five file formats: GIF, JPG, PNG, Form storeOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream _ (FileStream readOnlyFileNamed: fullName) binary.	image _ self fromBinaryStream: myStream.	myStream close.	Smalltalk isMorphic ifTrue:[		Project current resourceManager 			addResource: image 			url: (FileDirectory urlForFileNamed: fullName) asString.	].	Smalltalk isMorphic		ifTrue: [(World drawingClass withForm: image) openInWorld]		ifFalse: [FormView open: image named: fullName]! !!SARInstaller methodsFor: 'client services' stamp: 'nk 6/12/2004 10:03'!openGraphicsFile: memberOrName	| member morph |	member _ self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	morph _ (World drawingClass fromStream: member contentStream binary).	morph ifNotNil: [ morph openInWorld ].	self installed: member.! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'RAA 5/2/2001 23:35'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht f¬¶¬r n-m matches"	matches := TwoLevelDictionary new.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!FlexibleVocabulariesInfo class methodsFor: 'class initialization' stamp: 'nk 5/3/2004 15:48'!initialize	[self new register] on: MessageNotUnderstood do: [].	SyntaxMorph class removeSelector: #initialize.	SyntaxMorph removeSelector: #allSpecs.	EToyVocabulary removeSelector: #morphClassesDeclaringViewerAdditions.	SyntaxMorph clearAllSpecs.	Vocabulary initialize.! !!MPEGMoviePlayerMorph class methodsFor: 'registering' stamp: 'sw 9/7/2004 18:22'!openFile: aFileName	"Open the given file (if not nil) in an instance of the receiver."     | wrapper |	aFileName ifNil: [^ Beeper beep].     wrapper _ self openOn: aFileName. 	wrapper openInWorld.     ^ wrapper! !!MPEGMoviePlayerMorph class methodsFor: 'registering' stamp: 'sw 9/7/2004 18:17'!serviceOpenInMPEGPlayer	"Answer a service for opening a file in an MPEGMoviePlayer"	^ SimpleServiceEntry 		provider: self 		label: 'open'		selector: #openFile:		description: 'open file in an MPEG player'		buttonLabel: 'open'! !!MPEGMoviePlayerMorph class methodsFor: 'registering' stamp: 'sw 9/7/2004 18:22'!playFile: aFileName	"Play the given file (if not nil) in an MPEGMoviePlayerMorph"     | wrapper |	aFileName ifNil: [^ Beeper beep].     wrapper _ self openOn: aFileName.     wrapper moviePlayer startPlaying.      "wrapper openInWindow."	wrapper openInWorld.     ^wrapper! !!MPEGMoviePlayerMorph class methodsFor: 'fileIn/Out' stamp: 'sw 9/7/2004 18:17'!services 	"Answer the receiver's services"     ^ OrderedCollection with: self servicePlayInMPEGPlayer with: self serviceOpenInMPEGPlayer! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'nk 6/12/2004 09:23'!fixOldVersion	| uName uForm uEmail uIP |	uName _ self userName.	uForm _ userPicture ifNil: [		(self 		findDeepSubmorphThat: [ :x | (x isKindOf: ImageMorph) or: [x isSketchMorph]] 		ifAbsent: [self halt]) form.	].	uEmail _ (fields at: #emailAddress) contents.	uIP _ self ipAddress.	self		userName: uName 		userPicture: (uForm scaledToSize: 61@53)		userEmail: uEmail 		userIPAddress: uIP! !!MailMessage methodsFor: 'printing/formatting' stamp: 'nk 6/12/2004 09:36'!viewImageInBody	| stream image |	stream _ self body contentStream.	image _ Form fromBinaryStream: stream.	(World drawingClass withForm: image) openInWorld! !!AssignmentTileMorph methodsFor: 'arrow' stamp: 'nk 10/8/2004 14:27'!addArrowsIfAppropriate	"If the receiver's slot is of an appropriate type, add arrows to the tile."	(Vocabulary vocabularyForType: dataType)		ifNotNilDo:			[:aVocab | aVocab wantsAssignmentTileVariants ifTrue:				[self addArrows]].	(assignmentSuffix = ':') ifTrue:		[ self addMorphBack: (ImageMorph new image: (ScriptingSystem formAtKey: #NewGets)).		(self findA: StringMorph) ifNotNilDo: [ :sm |			(sm contents endsWith: ' :') ifTrue: [ sm contents: (sm contents allButLast: 2) ]]]! !!AssignmentTileMorph methodsFor: 'as yet unclassified' stamp: 'nk 10/8/2004 15:05'!fixLayout	super fixLayout.	self updateLiteralLabel; updateWordingToMatchVocabulary; layoutChanged; fullBounds! !!FileOutFormatTest methodsFor: 'as yet unclassified' stamp: 'yo 7/8/2004 08:29'!setUp	FileOutFormatTest compileSilently: 'asciiMethod\\	"a method with all ASCII chars."\' withCRs classified: 'support'.	FileOutFormatTest compileSilently: 'latin1Method\\	"a method with some latin1 chars. -¬¨¬¬¶¦°¬¨¬®¬¨¬·<¬¨¬¬¶¦°¬¨¬®¬¨¦®>¬¨¬¬¶¦°¬¨¬®¬¨¬ô+"\	^ ''-¬¨¬¬¶¦°¬¨¬®¬¨¬·<¬¨¬¬¶¦°¬¨¬®¬¨¦®>¬¨¬¬¶¦°¬¨¬®¬¨¬ô+''' withCRs classified: 'support'.! !!MethodInterface methodsFor: 'printing' stamp: 'nk 8/20/2004 09:38'!printOn: aStream	"print the receiver on a stream.  Overridden to provide details about wording, selector, result type, and companion setter."	super printOn: aStream.	aStream nextPutAll: ' - wording: ';		print: self wording;		nextPutAll: ' selector: ';		print: selector.	self argumentVariables size > 0 ifTrue:		[aStream nextPutAll: ' Arguments: '.		argumentVariables doWithIndex:			[:aVariable :anIndex | 				aStream nextPutAll: 'argument #', anIndex printString, ' name = ', aVariable variableName asString, ', type = ', aVariable variableType]].	resultSpecification ifNotNil:		[aStream nextPutAll: ' result type = ', resultSpecification resultType asString.		resultSpecification companionSetterSelector ifNotNil:			[aStream nextPutAll: ' setter = ', resultSpecification companionSetterSelector asString]]	! !!ScriptEditorMorph methodsFor: 'menu' stamp: 'nk 10/8/2004 15:27'!fixLayout	"Tell all morphs that their layout has changed, using a sledge-hammer"	"fix fonts and layout"	self		allMorphsDo: [:m | 			m ~~ self				ifTrue: [(m respondsTo: #fixLayout)						ifTrue: [m fixLayout]].			m layoutChanged]! !!ScriptEditorMorph methodsFor: '*customevents-other' stamp: 'nk 6/12/2004 14:23'!explainStatusAlternatives	(StringHolder new contents: ScriptingSystem statusHelpString)		openLabel: 'Script Status' translated! !!ScriptEditorMorph methodsFor: 'other' stamp: 'nk 10/8/2004 11:47'!unhibernate	"I have been loaded as part of an ImageSegment.	Make sure that I am fixed up properly."	self topEditor == self		ifFalse: [^ self]. "Part of a compound test"	self updateHeader.	self fixLayout.	"Recreate my tiles from my method if i have new universal tiles."	self world		ifNil: [(playerScripted isNil					or: [playerScripted isUniversalTiles not])				ifTrue: [^ self]]		ifNotNil: [Preferences universalTiles				ifFalse: [^ self]].	self insertUniversalTiles.	self showingMethodPane: false! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'nk 8/21/2004 12:16'!tryMe	"Evaluate the given script on behalf of the scripted object"	scriptName numArgs = 0		ifTrue:			[self playerScripted performScriptIfCan: scriptName ]! !!ScriptEditorMorph methodsFor: '*customevents-buttons' stamp: 'nk 4/23/2004 07:28'!actuallyDestroyScript	"Carry out the actual destruction of the associated script."	| aHandler itsCostume |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName ifAbsent: [].		"not quite enough yet in the multiple-instance case..."	itsCostume _ playerScripted costume.	(aHandler _ itsCostume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	itsCostume removeActionsSatisfying: [ :act | act receiver == playerScripted and: [ act selector == scriptName ]].	itsCostume currentWorld removeActionsSatisfying: [ :act | act receiver == playerScripted and: [ act selector == scriptName ]].	playerScripted updateAllViewersAndForceToShow: ScriptingSystem nameForScriptsCategory! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'nk 8/21/2004 15:55'!writeRecentCharacters: nCharacters toFileNamed: aFilename	"Schedule an editable text view on the last n characters of changes."	| changes |	changes _ SourceFiles at: 2.	changes setToEnd; skip: nCharacters negated.	(StandardFileStream newFileNamed: aFilename) nextPutAll: (changes next: nCharacters); close; open; edit! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/26/2001 14:22'!alanBinaryPostRcvr: aNode key: key args: args	| nodeWithNilReceiver row |"==Repeat for collection [ collect ( from foo. blah blah foo blah) ]Repeat for 1 to 50¬¨¬Ü [ do¬¨¬Ü ( from i. blah blab i blah¬¨¬Ü )¬¨¬Ü ]=="	nodeWithNilReceiver _ aNode copy receiver: nil.	(row _ self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	row addToken: key asString		type: #binary		on: (SelectorNode new key: key asString code: nil "fill this in?").	args first asMorphicSyntaxIn: row.! !!SyntaxMorph class methodsFor: '*flexiblevocabularies-accessing' stamp: 'nk 4/22/2004 20:39'!clearAllSpecs	"Clear the specs that the Viewer knows about."	"SyntaxMorph clearAllSpecs"	AllSpecs _ nil.! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'nk 6/23/2003 13:31'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line _ textLine.	rightMargin _ line rightMargin.	lastIndex _ line first.	self setStopConditions.		"also sets font"	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX _ leftMargin _ line leftMarginForAlignment: alignment.	destY _ line top.	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	done  _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex == nil				ifTrue: [					"Result for characterBlockAtPoint: "					(lastIndex == line last						and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ])							ifTrue: [ "Correct for right half of last character in line"								^ (CharacterBlock new stringIndex: lastIndex + 1										text: text										topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)										extent:  0 @ lastCharacterExtent y)									textLine: line							].						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifFalse: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !