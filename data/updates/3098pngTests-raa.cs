'From Squeak2.9alpha of 17 July 2000 [latest update: #3154] on 10 December 2000 at 10:12:35 am'!"Change Set:		pngTestsDate:			10 December 2000Author:			Bob Arning- a few minor tweaks to png image reading"!ImageReadWriter subclass: #PNGReadWriter	instanceVariableNames: 'chunk form width height depth bitsPerChannel colorType interlaceMethod bitsPerPixel bytesPerScanline thisScanline prevScanline rowSize globalDataChunk unknownChunks palette transparentPixelValue filtersSeen '	classVariableNames: 'BPP BlockHeight BlockWidth Debugging '	poolDictionaries: ''	category: 'Graphics-Files'!!PNGReadWriter methodsFor: 'accessing' stamp: 'RAA 11/7/2000 09:20'!debugging	^Debugging == true! !!PNGReadWriter methodsFor: 'accessing' stamp: 'RAA 11/7/2000 09:20'!nextImage	filtersSeen _ Bag new.	globalDataChunk _ nil.	transparentPixelValue _ nil.	unknownChunks _ Set new.	stream reset.	(stream respondsTo: #binary) ifTrue: [ stream binary] .	stream skip: 8.	[stream atEnd] whileFalse: [		self processNextChunk.	].	chunk _ globalDataChunk.	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty ifFalse: [		"Transcript show: ' ',unknownChunks asSortedCollection asArray printString."	].	self debugging ifTrue: [		Transcript cr; show: 'form = ',form printString.		Transcript cr; show: 'colorType = ',colorType printString.		Transcript cr; show: 'interlaceMethod = ',interlaceMethod printString.		Transcript cr; show: 'filters = ',filtersSeen sortedCounts asArray printString.	].	^ form! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/6/2000 22:31'!processInterlaced	| z filter bytesPerPass startingCol colIncrement rowIncrement startingRow cx sc temp |	startingCol _ #(0 4 0 2 0 1 0 ).	colIncrement _ #(8 8 4 4 2 2 1 ).	rowIncrement _ #(8 8 8 4 4 2 2 ).	startingRow _ #(0 0 4 0 2 0 1 ).	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: [:pass |		(self doPass: pass)			ifTrue:				[cx _ colIncrement at: pass.				sc _ startingCol at: pass.				bytesPerPass _ width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline _ ByteArray new: bytesPerPass.				thisScanline _ ByteArray new: bytesPerScanline.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do: [:y |						filter _ z next.						filtersSeen add: filter.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline _ z next: bytesPerPass into: thisScanline startingAt: 1.						self filterScanline: filter count: bytesPerPass.						self copyPixels: y at: sc by: cx.						temp := prevScanline.						prevScanline := thisScanline.						thisScanline := temp.					]				]	].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/6/2000 22:42'!processNonInterlaced	| z filter temp |	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline _ ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height-1 do: [ :y |		filter _ (z next: 1) first.		filtersSeen add: filter.		(filter isNil or: [(filter between: 0 and: 4) not])			ifTrue: [^ self].		thisScanline _ z next: bytesPerScanline into: thisScanline startingAt: 1.		self filterScanline: filter count: bytesPerScanline.		self copyPixels: y.		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp.		]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'RAA 11/7/2000 09:43'!filterAverage: count	"Use the average of the pixel to the left and the pixel above as a predictor"	| delta |	delta _ bitsPerPixel // 8 max: 1.	1 to: delta do: [:i |		thisScanline at: i put: ((thisScanline at: i) + ((prevScanline at: i) // 2) bitAnd: 255)].	delta + 1 to: count do: [:i |		thisScanline at: i put:			((thisScanline at: i)			+ ((prevScanline at: i)			+ (thisScanline at: i - delta) // 2) bitAnd: 255)]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'RAA 11/7/2000 09:45'!filterPaeth: count	"Select one of (the pixel to the left, the pixel above and the pixel to above left) to	predict the value of this pixel"	| delta |	delta _ bitsPerPixel // 8 max: 1.	1 to: delta do: [ :i |		thisScanline at: i put:			(((thisScanline at: i) + (prevScanline at: i)) bitAnd: 255)].	delta+1 to: count do: [ :i |		thisScanline			at: i			put: (((thisScanline at: i) + (self				paethPredictLeft: (thisScanline at: i-delta)				above: (prevScanline at: i)				aboveLeft: (prevScanline at: i-delta)))					bitAnd: 255)]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/7/2000 09:30'!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	bitsPerChannel = 8 ifTrue: [		i := 1.		1 to: width do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x put: pixel.			i _ i + 3.		]	] ifFalse: [		i := 1.		1 to: width do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x put: pixel.			i _ i + 6.		]	].	transparentPixelValue ifNotNil: [		1 to: width do: [ :x |			(tempBits at: x) = transparentPixelValue ifTrue: [				tempBits at: x put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:22'!createAFormFrom: data	| error f |	error _ ''.	f _ [		self formFromStream: (RWBinaryOrTextStream with: data)	] ifError: [ :a :b |		error _ a printString,'  ',b printString.		(StringMorph contents: error) color: Color red; imageForm	].	^{f. error}! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:20'!debugging: aBoolean	Debugging _ aBoolean! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:15'!insertMorph: aMorph named: aString into: aBook	| newPage |	aBook ifNil: [^self].	newPage _ aBook insertPageLabel: aString morphs: {aMorph}.	newPage color: Color lightYellow.	newPage extent: (		newPage submorphs inject: 10@10 into: [ :ex :m |			m left: 10.			ex max: m width @ m bottom		]	) + (20@20).! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 12/10/2000 10:11'!test1"PNGReadWriter test1"	| data t error d0 d1 f fileInfo book result d2 |	Debugging _ true.	1 = 1 ifTrue: [		book _ BookMorph new.		book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	].	d0 _ FileDirectory default.	d1 _ d0 directoryNamed: 'PngSuite Folder'.	d2 _ d0 directoryNamed: 'BIG PNG'.	{d0. d1. d2}.		"keep compiler quiet""==citrus_none_sub.pngcitrus_adm7_adap.pngcitrus_adm7_aver.pngcitrus_adm7_non.pngcitrus_adm7_paeth.pngpngs-img-ie5mac.png=="	fileInfo _ {		d2. {'citrus_adm7_adap.png'}.		"d1. d1 fileNames."	}.	fileInfo pairsDo: [ :dir :fileNames |		fileNames do: [ :each |			Transcript cr; show: each.			data _ (dir fileNamed: each) contentsOfEntireFile.			error _ ''.			MessageTally spyOn: [				t _ [					result _ self createAFormFrom: data.					f_ result first.					error _ result second.				] timeToRun.].			self insertMorph: f asMorph named: each into: book.			Transcript show: each,'  ',data size printString,' = ',t printString,' ms',error; cr.		].	].	book ifNotNil: [book openInWorld].	Debugging _ false.! !