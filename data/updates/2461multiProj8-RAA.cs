'From Squeak2.9alpha of 17 July 2000 [latest update: #2457] on 17 July 2000 at 1:35:32 pm'!"Change Set:		multiProjects8Date:			7 July 2000Author:			Bob ArningWhen saving (publishing) a morphic project whose parent is MVC, several problems were observed:- SystemWindow class variable TopWindow held a reference to a morph in the saving project- the saving happened without changing the active Process. This left other morph references alive on the stack.Both of these problems caused the save to notice morphs pointed to from outside and ask for help. If 'debug' was chosen, nothing happened on the screen since ScheduledControllers was in a funny stateSo the fixes:When leaving a morphic project to go to an MVC project, 1. Clear TopWindow.2. Create a new process (as would happen when going from morphic to morphic).3. Reset some key variables in ScheduledControllers------- When saving (or reloading) the current project, one must exit to another project. This project will now be one that shows the saving/loading project's image as the desktop so the user is not exposed to a potentially troubling discontinuity- When adding mouse up actions to a morph from the debug menu, handlers are also installed to change the cursor while over the morph and on mouse down to indicate this possible action.- Improvements to the email window for sending project links to a friend- fixed ProcessorScheduler>>objectForDataStream: (was missing the #)- beginnings of EToy communications. See the class comments on EToyChatMorph, EToyListenerMorph and EToySenderMorph- added EToyProjectHistoryMorph to display the most recent n (currently 10) projects- added EToyGateKeeperMorph to allow user control of communications accepted- reverted (temporarily I hope) the saving of projects to the old way pending resolution of the forward reference problem- 12 july changes--- use veryDeepCopy in sender and listener so players are copied correctly--- tear off project view morph from project history morph--- keep current project at top of project history morph--- deleted extraneous reference to the Publish project from the project history--- added zoom button to embedded project frame--- added translucent frame for morphs with special mouseup action--- added button to sender morph to initiate chat with that person--- added button to sender morph to open telemorphic and add users picture to the remote hand--- fixed color picker morph in embedded worlds--- added fixup method to correct early versions of Alan's mouse up event handlers-13 july changes--- if project history morph in a flap, close flap when jumping to project--- added additional controls to embedded worlds for views and entry--- better telemorphic start from sender badge--- added tell-a-friend button to sender badge--- moved add/remove mouseUp action to top level of red menu--- scale sender badge pictures to same size--- prefill user name and ip address when starting telemorphic from sender badge--- the 'Fridge' is now available--- fancy blue verion of project loader created--- fixed pen trails problem in embedded feedback car project--- fixed stepping of new arrivals in the fridge-14 july changes--- added user picture to each line of text received in chat--- fixed inset borders walkback when morph has no owner--- use form 'fridge.form' from default directory (if it exists) as background for the fridge morph--- show project load progress on the file picker morph--- enabled removal of sender badges from fridge--- use pictures for both chat participants--- delete project loader picker when project loaded--- fudged up fridge so morphs start below the bar--- made chat internal to sender badge.--- if chat received and no chat present, user sender if present.--- try to keep new items on fridge project fully in the world.--- made drop zone on sender badge smaller.--- made the fridge morph a button to jump to the fridge project--- add button to navigator to toggle full screen--- prevent chat in a sender in the fridge--- limit senders in fridge to 2 per row until there are more than 615 july--- allow sender badges to be dragged out of fridge again (broken when enabling click-to-go-to-fridge)--- fixed blinking balloon on Escape Browser button--- fixed clipping of small sender badge images in chat window--- un-broke the toggling off of chat in a sender badge--- made EToyListener use single listener/queue accessible to listeners in any project--- when loading a project with same name as existing project, use <name>N rather than unnamedN--- looking for a newer version and seeing 'This project thinks it has never been on a server' now offers a chance to select a server16 July--- bigger mouse ears--- unhelpful code removed from PasteUpMorph>>sleep--- missing gradient restored to project loading picker--- added navigator button to toggle flap display--- added 'Socket newAcceptCheck' to test if support of BSD style accept() is present--- reverted change to Morph>>moveWithPenDownBy: (temporarily)--- if using history morph from flap, ensure that flap does not show in thumbnail--- added jump to button to top of history--- reduced amount of flashing when sending a morph to speed up transfer--- put incoming chat in a sender badge at all costs--- added gate keeper info to listener morph--- created EToyMorphsWelcomeMorph. If one of these exists in the current world, then received morphs will appear automatically at the same position they had in their originating world--- added new rollover indicators to ProjectViewMorphs--- enabled DnD into ProjectViewMorphs providing that the project is actually in memory"!Object subclass: #EToyPeerToPeer	instanceVariableNames: 'socket dataToSend communicatorMorph process ipAddress connectionQueue '	classVariableNames: 'DEBUG PREVTICK '	poolDictionaries: ''	category: 'Network-EToy Communications'!!AlignmentMorphBob1 commentStamp: 'RAA 7/17/2000 12:39' prior: 0!A quick and easy to space things vertically in absolute or proportional amounts.!Morph subclass: #DoCommandOnceMorph	instanceVariableNames: 'target command actionBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!DoCommandOnceMorph commentStamp: '<historical>' prior: 0!I am used to execute a once-only command. My first use was in loading/saving the current project. In such cases it is necessary to be in another project to do the actual work. So an instance of me is added to a new world/project and that project is entered. I do my stuff (save/load followed by a re-enter of the previous project) and everyone is happy.!AlignmentMorphBob1 subclass: #EToyCommunicatorMorph	instanceVariableNames: 'fields resultQueue '	classVariableNames: 'LastFlashTime '	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyCommunicatorMorph commentStamp: '<historical>' prior: 0!An abstract superclass of various EToy communicator widgets!EToyCommunicatorMorph subclass: #EToyChatOrBadgeMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!EToyChatOrBadgeMorph subclass: #EToyChatMorph	instanceVariableNames: 'listener receivingPane myForm recipientForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyChatMorph commentStamp: 'RAA 7/17/2000 12:39' prior: 0!EToyChatMorph new open setIPAddress: '1.2.3.4'"EToyChatMorph represents a chat session with another person. Type your message in the top text pane and press cmd-S."!]style[(46 122)f2cblue;,f1!EToyCommunicatorMorph subclass: #EToyFridgeMorph	instanceVariableNames: 'recipients incomingRow recipientRow updateCounter groupMode '	classVariableNames: 'FridgeRecipients NewItems TheFridgeForm UpdateCounter '	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyFridgeMorph commentStamp: '<historical>' prior: 0!EToyFridgeMorph new openInWorld!]style[(31)f4cblue;!MorphicModel subclass: #EToyGateKeeperEntry	instanceVariableNames: 'ipAddress accessAttempts lastTimes acceptableTypes latestUserName attempsDenied lastRequests '	classVariableNames: 'KnownIPAddresses '	poolDictionaries: ''	category: 'Morphic-Experimental'!EToyCommunicatorMorph subclass: #EToyGateKeeperMorph	instanceVariableNames: 'counter '	classVariableNames: 'KnownIPAddresses UpdateCounter '	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyGateKeeperMorph commentStamp: 'RAA 7/17/2000 12:40' prior: 0!EToyGateKeeperMorph new open"I am used to control the types of connections a user is willing to allow."!]style[(28 79)f4cblue;,f1!EToyCommunicatorMorph subclass: #EToyListenerMorph	instanceVariableNames: 'listener updateCounter '	classVariableNames: 'GlobalIncomingQueue GlobalListener QueueSemaphore UpdateCounter '	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyListenerMorph commentStamp: '<historical>' prior: 0!EToyListenerMorph new openEToyListenerMorph startListening.EToyListenerMorph stopListening."EToyListenerMorph listens for messgaes from other EToy communicators. You need one of these open to receive messages from elsewhere.- Received Morphs are shown in a list. Items can be grabbed (a copy) or deleted.- Chat messages are sent to an appropriate EToyChatMorph (created if necessary)"!]style[(45 16 18 15 1 299)cblue;f3,bf3,cblue;f3,bf3,cblue;f3,f1!EToyCommunicatorMorph subclass: #EToyMorphsWelcomeMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyMorphsWelcomeMorph commentStamp: '<historical>' prior: 0!EToyMorphsWelcomeMorph new openInWorld!EToyCommunicatorMorph subclass: #EToyProjectHistoryMorph	instanceVariableNames: 'changeCounter '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToyProjectHistoryMorph commentStamp: '<historical>' prior: 0!EToyProjectHistoryMorph new openInWorldEToyProjectHistoryMorph provides a quick reference of the most recent projects. Click on one to go there.!]style[(40 106)f3cblue;,f1!EToyChatOrBadgeMorph subclass: #EToySenderMorph	instanceVariableNames: 'userPicture '	classVariableNames: 'DEBUG '	poolDictionaries: ''	category: 'Morphic-Experimental'!!EToySenderMorph commentStamp: 'RAA 7/17/2000 12:41' prior: 0!EToySenderMorph	new	userName: 'Bob Arning' 	userPicture: nil 	userEmail: 'arning@charm.net' 	userIPAddress: '1.2.3.4';	position: 200@200;	open"EToySenderMorph represents another person to whom you wish to send things. Drop a morph on an EToySenderMorph and a copy of that morph is sent to the person represented. Currently only peer-to-peer communications are supported, but other options are planned."!]style[(149 1 262)cblue;f2,f2,f1!UpdatingThreePhaseButtonMorph subclass: #EtoyUpdatingThreePhaseButtonMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!EtoyUpdatingThreePhaseButtonMorph commentStamp: 'RAA 7/17/2000 13:13' prior: 0!A slight variation wherein the actionSelector and getSelector both take argument(s).!Morph subclass: #MouseActionIndicatorMorph	instanceVariableNames: 'siblings '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!MouseActionIndicatorMorph commentStamp: '<historical>' prior: 0!I am used to highlight morphs which have a special mouseup action!Notification subclass: #ProgressTargetRequestNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!ProgressTargetRequestNotification commentStamp: '<historical>' prior: 0!I am used to allow the ComplexProgressIndicator one last chance at finding an appropriate place to display. If I am unhandled, then the cursor location and a default rectangle are used.!!ProjectEntryNotification commentStamp: '<historical>' prior: 0!I provide a way to override the style of Project entry (which is buried deep in several different methods). My default is a normal full-screen enter.!Model subclass: #ProjectHistory	instanceVariableNames: 'mostRecent '	classVariableNames: 'ChangeCounter CurrentHistory '	poolDictionaries: ''	category: 'System-Support'!!RequestAlternateSyntaxSetting commentStamp: '<historical>' prior: 0!I provide a way to override the current setting of the alternate syntax preference. I am used when filing in code to insure that the Smalltalk-80 preference is used regardless of what the user likes to see in her browsers.!!RequestCurrentWorldNotification commentStamp: '<historical>' prior: 0!I provide a way to alter the "currentWorld" in which non-specific things happen. Code which says:	aMorph openInWorldfor example, will try to open in this "currentWorld" (whose precise definition is still a bit fuzzy). By writing something like:	[		someAnonymousStuff happen	]		on: RequestCurrentWorldNotification		do: [ :ex | ex resume: aParticularWorld ]you can ensure that <aParticularWorld> is used for any non-specific world request during the execution of the block.!Controller subclass: #ScreenController	instanceVariableNames: ''	classVariableNames: 'LastScreenModeSelected '	poolDictionaries: ''	category: 'Kernel-ST80 Remnants'!AlignmentMorphBob1 subclass: #StretchyImageMorph	instanceVariableNames: 'form cache '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!StretchyImageMorph commentStamp: '<historical>' prior: 0!I draw a form to fill whatever bounds I have.!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime '	classVariableNames: 'DeferredUIMessages DisableDeferredUpdates MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Worlds'!!Object methodsFor: 'user interface' stamp: 'RAA 7/10/2000 08:11'!eToyStreamedRepresentationNotifying: aWidget	| outData |	[ outData _ SmartRefStream streamedRepresentationOf: self ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				aWidget ifNotNil: [aWidget flashIndicator: #working].			].		].	^outData! !!ChangeSet class methodsFor: 'defaults' stamp: 'RAA 7/15/2000 18:38'!uniqueNameLike: aString	| namesInUse try |	namesInUse _ ChangeSorter gatherChangeSets collect: [:each | each name].	1 to: 999999 do: [:i |		try _ aString , i printString.		(namesInUse includes: try) ifFalse: [^ try]	]! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:33'!forkProgressWatcher	| killTarget |	[		[stageCompleted < 999 and: 				[formerProject == Project current and: 				[formerWorld == World and: 				[translucentMorph world notNil and:				[formerProcess suspendedContext notNil and: 				[Project uiProcess == formerProcess]]]]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			translucentMorph owner addMorphInLayer: translucentMorph.			self backgroundWorldDisplay.			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		killTarget _ targetMorph ifNotNil: [			targetMorph valueOfProperty: #deleteOnProgressCompletion		].		formerWorld == World ifTrue: [			translucentMorph delete.			killTarget ifNotNil: [killTarget delete].		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.			killTarget ifNotNil: [killTarget privateDeleteWithAbsolutelyNoSideEffects].		].	] forkAt: 6.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 12:25'!withProgressDo: aBlock	| safetyFactor totals trialRect delta |	Smalltalk isMorphic ifFalse: [^aBlock value].	formerProject _ Project current.	formerWorld _ World.	formerProcess _ Processor activeProcess.	targetMorph ifNil: [targetMorph _ ProgressTargetRequestNotification signal].	targetMorph ifNil: [		trialRect _ Rectangle center: Sensor cursorPoint extent: 80@80.		delta _ trialRect amountToTranslateWithin: formerWorld bounds.		trialRect _ trialRect translateBy: delta.		translucentMorph _ TranslucentProgessMorph new			opaqueBackgroundColor: Color white;			bounds: trialRect;			openInWorld: formerWorld.	] ifNotNil: [		translucentMorph _ TranslucentProgessMorph new			bounds: targetMorph bounds;			openInWorld: targetMorph world.	].	stageCompleted _ 0.	safetyFactor _ 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	totals _ self loadingHistoryDataForKey: 'total'.	newRatio _ 1.0.	estimate _ totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	start _ Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note |		stageCompleted _ (note messageText findTokens: ' ') first asNumber.		cumulativeStageTime _ Time millisecondClockValue - start max: 1.		prevData _ self loadingHistoryDataForKey: stageCompleted.		prevData isEmpty ifFalse: [			newRatio _ (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self loadingHistoryAt: stageCompleted add: cumulativeStageTime.		translucentMorph setProperty: #progressStageNumber toValue: stageCompleted + 1.		note resume.	].	stageCompleted _ 999.	"we may or may not get here"! !!ConnectionQueue methodsFor: 'public' stamp: 'RAA 7/15/2000 12:36'!getConnectionOrNilLenient	"Return a connected socket, or nil if no connection has been established."	| result |	accessSema critical: [		connections isEmpty ifTrue: [			result _ nil		] ifFalse: [			result _ connections removeFirst.			(result isValid and: [result isConnected or: [result isOtherEndClosed]]) ifFalse: [				"stale connection"				result destroy.				result _ nil			]		]	].	^ result! !!ControlManager methodsFor: 'scheduling' stamp: 'RAA 7/7/2000 09:22'!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController _ nil.	activeControllerProcess _ Processor activeProcess.! !!DisplayScanner methodsFor: 'scanning' stamp: 'RAA 7/15/2000 10:23'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY _ lineY.		runX _ destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 23:17'!awaitDataFor: aCommunicatorMorph	Socket initializeNetwork.	connectionQueue _ ConnectionQueue 		portNumber: self class eToyCommunicationsPort 		queueLength: 6.	communicatorMorph _ aCommunicatorMorph.	process _ [self doAwaitData] newProcess.	process priority: Processor highIOPriority.	process resume.! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 14:04'!debug: x	self class debug: x! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 14:05'!doAwaitData	[true] whileTrue: [		socket _ connectionQueue getConnectionOrNilLenient.		socket ifNil: [			(Delay forMilliseconds: 50) wait		] ifNotNil: [			self class new receiveDataOn: socket for: communicatorMorph		]	].! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 12:31'!doReceiveData	| firstPart awaitingLength i length answer remoteAddress |	Socket initializeNetwork.	remoteAddress _ socket remoteAddress.	self debug: '--RECEIVE start'.	firstPart _ ''.	awaitingLength _ true.	answer _ WriteStream on: String new.	[		[awaitingLength] whileTrue: [			firstPart _ firstPart,socket getData.			(i _ firstPart indexOf: $ ) > 0 ifTrue: [				awaitingLength _ false.				length _ (firstPart first: i - 1) asNumber.				answer nextPutAll: (firstPart allButFirst: i).			].		].		[answer size < length] whileTrue: [			answer nextPutAll: socket getData.			communicatorMorph commResult: {#commFlash -> true}.		].	] 		on: Error		do: [ :ex | 			socket closeAndDestroy.			^communicatorMorph commResult: {#message -> (ex description,' ',					length printString,' ',answer size printString,' ',socket printString)}		].	communicatorMorph commResult: {		#message -> 'OK'. 		#data -> answer contents.		#ipAddress -> remoteAddress.	}.	self debug: 'rcv close1'.	socket closeAndDestroy.	self debug: 'rcv close2'.! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 23:17'!doSendData	| success addr totalLength |	Socket initializeNetwork.	totalLength _ (dataToSend collect: [ :x | x size]) sum.	self debug: '--SEND start (',totalLength printString,' bytes)'.	addr _ NetNameResolver addressForName: ipAddress.	addr ifNil: [		^communicatorMorph commResult: {#message -> ('could not find ',ipAddress)}	].	socket connectTo: addr port: self class eToyCommunicationsPort.	success _ socket waitForConnectionUntil: (Socket deadlineSecs: 15).	self debug: {'send connect'. socket printString}.	success ifFalse: [		^communicatorMorph commResult: {#message -> ('no connection to ',ipAddress,' (',				(NetNameResolver stringFromAddress: addr),')')}	].	socket sendData: totalLength printString,' '.	dataToSend do: [ :chunk | self sendDataCautiously: chunk].	communicatorMorph commResult: {#message -> 'OK'}.	self debug: 'send close1'.	socket closeAndDestroy.	self debug: 'send close2'.! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 07:54'!receiveDataOn: aSocket for: aCommunicatorMorph	socket _ aSocket.	communicatorMorph _ aCommunicatorMorph.	process _ [self doReceiveData] newProcess.	process priority: Processor highIOPriority.	process resume.! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 23:29'!sendDataCautiously: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent. Try not to send too much at once since this seemed to cause problems talking to a port on the same machine"	| bytesSent bytesToSend count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		count _ socket 			sendSomeData: aStringOrByteArray 			startIndex: bytesSent + 1  			count: (bytesToSend - bytesSent min: 4000).		bytesSent _ bytesSent + count.		communicatorMorph commResult: {#commFlash -> true}.		(Delay forMilliseconds: 100) wait.	].	^ bytesSent! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 11:31'!sendSomeData: arrayOfByteObjects to: anIPAddress for: aCommunicatorMorph	Socket initializeNetwork.	socket _ Socket newTCP.	dataToSend _ arrayOfByteObjects.	communicatorMorph _ aCommunicatorMorph.	ipAddress _ anIPAddress.	process _ [self doSendData] newProcess.	process priority: Processor highIOPriority.	process resume.! !!EToyPeerToPeer methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 08:22'!stopListening	process ifNotNil: [process terminate. process _ nil].	connectionQueue ifNotNil: [connectionQueue destroy. connectionQueue _ nil].! !!EToyPeerToPeer class methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 14:10'!debug: x	| now |	(DEBUG isNil or: [DEBUG size > 100]) ifTrue: [DEBUG _ SharedQueue new].	now _ Time millisecondClockValue.	PREVTICK ifNil: [PREVTICK _ now].	DEBUG nextPut: {now - PREVTICK. x}.	PREVTICK _ now.! !!EToyPeerToPeer class methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 06:21'!eToyCommunicationsPort	^34151		"picked at random"! !!EventHandler methodsFor: 'fixups' stamp: 'RAA 7/12/2000 14:54'!fixAlansOldEventHandlers	(#(programmedMouseUp:for: programmedMouseUp:for:with:) 			includes: mouseUpSelector) ifFalse: [^self].	mouseDownSelector ifNotNil: [^self].	mouseUpRecipient addMouseUpActionWith: (		mouseUpRecipient valueOfProperty: #mouseUpCodeToRun ifAbsent: [valueParameter]	)! !!EventHandler class methodsFor: 'fixups' stamp: 'RAA 7/12/2000 15:03'!fixAlansOldEventHandlers"EventHandler fixAlansOldEventHandlers"	| allHandlers |	allHandlers _ EventHandler allInstances select: [ :each |		(#(programmedMouseUp:for: programmedMouseUp:for:with:) includes: 				each mouseUpSelector) and: [each mouseDownSelector isNil]	].	allHandlers do: [ :each |		each fixAlansOldEventHandlers	].! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:51'!borderAndButtonColor	^Color r: 0.729 g: 0.365 b: 0.729! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:51'!buttonWithAction: aSymbol label: labelString help: helpString	^self newColumn		centering: #center;		addMorph: (			SimpleButtonMorph new 				color: self borderAndButtonColor;				target: self; 				actionSelector: aSymbol;				label: labelString;				setBalloonText: helpString		)			! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:35'!forgetIt	morphicWindow ifNotNil: [ morphicWindow delete ].	mvcWindow ifNotNil: [ mvcWindow controller close ].! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:42'!newColumn	^AlignmentMorph newColumn color: self staticBackgroundColor! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:41'!newRow	^AlignmentMorph newRow color: self staticBackgroundColor! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:51'!openInMorphic	"open an interface for sending a mail message with the given initial 	text "	| buttonsList container toField subjectField |	(buttonsList _ self newRow centering: #center)		addMorphBack: (			(self 				buttonWithAction: #submit				label: 'send later'				help: 'add this to the queue of messages to be sent')		);		addMorphBack: (			(self 				buttonWithAction: #sendNow				label: 'send now'				help: 'send this message immediately')		);		addMorphBack: (			(self 				buttonWithAction: #forgetIt				label: 'forget it'				help: 'forget about sending this message')		).	morphicWindow _ container _ AlignmentMorphBob1 new		borderWidth: 8;		borderColor: self borderAndButtonColor;		color: Color white.	container heights: #(25 18 50 18 50 18 9999999).	container 		addMorphBack: buttonsList;		addMorphBack: (self simpleString: 'To:');		addMorphBack: (toField _ PluggableTextMorph			on: self			text: #to			accept: #to:		);		addMorphBack: (self simpleString: 'Subject:');		addMorphBack: (subjectField _ PluggableTextMorph			on: self			text: #subject			accept: #subject:		);		addMorphBack: (self simpleString: 'Message:');		addMorphBack: (textEditor _ PluggableTextMorph			on: self			text: #messageText			accept: #messageText:		).	textFields _ {toField. subjectField. textEditor}.	container 		extent: 300@400;		openInWorld.! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:42'!simpleString: aString	^self newRow		inset: 2;		addMorphBack: (StringMorph contents: aString) lock! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:38'!staticBackgroundColor	^Color veryLightGray! !!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 17:35'!submit: sendNow	| newMessageNumber personalCeleste windows |	personalCeleste _ false.	celeste ifNil: [		personalCeleste _ true.		celeste _ Celeste open.	].	newMessageNumber _ celeste PROTOqueueMessageWithText: (		self breakLines: self completeTheMessage atWidth: 72	).	sendNow ifTrue: [celeste sendMail: {newMessageNumber}].	personalCeleste ifTrue: [		windows _ SystemWindow 			windowsIn: self currentWorld 			satisfying: [ :each | each model == celeste].		celeste close.		windows do: [ :each | each delete].	].	self forgetIt.! !!FileList methodsFor: 'file list menu' stamp: 'RAA 7/13/2000 14:11'!openProjectFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world."	fileName ifNil: [^self].	Project canWeLoadAProjectNow ifFalse: [^ self].	ProjectViewMorph 		openFromDirectory: directory 		andFileName: fileName! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 14:07'!getSelectedFile	directory ifNil: [^nil].	fileName ifNil: [^nil].	^ directory oldFileNamed: fileName! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:32'!okHitForProjectLoader	| areaOfProgress |	areaOfProgress _ modalView firstSubmorph.	[		areaOfProgress setProperty: #deleteOnProgressCompletion toValue: modalView.		self openProjectFromFile.		modalView delete.	"probably won't get here"	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: areaOfProgress].! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 19:22'!modalFolderSelectorForProjectLoad	| window fileModel w |	window _ self morphicViewProjectLoader2InWorld: self currentWorld reallyLoad: false.	fileModel _ window valueOfProperty: #FileList.	w _ self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	window openInWorld: w.	[window world notNil] whileTrue: [		window outermostWorldMorph doOneCycleNow.	].	^fileModel getSelectedDirectory withoutListWrapper! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 19:21'!morphicViewProjectLoader2InWorld: aWorld	^self morphicViewProjectLoader2InWorld: aWorld reallyLoad: true! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 00:38'!morphicViewProjectLoader2InWorld: aWorld reallyLoad: aBoolean	| window dir aFileList buttons ramp1 ramp2 ramp3 treePane textColor1 fileListPane pane2a pane2b |	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	ramp1 _ {		0.0->(Color r: 0.516 g: 0.645 b: 1.0).		1.0->(Color r: 0.742 g: 0.871 b: 1.0)	}.	ramp3 _ {		0.0->(Color r: 0.742 g: 0.871 b: 1.0).		1.0->(Color r: 0.516 g: 0.645 b: 1.0).	}.	ramp2 _ {		0.0->(Color r: 0.516 g: 0.645 b: 1.0).		1.0->(TranslucentColor r: 0.645 g: 0.968 b: 1.0 alpha: 0.56078431372549)	}.	dir _ FileDirectory default.	aFileList _ self new directory: dir.	aFileList optionalButtonSpecs: self specsForProjectLoader.	aFileList fileSelectionBlock: [ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			('*.pr' match: entry name) or: ['*.pr.gz' match: entry name]		]	].	window _ AlignmentMorph newColumn.	aFileList modalView: window.	window		setProperty: #FileList toValue: aFileList;		centering: #center;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	buttons _ #('OK' 'Cancel') collect: [ :each |		 (self fancyText: each ofSize: 15 color: textColor1)			hResizing: #rigid;			extent: 100@20;			inset: 4;			borderWidth: 0;			useRoundedCorners	].	treePane _ aFileList morphicDirectoryTreePane 		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane _ aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window		addMorphBack: (self inARow: (			self fancyText: 'Load A Project' ofSize: 21 color: textColor1		));		addMorphBack: (self inARow: {							buttons first. 							(Morph new extent: 30@5) color: Color transparent. 							buttons second						}		);		addMorphBack: (self inARow: (			self fancyText: 'Please select a project' ofSize: 21 color: Color blue		));		addMorphBack: (			self inARow: {				(self inAColumn: ((pane2a _ self inARow: (self inAColumn: treePane)) 					useRoundedCorners; inset: 6)) inset: 10.				(self inAColumn: ((pane2b _ self inARow: (self inAColumn: fileListPane)) 					useRoundedCorners; inset: 6)) inset: 10.			} 		).	window fixLayout.	window fullBounds.	self fill: window with: ramp1 oriented: 0.65.	self fill: pane2a with: ramp3 oriented: (0.7 @ 0.35).	self fill: pane2b with: ramp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		self fill: each with: ramp2 oriented: (0.75 @ 0).	].	buttons first 		on: #mouseUp 		send: (aBoolean ifTrue: [#okHitForProjectLoader] ifFalse: [#okHit])		to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	^ window openInWorld: aWorld.! !!Form methodsFor: 'scaling, rotation' stamp: 'RAA 7/13/2000 12:09'!scaledToSize: newExtent	| scale |	newExtent = self extent ifTrue: [^self].	scale _ newExtent x / self width min: newExtent y / self height.	^self magnify: self boundingBox by: scale smoothing: 2.! !!FormCanvas methodsFor: 'drawing-support' stamp: 'RAA 7/11/2000 15:49'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| innerRect patchRect start subCanvas |	self flag: #bob.		"we probably want a generic version of this in Canvas"	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					"warp combinationRule: Form erase"]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					"warp combinationRule: Form paint"].		subCanvas translateBy: patchRect topLeft negated truncated			during:[:offsetCanvas| aBlock value: offsetCanvas].		subCanvas form 			displayInterpolatedIn: (innerRect translateBy: origin) truncated			on: self form.	].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 7/12/2000 22:57'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isBitmapFill and:[aFillStyle isKindOf: InfiniteForm]) ifTrue:[		self flag: #fixThis.		self flag: #bob.		"maybe I fixed it"		^aFillStyle displayOnPort: (port clippedBy: aRectangle) at: aRectangle origin - origin		"^self fillRectangle: aRectangle color: aFillStyle"	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern _ aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self asBalloonCanvas fillRectangle: aRectangle fillStyle: aFillStyle.! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 10:59'!command: aString	"Overridden by HtmlFileStream to append commands directly without translation.  4/5/96 tk"	"We ignore any HTML commands.  Do nothing"! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:36'!nextPutAllWordArray: aWordArray	| ba hackwa hackba blt rowsAtATime sourceOrigin rowsRemaining |	self flag: #bob.		"do we need to be concerned by bytesPerElement??"	ba _ nil.	rowsAtATime _ 2000.		"or 8000 bytes"	hackwa _ Form new hackBits: aWordArray.	sourceOrigin _ 0@0.	[(rowsRemaining _ hackwa height - sourceOrigin y) > 0] whileTrue: [		rowsAtATime _ rowsAtATime min: rowsRemaining.		(ba isNil or: [ba size ~= (rowsAtATime * 4)]) ifTrue: [			ba _ ByteArray new: rowsAtATime * 4.			hackba _ Form new hackBits: ba.			blt _ (BitBlt toForm: hackba) sourceForm: hackwa.		].		blt 			combinationRule: Form over;			sourceOrigin: sourceOrigin;			destX: 0 destY: 0 width: 4 height: rowsAtATime;			copyBits.		self bufferStream nextPutAll: ba.		self flushBuffer.		sourceOrigin _ sourceOrigin x @ (sourceOrigin y + rowsAtATime).	].! !!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:22'!originalContents	^''		"used only to determine if we are byte-structured"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 7/11/2000 19:00'!writeForExportWithSources: fName inDirectory: aDirectory	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	"this is the old version which I restored until I solve the gzip problem"	| fileStream temp classes tempFileName zipper |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' at the end of the file name'.].	temp _ endMarker.	endMarker _ nil.	tempFileName _ aDirectory nextNameFor: 'SqProject' extension: 'temp'.	zipper _ [		(aDirectory oldFileNamed: tempFileName) compressFile.	"makes xxx.gz"		aDirectory 			rename: (tempFileName, FileDirectory dot, 'gz')			toBe: fName.		aDirectory			deleteFileNamed: tempFileName			ifAbsent: []	].	fileStream _ aDirectory newFileNamed: tempFileName.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker _ temp.	"append sources"	classes _ arrayOfRoots select: [:cls | 		(cls isKindOf: Behavior) and: [cls theNonMetaClass isSystemDefined]].	classes size = 0 ifTrue: [zipper value. ^ self].	fileStream reopen; setToEnd.	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	classes do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream close.	zipper value.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 7/11/2000 18:33'!writeForExportWithSourcesGZ: fName inDirectory: aDirectory	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	"this is the gzipped version which I have temporarily suspended until I can get resolve the problem with forward references tring to reposition the stream - RAA 11 june 2000"	| fileStream temp allClassesInRoots classesToWriteEntirely methodsWithSource |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' at the end of the file name'.].	temp _ endMarker.	endMarker _ nil.	fileStream _ GZipSurrogateStream newFileNamed: fName inDirectory: aDirectory.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker _ temp.	"append sources"	allClassesInRoots _ arrayOfRoots select: [:cls | cls isKindOf: Behavior].	classesToWriteEntirely _ allClassesInRoots select: [ :cls | cls theNonMetaClass isSystemDefined].	methodsWithSource _ OrderedCollection new.	allClassesInRoots do: [ :cls |		(classesToWriteEntirely includes: cls) ifFalse: [			cls selectorsAndMethodsDo: [ :sel :meth |				meth sourcePointer = 0 ifFalse: [methodsWithSource add: {cls. sel. meth}].			].		].	].	(classesToWriteEntirely isEmpty and: [methodsWithSource isEmpty]) ifTrue: [		fileStream reallyClose.	"since #close is ignored"		^ self	].	"fileStream reopen; setToEnd."	"<--not required with gzipped surrogate stream"	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	methodsWithSource do: [ :each |		fileStream nextPut: $!!.	"try to pacify ImageSegment>>scanFrom:"		fileStream nextChunkPut: 'RenamedClassSourceReader formerClassName: ',				each first name printString,' methodsFor: ',				(each first organization categoryOfElement: each second) asString printString,				' stamp: ',(Utilities timeStampForMethod: each third) printString; cr.		fileStream nextChunkPut: (each third getSourceFor: each second in: each first) asString.		fileStream nextChunkPut: ' '; cr.	].	classesToWriteEntirely do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream reallyClose.	"since #close is ignored"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 7/15/2000 18:37'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect ccFixups real insts receiverClasses |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal 				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is not compatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			real _ mapFakeClassesToReal at: aFakeClass.			(real indexIfCompact > 0) "and there is a fake class"				ifFalse: ["normal case"					aFakeClass allInstancesDo: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]				ifTrue: ["instances have the wrong class.  Fix them before anyone notices."					insts _ OrderedCollection new.					self allObjectsDo: [:obj | obj class == real ifTrue: [insts add: obj]].					insts do: [:misShapen | 						perfect _ smartRefStream convert: misShapen to: real.						(bads includes: misShapen) ifFalse: [							bads add: misShapen.							goods add: perfect]]]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		(aRoot isKindOf: Project) ifTrue: [aRoot ensureChangeSetNameUnique].		aRoot class class == Metaclass ifTrue: [ self declare: aRoot]	].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | 			aFake indexIfCompact > 0 ifTrue: [aFake becomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!Morph methodsFor: 'menus' stamp: 'RAA 7/13/2000 11:19'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	"Add the fill style items"	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/13/2000 15:47'!addMouseActionIndicatorsWidth: anInteger color: aColor	| inner allMorphs |	self deleteAnyMouseActionIndicators.	inner _ self boundsInWorld.	allMorphs _ MouseActionIndicatorMorph		world: self world 		inner: inner 		outer: (inner expandBy: anInteger) 		color: aColor.	self setProperty: #mouseActionIndicatorMorphs toValue: allMorphs.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/13/2000 11:19'!addMouseUpAction 	| codeToRun oldCode |	oldCode _ self valueOfProperty: #mouseUpCodeToRun ifAbsent: [''].	codeToRun _ FillInTheBlank request: 'MouseUp expression:' initialAnswer: oldCode.	self addMouseUpActionWith: codeToRun! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/12/2000 14:49'!addMouseUpActionWith: codeToRun	codeToRun isEmptyOrNil ifTrue: [^self].	self setProperty: #mouseUpCodeToRun toValue: codeToRun.	self		on: #mouseUp 		send: #programmedMouseUp:for:		to: self.	self		on: #mouseDown		send: #programmedMouseDown:for:		to: self.	self		on: #mouseEnter		send: #programmedMouseEnter:for:		to: self.	self		on: #mouseLeave		send: #programmedMouseLeave:for:		to: self.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:27'!altSpecialCursor0	"an arrow"	^(Form	extent: 16@16	depth: 8	fromArray: #( 0 0 0 0 14869218 3806520034 3806520034 3791650816 14848144 2425393296 2425393378 0 14848144 2425393296 2425414144 0 14848144 2425393296 2430730240 0 14848144 2425393296 3791650816 0 14848144 2425393378 3791650816 0 14848144 2425414370 3806461952 0 14848144 2430788322 3806519808 0 14848144 3791651042 3806520034 0 14848226 0 3806520034 3791650816 14868992 0 14869218 3806461952 14811136 0 58082 3806519808 0 0 226 3806520034 0 0 0 3806520034 0 0 0 14869218)	offset: 0@0)! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:28'!altSpecialCursor1	"a star and an arrow"	^(Form	extent: 31@26	depth: 8	fromArray: #( 14417920 0 0 0 0 0 0 0 3705461980 3705461980 3705405440 0 0 0 0 0 3705461980 3705461980 3705461760 0 0 0 0 0 14474460 3705461980 3705405440 0 0 0 0 0 56540 3705461980 3690987520 0 0 3690987520 0 0 220 3705461980 3705461760 0 0 3690987520 0 0 220 3705405440 3705461980 0 0 3705405440 0 0 0 3705461760 56540 3690987520 220 3705405440 0 0 0 3705405440 220 3705461760 220 3705405440 0 0 0 0 0 14474460 220 3705461760 0 0 0 0 0 56540 3691044060 3705461760 0 0 0 0 0 220 3705461980 3705461760 0 0 0 0 56540 3705461980 3705461980 3705461980 3705461980 3705461760 0 0 220 3705461980 3705461980 3705461980 3705461980 3705461760 0 0 0 3705461980 3705461980 3705461980 3705461980 3705405440 0 0 0 14474460 3705461980 3705461980 3705461980 3690987520 0 0 0 56540 3705461980 3705461980 3705461760 0 0 0 0 220 3705461980 3705461980 3705405440 0 0 0 0 0 3705461980 3705461980 3690987520 0 0 0 0 0 3705461980 3705461980 3705405440 0 0 0 0 220 3705461980 3705461980 3705405440 0 0 0 0 220 3705461980 3705461980 3705405440 0 0 0 0 220 3705461980 14474460 3705405440 0 0 0 0 220 3705405440 220 3705461760 0 0 0 0 56540 3690987520 0 3705461760 0 0 0 0 56540 0 0 14474240 0)	offset: 0@0)! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:41'!altSpecialCursor2	| f |	"a blue box with transparent center"	f _ Form extent: 32@32 depth: 32.	f offset: (f extent // 2) negated.	f fill: f boundingBox rule: Form over fillColor: (Color blue alpha: 0.5).	f fill: (f boundingBox insetBy: 4) rule: Form over fillColor: Color transparent.	^f! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:42'!altSpecialCursor3		^self altSpecialCursor3: Color blue! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:41'!altSpecialCursor3: aColor	| f box |	"a bulls-eye pattern in this color"	f _ Form extent: 32@32 depth: 32.	f offset: (f extent // 2) negated.	box _ f boundingBox.	[ box width > 0] whileTrue: [		f fill: box rule: Form over fillColor: aColor.		f fill: (box insetBy: 2) rule: Form over fillColor: Color transparent.		box _ box insetBy: 4.	].	^f! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/13/2000 11:15'!debuggingMenuFor: aHandMorph	| aMenu aPlayer |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect].     aMenu add: 'explore morph' target: self selector: #explore.	(aPlayer _ self player) ifNotNil:		[aMenu add: 'inspect player' target: aPlayer action: #inspect.		Smalltalk isMorphic ifFalse: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic]].	aMenu addLine.	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aPlayer ifNotNil: 		[aMenu add: 'browse player class' target: aPlayer action: #inspect].	aMenu 		addLine;		add: 'make own subclass' target: aHandMorph action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file'  action: #saveOnFile;		addLine;		add: 'call #tempCommand' target: aHandMorph action: #callTempCommand;		add: 'define #tempCommand' target: aHandMorph action: #defineTempCommand;		addLine;		add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: self;		add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/12/2000 11:43'!deleteAnyMouseActionIndicators	(self valueOfProperty: #mouseActionIndicatorMorphs ifAbsent: [#()]) do: [ :each |		each deleteWithSiblings		"one is probably enough, but be safe"	].	self removeProperty: #mouseActionIndicatorMorphs! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/12/2000 11:16'!programmedMouseDown: anEvent for: aMorph	aMorph addMouseActionIndicatorsWidth: 15 color: (Color blue alpha: 0.7).! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/12/2000 11:16'!programmedMouseEnter: anEvent for: aMorph	aMorph addMouseActionIndicatorsWidth: 10 color: (Color blue alpha: 0.3).! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/12/2000 11:10'!programmedMouseLeave: anEvent for: aMorph	self deleteAnyMouseActionIndicators.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/12/2000 11:11'!programmedMouseUp: anEvent for: aMorph	| aCodeString |	self deleteAnyMouseActionIndicators.	aCodeString _ self valueOfProperty: #mouseUpCodeToRun ifAbsent: [^self].	(self fullBounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	[		Compiler			evaluate: aCodeString			for: self			notifying: nil			logged: false	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: self].		"in case a save/load progress display needs a home"! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:57'!programmedMouseUp: anEvent for: aMorph with: aCodeString	self flag: #bob.		"no longer used, but there may be old morphs out there"	anEvent hand showTemporaryCursor: nil.	(self fullBounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	[		Compiler			evaluate: aCodeString			for: self			notifying: nil			logged: false	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: self].		"in case a save/load progress display needs a home"! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:43'!removeMouseUpAction	self primaryHand showTemporaryCursor: nil.	self removeProperty: #mouseUpCodeToRun.	#(mouseUp mouseEnter mouseLeave mouseDown) do: [ :sym |		self			on: sym 			send: #yourself 			to: nil.	]! !!Morph methodsFor: 'private' stamp: 'di 6/5/2000 14:39'!moveWithPenDownBy: delta	| trailMorph tfm start tfmEnd |	"If this is a costume for a player with its pen down, draw a line."	(trailMorph _ self trailMorph) ifNotNil:		[tfm _ self owner transformFrom: trailMorph.		start _  self referencePosition.		Preferences batchPenTrails			ifTrue: [trailMorph notePenDown: true								forPlayer: self player								at: (tfm localPointToGlobal: start)]			ifFalse: [trailMorph drawPenTrailFor: self								from: (tfm localPointToGlobal: start)								to: (tfmEnd _ tfm localPointToGlobal: start + delta).					trailMorph noteNewLocation: tfmEnd forPlayer: self player]]! !!Morph methodsFor: 'private' stamp: 'RAA 7/16/2000 11:51'!moveWithPenDownByRAA: delta	| trailMorph tfm start tfmEnd xStart |	self flag: #bob.		"temp revert to old version for Alan's demo"	"If this is a costume for a player with its pen down, draw a line."	(trailMorph _ self trailMorph) ifNil: [^self].	tfm _ self owner transformFrom: "trailMorph" self world.	start _  self referencePosition.	Preferences batchPenTrails ifTrue: [		trailMorph notePenDown: true forPlayer: self player at: (tfm localPointToGlobal: start)	] ifFalse: [		xStart _ (tfm localPointToGlobal: start).		tfmEnd _ tfm localPointToGlobal: start + delta.		trailMorph drawPenTrailFor: self from: xStart to: tfmEnd.		"I don't think we should be doing this if batchPenTrails is false"		"trailMorph noteNewLocation: tfmEnd forPlayer: self player."	]	! !!Morph methodsFor: 'WiW support' stamp: 'RAA 7/16/2000 13:54'!randomBoundsFor: aMorph	| trialRect |	trialRect _ (		self topLeft + 			((self width * (15 + 75 atRandom/100)) rounded @			(self height * (15 + 75 atRandom/100)) rounded)	) extent: aMorph extent.	^trialRect translateBy: (trialRect amountToTranslateWithin: self bounds)! !!BorderedMorph methodsFor: 'drawing' stamp: 'RAA 7/14/2000 09:36'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor |	borderWidth = 0 ifTrue: [  "no border"		"Note: This is the hook for border styles.			When converting to the new borders we'll just put 0 into the borderWidth"		super drawOn: aCanvas.		^ self].	borderColor == #raised ifTrue: [		"Use a hack for now"		aCanvas fillRectangle: self bounds fillStyle: self fillStyle.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: (borderWidth = 1 ifTrue: [color twiceLighter]										ifFalse: [color lighter])			bottomRightColor: (borderWidth = 1 ifTrue: [color twiceDarker]										ifFalse: [color darker])].	borderColor == #inset ifTrue: [		insetColor _ owner ifNil: [Color black] ifNotNil: [owner colorForInsets].		aCanvas fillRectangle: self bounds fillStyle: self fillStyle.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: (borderWidth = 1 ifTrue: [insetColor twiceDarker]										ifFalse: [insetColor darker])			bottomRightColor: (borderWidth = 1 ifTrue: [insetColor twiceLighter]										ifFalse: [insetColor lighter])].	"solid color border"	aCanvas fillRectangle: (self bounds insetBy: borderWidth) fillStyle: self fillStyle.	aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: borderWidth		borderColor: borderColor.! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 17:56'!fixLayout	| nextY newBnds r deltaY |	submorphs size < 1 ifTrue: [^super fixLayout].	submorphs size = heights size ifFalse: [^super fixLayout].	r _ self innerBounds.	nextY _ r top.	submorphs with: heights do: [ :sub :ht |		deltaY _ ht < 1 ifTrue: [(r height * ht) truncated] ifFalse: [ht].		newBnds _ r left @ nextY corner: (r right @ (nextY + deltaY min: r bottom)).		newBnds = sub bounds ifFalse: [sub bounds: newBnds].		nextY _ newBnds bottom.	].! !!ColorPickerMorph methodsFor: 'private' stamp: 'RAA 7/12/2000 14:14'!pickColorAt: aGlobalPoint 	| alpha selfRelativePoint pickedColor |	selfRelativePoint _ (self globalPointToLocal: aGlobalPoint) - self topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue: [		alpha _ (selfRelativePoint x - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"		self 			updateColor: (selectedColor alpha: alpha)			feedbackColor: (selectedColor alpha: alpha).		^self	].	"pick up color, either inside or outside this world"	pickedColor _ Display colorAt: aGlobalPoint.	self 		updateColor: (			(selectedColor isColor and: [selectedColor isTranslucentColor])						ifTrue: [pickedColor alpha: selectedColor alpha]						ifFalse: [pickedColor]		)		feedbackColor: pickedColor! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 11:49'!actionBlock: aBlock	actionBlock _ aBlock! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 12:38'!addText: aString	| t |	t _ TextMorph new 		beAllFont: (TextStyle default fontOfSize: 26);		contents: aString.	self extent: t extent * 3.	self addMorph: (t position: self position + t extent; lock).! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 12:19'!initialize	super initialize.	color _ Color white.! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 12:19'!openInWorld: aWorld	self position: aWorld topLeft + (aWorld extent - self extent // 2).	super openInWorld: aWorld! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 12:36'!step	| goForIt |	actionBlock ifNil: [^self stopStepping].	goForIt _ actionBlock.	actionBlock _ nil.	[		goForIt value.	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: self].		"in case a save/load progress display needs a home"! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 11:46'!stepTime	^1! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 11:50'!wantsSteps	^actionBlock notNil! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 17:04'!addAColumn: aCollectionOfMorphs	| col |	col _ self inAColumn: aCollectionOfMorphs.	self addMorphBack: col.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 17:05'!addARow: aCollectionOfMorphs	| row |	row _ self inARow: aCollectionOfMorphs.	self addMorphBack: row.	^row! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:27'!addGateKeeperMorphs	| list currentTime choices age row |	self setProperty: #gateKeeperCounterValue toValue: EToyGateKeeperMorph updateCounter.	choices _ #(		(60 'm' 'in the last minute')		(3600 'h' 'in the last hour')		(86400 'd' 'in the last day')	).	currentTime _ Date today asSeconds + Time now asSeconds.	list _ EToyGateKeeperMorph knownIPAddresses.	list do: [ :each |		age _ each timeBetweenLastAccessAnd: currentTime.		age _ choices			detect: [ :x | age <= x first]			ifNone: [{0. '-'. (age // 86400) printString,'days ago'}].		row _ self addARow: {			self toggleButtonFor: each attribute: 'chat'.			self toggleButtonFor: each attribute: 'morph'.			self toggleButtonFor: each attribute: 'fridge'.			(self inAColumn: {				(StringMorph contents: age second) lock.			}) inset: 2; hResizing: #shrinkWrap; setBalloonText: 'Last attempt was ',age third.			(self inAColumn: {				(StringMorph contents: each ipAddress) lock.			}) inset: 2; hResizing: #shrinkWrap.			(self inAColumn: {				(StringMorph contents: each latestUserName) lock.			}) inset: 2.		}.		row			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			"on: #mouseUp send: #mouseUp:in: to: self;"			setBalloonText: each fullInfoString	].! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 11:33'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f _ SimpleButtonMorph new		target: self;		label: aString;		color: aColor;		actionSelector: aSymbol;		setBalloonText: helpString.	self field: aSymbol is: f.	col _ (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 05:57'!commResult: anArrayOfAssociations	| aDictionary |	aDictionary _ Dictionary new.	anArrayOfAssociations do: [ :each | aDictionary add: each].	resultQueue nextPut: aDictionary! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 17:45'!delete	super delete.	self breakDependents! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:33'!editEvent: anEvent for: aMorph	| answer |	(aMorph bounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	answer _ FillInTheBlankMorph		request: 'Enter a new ',aMorph balloonText		initialAnswer: aMorph contents.	answer isEmptyOrNil ifTrue: [^self].	aMorph contents: answer! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 16:59'!field: fieldName is: anObject	fields at: fieldName put: anObject.	^anObject! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:15'!flashIndicator: aSymbol	| indicator firstColor now |	indicator _ fields at: aSymbol ifAbsent: [^self].	now _ Time millisecondClockValue.	(LastFlashTime notNil and: [(Time millisecondClockValue - now) abs < 500]) ifTrue: [^self].	LastFlashTime _ now.	firstColor _ indicator 		valueOfProperty: #firstColor		ifAbsent: [			indicator setProperty: #firstColor toValue: indicator color.			indicator color		].	indicator color: (indicator color = firstColor ifTrue: [Color white] ifFalse: [firstColor]).	self world displayWorldSafely.! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 16:42'!handleResult: aDictionary	| m |	aDictionary at: #commFlash ifPresent: [ :ignore | ^self flashIndicator: #communicating].	self resetIndicator: #communicating.	m _ aDictionary at: #message ifAbsent: ['unknown message'].	m = 'OK' ifTrue: [^self].	self reportError: m! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:15'!inAColumn: aCollectionOfMorphs	| col |	col _ AlignmentMorph newColumn		color: Color transparent;		vResizing: #shrinkWrap;		inset: 1;		centering: #center.	aCollectionOfMorphs do: [ :each | col addMorphBack: each].	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:14'!inARow: aCollectionOfMorphs	| row |	row _ AlignmentMorph newRow		color: Color transparent;		vResizing: #shrinkWrap;		inset: 1;		centering: #center.	aCollectionOfMorphs do: [ :each | row addMorphBack: each].	^row! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 17:32'!indicatorFieldNamed: aSymbol color: aColor help: helpString	| f col |	f _ EllipseMorph new		extent: 10@10;		color: aColor;		setBalloonText: helpString.	self field: aSymbol is: f.	col _ (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 09:49'!initialize	super initialize.	vResizing _ hResizing _ #shrinkWrap.	resultQueue _ SharedQueue new.	fields _ Dictionary new.	self useRoundedCorners.! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 16:48'!open	self openInWorld! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 16:41'!reportError: aString	self inform: aString! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 08:18'!resetIndicator: aSymbol	| indicator firstColor |	indicator _ fields at: aSymbol ifAbsent: [^self].	firstColor _ indicator 		valueOfProperty: #firstColor		ifAbsent: [^self].	indicator color: firstColor.	self world displayWorldSafely.! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 10:14'!step	| state |	[resultQueue isEmpty] whileFalse: [		self handleResult: resultQueue next	].	(state _ self valueOfProperty: #flashingState ifAbsent: [0]) > 0 ifTrue: [		self borderColor: (			(self valueOfProperty: #flashingColors ifAbsent: [{Color green. Color red}]) atWrap: state		).		self setProperty: #flashingState toValue: state + 1	].! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 10:27'!stepTime	(self valueOfProperty: #flashingState ifAbsent: [0]) > 0 ifTrue: [		^200	] ifFalse: [		^1000	].! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 16:19'!stopFlashing	self setProperty: #flashingState toValue: 0.	self borderColor: (self valueOfProperty: #normalBorderColor ifAbsent: [Color blue]).! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:35'!textEntryFieldNamed: aSymbol with: aString help: helpString	| f col |	f _ (StringMorph new contents: aString)		setBalloonText: helpString;		on: #mouseUp send: #editEvent:for: to: self.	self field: aSymbol is: f.	col _ (self inAColumn: {f}) color: Color white; hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:21'!toggleButtonFor: entry attribute: attribute	^(self inAColumn: {		(EtoyUpdatingThreePhaseButtonMorph checkBox)			target: entry;			actionSelector: #toggleChoice:;			arguments: {attribute};			getSelector: #getChoice:;			setBalloonText: 'Whether you want "',attribute,'" messages';			step	}) hResizing: #shrinkWrap! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 16:14'!transmitStreamedObject: outData to: anIPAddress	| null |	null _ String with: 0 asCharacter.	EToyPeerToPeer new 		sendSomeData: {			self transmittedObjectCategory,null. 			Preferences defaultAuthorName,null.			outData		}		to: anIPAddress		for: self.! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 06:25'!wantsSteps	^true! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 22:21'!acceptTo: someText forMorph: aMorph	self 		transmitStreamedObject: (someText eToyStreamedRepresentationNotifying: self) 		to: self ipAddress.	aMorph setText: '' asText.	self appendMessage: 		self startOfMessageFromMe,		' - ',		someText,		String cr.	^true! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 22:34'!appendMessage: aText	receivingPane appendTextEtoy: aText.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:01'!chatFrom: ipAddress name: senderName text: text	| initialText attrib |	recipientForm ifNil: [		initialText _ senderName asText allBold.	] ifNotNil: [		attrib _ TextAnchor new anchoredMorph: recipientForm "asMorph".		initialText _ '*' asText.		initialText addAttribute: attrib from: 1 to: 1.	].	self appendMessage: initialText,' - ',text,String cr.	SampledSound playSoundNamed: 'chirp'.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 08:07'!initialize	super initialize.	orientation _ #vertical.	color _ Color paleYellow.	inset _ 0.	borderColor _ Color darkGray.	borderWidth _ 8.	hResizing _ vResizing _ #rigid.	minWidth _ minHeight _ 200.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 16:14'!insetTheScrollbars	self allMorphsDo: [ :each | 		(each isKindOf: PluggableTextMorph) ifTrue: [each retractable: false]	].! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 06:09'!ipAddress		^(fields at: #ipAddress) contents! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 11:30'!open		^self openIn: self currentWorld! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 15:05'!openIn: aWorld	| r1 r2 |	"open an a chat window"	r1 _ self addARow: {		self inAColumn: {StringMorph new contents: 'Your message to:'; lock}.		self textEntryFieldNamed: #ipAddress with: ''					help: 'IP address for chat partner'.	}.	recipientForm ifNotNil: [		r1 addMorphBack: recipientForm asMorph lock	].	self		addMorphBack: (			PluggableTextMorph				on: self				text: nil				accept: #acceptTo:forMorph:		).	r2 _ self addARow: {self inAColumn: {StringMorph new contents: 'Replies'; lock}}.	self		addMorphBack: (			receivingPane _ PluggableTextMorph				on: self				text: nil				accept: nil		).	{r1. r2} do: [ :each |		each			vResizing: #spaceFill;			color: Color veryLightGray.	].	heights _ #(18 0.25 18 9999999).	aWorld ifNil: [^self].	self 		position: 400@100;		extent:  200@150;		openInWorld: aWorld.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 08:50'!recipientForm: aForm	recipientForm _ aForm.	recipientForm ifNotNil: [recipientForm _ recipientForm scaledToSize: 20@20].! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 16:43'!reportError: aString	receivingPane appendTextEtoy: (aString asText addAttribute: TextColor red), String cr.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 05:39'!setIPAddress: aString		(fields at: #ipAddress) contents: aString! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:50'!startOfMessageFromMe	myForm ifNil: [		myForm _ EToySenderMorph pictureForIPAddress: NetNameResolver localAddressString.		myForm ifNotNil: [			myForm _ myForm scaledToSize: 20@20		].	].	myForm ifNil: [		^(Preferences defaultAuthorName asText allBold addAttribute: TextColor blue)	].	^'*' asText		addAttribute: (TextAnchor new anchoredMorph: myForm);		yourself! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 22:19'!transmittedObjectCategory	^'chat'! !!EToyChatMorph methodsFor: 'object fileIn' stamp: 'RAA 7/14/2000 09:30'!convertbosfcebbochvimlphmmfrlr0: varDict bosfcebbochvimlphmmfrlrr0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'heights' 'minWidth' 'minHeight' 'fields' 'resultQueue' 'listener' 'receivingPane').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('recipientForm')  If a non-nil value is needed, please assign it."! !!EToyChatMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:51'!chatFrom: ipAddress name: senderName text: text	| chatWindow |	chatWindow _ self 		chatWindowForIP: ipAddress 		name: senderName 		picture: (EToySenderMorph pictureForIPAddress: ipAddress) 		inWorld: self currentWorld.	chatWindow		chatFrom: ipAddress 		name: senderName 		text: text! !!EToyChatMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:11'!chatWindowForIP: ipAddress name: senderName picture: aForm inWorld: aWorld	| makeANewOne aSenderBadge existing |	existing _ self instanceForIP: ipAddress inWorld: aWorld.	existing ifNotNil: [^existing].	makeANewOne _ [		self new			recipientForm: aForm; 			open; 			setIPAddress: ipAddress	].	SampledSound playSoundNamed: 'chirp'.	self doChatsInternalToBadge ifTrue: [		aSenderBadge _ EToySenderMorph instanceForIP: ipAddress inWorld: aWorld.		aSenderBadge ifNotNil: [			aSenderBadge startChat: false.			^aSenderBadge 				findDeepSubmorphThat: [ :x | x isKindOf: EToyChatMorph] 				ifAbsent: makeANewOne		].		aSenderBadge _ EToySenderMorph instanceForIP: ipAddress.		aSenderBadge ifNotNil: [			aSenderBadge _ aSenderBadge veryDeepCopy.			aSenderBadge 				killExistingChat;				openInWorld: aWorld;				startChat: false.			^aSenderBadge 				findDeepSubmorphThat: [ :x | x isKindOf: EToyChatMorph] 				ifAbsent: makeANewOne		].		(aSenderBadge _ EToySenderMorph new)			userName: senderName 			userPicture: aForm			userEmail: 'unknown' 			userIPAddress: ipAddress;			position: 200@200;			openInWorld: aWorld;			startChat: false.		^aSenderBadge 			findDeepSubmorphThat: [ :x | x isKindOf: EToyChatMorph] 			ifAbsent: makeANewOne	].	^makeANewOne value.! !!EToyChatMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 17:12'!doChatsInternalToBadge	^true! !!EToyChatMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:48'!instanceForIP: ipAddress inWorld: aWorld	^self allInstances detect: [ :x | 		x world == aWorld and: [x ipAddress = ipAddress]	] ifNone: [nil]! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 13:36'!acceptDroppingMorph: morphToDrop event: evt	| outData |	evt hand rejectDropMorph: morphToDrop event: evt.		"we don't really want it"	(morphToDrop isKindOf: EToySenderMorph) ifTrue: [		self class addRecipient: morphToDrop.		^self rebuild	].	self stopFlashing.	outData _ morphToDrop veryDeepCopy eToyStreamedRepresentationNotifying: self.	self resetIndicator: #working.	self class fridgeRecipients do: [ :each |		self transmitStreamedObject: outData to: each ipAddress	].! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 12:07'!drawOn: aCanvas	| f cache |	f _ self class fridgeForm ifNil: [^super drawOn: aCanvas].	cache _ Form extent: bounds extent depth: aCanvas depth.	f		displayInterpolatedIn: cache boundingBox truncated		on: cache.	cache replaceColor: Color black withColor: Color transparent.	aCanvas 		translucentImage: cache		at: bounds origin.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 12:47'!getChoice: aString	aString = 'group' ifTrue: [^groupMode ifNil: [true]].! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 13:13'!groupToggleButton	^(self inAColumn: {		(EtoyUpdatingThreePhaseButtonMorph checkBox)			target: self;			actionSelector: #toggleChoice:;			arguments: {'group'};			getSelector: #getChoice:;			setBalloonText: 'Changes between group mode and individuals';			step	}) hResizing: #shrinkWrap! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 09:21'!handlesMouseDown: globalEvt	| localCursorPoint |	localCursorPoint _ self globalPointToLocal: globalEvt cursorPoint.	groupMode ifFalse: [		self allMorphsDo: [ :each |			(each isKindOf: EToySenderMorph) ifTrue: [				(each bounds containsPoint: localCursorPoint) ifTrue: [^false].			].		].	].	^true! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 11:21'!initialize	super initialize.	groupMode _ true.	color _ Color paleRed.	orientation _ #vertical.	inset _ 10.	borderColor _ #raised.	borderWidth _ 4.	hResizing _ vResizing _ #shrinkWrap.	self setProperty: #normalBorderColor toValue: borderColor.	self setProperty: #flashingColors toValue: {Color red. Color yellow}.	self rebuild.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 11:21'!minHeight	^super minHeight max: 200! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 09:19'!mouseDown: localEvt	Project enterIfThereOrFind: 'Fridge'! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 11:05'!noteRemovalOf: aSenderMorph	self class removeRecipientWithIPAddress: aSenderMorph ipAddress! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 22:28'!rebuild	| row filler fudge people maxPerRow |	updateCounter _ self class updateCounter.	self removeAllMorphs.	(self addARow: {		filler _ Morph new color: Color transparent; extent: 4@4.	}) vResizing: #shrinkWrap.	self addARow: {		(StringMorph contents: 'the Fridge') lock.		self groupToggleButton.	}.	row _ self addARow: {}.	people _ self class fridgeRecipients.	maxPerRow _ people size < 7 ifTrue: [2] ifFalse: [3].			"how big can this get before we need a different approach?"	people do: [ :each |		row submorphCount >= maxPerRow ifTrue: [row _ self addARow: {}].		row addMorphBack: (			groupMode ifTrue: [				(each userPicture scaledToSize: 35@35) asMorph lock			] ifFalse: [				each veryDeepCopy killExistingChat			]		)	].	fullBounds _ nil.	self fullBounds.	"htsBefore _ submorphs collect: [ :each | each height]."	fudge _ 20.	filler extent: 4 @ (self height - filler height * 0.37 - inset - borderWidth - fudge) truncated.	"self fixLayout.	htsAfter _ submorphs collect: [ :each | each height].	{htsBefore. htsAfter} explore."! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 13:37'!rootForGrabOf: x	| aSender |	groupMode ifTrue: [^super rootForGrabOf: x].	(x isKindOf: EToySenderMorph) ifTrue: [^x].	aSender _ x ownerThatIsA: EToySenderMorph.	aSender ifNil: [^super rootForGrabOf: x].	^aSender! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 12:31'!step	super step.	updateCounter = self class updateCounter ifFalse: [self rebuild].! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 12:50'!toggleChoice: aString	updateCounter _ nil.		"force rebuild"	aString = 'group' ifTrue: [^groupMode _ (groupMode ifNil: [true]) not].! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 16:13'!transmittedObjectCategory	^'fridge'! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 15:53'!wantsDroppedMorph: aMorph event: evt	^true! !!EToyFridgeMorph methodsFor: 'object fileIn' stamp: 'RAA 7/14/2000 15:21'!convertbosfcebbochvimlphmmfrrirug0: varDict bosfcebbochvimlphmmfrug0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'heights' 'minWidth' 'minHeight' 'fields' 'resultQueue' 'updateCounter' 'groupMode').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('recipients' 'incomingRow' 'recipientRow').  Possibly store their info in another variable?"! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 12:19'!addRecipient: aSenderMorph	self fridgeRecipients do: [ :each |		aSenderMorph ipAddress = each ipAddress ifTrue: [^self]	].	self fridgeRecipients add: aSenderMorph.	UpdateCounter _ self updateCounter + 1! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 12:09'!fridgeForm	| fridgeFileName |	fridgeFileName _ 'fridge.form'.	TheFridgeForm ifNotNil: [^TheFridgeForm].	(FileDirectory default fileExists: fridgeFileName) ifFalse: [^nil].	^TheFridgeForm _ Form fromFileNamed: fridgeFileName.! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 19:23'!fridgeRecipients	^FridgeRecipients ifNil: [FridgeRecipients _ OrderedCollection new]! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:55'!newItem: newMorph	| theFridge fridgeWorld trialRect |	theFridge _ Project named: 'Fridge'.	theFridge ifNil: [^self newItems add: newMorph].	fridgeWorld _ theFridge world.	trialRect _ fridgeWorld randomBoundsFor: newMorph.	fridgeWorld 		addMorphFront: (newMorph position: trialRect topLeft);		startSteppingSubmorphsOf: newMorph! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 19:19'!newItems	^NewItems ifNil: [NewItems _ OrderedCollection new]! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 11:04'!removeRecipientWithIPAddress: ipString	FridgeRecipients _ self fridgeRecipients reject: [ :each |		ipString = each ipAddress	].	UpdateCounter _ self updateCounter + 1! !!EToyFridgeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 19:22'!updateCounter	^UpdateCounter ifNil: [0]! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:48'!dateAndTimeStringFrom: totalSeconds	| date time |	date _ Date fromSeconds: totalSeconds.	time _ Time fromSeconds: totalSeconds - date asSeconds.	^date printString,' ',time printString! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 10:47'!fullInfoString	^(latestUserName ifNil: ['???']),		' at ',		ipAddress ,		' attempts: ',		accessAttempts printString,		'/',		attempsDenied printString,		' last: ',		(self dateAndTimeStringFrom: lastRequests first first)	 "acceptableTypes" ! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 12:19'!getChoice: aString	^acceptableTypes includes: aString! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 13:30'!initialize	super initialize.	ipAddress _ '???'.	accessAttempts _ attempsDenied _ 0.	lastRequests _ OrderedCollection new.	acceptableTypes _ Set withAll: #('chat' 'morph' 'fridge'). ! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:33'!ipAddress	^ipAddress! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:18'!ipAddress: aString	ipAddress _ aString! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 10:49'!latestUserName	^latestUserName ifNil: ['???']! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 10:46'!latestUserName: aString	latestUserName _ aString! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:32'!requestAccessOfType: aString	| ok |	accessAttempts _ accessAttempts + 1.	lastRequests addFirst: {Date today asSeconds + Time now asSeconds. aString}.	lastRequests size > 10 ifTrue: [		lastRequests _ lastRequests copyFrom: 1 to: 10.	].	ok _ (acceptableTypes includes: aString) or: [acceptableTypes includes: 'all'].	ok ifFalse: [attempsDenied _ attempsDenied + 1].	^ok! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:38'!timeBetweenLastAccessAnd: currentTime	lastRequests isEmpty ifTrue: [^0].	^currentTime - lastRequests first first! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 10:39'!toggleChoice: aString	(acceptableTypes includes: aString) ifTrue: [		acceptableTypes remove: aString ifAbsent: []	] ifFalse: [		acceptableTypes add: aString	].! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:43'!initialize	super initialize.	orientation _ #vertical.	color _ Color lightGray.	inset _ 4.	borderColor _ #raised "Color brown".	borderWidth _ 4.	hResizing _ vResizing _ #spaceFill.	self useRoundedCorners.	self rebuild.	! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 12:32'!minHeightWhenEmpty	^20! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 12:33'!minWidthWhenEmpty	^20! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:29'!open	self rebuild.	self openInWorld.! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:27'!rebuild	self removeAllMorphs.	self addGateKeeperMorphs.! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:28'!step	(self valueOfProperty: #gateKeeperCounterValue) = 			EToyGateKeeperMorph updateCounter ifTrue: [^self].	self rebuild.! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 10:51'!acceptRequest: requestType from: senderName at: ipAddressString	| known entry |	UpdateCounter _ self updateCounter + 1.	known _ self knownIPAddresses.	entry _ known at: ipAddressString ifAbsentPut: [		entry _ EToyGateKeeperEntry new.		entry ipAddress: ipAddressString.		entry	].	entry latestUserName: senderName.	^entry requestAccessOfType: requestType! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 08:42'!knownIPAddresses	^KnownIPAddresses ifNil: [KnownIPAddresses _ Dictionary new]! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:28'!updateCounter	^UpdateCounter ifNil: [UpdateCounter _ 0]! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:17'!addNewObject: newObject thumbForm: aForm sentBy: senderName ipAddress: ipAddressString	| thumb row |	thumb _ aForm asMorph.	thumb setProperty: #depictedObject toValue: newObject.	row _ self addARow: {		thumb. 		self inAColumn: {			StringMorph new contents: senderName; lock.			StringMorph new contents: ipAddressString; lock.		}	}.	row on: #mouseDown send: #mouseDownEvent:for: to: self.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 10:44'!delete	listener ifNotNil: [listener stopListening. listener _ nil].						"for old instances that were locally listening"	super delete.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 19:18'!handleNewFridgeMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject |	newObject _ self newObjectFromStream: dataStream.	newObject		setProperty: #fridgeSender toValue: senderName;		setProperty: #fridgeIPAddress toValue: ipAddressString;		setProperty: #fridgeDate toValue: Time dateAndTimeNow.	EToyFridgeMorph newItem: newObject.	! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:22'!handleNewMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject |	newObject _ self newObjectFromStream: dataStream.	self		addNewObject: newObject 		thumbForm: (newObject imageForm scaledToSize: 50@50) 		sentBy: senderName 		ipAddress: ipAddressString.	SampledSound playSoundNamed: 'chirp'.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:20'!handleResult: aDictionary	| nullChar dataStream messageType senderName m ipAddress |	m _ aDictionary at: #message ifAbsent: [^super handleResult: aDictionary].	m = 'OK' ifFalse: [^super handleResult: aDictionary].	self resetIndicator: #communicating.	ipAddress _ NetNameResolver stringFromAddress: (aDictionary at: #ipAddress).	nullChar _ 0 asCharacter.	dataStream _ ReadStream on: (aDictionary at: #data).	messageType _ dataStream upTo: nullChar.	senderName _ dataStream upTo: nullChar.	(EToyGateKeeperMorph acceptRequest: messageType from: senderName at: ipAddress) ifFalse: [		^self	].	messageType = 'morph' ifTrue: [		^self handleNewMorphFrom: dataStream sentBy: senderName ipAddress: ipAddress.	].	messageType = 'fridge' ifTrue: [		^self handleNewFridgeMorphFrom: dataStream sentBy: senderName ipAddress: ipAddress.	].	messageType = 'chat' ifTrue: [		^ EToyChatMorph 			chatFrom: ipAddress 			name: senderName 			text: (self newObjectFromStream: dataStream).	].	self halt.	! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 17:45'!initialize	super initialize.	orientation _ #vertical.	color _ Color lightBlue.	inset _ 4.	borderColor _ Color blue.	borderWidth _ 4.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:33'!mouseDownEvent: event for: aMorph	| menu selection depictedObject |	depictedObject _ aMorph firstSubmorph valueOfProperty: #depictedObject.	menu _ CustomMenu new.	menu 		add: 'Grab' 		action: [			event hand attachMorph: depictedObject veryDeepCopy		];		add: 'Delete' 		action: [			self class usingGlobalListener ifTrue: [				self class removeFromGlobalIncomingQueue: depictedObject			] ifFalse: [				aMorph delete			].		].	selection _ menu build startUpCenteredWithCaption: 'Morph from ',					(aMorph submorphs at: 2) firstSubmorph contents.	selection ifNil: [^self].	selection value.! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 18:14'!newObjectFromStream: dataStream	| newObject |	[newObject _ SmartRefStream objectFromStreamedRepresentation: dataStream upToEnd.]		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				self flashIndicator: #working.			].		].	self resetIndicator: #working.	^newObject! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:05'!open	self class usingGlobalListener ifFalse: [		listener _ EToyPeerToPeer new awaitDataFor: self.	].	self 		rebuild;		openInWorld! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:39'!rebuild	| tuples earMorph |	updateCounter _ UpdateCounter.	self removeAllMorphs.	self addGateKeeperMorphs.	self class usingGlobalListener ifTrue: [		GlobalListener ifNil: [			earMorph _ (self class makeListeningToggle: false) asMorph.			earMorph setBalloonText: 'Click to START listening for messages'.			earMorph on: #mouseUp send: #startListening to: self.		] ifNotNil: [			earMorph _ (self class makeListeningToggle: true) asMorph.			earMorph setBalloonText: 'Click to STOP listening for messages'.			earMorph on: #mouseUp send: #stopListening to: self.		].		self addARow: {self inAColumn: {earMorph}}.	].	self		addARow: {			self inAColumn: {(StringMorph contents: 'Incoming communications') lock}.			self indicatorFieldNamed: #working color: Color blue help: 'working'.			self indicatorFieldNamed: #communicating color: Color green help: 'receiving'.		}.	self class usingGlobalListener ifTrue: [		"{thumbForm. newObject. senderName. ipAddressString}"		tuples _ self class globalIncomingQueueCopy.		tuples do: [ :each |			self				addNewObject: each second 				thumbForm: each first 				sentBy: each third 				ipAddress: each fourth.		].	].! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:23'!startListening	self class startListening! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:30'!step	| needRebuild |	super step.	needRebuild _ false.	(self valueOfProperty: #gateKeeperCounterValue) = 			EToyGateKeeperMorph updateCounter ifFalse: [needRebuild _ true].	self class usingGlobalListener ifTrue: [		updateCounter = UpdateCounter ifFalse: [			needRebuild _ true.		].	].	needRebuild ifTrue: [self rebuild].! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:23'!stopListening	self class stopListening! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:24'!addToGlobalIncomingQueue: aMorphTuple	self critical: [		self globalIncomingQueue add: aMorphTuple.		self bumpUpdateCounter.	].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:23'!bumpUpdateCounter	UpdateCounter _ (UpdateCounter ifNil: [0]) + 1.! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 10:52'!commResult: anArrayOfAssociations	| nullChar dataStream messageType senderName m ipAddress aDictionary |	aDictionary _ Dictionary new.	anArrayOfAssociations do: [ :each | aDictionary add: each].		aDictionary at: #commFlash ifPresent: [ :ignore | ^self].	m _ aDictionary at: #message ifAbsent: [^self].	m = 'OK' ifFalse: [^self].	ipAddress _ NetNameResolver stringFromAddress: (aDictionary at: #ipAddress).	nullChar _ 0 asCharacter.	dataStream _ ReadStream on: (aDictionary at: #data).	messageType _ dataStream upTo: nullChar.	senderName _ dataStream upTo: nullChar.	(EToyGateKeeperMorph acceptRequest: messageType from: senderName at: ipAddress) ifFalse: [		^self	].	messageType = 'morph' ifTrue: [		^self handleNewMorphFrom: dataStream sentBy: senderName ipAddress: ipAddress.	].	messageType = 'fridge' ifTrue: [		^self handleNewFridgeMorphFrom: dataStream sentBy: senderName ipAddress: ipAddress.	].	messageType = 'chat' ifTrue: [		^ EToyChatMorph 			chatFrom: ipAddress 			name: senderName 			text: (self newObjectFromStream: dataStream).	].	self halt.	! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:11'!critical: aBlock	QueueSemaphore ifNil: [QueueSemaphore _ Semaphore forMutualExclusion].	^QueueSemaphore critical: aBlock! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:04'!ensureListenerInCurrentWorld	| w |	w _ self currentWorld.	EToyListenerMorph allInstances 		detect: [ :each | each world == w]		ifNone: [EToyListenerMorph new open]! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 12:46'!flashIndicator: ignoredForNow! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:12'!globalIncomingQueue	^GlobalIncomingQueue ifNil: [GlobalIncomingQueue _ OrderedCollection new].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:13'!globalIncomingQueueCopy	^self critical: [self globalIncomingQueue copy].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 13:01'!handleNewFridgeMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject |	newObject _ self newObjectFromStream: dataStream.	newObject		setProperty: #fridgeSender toValue: senderName;		setProperty: #fridgeIPAddress toValue: ipAddressString;		setProperty: #fridgeDate toValue: Time dateAndTimeNow.	WorldState addDeferredUIMessage: [EToyFridgeMorph newItem: newObject] fixTemps.	! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:55'!handleNewMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject thumbForm targetWorld |	newObject _ self newObjectFromStream: dataStream.	SampledSound playSoundNamed: 'chirp'.	targetWorld _ self currentWorld.	(EToyMorphsWelcomeMorph morphsWelcomeInWorld: targetWorld) ifTrue: [		newObject position: (			newObject 				valueOfProperty: #positionInOriginatingWorld 				ifAbsent: [(targetWorld randomBoundsFor: newObject) topLeft]		).		WorldState addDeferredUIMessage: [			newObject openInWorld: targetWorld.		] fixTemps.		^self	].	thumbForm _ newObject imageForm scaledToSize: 50@50.	self addToGlobalIncomingQueue: {thumbForm. newObject. senderName. ipAddressString}.	WorldState addDeferredUIMessage: [		self ensureListenerInCurrentWorld	] fixTemps.! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:40'!makeListeningToggle: withEars	| background c capExtent bgExtent earExtent earDeltaX earDeltaY botCent factor parts |	factor _ 2.	bgExtent _ (50@25) * factor.	capExtent _ (30@30) * factor.	earExtent _ (15@15) * factor.	earDeltaX _ capExtent x // 2.	earDeltaY _ capExtent y // 2.	background _ Form extent: bgExtent depth: 8.	botCent _ background boundingBox bottomCenter.	c _ FormCanvas on: background.	"c fillColor: Color white."	parts _ {		(botCent - (capExtent // 2)) extent: capExtent.	}.	withEars ifTrue: [		parts _ parts , {			(botCent - (earDeltaX @ earDeltaY) - (earExtent // 2)) extent: earExtent.			(botCent - (earDeltaX negated @ earDeltaY) - (earExtent // 2)) extent: earExtent.		} 	].	parts do: [ :each |		c			fillOval: each			color: Color black 			borderWidth: 0 			borderColor: Color black.	].	^background"=====	f2 _ Form extent: 30@15 depth: 8.	background displayInterpolatedOn: f2.	f2 replaceColor: Color white withColor: Color transparent.	^f2====="	! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 12:46'!newObjectFromStream: dataStream	| newObject |	[newObject _ SmartRefStream objectFromStreamedRepresentation: dataStream upToEnd.]		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				self flashIndicator: #working.			].		].	self resetIndicator: #working.	^newObject! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:24'!removeFromGlobalIncomingQueue: theActualObject	self critical: [		GlobalIncomingQueue _ self globalIncomingQueue reject: [ :each | 			each second == theActualObject		].		self bumpUpdateCounter.	].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 12:47'!resetIndicator: ignoredForNow! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:24'!startListening	self stopListening.	GlobalListener _ EToyPeerToPeer new awaitDataFor: self.	self bumpUpdateCounter.! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 18:24'!stopListening	GlobalListener ifNotNil: [		GlobalListener stopListening.		GlobalListener _ nil.		self bumpUpdateCounter.	].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 14:24'!usingGlobalListener	^true! !!EToyMorphsWelcomeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:40'!initialize	| earMorph |	super initialize.	color _ Color yellow.	earMorph _ (EToyListenerMorph makeListeningToggle: true) asMorph.	earMorph setBalloonText: 'My presence in this world means received morphs may appear automatically'.	self addARow: {earMorph}.! !!EToyMorphsWelcomeMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:44'!morphsWelcomeInWorld: aWorld	^self allInstances anySatisfy: [ :each | each world == aWorld]! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 11:57'!closeMyFlapIfAny	| myFlap allTabs myTab myWorld |	myWorld _ self world.	myFlap _ self nearestOwnerThat: [ :each | each hasProperty: #flap].	myFlap ifNil: [^self].	allTabs _ myWorld submorphs select: [ :each | each isKindOf: FlapTab].	myTab _ allTabs detect: [ :each | each referent == myFlap] ifNone: [^self].	myTab hideFlap.	myWorld displayWorldSafely.	! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 16:45'!initialize	super initialize.	orientation _ #vertical.	color _ Color lightBrown.	inset _ 4.	borderColor _ #raised "Color brown".	borderWidth _ 4.	hResizing _ vResizing _ #spaceFill.	self useRoundedCorners.	self rebuild.	! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:02'!jumpToProject	| selection |	selection _ (Project buildJumpToMenu: CustomMenu new) startUp.	self closeMyFlapIfAny.	Project jumpToSelection: selection! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 07:25'!mouseDown: evt in: aMorph	aMorph setProperty: #mouseDownPoint toValue: evt cursorPoint.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 07:28'!mouseLeave: evt in: aMorph	aMorph removeProperty: #mouseDownPoint.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 07:49'!mouseMove: evt in: aMorph	| start tuple project url pvm |	start _ aMorph valueOfProperty: #mouseDownPoint ifAbsent: [^self].	(start dist: evt cursorPoint) abs < 5 ifTrue: [^self].	aMorph removeProperty: #mouseDownPoint.	evt hand hasSubmorphs ifTrue: [^self].	tuple _ aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^self].	project _ tuple fourth first.	project ifNotNil: [		^evt hand attachMorph: (ProjectViewMorph on: project).	].	url _ tuple third.	url isEmptyOrNil ifTrue: [^self].	pvm _ ProjectViewMorph new.	pvm		project: (DiskProxy global: #Project selector: #namedUrl: args: {url});		lastProjectThumbnail: tuple second.	evt hand attachMorph: pvm.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 09:22'!mouseUp: evt in: aMorph	| tuple project url |	(aMorph boundsInWorld containsPoint: evt cursorPoint) ifFalse: [^self].	tuple _ aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^1 beep].	project _ tuple fourth first.	project ifNotNil: [self closeMyFlapIfAny. ^project enter].	url _ tuple third.	url isEmptyOrNil ifTrue: [^1 beep].	self closeMyFlapIfAny.	Project thumbnailFromUrl: url."---	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:04'!rebuild	| history r1 |	changeCounter _ ProjectHistory changeCounter.	history _ ProjectHistory currentHistory mostRecentCopy.	self removeAllMorphs.	r1 _ self addARow: {		self inAColumn: {			StringMorph new contents: 'Jump...'; lock.		}.	}.	r1 on: #mouseUp send: #jumpToProject to: self.	history do: [ :each |		(			self addARow: {				(self inAColumn: {					StretchyImageMorph new form: each second; minWidth: 35; minHeight: 35; lock				}) vResizing: #spaceFill.				self inAColumn: {					StringMorph new contents: each first; lock.					"StringMorph new contents: each third; lock."				}.			}		)			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			on: #mouseUp send: #mouseUp:in: to: self;			on: #mouseDown send: #mouseDown:in: to: self;			on: #mouseStillDown send: #mouseMove:in: to: self;			on: #mouseLeave send: #mouseLeave:in: to: self;			setProperty: #projectParametersTuple toValue: each;			setBalloonText: (each third isEmptyOrNil ifTrue: ['not saved'] ifFalse: [each third])	]."---	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 23:07'!step	changeCounter = ProjectHistory changeCounter ifTrue: [^self].	self rebuild.	! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 11:02'!aboutToBeGrabbedBy: aHand	| aFridge |	aFridge _ self ownerThatIsA: EToyFridgeMorph.	aFridge ifNil: [^self].	aFridge noteRemovalOf: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:50'!acceptDroppingMorph: morphToDrop event: evt	| myCopy outData |	evt hand rejectDropMorph: morphToDrop event: evt.		"we don't really want it"	myCopy _ morphToDrop veryDeepCopy.	"gradient fills require doing this second"	myCopy setProperty: #positionInOriginatingWorld toValue: morphToDrop position.	self stopFlashing.	outData _ myCopy eToyStreamedRepresentationNotifying: self.	self resetIndicator: #working.	self transmitStreamedObject: outData.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 18:26'!currentBadgeVersion	^5! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 12:30'!establishDropZone: aMorph	self setProperty: #specialDropZone toValue: aMorph.	aMorph 		on: #mouseEnterDragging send: #mouseEnteredDZ to: self;		on: #mouseLeaveDragging send: #mouseLeftDZ to: self;		on: #mouseLeave send: #mouseLeftDZ to: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 13:08'!fixOldVersion	| uName uForm uEmail uIP |	uName _ self userName.	uForm _ userPicture ifNil: [		(self 		findDeepSubmorphThat: [ :x | (x isKindOf: ImageMorph) or: [x isKindOf: SketchMorph]] 		ifAbsent: [self halt]) form.	].	uEmail _ (fields at: #emailAddress) contents.	uIP _ self ipAddress.	self		userName: uName 		userPicture: (uForm scaledToSize: 61@53)		userEmail: uEmail 		userIPAddress: uIP! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 10:19'!initialize	super initialize.	orientation _ #vertical.	color _ Color lightMagenta.	inset _ 4.	borderColor _ Color magenta.	borderWidth _ 4.	self setProperty: #normalBorderColor toValue: borderColor.	self setProperty: #flashingColors toValue: {Color red. Color yellow}.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 15:58'!ipAddress	^(fields at: #ipAddress) contents! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:13'!killExistingChat	| oldOne |	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	(oldOne _ self valueOfProperty: #embeddedChatHolder) ifNotNil: [		oldOne delete.		self removeProperty: #embeddedChatHolder	].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 18:05'!mouseEnteredDZ	| dz |	dz _ self valueOfProperty: #specialDropZone ifAbsent: [^self].	dz color: Color blue.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 18:05'!mouseLeftDZ	| dz |	dz _ self valueOfProperty: #specialDropZone ifAbsent: [^self].	dz color: Color transparent.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 17:14'!startChat	self startChat: true! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 13:14'!startChat: toggleMode	| chat r |	(self valueOfProperty: #embeddedChatHolder) ifNotNil: [		toggleMode ifFalse: [^self].		^self killExistingChat	].	(EToyChatMorph doChatsInternalToBadge and: 				[(self ownerThatIsA: EToyFridgeMorph) isNil]) ifTrue: [		chat _ EToyChatMorph new			recipientForm: userPicture; 			openIn: nil; 			setIPAddress: self ipAddress.		chat			vResizing: #spaceFill;			hResizing: #spaceFill;			borderWidth: 2;			insetTheScrollbars.		r _ (self addARow: {chat}) vResizing: #spaceFill.		self setProperty: #embeddedChatHolder toValue: r.		self hResizing: #spaceFill; vResizing: #spaceFill.	] ifFalse: [		chat _ EToyChatMorph 			chatWindowForIP: self ipAddress			name: self userName 			picture: userPicture 			inWorld: self world.		chat owner addMorphFront: chat.	]! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 13:41'!startTelemorphic	self world primaryHand 		connectRemoteUserWithName: self userName 		picture: (userPicture ifNotNil: [userPicture scaledToSize: 16@20]) 		andIPAddress: self ipAddress! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:53'!step	(self valueOfProperty: #currentBadgeVersion) = self currentBadgeVersion ifFalse: [		self setProperty: #currentBadgeVersion toValue: self currentBadgeVersion.		self fixOldVersion	].	super step.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 11:12'!tellAFriend	self world project tellAFriend: (fields at: #emailAddress) contents! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 16:15'!transmitStreamedObject: outData	self transmitStreamedObject: outData to: self ipAddress! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 16:13'!transmittedObjectCategory	^'morph'! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 13:07'!userName	^ (self 		findDeepSubmorphThat: [ :x | x isKindOf: StringMorph] 		ifAbsent: [self halt]) contents! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 12:31'!userName: aString userPicture: aFormOrNil userEmail: emailString userIPAddress: ipString	| dropZoneRow |	self setProperty: #currentBadgeVersion toValue: self currentBadgeVersion.	userPicture _ aFormOrNil ifNil: [		(TextStyle default fontOfSize: 26) emphasized: 1; characterFormAt: $?	].	self killExistingChat.	self removeAllMorphs.	self useRoundedCorners.	self 		addARow: {			self inAColumn: {(StringMorph contents: aString) lock}		}.	dropZoneRow _ self		addARow: {			self inAColumn: {userPicture asMorph lock}		}.	self establishDropZone: dropZoneRow.	self		addARow: {			self textEntryFieldNamed: #emailAddress with: emailString					help: 'Email address for this person'		};		addARow: {			self textEntryFieldNamed: #ipAddress with: ipString					help: 'IP address for this person'		};		addARow: {			self indicatorFieldNamed: #working color: Color blue help: 'working'.			self indicatorFieldNamed: #communicating color: Color green help: 'sending'.			self buttonNamed: 'C' action: #startChat color: Color paleBlue 								help: 'Open a chat with this person'.			self buttonNamed: 'T' action: #startTelemorphic color: Color paleYellow 								help: 'Start telemorphic with this person'.			self buttonNamed: '!!' action: #tellAFriend color: Color paleGreen 								help: 'Tell this person about the current project'.		}.	! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 16:06'!userPicture	^userPicture! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 18:02'!wantsDroppedMorph: aMorph event: evt	| dz |	dz _ self valueOfProperty: #specialDropZone ifAbsent: [^false].	(dz bounds containsPoint: (evt cursorPoint)) ifFalse: [^false].	^true.! !!EToySenderMorph methodsFor: 'object fileIn' stamp: 'RAA 7/12/2000 12:38'!convertbosfcebbochvimlphmmfr0: varDict bosfcebbochvimlphmmfru0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'heights' 'minWidth' 'minHeight' 'fields' 'resultQueue').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('userPicture')  If a non-nil value is needed, please assign it." ! !!EToySenderMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:52'!instanceForIP: ipAddress	^self allInstances detect: [ :x | 		x ipAddress = ipAddress	] ifNone: [nil]! !!EToySenderMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:50'!instanceForIP: ipAddress inWorld: aWorld	^self allInstances detect: [ :x | 		x world == aWorld and: [x ipAddress = ipAddress]	] ifNone: [nil]! !!EToySenderMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 14:47'!pictureForIPAddress: ipString	| senderMorphs |	senderMorphs _ EToySenderMorph allInstances select: [ :x | 		x userPicture notNil and: [x ipAddress = ipString]	].	senderMorphs isEmpty ifTrue: [^nil].	^senderMorphs first userPicture! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:16'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self worldIEnclose		addScalingMenuItems: menu 		hand: aHandMorph! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:08'!drawOn: aCanvas	super drawOn: aCanvas.	self boxesAndColorsAndSelectors do: [ :each |		aCanvas fillRectangle: each first fillStyle: each second	].! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:16'!goAppView	self worldIEnclose showApplicationView! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:17'!goFactoryView	self worldIEnclose showFactoryView! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:18'!goFullView	self worldIEnclose showFullView! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:18'!goNormalProjectEntry	| w |	w _ self worldIEnclose.	self delete.	w project enter.! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:10'!handlesMouseDown: evt	self boxesAndColorsAndSelectors do: [ :each |		(each first containsPoint: evt cursorPoint) ifTrue: [^true]	].	^false! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:26'!initialize	super initialize.	self setBalloonText: 'This is the frame of an embedded project. Click on the colored boxes:blue - expand or reduceyellow - app viewred - factory viewcyan - full viewwhite - enter the project completely'! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:13'!mouseDown: evt	self boxesAndColorsAndSelectors do: [ :each |		(each first containsPoint: evt cursorPoint) ifTrue: [			^self perform: each third		].	].! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:12'!toggleZoom	self bounds: (		bounds area > (Display boundingBox area * 0.9) ifTrue: [			Display extent // 4 extent: Display extent // 2.		] ifFalse: [			Display boundingBox		]	)! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:15'!worldIEnclose	^self firstSubmorph firstSubmorph						"quick hack since this is the only usage pattern at the moment"! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:04'!appViewBoxArea	^self genericBoxArea: 1! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:12'!boxesAndColorsAndSelectors	^{		{self zoomBoxArea. Color blue. #toggleZoom}.		{self appViewBoxArea. Color yellow. #goAppView}.		{self factoryViewBoxArea. Color red. #goFactoryView}.		{self fullViewBoxArea. Color cyan. #goFullView}.		{self normalEntryBoxArea. Color white. #goNormalProjectEntry}.	}! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:04'!factoryViewBoxArea	^self genericBoxArea: 2! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:04'!fullViewBoxArea	^self genericBoxArea: 3! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:03'!genericBoxArea: countDownFromTop	^self innerBounds right @ (self top + (countDownFromTop * 2 * borderWidth)) 		extent: borderWidth @ borderWidth! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:04'!normalEntryBoxArea	^self genericBoxArea: 4! !!EmbeddedWorldBorderMorph methodsFor: 'boxes' stamp: 'RAA 7/13/2000 10:03'!zoomBoxArea	^self genericBoxArea: 0! !!EtoyUpdatingThreePhaseButtonMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 12:18'!step	| newBoolean |	state == #pressed ifTrue: [^ self].	newBoolean _ target perform: getSelector withArguments: arguments.	newBoolean == self isOn		ifFalse:			[self state: (newBoolean ifTrue: [#on] ifFalse: [#off])]! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'RAA 7/12/2000 11:54'!resumePlayIn: aWorld	playHand _ HandMorphForReplay new recorder: self.	playHand position: tapeStream peek value cursorPoint.	aWorld addHand: playHand.	playHand newKeyboardFocus: aWorld.	playHand userInitials: 'play' andPicture: nil.	lastEvent _ nil.	lastDelta _ 0@0.	state _ #play.	self synchronize.! !!FlashSpriteMorph methodsFor: 'object fileIn' stamp: 'RAA 7/12/2000 15:04'!convertbosfcetcpmlfsdsallu0: varDict bosfcetcpmlfsdsall0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'transform' 'colorTransform' 'playing' 'maxFrames' 'loadedFrames' 'frameNumber' 'stepTime' 'damageRecorder' 'sounds' 'actions' 'labels' 'lastStepTime').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('useTimeSync').  Possibly store their info in another variable?"! !!FlashPlayerMorph methodsFor: 'object fileIn' stamp: 'RAA 7/12/2000 15:04'!convertbosfcetcpmlfsdsalluaalsp0: varDict bosfcetcpmlfsdsallaalsp0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'transform' 'colorTransform' 'playing' 'maxFrames' 'loadedFrames' 'frameNumber' 'stepTime' 'damageRecorder' 'sounds' 'actions' 'labels' 'lastStepTime' 'activationKeys' 'activeMorphs' 'localBounds' 'sourceUrl' 'progressValue').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('useTimeSync').  Possibly store their info in another variable?"! !!HandMorph methodsFor: 'cursor' stamp: 'RAA 7/12/2000 12:18'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	cursorOrNil == nil		ifTrue: [temporaryCursor _ temporaryCursorOffset _ nil]		ifFalse: [temporaryCursor _ cursorOrNil asCursorForm.				temporaryCursorOffset _ temporaryCursor offset - hotSpotOffset].	bounds _ self cursorBounds.	self 		userInitials: userInitials andPicture: (self valueOfProperty: #remoteUserPicture);		layoutChanged;		changed! !!HandMorph methodsFor: 'geometry' stamp: 'RAA 7/12/2000 11:55'!userInitials: aString	self flag: #bob.		"obsolete?"	^self userInitials: aString andPicture: nil! !!HandMorph methodsFor: 'geometry' stamp: 'RAA 7/12/2000 12:17'!userInitials: aString andPicture: aForm	| qp cb pictRect initRect |	userInitials _ aString.	pictRect _ initRect _ cb _ self cursorBounds.	userInitials isEmpty ifFalse: [		qp _ DisplayScanner quickPrintOn: Display.		initRect _ cb topRight + (0@4) extent: (qp stringWidth: userInitials)@(qp lineHeight).	].	self setProperty: #remoteUserPicture toValue: aForm.	aForm ifNotNil: [		pictRect _ (self cursorBounds topRight + (0@24)) extent: aForm extent.	].	self bounds: ((cb merge: initRect) merge: pictRect).! !!HandMorph methodsFor: 'drawing' stamp: 'RAA 7/12/2000 12:10'!drawOn: aCanvas	| userPic |	"Draw the hand itself (i.e., the cursor)."	temporaryCursor == nil		ifTrue: [aCanvas paintImage: NormalCursor at: bounds topLeft]		ifFalse: [aCanvas paintImage: temporaryCursor at: bounds topLeft].	self hasUserInformation ifTrue: [		aCanvas 			text: userInitials			at: (self cursorBounds topRight + (0@4))			font: nil			color: color.		(userPic _ self valueOfProperty: #remoteUserPicture) ifNotNil: [			aCanvas paintImage: userPic at: (self cursorBounds topRight + (0@24))		].	].! !!HandMorph methodsFor: 'drawing' stamp: 'RAA 7/12/2000 12:08'!hasUserInformation	^self userInitials size > 0 or: [self hasProperty: #remoteUserPicture]! !!HandMorph methodsFor: 'drawing' stamp: 'RAA 7/12/2000 11:47'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	savedPatch ifNotNil: [^ true].  "always process if this hand has a saved patch"	self hasUserInformation ifTrue: [^ true].	((submorphs size > 0) or:	 [temporaryCursor ~~ nil])		ifTrue: [			"using the software cursor; hide the hardware one"			Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show].			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'RAA 7/12/2000 11:50'!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas drawImage: savedPatch at: savedPatch offset.		self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"		submorphs size > 0 ifTrue: [^self].		temporaryCursor ifNotNil: [^self].		"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."		super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).		Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].  "show hardware cursor"		savedPatch _ nil.	].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 7/13/2000 15:54'!grabMorphInner: m	| myPos morphPos localPt trans morphToGrab newT |	formerOwner _ m owner.	formerPosition _ m position.	"Check if the morph will keep it's transform while grabbed"	myPos _ self position.	morphPos _ m position.	localPt _ (m keepsTransform "or: [formerOwner isNil]")		ifTrue:[myPos]		ifFalse:[((m world ifNil: [self worldUnderCursor]) 							globalPointToLocal: myPos) truncated].						"fix grabbing new morph in embedded world"	(formerOwner == nil		or: [m keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		m position: myPos + (morphPos - localPt).		morphToGrab _ m.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ m addFlexShell transform: trans asMorphicTransform.		m position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	gridOn ifTrue: [morphToGrab position: (morphToGrab position grid: grid)].	self addMorphBack: morphToGrab.! !!HandMorph methodsFor: 'remote morphic' stamp: 'RAA 7/13/2000 13:05'!connectRemoteUser		^self		connectRemoteUserWithName: nil 		picture: nil 		andIPAddress: nil! !!HandMorph methodsFor: 'remote morphic' stamp: 'RAA 7/13/2000 13:09'!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials _ nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr _ 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr _ NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr _ NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	Socket ensureNetworkConnected.	h _ RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self world addHand: h.	h changed.	h startListening.	self startTransmittingEventsTo: addr.! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:49'!deleteWithSiblings	siblings do: [ :each | each delete]! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:48'!handlesMouseOver: evt	^true! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:48'!initialize	super initialize.	siblings _ #().! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:50'!mouseEnter: evt	self deleteWithSiblings! !!MouseActionIndicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:49'!siblings: aCollection	siblings _ aCollection.! !!MouseActionIndicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 11:08'!world: aWorld inner: innerRectangle outer: outerRectangle color: aColor	| allRects allMorphs |	allRects _ outerRectangle areasOutside: innerRectangle.	allMorphs _ allRects collect: [ :each |		self new bounds: each; color: aColor	].	allMorphs do: [ :each |		each siblings: allMorphs; openInWorld: aWorld	].	^allMorphs! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 7/13/2000 10:28'!addScalingMenuItems: menu hand: aHandMorph	| subMenu |	(subMenu _ MenuMorph new)		defaultTarget: self;		add: 'show application view' action: #showApplicationView;		add: 'show factory view' action: #showFactoryView;		add: 'show whole world view' action: #showFullView;		add: 'expand' action: #showExpandedView;		add: 'reduce' action: #showReducedView;		addLine;		add: 'define application view' action: #defineApplicationView;		add: 'define factory view' action: #defineFactoryView.	menu		add: 'world scale and clip...'		subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 7/13/2000 10:17'!showFullView	self transformToShow: bounds		! !!PasteUpMorph methodsFor: 'pen' stamp: 'RAA 7/13/2000 18:39'!updateTrailsForm 	"Update the turtle-trails form using the current positions of all pens.	Only used in conjunction with Preferences batchPenTrails."	"Details: The positions of all morphs with their pens down are recorded each time the draw method is called. If the list from the previous display cycle isn't empty, then trails are drawn from the old to the new positions of those morphs on the turtle-trails form. The turtle-trails form is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| morph oldPoint newPoint removals player tfm |	self flag: #bob.		"transformations WRONG here"	(lastTurtlePositions == nil or: [lastTurtlePositions size = 0]) ifTrue: [^ self].	removals _ OrderedCollection new.	lastTurtlePositions associationsDo: [:assoc |		player _ assoc key.		morph _ player costume.		(player getPenDown and: [morph trailMorph == self])			 ifTrue:				[oldPoint _ assoc value.				tfm _ morph owner transformFrom: self.				newPoint _ tfm localPointToGlobal: morph referencePosition.				newPoint = oldPoint ifFalse:					[assoc value: newPoint.					self drawPenTrailFor: morph from: oldPoint to: newPoint]]			ifFalse: [removals add: player]].	removals do: [:key | lastTurtlePositions removeKey: key ifAbsent: []]! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 7/16/2000 00:36'!sleep	self flag: #bob.		"Alan wanted this"	worldState canvas ifNil: [^ self  "already called (clean this up)"].	Cursor normal show.	"restore the normal cursor"">>>> Alan wanted this out	(turtleTrailsForm ~~ nil and: [self confirm: 'May I clear the pen trailsin this worldState to save space?']) ifTrue: [self clearTurtleTrails].<<<<<"	worldState canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!PluggableTextMorph methodsFor: 'transcript' stamp: 'RAA 7/11/2000 06:27'!appendTextEtoy: moreText	"Append the text in the model's writeStream to the editable text. "	self 		selectInvisiblyFrom: textMorph asText size + 1 to: textMorph asText size;		replaceSelectionWith: moreText;		selectFrom: textMorph asText size + 1 to: textMorph asText size;		hasUnacceptedEdits: false;		scrollSelectionIntoView;		changed! !!ProcessorScheduler methodsFor: 'objects from disk' stamp: 'RAA 7/7/2000 23:19'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a path to me in the other system instead."	^ DiskProxy global: #Processor selector: #yourself args: #()! !!ProgressTargetRequestNotification methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 12:25'!defaultAction	self resume: nil! !!Project methodsFor: 'menu messages' stamp: 'RAA 7/12/2000 10:20'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject makeThumbnail.			returningFlag == #specialReturn ifTrue: [				ProjectHistory forget: CurrentProject.		"this guy is irrelevant"			] ifFalse: [				ProjectHistory remember: CurrentProject.			].		].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ Display pauseMorphicEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[Display changeMorphicWorldTo: world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[Display changeMorphicWorldTo: nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: 'menu messages' stamp: 'RAA 7/7/2000 11:53'!finalEnterActions	| navigator armsLengthCmd |	armsLengthCmd _ self parameterAt: #armsLengthCmd ifAbsent: [nil].	navigator _ world findA: ProjectNavigationMorph.	Preferences showProjectNavigator & navigator isNil ifTrue: [		navigator _ ProjectNavigationMorph new openInWorld: world.		navigator bottomLeft: world bottomLeft.	].	navigator notNil & armsLengthCmd notNil ifTrue: [		navigator color: Color lightBlue	].	armsLengthCmd notNil ifTrue: [		armsLengthCmd openInWorld: world	].! !!Project methodsFor: 'release' stamp: 'RAA 7/7/2000 13:31'!okToChange	| ok hasSubProjects is list |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ world isMorph not and: [world scheduledControllers size <= 1].	ok ifFalse: [self isMorphic ifTrue: [		self parent == CurrentProject 			ifFalse: [^true]]].  "view from elsewhere.  just delete it."	ok _ (self confirm:'Really delete the project', self name printString, 'and all its windows?').			ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	ImageSegment allSubInstancesDo: [:seg |		seg ifOutPointer: self thenAllObjectsDo: [:obj |			(obj isKindOf: ProjectViewMorph) ifTrue: [				obj deletingProject: self.  obj abandon].			obj class == Project ifTrue: [obj deletingProject: self]]].	Project allProjects do: [:p | p deletingProject: self].	"ones that are in"	ProjectViewMorph allSubInstancesDo: [:p | 		p deletingProject: self.		p project == self ifTrue: [p abandon]].	world isMorph 		ifTrue: [world submorphs do:   "special release for wonderlands"						[:m | (m isKindOf: WonderlandCameraMorph)								and: [m getWonderland release]].			"Remove Player classes and metaclasses owned by project"			is _ ImageSegment new arrayOfRoots: (Array with: self).			(list _ is rootsIncludingPlayers) ifNotNil: [				(list copyWithout: self) do: [:playerCls | 					playerCls isMeta ifFalse: [						playerCls removeFromSystemUnlogged]]]].	self removeChangeSetIfPossible.	^ true! !!Project methodsFor: 'release' stamp: 'RAA 7/7/2000 13:31'!removeChangeSetIfPossible	| itsName |	changeSet isEmpty ifFalse: [^self].	(changeSet projectsBelongedTo copyWithout: self) isEmpty ifFalse: [^self].	itsName _ changeSet name.	ChangeSorter removeChangeSet: changeSet.	Transcript cr; show: 'project change set ', itsName, ' deleted.'! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/7/2000 12:20'!armsLengthCommand: aCommand withDescription: aString	| pvm tempProject |	"Set things up so that this aCommand is sent to self as a messageafter jumping to the parentProject.  For things that can't be executedwhile in this project, such as saveAs, loadFromServer, storeOnServer.  SeeProjectViewMorph step."	self isMorphic ifTrue: [		tempProject _ Project newMorphic.		tempProject world color: (InfiniteForm with: world imageForm).		tempProject projectParameters 			at: #armsLengthCmd 			put: (				DoCommandOnceMorph new					addText: aString;					actionBlock: [						self doArmsLengthCommand: aCommand.					] fixTemps			).		tempProject enter.	] ifFalse: [		parentProject ifNil: [^ self inform: 'The top project can''t do that'].		pvm _ parentProject findProjectView: self.		pvm armsLengthCommand: {self. aCommand}.		self exit.	].! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/7/2000 13:35'!doArmsLengthCommand: aCommand	"We are no longer the active project, so do it"	self perform: aCommand.	self enter: #specialReturn.	"re-enter me and forget the temp project"! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/15/2000 18:39'!ensureChangeSetNameUnique	| myName |	myName _ self name.	Project allInstancesDo: [:pp | 		pp == self ifFalse: [			pp name = myName ifTrue: [				^self projectChangeSet name: (ChangeSet uniqueNameLike: myName)			]		]	]! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/15/2000 19:23'!findAFolderToLoadProjectFrom	self couldOpenInMorphic ifTrue: [		^FileList2 modalFolderSelectorForProjectLoad	] ifFalse: [		^PluggableFileList getFolderDialog openLabel: 'Select a folder on a server:'	]! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/15/2000 18:54'!loadFromServer: newerAutomatically	| servers pair resp |	"If a newer version of me is on the server, load it."	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #loadFromServer withDescription: 'Loading'	].	servers _ self tryToFindAServerWithMe ifNil: [^ nil].	pair _ self class mostRecent: self name onServer: servers first.	pair first ifNil: [^ self inform: 'can''t find file on server for ', self name].	self currentVersionNumber > pair second ifTrue: [		^ self inform: 'That server has an older version of the project.'].	version = (pair first findTokens: '|.') second ifTrue: [		resp _ (PopUpMenu labels: 'Reload anyway\Cancel' withCRs) startUpWithCaption: 					'The only changes are the ones you made here.'.		resp ~= 1 ifTrue: [^ nil]	] ifFalse: [		newerAutomatically ifFalse: [			resp _ (PopUpMenu labels: 'Load it\Cancel' withCRs) startUpWithCaption: 						'A newer version exists on the server.'.			resp ~= 1 ifTrue: [^ nil]		].	].	"Find parent project, go there, zap old thumbnail"	parentProject installRemoteNamed: pair first from: servers first named: self name.! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/7/2000 12:14'!storeOnServer	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	world setProperty: #optimumExtentFromAuthor toValue: world extent.	self hasBadNameForStoring ifTrue: [		^self inform: 'The name of this project may cause problems when stored in a file.Please fix it and try again.'	].	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer withDescription: 'Publishing'	].	self storeOnServerWithProgressInfo.! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/7/2000 12:14'!storeOnServerShowProgressOn: aMorphOrNil	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	world setProperty: #optimumExtentFromAuthor toValue: world extent.	self hasBadNameForStoring ifTrue: [		^self inform: 'The name of this project may cause problems when stored in a file.Please fix it and try again.'	].	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer withDescription: 'Publishing'	].	self storeOnServerWithProgressInfoOn: aMorphOrNil.! !!Project methodsFor: 'file in/out' stamp: 'RAA 7/15/2000 19:13'!tryToFindAServerWithMe	| servers resp primaryServerDirectory |	[(servers _ self serverList) isEmpty] whileTrue: [		resp _ (PopUpMenu labels: 'Try to find a server\Cancel' withCRs) startUpWithCaption: 					'This project thinks it has never been on a server'.		resp ~= 1 ifTrue: [^ nil].		(primaryServerDirectory _ self findAFolderToLoadProjectFrom) ifNil: [^nil].		urlList _ Array with: primaryServerDirectory realUrl, '/'.	].	^servers! !!Project methodsFor: 'SuperSwiki' stamp: 'RAA 7/13/2000 11:11'!tellAFriend	self tellAFriend: nil! !!Project methodsFor: 'SuperSwiki' stamp: 'RAA 7/13/2000 11:11'!tellAFriend: emailAddressOrNil"Project current tellAFriend"	self url isEmpty ifTrue: [		^self inform: 'Since this project has not been saved yet,I cannot tell someone where it is.'	].	FancyCelesteComposition new		celeste: nil 		to: (emailAddressOrNil ifNil: ['RECIPIENT.GOESHERE'])		subject: 'A Squeak project link you might like'		initialText: 'This is a link to a Squeak project: '		theLinkToInclude: '<A HREF="sqPr://',self url,'">',self name,'</A>';		open.! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:57'!changed	ChangeCounter _ (ChangeCounter ifNil: [0]) + 1.	super changed.! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:17'!forget: aProject	| newTuple |	newTuple _ {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.	mostRecent _ mostRecent reject: [ :each |		each fourth first == aProject or: [			each fourth isNil & (each first = newTuple first)		].	].	self changed.	^newTuple! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:27'!initialize	mostRecent _ OrderedCollection new.! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 16:06'!mostRecentCopy	^mostRecent copy! !!ProjectHistory methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:17'!remember: aProject	| newTuple |	newTuple _ self forget: aProject.	mostRecent addFirst: newTuple.	mostRecent size > 10 ifTrue: [mostRecent _ mostRecent copyFrom: 1 to: 10].	self changed! !!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:56'!changeCounter	^ChangeCounter ifNil: [ChangeCounter _ 0].! !!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:27'!currentHistory	^CurrentHistory ifNil: [CurrentHistory _ self new initialize].! !!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/12/2000 10:16'!forget: aProject	self currentHistory forget: aProject! !!ProjectHistory class methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 15:31'!remember: aProject	self currentHistory remember: aProject! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 08:31'!addButtons	self 		addButton: '< Prev' balloonText: 'Previous project' for: #previousProject;		addButton: 'Next >' balloonText: 'Next project' for: #nextProject;		addButton: '^ Publish' balloonText: 'Publish this project. Save it where it came from (server, hard disk, etc.) ' for: #publishProject;		addButton: 'Newer?' balloonText: 'Is there a newer version of this project ?' for: #getNewerVersionIfAvailable;		addButton: 'Tell!!' balloonText: 'Tell a friend about this project' for: #tellAFriend;		addButton: 'Find...' balloonText: 'Find a project' for: #findAProject.	self inFullScreenMode ifTrue: [		self addButton: 'Browser Reentry' balloonText: 'Re-enter the browser' for: #fullScreenOff	] ifFalse: [		self addButton: 'Escape Browser' balloonText: 'Use the full screen' for: #fullScreenOn	].	self inFlapsSuppressedMode ifTrue: [		self addButton: 'Show tabs' balloonText: 'Show tabs' for: #toggleFlapsSuppressed	] ifFalse: [		self addButton: 'Hide tabs' balloonText: 'Hide tabs' for: #toggleFlapsSuppressed	].! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 08:34'!currentNavigatorVersion	^7		"since these guys get saved, we fix them up if they are older versions"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 14:32'!findAProject	FileList2 morphicViewProjectLoader2InWorld: self world! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 00:04'!fullScreenOff	self setProperty: #showingFullScreenMode toValue: false.	ScreenController new fullScreenOff.	self removeProperty: #currentNavigatorVersion.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/14/2000 23:28'!fullScreenOn	self setProperty: #showingFullScreenMode toValue: true.	ScreenController new fullScreenOn.	self removeProperty: #currentNavigatorVersion.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 08:26'!inFlapsSuppressedMode	^(self valueOfProperty: #flapsSuppressedMode) == true! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 00:03'!inFullScreenMode	^(self valueOfProperty: #showingFullScreenMode) == true! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 08:30'!step	| wb lastScreenMode flapsSuppressed |	owner == self world ifFalse: [^ self].	lastScreenMode _ ScreenController lastScreenModeSelected ifNil: [false].	flapsSuppressed _ CurrentProjectRefactoring currentFlapsSuppressed.	((self valueOfProperty: #currentNavigatorVersion) = self currentNavigatorVersion			and: [lastScreenMode = self inFullScreenMode			and: [flapsSuppressed = self inFlapsSuppressedMode]]) ifFalse: [		self setProperty: #flapsSuppressedMode toValue: flapsSuppressed.		self setProperty: #showingFullScreenMode toValue: lastScreenMode.		self setProperty: #currentNavigatorVersion toValue: self currentNavigatorVersion.		self removeAllMorphs.		self addButtons.	].	owner addMorphInLayer: self.	wb _ self worldBounds.	self left < wb left ifTrue: [self left: wb left].	self right > wb right ifTrue: [self right: wb right].	self positionVertically.	"button color stuff moved to #color:"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 08:31'!toggleFlapsSuppressed	CurrentProjectRefactoring currentToggleFlapsSuppressed! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:13'!enter	"Enter my project."	self world == self outermostWorldMorph ifFalse: [^1 beep]. "can't do this at the moment"	project class == DiskProxy ifFalse: [		(project world notNil and: 				[project world outermostWorldMorph == self outermostWorldMorph]) ifTrue: [			^1 beep		"project is open in a window already"		].	].	project class == DiskProxy ifTrue: ["When target is not in yet"		self enterWhenNotPresent.	"will bring it in"		project class == DiskProxy ifTrue: [^self inform: 'Project not found']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project enter: false revert: false saveForRevert: false.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:13'!enterAsActiveSubproject	"Enter my project."	project class == DiskProxy ifTrue: ["When target is not in yet"		[self enterWhenNotPresent]	"will bring it in"			on: ProjectEntryNotification			do: [ :ex | 				^ex projectToEnter enterAsActiveSubprojectWithin: self world			].		project class == DiskProxy ifTrue: [self error: 'Could not find view']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project enterAsActiveSubprojectWithin: self world.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/12/2000 07:44'!lastProjectThumbnail: aForm		lastProjectThumbnail _ aForm! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:17'!mouseDown: evt	self removeProperty: #wasOpenedAsSubproject.	self showMouseState: 2.	mouseDownTime _ Time millisecondClockValue! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:14'!mouseEnter: evt	self showMouseState: 1! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:13'!mouseLeave: evt	self showMouseState: 3.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:13'!mouseUp: evt	((self containsPoint: evt cursorPoint) and: 				[(self hasProperty: #wasOpenedAsSubproject) not]) ifTrue:		[^ self enter].	self showMouseState: 3.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/16/2000 14:18'!showMouseState: anInteger	anInteger = 1 ifTrue: [		"enter"		self addMouseActionIndicatorsWidth: 10 color: (Color blue alpha: 0.3).		self showBorderAs: Color blue	].	anInteger = 2 ifTrue: [		"down"		self addMouseActionIndicatorsWidth: 15 color: (Color blue alpha: 0.7).		self showBorderAs: Color red.	].	anInteger = 3 ifTrue: [		"leave"		self deleteAnyMouseActionIndicators.		self showBorderAs: Color gray	].! !!ProjectViewMorph methodsFor: 'fileIn/out' stamp: 'RAA 7/10/2000 23:30'!eToyStreamedRepresentationNotifying: aWidget	| safeVariant outData |	self flag: #bob.		"probably irrelevant"	safeVariant _ self copy.	[ outData _ SmartRefStream streamedRepresentationOf: safeVariant ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				aWidget ifNotNil: [aWidget flashIndicator: #working].			].		].	^outData! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 14:58'!acceptDroppingMorph: morphToDrop event: evt	| myCopy |	evt hand rejectDropMorph: morphToDrop event: evt.		"we don't really want it"	project ifNil: [^1 beep].	(project isInMemory not or: [project class == DiskProxy]) ifTrue: [		^1 beep	].	myCopy _ morphToDrop veryDeepCopy.	"gradient fills require doing this second"	myCopy openInWorld: project world! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 14:54'!wantsDroppedMorph: aMorph event: evt	^true.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'RAA 7/12/2000 11:46'!startListening	"Create a socket and start listening for a connection."	self stopListening.	Transcript show: 'My address is ', NetNameResolver localAddressString; cr.	Transcript show: 'Remote hand ', self userInitials, ' waiting for a connection...'; cr.	socket _ Socket new.	socket listenOn: 54323.	waitingForConnection _ true.! !!RemoteHandMorph methodsFor: 'other' stamp: 'RAA 7/12/2000 11:46'!withdrawFromWorld	"Close the socket, if any, and remove this hand from the world."	self stopListening.	Transcript show: 'Remote hand ', self userInitials, ' closed'; cr.	owner ifNotNil: [owner removeHand: self].! !!ScorePlayerMorph methodsFor: 'object fileIn' stamp: 'RAA 7/15/2000 15:51'!convertbosfcebbochvimolpstis0: varDict bosfcebbochvimlpstis0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'scorePlayer' 'trackInstNames' 'instrumentSelector' 'scrollSlider').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!ScreenController methodsFor: 'menu messages' stamp: 'RAA 7/15/2000 00:01'!fullScreenOff	Smalltalk fullScreenMode: (LastScreenModeSelected _ false).	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'RAA 7/15/2000 00:01'!fullScreenOn	Smalltalk fullScreenMode: (LastScreenModeSelected _ true).	self restoreDisplay.! !!ScreenController class methodsFor: 'as yet unclassified' stamp: 'RAA 7/15/2000 09:28'!lastScreenModeSelected	^LastScreenModeSelected! !!SimpleSliderMorph methodsFor: 'object fileIn' stamp: 'RAA 7/15/2000 15:51'!convertbosfcebbmsosvssstammt0: varDict bosfcebbmsosvsssdtammt0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'model' 'slotName' 'open' 'slider' 'value' 'setValueSelector' 'sliderShadow' 'sliderColor' 'target' 'arguments' 'minVal' 'maxVal' 'truncate').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('descending')  If a non-nil value is needed, please assign it."! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 05:48'!objectFromStreamedRepresentation: someBytes	| file |	file _ RWBinaryOrTextStream with: someBytes.	file reset.	^file fileInObjectAndCode! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 05:35'!streamedRepresentationOf: anObject	| file |	file _ (RWBinaryOrTextStream on: (ByteArray new: 5000)).	file binary.	(self on: file) nextPut: anObject.	file close.	^file contents! !!Socket class methodsFor: 'tests' stamp: 'RAA 7/16/2000 10:03'!newAcceptCheck"Socket newAcceptCheck"	| socket |	self initializeNetwork.	socket _ self newTCP.	socket listenOn: 44444 backlogSize: 4.	socket isValid ifTrue: [		self inform: 'Everything looks OK for the BSD style accept()'	] ifFalse: [		self inform: 'It appears that you DO NOT have support for the BSD style accept()'	].	socket destroy.! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'RAA 7/11/2000 11:38'!writeOn: aStream 	| reversed convertToBytes |	"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds."	self flag: #bob.		"clean up the first part of this"	convertToBytes _ aStream originalContents "collection" class isBytes.	((aStream isKindOf: FileStream) or: 		[aStream isKindOf: GZipSurrogateStream]) ifTrue: [convertToBytes _ false].	"knows how"	aStream nextInt32Put: self size.	Smalltalk endianness == #big 		ifTrue: ["no change"			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a non-file byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]	"files use this"		ifFalse: [			reversed _ self clone.			reversed restoreEndianness.	"swap an extra time to get to big endian format"			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !!SoundBuffer methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:31'!writeOnGZIPByteStream: aStream 		aStream nextPutAllWordArray: self! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 09:59'!drawOn: aCanvas	form ifNil: [form _ (Form extent: 32@32 depth: 8) fillColor: Color green].	(cache isNil or: [cache extent ~= bounds extent]) ifTrue: [		cache _ Form extent: bounds extent depth: aCanvas depth.		form displayInterpolatedIn: cache boundingBox on: cache.	].	aCanvas paintImage: cache at: bounds origin.! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 16:20'!form: aForm	form _ aForm! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 16:23'!initialize	super initialize.	hResizing _ vResizing _ #spaceFill.! !!SystemWindow class methodsFor: 'top window' stamp: 'RAA 7/7/2000 09:34'!clearTopWindow	TopWindow _ nil.	"if leaving morphic to export from mvc, this ref could cause problems"! !!WorldState methodsFor: 'stepping' stamp: 'RAA 7/15/2000 13:00'!runStepMethodsIn: aWorld	| queue |	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	queue _ self class deferredUIMessages.	[queue isEmpty] whileFalse: [		queue next value	].	self runLocalStepMethodsIn: aWorld.	aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ].! !!WorldState class methodsFor: 'class initialization' stamp: 'RAA 7/15/2000 12:58'!addDeferredUIMessage: valuableObject	self deferredUIMessages nextPut: valuableObject.! !!WorldState class methodsFor: 'class initialization' stamp: 'RAA 7/15/2000 12:58'!deferredUIMessages	^DeferredUIMessages ifNil: [DeferredUIMessages _ SharedQueue new].! !!WorldState class methodsFor: 'class initialization' stamp: 'RAA 7/15/2000 12:56'!initialize	"WorldState initialize"	MinCycleLapse _ 20.		"allows 50 frames per second..."	DisableDeferredUpdates _ false.	DeferredUIMessages _ SharedQueue new.! !WorldState initialize!Project removeSelector: #armsLengthCommand:!!EmbeddedWorldBorderMorph reorganize!('as yet unclassified' addCustomMenuItems:hand: drawOn: extent: fixLayout goAppView goFactoryView goFullView goNormalProjectEntry handlesMouseDown: initialize minHeight minHeight: minWidth minWidth: morphicLayerNumber mouseDown: myWorldChanged toggleZoom worldIEnclose)('boxes' appViewBoxArea boxesAndColorsAndSelectors factoryViewBoxArea fullViewBoxArea genericBoxArea: normalEntryBoxArea zoomBoxArea)!FancyCelesteComposition removeSelector: #buttonWithAction:!