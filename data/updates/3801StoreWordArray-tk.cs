'From Squeak3.1alpha of 4 February 2001 [latest update: #3810] on 7 March 2001 at 6:28 pm'!"Change Set:		StoreWordArray-tkDate:			7 March 2001Author:			Ted KaehlerFor all classes that act like WordArrays (variable, non-pointer, words) tell them to use the same storage method as ColorArray.  In DataStream, store as raw bits, and correct for endianness.  	16-bit classes like SoundBuffer have their own copies of the methods.Fixes problem with ColorArray."!!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:42'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Reverse the byte order if the current machine is Little Endian.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	self class isPointers | self class isWords not ifTrue: [^ self].	Smalltalk endianness == #little 		ifTrue: [self swapBytesFrom: 1 to: self size]! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:45'!swapBytesFrom: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	| hack blt |	self class isPointers | self class isWords not ifTrue: [^ self].	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:36'!swapHalves		"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word.	This method is only used for 16-bit quanities in SoundBuffer, ShortIntegerArray, etc."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 2.	blt sourceX: 0; destX: 2; copyBits.  "Exchange bytes 0&1 with 2&3"	blt sourceX: 2; destX: 0; copyBits.	blt sourceX: 0; destX: 2; copyBits.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 18:07'!writeOn: aStream 	| reversed convertToBytes |	"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	self class isPointers | self class isWords not ifTrue: [^ super writeOn: aStream].				"super may cause an error, but will not be called."	convertToBytes _ aStream originalContents "collection" class isBytes.	(aStream isKindOf: FileStream) ifTrue: [convertToBytes _ false].	"knows how"	Smalltalk endianness == #big 		ifTrue: ["no change"			aStream nextInt32Put: self size.			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]		ifFalse: [			reversed _ self clone.			reversed swapBytesFrom: 1 to: reversed size.			aStream nextInt32Put: reversed size.			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 18:07'!writeOnGZIPByteStream: aStream 	"We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	self class isPointers | self class isWords not ifTrue: [^ super writeOnGZIPByteStream: aStream].		"super may cause an error, but will not be called."		aStream nextPutAllWordArray: self! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'tk 3/7/2001 18:06'!newFromStream: s	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."	| len |	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].		"super may cause an error, but will not be called."	s next = 16r80 ifTrue:		["A compressed format.  Could copy what BitMap does, or use a 		special sound compression format.  Callers normally compress their own way."		^ self error: 'not implemented'].	s skip: -1.	len _ s nextInt32.	^ s nextWordsInto: (self new: len)! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'tk 3/7/2001 17:57'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 80. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"bitmap-like"	t at: SoundBuffer put: 20.  refTypes add: 1.	"And all other word arrays, both 		16-bit and 32-bit.  See methods in ArrayedCollection.  Overridden in SoundBuffer."	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"	"t at:  put: 22.  refTypes add: 0."	ReferenceStream refTypes: refTypes.		"save it"	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."	Smalltalk do: [:cls |		cls isInMemory ifTrue: [			cls isBehavior ifTrue: [				cls isPointers not & cls isVariable & cls isWords ifTrue: [					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].! !!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:37'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| hack blt |	Smalltalk endianness == #little ifTrue: [		"The implementation is a hack, but fast for large ranges"		hack _ Form new hackBits: self.		blt _ (BitBlt toForm: hack) sourceForm: hack.		blt combinationRule: Form reverse.  "XOR"		blt sourceY: 0; destY: 0; height: self size; width: 1.		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"		blt sourceX: 1; destX: 0; copyBits.		blt sourceX: 0; destX: 1; copyBits.		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"		blt sourceX: 3; destX: 2; copyBits.		blt sourceX: 2; destX: 3; copyBits].! !!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:37'!writeOn: aStream 	| reversed convertToBytes |	"*** An Array of 16-bit values stored in a 32-bit array.  Fancy swapping is done on the reading side. ***	Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds."	self flag: #bob.		"clean up the first part of this"	convertToBytes _ aStream originalContents "collection" class isBytes.	((aStream isKindOf: FileStream) or: 		[aStream isKindOf: GZipSurrogateStream]) ifTrue: [convertToBytes _ false].	"it knows how"	aStream nextInt32Put: self size.	Smalltalk endianness == #big 		ifTrue: ["no change"			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a non-file byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]	"files use this"		ifFalse: [			reversed _ self clone.			reversed restoreEndianness.	"swap an extra time to get to big endian format"			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !!ShortRunArray methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:38'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| hack blt |	Smalltalk endianness == #little ifTrue: [		"The implementation is a hack, but fast for large ranges"		hack _ Form new hackBits: self.		blt _ (BitBlt toForm: hack) sourceForm: hack.		blt combinationRule: Form reverse.  "XOR"		blt sourceY: 0; destY: 0; height: self size; width: 1.		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"		blt sourceX: 1; destX: 0; copyBits.		blt sourceX: 0; destX: 1; copyBits.		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"		blt sourceX: 3; destX: 2; copyBits.		blt sourceX: 2; destX: 3; copyBits].! !!ShortRunArray methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:37'!writeOn: aStream 	| reversed convertToBytes |	"*** An Array of 16-bit values stored in a 32-bit array.  Fancy swapping is done on the reading side. ***	Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds."	self flag: #bob.		"clean up the first part of this"	convertToBytes _ aStream originalContents "collection" class isBytes.	((aStream isKindOf: FileStream) or: 		[aStream isKindOf: GZipSurrogateStream]) ifTrue: [convertToBytes _ false].	"it knows how"	aStream nextInt32Put: self size.	Smalltalk endianness == #big 		ifTrue: ["no change"			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a non-file byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]	"files use this"		ifFalse: [			reversed _ self clone.			reversed restoreEndianness.	"swap an extra time to get to big endian format"			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/7/2001 18:17'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures _ Dictionary new.	superclasses _ Dictionary new.	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"			refs keysDo: [:each | 				cls _ each class.				"cls isObsolete ifTrue: [self error: 'Trying to write ', cls name]."				(cls class ~~ Metaclass) & (cls isObsolete not) ifTrue: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures at: #Point put: false.	"writeRectangle: does not put out class pointer"	structures at: #Rectangle put: false.	structures at: #LargePositiveInteger put: false.	"used in slow case of WordArray"	structures keysDo: [:nm | 		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	(refs includesKey: #AnImageSegment) 		ifTrue: [classInstVars _ #()]		ifFalse: [self saveClassInstVars].	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:31'!writeOn: aStream 	| reversed convertToBytes |	"*** An Array of 16-bit values stored in a 32-bit array.  Fancy swapping is done on the reading side. ***	Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds."	self flag: #bob.		"clean up the first part of this"	convertToBytes _ aStream originalContents "collection" class isBytes.	((aStream isKindOf: FileStream) or: 		[aStream isKindOf: GZipSurrogateStream]) ifTrue: [convertToBytes _ false].	"it knows how"	aStream nextInt32Put: self size.	Smalltalk endianness == #big 		ifTrue: ["no change"			convertToBytes ifTrue: [self do: [:vv | aStream nextNumber: 4 put: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a non-file byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]	"files use this"		ifFalse: [			reversed _ self clone.			reversed restoreEndianness.	"swap an extra time to get to big endian format"			convertToBytes ifTrue: [reversed do: [:vv | aStream nextNumber: 4 put: vv]]				ifFalse: [aStream nextPutAll: reversed]]! !WordArray class removeSelector: #newFromStream:!WordArray removeSelector: #restoreEndianness!WordArray removeSelector: #swapBytesFrom:to:!WordArray removeSelector: #writeOn:!WordArray removeSelector: #writeOnGZIPByteStream:!!WordArray reorganize!('converting' asWordArray)('accessing' atAllPut: byteSize bytesPerElement defaultElement)('private' replaceFrom:to:with:startingAt:)!SoundBuffer class removeSelector: #newFromStream:!SoundBuffer removeSelector: #swapHalves!DataStream initialize!Bitmap removeSelector: #swapBytesFrom:to:!"Postscript:Changing the table that decides how an instance is stored."DataStream initialize!