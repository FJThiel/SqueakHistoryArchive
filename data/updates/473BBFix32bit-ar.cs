'From Squeak 2.3 beta of Nov 25, 1998 on 8 December 1998 at 3:21:40 pm'!Object subclass: #BitBltSimulation	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight sourceBits sourceRaster sourcePixSize destBits destRaster destPixSize pixPerWord bitCount skew mask1 mask2 preload nWords destMask hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH srcWidth srcHeight halftoneHeight noSource noHalftone halftoneBase colorMap sourceAlpha cmBitsPerColor srcBitIndex scanStart scanStop scanString scanRightX scanStopArray scanDisplayFlag scanXTable stopCode bitBltOop affectedL affectedR affectedT affectedB interpreterProxy opTable maskTable '	classVariableNames: 'AllOnes BBClipHeightIndex BBClipWidthIndex BBClipXIndex BBClipYIndex BBColorMapIndex BBDestFormIndex BBDestXIndex BBDestYIndex BBHalftoneFormIndex BBHeightIndex BBLastIndex BBRuleIndex BBSourceFormIndex BBSourceXIndex BBSourceYIndex BBWarpBase BBWidthIndex BBXTableIndex BinaryPoint CrossedX EndOfRun FixedPt1 FormBitsIndex FormDepthIndex FormHeightIndex FormWidthIndex OpTable OpTableSize '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 12/7/1998 21:12'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	sourcePixMask _ maskTable at: sourcePixSize.	destPixMask _ maskTable at: destPixSize.	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]"NOTE: in both noted shifts above, we are shifting the right-justified output of pickSourcePixels so that it is aligned with the destination word.  Since it gets masked anyway, we could have just picked more pixels (startBits in the first case and destPixSize in the second), and it would have been simpler, but it is slower to run the pickSourcePixels loop.  CopyLoopAlphaHack takes advantage of this to avoid having to shift full-words in its alphaSource buffer" ! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:11'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ maskTable at: destPixSize.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:33'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ maskTable at: destPixSize.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:21'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	pixMask _ maskTable at: destPixSize.	destPixSize = 16 		ifTrue: [bitsPerColor _ 5]		ifFalse:[bitsPerColor _ 8].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:18'!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).		sum <= mask  "result must not carry out of partition"			ifTrue: [result _ result bitOr: sum]			ifFalse: [result _ result bitOr: mask].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:35'!partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:36'!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	mask _ maskTable at: nBits.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		p1 _ word1 bitAnd: mask.		p2 _ word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result _ result bitOr: p2 - p1]			ifFalse: [result _ result bitOr: p1 - p2].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 21:12'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	self inline: false.	pixMask _ maskTable at: destPixSize.	destPixSize = 16		ifTrue: [bitsPerColor _ 5.  rgbMask _ 16r1F]		ifFalse: [bitsPerColor _ 8.  rgbMask _ 16rFF].	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal _ destShifted bitAnd: pixMask.			sourcePixVal _ sourceShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff _ 0]							ifFalse: [diff _ 1]]				ifFalse: [diff _ (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff _ (diff bitAnd: rgbMask)							+ (diff>>bitsPerColor bitAnd: rgbMask)							+ ((diff>>bitsPerColor)>>bitsPerColor bitAnd: rgbMask)].			bitCount _ bitCount + diff].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'ar 12/7/1998 22:27'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	pixMask _ maskTable at: destPixSize.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) = 0 ifFalse:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destPixSize = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].		maskShifted _ maskShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:15'!pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize <= 8		and colorMap notNil"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord."	| sourceWord destWord sourcePix destPix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		"look up sourcePix in colorMap"		destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask.		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:18'!pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for colorMap==nil.		SourcePixelSize is also known to be 8 bits or less."	"With no color map, pixels are just masked or zero-filled."	| sourceWord destWord sourcePix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		destPixSize = 32			ifTrue:[destWord _ sourcePix]			ifFalse:[destWord _ (destWord << destPixSize) 								bitOr: (sourcePix bitAnd: destPixMask)].		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:20'!pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize >= 16"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord.	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.	With no color map, pixels are just masked or zero-filled or	if 16- or 32-bit pixels, the r, g, and b are so treated individually."	| sourceWord destWord sourcePix destPix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		nullMap		ifTrue:			["Map between RGB pixels"			sourcePixSize = 16				ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]				ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]		ifFalse:			["RGB pixels first get reduced to cmBitsPerColor"			sourcePixSize = 16				ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]				ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor].			"Then look up sourcePix in colorMap"			destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask].		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'ar 12/7/1998 21:14'!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |	self inline: false.	sourcePixMask _ maskTable at: sourcePixSize.	destPixMask _ maskTable at: destPixSize.	srcPixPerWord _ 32 // sourcePixSize.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].		destPixSize = 32			ifTrue:[destWord _ destPix]			ifFalse:[destWord _ (destWord << destPixSize) bitOr: destPix].		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!BitBltSimulation class methodsFor: 'translation' stamp: 'ar 12/7/1998 21:27'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.! !!BitBltSimulator methodsFor: 'all' stamp: 'ar 12/7/1998 21:10'!initBBOpTable	opTable _ OpTable.	maskTable _ Array new: 32.	#(1 2 4 8 16 32) do:[:i| maskTable at: i put: (1 << i)-1].! !