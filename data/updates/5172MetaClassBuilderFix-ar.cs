'From Squeak3.4beta of ''1 December 2002'' [latest update: #5156] on 27 February 2003 at 11:47:18 pm'!"Change Set:		MetaClassBuilderFix-arDate:			27 February 2003Author:			Andreas RaabThis change set fixes a rather obscure bug with reshaping the entire class hierarchy from ClassBuilder. The problem was introduced by accidentally breaking the superclass/subclass invariant. The CS fixes this problem, by doing so actually removes some code and documents the critical invariants (both by putting comments into the methods affected and by making those methods private which temporarily break the crucial invariants).The class comment has been extended to document the fundamental assumption that ClassBuilder needs access to ALL of the subclasses no matter where no matter how they are created."!!ClassBuilder commentStamp: 'ar 2/27/2003 22:55' prior: 0!Responsible for creating a new class or changing the format of an existing class (from a class definition in a browser or a fileIn). This includes validating the definition, computing the format of instances, creating or modifying the accompanying Metaclass, setting up the class and metaclass objects themselves, registering the class as a global, recompiling methods, modifying affected subclasses, mutating existing instances to the new format, and more.You typically only need to use or modify this class, or even know how it works, when making fundamental changes to how the Smalltalk system and language works.Implementation notes:ClassBuilder relies on the assumption that it can see ALL subclasses of some class. If there are any existing subclasses of some class, regardless of whether they have instances or not, regardless of whether they are considered obsolete or not, ClassBuilder MUST SEE THEM.!!ClassBuilder methodsFor: 'class definition' stamp: 'ar 2/27/2003 22:56'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newFormat newClass |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass _ self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass _ oldClass clone].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 2/27/2003 22:24'!recompile: force from: oldClass to: newClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	oldClass == nil ifTrue:[		"newClass has an empty method dictionary		so we don't need to recompile"		Smalltalk changes addClass: newClass.		^newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		"No recompilation necessary but we might have added		class vars or class pools so record the change"		Smalltalk changes changeClass: newClass from: oldClass.		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		Smalltalk changes changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.	].	^oldClass "now mutated to newClass"! !!ClassBuilder methodsFor: 'private' stamp: 'ar 2/27/2003 22:56'!privateNewSubclassOf: newSuper	"Create a new meta and non-meta subclass of newSuper"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta newMeta |	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	newMeta _ Metaclass new.	newMeta 		superclass: newSuperMeta 		methodDictionary: MethodDictionary new 		format: newSuperMeta format.	^newMeta new! !!ClassBuilder methodsFor: 'private' stamp: 'ar 2/27/2003 22:56'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: MethodDictionary new		format: (self computeFormat: oldMeta typeOfClass 					instSize: oldMeta instVarNames size 					forSuper: newSuperMeta					ccIndex: 0);		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 2/27/2003 22:44'!mutate: oldClass to: newClass	"Mutate the old class and subclasses into newClass and subclasses.	Note: This method is slightly different from: #mutate:toSuper: since	here we are at the root of reshaping and have two distinct roots."	| newSubclass |	self showProgressFor: oldClass.	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass| 		newSubclass _ self reshapeClass: oldSubclass toSuper: newClass.		self mutate: oldSubclass to: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			newSubclass _ self reshapeClass: oldSubclass toSuper: newClass.			self mutate: oldSubclass to: newSubclass.		].	].	self update: oldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 2/27/2003 23:42'!update: oldClass to: newClass	"Convert oldClass, all its instances and possibly its meta class into newClass, instances of newClass and possibly its meta class. The process is surprisingly simple in its implementation and surprisingly complex in its nuances and potentially bad side effects. 	We can rely on two assumptions (which are critical):		#1: The method #updateInstancesFrom: will not create any lasting pointers to 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do a become of the old vs. the new instances and therefore it will not create pointers to *new* instances before the #become: which are *old* afterwards)		#2: The non-preemptive execution of the critical piece of code guarantees that nobody can get a hold by 'other means' (such as process interruption and reflection) on the old instances.	Given the above two, we know that after #updateInstancesFrom: there are no pointer to any old instances. After the forwarding become there will be no pointers to the old class or meta class either. Meaning that if we throw in a nice fat GC at the end of the critical block, everything will be gone (but see the comment right there). There's no need to worry.	"	| meta |	meta _ oldClass isMeta.	"Note: Everything from here on will run without the ability to get interrupted	to prevent any other process to create new instances of the old class."	[		"Note: The following removal may look somewhat obscure and needs an explanation. When we mutate the class hierarchy we create new classes for any existing subclass. So it may look as if we don't have to remove the old class from its superclass. However, at the top of the hierarchy (the first class we reshape) that superclass itself is not newly created so therefore it will hold both the oldClass and newClass in its (obsolete or not) subclasses. Since the #become: below will transparently replace the pointers to oldClass with newClass the superclass would have newClass in its subclasses TWICE. With rather unclear effects if we consider that we may convert the meta-class hierarchy itself (which is derived from the non-meta class hierarchy).		Due to this problem ALL classes are removed from their superclass just prior to converting them. Here, breaking the superclass/subclass invariant really doesn't matter since we will effectively remove the oldClass (become+GC) just a few lines below."		oldClass superclass removeSubclass: oldClass.		oldClass superclass removeObsoleteSubclass: oldClass.		"Convert the instances of oldClass into instances of newClass"		newClass updateInstancesFrom: oldClass.		meta			ifTrue:[oldClass becomeForward: newClass]			ifFalse:[(Array with: oldClass with: oldClass class)						elementsForwardIdentityTo:							(Array with: newClass with: newClass class)].		Smalltalk garbageCollect.		"Warning: Read this before you even think about removing the GC. Yes, it slows us down. Quite heavily if you have a large image. However, there's no good and simple alternative here, since unfortunately, #become: does change class pointers. What happens is that after the above become all of the instances of the old class will have a class pointer identifying them as instances of newClass. If we get our hands on any of these instances we will break immediately since their expected instance layout (that of its class, e.g., newClass) will not match their actual instance layout (that of oldClass). And getting your hands on any of those instances is really simple - just reshaping one class two times in rapid succession will do it. Reflection techniques, interrupts, etc. will only add to this problem. In the case of Metaclass things get even worse since when we recompile the entire class hierarchy we will recompile both, Metaclass and its instances (and some of its instances will have the old and some the new layout).		The only easy solution to this problem would be to 'fix up' the class pointers of the old instances to point to the old class (using primitiveChangeClassTo:). But this won't work either - as we do a one-way become we would have to search the entire object memory for the oldClass and couldn't even clearly identify it unless we give it some 'special token' which sounds quite error-prone. If you really need to get rid of the GC here are some alternatives:		On the image level, one could create a copy of the oldClass before becoming it into the new class and, after becoming it, 'fix up' the old instances. That would certainly work but it sounds quite complex, as we need to make sure we're not breaking any of the superclass/subclass meta/non-meta class variants.		Alternatively, fix up #becomeForward on the VM-level to 'dump the source objects' of #become. This would be quite doable (just 'convert' them into a well known special class such as bitmap) yet it has problems if (accidentally or not) one of the objects in #become: appears on 'both sides of the fence' (right now, this will work ... in a way ... even though the consequences are unclear).		Another alternative is to provide a dedicated primitive for this (instead of using it implicitly in become) which would allow us to dump all the existing instances right here. This is equivalent to a more general primitiveChangeClassTo: and might be worthwhile but it would likely have to keep in mind the differences between bits and pointer thingies etc.		Since all of the alternatives seem rather complex and magical compared to a straight-forward GC it seems best to stick with the GC solution for now. If someone has a real need to fix this problem, that person will likely be motivated enough to check out the alternatives. Personally I'd probably go for #1 (copy the old class and remap the instances to it) since it's a solution that could be easily reverted from within the image if there's any problem with it."	] valueUnpreemptively.! !ClassBuilder removeSelector: #mutate:toSuper:!ClassBuilder removeSelector: #newSubclassOf:!ClassBuilder removeSelector: #newSubclassOf:from:!