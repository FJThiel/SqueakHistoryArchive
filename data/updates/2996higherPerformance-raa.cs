'From Squeak2.9alpha of 17 July 2000 [latest update: #3042] on 26 November 2000 at 12:17:57 pm'!"Change Set:		higherPerformanceDate:			24 November 2000Author:			Bob ArningThis is mostly a Mac issue, but may have some effect on other platforms. These changes do not take effect until you set the preference #higherPerformance to true. The impact of setting this pref to true may be higher performance for this Squeak image, but lower performance for other applications/processes that may be running concurrently. Experiment with your particular configuration/desires and decide for yourself.1. In order to reduce the amount of time lost (perhaps 20 to 30% in some cases) to background applications on the Mac, change the strategy used to poll for UI events. Every time we poll the OS for UI events, increase the delay until the next check. Every time Squeak actually requests an event from EventSensor, reset the delay to its normal value (20 ms). This means that a long-running evaluation started in the UI process will receive less competition from background apps (and less overhead even if it is the only app), but normal UI-intensive operations will happen as they do now. What is lost by this change is some sensitivity to mouse events that occur while Squeak is busy over long periods. My thought is that if Squeak is so occupied for a period of seconds, these events are much less useful and perhaps even harmful.2. Reduce the minimum morphic cycle time (MinCycleLapse) so that the frame rate (and, hence, running of #step methods) can proceed at greater than 50 frames per second. This can be quite beneficial to things like simulations that are run via #step.---executable code follows"Preferences	addPreference: #higherPerformance	category: #performance	default:  false	balloonHelp: 'May offer higer performance at the expense of other applications on your computer. See the comment in EventSensor>>higherPerformanceNotes for more details'.!!EventSensor methodsFor: 'accessing' stamp: 'RAA 11/24/2000 11:03'!nextEventFromQueue	"Return the next event from the receiver."	EventPollFrequency _ 20.	"since Squeak is taking the event, reset to normal delay"	eventQueue isEmpty		ifTrue:[^nil]		ifFalse:[^eventQueue next]! !!EventSensor methodsFor: 'private-I/O' stamp: 'RAA 11/26/2000 11:57'!ioProcess	"Run the i/o process"	| eventBuffer type |	eventBuffer _ Array new: 8.	[true] whileTrue:[		[self primGetNextEvent: eventBuffer.		type _ eventBuffer at: 1.		type = EventTypeNone] whileFalse:[self processEvent: eventBuffer].		inputSemaphore waitTimeoutMSecs: EventPollFrequency.		Preferences higherPerformance ifTrue: [			EventPollFrequency _ (EventPollFrequency * 1.5) rounded min: 500.		].	].! !!EventSensor methodsFor: 'NOTES' stamp: 'RAA 11/26/2000 12:09'!higherPerformanceNotes"This is mostly a Mac issue, but may have some effect on other platforms. These changes do not take effect until you set the preference #higherPerformance to true. The impact of setting this pref to true may be higher performance for this Squeak image, but lower performance for other applications/processes that may be running concurrently. Experiment with your particular configuration/desires and decide for yourself.1. In order to reduce the amount of time lost (perhaps 20 to 30% in some cases) to background applications on the Mac, change the strategy used to poll for UI events. Every time we poll the OS for UI events, increase the delay until the next check. Every time Squeak actually requests an event from EventSensor, reset the delay to its normal value (20 ms). This means that a long-running evaluation started in the UI process will receive less competition from background apps (and less overhead even if it is the only app), but normal UI-intensive operations will happen as they do now. What is lost by this change is some sensitivity to mouse events that occur while Squeak is busy over long periods. My thought is that if Squeak is so occupied for a period of seconds, these events are much less useful and perhaps even harmful.2. Reduce the minimum morphic cycle time (MinCycleLapse) so that the frame rate (and, hence, running of #step methods) can proceed at greater than 50 frames per second. This can be quite beneficial to things like simulations that are run via #step."! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 11/26/2000 12:04'!doOneCycleFor: aWorld	self interCyclePause: (Preferences higherPerformance ifTrue: [1] ifFalse: [MinCycleLapse]).	self doOneCycleNowFor: aWorld.! !"Postscript:Reset the event polling since we changed the method it is running."EventSensor shutDown; startUp!