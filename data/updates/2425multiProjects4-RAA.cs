'From Squeak2.9alpha of 13 June 2000 [latest update: #2424] on 20 June 2000 at 1:30:44 pm'!"Change Set:		multiProjects4Date:			16 June 2000Author:			Bob Arning- introducing some FileList variants using hierarchical lists. The main reason is to create some simplified file locators for loading projects, but you may want to use this in other circumstances as well.- improvements to the ComplexProgressIndicator.  Is removed when interrupted.- miscellaneous improvements to hierarchical list- coordinate transformation fix for flaps in scaled projects- utility space comparison before and after methods- fix for opening an MVC view in a Morpic world- handle string returned where boolean expectd in #storeOnServerInnards- properly pick up flexed morphs- fixed flap tab remaining behind when popup on mouseover = false- fixed glitch when Display was resized- added two methods to Stream so that parse nodes could be printed without encountering dialect problems- fixed problem in RecentMessageSet where the selection was constantly forced to the first item"!!ComplexProgressIndicator commentStamp: 'RAA 6/20/2000 12:41' prior: 0!Note: in an effort to remove the progress indicator if a walkback occurs, #withProgressDo: must be sent from the current uiProcess. Hopefully we can relax this restriction in the future. !FileList subclass: #FileList2	instanceVariableNames: 'showDirsInFileList currentDirectorySelected fileSelectionBlock optionalButtonSpecs another yetanother andanother '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!FileList2 commentStamp: '<historical>' prior: 0!Some variations on FileList that- use a hierarchical pane to show folder structure- use different pane combinations, button layouts and prefiltering for specific uses"an alternative to the standard FileList"FileList2 morphicView openInWorld"useful for selecting, but not viewing"FileList2 morphicViewNoFile openInWorld"useful for finding and loading projects"FileList2 morphicViewProjectLoader openInWorld"useful for finding and using images"FileList2 morphicViewImageViewer openInWorld!]style[(211 36 39 42 41 49 37 49)f1cblue;,f1,f1cblue;,f1,f1cblue;,f1,f1cblue;,f1!ListItemWrapper subclass: #FileDirectoryWrapper	instanceVariableNames: 'itemName '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!PasteUpMorph subclass: #Flipper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!Object methodsFor: 'converting' stamp: 'RAA 8/2/1999 12:41'!complexContents	^self! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 15:31'!backgroundWorldDisplay	| f |	self flag: #bob.		"really need a better way to do this"			"World displayWorldSafely."	"ugliness to try to track down a possible error"	[World displayWorld] ifError: [ :a :b |		stageCompleted _ 999.		f _ FileDirectory default fileNamed: 'bob.errors'.		f nextPutAll: a printString,'  ',b printString; cr; cr.		f nextPutAll: 'worlds equal ',(formerWorld == World) printString; cr; cr.		f nextPutAll: thisContext longStack; cr; cr.		f nextPutAll: formerProcess suspendedContext longStack; cr; cr.		f close. 1 beep.	].! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/20/2000 12:40'!forkProgressWatcher	[		[stageCompleted < 999 and: 				[formerProject == Project current and: 				[formerWorld == World and: 				[translucentMorph world notNil and:				[formerProcess suspendedContext notNil and: 				[Project uiProcess == formerProcess]]]]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			self backgroundWorldDisplay.			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		formerWorld == World ifTrue: [			translucentMorph delete.			userSuppliedMorph ifNil: [targetMorph delete].		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.			userSuppliedMorph ifNil: [targetMorph privateDeleteWithAbsolutelyNoSideEffects].		].	] forkAt: 6.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 15:32'!withProgressDo: aBlock	| safetyFactor totals |	targetMorph ifNil: [		targetMorph _ RectangleMorph new			position: Sensor cursorPoint;			extent: 120@120;			openInWorld		"need to see about deleting later"	].	translucentMorph _ TranslucentProgessMorph new		bounds: targetMorph bounds;		openInWorld.	stageCompleted _ 0.	safetyFactor _ 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	totals _ self loadingHistoryDataForKey: 'total'.	newRatio _ 1.0.	estimate _ totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	formerProject _ Project current.	formerWorld _ World.	formerProcess _ Processor activeProcess.	start _ Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note |		stageCompleted _ (note messageText findTokens: ' ') first asNumber.		cumulativeStageTime _ Time millisecondClockValue - start max: 1.		prevData _ self loadingHistoryDataForKey: stageCompleted.		prevData isEmpty ifFalse: [			newRatio _ (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self loadingHistoryAt: stageCompleted add: cumulativeStageTime.		translucentMorph setProperty: #progressStageNumber toValue: stageCompleted + 1.		note resume.	].	stageCompleted _ 999.	"we'll rarely get here"! !!EventHandler methodsFor: 'object fileIn' stamp: 'RAA 6/16/2000 13:16'!convertmmmmmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkvssdd0: smartRefStrm	"These variables are automatically stored into the new instance #('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"New variables: #('startDragRecipient' 'startDragSelector' 'doubleClickSelector' 'doubleClickRecipient')  If a non-nil value is needed, please assign it."! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 23:01'!defaultBackgroundColor	^Color white! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:39'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory _ dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode _ #date].	volList _ Array with: '[]'.	directory ifNotNil: [		volList _ volList, directory pathParts.  "Nesting suggestion from RvL"	].	volList _ volList withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 13:08'!fileSelectionBlock: aBlock	fileSelectionBlock _ aBlock! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 18:29'!getSelectedDirectory	^ currentDirectorySelected! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 18:31'!initialDirectoryList	^ 	((FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self	]),	(		ServerDirectory serverNames collect: [ :n | 			FileDirectoryWrapper with: (ServerDirectory serverNamed: n) name: n model: self		]	)! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 13:17'!initialize	showDirsInFileList _ false.	fileSelectionBlock _ [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	] fixTemps.! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:40'!labelString	^ (directory ifNil: [^'[]']) pathName contractTo: 50! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/19/2000 05:33'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList sortBlock |	directory ifNil: [^#()].	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	"create block to decide what order to display the entries"	sortBlock _ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x fileSize = y fileSize 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ].	newList _ (SortedCollection new: 30) sortBlock: sortBlock.	entries do: [:entry |		(fileSelectionBlock value: entry value: pat) ifTrue: [newList add: entry]	].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	^ newList asArray.! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 18:31'!morphicDirectoryTreePane	^(SimpleHierarchicalListMorph 		on: self		list: #initialDirectoryList		selected: #getSelectedDirectory		changeSelected: #setSelectedDirectoryTo:		menu: nil		keystroke: nil) autoDeselect: false		! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:53'!morphicFileContentsPane	^PluggableTextMorph 		on: self 		text: #contents 		accept: #put:		readSelection: #contentsSelection 		menu: #fileContentsMenu:shifted:! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:54'!morphicFileListPane	^PluggableListMorph 		on: self 		list: #fileList 		selected: #fileListIndex		changeSelected: #fileListIndex: 		menu: #fileListMenu:! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:57'!morphicPatternPane	^PluggableTextMorph 		on: self 		text: #pattern 		accept: #pattern:		! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 13:00'!optionalButtonSpecs	^optionalButtonSpecs ifNil: [super optionalButtonSpecs]! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 13:01'!optionalButtonSpecs: anArray	optionalButtonSpecs _ anArray! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:48'!postOpen	directory ifNotNil: [		self changed: #(openPath) , directory pathParts. 	].! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 18:30'!setSelectedDirectoryTo: aFileDirectoryWrapper	currentDirectorySelected _ aFileDirectoryWrapper.	self directory: aFileDirectoryWrapper withoutListWrapper.	brevityState := #FileList.	"self addPath: path."	self changed: #fileList.	self changed: #contents.	self changed: #getSelectedDirectory.! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/17/2000 18:35'!addPanesTo: window from: aCollection	aCollection do: [ :each |		window addMorph: each first frame: each second.	]! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/19/2000 05:27'!morphicView	| dir aFileList window fileListTop fileListBottom midLine |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	fileListTop _ 0.08.	fileListBottom _ 0.4.	midLine _ 0.4.	self addPanesTo: window from: {		{aFileList morphicPatternPane. 0@0 corner: 0.3@fileListTop}.		{aFileList optionalButtonRow. 0.3 @ 0 corner: 1 @ fileListTop}.		{aFileList morphicDirectoryTreePane. 0@fileListTop corner: midLine@fileListBottom}.		{aFileList morphicFileListPane. midLine @ fileListTop corner: 1@fileListBottom}.		{aFileList morphicFileContentsPane. 0@fileListBottom corner: 1@1}.	}.	aFileList postOpen.	^ window ! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/19/2000 05:27'!morphicViewImageViewer	| dir aFileList window fileListTop midLine |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	aFileList optionalButtonSpecs: self specsForImageViewer.	aFileList fileSelectionBlock: [ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			#('bmp' 'gif' 'jpg' 'form' suffix = 'png') includes: 					(aFileList getSuffix: entry name asLowercase)		]	] fixTemps.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	fileListTop _ 0.08.	midLine _ 0.4.	self addPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ fileListTop}.		{aFileList morphicDirectoryTreePane. 0@fileListTop corner: midLine@1}.		{aFileList morphicFileListPane. midLine @ fileListTop corner: 1@1}.	}.	aFileList postOpen.	^ window ! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/19/2000 05:28'!morphicViewNoFile	| dir aFileList window fileListTop midLine |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	fileListTop _ 0.08.	midLine _ 0.4.	self addPanesTo: window from: {		{aFileList morphicPatternPane. 0@0 corner: 0.3@fileListTop}.		{aFileList optionalButtonRow. 0.3 @ 0 corner: 1 @ fileListTop}.		{aFileList morphicDirectoryTreePane. 0@fileListTop corner: midLine@1}.		{aFileList morphicFileListPane. midLine @ fileListTop corner: 1@1}.	}.	aFileList postOpen.	^ window ! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/19/2000 05:28'!morphicViewProjectLoader	| dir aFileList window fileListTop midLine |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	aFileList optionalButtonSpecs: self specsForProjectLoader.	aFileList fileSelectionBlock: [ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			('*.pr' match: entry name) or: ['*.pr.gz' match: entry name]		]	].	window _ (SystemWindow labelled: dir pathName) model: aFileList.	fileListTop _ 0.08.	midLine _ 0.4.	self addPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ fileListTop}.		{aFileList morphicDirectoryTreePane. 0@fileListTop corner: midLine@1}.		{aFileList morphicFileListPane. midLine @ fileListTop corner: 1@1}.	}.	aFileList postOpen.	^ window ! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 13:10'!new	^super new initialize! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/17/2000 18:47'!specsForImageViewer	^ #(	('Name' 		sortByName				sortingByName	'sort entries by name')('Date'			sortByDate				sortingByDate	'sort entries by date')('Size'			sortBySize				sortingBySize	'sort entries by size')('View'			openImageInWindow		none			'open image in a window')('Import'		importImage				none			'read image into ImageImports')('Bgnd'			openAsBackground		none			'open image as background')	)! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 13:03'!specsForProjectLoader	^ #(	('Name' 		sortByName				sortingByName	'sort entries by name')('Date'			sortByDate				sortingByDate	'sort entries by date')('Size'			sortBySize				sortingBySize	'sort entries by size')('Load'			openProjectFromFile		none			'load the selected project')	)! !!FontSet class methodsFor: 'private' stamp: 'RAA 6/20/2000 13:29'!fontName	self flag: #bob.		"temporary hack until I figure out what's happening here"	(self name beginsWith: superclass name) ifFalse: [^self name].	^ (self name copyFrom: superclass name size + 1 to: self name size) asSymbol! !!FontSet class methodsFor: 'installing' stamp: 'RAA 6/17/2000 10:16'!size: pointSize fromLiteral: aString	"This method allows a font set to be captured as sourcecode in a subclass.	The string literals will presumably be created by printing, eg,		(FileStream readOnlyFileNamed: 'Palatino24.sf2') contentsOfEntireFile,		and then pasting into a browser after a heading like, eg,size24	^ self size: 24 fromLiteral:	'--unreadable binary data--'	See the method installAsTextStyle to see how this can be used."	"This method is old and for backward compatibility only.	please use fontNamed:fromLiteral: instead."	self flag: #bob.		"used in Alan's projects"	^ StrikeFont new 		name: self fontName , (pointSize < 10			ifTrue: ['0' , pointSize printString]			ifFalse: [pointSize printString]);		readFromStrike2Stream: ((RWBinaryOrTextStream with: aString) reset; binary)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'RAA 6/19/2000 06:28'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| innerRect patchRect start subCanvas |	self flag: #bob.		"we probably want a generic version of this in Canvas"	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					"warp combinationRule: Form erase"]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					"warp combinationRule: Form paint"].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		subCanvas form 			displayInterpolatedIn: (innerRect translateBy: origin) truncated			on: self form.	].! !!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 8/3/1999 09:40'!highlightingColor	^Color red! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 18:07'!asString 	^itemName! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 18:03'!contents	^item directoryNames asSortedCollection collect: [ :n | 		FileDirectoryWrapper with: (item directoryNamed: n) name: n model: self	]! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 18:03'!hasContents	^true	! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 18:01'!setItem: anObject name: aString model: aModel	item _ anObject.	model _ aModel.	itemName _ aString.! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 18:30'!settingSelector	^#setSelectedDirectoryTo:! !!FileDirectoryWrapper class methodsFor: 'as yet unclassified' stamp: 'RAA 6/15/2000 18:01'!with: anObject name: aString model: aModel	^self new 		setItem: anObject name: aString model: aModel! !!Morph methodsFor: 'geometry' stamp: 'RAA 6/19/2000 08:17'!pointInWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFromNearestWorld) localPointToGlobal: aPoint.! !!Morph methodsFor: 'event handling' stamp: 'RAA 6/19/2000 07:13'!transformFromOutermostWorld	"Return a transform to map world coordinates into my local coordinates"	"self isWorldMorph ifTrue: [^ MorphicTransform identity]."	^ self transformFrom: self outermostWorldMorph! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/19/2000 16:26'!drawSubmorphsOn: aCanvas	| t1 t2 |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	"(Smalltalk garbageCollectMost) < 1000000 ifTrue: [		^aCanvas fillRectangle: self innerBounds color: Color red	]."	t1 _ Time millisecondsToRun: [		aCanvas 			transform2By: transform		"#transformBy: for pure WarpBlt"			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) truncated			during: [:myCanvas |				t2 _ Time millisecondsToRun: [					submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]				].			]			smoothing: smoothing	].	"BOBDEBUG ifNil: [BOBDEBUG _ OrderedCollection new].	BOBDEBUG add: {Time millisecondClockValue. t1. t2. aCanvas clipRect. self innerBounds.			(self innerBounds intersects: aCanvas clipRect)}.	BOBDEBUG size > 100 ifTrue: [ BOBDEBUG _ BOBDEBUG last: 50]."! !!BooklikeMorph methodsFor: 'object fileIn' stamp: 'RAA 6/17/2000 10:13'!convertbosfcebbochvimolppn0: varDict bosfcebbochvimlppn0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'pageSize' 'newPagePrototype').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!BookMorph methodsFor: 'object fileIn' stamp: 'RAA 6/17/2000 10:13'!convertbosfcebbochvimolppnpc0: varDict bosfcebbochvimlppnpc0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'pageSize' 'newPagePrototype' 'pages' 'currentPage').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!FlapTab methodsFor: 'positioning' stamp: 'RAA 6/19/2000 17:19'!fitOnScreen	| constrainer |	constrainer _ (owner == nil or: [owner viewBox == nil])                                        ifTrue: [self bounds]                                        ifFalse: [owner viewBox].	self orientation == #vertical ifTrue: [		self top: ((self top min: (constrainer bottom- self height)) max: constrainer top).	] ifFalse: [		self left: ((self left min: (constrainer right - self width)) max: constrainer left).	].	self flapShowing ifFalse: [self positionObject: self atEdgeOf: constrainer].! !!FlapTab methodsFor: 'show & hide' stamp: 'RAA 6/16/2000 18:46'!hideFlapUnlessOverReferent	| aWorld where |		(referent isInWorld and: 		[			where _ self outermostWorldMorph activeHand lastEvent cursorPoint.			referent bounds containsPoint: (referent globalPointToLocal: where)		]	) ifTrue: [^self].	aWorld _ self world.	self referent delete.	aWorld removeAccommodationForFlap: self.	flapShowing _ false.	self isInWorld ifFalse:		[self inboard ifTrue: [aWorld addMorphFront: self]].	self adjustPositionAfterHidingFlap! !!HaloMorph methodsFor: 'stepping' stamp: 'RAA 6/19/2000 12:58'!localHaloBoundsFor: aMorph	"aMorph may be in the hand and perhaps not in our world"	| r |	r _ aMorph worldBoundsForHalo truncated.	aMorph world = self world ifTrue: [^r].	^((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated! !!HaloMorph methodsFor: 'stepping' stamp: 'RAA 6/19/2000 12:47'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ self localHaloBoundsFor: target renderedMorph].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'RAA 6/19/2000 08:02'!doDrag: evt with: dragHandle	target setConstrainedPositionFrom: (evt cursorPoint - positionOffset). "evt is local here"! !!HaloMorph methodsFor: 'private' stamp: 'RAA 6/19/2000 09:14'!startDrag: evt with: dragHandle	| itsOwner |	"Drag my target without removing it from its owner."	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - target position"InWorld".	 ((itsOwner _ target topRendererOrSelf owner) notNil and:			[itsOwner automaticViewing]) ifTrue:				[target openViewerForArgument]"Smalltalk at: #Q put: OrderedCollection new"! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'RAA 6/19/2000 13:10'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor localPt m trans morphToGrab myPos morphPos newT |	m _ aMorph.	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	(m owner isKindOf: DropShadowMorph) ifTrue:		[self grabMorph: m owner.		^ editor ifNotNil: [editor scriptEdited]].	m _ m aboutToBeGrabbedBy: self.	m == nil ifTrue: [^ self].	"Check if the morph will keep it's transform while grabbed"	myPos _ self position.	morphPos _ m position.	(m keepsTransform or: [formerOwner isNil])		ifTrue:[localPt _ myPos]		ifFalse:[localPt _ (m world globalPointToLocal: myPos) truncated].	(formerOwner == nil		or: [m keepsTransform			or: [(trans _ formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		m position: myPos + (morphPos - localPt).		morphToGrab _ m.		addedFlexAtGrab _ false.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ m addFlexShell transform: trans asMorphicTransform.		m position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.		addedFlexAtGrab _ true.	].	gridOn ifTrue: [morphToGrab position: (morphToGrab position grid: grid)].	self addMorphBack: morphToGrab.	editor ifNotNil: [editor scriptEdited].! !!HandMorph methodsFor: 'halos' stamp: 'RAA 6/19/2000 05:35'!popUpHaloFromClick: evt	"Pop up a halo on a suitable morph below the hand.	If there are multiple possible targets, and one of them already has a halo, then	choose the next inner target.  That is, unless we are already at the bottom, in which case	go topmost again."	| oldTargets targets anIndex w |	oldTargets _ OrderedCollection new.	w _ self worldUnderCursor.	w haloMorphs do: [:h | oldTargets addLast: h target. h delete].	targetOffset _ w globalPointToLocal: self position.	(argument _ self argumentOrNil) ifNil: [^ w addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument wantsHaloFromClick ifTrue: [argument addHalo: evt "sole target"]].	"Multiple possible targets, choose the outermost suitable one first, but if one already		has a halo, then choose the next farther in."	targets _ argument unlockedMorphsAt: targetOffset.	targets _ targets reversed select: [:aMorph | aMorph wantsHaloFromClick].	targets size = 0 ifTrue: [^ argument wantsHaloFromClick			ifTrue: [argument addHalo: evt "sole target"]			ifFalse: ["no halo recipient"]].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	anIndex _ targets findFirst: [:t | oldTargets includes: t].	anIndex = 0 ifTrue:		[^ self popUpNewHaloFromClick: evt targets: targets].	^ (targets atWrap: anIndex + 1) addHalo: evt from: (targets at: anIndex) "next inner target"! !!IndentingListItemMorph methodsFor: 'mouse events' stamp: 'RAA 8/5/1999 19:28'!handlesMouseDown: evt	"if user wants a menu, let the pane handle it"	^evt yellowButtonPressed not! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'RAA 8/3/1999 09:47'!highlight	complexContents highlightingColor ifNotNil: [self color: complexContents highlightingColor].	self changed.	! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'RAA 8/3/1999 09:46'!unhighlight	complexContents highlightingColor ifNotNil: [self color: Color black].	self changed.		! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/2/1999 16:48'!firstChild	^firstChild! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 11:30'!openPath: anArray	anArray isEmpty ifTrue: [^container setSelectedMorph: nil].	self withSiblingsDo: [:each | 		(each complexContents asString = anArray first or: [anArray first isNil]) ifTrue: [			each isExpanded ifFalse: [				each toggleExpandedState.				container installEventHandlerOn: each children.				container adjustSubmorphPositions.			].			each changed.			anArray size = 1 ifTrue: [				^container setSelectedMorph: each			].			each firstChild ifNil: [^container setSelectedMorph: nil].			^each firstChild openPath: anArray allButFirst.		].	].	^container setSelectedMorph: nil! !!IndentingListItemMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/16/2000 10:33'!toggleExpandedState 	| newChildren toDelete c |	isExpanded _ isExpanded not.	toDelete _ OrderedCollection new.	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode | aNode recursiveAddTo: toDelete].	].	container noteRemovalOfAll: toDelete.	(isExpanded and: [complexContents hasContents]) ifFalse: [		^self changed	].	(c _ complexContents contents) isEmpty ifTrue: [^self changed].	newChildren _ container 		addSubmorphsAfter: self 		fromCollection: c 		allowSorting: true.	firstChild _ newChildren first.	firstChild withSiblingsDo: [ :aNode |		aNode indentLevel: indentLevel + 1.	].! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'RAA 6/16/2000 13:26'!convertbosfcebbfgccpmcpbttloiairfidcuww0: varDict bosfcebbpmcpbttliairfidcuww0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'presenter' 'model' 'cursor' 'padding' 'backgroundMorph' 'turtleTrailsForm' 'turtlePen' 'lastTurtlePositions' 'isPartsBin' 'autoLineLayout' 'indicateCursor' 'resizeToFit' 'fileName' 'isStackLike' 'dataInstances' 'currentDataInstance' 'userFrameRectangle' 'wantsMouseOverHalos' 'worldState').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('fillColor2' 'gradientDirection' 'colorArray' 'colorDepth' 'openToDragNDrop').  Possibly store their info in another variable?"! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/19/2000 07:44'!beWorldForProject: aProject	self privateOwner: nil.	worldState _ WorldState new.	self addHand: HandMorph new.	self setProperty: #automaticPhraseExpansion toValue: true.	self setProperty: #optimumExtentFromAuthor toValue: Display extent.	self startSteppingSubmorphsOf: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/20/2000 12:42'!extent: aPoint	super extent: aPoint.	worldState ifNotNil: [		worldState viewBox ifNotNil: [			worldState canvas: nil.			worldState viewBox: bounds		].	].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/19/2000 08:22'!initForProject: aWorldState	worldState _ aWorldState.	bounds _ Display boundingBox.	color _ (Color r:0.937 g: 0.937 b: 0.937).	self addHand: HandMorph new.	self setProperty: #automaticPhraseExpansion toValue: true.	self setProperty: #optimumExtentFromAuthor toValue: Display extent.	model _ nil.! !!PhraseTileMorph methodsFor: 'object fileIn' stamp: 'RAA 6/16/2000 13:26'!convertbosfcebbochvimolprbu0: varDict bosfcebbochvimlprbu0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'resultType' 'brightenedOnEnter' 'userScriptSelector').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/19/2000 07:46'!storeOnServer	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	self setProperty: #optimumExtentFromAuthor toValue: world extent.	self hasBadNameForStoring ifTrue: [		^self inform: 'The name of this project may cause problems when stored in a file.Please fix it and try again.'	].	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #storeOnServer].	self storeOnServerWithProgressInfo.! !!Project methodsFor: 'file in/out' stamp: 'RAA 6/18/2000 12:58'!storeOnServerInnards        | servers pair newVersion resp newName local folder |        "Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."        "write locally"        self exportSegment.        (FileStream oldFileNamed: self name, '.pr') compressFile.        "Find out what version"        (servers _ self serverList) isEmpty                 ifTrue: [folder _ self findAFolderToStoreProjectIn ifNil: [^ self].                        servers _ Array with: folder.                        urlList _ Array with: folder realUrl, '/'.                        pair _ Array with: nil with: -1]                ifFalse: [pair _ self class mostRecent: self name onServer: servers first].        (newVersion _ self newVersion: pair) ifNil: [^ self].        newName _ self name, '|', newVersion, '.pr'.        local _ FileStream oldFileNamed: self name, '.pr.gz'.        resp _ servers first putFile: local named: newName retry: false.        resp == true ifFalse: [			self inform: 'the primary server of this project seems to be down (',							resp printString,')'. 			^ self		].        version _ newVersion.   "committed"        "Later, store with same name on secondary servers.  Still can be race conditions.  All machines will go through the server list in the same order."        "2 to: servers size do: [:aServer | aServer putFile: local named: newName]."        "Rename disk file to be the final name"        local reset.        local localName = newName                 ifFalse: [FileDirectory default rename: local localName toBe: newName]                ifTrue: [local close].! !!RecentMessageSet methodsFor: 'as yet unclassified' stamp: 'RAA 6/20/2000 13:28'!updateListsAndCodeIn: aWindow	| recentFromUtilities |	"RAA 20 june 2000 - a recent change to how messages were displayed in the list caused them not to match what was stored in Utilities. This caused the recent submissions to be continuously updated. The hack below fixed that problem"	self canDiscardEdits ifFalse: [^ self].	recentFromUtilities _ Utilities mostRecentlySubmittedMessage asString,' '.	(messageList first asString beginsWith: recentFromUtilities)		ifFalse:			[self reformulateList]		ifTrue:			[self updateCodePaneIfNeeded]! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/19/2000 16:26'!mouseEnter: evt	| hand tile |	self flag: #bob.		"needed renderedMorph due to transformations"	hand _ evt hand.	hand submorphs size = 1 ifFalse: [^self].	hand lastEvent redButtonPressed ifFalse: [^self].	tile _ hand firstSubmorph renderedMorph.	(self wantsDroppedMorph: tile event: evt) ifFalse: [^self].	(tile isKindOf: PhraseTileMorph) ifTrue: [tile brightenTiles]. 	handWithTile _ hand.	self startStepping! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/19/2000 16:23'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |	hand _ handWithTile ifNil: [self primaryHand].	(hand lastEvent redButtonPressed and: [(self hasInOwnerChain: hand) not]) ifTrue: [		hand submorphCount > 0 ifTrue: [			insertion _ hand firstSubmorph renderedMorph.			insHt _ insertion height.			self removeSpaces.			where _ self globalPointToLocal: hand position"insertion fullBounds topLeft".			i _ (ii _ self indexOfMorphAbove: where) min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]							ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty				ifTrue: [insertion]				ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (where y - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1).		]	] ifFalse: [		self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (ScriptingSystem unbrightColorFor: m color)			]		]	]! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 6/19/2000 16:23'!wantsDroppedMorph: aMorph event: evt	aMorph isTileLike ifFalse: [^false].	aMorph resultType == #command ifFalse: [^false].	self isTextuallyCoded ifTrue: [^false].	^true! !!ScriptEditorMorph methodsFor: 'object fileIn' stamp: 'RAA 6/16/2000 13:26'!convertbosfcebbochvimolpsftph0: varDict bosfcebbochvimlpsftph0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds' 'scriptName' 'firstTileRow' 'timeStamp' 'playerScripted' 'handWithTile').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('openToDragNDrop').  Possibly store their info in another variable?"! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'RAA 8/3/1999 09:44'!highlightSelection	selectedMorph ifNotNil: [selectedMorph highlight]! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'RAA 8/3/1999 09:44'!unhighlightSelection	selectedMorph ifNotNil: [selectedMorph unhighlight]! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'RAA 8/31/1999 08:36'!selection: item	"Called from outside to request setting a new selection.	Assumes scroller submorphs is exactly our list.	Note: MAY NOT work right if list includes repeated items"	| i |	item ifNil: [^self selectionIndex: 0].	i _ scroller submorphs findFirst: [:m | m complexContents == item].	i > 0 ifTrue: [^self selectionIndex: i].	i _ scroller submorphs findFirst: [:m | m withoutListWrapper = item withoutListWrapper].	self selectionIndex: i! !!SimpleHierarchicalListMorph methodsFor: 'updating' stamp: 'RAA 8/4/1999 17:39'!update: aSymbol 	aSymbol == getSelectionSelector ifTrue:		[self selection: self getCurrentSelectionItem.		^ self].	aSymbol == getListSelector ifTrue: 		[self list: self getList.		^ self].	((aSymbol isKindOf: Array) and: [aSymbol size > 0 and: [aSymbol first == #openPath]]) ifTrue: [		^(scroller submorphs at: 1 ifAbsent: [^self]) openPath: aSymbol allButFirst	].! !!SimpleHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/30/1999 10:19'!expandedForm	^expandedForm ifNil: [expandedForm _ (Form	extent: 10@10	depth: 8	fromArray: #( 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760 4278255873 16843009 16842752 4294902089 1229539657 33488896 4294967041 1229539585 4294901760 4294967295 21561855 4294901760 4294967295 4278321151 4294901760 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760)	offset: 0@0) asFormOfDepth: Display depth.	expandedForm replaceColor: Color white withColor: color.	expandedForm	].! !!SimpleHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/30/1999 10:19'!notExpandedForm	^notExpandedForm ifNil: [notExpandedForm _ (Form	extent: 10@10	depth: 8	fromArray: #( 4294967295 4294967295 4294901760 4294967041 4294967295 4294901760 4294967041 33554431 4294901760 4294967041 1224867839 4294901760 4294967041 1229521407 4294901760 4294967041 1229539585 4294901760 4294967041 1229521407 4294901760 4294967041 1224867839 4294901760 4294967041 33554431 4294901760 4294967041 4294967295 4294901760)	offset: 0@0) asFormOfDepth: Display depth.	notExpandedForm replaceColor: Color white withColor: color.	notExpandedForm]! !!SimpleHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/2/1999 12:42'!noteRemovalOfAll: aCollection	scroller removeAllMorphsIn: aCollection.	(aCollection includes: selectedMorph) ifTrue: [self setSelectedMorph: nil].! !!Stream methodsFor: 'alternate syntax' stamp: 'RAA 6/20/2000 12:52'!dialect	^#ST80		"in case a regular stream is used to print parse nodes"! !!Stream methodsFor: 'alternate syntax' stamp: 'RAA 6/20/2000 12:54'!withStyleFor: elementType do: aBlock	^aBlock value		"in case a regular stream is used to print parse nodes"">>(Compiler new compile: 'blah ^self' in: String notifying: nil ifFail: []) printString<<"! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'RAA 6/17/2000 11:27'!compareTallyIn: beforeFileName to: afterFileName	| answer s beforeDict a afterDict allKeys before after diff |	beforeDict _ Dictionary new.	s _ FileDirectory default fileNamed: beforeFileName.	[s atEnd] whileFalse: [		a _ Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict _ Dictionary new.	s _ FileDirectory default fileNamed: afterFileName.	[s atEnd] whileFalse: [		a _ Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer _ WriteStream on: String new.	allKeys _ (Set new addAll: beforeDict keys; addAll: afterDict keys; yourself) asSortedCollection.	allKeys do: [ :each |		before _ beforeDict at: each ifAbsent: [#(0 0 0)].		after _ afterDict at: each ifAbsent: [#(0 0 0)].		diff _ before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each,'  ',diff printString; cr.		].	].	StringHolder new contents: answer contents; openLabel: 'space diffs'.	! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'RAA 6/17/2000 11:08'!spaceTallyTo: aFileName	| answer s |	Smalltalk garbageCollect.	answer _ Smalltalk spaceTally.	(FileDirectory default fileExists: aFileName) ifTrue: [		FileDirectory default deleteFileNamed: aFileName	].	s _ FileDirectory default fileNamed: aFileName.	answer do: [ :each | s nextPutAll: each printString; cr].	s close! !!SystemWindow class methodsFor: 'top window' stamp: 'RAA 6/17/2000 12:28'!windowsIn: aWorld satisfying: windowBlock	| windows s |	windows _ OrderedCollection new.	aWorld ifNil: [^windows].	"opening MVC in Morphic - WOW!!"	aWorld submorphs do:		[:m |		((m isKindOf: SystemWindow) and: [windowBlock value: m])			ifTrue: [windows addLast: m]			ifFalse: [((m isKindOf: TransformationMorph) and: [m submorphs size = 1])					ifTrue: [s _ m firstSubmorph.							((s isKindOf: SystemWindow) and: [windowBlock value: s])								ifTrue: [windows addLast: s]]]].	^ windows! !