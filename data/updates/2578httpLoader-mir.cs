'From Squeak2.9alpha of 17 July 2000 [latest update: #2574] on 8 September 2000 at 7:28:56 pm'!"Change Set:		http-loader.csDate:			6 September 2000Author:			Michael RuegerThis change set adds access to parts of the netscape browser API (also supported in IE).When Squeak is running inside a web browser http puts and gets can be routed through the API. This way the browser's proxy settings, cookies and cache will be used.Part of this change set adds a small framework to load files and (signed) image segments through the plugin API if available. Several requests can be issued at the same time and are executed in the background. CAVEAT: IE 5 tries to do something *smart* about files ending with gz, so the default ending is set to 'sgz' (see CodeLoader>>fileExtension)."!Object subclass: #CodeLoader	instanceVariableNames: 'baseURL sourceFiles segments publicKey '	classVariableNames: 'DefaultBaseURL DefaultKey '	poolDictionaries: ''	category: 'Framework-Download'!!CodeLoader commentStamp: '<historical>' prior: 0!CodeLoader provides a simple facility for loading code from the network.Examples:	| loader |	loader _ CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!CodeLoader subclass: #CachingCodeLoader	instanceVariableNames: 'cacheDir '	classVariableNames: ''	poolDictionaries: ''	category: 'Framework-Download'!CodeLoader class	instanceVariableNames: ''!Object subclass: #HTTPLoader	instanceVariableNames: 'requests downloads '	classVariableNames: 'DefaultLoader MaxNrOfConnections '	poolDictionaries: ''	category: 'Framework-Download'!HTTPLoader class	instanceVariableNames: ''!Object subclass: #HTTPRequest	instanceVariableNames: 'semaphore url content loader process '	classVariableNames: ''	poolDictionaries: ''	category: 'Framework-Download'!HTTPRequest subclass: #CachedHTTPRequest	instanceVariableNames: 'cachedName '	classVariableNames: ''	poolDictionaries: ''	category: 'Framework-Download'!HTTPRequest class	instanceVariableNames: ''!CodeLoader subclass: #PluginCodeLoader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Framework-Download'!!PluginCodeLoader commentStamp: '<historical>' prior: 0!PluginCodeLoader provides a simple facility for loading code from the network with integrated code signing.Examples:	| loader |	loader _ PluginCodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!HTTPRequest subclass: #PluginHTTPRequest	instanceVariableNames: 'fileStream '	classVariableNames: ''	poolDictionaries: ''	category: 'Framework-Download'!!PluginHTTPRequest commentStamp: '<historical>' prior: 0!HTTPBrowserRequest attempts to fetch the contents through a Webbrowser. This works transparently if Squeak is not running in the browser.!!Object methodsFor: 'logging' stamp: 'mir 8/10/1999 16:05'!flag: aFlagString log: aString	Transcript show: aString; cr	! !!Object methodsFor: 'logging' stamp: 'mir 8/10/1999 16:05'!flag: aFlagString streamLog: aBlockWithStreamArgument	! !!Object methodsFor: 'logging' stamp: 'mir 8/10/1999 18:05'!log: aString	Transcript show: aString; cr	! !!CodeLoader methodsFor: 'accessing' stamp: 'ar 12/13/1999 18:19'!baseURL	^baseURL! !!CodeLoader methodsFor: 'accessing' stamp: 'ar 12/13/1999 18:19'!baseURL: aString	baseURL _ aString.! !!CodeLoader methodsFor: 'accessing' stamp: 'ar 12/22/1999 15:07'!publicKey	^publicKey! !!CodeLoader methodsFor: 'accessing' stamp: 'ar 12/22/1999 15:07'!publicKey: aPublicKey	publicKey _ aPublicKey! !!CodeLoader methodsFor: 'loading' stamp: 'mir 1/20/2000 13:36'!loadSegments: anArray	"Load all the source files in the given array."	| loader request |	loader _ HTTPLoader default.	segments _ anArray collect:[:name|		request _ self createRequestFor: name in: loader.		name->request].! !!CodeLoader methodsFor: 'loading' stamp: 'ar 12/14/1999 14:40'!loadSourceFiles: anArray	"Load all the source files in the given array."	| loader request |	loader _ HTTPLoader default.	sourceFiles _ anArray collect:[:name|		request _ self createRequestFor: name in: loader.		request].! !!CodeLoader methodsFor: 'installing' stamp: 'mir 2/23/2000 12:58'!installSegment: reqEntry	"Install the previously loaded segment"	| secured contentStream contents |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	secured _ self positionedToSecuredContentsOf: contentStream.	secured		ifFalse: [			(contentStream respondsTo: #close) ifTrue:[contentStream close].			^self error:'Insecure content encountered: ', reqEntry key printString].	contents _ contentStream upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	^(RWBinaryOrTextStream with: contents) reset fileInObjectAndCode install.! !!CodeLoader methodsFor: 'installing' stamp: 'mir 1/20/2000 13:37'!installSegments	"Install the previously loaded segments"	segments == nil ifTrue:[^self].	segments do:[:req| self installSegment: req].	segments _ nil.! !!CodeLoader methodsFor: 'installing' stamp: 'mir 2/23/2000 12:59'!installSourceFile: aStream	"Install the previously loaded source file"	| contents secured |	aStream ifNil:[^self error:'No content to install'].	secured _ self positionedToSecuredContentsOf: aStream.	secured		ifFalse: [			(aStream respondsTo: #close) ifTrue:[aStream close].			^self error:'Insecure content encountered'].	contents _ aStream upToEnd unzipped.	(aStream respondsTo: #close) ifTrue:[aStream close].	^(RWBinaryOrTextStream with: contents) reset fileIn! !!CodeLoader methodsFor: 'installing' stamp: 'ar 12/22/1999 15:02'!installSourceFiles	"Install the previously loaded source files"	sourceFiles == nil ifTrue:[^self].	sourceFiles do:[:req| self installSourceFile: req contentStream].	sourceFiles _ nil.! !!CodeLoader methodsFor: 'private' stamp: 'mir 1/10/2000 18:56'!createRequestFor: name in: aLoader	"Create a URL request for the given string, which can be cached locally."	| request |	request _ self httpRequestClass for: self baseURL , name in: aLoader.	aLoader addRequest: request. "fetch from URL"	^request! !!CodeLoader methodsFor: 'private' stamp: 'mir 12/22/1999 14:13'!httpRequestClass	^HTTPRequest! !!CodeLoader methodsFor: 'private' stamp: 'mir 2/23/2000 12:57'!positionedToSecuredContentsOf: aStream	"Private - return the 'secured' part of the given stream, e.g., the actual contents without the verification checksum. If the verification fails return nil (since there is no secured contents)."	| hash signature part1 part2 dsa okay |	"No key, no security..."	publicKey == nil		ifTrue: [^true].	aStream position: 0.	aStream binary.	part1 _ aStream nextInto: (LargePositiveInteger basicNew: 20).	part2 _ aStream nextInto: (LargePositiveInteger basicNew: 20).	signature _ Array with: part1 with: part2.	hash _ SecureHashAlgorithm new hashStream: aStream.	dsa _ DigitalSignatureAlgorithm new.	okay _ dsa verifySignature: signature ofMessageHash: hash publicKey: publicKey.	okay		ifFalse: [^false].	aStream ascii.	aStream position: 40.	^true! !!CodeLoader methodsFor: 'initialize-release' stamp: 'mir 1/11/2000 13:47'!initialize	publicKey _ DefaultKey.	baseURL _ self class defaultBaseURL! !!CachingCodeLoader methodsFor: 'accessing' stamp: 'mir 12/22/1999 14:10'!cacheDir	^cacheDir! !!CachingCodeLoader methodsFor: 'accessing' stamp: 'mir 12/22/1999 14:10'!cacheDir: aString	cacheDir _ aString.! !!CachingCodeLoader methodsFor: 'accessing' stamp: 'mir 12/22/1999 14:10'!localCache: stringArray	| fd |	fd _ FileDirectory default.	stringArray do:[:part|		(fd directoryNames includes: part) 			ifFalse:[fd createDirectory: part].		fd _ fd directoryNamed: part].	self cacheDir: (fd pathName copyWith: fd pathNameDelimiter).! !!CachingCodeLoader methodsFor: 'accessing' stamp: 'mir 12/22/1999 14:10'!localCacheDir: aString	self cacheDir:		(FileDirectory default pathName,		FileDirectory slash,		aString,		FileDirectory slash)! !!CachingCodeLoader methodsFor: 'private' stamp: 'mir 12/22/1999 14:11'!createRequestFor: name in: aLoader	| request |	request _ super createRequestFor: name in: aLoader.	request cachedName: cacheDir, name.	^request! !!CachingCodeLoader methodsFor: 'private' stamp: 'mir 12/22/1999 14:12'!httpRequestClass	^CachedHTTPRequest! !!CodeLoader class methodsFor: 'instance creation' stamp: 'ar 12/22/1999 15:08'!new	^super new initialize! !!CodeLoader class methodsFor: 'accessing' stamp: 'mir 1/11/2000 13:45'!defaultBaseURL	^DefaultBaseURL ifNil: ['']! !!CodeLoader class methodsFor: 'accessing' stamp: 'mir 1/11/2000 13:45'!defaultBaseURL: aURLString	DefaultBaseURL _ aURLString! !!CodeLoader class methodsFor: 'accessing' stamp: 'ar 12/22/1999 15:08'!defaultKey	"Return the default key used for verifying signatures of loaded code"	^DefaultKey! !!CodeLoader class methodsFor: 'accessing' stamp: 'mir 1/10/2000 18:16'!defaultKey: aPublicKey	"Store the default key used for verifying signatures of loaded code"	DefaultKey _ aPublicKey	"CodeLoader defaultKey: DOLPublicKey"	"CodeLoader defaultKey: (DigitalSignatureAlgorithm testKeySet at: 2)"! !!CodeLoader class methodsFor: 'accessing' stamp: 'mir 9/6/2000 15:04'!fileExtension	^'segz'! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 9/6/2000 15:03'!compressFileNamed: aFileName	self compressFileNamed: aFileName in: FileDirectory default! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 9/6/2000 15:03'!compressFileNamed: aFileName in: aDirectory	"Compress the currently selected file"	| zipped buffer unzipped zipFileName |	unzipped _ aDirectory readOnlyFileNamed: (aDirectory fullNameFor: aFileName).	unzipped binary.	zipFileName _ aFileName copyUpToLast: $. .	zipped _ aDirectory newFileNamed: (zipFileName, FileDirectory dot, self fileExtension).	zipped binary.	zipped _ GZipWriteStream on: zipped.	buffer _ ByteArray new: 50000.	'Compressing ', zipFileName displayProgressAt: Sensor cursorPoint		from: 0 to: unzipped size		during:[:bar|			[unzipped atEnd] whileFalse:[				bar value: unzipped position.				zipped nextPutAll: (unzipped nextInto: buffer)].			zipped close.			unzipped close].! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 16:22'!exportCategories: catList to: aFileName	"CodeLoader exportCategories: #( 'Game-Animation' 'Game-Framework' ) to: 'Game-Framework'"	| list classList |	classList _ OrderedCollection new.	catList do: [:catName |		list _ SystemOrganization listAtCategoryNamed: catName asSymbol.		list do: [:nm | classList add: (Smalltalk at: nm); add: (Smalltalk at: nm) class]].	self exportCodeSegment: aFileName classes: classList keepSource: true! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 20:53'!exportCategoryNamed: catName	"CodeLoader exportCategoryNamed: 'OceanicPanic' "	| list |	list _ SystemOrganization listAtCategoryNamed: catName asSymbol.	self exportClassesNamed: list to: catName! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 20:53'!exportClassesNamed: classNameList to: aFileName	| classList |	classList _ OrderedCollection new.	classNameList do: [:nm | classList add: (Smalltalk at: nm); add: (Smalltalk at: nm) class].	self exportCodeSegment: aFileName classes: classList keepSource: true! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/27/2000 17:24'!exportCodeSegment: exportName classes: aClassList keepSource: keepSources	"Code for writing out a specific category of classes as an external image segment.  Perhaps this should be a method."	| is oldMethods newMethods m oldCodeString argsAndTemps classList symbolHolder |	keepSources		ifTrue: [			self confirm: 'We are going to abandon sources.Quit without saving after this has run.' orCancel: [^self]].	classList _ aClassList asArray.	"Strong pointers to symbols"	symbolHolder := Symbol allInstances.	oldMethods _ OrderedCollection new: classList size * 150.	newMethods _ OrderedCollection new: classList size * 150.	keepSources		ifTrue: [			classList do: [:cl |				cl selectors do:					[:selector |					m _ cl compiledMethodAt: selector.					m fileIndex > 0 ifTrue:						[oldCodeString _ cl sourceCodeAt: selector.						argsAndTemps _ (cl compilerClass new							parse: oldCodeString in: cl notifying: nil) tempNames.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	oldMethods _ newMethods _ m _ oldCodeString _ argsAndTemps _ nil.	Smalltalk garbageCollect.	is _ ImageSegment new copyFromRootsForExport: classList.	"Classes and MetaClasses"	is writeForExport: exportName."is inspect."! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 12/22/1999 18:09'!loadCodeSegment: fileName	"CodeLoader loadCodeSegment: 'OceanicPanic.extSeg' "	(FileStream oldFileNamed: fileName) fileInObjectAndCode! !!CodeLoader class methodsFor: 'utilities' stamp: 'ar 12/22/1999 15:09'!signFile: fileName renameAs: destFile key: privateKey dsa: dsa	"Sign the given file using the private key."	| in hash sig out |	in _ FileStream readOnlyFileNamed: fileName.	in binary.	hash _ SecureHashAlgorithm new hashStream: in.	sig _ dsa computeSignatureForMessageHash: hash privateKey: privateKey.	out _ FileStream newFileNamed: destFile.	out binary.	out nextPutAll: sig first; nextPutAll: sig last.	in position: 0.	[in atEnd] whileFalse:[out nextPutAll: (in next: 4096)].	in close.	out close.! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 2/14/2000 16:47'!signFiles: fileNames in: dirName key: privateKey	"Sign the files in the current directory and put them into a folder signed."	|  newNames oldNames |	oldNames _ fileNames collect:[:fileName | dirName , FileDirectory slash, fileName].	newNames _ fileNames collect:[:fileName | dirName , FileDirectory slash, 'signed', FileDirectory slash, fileName].	CodeLoader		signFilesFrom: oldNames		to: newNames		key: privateKey! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 18:49'!signFiles: fileNames key: privateKey	"Sign the files in the current directory and put them into a folder signed."	|  newNames |	newNames _ fileNames collect:[:fileName | 'signed', FileDirectory slash, fileName].	CodeLoader		signFilesFrom: fileNames		to: newNames		key: privateKey! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 11:14'!signFilesFrom: sourceNames to: destNames key: privateKey	"Sign all the given files using the private key.	This will add an 's' to the extension of the file."	"| fd oldNames newNames |	fd _ FileDirectory default directoryNamed:'unsigned'.	oldNames _ fd fileNames.	newNames _ oldNames collect:[:name| 'signed', FileDirectory slash, name].	oldNames _ oldNames collect:[:name| 'unsigned', FileDirectory slash, name].	CodeLoader		signFilesFrom: oldNames		to: newNames		key: DOLPrivateKey."	| dsa |	dsa _ DigitalSignatureAlgorithm new.	dsa initRandom: (dsa randomBitsFromSoundInput: 512).	'Signing files...' displayProgressAt: Sensor cursorPoint		from: 1 to: sourceNames size during:[:bar|			1 to: sourceNames size do:[:i|				bar value: i.				self signFile: (sourceNames at: i) renameAs: (destNames at: i) key: privateKey dsa: dsa]].! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 2/23/2000 12:57'!verifySignedFileNamed: aFileName	"CodeLoader verifySignedFileNamed: 'signed\dummy1.dsq' "	| secured signedFileStream |	signedFileStream _ FileStream fileNamed: aFileName.	secured _ CodeLoader new positionedToSecuredContentsOf: signedFileStream.	signedFileStream close.	Transcript show: aFileName , ' verified: '; show: secured printString; cr.! !!FileStream class methodsFor: 'browser requests' stamp: 'ar 3/2/2000 17:48'!post: data url: url ifError: errorBlock	^self concreteStream new post: data url: url ifError: errorBlock! !!FileStream class methodsFor: 'browser requests'!requestURLStream: url	"FileStream requestURLStream:'http://isgwww.cs.uni-magdeburg.de/~raab'"	^self concreteStream new requestURLStream: url! !!FileStream class methodsFor: 'browser requests'!requestURLStream: url ifError: errorBlock	"FileStream requestURLStream:'http://isgwww.cs.uni-magdeburg.de/~raab'"	^self concreteStream new requestURLStream: url ifError: errorBlock! !!HTTPLoader methodsFor: 'private' stamp: 'mir 1/16/2000 16:11'!addRequest: aHTTPRequest	requests nextPut: aHTTPRequest.	self startDownload! !!HTTPLoader methodsFor: 'private' stamp: 'mir 10/4/1999 18:31'!maxNrOfConnections	^MaxNrOfConnections! !!HTTPLoader methodsFor: 'private' stamp: 'mir 10/7/1999 18:16'!nextRequest	^requests next! !!HTTPLoader methodsFor: 'private' stamp: 'mir 10/7/1999 18:37'!removeProcess: downloadProcess.	downloads remove: downloadProcess ifAbsent: []! !!HTTPLoader methodsFor: 'private' stamp: 'mir 10/7/1999 17:02'!removeRequest: request	requests remove: request! !!HTTPLoader methodsFor: 'private' stamp: 'mir 1/11/2000 15:23'!startDownload	| newDownloadProcess |	(downloads size < self maxNrOfConnections 		and: [requests size > 0]) ifTrue: [			newDownloadProcess _ [				self flag: #httpLoader log: 'Starting download'.				self nextRequest startRetrieval.				self flag: #httpLoader log: 'Download done'.				downloads remove: Processor activeProcess.				self startDownload] newProcess.			downloads add: newDownloadProcess.			newDownloadProcess resume]! !!HTTPLoader methodsFor: 'requests' stamp: 'mir 1/15/2000 22:59'!abort	| oldRequests |	"Abort all requests"	oldRequests _ requests.	requests _ SharedQueue new.	[oldRequests isEmpty] whileFalse: [		oldRequests next signalAbort].	downloads do: [:each | each ifNotNil: [each terminate]].	downloads _ OrderedCollection new! !!HTTPLoader methodsFor: 'requests' stamp: 'mir 12/22/1999 13:53'!retrieveContentsFor: url	| request |	request _ PluginHTTPRequest for: url in: self.	self addRequest: request.	^request contents! !!HTTPLoader methodsFor: 'requests' stamp: 'mir 1/16/2000 16:35'!retrieveObjectsFor: aURL	"Load a remote image segment and extract the root objects.	Check if the remote file is a zip archive."	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.extSeg' 		asUrl loadRemoteObjects" 	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.zip' 		asUrl loadRemoteObjects" 	| stream info data | 	data _ self retrieveContentsFor: aURL.	(data isKindOf: String)		ifTrue: [^self error: data]		ifFalse: [data _ data content].	(data beginsWith: 'error')		ifTrue: [^self error: data].	data _ data unzipped.	stream _ RWBinaryOrTextStream on: data.	stream reset.	info _ stream fileInObjectAndCode.	stream close.	^info originalRoots! !!HTTPLoader methodsFor: 'initialize/release' stamp: 'mir 10/7/1999 18:14'!initialize	requests _ SharedQueue new.	downloads _ OrderedCollection new! !!HTTPLoader methodsFor: 'initialize/release' stamp: 'mir 10/7/1999 16:59'!release	self abort.	downloads _ nil.	requests _ nil! !!HTTPLoader class methodsFor: 'class initialization' stamp: 'mir 10/7/1999 20:08'!initialize	"HTTPLoader initialize"	MaxNrOfConnections _ 2.	DefaultLoader ifNotNil: [		DefaultLoader release.		DefaultLoader _ nil]! !!HTTPLoader class methodsFor: 'instance creation' stamp: 'mir 10/4/1999 18:20'!new	^super new initialize! !!HTTPLoader class methodsFor: 'accessing' stamp: 'mir 10/4/1999 18:41'!default	DefaultLoader ifNil: [		DefaultLoader _ HTTPLoader new].	^DefaultLoader! !!HTTPRequest methodsFor: 'accessing' stamp: 'mir 10/4/1999 18:26'!content: retrievedContent	content _ retrievedContent.	semaphore signal! !!HTTPRequest methodsFor: 'accessing' stamp: 'ar 12/21/1999 14:23'!contentStream	"Return a stream on the content of a previously completed HTTP request"	semaphore wait.	^content contentStream! !!HTTPRequest methodsFor: 'accessing' stamp: 'mir 10/4/1999 18:25'!contents	semaphore wait.	^content! !!HTTPRequest methodsFor: 'accessing' stamp: 'mir 10/7/1999 16:57'!process: aProcess	process _ aProcess! !!HTTPRequest methodsFor: 'accessing' stamp: 'mir 1/15/2000 22:55'!signalAbort	loader removeProcess: process.	self content: 'Retrieval aborted'.	process ifNotNil: [process terminate]! !!HTTPRequest methodsFor: 'accessing' stamp: 'mir 1/10/2000 18:33'!startRetrieval	self content: url asUrl retrieveContents! !!HTTPRequest methodsFor: 'accessing' stamp: 'mir 1/20/2000 13:33'!url	^url! !!HTTPRequest methodsFor: 'initialize' stamp: 'mir 10/7/1999 17:00'!for: aUrl in: aLoader	url _ aUrl.	loader _ aLoader.	semaphore _ Semaphore new.! !!CachedHTTPRequest methodsFor: 'accessing' stamp: 'ar 12/14/1999 14:53'!cachedName	^cachedName! !!CachedHTTPRequest methodsFor: 'accessing' stamp: 'ar 12/14/1999 14:53'!cachedName: aString	cachedName _ aString.! !!CachedHTTPRequest methodsFor: 'accessing' stamp: 'ar 12/14/1999 15:00'!startRetrieval	| fileStream |	cachedName == nil ifTrue:[^super startRetrieval].	(FileDirectory default fileExists: cachedName) ifTrue:[		fileStream _ FileStream concreteStream new open: cachedName forWrite: false.		fileStream == nil ifFalse:[^self content: 			(MIMEDocument 				contentType: 'text/plain' 				content: fileStream contentsOfEntireFile)].		FileDirectory default deleteFileNamed: cachedName ifAbsent:[]].	super startRetrieval. "fetch from URL"	"and cache in file dir"	fileStream _ FileStream concreteStream new open: cachedName forWrite: true.	fileStream == nil ifFalse:[		fileStream nextPutAll: (content content).		fileStream close].! !!HTTPRequest class methodsFor: 'instance creation' stamp: 'mir 10/7/1999 16:59'!for: aUrl in: aLoader	^self new for: aUrl in: aLoader! !!HttpUrl methodsFor: 'downloading' stamp: 'mir 10/13/1999 19:41'!loadRemoteObjects	"Load a remote image segment and extract the root objects.	Check if the remote file is a zip archive."	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.extSeg' 		asUrl loadRemoteObjects" 	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.zip' 		asUrl loadRemoteObjects" 	| stream info data extension | 	data _ self retrieveContents content.	extension _ (FileDirectory extensionFor: self path last) asLowercase.	(#('zip' 'gzip') includes: extension)		ifTrue: [data _ (GZipReadStream on: data) upToEnd]."	stream _ StreamWrapper streamOver: (ReadStream on: data)."	stream _ RWBinaryOrTextStream on: data.	stream reset.	info _ stream fileInObjectAndCode.	stream close.	^info arrayOfRoots! !!PluginCodeLoader methodsFor: 'private' stamp: 'mir 1/6/2000 21:15'!httpRequestClass	^PluginHTTPRequest! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'mir 1/20/2000 13:33'!contentStream	semaphore wait.	fileStream == nil ifFalse:[^fileStream].	^content == nil		ifTrue:[nil]		ifFalse:[			(content isKindOf: String)				ifTrue: [self error: 'Error loading ' , self url printString]				ifFalse: [content contentStream]]! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'mir 2/23/2000 12:41'!contents	| |	semaphore wait.	(content isNil and:[fileStream notNil]) ifTrue:["		pos _ fileStream position."		fileStream position: 0.		content _ MIMEDocument content: fileStream upToEnd.		(fileStream respondsTo: #close) ifTrue:[fileStream close].	].	^content! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'ar 12/21/1999 16:36'!maxAttempts	"Return the number of attempts to retry before giving up"	^3! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'mir 2/23/2000 12:40'!signalAbort	fileStream ifNotNil: [		(fileStream respondsTo: #close) ifTrue:[fileStream close]].	fileStream _ nil.	super signalAbort.! !!PluginHTTPRequest methodsFor: 'accessing' stamp: 'mir 1/11/2000 11:36'!startRetrieval	| attempts |	attempts _ self maxAttempts.	"Note: Only the first request may fail due to not running in a browser"	url first = $/		ifTrue: [url _ url copyFrom: 2 to: url size].	fileStream _ FileStream requestURLStream: url ifError:[^super startRetrieval].	[fileStream == nil] whileTrue:[		attempts _ attempts - 1.		attempts = 0 ifTrue:[^self content:'Error downloading file'].		fileStream _ FileStream requestURLStream: url].	semaphore signal.! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 1/11/2000 10:44'!defaultBrowserReadyWait	^5000! !!StandardFileStream methodsFor: 'browser requests' stamp: 'ar 3/2/2000 17:47'!post: data url: url ifError: errorBlock	"Post data to the given URL. The returned file stream contains the reply of the server.	If Squeak is not running in a browser evaluate errorBlock"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema _ Semaphore new.	index _ Smalltalk registerExternalObject: sema.	request _ self primURLPost: url data: data semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result _ self primURLRequestState: request.		result == nil] whileTrue.		result ifTrue:[fileID _ self primURLRequestFileHandle: request].		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name _ url.	rwmode _ false.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 1/11/2000 10:38'!primBrowserReady	<primitive:'primitivePluginBrowserReady'>	self primitiveFailed! !!StandardFileStream methodsFor: 'browser requests' stamp: 'ar 3/2/2000 17:45'!primURLPost: url data: contents semaIndex: index	"Post the data (url might be 'mailto:' etc)"	<primitive:'primitivePluginPostURL'>	^nil ! !!StandardFileStream methodsFor: 'browser requests'!primURLRequest: url semaIndex: index	<primitive:'primitivePluginRequestURLStream'>	^nil! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 2/29/2000 11:22'!primURLRequest: url target: target semaIndex: index	"target - String (frame, also '_top', '_parent' etc)"	<primitive:'primitivePluginRequestURL'>	^nil ! !!StandardFileStream methodsFor: 'browser requests'!primURLRequestDestroy: request	<primitive:'primitivePluginDestroyRequest'>	^nil! !!StandardFileStream methodsFor: 'browser requests'!primURLRequestFileHandle: request	<primitive: 'primitivePluginRequestFileHandle'>	^nil! !!StandardFileStream methodsFor: 'browser requests'!primURLRequestState: request	<primitive:'primitivePluginRequestState'>	^false! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 2/29/2000 11:22'!requestURL: url target: target	^self requestURL: url target: target ifError: [nil]! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 2/29/2000 11:24'!requestURL: url target: target ifError: errorBlock	"Request to go to the target for the given URL.	If Squeak is not running in a browser evaluate errorBlock"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema _ Semaphore new.	index _ Smalltalk registerExternalObject: sema.	request _ self primURLRequest: url target: target semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result _ self primURLRequestState: request.		result == nil] whileTrue.		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name _ url.	rwmode _ false.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'browser requests'!requestURLStream: url	"FileStream requestURLStream:'http://www.squeak.org'"	^self requestURLStream: url ifError:[nil]! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 1/11/2000 10:43'!requestURLStream: url ifError: errorBlock	"Request a FileStream for the given URL.	If Squeak is not running in a browser evaluate errorBlock"	"FileStream requestURLStream:'http://www.squeak.org'"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema _ Semaphore new.	index _ Smalltalk registerExternalObject: sema.	request _ self primURLRequest: url semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result _ self primURLRequestState: request.		result == nil] whileTrue.		result ifTrue:[fileID _ self primURLRequestFileHandle: request].		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name _ url.	rwmode _ false.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'browser requests' stamp: 'mir 1/11/2000 10:55'!waitBrowserReadyFor: timeout ifFail: errorBlock	| startTime delay |	self primBrowserReady		ifTrue: [^true].	startTime _ Time millisecondClockValue.	delay _ Delay forMilliseconds: 100.	[(Time millisecondsSince: startTime) < timeout]		whileTrue: [			delay wait.			self primBrowserReady				ifTrue: [^true]].	^errorBlock value! !!StandardFileStream class methodsFor: 'browser requests' stamp: 'mir 9/7/2000 16:11'!isRunningAsBrowserPlugin	(self privateCheckForBrowserPrimitives ~~ false)		ifFalse: [^false].	self new waitBrowserReadyFor: 1000 ifFail: [^false].	^true! !!StandardFileStream class methodsFor: 'browser requests' stamp: 'mir 9/7/2000 16:08'!privateCheckForBrowserPrimitives	<primitive:'primitivePluginBrowserReady'>	^false! !!String methodsFor: 'converting' stamp: 'mir 12/22/1999 13:58'!unzipped	| magic1 magic2 |	magic1 _ (self at: 1) asInteger.	magic2 _ (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !HTTPLoader initialize!