'From Squeak 2.3 of January 14, 1999 on 10 February 1999 at 8:08:13 am'!"Change Set:		clonerfix3/8Febr326pmDate:			9 February 1999Author:			Tim RowledgeA bunch of changes to SystemTracer to do two things:1) the new version of #sizeInWordsOf: & formatOfCls: fix the tracing of Contexts so they are correctly sized. The hack in #sizeInWordsOf: is shameful. Shoot me now, before I sin again.2) by adding the instvar 'replacementClasses' and using the other methods (also from NCM work) it is easy to replace one object with another during cloning - sort of like a one way become. Implement your replacement class and test it, then use the cloner to put it in every place where the replacee is as well as leaving it in original places. The replacee disappears completely. This is a bit more complex than just writing out objects in a different form as it need the oop of both the new and old objects to be mapped."!Object subclass: #SystemTracer	instanceVariableNames: 'oopMap map file writeDict maxOop specialObjects initialProcess hashGenerator imageHeaderSize cleaningUp compactClasses replacementClasses '	classVariableNames: 'Clamped NewNil UnassignedOop '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!SystemTracer commentStamp: 'di 2/9/1999 16:31' prior: 0!NOTE:  The SystemTracer was invented by Ted Kaehler.  It has gone through many variations.  I have simplified it and adapted it to work with Squeak's limited Object hashing.  It has written runnable Mac images on a Mac.  Some changes may be needed for it to produce runnable images on a bigEndian machine.  -- Dan I. 9/29/97The SystemTracer runs through the system tracing every accessible object, and writing a copy of each object onto a disk image. It does this carefully enough that the resulting clone can be started up and run, just like a snapshot.  Great care must also be taken that the tracer never sees (due to clamping) any of the structures created dynamically while writing the clone.  If this happens an infinite recursion can result.	The tracer has built-in support for clamping unwanted (or unneeded) objects out of the system. It also allows fundamental changes to, eg, object header format, compiledMethod format, number formats, etc.  The current version is fairly simple, as it just copies what is already in the system. This version does, however, reassign object hashes in order to illustrate how one must remap all the hashed structures accordingly.Squeak currently only has 12 bits of object hash.  A normal dictionary, used to map from old oop to new oop, would bog down in a system of, say, 50k objects.  This tracer has a special structure that is optimized for this purpose.  See the comment in initOopMap.  If we ever extend the object hash, this structure could be replaced by a simple IdentityDictionary.When you first start up the cloned image, you will probably get a "cannotReturn" error, a vestige of the old tracing process.  This can simply be closed (or maybe you can figure out how to fix the tracers so it doens't happen ;-).  Further comment from Tim Rowledge's message about replacing classes...The cloner already does a great job of allowing one to leave out classes,individual instances, change representation of particular objects etc.However, when doing the ncm stuff I needed a way to build the new class inthe image and test it before cloning. Thus at clone-time I needed toa) replace each compiled method with a new compiled methodb) replace the class CompiledMethod with  NewCompiledMethodc) get rid of the now-redundant CompiledMethod classDoing a) is easy, that is the stock in trade of the cloner.Doing b) & c) is a little more complicated since I wanted to catch everyreference to CM and write it out as a reference to NCM and also  needed to'clamp' CM.To do this we need to make sure that when a ref to CM is found we not onlywrite out the replacement reference to NCM instead, but that we log both CMand NCM as having been dealt with by putting _both_ into the oopmap withthe same new-oop. Thus when we find a reference to NCM (for example whenthe subclass list of its superclass is scanned) it will already have been'dealt with'. The system also has to cope with arbitrary order of findingeither of the involved objects; you cannot guarantee that one will bespotted before the other and rely on that.Take a look at SystemTracer>replace:withNew:class:length:trace:write: tosee the diferences from the normal #new:class:length:trace:write:. One alsoneeds to check Associations in order to 'correct' the value instvar if itrefers to a replaced class.!!SystemTracer methodsFor: 'initialization' stamp: 'TPR 2/8/1999 15:12'!initDict	writeDict _ Dictionary new: 256.	Smalltalk allClassesDo: 		[:class | 		class isBits 			ifTrue: 			[writeDict at: class put: (class isBytes ifTrue: [#writeBytes:]												ifFalse: [#writeWords:])]			ifFalse:			[writeDict at: class put: #writePointers:.			(class inheritsFrom: Set) | (class == Set) ifTrue:				[writeDict at: class put: #writeSet:].			(class inheritsFrom: IdentitySet) | (class == IdentitySet) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: MethodDictionary) | (class == MethodDictionary) ifTrue:				[writeDict at: class put: #writeMethodDictionary:]].				]."check for Associations of replaced classes"	writeDict at: Association put: #writeAssociation:.	Smalltalk allBehaviorsDo: 		[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: PseudoContext class put: #writeBehavior:.	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.! !!SystemTracer methodsFor: 'mapping oops' stamp: 'TPR 9/11/1998 14:45'!hasReplacement: obj	"See if obj will be replaced in the new system."	obj class == SmallInteger ifTrue: [^ false].	^ replacementClasses includes: obj ! !!SystemTracer methodsFor: 'mapping oops' stamp: 'TPR 9/11/1998 14:42'!initOopMap	"oopMap is an array 4096 long indexed by basicHash.	Each element a subarray of object/newOop/hash triplets.	The subarrrays must be linearly searched.	Access to an object causes it to be promoted in the subarray,		so that frequently accessed objects can be found quickly."	oopMap _ (1 to: 4096) collect: [:i | Array new].	"replacementClasses is a simple Dictionary to contain pairs of classes (well, globals should work actually) where the key is a class being replaced and the value is the replacement class"	replacementClasses _ Dictionary new! !!SystemTracer methodsFor: 'mapping oops' stamp: 'TPR 9/11/1998 14:48'!replaceClass: original by: obj	"setup the replacement class"	replacementClasses at: original put: obj ! !!SystemTracer methodsFor: 'mapping oops' stamp: 'TPR 9/11/1998 14:47'!replacementFor: obj	"return the replacement class, if there is one"	obj class == SmallInteger ifTrue: [^ nil].	^ replacementClasses at: obj ifAbsent:[nil]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 2/10/1999 08:08'!replace: original withNew: obj class: class length: length trace: traceBlock write: writeBlock	| oop objpos headers type hash |	"We assign file space for an object, replacing original.	Only does something when original has not been assigned a new oop yet.  	Length is the instance vars and variable portion in longs.	Class is not included in length.	Special objects come here for an oop, and do no tracing or writing.	To trace and write their fields later, do NOT use this method."  	oop_ self mapAt: original.	oop = UnassignedOop ifFalse:		["Original has already been assigned a new oop or clamped."		^ self].	oop_ self mapAt: obj.	oop = UnassignedOop ifFalse:		["replacement has already been assigned a new oop or clamped."		^ self].	"Write header and remember new oop in map. Headers must be derived from new object, since its class and format affect the values."	hash _ (hashGenerator next * 16rFFF asFloat) asInteger.	headers _ self headersFor: obj withHash: hash.	file position: maxOop + imageHeaderSize.	headers do: [:h | self write4Bytes: h].	maxOop _ maxOop + (headers size-1*4).		"New oop points at header word"	"log thenew object as both the original and itself"	self mapAt: obj put: maxOop with: hash.	self mapAt: original put: maxOop with: hash.	objpos _ maxOop + imageHeaderSize.		"file position"length > 20 ifTrue: [maxOop printString, ' ' displayAt: 0@0].	"Write blank data, advancing to next object position"	maxOop _ maxOop + (length+1*4).	"ready for next object"	file nextPutAll: (ByteArray new: length*4 withAll: 0).	"There is a good chance that we might need to substitute the class of the original object with the class of 'obj', so make sure both classes are properly traced"	traceBlock notNil ifTrue: [self trace: original class. self trace: class.  traceBlock value].	(headers size > 1 and: [(headers at: headers size-1) < 0])		ifTrue: ["rewrite class word if not known before"				file position: objpos-4.				type _ (headers at: headers size-1) bitAnd: 3.				self write4Bytes: (self mapAt: class) + type.				self write4Bytes: (headers at: headers size) "faster to write than skip"]		ifFalse: ["Had no class header, or was already valid"				file position: objpos+4].	"Now positioned after header, before data..."	writeBlock value.	"No allocation of new oops is allowed in here!!"	"Consistency check"	file position = (objpos + (length+1*4)) ifFalse:		["writeBlock did not leave us at end of object"		self error: 'reposition error'.		"Maybe copied an object without putting it in holder,		so it got freed and became something else of a different size"]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'TPR 9/23/1998 21:34'!writeAssociation: obj"when handling an Association, we need to check to see if it is one representing a class in the globals dictionary.If it is, check to see if the class is to be substituted.If it is, trace & write the substitute instead of the original value"	|  actualValue |	actualValue _ self replacementFor: obj value.	(actualValue notNil and:[Smalltalk includes: obj value])		ifFalse:[ actualValue _ obj value].	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: [self trace: obj key. self trace: actualValue]		write: [self writePointerField: obj key. self writePointerField: actualValue]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'TPR 2/8/1999 13:38'!writeContext: aContext	"Nil out any garbage above the stack pointer to avoid a crash."	| wordLength length |	aContext stackPtr == nil ifFalse:		[aContext stackPtr+1 to: aContext size do: [:ind | aContext at: ind put: nil]].	"writing out a context is made more complicated as of sq2.3 by the change in the size primitive to return the stackpointer instead of the number of indexable slots.	Thus the length parameter needs to be 		BlockContext instSize + CompiledMethod fullFrameSize = 38	while the trace block must only trace the first (named + sp) slots and the write block must add nulls after the sp."	wordLength _ self sizeInWordsOf: aContext.	length _ BlockContext instSize + aContext basicSize.	self new: aContext		class: aContext class		length: wordLength		trace: [1 to: length do: [:i | self trace: (aContext instVarAt: i)]]		write: [ 1 to: length do: [:i | self writePointerField: (aContext instVarAt: i)].			length + 1 to: wordLength do:[:i | self writePointerField: 0] ]! !!SystemTracer methodsFor: 'private' stamp: 'TPR 2/3/1999 21:40'!formatOfCls: class	"Return the full word value that encodes instSize, bits, bytes, and variable."	"See the comment in Behavior format:variable:words:pointers:	NB: we must clear the compact class related field and replace it with the value from the cloner's list of compact classes"	| ccField |	ccField _ compactClasses indexOf: class.	"0 means need full word for class "	^ (class format bitClear: (2r11111 bitShift:11)) bitOr: (ccField bitShift:11)! !!SystemTracer methodsFor: 'private' stamp: 'TPR 2/2/1999 15:56'!sizeInWordsOf: anObject"NOTE: This is the new length of the object in LONG WORDS.		Does not include the class (header) word."	| class |	class _ anObject class.	class isBytes ifTrue: [^ anObject basicSize+3 // 4].	class isBits ifTrue: [^ anObject basicSize].	"in two byte chunks"	class isVariable ifTrue: [		"terrible hack to get around contexts beleiving they are only sized up to the SP"		(class = BlockContext or: [class = MethodContext])			ifTrue:[^class instSize + CompiledMethod fullFrameSize].		 ^ class instSize + anObject basicSize].	^ class instSize! !