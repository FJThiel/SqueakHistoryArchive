'From Squeak2.9alpha of 13 June 2000 [latest update: #2964] on 6 November 2000 at 11:38:54 pm'!"Change Set:		WnldFirstPerson-arDate:			6 November 2000Author:			Andreas RaabAllow mouse navigation when first person controls are enabled. Fixes a problem in the alarm scheduler."!!B3DInterpolatedMesh methodsFor: 'accessing' stamp: 'ar 8/31/2000 23:19'!boundingBox	| box origin corner |	box _ meshes first boundingBox.	origin _ box origin.	corner _ box corner.	2 to: meshes size do:[:i|		box _ (meshes at: i) boundingBox.		origin _ origin min: box origin.		corner _ corner max: box corner.	].	^Rectangle origin: origin corner: corner! !!Scheduler methodsFor: 'ticking' stamp: 'ar 11/6/2000 23:31'!processAlarms	"This method checks all the alarms and processes any that have gone off"	alarmList do: [:alarm | 		((alarm checkTime) < currentTime) ifTrue:[			self removeAlarm: alarm.			alarm execute]]! !!WonderlandCameraControls methodsFor: 'accessing' stamp: 'ar 11/6/2000 14:48'!getCenter	^self valueOfProperty: #center ifAbsent:[self center]! !!WonderlandCameraControls methodsFor: 'accessing' stamp: 'ar 11/6/2000 14:48'!setCenter: aPoint	aPoint == nil		ifTrue:[self removeProperty: #center]		ifFalse:[self setProperty: #center toValue: aPoint].! !!WonderlandCameraControls methodsFor: 'camera control' stamp: 'ar 11/6/2000 14:48'!moveCamera	"Move the camera an amount and direction determined by the current position of the mouse and which modifier keys are held down."	| offset dt |	myMoveScale == nil ifTrue:[myMoveScale _ 0.1].	myRotationScale == nil ifTrue:[myRotationScale _ 0.01].	dt _ myScheduler getElapsedTime.	offset _ (self getCenter) - (0@8) - (Sensor mousePoint).	(Sensor shiftPressed)		ifTrue: [ (Sensor controlKeyPressed)					ifTrue: [						myCamera turnRightNow: up numberOfTurns: (dt * (offset y) * myRotationScale)										undoable: false.							]					ifFalse: [						myCamera moveRightNow: up distance: (dt * (offset y) * myMoveScale)										undoable: false.						myCamera moveRightNow: left distance: (dt * (offset x) * myMoveScale)										undoable: false.							].				]		ifFalse: [ (Sensor controlKeyPressed)					ifTrue: [						myCamera turnRightNow: left numberOfTurns: (dt * (offset x) * myRotationScale)										undoable: false.							]					ifFalse: [						myCamera moveRightNow: forward distance: (dt * (offset y) * myMoveScale)										undoable: false.						myCamera turnRightNow: left numberOfTurns: (dt * (offset x) * myRotationScale)										undoable: false.							].				].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/6/2000 23:38'!containsPoint: aPoint event: anEvent	(anEvent isMouseOver or:[firstPersonControls == true]) ifTrue:[		"Approximate for mouseOver; they're just sent too often"		^self bounds containsPoint: aPoint].	^super containsPoint: aPoint event: anEvent! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/6/2000 14:58'!mouseDown: evt 	"When the user clicks in a camera window, determine which actor the    	         user clicked on and have that actor respond to the event"	| newEvent reactions |	firstPersonControls == true ifTrue:[		myControls setCenter: evt position.		myControls mouseDown: evt.		evt hand needsToBeDrawn ifFalse:[Cursor crossHair show].		^self	].	newEvent _ self convertEvent: evt.	newEvent		ifNotNil: 			[((mode = #paint and: [newEvent getVertex ~= nil]) and: [evt commandKeyPressed not])				ifTrue:					[self prepareAction: newEvent.					^self perform: palette action with: newEvent]				ifFalse:					[newEvent getActor hasActiveTexture						ifTrue: [^ newEvent getActor morphicMouseDown: newEvent].					evt redButtonPressed						ifTrue: 							[reactions _ newEvent getActor getReactionsTo: leftMouseDown.							mouseUpButton _ leftMouseUp]						ifFalse: [evt yellowButtonPressed								ifTrue: 									[reactions _ newEvent getActor getReactionsTo: rightMouseDown.									mouseUpButton _ rightMouseUp]								ifFalse: [reactions _ nil]].					reactions ifNotNil: [reactions do: [:aReaction | aReaction reactTo: newEvent]]]]! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/6/2000 14:49'!mouseMove: evt 	"When the user clicks in a camera window, determine which actor the    	    user clicked on and have that actor respond to the event"	| newEvent reactions |	firstPersonControls == true ifTrue:[^self].	newEvent _ self convertEvent: evt.	mode = #stroke		ifTrue: [self recordStroke: evt cursorPoint]		ifFalse: [newEvent				ifNotNil: 					[((mode = #paint and: [newEvent getVertex ~= nil]) and: [evt commandKeyPressed not])						ifTrue:							[newEvent getActor = currentActor								ifTrue: [									self prepareAction: newEvent.									^self perform: palette action with: newEvent]]						ifFalse: [							newEvent getActor hasActiveTexture								ifTrue: [^ newEvent getActor morphicMouseMove: newEvent].								reactions _ newEvent getActor getReactionsTo: mouseMove.								reactions ifNotNil: [reactions do: [:aReaction | aReaction reactTo: newEvent]]]]]! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 11/6/2000 14:50'!mouseUp: evt 	"When the user clicks in a camera window, determine which actor the    	user clicked on and have that actor respond to the event"	| newEvent reactions |	firstPersonControls == true ifTrue:[		myControls mouseUp: evt.		myControls setCenter: nil.		evt hand needsToBeDrawn ifFalse:[Cursor normal show].		^self	].	self mode = #stroke ifTrue: [self createPoohActor. ^ self mode: nil].	newEvent _ self convertEvent: evt.	newEvent ifNil: [^ self].	(self mode = #paint and: [newEvent getVertex ~= nil])		ifTrue:			[self prepareAction: newEvent.			^ self perform: palette action with: newEvent].	newEvent getActor hasActiveTexture ifTrue: [^ newEvent getActor morphicMouseUp: newEvent].	reactions _ newEvent getActor getReactionsTo: mouseUpButton.	reactions ifNotNil: [reactions do: [:aReaction | aReaction reactTo: newEvent]]! !