'From Squeak3.1alpha of 28 February 2001 [latest update: #4274] on 22 August 2001 at 4:46:20 pm'!"Change Set:		projectFixesDate:			22 August 2001Author:			Michael RuegerFixes some problems with loading and storing older projects with external resources.External Resources are now always localized with the project.At some time it would be nice to have a small tool to determine which resource should stay where they came from."!Object subclass: #ResourceManager	instanceVariableNames: 'resourceMap loaded unloaded stopSemaphore stopFlag loaderProcess '	classVariableNames: 'CachedResources LocalizedExternalResources '	poolDictionaries: ''	category: 'System-Support'!!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'mir 8/16/2001 15:34'!buttonPublish	^self makeButton: 'PUBLISH IT!!' balloonText: 'Publish this project. Save it where it came from (server, hard disk, etc.) ' for: #publishProject! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 5/16/2001 17:56'!doPublishButtonMenuEvent: evt	| menu selection |	menu _ CustomMenu new.	menu 		add: 'Publish' action: [self publishProject];		add: 'Publish As...' action: [self publishProjectAs];		add: 'Publish to Different Server' action: [self publishDifferent];		add: 'edit project info' action: [self editProjectInfo].	selection _ menu build startUpCenteredWithCaption: 'Publish options'.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'mir 8/16/2001 15:34'!publishProject	self 		publishStyle: #limitedSuperSwikiPublishDirectoryList 		forgetURL: false		withRename: false! !!ResourceManager methodsFor: 'accessing' stamp: 'mir 8/20/2001 19:06'!adjustToNewServer: newResourceUrl from: oldResourceUrl	"Adjust the resource manager to the current download location. A project might have been moved manually to a different location or server."	| urlMap oldUrl newUrl |	newResourceUrl isEmptyOrNil ifTrue: [^self].	urlMap _ Dictionary new.	self resourceMap		keysDo: [:locator | 			"Local file refs are not handled well, so work around here"			oldUrl _ ((oldResourceUrl includesSubString: '://') not				and: [(locator urlString includesSubString: '://') not])				ifTrue: [oldResourceUrl , locator urlString]				ifFalse: [locator urlString asUrlRelativeTo: oldResourceUrl asUrl].			newUrl _ locator urlString asUrlRelativeTo: newResourceUrl asUrl.			oldUrl ~= newUrl				ifTrue: [urlMap at: oldUrl asString unescapePercents put: newUrl asString unescapePercents]].	self resourceMap rehash.	unloaded rehash.	urlMap keysAndValuesDo: [:old :new |		ResourceManager renameCachedResource: old to: new]! !!ResourceManager methodsFor: 'accessing' stamp: 'mir 8/21/2001 17:07'!makeAllProjectResourcesLocalTo: resourceUrl	"Change the urls in the resource locators so project specific resources are stored and referenced locally. Project specific resources are all those that are kept locally in any of the project's versions."	| locators locUrl locBase lastSlash projectBase localResource isExternal | 	"Construct the version neutral project base"	resourceUrl isEmptyOrNil ifTrue: [^self].	projectBase _ resourceUrl copyFrom: 1 to: (resourceUrl lastIndexOf: $.) - 1.	locators _ OrderedCollection new.	self resourceMap		keysAndValuesDo:[:loc :res | res ifNotNil: [locators add: loc]].	locators do: [:locator |		locUrl _ locator urlString.		locUrl ifNotNil: [			lastSlash _ locUrl lastIndexOf: $/.			lastSlash > 0				ifTrue: [					locBase _ locUrl copyFrom: 1 to: lastSlash - 1.					locBase _ locBase copyFrom: 1 to: (((locBase lastIndexOf: $.) - 1) max: 0).					isExternal _ projectBase ~= locBase.					(isExternal not						or: [self localizeAllExternalResources])						ifTrue: [							localResource _ locUrl copyFrom: lastSlash+1 to: locUrl size.							"Update the cache entry to point to the new resource location"							ResourceManager renameCachedResource: locUrl to: (resourceUrl , localResource) external: isExternal.							locator urlString: localResource]]]].	self resourceMap rehash! !!ResourceManager methodsFor: 'loading' stamp: 'mir 8/21/2001 18:33'!loaderProcess	| loader requests req locator resource stream |	loader _ HTTPLoader default.	requests _ Dictionary new.	self prioritizedUnloadedResources do:[:loc|		req _ HTTPLoader httpRequestClass for: (self hackURL: loc urlString) in: loader.		loader addRequest: req.		requests at: req put: loc].	[stopFlag or:[requests isEmpty]] whileFalse:[		stopSemaphore waitTimeoutMSecs: 500.		requests keys "need a copy" do:[:r|			r isSemaphoreSignaled ifTrue:[				locator _ requests at: r.				requests removeKey: r.				stream _ r contentStream.				resource _ resourceMap at: locator ifAbsent:[nil].				self class cacheResource: locator urlString stream: stream.				self installResource: resource					from: stream					locator: locator.				(resource isKindOf: Form) ifTrue:[					WorldState addDeferredUIMessage: self formChangedReminder]ifFalse: [self halt].			].		].	].	"Either done downloading or terminating process"	stopFlag ifTrue:[loader abort].	loaderProcess _ nil.	stopSemaphore _ nil.! !!ResourceManager methodsFor: 'private' stamp: 'mir 8/20/2001 17:12'!localizeAllExternalResources	"Should be a preference later."	^true! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 8/21/2001 17:37'!lookupCachedResource: cachedUrlString ifPresentDo: streamBlock	"See if we have cached the resource described by the given url and if so, evaluate streamBlock with the cached resource."	|  urlString candidates |	CachedResources ifNil:[^self].	candidates _ CachedResources at: cachedUrlString ifAbsent:[nil].	(self lookupCachedResource: cachedUrlString in: candidates ifPresentDo: streamBlock)		ifTrue: [^self].	urlString _ self relocatedExternalResource: cachedUrlString.	urlString ifNil: [^self].	candidates _ CachedResources at: urlString ifAbsent:[nil].	self lookupCachedResource: urlString in: candidates ifPresentDo: streamBlock! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 8/21/2001 18:31'!lookupCachedResource: urlString in: candidates ifPresentDo: streamBlock	"See if we have cached the resource described by the given url and if so, evaluate streamBlock with the cached resource."	| sortedCandidates dir file |	(candidates isNil or:[candidates size = 0])		ifTrue:[^false].	"First, try non-zip members (faster since no decompression is involved)"	sortedCandidates _ (candidates reject:[:each| each beginsWith: 'zip://']),					(candidates select:[:each| each beginsWith: 'zip://']).	dir _ Project squeakletDirectory.	sortedCandidates do:[:fileName|		file _ self loadResource: urlString fromCacheFileNamed: fileName in: dir.		file ifNotNil:[			[streamBlock value: file] ensure:[file close].			^true]].	^false! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 8/22/2001 15:16'!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources _ Dictionary new.	LocalizedExternalResources _ nil.	fd _ Project squeakletDirectory.	files _ fd fileNames asSet.	stream _ [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream _ ReadStream on: stream contentsOfEntireFile].	storeBack _ false.	[stream atEnd] whileFalse:[		url _ stream upTo: Character cr.			localName _ stream upTo: Character cr.		(localName beginsWith: 'zip://') ifTrue:[			archiveName _ localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack _ true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack _ true]		].	].	(stream respondsTo: #close) ifTrue:[stream close].	storeBack ifTrue:[		stream _ fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 8/21/2001 17:24'!renameCachedResource: urlString to: newUrlString	"A project was renamed. Reflect this change by duplicating the cache entry to the new url."	self renameCachedResource: urlString to: newUrlString external: true! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 8/21/2001 16:01'!renameCachedResource: urlString to: newUrlString external: isExternal	"A project was renamed. Reflect this change by duplicating the cache entry to the new url."	| candidates |	CachedResources ifNil:[^self].	candidates _ CachedResources at: urlString ifAbsent:[nil].	(candidates isNil or:[candidates size = 0]) ifTrue:[^self].	candidates do: [:candidate |		self addCacheLocation: candidate for: newUrlString].	isExternal		ifTrue: [self relocatedExternalResource: urlString to: newUrlString]! !!ResourceManager class methodsFor: 'private-resources' stamp: 'mir 8/21/2001 15:50'!localizedExternalResources	^LocalizedExternalResources ifNil:[LocalizedExternalResources _ Dictionary new]! !!ResourceManager class methodsFor: 'private-resources' stamp: 'mir 8/21/2001 16:06'!relocatedExternalResource: urlString	^self localizedExternalResources at: urlString ifAbsent: [nil]! !!ResourceManager class methodsFor: 'private-resources' stamp: 'mir 8/21/2001 16:00'!relocatedExternalResource: urlString to: newUrlString	| originalURL |	originalURL _ (self localizedExternalResources includesKey: urlString)		ifTrue: [self localizedExternalResources at: urlString]		ifFalse: [urlString].	self localizedExternalResources at: newUrlString put: originalURL! !ResourceManager removeSelector: #makeProjectResourcesLocalTo:!ProjectNavigationMorph removeSelector: #publishProjectSimple!