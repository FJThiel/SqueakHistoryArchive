'From Squeak2.8alpha of 13 January 2000 [latest update: #2066] on 6 May 2000 at 12:07:09 am'!"Change Set:		altBrowseIt-swDate:			6 May 2000Author:			Scott WallaceOffers an alternative implementation of the 'browse it' command in the text editor, which some users may wish to try out.  To arm it, set the new Preference #alternateBrowseIt to true (default is false).The alternative browseIt analyzes the selection using pattern-matching similar to that found in the find-class feature of the browser; if a unique match is found, the class concerned is summarily browsed.  If more than one hit is found, then a menu offering the alternatives is presented.Finally, once the class to be browsed is determined, a hierarchy browser is opened on it."!!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 5/4/2000 13:45'!browseClassFromIt	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self lineSelectAndEmptyCheck: [^ self].	aClass _ Utilities classFromPattern: (self selection string copyWithout: Character cr) withCaption: 'choose a class to browse...'.	aClass ifNil: [^ view flash].	self terminateAndInitializeAround:		[Utilities spawnHierarchyForClass: aClass selector: nil]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/20/2000 12:18'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk					at: aSymbol					ifAbsent:						[Smalltalk browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isKindOf: Class)					ifFalse:	[anEntry _ anEntry class].				brow _ Preferences browseToolClass new.				brow setClass: anEntry selector: nil.				brow class					openBrowserView: (brow openEditString: nil)					label: 'System Browser']			ifFalse:				[Smalltalk browseAllImplementorsOf: aSymbol]]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 5/4/2000 13:32'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ self selectedClassOrMetaClass 		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages _ method messages) size == 0])		 ifTrue: [^ aBlock value: selector].	(messages size == 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	Smalltalk 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 5/4/2000 13:47'!classFromPattern: pattern withCaption: aCaption	"If there is a class whose name exactly given by pattern, return it.	If there is only one class in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen"	| toMatch potentialClassNames classNames exactMatch index |	pattern isEmpty ifTrue: [^ nil].	Symbol hasInterned: pattern ifTrue:		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:			[:maybeClass | (maybeClass isKindOf: Class) ifTrue: [^ maybeClass]]].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ Smalltalk classNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ nil].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUpWithCaption: aCaption]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUpWithCaption: aCaption]].	index = 0 ifTrue: [^ nil].	^ Smalltalk at: (classNames at: index) asSymbol"	Utilities classFromPattern: 'CharRecog'	Utilities classFromPattern: 'rRecog'	Utilities classFromPattern: 'znak'	Utilities classFromPattern: 'orph'"! !"Postscript:"Preferences addPreference: #alternativeBrowseIt category: #browsing default: false balloonHelp: 'if true, then the "browse it" (cmd-b) feature in the text editor will offer you a list of class names matching the selection, if appropriate'. !