'From Squeak 2.3 of January 14, 1999 on 10 April 1999 at 8:48:22 am'!Object subclass: #DiskProxy	instanceVariableNames: 'globalObjectName preSelector constructorSelector constructorArgs '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!Object subclass: #ImageSegment	instanceVariableNames: 'arrayOfRoots segment outPointers state fileName '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!!ImageSegmentRootStub methodsFor: 'as yet unclassified' stamp: 'tk 4/9/1999 10:32'!xxxClass	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!Object methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 12:46'!comeFullyUpOnReload: smartRefStream	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"	^ self! !!Object methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 12:05'!readDataFrom: aDataStream size: varsOnDisk	"Fill in the fields of self based on the contents of aDataStream.  Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	self class isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars _ 0.				cntInstVars _ varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self	"If we ever return something other than self, fix calls 			on (super readDataFrom: aDataStream size: anInteger)"! !!DataStream methodsFor: 'as yet unclassified' stamp: 'tk 4/8/1999 13:11'!maybeBeginReference: internalObject	"Do nothing.  See ReferenceStream|maybeBeginReference:"	^ internalObject! !!DataStream methodsFor: 'as yet unclassified' stamp: 'tk 4/8/1999 12:47'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString rTetraByteArray) at: type.	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject _ anObject comeFullyUpOnReload: self.	^ self maybeBeginReference: internalObject! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 4/8/1999 12:44'!comeFullyUpOnReload: smartRefStream	"Internalize myself into a fully alive object after raw loading from a DataStream. (See my class comment.)  DataStream will substitute the object from this eval for the DiskProxy."	| globalObj symbol |	symbol _ globalObjectName.	"See if class is mapped to another name"	(smartRefStream respondsTo: #renamed) ifTrue: [		symbol _ smartRefStream renamed at: symbol ifAbsent: [symbol]].	globalObj _ Smalltalk at: symbol 		ifAbsent: [^ self halt: 'Global not found'].	((symbol == #World) and: [World == nil]) ifTrue: [		self inform: 'These objects will work better if opened in a Morphic World.Dismiss and reopen all menus.'].	preSelector ifNotNil: [		Symbol hasInterned: preSelector ifTrue: [:selector |			globalObj _ globalObj perform: selector]].	constructorSelector ifNil: [^ globalObj].	constructorSelector ifNotNil: [		Symbol hasInterned: constructorSelector ifTrue: [:selector |			^ globalObj perform: selector					withArguments: constructorArgs]].					"args not checked against Renamed"	^ nil 	"was not in proper form"! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 4/8/1999 12:58'!global: globalNameSymbol preSelector: aSelector selector: selectorSymbol args: argArray	"Initialize self as a DiskProxy constructor with the given	globalNameSymbol, selectorSymbol, and argument Array.	I will internalize by looking up the global object name in the	SystemDictionary (Smalltalk) and sending it this message with	these arguments."	globalObjectName _ globalNameSymbol asSymbol.	preSelector _ aSelector asSymbol.	constructorSelector _ selectorSymbol asSymbol.	constructorArgs _ argArray.! !!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 4/8/1999 12:54'!preSelector: aSelector	preSelector _ aSelector! !!DiskProxy methodsFor: 'object fileIn' stamp: 'tk 4/8/1999 13:16'!convertgcc0: varDict gpcc0: smartRefStrm	"These variables are automatically stored into the new instance ('globalObjectName' 'constructorSelector' 'constructorArgs' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('preSelector' ) and deal with the information in ()"! !!ImageSegment commentStamp: 'tk 4/8/1999 20:56' prior: 0!I represent a segment of Squeak address space.  I am created from an array of root objects.  After storing, my segment contains a binary encoding of every object accessible from my roots but not otherwise accessible from anywhere else in the system.  Within my segment are indices into my table of outPointers.I may exist in several states...#activeCopyarrayOfRoots segment outPointers are all as created by the copyFromRoots: initialization message.  Nothing else has changed about the Squeak system.#activeEach of the original roots has been transmuted into an ImageSegmentRootStub that refers back to this image segment.  The original objects in the segment will all be garbageCollected.#onFileThe segment has been written out to a file and replaced by a file pointer.  Only the array of outPointers remains in the image.	NOTE: All IdentitySets or dictionaries with internal keys (not in outPointers) must be rehashed when being read back from this format.#onFileWithSymbolsThe segment has been written out to a file, along with the text of all the symbols in the outPointers array, and replaced by a file pointer.  This reduces the size of the outPointers array, and also allows the system to reclaim any symbols that are not referred to from elsewhere in the image.  The specific format used is that of a literal array as follows:	#(symbol1 symbol2 # symbol3 symbol4 'symbolWithSpaces' # symbol5).In this case, the original outPointers array was 8 long, but the compacted table of outPointers retains only two entries.  These get inserted in place of the #'s in the array of symbols after it is read back in.  Symbols with embedded spaces or other strange characters are written as strings, and converted back to symbols when read back in.  The symbol # is never written out.	NOTE: All IdentitySets or dictionaries must be rehashed when being read back from this format.  The symbols are effectively internal.  (No, not if read back into same image.  If a different image, then use #imported.  -tk)#importedThe segment is on an external file or just read in from one.  The segment and outPointers are meant to be read into a foreign image.   (It is in SmartRefStream format.)  In this form the segment can be read from, eg, a URL, and installed with the resulting value being the original array of root objects, with former outPointers bound in some appropriate manner to existing objects in the host system.  	(Any Class inside the segment MUST be in the arrayOfRoots.  This is so its association can be inserted into Smalltalk.	All IdentitySets and dictionaries must be rehashed when being read back from this format.) #inactiveIn this state, the rootsArray is set, but the segment is invalid.!!ImageSegment reorganize!('initialization' copyFromRoots:)('access' arrayOfRoots outPointers)('changing state' extract extractThenInstall install readFromFile segmentCopy writeForExport: writeToFile: writeToFileWithSymbols:)('primitives' loadSegmentFrom:outPointers: storeSegmentFor:into:outPointers:)('testing' deepCopyTest: errorWrongState verify:matches:knowing: verifyCopy)('fileIn/Out' comeFullyUpOnReload: declare: prepareToBeSaved rehashSets storeDataOn:)('object fileIn' convertasosfs0:asosf0:)!!ImageSegment methodsFor: 'access' stamp: 'tk 4/6/1999 13:15'!arrayOfRoots	^ arrayOfRoots! !!ImageSegment methodsFor: 'access' stamp: 'tk 3/31/1999 21:47'!outPointers	^ outPointers! !!ImageSegment methodsFor: 'changing state' stamp: 'tk 4/8/1999 21:39'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots _ self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots _ newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	self rehashSets.	state _ #inactive.! !!ImageSegment methodsFor: 'changing state' stamp: 'tk 4/6/1999 18:05'!writeForExport: shortName	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk."	| fileStream |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(shortName endsWith: '.extSeg')		ifTrue: [fileName _ shortName]		ifFalse: [fileName _ shortName , '.extSeg'].	fileStream _ FileStream newFileNamed: fileName.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 4/10/1999 08:45'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  An object in the segment is the wrong size for the modern version of the class.  Construct a fake class that is the old size.  Replace the modern class with the old one in outPointers.  Load the segment.  Traverse the instances, making new instances by copying fields, and running conversion messages.  Keep the new instances.  Bulk forward become the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.  Globalize new classes.  Caller may want to do some special install on certain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal fakes goods bads perfect |	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.  Substitute them in outPointers."	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		fakes _ mapFakeClassesToReal keys.		goods _ OrderedCollection new.		bads _ OrderedCollection new.		fakes do: [:aFakeClass | 			aFakeClass allInstancesDo: [:misShapen | 				perfect _ smartRefStream convert: misShapen 							to: (mapFakeClassesToReal at: aFakeClass).				bads add: misShapen.				goods add: perfect]].		bads size > 0 ifTrue: [			bads asArray elementsForwardIdentityTo: goods asArray]].	self rehashSets.	"Classes in this segment."	arrayOfRoots do: [:aRoot | 		aRoot class class == Metaclass ifTrue: [			self declare: aRoot.			aRoot category: 'Newly-Imported']].	mapFakeClassesToReal isEmpty ifFalse: [		fakes do: [:aFake | aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 4/10/1999 08:02'!declare: classThatIsARoot	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	(Smalltalk includesKey: classThatIsARoot name) ifFalse: [		"Class entry in Smalltalk not referred to in Segment, install anyway."		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	(Smalltalk at: classThatIsARoot name) xxxClass == ImageSegmentRootStub ifTrue: [		"We are that segment!!  Must ask it carefully!!"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	(Smalltalk at: classThatIsARoot name) == false ifTrue: [		"association is in outPointers, just installed"		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	"Conflict with existing global or copy of the class"	((Smalltalk at: classThatIsARoot name) isKindOf: Class) ifTrue: [		"Take the incoming one"		self inform: 'Using newly arrived version of ', classThatIsARoot name.		^ (Smalltalk at: classThatIsARoot name) becomeForward: classThatIsARoot].	self error: 'Name already in use by a non-class: ', classThatIsARoot name.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 4/10/1999 08:25'!prepareToBeSaved	"Prepare objects in outPointers to be written on the disk.  They must be able to match up with existing objects in their new system.  outPointers is already a copy.	Classes are already converted to a DiskProxy.  	Associations in outPointers:1) in Smalltalk.2) in a classPool.3) in a shared pool.4) A pool dict pointed at directly"| left pool myClasses outIndexes key |myClasses _ Set new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [myClasses add: aRoot]].outIndexes _ IdentityDictionary new.outPointers withIndexDo: [:anOut :ind | 	anOut class == Association ifTrue: [		(myClasses includes: anOut value)			ifFalse: [outIndexes at: anOut put: ind]			ifTrue: [(Smalltalk associationAt: anOut key ifAbsent: [3]) == anOut 				ifTrue: [outPointers at: ind put: 					(DiskProxy global: #Smalltalk selector: #associationDeclareAt: 						args: (Array with: anOut key))]				ifFalse: [outIndexes at: anOut put: ind]				]].	(anOut isKindOf: Dictionary) ifTrue: ["Pools pointed at directly"		(key _ Smalltalk keyAtIdentityValue: anOut ifAbsent: [nil]) ifNotNil: [			outPointers at: ind put: 				(DiskProxy global: key selector: #yourself args: #())]]	].left _ outIndexes keys asSet.left size > 0 ifTrue: ["Globals"	(left copy) do: [:assoc |	"stay stable while delete items"		(Smalltalk associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [			outPointers at: (outIndexes at: assoc) put: 				(DiskProxy global: #Smalltalk selector: #associationAt: 					args: (Array with: assoc key)).			left remove: assoc]]].left size > 0 ifTrue: ["Class variables"	Smalltalk allClassesDo: [:cls | cls classPool size > 0 ifTrue: [		(left copy) do: [:assoc |	"stay stable while delete items"			(cls classPool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [				outPointers at: (outIndexes at: assoc) put: 					(DiskProxy new global: cls name						preSelector: #classPool						selector: #associationAt: 						args: (Array with: assoc key)).				left remove: assoc]]]]].left size > 0 ifTrue: ["Pool variables"	Smalltalk associationsDo: [:poolAssoc |		poolAssoc value class == Dictionary ifTrue: ["a pool"			pool _ poolAssoc value.			(left copy) do: [:assoc |	"stay stable while delete items"				(pool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [					outPointers at: (outIndexes at: assoc) put: 						(DiskProxy global: poolAssoc key selector: #associationAt: 							args: (Array with: assoc key)).					left remove: assoc]]]]].left size > 0 ifTrue: [	"If points to class in arrayOfRoots, must deal with it separately"	"OK to have obsolete associations that just get moved to the new system"	self inform: 'extra associations'.	left inspect].! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 4/8/1999 21:22'!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it)."	| object |	object _ segment.	[object _ object nextObject.  object rehash. object == 0] whileFalse.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 4/9/1999 11:31'!storeDataOn: aDataStream	"Don't wrote the array of Roots.  Also remember the structures of the classes of objects inside the segment."	| tempRoots tempOutP |	state = #activeCopy ifFalse: [self error: 'wrong state'].		"real state is activeCopy, but we changed it will be right when coming in"	tempRoots _ arrayOfRoots.	tempOutP _ outPointers.	outPointers _ outPointers clone.	self prepareToBeSaved.	arrayOfRoots _ nil.	state _ #imported.	super storeDataOn: aDataStream.		"record my inst vars"	arrayOfRoots _ tempRoots.	outPointers _ tempOutP.	state _ #activeCopy.	aDataStream references at: #AnImageSegment put: false.		"flag that there is one in this write"! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'tk 4/8/1999 12:45'!comeFullyUpOnReload: smartRefStream	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."	leftSamples == rightSamples		ifTrue: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ leftSamples]		ifFalse: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ SoundBuffer fromByteArray: self rightSamples].! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 4/8/1999 12:45'!comeFullyUpOnReload: smartRefStream	"inst vars have default booplean values."	locked ifNil: [locked _ false].	visible ifNil: [visible _ true].	sticky ifNil: [sticky _ false].	isPartsDonor ifNil: [isPartsDonor _ false].	^ self! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 4/8/1999 12:46'!comeFullyUpOnReload: smartRefStream	"Normally this read-in object is exactly what we want to store.  Try to dock first.  If it is here already, use that one."	| sp |	Transcript show: 'has ref to: ', url; cr.	(sp _ SqueakPageCache pageCache at: page ifAbsent: [nil]) ifNotNil: [		sp isContentsInMemory ifTrue: [^ sp contentsMorph]].	^ self! !!ReferenceStream methodsFor: 'reading' stamp: 'tk 4/8/1999 13:11'!maybeBeginReference: internalObject	"See if need to record a reference.  In case in the file twice"	(self isAReferenceType: (self typeIDFor: internalObject))			ifTrue: [self beginReference: internalObject].			"save the final object and give it out next time."	^ internalObject! !!Set methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 13:05'!comeFullyUpOnReload: smartRefStream	"Symbols have new hashes in this image."	self rehash.	"^ self"! !!Dictionary methodsFor: 'accessing' stamp: 'tk 4/9/1999 10:22'!associationDeclareAt: aKey	"Return an existing association, or create and return a new one.  Needed as a single message by ImageSegment.prepareToBeSaved."	| existing |	^ self associationAt: aKey ifAbsent: [		(Undeclared includesKey: aKey)			ifTrue: 				[existing _ Undeclared associationAt: aKey.				Undeclared removeKey: aKey.				self add: existing]			ifFalse: 				[self add: aKey -> false]]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 4/9/1999 11:32'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures _ Dictionary new.	superclasses _ Dictionary new.	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			refs keysDo: [:each | 				cls _ each class.				cls class == Metaclass ifFalse: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	self saveClassInstVars.	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/31/1999 21:53'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls |	refs keysDo: [:each | 		cls _ each class.		cls class == Metaclass ifFalse: [			structures at: cls name put: false.			(each isKindOf: ImageSegment) ifTrue: [				each outPointers do: [:out |					(out isKindOf: Class) ifTrue: [						structures at: out theNonMetaClass name put: false]]].			(each isKindOf: Association) ifTrue: [].			]]! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 4/4/1999 12:58'!convert: misShapenInst to: goodClass	"Go through the normal instance conversion process and return a modern object."	| newName className oldInstVars anObject varMap supers this sel |	goodClass isVariable ifTrue: [		goodClass error: 'shape change for variable class not implemented yet'].	newName _ goodClass name.	className _ renamed keyAtValue: newName ifAbsent: [newName].		"A problem here if two classes map to the same one!!"	oldInstVars _ structures at: className.	anObject _ goodClass basicNew.	varMap _ Dictionary new.	"later, indexed vars as (1 -> val) etc."	2 to: oldInstVars size do: [:ind |		varMap at: (oldInstVars at: ind) put: (misShapenInst instVarAt: ind-1)].	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: varMap. 	"ones with the same names"	supers _ OrderedCollection with: (this _ className).	[(this _ superclasses at: this) = 'nil'] whileFalse: [supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject _ anObject perform: sel with: varMap with: self]].				"do the mapping"	^ anObject! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 4/9/1999 18:52'!mapClass: newClass installIn: mapFakeClassesToReal	"aClass is has already been mapped!!  Make a fake class for the old shape.  Write it into the dictionary mapping Fake classes to Real classes."	| newName className oldInstVars fakeClass |	newClass isMeta ifTrue: [^ nil].	newName _ newClass name.	className _ renamed keyAtValue: newName ifAbsent: [newName].		"A problem here if two classes map to the same one!!"	(steady includes: newClass) ifTrue: [^ nil].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	fakeClass _ Object subclass: ('Fake',className) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	mapFakeClassesToReal at: fakeClass put: newClass.	^ fakeClass! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk 4/4/1999 12:34'!reshapedClassesIn: outPointers	"Look for classes in the outPointer array that have changed shape.  Make a fake class for the old shape.  Return a dictionary mapping Fake classes to Real classes.  Substitute fake classes for real ones in outPointers."	| mapFakeClassesToReal fakeCls |	mapFakeClassesToReal _ IdentityDictionary new.	outPointers withIndexDo: [:outp :ind | 		(outp isKindOf: ClassDescription) ifTrue: [			(fakeCls _ self mapClass: outp installIn: mapFakeClassesToReal) ifNotNil: [				outPointers at: ind put: fakeCls]]].	^ mapFakeClassesToReal! !Object removeSelector: #comeFullyUpOnReload!DataStream removeSelector: #internalize:!DiskProxy removeSelector: #comeFullyUpOnReload2!DiskProxy removeSelector: #readDataFrom:size:!DiskProxy removeSelector: #comeFullyUpOnReload!DiskProxy removeSelector: #global:evalString:!DiskProxy removeSelector: #evalString:!ImageSegment removeSelector: #comeFullyUpOnReload!ImageSegment removeSelector: #readDataFrom:size:!LoopedSampledSound removeSelector: #comeFullyUpOnReload!MorphExtension removeSelector: #comeFullyUpOnReload!ObjectOut removeSelector: #comeFullyUpOnReload!ReferenceStream removeSelector: #internalize:!Set removeSelector: #readDataFrom:size:!