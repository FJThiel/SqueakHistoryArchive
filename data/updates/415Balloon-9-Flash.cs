'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:06:19 am'!"Change Set:		Balloon-9-FlashDate:			15 November 1998Author:			Your Name<your descriptive text goes here>"!CompressedBoundaryShape subclass: #FlashBoundaryShape	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashColorTransform	instanceVariableNames: 'rAdd rMul gAdd gMul bAdd bMul aAdd aMul '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!DamageRecorder subclass: #FlashDamageRecorder	instanceVariableNames: 'fullDamageRect '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!Object subclass: #FlashFileReader	instanceVariableNames: 'stream log dataSize nFillBits nLineBits nGlyphBits nAdvanceBits jpegDecoder '	classVariableNames: 'ActionTable IndexTables StepTable TagTable '	poolDictionaries: ''	category: 'MM-Flash-Import'!Stream subclass: #FlashFileStream	instanceVariableNames: 'stream bitBuffer bitPosition hasAlpha '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashFileWriter	instanceVariableNames: 'stream log dataSize nFillBits nLineBits nGlyphBits nAdvanceBits jpegEncoder '	classVariableNames: 'TagTable '	poolDictionaries: ''	category: 'MM-Flash-Import'!JPEGReadWriter subclass: #FlashJPEGDecoder	instanceVariableNames: 'eoiSeen '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashKeyframe	instanceVariableNames: 'start stop data '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashKeyframes	instanceVariableNames: 'kfList lastIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashLineStyle	instanceVariableNames: 'width color '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!FlashFileReader subclass: #FlashMorphReader	instanceVariableNames: 'location fillStyles lineStyles shapes fonts forms sounds buttons lineSequence currentShape player stepTime frame activeMorphs passiveMorphs activeFont textOffset textPosition textHeight textMorph canCompressPoints pointList compressionBounds fillIndex0 fillIndex1 lineStyleIndex leftFillList rightFillList lineStyleList '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Import'!Object subclass: #FlashSoundEnvelope	instanceVariableNames: 'mark44 level0 level1 '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!Object subclass: #FlashSoundInformation	instanceVariableNames: 'syncFlags inPoint outPoint loopCount envelopes '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Support'!MatrixTransformMorph subclass: #FlashMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashCharacterMorph	instanceVariableNames: 'id stepTime frame renderTime vData mData dData cmData pData '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashCharacterMorph subclass: #FlashButtonMorph	instanceVariableNames: 'menuFlag events default over press sensitive sounds '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashGlyphMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashPlayerMorph	instanceVariableNames: 'borderWidth borderColor controls frames frameNumber stepTime aaLevel sounds actions labels activationKeys activeMorphs damageRecorder localBounds '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!FlashMorph subclass: #FlashShapeMorph	instanceVariableNames: 'shape '	classVariableNames: ''	poolDictionaries: ''	category: 'MM-Flash-Morphs'!!FileList methodsFor: 'file list menu' stamp: 'ar 10/12/1998 23:44'!openAsFlash	"Open a MoviePlayerMorph on the given file (must be in .movie format)."	| f |	Smalltalk at: #Morph ifAbsent: [^ self beep].	f _ (directory readOnlyFileNamed: self fullName) binary.	(FlashMorphReader on: f) processFile.! !!FlashBoundaryShape methodsFor: 'private' stamp: 'ar 11/3/1998 21:54'!remapFills	"Replace the fill style dictionary with an array"	| indexMap newFillStyles index |	(fillStyles isKindOf: Dictionary) ifFalse:[^false].	indexMap _ Dictionary new.	indexMap at: 0 put: 0. "Map zero to zero"	newFillStyles _ Array new: fillStyles size.	index _ 1.	fillStyles associationsDo:[:assoc|		indexMap at: assoc key put: index.		newFillStyles at: index put: assoc value.		index _ index + 1.	].	leftFills _ leftFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	rightFills _ rightFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	lineFills _ lineFills valuesCollect:[:value| indexMap at: value ifAbsent:[0]].	fillStyles _ newFillStyles! !!FlashBoundaryShape methodsFor: 'accessing' stamp: 'ar 11/9/1998 02:30'!complexity	^points size // 3! !!FlashColorTransform methodsFor: 'initialize' stamp: 'ar 7/2/1998 23:43'!initialize	rMul _ bMul _ gMul _ aMul _ 256.	rAdd _ bAdd _ gAdd _ aAdd _ 0.! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aAdd	^aAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aAdd: aFixed	aAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!aMul	^aMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!aMul: aFixed	aMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bAdd	^bAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bAdd: aFixed	bAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!bMul	^bMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!bMul: aFixed	bMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gAdd	^gAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gAdd: aFixed	gAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!gMul	^gMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!gMul: aFixed	gMul _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rAdd	^rAdd! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rAdd: aFixed	rAdd _ aFixed! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:43'!rMul	^rMul! !!FlashColorTransform methodsFor: 'accessing' stamp: 'ar 7/2/1998 23:44'!rMul: aFixed	rMul _ aFixed! !!FlashColorTransform methodsFor: 'comparing' stamp: 'ar 8/14/1998 19:39'!= aCT	self class == aCT class ifFalse:[^false].	^rAdd = aCT rAdd and:[rMul = aCT rMul and:[		gAdd = aCT gAdd and:[gMul = aCT gMul and:[			bAdd = aCT bAdd and:[bMul = aCT bMul and:[				aAdd = aCT aAdd and:[aMul = aCT aMul]]]]]]]! !!FlashColorTransform methodsFor: 'comparing' stamp: 'ar 8/14/1998 19:40'!hash	^rAdd hash + gMul hash + bAdd hash + aMul hash! !!FlashColorTransform class methodsFor: 'instance creation' stamp: 'ar 7/2/1998 23:42'!new	^super new initialize! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/13/1998 15:54'!fullDamageRect: maxBounds	invalidRects isEmpty ifTrue:[^0@0 corner: 0@0].	^fullDamageRect intersect: maxBounds! !!FlashDamageRecorder methodsFor: 'all' stamp: 'ar 11/13/1998 15:43'!recordInvalidRect: rect	totalRepaint ifTrue:[^self].	self updateIsNeeded ifTrue:[		fullDamageRect _ fullDamageRect merge: rect.	] ifFalse:[		fullDamageRect _ rect copy.	].	^super recordInvalidRect: rect! !!FlashFileReader methodsFor: 'initialize' stamp: 'ar 7/4/1998 20:14'!on: aStream	aStream binary.	stream _ FlashFileStream on: aStream.	log _ Transcript.	log _ nil.! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 7/3/1998 18:57'!frameNumber	^0! !!FlashFileReader methodsFor: 'property access' stamp: 'ar 7/3/1998 18:57'!frameNumber: anInteger! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/12/1998 23:46'!processFile	"Read and process the entire file"	self processHeader ifFalse:[^nil].	'Reading file' displayProgressAt: Sensor cursorPoint		from: 1 to: 100		during:[:theBar|	[self processTagFrom: stream] whileTrue:[		theBar value: (stream position * 100 // stream size).		stream atEnd ifTrue:[			log ifNotNil:[				log cr; nextPutAll:'Unexpected end of data (no end tag)'.				self flushLog].			^self]].	].	(stream respondsTo: #close) ifTrue:[stream close].! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/4/1998 16:51'!processHeader	"Read header information from the source stream.	Return true if successful, false otherwise."	| version twipsFrameSize frameRate frameCount |	self processSignature ifFalse:[^false].	version _ stream nextByte.	"Check for the version supported"	version > self maximumSupportedVersion ifTrue:[^false].	dataSize _ stream nextLong.	"Check for the minimal file size"	dataSize < 21 ifTrue:[^false].	twipsFrameSize _ stream nextRect.	self recordGlobalBounds: twipsFrameSize.	frameRate _ stream nextWord / 256.0.	self recordFrameRate: frameRate.	frameCount _ stream nextWord.	log ifNotNil:[		log cr; nextPutAll:'------------- Header information --------------'.		log cr; nextPutAll:'File version		'; print: version.		log cr; nextPutAll:'File size			'; print: dataSize.		log cr; nextPutAll:'Movie width		'; print: twipsFrameSize extent x // 20.		log cr; nextPutAll:'Movie height	'; print: twipsFrameSize extent y // 20.		log cr; nextPutAll:'Frame rate		'; print: frameRate.		log cr; nextPutAll:'Frame count	'; print: frameCount.		log cr; cr.		self flushLog].	^true! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 7/4/1998 20:08'!processSignature	"Check the signature of the SWF file"	stream nextByte asCharacter = $F ifFalse:[^false].	stream nextByte asCharacter = $W ifFalse:[^false].	stream nextByte asCharacter = $S ifFalse:[^false].	^true! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 10/12/1998 23:57'!processTagFrom: aStream	"Read and process the next tag from the input stream."	| tag data result |	tag _ aStream nextTag.	log ifNotNil:[		log cr; nextPutAll:'Tag #'; print: tag key.		log nextPutAll:' ('; nextPutAll: (TagTable at: tag key + 1); space; print: tag value size;			nextPutAll:' bytes)'.		self flushLog].	data _ FlashFileStream on: (ReadStream on: tag value).	result _ self dispatch: data on: tag key+1 in: TagTable ifNone:[self processUnknown: data].	(log isNil or:[data atEnd]) ifFalse:[		log 			nextPutAll:'*** ';			print: (data size - data position);			nextPutAll:' bytes skipped ***'.		self flushLog].	^result! !!FlashFileReader methodsFor: 'reading' stamp: 'ar 7/4/1998 20:14'!readFile	| time |	"MessageTally spyOn:[self processFile]."	time _ Time millisecondsToRun:[self processFile].	Transcript crtab; print: time; nextPutAll:' msecs to process file'.	Transcript endEntry.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/13/1998 17:53'!processCurveRecordFrom: data	| nBits cx cy ax ay |	log ifNotNil:[log crtab; nextPutAll:'C: '].	nBits _ (data nextBits: 4) + 2. "Offset by 2"	"Read control point change"	cx _ data nextSignedBits: nBits.	cy _ data nextSignedBits: nBits.	log ifNotNil:[log print: cx@cy].	"Read anchor point change"	ax _ data nextSignedBits: nBits.	ay _ data nextSignedBits: nBits.	log ifNotNil:[log nextPutAll:' -- '; print: ax@ay.				self flushLog].	self recordCurveSegmentTo: ax@ay with: cx@cy! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 11/13/1998 20:31'!processFillStylesFrom: data	| nFills matrix nColors rampIndex rampColor id color fillStyleType ramp |	nFills _ data nextByte.	nFills = 255 ifTrue:[nFills _ data nextWord].	log ifNotNil:[log crtab; print: nFills; nextPutAll:' New fill styles'].	1 to: nFills do:[:i|		log ifNotNil:[log crtab: 2; print: i; nextPut:$:; tab].		fillStyleType _ data nextByte.		(fillStyleType = 0) ifTrue:["Solid fill"			color _ data nextColor.			self recordSolidFill: i color: color.			log ifNotNil:[log nextPutAll:'solid color '; print: color].		].		(fillStyleType anyMask: 16) ifTrue:["Gradient fill"			"Read gradient matrix"			matrix _ data nextMatrix.			"Read color ramp data"			nColors _ data nextByte.			ramp _ Array new: nColors.			log ifNotNil:[log nextPutAll:'Gradient fill with '; print: nColors; nextPutAll:' colors'].			1 to: nColors do:[:j|				rampIndex _ data nextByte.				rampColor _ data nextColor.				ramp at: j put: (rampIndex -> rampColor)].			self recordGradientFill: i matrix: matrix ramp: ramp linear: (fillStyleType = 16)].		(fillStyleType anyMask: 16r40) ifTrue:["Bit fill"			"Read bitmap id"			id _ data nextWord.			"Read bitmap matrix"			matrix _ data nextMatrix.			log ifNotNil:[log nextPutAll:'Bitmap fill id='; print: id].			self recordBitmapFill: i matrix: matrix id: id clipped: (fillStyleType anyMask: 1)].		self flushLog.	].! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/12/1998 23:35'!processFontShapeFrom: data	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/9/1998 20:43'!processLineRecordFrom: data	| nBits x y |	nBits _ (data nextBits: 4) + 2. "Offset by 2"	data nextBitFlag ifTrue:[		"General line"		x _ data nextSignedBits: nBits.		y _ data nextSignedBits: nBits.		self recordLineSegmentBy: x@y.	] ifFalse:[		data nextBitFlag 			ifTrue:[	"vertical line"					y _ data nextSignedBits: nBits. 					self recordLineSegmentVerticalBy: y]			ifFalse:[	"horizontal line"					x _ data nextSignedBits: nBits.					self recordLineSegmentHorizontalBy: x].	].	log ifNotNil:[log crtab; nextPutAll:'E: ';print: x; nextPut:$@; print: y.				self flushLog].! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/4/1998 20:04'!processLineStylesFrom: data	| nStyles styles lineWidth lineColor |	nStyles _ data nextByte.	nStyles = 255 ifTrue:[nStyles _ data nextWord].	log ifNotNil:[log crtab; print: nStyles; nextPutAll:' New line styles'].	styles _ Array new: nStyles.	1 to: nStyles do:[:i|		lineWidth _ data nextWord.		lineColor _ data nextColor.		self recordLineStyle: i width: lineWidth color: lineColor.		log ifNotNil:[log crtab: 2; print: i; nextPut:$:; tab; 						print: lineWidth; tab; print: lineColor]].	self flushLog.	^styles! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 10/14/1998 00:39'!processShapeRecordFrom: data	| flags pt lineInfo fillInfo0 fillInfo1 |	data nextBitFlag ifTrue:["Boundary edge record"		data nextBitFlag			ifTrue:[self processLineRecordFrom: data]			ifFalse:[self processCurveRecordFrom: data].		^true].	flags _ data nextBits: 5.	flags = 0 ifTrue:[^false]. "At end of shape"	(flags anyMask: 1) ifTrue:["move to"		pt _ data nextPoint.		self recordMoveTo: pt.		log ifNotNil:[log crtab; nextPutAll:'MoveTo '; print: pt]].	(flags anyMask: 2) ifTrue:["fill info 0"		fillInfo0 _ data nextBits: nFillBits.		self recordFillStyle0: fillInfo0.		log ifNotNil:[log crtab; nextPutAll:'FillInfo0 '; print: fillInfo0]].	(flags anyMask: 4) ifTrue:["fill info 1"		fillInfo1 _ data nextBits: nFillBits.		self recordFillStyle1: fillInfo1.		log ifNotNil:[log crtab; nextPutAll:'FillInfo1 '; print: fillInfo1]].	(flags anyMask: 8) ifTrue:["line info"		lineInfo _ data nextBits: nLineBits.		self recordLineStyle: lineInfo.		log ifNotNil:[log crtab; nextPutAll:'LineInfo '; print: lineInfo]].	(flags anyMask: 16) ifTrue:["new styles"		log ifNotNil:[log crtab; nextPutAll:'New Set of styles '].		self processShapeStylesFrom: data.		"And reset info"		data initBits.		nFillBits _ data nextBits: 4.		nLineBits _ data nextBits: 4].	flags = 31 ifTrue:[self recordResetSubshape].	^true! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 7/4/1998 20:05'!processShapeStylesFrom: data	self processFillStylesFrom: data.	self processLineStylesFrom: data.! !!FlashFileReader methodsFor: 'processing shapes' stamp: 'ar 10/14/1998 00:29'!processShapesFrom: data	| id bounds |	"Read shape id and bounding box"	id _ data nextWord.	bounds _ data nextRect.	"Start new shape definition"	self recordShapeStart: id bounds: bounds.	"Read styles for this shape"	self processShapeStylesFrom: data.	"Get number of bits for fill and line styles"	data initBits.	nFillBits _ data nextBits: 4.	nLineBits _ data nextBits: 4.	"Process all records in this shape definition"	[self processShapeRecordFrom: data] whileTrue.	"And mark the end of this shape"	self recordShapeEnd: id.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/14/1998 23:17'!processGlyphEntries: nGlyphs from: data	| index advance |	data initBits.	1 to: nGlyphs do:[:i|		index _ data nextBits: nGlyphBits.		advance _ data nextSignedBits: nAdvanceBits.		self recordNextChar: index+1 advanceWidth: advance.		log ifNotNil:[			log nextPut:$(;print: index; space; print: advance; nextPut:$).			self flushLog].	].! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/13/1998 01:04'!processGlyphRecordFrom: data	| flags |	flags _ data nextByte.	flags = 0 ifTrue:[^false].	(flags anyMask: 128) ifTrue:[		self processGlyphStateChange: flags from: data.	] ifFalse:[		self processGlyphEntries: flags from: data.	].	^true! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 7/15/1998 19:45'!processGlyphStateChange: flags from: data	| hasFont hasColor hasXOffset hasYOffset fontId color xOffset yOffset height |	hasFont _ flags anyMask: 8.	hasColor _ flags anyMask: 4.	hasYOffset _ flags anyMask: 2.	hasXOffset _ flags anyMask: 1.	hasFont ifTrue:[fontId _ data nextWord].	hasColor ifTrue:[color _ data nextColor].	hasXOffset ifTrue:[xOffset _ data nextWord].	hasYOffset ifTrue:[yOffset _ data nextWord].	hasFont ifTrue:[height _ data nextWord].	log ifNotNil:[		log nextPutAll:'['.		hasFont ifTrue:[log nextPutAll:' font='; print: fontId].		hasColor ifTrue:[log nextPutAll:' color='; print: color].		hasXOffset ifTrue:[log nextPutAll:' xOfs=';print: xOffset].		hasYOffset ifTrue:[log nextPutAll:' yOfs=';print: yOffset].		hasFont ifTrue:[log nextPutAll:' height='; print: height].		log nextPutAll:' ]'.		self flushLog.	].	self recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height.! !!FlashFileReader methodsFor: 'processing glyphs' stamp: 'ar 10/15/1998 03:23'!processGlyphsFrom: data	| id bounds matrix |	id _ data nextWord.	bounds _ data nextRect.	matrix _ data nextMatrix.	self recordTextStart: id bounds: bounds matrix: matrix.	nGlyphBits _ data nextByte.	nAdvanceBits _ data nextByte.	log ifNotNil:[		log	nextPutAll:'(nGlyphBits = '; 			print: nGlyphBits; 			nextPutAll:' nAdvanceBits = '; 			print: nAdvanceBits;			nextPutAll:') '.		self flushLog].	[self processGlyphRecordFrom: data] whileTrue.	self recordTextEnd: id.! !!FlashFileReader methodsFor: 'processing buttons' stamp: 'ar 7/15/1998 19:19'!processButtonRecords: id from: data	| flags state characterId layer matrix |	[flags _ data nextByte.	flags = 0] whileFalse:[		state _ flags bitAnd: 15.		characterId _ data nextWord.		layer _ data nextWord.		matrix _ data nextMatrix.		self recordButton: id character: characterId state: state layer: layer matrix: matrix].! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGetURL: data	| length position urlString winString |	length _ data nextWord.	position _ data position.	urlString _ data nextString.	winString _ data nextString.	data position = (position + length) ifFalse:[		self halt.		data position: position.		^self processUnknownAction: data].	log ifNotNil:[		log 			nextPutAll:' url='; print: urlString;			nextPutAll:', win='; print: winString].	^Message selector: #getURL:window: arguments: (Array with: urlString with: winString)! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGotoFrame: data	| length frame |	length _ data nextWord.	length = 2 ifFalse:["There is something wrong here"		self halt.		data skip: -2.		^self processUnknownAction: data].	frame _ data nextWord.	log ifNotNil:[log nextPutAll:' frame = '; print: frame.].	^Message selector: #gotoFrame: argument: frame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionGotoLabel: data	| length label |	self halt.	length _ data nextWord.	label _ data nextString.	log ifNotNil:[log nextPutAll:' label = '; print: label].	^Message selector: #gotoLabel: argument: label! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionNextFrame: data	^Message selector: #gotoNextFrame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionPlay: data	^Message selector: #play! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionPrevFrame: data	^Message selector: #gotoPrevFrame! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 7/15/1998 19:39'!processActionRecordsFrom: data	| code actionList action |	actionList _ OrderedCollection new.	[code _ data nextByte.	code = 0] whileFalse:[		code _ code bitAnd: 127. "Mask out the length-follow flag"		log ifNotNil:[			log cr; nextPutAll:'	Action #'; print: code.			log nextPutAll:' ('; nextPutAll: (ActionTable at: code); nextPutAll:')'].		action _ self dispatch: data on: code in: ActionTable 					ifNone:[self processUnknownAction: data].		action ifNotNil:[actionList add: action].		log ifNotNil:[self flushLog].	].	^actionList! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionSetTarget: data	| length target |	self halt.	length _ data nextWord.	target _ data nextString.	log ifNotNil:[log nextPutAll:' target = '; print: target].	^Message selector: #actionTarget: argument: target.! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionStop: data	^Message selector: #stop! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionStopSounds: data	^Message selector: #stopSounds! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionToggleQuality: data	^Message selector: #toggleQuality! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 8/17/1998 10:10'!processActionWaitForFrame: data	| length frame skip |	length _ data nextWord.	length = 3 ifFalse:["Something is wrong"		self halt.		data skip: -2.		^self processUnknownAction: data].	frame _ data nextWord.	skip _ data nextByte.	log ifNotNil:[		log nextPutAll:'frame = '; print: frame;			nextPutAll:', skip = '; print: skip].	^Message selector: #isFrameLoaded:elseSkip: arguments: (Array with: frame with: skip).! !!FlashFileReader methodsFor: 'processing actions' stamp: 'ar 7/15/1998 19:37'!processUnknownAction: data	| code length |	data skip: -1. "For determining the length of the action"	code _ data nextByte.	(code anyMask: 128) ifTrue:["Two byte length following"		length _ data nextWord.		data skip: length].	log ifNotNil:[log nextPutAll:'*** skipped ***'].	^nil! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 10/15/1998 02:17'!decompressSound: aByteArray stereo: stereo samples: numSamples rate: samplingRate	| data buffers nBits signMask indexTable channels valPred index vp idx delta step vpdiff allButSignMask sound k k0 |	data _ FlashFileStream on: (ReadStream on: aByteArray).	data initBits.	nBits _ (data nextBits: 2) + 2.	signMask _ 1 bitShift: nBits - 1.	allButSignMask _ signMask bitInvert32.	k0 _ 1 bitShift: (nBits - 2).	indexTable _ IndexTables at: nBits - 1.	channels _ stereo ifTrue:[2] ifFalse:[1].	buffers _ Array new: channels.	1 to: channels do:[:i| 		buffers at: i put: 			(WriteStream on: ((SoundBuffer newMonoSampleCount: numSamples)))].	valPred _ IntegerArray new: channels.	index _ IntegerArray new: channels.	1 to: numSamples do:[:nOut|		(nOut bitAnd: 16rFFF) = 1 ifTrue:["New block header starts every 4KB"			1 to: channels do:[:i|				vp _ data nextSignedBits: 16.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.				"First sample has no delta"				index at: i put: (data nextBits: 6).			].		] ifFalse:[ "Decode next sample"			1 to: channels do:[:i|				vp _ valPred at: i.				idx _ index at: i.				"Get next delta value"				delta _ data nextBits: nBits.				"Compute difference and new predicted value"				"Computes 'vpdiff = (delta+0.5)*step/4"				step _ StepTable at: idx + 1.				k _ k0.				vpdiff _ 0.				[	(delta bitAnd: k) = 0 ifFalse:[vpdiff _ vpdiff + step].					step _ step bitShift: -1.					k _ k bitShift: -1.					k = 0] whileFalse.				(delta anyMask: signMask) 					ifTrue:[vp _ vp - vpdiff]					ifFalse:[vp _ vp + vpdiff].				"Compute new index value"				idx _ idx + (indexTable at: (delta bitAnd: allButSignMask) + 1).				"Clamp index"				idx < 0 ifTrue:[idx _ 0].				idx > 88 ifTrue:[idx _ 88].				"Clamp output value"				vp < -32768 ifTrue:[vp _ -32768].				vp > 32767 ifTrue:[vp _ 32767].				"Store values back"				index at: i put: idx.				valPred at: i put: vp.				(buffers at: i) nextPut: vp.			]		].	].	1 to: channels do:[:i|		sound _ SampledSound samples:  (buffers at: i) contents samplingRate: samplingRate.		buffers at: i put: sound.	].	stereo ifTrue:[		^ MixedSound new			add: (buffers at: 1) pan: 0.0;			add: (buffers at: 2) pan: 1.0;			yourself.	] ifFalse:[		^buffers at: 1	].! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 8/10/1998 15:37'!processEnvelopeFrom: data	| env |	env _ FlashSoundEnvelope new.	env mark44: data nextULong.	env level0: data nextWord.	env level1: data nextWord.	^env! !!FlashFileReader methodsFor: 'processing sounds' stamp: 'ar 8/10/1998 16:11'!processSoundInfoFrom: data	| flags info nPoints |	flags _ data nextByte.	info _ FlashSoundInformation new.	info syncFlags: (flags bitShift: -4).	(flags anyMask: 1) ifTrue:[info inPoint: data nextULong].	(flags anyMask: 2) ifTrue:[info outPoint: data nextULong].	(flags anyMask: 4) ifTrue:[info loopCount: data nextWord].	(flags anyMask: 8) ifTrue:[		nPoints _ data nextByte.		info envelopes: ((1 to: nPoints) collect:[:i| self processEnvelopeFrom: data]).	].	^info! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 14:02'!processDefineBits2: data	| id |	self halt.	id _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 14:02'!processDefineBits3: data	| id |	self halt.	id _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 16:31'!processDefineBits: data	| id image |	id _ data nextWord.	image _ jpegDecoder decodeNextImageFrom: data.	"image display."	self recordBitmap: id data: image.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 22:30'!processDefineBitsLossless2: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 22:29'!processDefineBitsLossless: data	| id format width height |	id _ data nextWord.	format _ data nextByte.	width _ data nextWord.	height _ data nextWord.	self recordBitmap: id data: nil.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/14/1998 12:11'!processDefineButton2: data	| id flags actions actionOffset condition |	true ifTrue:[^true].	data hasAlpha: true.	id _ data nextWord.	flags _ data nextByte.	self recordButton: id trackAsMenu: flags = 0.	self halt. "Hier fehlt die CXFORM[nCharacters in button]"	self processButtonRecords: id from: data.	[actionOffset _ data nextWord.	actionOffset = 0] whileFalse:[		condition _ data nextWord.		actions _ self processActionRecordsFrom: data.		self recordButton: id actions: actions condition: condition].	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:40'!processDefineButton: data	| id actions |	id _ data nextWord.	self processButtonRecords: id from: data.	actions _ self processActionRecordsFrom: data.	self recordButton: id actions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 8/10/1998 16:18'!processDefineButtonSound: data	| id soundID soundInfo |	id _ data nextWord.	#(0 1 2 3) do:[:state|		soundID _ data nextWord.		soundID = 0 ifFalse:[			soundInfo _ self processSoundInfoFrom: data.			self recordButton: id sound: soundID info: soundInfo state: state]].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 03:18'!processDefineFont: data	| fontId firstOffset offsets nShapes |	fontId _ data nextWord.	firstOffset _ data nextWord.	nShapes _ firstOffset // 2.	offsets _ Array new: nShapes.	offsets at: 1 put: firstOffset.	2 to: nShapes do:[:i| offsets at: i put: data nextWord].	self recordFontBegin: fontId with: nShapes.	1 to: nShapes do:[:i|		log ifNotNil:[log cr; nextPutAll:'Glyph '; print: i].		self recordFontShapeStart: fontId with: i.		self processFontShapeFrom: data.		self recordFontShapeEnd: fontId with: i].	data atEnd ifFalse:[self halt].	self recordFontEnd: fontId.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/13/1998 23:52'!processDefineShape2: data	self processShapesFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:48'!processDefineShape3: data	data hasAlpha: true.	self processShapesFrom: data.	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/13/1998 23:22'!processDefineShape: data	self processShapesFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 03:04'!processDefineSound: data	| flags sampleCount sampleData id stereo bitsPerSample rate compressed sound |	id _ data nextWord.	flags _ data nextByte.	stereo _ (flags anyMask: 1).	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	rate _ #( 5512 11025 22050 44100 ) at: (flags >> 2 bitAnd: 3)+1.	compressed _ flags anyMask: 16.	sampleCount _ data nextULong.	sampleData _ data upToEnd.	compressed ifTrue:[		Cursor wait showWhile:[			sound _ self decompressSound: sampleData 						stereo: stereo 						samples: sampleCount 						rate: rate.		].	] ifFalse:[		self halt.		sound _ nil.	].	self recordSound: id data: sound.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:47'!processDefineText2: data	data hasAlpha: true.	self processGlyphsFrom: data.	data hasAlpha: false.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 23:23'!processDefineText: data	self processGlyphsFrom: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:40'!processDoAction: data	| actions |	actions _ self processActionRecordsFrom: data.	self recordFrameActions: actions.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:30'!processEnd: data	"At end of data"	^false! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:31'!processFrameLabel: data	| name |	name _ data nextString.	self recordFrameLabel: name.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 8/10/1998 15:55'!processFreeCharacter: data	| id |	id _ data nextWord.	data atEnd ifFalse:[self halt].	self recordFreeCharacter: id.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/1/1998 15:27'!processJPEGTables: data	jpegDecoder _ FlashJPEGDecoder new.	jpegDecoder decodeJPEGTables: data.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/14/1998 20:18'!processPlaceObject2: data	| id flags depth matrix cxForm ratio name move |	flags _ data nextByte.	depth _ data nextWord.	move _ (flags anyMask: 1).	(flags anyMask: 2) ifTrue:[id _ data nextWord].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[cxForm _ data nextColorMatrix].	(flags anyMask: 16) ifTrue:["self halt." ratio _ data nextWord].	(flags anyMask: 32) ifTrue:["self halt." name _ data nextString].	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' name = ', name printString,' depth = ', depth printString, ' move: ', move printString, ')'.		self flushLog].	move ifTrue:[self recordRemoveObject: nil depth: depth].	self recordPlaceObject: id depth: depth matrix: (matrix ifNil:[MatrixTransform2x3 identity]) colorMatrix: cxForm.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/15/1998 19:46'!processPlaceObject: data	| id depth matrix colorMatrix |	id _ data nextWord.	depth _ data nextWord.	matrix _ data nextMatrix.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	data atEnd ifFalse:[colorMatrix _ data nextColorMatrix].	self recordPlaceObject: id depth: depth matrix: matrix colorMatrix: colorMatrix.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:32'!processProtect: data	self recordProtection.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/13/1998 00:20'!processRemoveObject2: data	| depth |	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: nil depth: depth.	data atEnd ifFalse:[self halt].	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/13/1998 00:19'!processRemoveObject: data	| id depth |	id _ data nextWord.	depth _ data nextWord.	log ifNotNil:[		log nextPutAll:' (id = ', id printString,' depth = ', depth printString, ')'.		self flushLog].	self recordRemoveObject: id depth: depth.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:33'!processSetBackgroundColor: data	| color |	color _ data nextColor.	self recordBackgroundColor: color.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:34'!processShowFrame: data	"Show the current frame"	self recordShowFrame.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 02:28'!processSoundStreamBlock: data	self halt.	self recordSoundStreamBlock: data upToEnd.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 11/3/1998 13:43'!processSoundStreamHead2: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 21:23'!processSoundStreamHead: data	| mixFmt flags stereo bitsPerSample compressed sampleCount |	mixFmt _ data nextByte.	flags _ data nextByte.	stereo _ flags anyMask: 1.	bitsPerSample _ (flags anyMask: 2) ifTrue:[16] ifFalse:[8].	compressed _ (flags bitShift: -4) = 1.	sampleCount _ data nextWord.	self recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 10/15/1998 02:47'!processStartSound: data	| id info |	id _ data nextWord.	info _ self processSoundInfoFrom: data.	self recordStartSound: id info: info.	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/4/1998 20:34'!processUnknown: data	"An unknown tag has been encountered"	^true! !!FlashFileReader methodsFor: 'processing tags' stamp: 'ar 7/3/1998 18:49'!tagPlaceObject2: data	| flags id depth matrix colorMatrix ratio name clipDepth |	flags _ data nextByte.	depth _ data nextWord.	(flags anyMask: 2) 		ifTrue:[id _ data nextWord]		ifFalse:[(flags anyMask:1) "sanity check"					ifFalse:[self error:'Either move or character must be specified']].	(flags anyMask: 4) ifTrue:[matrix _ data nextMatrix].	(flags anyMask: 8) ifTrue:[colorMatrix _ data nextColorMatrix: true].	(flags anyMask: 16) ifTrue:[ratio _ stream nextWord].	(flags anyMask: 32) ifTrue:[name _ stream nextString].	(flags anyMask: 64) ifTrue:[clipDepth _ stream nextWord].	(flags anyMask: 128) ifTrue:[self warn:'Unknown tagPlaceObject flag'].	^true! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/3/1998 18:55'!dispatch: argument on: aKey in: aTable ifNone: exceptionBlock	| selector |	(aKey < 1 or:[aKey > aTable size]) ifTrue:[^exceptionBlock value].	selector _ aTable at: aKey.	^(self respondsTo: selector) ifTrue:[		self perform: selector with: argument.	] ifFalse:[exceptionBlock value]! !!FlashFileReader methodsFor: 'private' stamp: 'ar 11/5/1998 23:42'!flushLog	(log == Transcript) ifTrue:[		log endEntry.		Sensor leftShiftDown ifTrue:[self halt].	].! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/2/1998 20:37'!maximumSupportedVersion	^3! !!FlashFileReader methodsFor: 'private' stamp: 'ar 7/12/1998 23:41'!warn: aString	Transcript cr; show: aString.! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:46'!recordCurveSegmentTo: anchorPoint with: controlPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:39'!recordFillStyle0: fillIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:39'!recordFillStyle1: fillIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 20:56'!recordLineSegmentBy: deltaPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/8/1998 15:56'!recordLineSegmentHorizontalBy: deltaX	^self recordLineSegmentBy: (deltaX@0)! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/8/1998 15:56'!recordLineSegmentVerticalBy: deltaY	^self recordLineSegmentBy: (0@deltaY)! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:48'!recordLineStyle: styleIndex! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:47'!recordMoveTo: aPoint! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 10/14/1998 00:19'!recordResetSubshape! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:59'!recordShapeEnd: shapeId! !!FlashFileReader methodsFor: 'composing shapes' stamp: 'ar 7/4/1998 19:59'!recordShapeStart: shapeId bounds: shapeBounds! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 18:50'!recordFontBegin: fontId with: nGlyphs! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 18:50'!recordFontEnd: fontId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordFontShapeEnd: fontId with: charId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordFontShapeStart: fontId with: charId! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:09'!recordNextChar: glyphIndex advanceWidth: advance! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:08'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:16'!recordTextEnd: id! !!FlashFileReader methodsFor: 'defining text' stamp: 'ar 7/13/1998 01:16'!recordTextStart: id bounds: bounds matrix: matrix! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 11/13/1998 20:31'!recordBitmapFill: fillIndex matrix: bmMatrix id: bitmapID clipped: aBoolean! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:52'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:55'!recordLineStyle: styleIndex width: lineWidth color: lineColor! !!FlashFileReader methodsFor: 'defining styles' stamp: 'ar 7/4/1998 19:48'!recordSolidFill: index color: fillColor! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:22'!recordButton: buttonId actions: actionList	"Associate an action list with the given button"	^self recordButton: buttonId actions: actionList condition: 8. "OverDownToOverUp"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:34'!recordButton: buttonId actions: actionList condition: condition	"Associate an action list with the given button:		buttonId:	global ID of the button		actions:		Collection of MessageSends (e.g., actions)		condition:	bit mask describing when the actions should be applied					General conditions:						1 - IdleToOverUp (Mouse enter up)						2 - OverUpToIdle (Mouse exit up)						4 - OverUpToOverDown (Mouse down)						8 - OverDownToOverUp (Mouse up in)					Push button conditions:						16 - OverDownToOutDown (Mouse exit down)						32 - OutDownToOverDown (Mouse enter down)						64 - OutDownToIdle (Mouse up out)					Menu button conditions:						128 - IdleToOverDown (Mouse enter down)						256 - OverDownToIdle (Mouse exit down)"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 19:57'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix	"Define the character to use for a button.		buttonId:	global ID used for the button		characterId:	ID of the character defining the shape for the button		state:		bit mask for when to use the character						1 - default (e.g. no other state applies)						2 - display when the mouse is over the button but not pressed						4 - display when the button is pressed						8 - the area in which the mouse is supposed to be 'over' the button		layer:		UNKNOWN.		matrix:		Transformation to apply to the character. (Guess!!)"! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 8/10/1998 15:51'!recordButton: id sound: soundId info: soundInfo state: state! !!FlashFileReader methodsFor: 'defining buttons' stamp: 'ar 7/15/1998 20:06'!recordButton: id trackAsMenu: aBoolean	"Track the button with the given ID as a menu (in contrast to a push) button. Push buttons capture the mouse until the button is released. Menu buttons don't.	Note: If defined for a button, this method will be called prior to any other #recordButton: methods."! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 10/15/1998 02:36'!recordSound: id data: aSampledSound! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:47'!recordSound: id data: sampleData stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount rate: rate compressed: compressed! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:41'!recordSoundStreamBlock: compressedData! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:45'!recordSoundStreamHead: mixFmt stereo: stereo bitsPerSample: bitsPerSample sampleCount: sampleCount compressed: compressed! !!FlashFileReader methodsFor: 'defining sounds' stamp: 'ar 8/10/1998 15:41'!recordStartSound: id info: info! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:33'!recordBackgroundColor: aColor! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:27'!recordBitmap: bitmapId data: aForm! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/15/1998 19:41'!recordFrameActions: actionList	"Record the list of actions executed at the next showFrame"! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:31'!recordFrameLabel: aString! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 8/10/1998 18:23'!recordFrameRate: fps! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/15/1998 20:30'!recordFreeCharacter: id	"Free the character with the given id.	Not documented."! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/10/1998 15:51'!recordGlobalBounds: bounds! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:32'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:32'!recordProtection! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 22:34'!recordRemoveObject: id depth: depth! !!FlashFileReader methodsFor: 'misc' stamp: 'ar 7/4/1998 20:34'!recordShowFrame! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:18'!initialize	"FlashFileReader initialize"	self initializeTagTable.	self initializeActionTable.	self initializeStepTable.	self initializeIndexTables.! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 7/15/1998 18:53'!initializeActionTable	"Create and return a new SWF action table"	"FlashFileReader initializeActionTable"	ActionTable _ Array new: 12.	ActionTable atAllPut: #processUnknownAction:.	#(		(processActionGotoFrame:	1)		(processActionGetURL:		3)		(processActionNextFrame:	4)		(processActionPrevFrame:	5)		(processActionPlay:			6)		(processActionStop:			7)		(processActionToggleQuality:	8)		(processActionStopSounds:	9)		(processActionWaitForFrame:	10)		(processActionSetTarget:		11)		(processActionGotoLabel:		12)	) do:[:spec|			ActionTable at: spec last put: spec first.	].! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:18'!initializeIndexTables	IndexTables _ Array new: 4.	IndexTables at: 1 put:		#(-1 2).	IndexTables at: 2 put:		#(-1 -1 2 4).	IndexTables at: 3 put:		#(-1 -1 -1 -1 2 4 6 8).	IndexTables at: 4 put:		#(-1 -1 -1 -1 -1 -1 -1 -1 1 2 4 6 8 10 13 16).! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 10/15/1998 01:15'!initializeStepTable	StepTable _ #(7 8 9 10 11 12 13 14 16 17					19 21 23 25 28 31 34 37 41 45					50 55 60 66 73 80 88 97 107 118					130 143 157 173 190 209 230 253 279 307					337 371 408 449 494 544 598 658 724 796					876 963 1060 1166 1282 1411 1552 1707 1878 2066					2272 2499 2749 3024 3327 3660 4026 4428 4871 5358					5894 6484 7132 7845 8630 9493 10442 11487 12635 13899					15289 16818 18500 20350 22385 24623 27086 29794 32767).! !!FlashFileReader class methodsFor: 'class initialization' stamp: 'ar 8/10/1998 15:53'!initializeTagTable	"Create and return a new SWF tag table"	"FlashFileReader initializeTagTable"	TagTable _ Array new: 50.	TagTable atAllPut: #processUnknown:.	#(	(processEnd:					0)	(processShowFrame:			1)	(processDefineShape:		2)	(processFreeCharacter:		3)	(processPlaceObject:			4)	(processRemoveObject:		5)	(processDefineBits:			6)	(processDefineButton:		7)	(processJPEGTables:			8) "NYI"	(processSetBackgroundColor:	9)	(processDefineFont:			10)	(processDefineText:			11)	(processDoAction:			12)	(processDefineFontInfo:		13) "NYI"	"Event sound tags."	(processDefineSound:		14)	(processStartSound:			15)	(processDefineButtonSound:	17)	(processSoundStreamHead:	18)	(processSoundStreamBlock:	19)	(processDefineBitsLossless:	20)	"A bitmap using lossless zlib compression."	(processDefineBitsJPEG2:		21)	"NYI" "A bitmap using an internal JPEG compression table"	(processDefineShape2:		22)	(processDefineButtonCxform:	23) "NYI"	(processProtect:				24)	"This file should not be importable for editing."	"These are the new tags for Flash 3."	(processPlaceObject2:			26)	"NYI" "The new style place w/ alpha color transform and name."	(processRemoveObject2:		28)	"A more compact remove object that omits the character tag (just depth)."	(processDefineShape3:		32)	"A shape V3 includes alpha values."	(processDefineText2:			33) "A text V2 includes alpha values."	(processDefineButton2:		34)	"A button V2 includes color transform) alpha and multiple actions"	(processDefineBitsJPEG3:		35)	"NYI" "A JPEG bitmap with alpha info."	(processDefineBitsLossless2:	36)	"NYI" "A lossless bitmap with alpha info."	(processDefineSprite:		39) "NYI" "Define a sequence of tags that describe the behavior of a sprite."	(processNameCharacter:		40) "NYI" "Name a character definition, character id and a string, (used for buttons) bitmaps, sprites and sounds)."	(processFrameLabel:			43) "A string label for the current frame."	(processSoundStreamHead2:	45) "For lossless streaming sound, should not have needed this..."	(processDefineMorphShape:	46) "NYI" "A morph shape definition"	(processDefineFont2:			48) "NYI"	) do:[:spec|			TagTable at: spec last+1 put: spec first.	].! !!FlashFileReader class methodsFor: 'instance creation' stamp: 'ar 7/3/1998 19:04'!fileNamed: aString	"FlashFileReader fileNamed:'/home/isg/raab/WDI/flash/samples/top.swf'"	^self on: (FileStream readOnlyFileNamed: aString).! !!FlashFileReader class methodsFor: 'instance creation' stamp: 'ar 7/2/1998 19:53'!on: aStream	^self new on: aStream! !!FlashFileReader class methodsFor: 'testing' stamp: 'ar 7/2/1998 20:30'!canRead: aStream	"Return true if instances of the receiver know how to handle the data from aStream."	| ok pos |	pos _ aStream position.	ok _ aStream next asCharacter = $F and:[			aStream next asCharacter  = $W and:[				aStream next asCharacter = $S]].	aStream position: pos.	^ok! !!FlashFileReader class methodsFor: 'accessing' stamp: 'ar 10/16/1998 00:29'!tagTable	^TagTable! !!FlashFileStream methodsFor: 'initialize' stamp: 'ar 7/15/1998 20:10'!on: aSourceStream	stream _ aSourceStream.	bitBuffer _ bitPosition _ 0.	hasAlpha _ false. "Turn on if needed"! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:48'!atEnd	^stream atEnd! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:44'!close	self flushBits.	stream close! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:46'!hasAlpha	^hasAlpha! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:46'!hasAlpha: aBoolean	hasAlpha _ aBoolean! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:23'!next	"Make sure the bit buffer is reset"	self initBits.	^stream next! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/13/1998 00:40'!nextByte	"Make sure the bit buffer is reset"	self initBits.	^stream next! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:24'!nextByteForBits	^stream next ifNil:[0]! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:19'!nextByteForBitsPut: aByte	^stream nextPut: aByte! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/16/1998 01:27'!nextBytePut: aByte	"Make sure the bit buffer is reset"	self flushBits.	stream nextPut: aByte! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:50'!nextBytes: n	"Return a ByteArray containing the next n bytes"	^stream next: n! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:43'!peekFor: anObject	^stream peekFor: anObject! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 18:00'!position	^stream position! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 10/1/1998 14:56'!position: aNumber	stream position: aNumber.! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 18:00'!size	^stream size! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/15/1998 19:01'!skip: nBytes	self initBits.	stream skip: nBytes! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 7/3/1998 17:48'!stream	^stream! !!FlashFileStream methodsFor: 'accessing' stamp: 'ar 8/10/1998 14:18'!upToEnd	^self stream upToEnd.! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:38'!initBits	"Initialize the bit buffer for future bit reading operations.	Note: We do not fetch the first byte here so we can do multiple #initBits	without harming the position of the input stream."	bitPosition _ bitBuffer _ 0.! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 21:39'!nextBitFlag	^(self nextBits: 1) = 1! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/4/1998 18:27'!nextBits: n	"Return the next n bits"	| shift value remaining |	n = 0 ifTrue:[^0].	(n between: 1 and: 32) ifFalse:[^self error:'Bad number of bits'].	value _ 0.	remaining _ n.	[true] whileTrue:[		shift _ remaining - bitPosition.		value _ value bitOr: (bitBuffer bitShift: shift).		shift > 0 ifTrue:["Consumes entire buffer"			remaining _ remaining - bitPosition.			"And get next byte"			bitBuffer _ self nextByteForBits.			bitPosition _ 8.		] ifFalse:["Consumes a portion of the buffer"			bitPosition _ bitPosition - remaining.			"Mask off the consumed bits"			bitBuffer _ bitBuffer bitAnd: (255 bitShift: (bitPosition - 8)).			^value]].! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/15/1998 19:44'!nextColor	| r g b baseColor |	r _ self nextByte / 255.0.	g _ self nextByte / 255.0.	b _ self nextByte / 255.0.	baseColor _ Color r: r g: g b: b.	^hasAlpha 		ifTrue:[baseColor alpha: self nextByte / 255.0]		ifFalse:[baseColor]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 10/4/1998 18:06'!nextColorMatrix	"Read a (possibly compressed) color transformation"	| transform nBits flags |	transform _ FlashColorTransform new.	self initBits.	flags _ self nextBits: 2.	nBits _ self nextBits: 4.	(flags anyMask: 1) ifTrue:["Read multiplication factors"		transform rMul: (self nextSignedBits: nBits).		transform gMul: (self nextSignedBits: nBits).		transform bMul: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aMul: (self nextSignedBits: nBits)]].	(flags anyMask: 2) ifTrue:["Read multiplication factors"		transform rAdd: (self nextSignedBits: nBits).		transform gAdd: (self nextSignedBits: nBits).		transform bAdd: (self nextSignedBits: nBits).		hasAlpha ifTrue:[transform aAdd: (self nextSignedBits: nBits)]].	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 10/16/1998 00:47'!nextLong	| ulong |	ulong _ self nextULong.	^ulong > 16r80000000		ifTrue:[ulong - 16r100000000]		ifFalse:[ulong]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 11/2/1998 23:00'!nextMatrix	"Read a (possibly compressed) transformation matrix"	| transform nBits |	transform _ MatrixTransform2x3 identity.	self initBits.	(self nextBits: 1) = 1 ifTrue:["Read a,d"		nBits _ self nextBits: 5.		transform a11: (self nextSignedBits: nBits) / 65536.0.		transform a22: (self nextSignedBits: nBits) / 65536.0].	(self nextBits: 1) = 1 ifTrue:["Read b,c"		nBits _ self nextBits: 5.		transform a12: (self nextSignedBits: nBits) / 65536.0.		transform a21: (self nextSignedBits: nBits) / 65536.0].	"Read tx, ty"	nBits _ self nextBits: 5.	"Transcript cr; show:'nBits = ', nBits printString, ' from ', thisContext sender printString."	transform a13: (self nextSignedBits: nBits) asFloat.	transform a23: (self nextSignedBits: nBits) asFloat.	^transform! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/4/1998 18:42'!nextPoint	"Read a (possibly compressed) point"	| nBits point |	nBits _ self nextBits: 5.	point _ (self nextSignedBits: nBits) @ (self nextSignedBits: nBits).	^point! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:41'!nextRect	"Read a (possibly compressed) rectangle"	| nBits xMin xMax yMin yMax |	self initBits.	nBits _ self nextBits: 5.	xMin _ self nextSignedBits: nBits.	xMax _ self nextSignedBits: nBits.	yMin _ self nextSignedBits: nBits.	yMax _ self nextSignedBits: nBits.	^(xMin@yMin) corner: (xMax@yMax).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 19:11'!nextSignedBits: n	"Return the next n bits as signed integer value"	| value bits signBit |	n = 0 ifTrue:[^0].	value _ self nextBits: n.	"Use a lookup for determining whether or not the value should be sign extended"	bits _ #( 1 2 4 8 16 32 64 128 "1 ... 8"			256 512 1024 2048 4096 8192 16384 32768 "9 ... 16"			65536 131072 262144 524288 1048576 2097152 4194304 8388608 "17 ... 24"			16777216 33554432 67108864 134217728 268435456 536870912 1073741824 2147483648 "25 ... 32"			 4294967296 "33 bit -- for negation only" ).	signBit _ bits at: n.	^(value bitAnd: signBit) = 0		ifTrue:[value]		ifFalse:[value - (bits at: n+1)]! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextString	| out byte |	out _ WriteStream on: (String new: 50).	[byte _ self nextByte.	byte = 0] whileFalse:		[out nextPut: (self convertChar2Squeak: byte asCharacter)].	^out contents! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:44'!nextTag	"Read the next tag. Return an association with the key being the tag id and its value the contents of the chunk following."	| word tag length |	word _ self nextWord.	"Extract tag and length from the word"	length _ word bitAnd: 16r3F.	tag _ word bitShift: -6.	"Check if an extra word follows"	length = 16r3F ifTrue:[length _ self nextULong].	^Association key: tag value: (self nextBytes: length).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextULong	^self nextByte + 		(self nextByte bitShift: 8) + 		(self nextByte bitShift: 16) + 		(self nextByte bitShift: 24).! !!FlashFileStream methodsFor: 'reading data' stamp: 'ar 7/3/1998 17:40'!nextWord	^self nextByte + (self nextByte bitShift: 8)! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:27'!flushBits	"Flush the bit buffer for future bit writing operations."	bitPosition = 0 ifFalse:[self nextByteForBitsPut: bitBuffer].	bitPosition _ 0.	bitBuffer _ 0.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:36'!nextBitFlag: aBoolean	^self nextBits: 1 put: (aBoolean ifTrue:[1] ifFalse:[0])! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:41'!nextBits: n put: aNumber	"Write the next n bits"	| value remaining shift |	value _ aNumber. "Do not round - this is a sanity check"	value isInteger ifFalse:[^self error:'Not an integer number'].	value < 0 ifTrue:[^self error:'Not a positive number'].	n = 0 ifTrue:[^0].	(n between: 1 and: 32) ifFalse:[^self error:'Bad number of bits'].	value < (1 bitShift: n) ifFalse:[^self error:'Unable to represent number'].	remaining _ n.	[true] whileTrue:[		shift _ 8 - bitPosition - remaining.		bitBuffer _ bitBuffer + (value bitShift: shift).		"Mask out consumed bits"		value _ value bitAnd: (1 bitShift: 0-shift) - 1.		shift < 0 ifTrue:["Buffer overflow"			remaining _ remaining - (8 - bitPosition).			"Store next byte"			self nextByteForBitsPut: bitBuffer.			bitBuffer _ 0.			bitPosition _ 0.		] ifFalse:["Store only portion of the buffer"			bitPosition _ bitPosition + remaining.			^self		].	].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:44'!nextColorMatrixPut: cm	"Write a (possibly compressed) color transformation"	self flushBits.	self nextBits: 2 put: 3. "Always write full transform"	self mextBits: 4 put: 15. "Always use full accuracy"	self nextSignedBits: 15 put: cm rMul.	self nextSignedBits: 15 put: cm gMul.	self nextSignedBits: 15 put: cm bMul.	hasAlpha ifTrue:[self nextSignedBits: 15 put: cm aMul].	self nextSignedBits: 15 put: cm rAdd.	self nextSignedBits: 15 put: cm gAdd.	self nextSignedBits: 15 put: cm bAdd.	hasAlpha ifTrue:[self nextSignedBits: 15 put: cm aAdd].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:38'!nextColorPut: aColor	self nextBytePut: (aColor red * 255) rounded.	self nextBytePut: (aColor green * 255) rounded.	self nextBytePut: (aColor blue * 255) rounded.	hasAlpha ifTrue:[self nextBytePut: (aColor alpha * 255) rounded].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:46'!nextLongPut: value	value < 0 		ifTrue:[self nextULongPut: 16r100000000 - value]		ifFalse:[self nextULongPut: value]! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 11/2/1998 23:00'!nextMatrixPut: matrix	"write a (possibly compressed) transformation matrix"	self flushBits.	(matrix a11 = 0.0 and:[matrix  a22 = 0.0]) ifFalse:[		"Write a/d"		self nextBits: 1 put: 1.		self nextBits: 5 put: 31. "Always use full accuracy"		self nextSignedBits: 31 put: matrix a11 * 65536.		self nextSignedBits: 31 put: matrix a22 * 65536.	] ifTrue:[self nextBits: 1 put: 0].	((matrix a12) = 0.0 and:[(matrix  a21) = 0.0]) ifFalse:[		"Write b/c"		self nextBits: 1 put: 1.		self nextBits: 5 put: 31. "Always use full accuracy"		self nextSignedBits: 31 put: matrix a12 * 65536.		self nextSignedBits: 31 put: matrix a21 * 65536.	] ifTrue:[self nextBits: 1 put: 0].	"Write tx/ty"	self nextBits: 5 put: 31. "Always use full accuracy"	self nextSignedBits: 31 put: matrix a13.	self nextSignedBits: 31 put: matrix a23.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:55'!nextPointPut: aPoint	"Write a (possibly compressed) point"	self nextBits: 5 put: 31. "Always write full accuracy"	self nextSignedBits: 31 put: aPoint x.	self nextSignedBits: 31 put: aPoint y.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:29'!nextRectPut: aRect	"Write a (possibly compressed) rectangle"	self nextBits: 5 put: 31. "Always use full accuracy"	self nextSignedBits: 31 put: aRect origin x.	self nextSignedBits: 31 put: aRect corner x.	self nextSignedBits: 31 put: aRect origin y.	self nextSignedBits: 31 put: aRect corner y.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 00:59'!nextSignedBits: n put: someValue	"Write the next n bits as signed integer value"	| value |	value _ someValue rounded. "Do rounding here if not done before"	value < 0		ifTrue:[self nextBits: n put: 16r100000000 - value]		ifFalse:[self nextBits: n put: value]! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:01'!nextStringPut: aString	aString do:[:char| self nextBytePut: (self convertCharFromSqueak: char) asInteger].	self nextBytePut: 0.! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:03'!nextTagPut: tag length: length	"Write the next tag."	length >= 16r3f ifTrue:[		self nextWordPut: (tag bitShift: 6) + 16r3F.		self nextULongPut: length.	] ifFalse:[		self nextWordPut: (tag bitShift: 6) + length.	].! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:04'!nextULongPut: long	self nextBytePut: (long bitAnd: 255).	self nextBytePut: ((long bitShift: -8) bitAnd: 255).	self nextBytePut: ((long bitShift: -16) bitAnd: 255).	self nextBytePut: ((long bitShift: -24) bitAnd: 255).! !!FlashFileStream methodsFor: 'writing data' stamp: 'ar 10/16/1998 01:06'!nextWordPut: value	self nextBytePut: (value bitAnd: 255).	self nextBytePut: ((value bitShift: -8) bitAnd: 255).! !!FlashFileStream methodsFor: 'private' stamp: 'ar 7/3/1998 18:17'!convertChar2Squeak: aCharacter	"Convert aCharacter from SWF char set (whatever this may be) to Squeaks char set"	^aCharacter! !!FlashFileStream methodsFor: 'private' stamp: 'ar 10/16/1998 01:01'!convertCharFromSqueak: aCharacter	"Convert aCharacter to SWF char set (whatever this may be) "	^aCharacter! !!FlashFileStream class methodsFor: 'instance creation' stamp: 'ar 7/3/1998 17:33'!on: aSourceStream	^self basicNew on: aSourceStream! !!FlashFileWriter methodsFor: 'initialize' stamp: 'ar 10/16/1998 01:23'!close	stream close! !!FlashFileWriter methodsFor: 'initialize' stamp: 'ar 10/16/1998 01:22'!on: aStream	aStream binary.	stream _ FlashFileStream on: aStream.! !!FlashFileWriter methodsFor: 'writing' stamp: 'ar 10/16/1998 01:26'!writeHeader: bounds rate: frameRate	"Read header information from the source stream.	Return true if successful, false otherwise."	self halt.	self writeSignature.	stream nextBytePut: 3. "Always write flash3"	dataSize _ stream nextLongPut: 0.	"Place holder for data size"	stream nextRectPut: bounds.	stream nextWordPut: (frameRate * 256) truncated.! !!FlashFileWriter methodsFor: 'writing' stamp: 'ar 10/16/1998 01:20'!writeSignature	stream nextBytePut: $F asInteger.	stream nextBytePut: $W asInteger.	stream nextBytePut: $S asInteger.! !!FlashFileWriter class methodsFor: 'class initialization' stamp: 'ar 10/16/1998 00:31'!initialize	"FlashFileWriter initialize"	TagTable _ Dictionary new.	FlashFileReader tagTable doWithIndex:[:tag :index|		TagTable at: (tag copyWithout: $:) asSymbol put: index	].! !!FlashFileWriter class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 01:23'!newFileNamed: aString	"FlashFileWriter newFileNamed:'f:\wdi\GraphicsEngine\flash\test.swf'"	^self on: (FileStream newFileNamed: aString).! !!FlashFileWriter class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 01:24'!on: aStream	^self new on: aStream! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 14:34'!decodeJPEGTables: aStream	self setStream: aStream.	eoiSeen _ false.	self parseFirstMarker.	[eoiSeen] whileFalse:[self parseNextMarker].! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 15:16'!decodeNextImageFrom: aStream	| image |	self setStream: aStream.	image _ Cursor wait showWhile:[self nextImage].	(stream position + 2 < stream size) ifTrue:[self halt].	^image! !!FlashJPEGDecoder methodsFor: 'decoding' stamp: 'ar 10/1/1998 14:34'!parseEndOfInput	eoiSeen _ true.! !!FlashJPEGDecoder methodsFor: 'stream access' stamp: 'ar 10/1/1998 14:42'!next	^stream nextByte! !!FlashJPEGDecoder methodsFor: 'stream access' stamp: 'ar 10/1/1998 14:43'!next: n	^stream nextBytes: n! !!FlashKeyframe reorganize!('initialize' from:to:data:)('accessing' data data: start start: stop stop:)('testing' contains:)('printing' printOn:)!!FlashKeyframe methodsFor: 'initialize' stamp: 'ar 11/12/1998 22:55'!from: startValue to: stopValue data: newData	start _ startValue.	stop _ stopValue.	data _ newData.! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:48'!data	^data! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:48'!data: anObject	data _ anObject! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!start	^start! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!start: startValue	start _ startValue! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!stop	^stop! !!FlashKeyframe methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:55'!stop: stopValue	stop _ stopValue! !!FlashKeyframe methodsFor: 'testing' stamp: 'ar 11/12/1998 22:56'!contains: aNumber	^aNumber >= start and:[aNumber <= stop]! !!FlashKeyframe methodsFor: 'printing' stamp: 'ar 11/13/1998 14:33'!printOn: aStream	aStream nextPutAll: self class name;		nextPut:$(;		print: start;		nextPut:$-;		print: stop;		nextPutAll:' -> ';		print: data;		nextPut:$)! !!FlashKeyframe class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 22:47'!from: startValue to: stopValue	^self new from: startValue to: stopValue! !!FlashKeyframe class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 22:54'!from: startValue to: stopValue data: newData	^self new from: startValue to: stopValue data: newData! !!FlashKeyframes methodsFor: 'initialize' stamp: 'ar 8/14/1998 19:32'!initialize	kfList _ OrderedCollection new.! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 23:05'!at: frameNumber	"Return data from the keyframe list at the given frame number"	| lastEntry |	kfList isEmpty ifTrue:[^nil].	lastIndex ifNil:[lastIndex _ self searchFor: frameNumber].	lastEntry _ kfList at: lastIndex.	(lastEntry contains: frameNumber) ifTrue:[^lastEntry data].	"Do a quick check if the frame is out of range"	kfList first stop >= frameNumber 		ifTrue:[	lastIndex _ 1.				^kfList first data].	kfList last start <= frameNumber 		ifTrue:[	lastIndex _ kfList size. 				^kfList last data].	"Search linearly from lastEntry - most times we'll just be one step away"	[lastEntry stop >= frameNumber] whileFalse:[		lastIndex _ lastIndex+1.		lastEntry _ kfList at: lastIndex].	[lastEntry start <= frameNumber] whileFalse:[		lastIndex _ lastIndex-1.		lastEntry _ kfList at: lastIndex].	^lastEntry data! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:51'!at: frameNumber put: newData	"Add newData to the keyframe list at the given frameNumber"	| kf |	kfList ifNil:[kfList _ OrderedCollection new].	kfList isEmpty ifFalse:["Check if we can extend the last interval"		kf _ kfList last.		kf stop < frameNumber 			ifFalse:[^self replaceData: newData at: frameNumber].		kf data = newData "Extend interval to include frameNumber"			ifTrue:[	kf stop: frameNumber.					^newData].		"Extend last interval to just before frameNumer"		kf stop: frameNumber - 1].	kfList add: (FlashKeyframe from: frameNumber to: frameNumber data: newData).	^newData! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 11/12/1998 22:51'!keys	^kfList collect:[:kf| kf start].! !!FlashKeyframes methodsFor: 'accessing' stamp: 'ar 10/14/1998 20:27'!size	^kfList size! !!FlashKeyframes methodsFor: 'printing' stamp: 'ar 8/14/1998 19:32'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		cr.	kfList do:[:item| aStream print: item; cr].	aStream nextPut:$).! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/12/1998 22:51'!replaceData: newData at: frameNumber	(kfList last stop = frameNumber) 		ifTrue:[^self replaceLastData: newData at: frameNumber].	self halt:'Not implemented yet'! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/13/1998 14:36'!replaceLastData: newData at: frameNumber	| kf |	kf _ kfList last.	(kf stop = kf start)		ifTrue:[kfList removeLast]		ifFalse:[kf stop: kf stop-1].	^self at: frameNumber put: newData! !!FlashKeyframes methodsFor: 'private' stamp: 'ar 11/12/1998 22:54'!searchFor: frameNumber	"Return data from the keyframe list at the given frame number"	| low high mid kf |	low _ kfList at: 1.	high _ kfList at: kfList size.	"Check if in or before first keyframe interval"	frameNumber <= low stop ifTrue:[^1].	"Check if in or after last keyframe interval"	frameNumber >= high start ifTrue:[^kfList size].	"Somewhere inbetween 2nd to (n-1)th interval"	low _ 2. high _ kfList size - 1.	[mid _ high + low // 2.	low > high] whileFalse:[		kf _ kfList at: mid.		(kf contains: frameNumber) ifTrue:[^mid].		(kf start < frameNumber)			ifTrue:[low _ mid + 1]			ifFalse:[high _ mid - 1]].	kf _ kfList at: low.	(kf contains: frameNumber) ifFalse:[self error:'No keyframe found'].	^low! !!FlashKeyframes class methodsFor: 'instance creation' stamp: 'ar 8/14/1998 19:32'!new	^super new initialize! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color	^color! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color: aColor	color _ aColor! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!color: aColor width: aNumber	self color: aColor.	self width: aNumber.! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!width	^width! !!FlashLineStyle methodsFor: 'accessing' stamp: 'ar 7/14/1998 21:20'!width: aNumber	width _ aNumber! !!FlashLineStyle methodsFor: 'comparing' stamp: 'ar 8/15/1998 00:59'!= aLineStyle	self class = aLineStyle class ifFalse:[^false].	^self color = aLineStyle color and:[self width = aLineStyle width].! !!FlashLineStyle class methodsFor: 'instance creation' stamp: 'ar 7/14/1998 21:19'!color: aColor width: aNumber	^self new color: aColor width: aNumber! !!FlashMorph class methodsFor: 'instance creation' stamp: 'ar 11/15/1998 16:44'!withAll: aCollection	^(self new) 		addAllMorphs: aCollection;		computeBounds;		yourself! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 10/15/1998 23:45'!doLog	^false! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 10/14/1998 19:22'!logShapes	^false! !!FlashMorphReader methodsFor: 'initialize' stamp: 'ar 11/12/1998 21:15'!on: aStream	super on: aStream.	self doLog ifTrue:[log _ Transcript].	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	shapes _ Dictionary new.	player _ FlashPlayerMorph new.	fonts _ Dictionary new.	forms _ Dictionary new.	sounds _ Dictionary new.	buttons _ Dictionary new.	stepTime _ 1000.	frame _ 1.	activeMorphs _ Dictionary new: 100.	passiveMorphs _ Dictionary new: 100.	self recordSolidFill: 1 color: Color black.	compressionBounds _ (-16r7FFF asPoint) corner: (16r8000) asPoint.	currentShape _ WriteStream on: (Array new: 5).	pointList _ WriteStream on: (Array new: 100).	leftFillList _ WriteStream on: (WordArray new: 100).	rightFillList _ WriteStream on: (WordArray new: 100).	lineStyleList _ WriteStream on: (WordArray new: 100).	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 10/13/1998 00:31'!processFile	"Read and process the entire file"	^self processFile: World.! !!FlashMorphReader methodsFor: 'reading' stamp: 'ar 11/16/1998 02:34'!processFile: aMorph	super processFile.	player frames: frame.	player position: player position // 20.	player extent: player extent // 20.	player loadInitialFrame.	player stepForward.	player stepBackward.	aMorph ifNil:[		player play.		^player openInMVC].	aMorph isWorldMorph ifTrue:[		"aMorph world activeHand attachMorph: player."		player openInWorld.	] ifFalse:[		aMorph addMorph: player.	].	^player! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/16/1998 01:23'!recordFontShapeEnd: fontId with: charId	| font shape |	self endShape.	shape _ FlashGlyphMorph withAll: currentShape contents reversed.	shape lockChildren.	currentShape resetToStart.	font _ fonts at: fontId ifAbsentPut:[Dictionary new].	font at: charId put: shape.	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/12/1998 21:39'!recordFontShapeStart: fontId with: charId	location _ 0@0.	self logShapes ifFalse:[log _ nil].	self beginShape.	self recordSolidFill: 1 color: Color black.! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/15/1998 17:17'!recordNextChar: glyphIndex advanceWidth: advance	| shape |	(activeFont includesKey: glyphIndex) ifTrue:[		shape _ (activeFont at: glyphIndex) fullCopy reset.		shape transform: ((MatrixTransform2x3 withOffset: textPosition) 							setScale: (textHeight@textHeight) / 1024.0).		shape color: textMorph color.		textMorph addMorphBack: shape.].	textPosition _ textPosition + (advance@0).! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 10/14/1998 19:23'!recordTextChange: fontId color: color xOffset: xOffset yOffset: yOffset height: height	fontId ifNotNil:[activeFont _ fonts at: fontId].	height ifNotNil:[textHeight _ height].	xOffset ifNotNil:[textPosition _  (textOffset x + xOffset) @ textPosition y].	yOffset ifNotNil:[textPosition _ textPosition x @ (yOffset + textOffset y)].	color ifNotNil:[textMorph color: color].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/12/1998 21:34'!recordTextEnd: id	textMorph submorphs isEmpty ifFalse:[		textMorph allMorphsDo:[:m| m color: textMorph color].		textMorph id: id.		textMorph stepTime: stepTime.		textMorph lockChildren.		shapes at: id put: textMorph].	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'defining text' stamp: 'ar 11/15/1998 18:43'!recordTextStart: id bounds: bounds matrix: matrix	textPosition _ textOffset _ bounds origin.	textMorph _ FlashCharacterMorph new.	textMorph privateBounds: bounds.	textMorph color: Color black.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 8/14/1998 16:19'!recordCurveSegmentTo: anchorPoint with: controlPoint	| target midPoint |	midPoint _ location + controlPoint.	target _ midPoint + anchorPoint.	self addLineFrom: location to: target via: midPoint.	location _ target.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:45'!recordFillStyle0: fillIndex	fillIndex0 _ fillIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:45'!recordFillStyle1: fillIndex	fillIndex1 _ fillIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/3/1998 16:09'!recordLineSegmentBy: deltaPoint	| target |	target _ location + deltaPoint.	self addLineFrom: location to: target via: location.	location _ target.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:40'!recordLineStyle: styleIndex	lineStyleIndex _ styleIndex.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 20:44'!recordMoveTo: aPoint	location _ aPoint.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/12/1998 21:41'!recordResetSubshape	| fills lines |	fills _ fillStyles.	lines _ lineStyles.	self endShape.	self beginShape.	fillStyles _ fills.	lineStyles _ lines.! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 11/16/1998 01:23'!recordShapeEnd: shapeId	| shape |	self endShape.	shape _ FlashCharacterMorph withAll: (currentShape contents reversed).	shape lockChildren.	currentShape resetToStart.	shape id: shapeId.	shape stepTime: stepTime.	shapes at: shapeId put: shape.	self doLog ifTrue:[log _ Transcript].! !!FlashMorphReader methodsFor: 'composing shapes' stamp: 'ar 8/14/1998 23:23'!recordShapeStart: shapeId bounds: bounds	location _ 0@0.	self logShapes ifFalse:[log _ nil].	self beginShape.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/3/1998 18:09'!addLineFrom: start to: end via: via	canCompressPoints ifTrue:[		"Check if we can compress the incoming points"		(compressionBounds containsPoint: start) ifFalse:[canCompressPoints _ false].		(compressionBounds containsPoint: via) ifFalse:[canCompressPoints _ false].		(compressionBounds containsPoint: end) ifFalse:[canCompressPoints _ false].	].	pointList nextPut: start.	pointList nextPut: via.	pointList nextPut: end.	leftFillList nextPut: fillIndex0.	rightFillList nextPut: fillIndex1.	lineStyleList nextPut: lineStyleIndex.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 21:43'!beginShape	canCompressPoints _ true.	fillStyles _ Dictionary new.	lineStyles _ Dictionary new.	pointList resetToStart.	leftFillList resetToStart.	rightFillList resetToStart.	lineStyleList resetToStart.	fillIndex0 _ fillIndex1 _ lineStyleIndex _ 0.! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 21:24'!computeFillLists	"Compute the fill index lists"	| leftFills rightFills |	leftFills_ leftFillList contents as: ShortRunArray.	rightFills _ rightFillList contents as: ShortRunArray.	^Array with: leftFills with: rightFills! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/12/1998 20:42'!computeLineStyleLists	"Compute the line style index lists.	Each line style will be splitted into two parts, the width and the fill.	Then, the fills will be added to the fillStyles and the indexes will be adjusted.	Finally, we compute two arrays containing the width of each line and the	fill style of each line"	| widthList fillList indexMap oldIndex newIndex allFillStyles style |	allFillStyles _ Dictionary new.	fillStyles associationsDo:[:assoc| 		allFillStyles at: assoc key put: assoc value].	indexMap _ Dictionary new.	lineStyles associationsDo:[:assoc|		oldIndex _ assoc key.		style _ assoc value.		allFillStyles at: allFillStyles size+1 put: (SolidFillStyle color: style color).		newIndex _ allFillStyles size.		indexMap at: oldIndex put: newIndex.	].	widthList _ OrderedCollection new: lineStyles size.	fillList _ OrderedCollection new: lineStyles size.	lineStyleList contents do:[:index|		index = 0 ifTrue:[			widthList add: 0.			fillList add: 0.		] ifFalse:[			style _ lineStyles at: index.			widthList add: style width.			fillList add: (indexMap at: index).		].	].	widthList _ widthList as: ShortRunArray.	fillList _ fillList as: ShortRunArray.	^Array with: allFillStyles with: fillList with: widthList! !!FlashMorphReader methodsFor: 'computing shapes' stamp: 'ar 11/15/1998 15:32'!endShape	| points shape fillLists lineLists index |	canCompressPoints ifTrue:[		points _ ShortPointArray new: pointList size.	] ifFalse:[		points _ PointArray new: pointList size.	].	index _ 1.	pointList contents do:[:p|		points at: index put: p.		index _ index + 1].	fillLists _ self computeFillLists.	lineLists _ self computeLineStyleLists.	shape _ FlashBoundaryShape 				points: points 				leftFills: fillLists first				rightFills: fillLists last				fillStyles: lineLists first				lineWidths: lineLists last				lineFills: (lineLists at: 2).	shape remapFills.	currentShape nextPut:(FlashShapeMorph shape: shape).! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/13/1998 20:34'!recordBitmapFill: index matrix: bmMatrix id: bitmapID clipped: aBoolean	| fillStyle form |	form _ forms at: bitmapID ifAbsent:[^nil].	fillStyle _ BitmapFillStyle form: form.	fillStyle origin: (bmMatrix localPointToGlobal: 0@0).	fillStyle direction: (bmMatrix localPointToGlobal: form extent x @ 0).	fillStyle normal: (bmMatrix localPointToGlobal: 0 @ form extent y).	fillStyles at: index put: fillStyle.! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/11/1998 22:39'!recordGradientFill: fillIndex matrix: gradientMatrix ramp: colorRampArray linear: aBoolean	| fillStyle ramp origin direction normal |	ramp _ colorRampArray collect:[:assoc| (assoc key / 255.0) -> assoc value].	origin _ gradientMatrix localPointToGlobal: (aBoolean ifFalse:[0@0] ifTrue:[-16384@0]).	direction _ (gradientMatrix localPointToGlobal: (16384@0)) - origin.	normal _ (gradientMatrix localPointToGlobal: (0@16384)) - origin.	fillStyle _ GradientFillStyle ramp: ramp.	fillStyle origin: origin.	fillStyle direction: direction.	fillStyle normal: normal.	fillStyle radial: aBoolean not.	Cursor wait showWhile:[fillStyle pixelRamp].	fillStyles at: fillIndex put: fillStyle.! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 8/15/1998 00:58'!recordLineStyle: styleIndex width: lineWidth color: lineColor	lineStyles at: styleIndex put: (FlashLineStyle color: lineColor width: lineWidth).! !!FlashMorphReader methodsFor: 'defining styles' stamp: 'ar 11/11/1998 22:39'!recordSolidFill: index color: fillColor	fillStyles at: index put: (SolidFillStyle color: fillColor)! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:44'!recordBackgroundColor: aColor	player color: aColor! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/12/1998 21:50'!recordBitmap: id data: aForm	aForm ifNil:[^self].	"Record the current form"	forms at: id put: aForm.	"Define a new character"! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 14:39'!recordFrameActions: actionList	player addActions: actionList atFrame: frame-1.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 14:32'!recordFrameLabel: aString	player addLabel: aString atFrame: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/16/1998 02:23'!recordFrameRate: fps	fps > 0.0 ifTrue:[stepTime _ (1000.0 / fps) rounded].	player stepTime: stepTime.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 21:34'!recordGlobalBounds: bounds	player localBounds: bounds.	player bounds: bounds.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/15/1998 16:04'!recordPlaceObject: objectIndex depth: depth matrix: matrix colorMatrix: colorMatrix	| cached active doLoad |	cached _ passiveMorphs at: objectIndex ifAbsent:[#()].	cached size >= 1 		ifTrue:["Got an old morph. Re-use it"				doLoad _ false.				active _ cached first.				passiveMorphs at: objectIndex put: (cached copyWithout: active)]		ifFalse:["Need a new morph"				doLoad _ true.				active _ self newMorphFromShape: objectIndex.				active isNil ifTrue:[^self].				active reset.				active visible: false atFrame: frame - 1].	active isNil ifTrue:[^self].	active visible: true atFrame: frame.	active depth: depth atFrame: frame.	active matrix:  matrix atFrame: frame.	active colorMatrix: colorMatrix atFrame: frame.	doLoad ifTrue:[		active loadInitialFrame.		player addMorph: active].	cached _ (activeMorphs at: objectIndex ifAbsent:[#()]) copyWith: active.	activeMorphs at: objectIndex put: cached.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/3/1998 23:19'!recordRemoveObject: id depth: depth	id ifNotNil:["Faster if id is given"		(activeMorphs at: id ifAbsent:[^self]) do:[:morph|			((morph depthAtFrame: frame-1) = depth) ifTrue:[self removeActiveMorph: morph]]].	activeMorphs do:[:list|		list do:[:morph|			((morph depthAtFrame: frame-1) = depth) ifTrue:[self removeActiveMorph: morph]]]! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:44'!recordShowFrame	frame _ frame + 1.	player frames: frame.! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 11/10/1998 23:46'!recordSound: id data: aSampledSound	aSampledSound ifNotNil:[sounds at: id put: aSampledSound]! !!FlashMorphReader methodsFor: 'misc' stamp: 'ar 10/15/1998 20:55'!recordStartSound: id info: info	| theSound |	theSound _ self createSound: id info: info.	theSound ifNotNil:[player addSound: theSound at: frame].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 11/12/1998 20:48'!createSound: id info: info	| theSound |	theSound _ sounds at: id ifAbsent:[^nil].	^RepeatingSound repeat: theSound count: info loopCount! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 10/15/1998 23:15'!newMorphFromShape: objectIndex	"Return a new character morph from the given object index.	If the character morph at objectIndex is already used, then create and return a full copy of it"	| prototype |	prototype _ self oldMorphFromShape: objectIndex.	prototype isNil ifTrue:[^nil].	^((passiveMorphs includesKey: objectIndex) or:[activeMorphs includesKey: objectIndex]) 		ifTrue:[prototype fullCopy]		ifFalse:[prototype].! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 10/15/1998 23:15'!oldMorphFromShape: objectIndex	"Return an existing character morph from the given object index."	| prototype |	prototype _ shapes at: objectIndex ifAbsent:[nil].	prototype ifNil:[prototype _ buttons at: objectIndex ifAbsent:[nil]].	^prototype! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/15/1998 15:27'!placeGlyph: aMorph at: position	aMorph privateFullMoveBy: position.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/14/1998 19:22'!removeActiveMorph: aMorph	| newActive newPassive |	aMorph visible: false atFrame: frame.	newActive _ (activeMorphs at: aMorph id) copyWithout: aMorph.	newPassive _ (passiveMorphs at: aMorph id ifAbsent:[#()]) copyWith: aMorph.	activeMorphs at: aMorph id put: newActive.	passiveMorphs at: aMorph id put: newPassive.! !!FlashMorphReader methodsFor: 'private' stamp: 'ar 8/15/1998 15:28'!resizeGlyph: aMorph to: extent	aMorph extent: 1440@1440.	aMorph extent: extent.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 01:52'!recordButton: buttonId actions: actionList condition: condition	| button |	button _ buttons at: buttonId ifAbsent:[^self].	(condition anyMask: 1) ifTrue:[		button on: #mouseEnter send: #executeActions: to: player withValue: actionList.	].	(condition anyMask: 2) ifTrue:[		button on: #mouseLeave send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 4) ifTrue:[		button on: #mouseDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 8) ifTrue:[		button on: #mouseUp send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 16) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 32) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 64) ifTrue:[		button on: #mouseUpOut send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 128) ifTrue:[		button on: #mouseEnterDown send:#executeActions: to: player withValue: actionList.	].	(condition anyMask: 256) ifTrue:[		button on: #mouseLeaveDown send:#executeActions: to: player withValue: actionList.	].! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 11/16/1998 01:24'!recordButton: buttonId character: characterId state: state layer: layer matrix: matrix	| button children shape |	button _ buttons at: buttonId ifAbsentPut:[FlashButtonMorph new].	button id: buttonId.	shape _ self oldMorphFromShape: characterId.	shape isNil ifTrue:[self halt].	children _ shape submorphs collect:[:m| m fullCopy].	shape _ FlashMorph withAll: children.	shape lockChildren.	shape transform: matrix.	(state anyMask: 1) ifTrue:[		button defaultLook: shape.	].	(state anyMask: 2) ifTrue:[		button overLook: shape.	].	(state anyMask: 4) ifTrue:[		button pressLook: shape.	].	(state anyMask: 8) ifTrue:[		button sensitiveLook: shape.	].	button lockChildren.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 10/15/1998 20:57'!recordButton: id sound: soundId info: soundInfo state: state	"Give the button a sound"	| button theSound |	button _ buttons at: id ifAbsent:[^self].	theSound _ self createSound: id info: soundInfo.	theSound ifNil:[^self].	self halt.	button addSound: theSound forState: state.! !!FlashMorphReader methodsFor: 'defining buttons' stamp: 'ar 10/15/1998 23:46'!recordButton: id trackAsMenu: aBoolean	| button |	button _ buttons at: id ifAbsentPut:[FlashButtonMorph new].	button id: id.	button trackAsMenu: aBoolean.! !!FlashShapeMorph class methodsFor: 'instance creation' stamp: 'ar 11/15/1998 15:32'!shape: aCompressedFlashGeometry	^self new shape: aCompressedFlashGeometry! !!FlashSoundEnvelope methodsFor: 'initialize' stamp: 'ar 8/10/1998 15:35'!initialize	mark44 _ level0 _ level1 _ 0.! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level0	^level0! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level0: anInteger	level0 _ anInteger! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level1	^level1! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!level1: anInteger	level1 _ anInteger! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!mark44	^mark44! !!FlashSoundEnvelope methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:36'!mark44: anInteger	mark44 _ anInteger! !!FlashSoundEnvelope class methodsFor: 'instance creation' stamp: 'ar 8/10/1998 15:35'!new	^super new initialize! !!FlashSoundInformation methodsFor: 'initialize' stamp: 'ar 8/10/1998 15:30'!initialize	syncFlags _ 0.	inPoint _ -1.	outPoint _ -1.	loopCount _ 0.	envelopes _ #().! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!envelopes	^envelopes! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!envelopes: aCollection	envelopes _ aCollection! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!inPoint	^inPoint! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!inPoint: anInteger	inPoint _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!loopCount	^loopCount! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:32'!loopCount: anInteger	loopCount _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!outPoint	^outPoint! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!outPoint: anInteger	outPoint _ anInteger! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:30'!syncFlags	^syncFlags! !!FlashSoundInformation methodsFor: 'accessing' stamp: 'ar 8/10/1998 15:31'!syncFlags: anInteger	syncFlags _ anInteger! !!FlashSoundInformation methodsFor: 'testing' stamp: 'ar 8/10/1998 15:33'!syncNoMultiple	"Don't start the sound if already playing."	^syncFlags anyMask: 1! !!FlashSoundInformation methodsFor: 'testing' stamp: 'ar 8/10/1998 15:34'!syncStopSound	"Stop the sound."	^syncFlags anyMask: 2! !!FlashSoundInformation class methodsFor: 'instance creation' stamp: 'ar 8/10/1998 15:29'!new	^super new initialize! !!Morph methodsFor: 'classification' stamp: 'ar 8/10/1998 18:50'!isFlashMorph	^false! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:27'!loadInitialFrame! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 8/15/1998 17:15'!lockChildren	submorphs do:[:m| m lock].! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 11/13/1998 16:10'!reset	submorphs do:[:m| m isFlashMorph ifTrue:[m reset]].! !!FlashMorph methodsFor: 'initialize' stamp: 'ar 8/15/1998 17:21'!unlockChildren	submorphs do:[:m| m unlock].! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:48'!defaultAALevel	^self valueOfProperty: #aaLevel! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:51'!defaultAALevel: aNumber	aNumber isNil 		ifTrue:[self removeProperty: #aaLevel]		ifFalse:[self setProperty: #aaLevel toValue: aNumber]! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:14'!depth	^0! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:40'!flashPlayer	| parent |	parent _ owner.	[parent isNil] whileFalse:[		(parent isFlashMorph and:[parent isFlashPlayer]) ifTrue:[^parent].		parent _ parent owner].	^nil! !!FlashMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:52'!isFlashCharacter	^false! !!FlashMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:12'!isFlashMorph	^true! !!FlashMorph methodsFor: 'classification' stamp: 'ar 11/15/1998 19:04'!isFlashPlayer	^false! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 02:47'!canvasForSubmorphs: canvasForMe	| canvas aaLevel |	canvas _ (super canvasForSubmorphs: canvasForMe).	aaLevel _ self defaultAALevel.	aaLevel isNil		ifTrue:[^canvas]		ifFalse:[^canvas copy aaLevel: aaLevel]! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:49'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self defaultAALevel = nil		ifTrue:[aCustomMenu add: 'turn on smoothing' action: #smoothingOn].	self defaultAALevel = 2 		ifTrue:[aCustomMenu add: 'more smoothing' action: #smoothingMore].	self defaultAALevel = 4 		ifTrue:[aCustomMenu add: 'turn off smoothing' action: #smoothingOff].! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingMore	self defaultAALevel: 4.	self changed! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingOff	self defaultAALevel: nil.	self changed! !!FlashMorph methodsFor: 'menu' stamp: 'ar 11/16/1998 02:50'!smoothingOn	self defaultAALevel: 2.	self changed! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/16/1998 02:56'!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player grabbedPoint |	player _ self flashPlayer.	player ifNotNil:[		player noticeRemovalOf: self.		grabbedPoint _ self pointFromWorld: aHand position.		self transform: (self transformFrom: player owner).		self position: grabbedPoint.	].! !!FlashMorph methodsFor: 'events' stamp: 'ar 11/16/1998 02:53'!justDroppedInto: newOwner event: evt	super justDroppedInto: newOwner event: evt.	self computeBounds.! !!FlashMorph methodsFor: 'printing' stamp: 'ar 11/13/1998 20:40'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$[;		print: self depth;		space.	self visible 		ifTrue:[aStream nextPutAll:'visible']		ifFalse:[aStream nextPutAll:'invisible'].	aStream		nextPut:$];		cr.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 11/15/1998 15:45'!initialize	super initialize.	vData _ FlashKeyframes new.	mData _ FlashKeyframes new.	dData _ FlashKeyframes new.	cmData _ FlashKeyframes new.	frame _ 1.	self matrix: MatrixTransform2x3 identity atFrame: 0.	self visible: false atFrame: 0.	self depth: 0 atFrame: 0.	self visible: true.! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:27'!loadInitialFrame	"Force the transformations taking place in the first frame."	self visible: (self visibleAtFrame: 1).! !!FlashCharacterMorph methodsFor: 'initialize' stamp: 'ar 10/14/1998 02:41'!reset	self removeAllKeyFrameData.! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 11/13/1998 13:40'!activationKeys	"Return the keyframes on which the receiver morph becomes visible"	^self visibleData keys select:[:key| self visibleAtFrame: key]! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 10/3/1998 21:39'!depth	^self depthAtFrame: frame! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 18:19'!id	^id! !!FlashCharacterMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 18:19'!id: aNumber	id _ aNumber! !!FlashCharacterMorph methodsFor: 'classification' stamp: 'ar 8/14/1998 21:52'!isFlashCharacter	^true! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:19'!colorMatrix: aMatrixTransform atFrame: frameNumber	self colorMatrixData at: frameNumber put: aMatrixTransform! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!colorMatrixAtFrame: frameNumber	^self colorMatrixData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!colorMatrixData	^cmData	"^self keyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!depth: aNumber atFrame: frameNumber	self depthData at: frameNumber put: aNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:20'!depthAtFrame: frameNumber	^self depthData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!depthData	^dData	"^self keyframeData: #depthData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:11'!matrix: aMatrixTransform atFrame: frameNumber	"self position: aMatrixTransform offset atFrame: frameNumber."	self matrixData at: frameNumber put: aMatrixTransform.! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:12'!matrixAtFrame: frameNumber	^(self matrixData at: frameNumber) "copy offset: (self positionAtFrame: frameNumber)"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:15'!matrixData	^mData	"^self keyframeData: #matrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:12'!removeAllKeyFrameData	"Remove all of the keyframe data associated with this morph"	self removeColorMatrixData.	self removeDepthData.	self removeMatrixData.	self removeVisibleData.! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeColorMatrixData	cmData _ FlashKeyframes new.	"^self removeKeyframeData: #colorMatrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeDepthData	dData _ FlashKeyframes new.	"^self removeKeyframeData: #depthData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeMatrixData	mData _ FlashKeyframes new.	"^self removeKeyframeData: #matrixData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!removeVisibleData	vData _ FlashKeyframes new.	"^self removeKeyframeData: #visibilityData"! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 17:13'!visible: aBool atFrame: frameNumber	^self visibleData at: frameNumber put: aBool! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 8/14/1998 19:23'!visibleAtFrame: frameNumber	^self visibleData at: frameNumber! !!FlashCharacterMorph methodsFor: 'keyframe data' stamp: 'ar 11/13/1998 15:16'!visibleData	^vData	"^self keyframeData: #visibilityData"! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 18:17'!stepTime	^stepTime ifNil:[super stepTime]! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 18:18'!stepTime: aNumber	stepTime _ aNumber! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/15/1998 16:56'!stepToFrame: frameNumber	| m wasVisible isVisible noTransform |	wasVisible _ self visible.	self visible: (self visibleAtFrame: frameNumber).	isVisible _ self visible.	frame _ frameNumber.	isVisible ifTrue:[		m _ self matrixAtFrame: frame.		noTransform _ m = transform.		(noTransform and:[isVisible = wasVisible]) ifTrue:[^self]. "No change"		((noTransform not) and:[wasVisible]) ifTrue:[			"Invalidate with old transform"			self changed.		].		self transform: m.		((noTransform not) and:[isVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].		((noTransform) and:[isVisible ~~ wasVisible]) ifTrue:[			"Invalidate with new transform"			self changed.		].	] ifFalse:[		wasVisible ifTrue:[self changed].	].! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:03'!stepToNextFrame	self stepToFrame: frame + 1.! !!FlashCharacterMorph methodsFor: 'stepping' stamp: 'ar 11/13/1998 14:02'!wantsSteps	^false	"^stepTime notNil"! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 8/14/1998 20:03'!keyframeData: aSymbol	| data |	data _ self valueOfProperty: aSymbol.	data isNil ifFalse:[^data].	data _ FlashKeyframes new.	self setProperty: aSymbol toValue: data.	^data! !!FlashCharacterMorph methodsFor: 'private' stamp: 'ar 9/20/1998 23:41'!removeKeyframeData: aSymbol	self removeProperty: aSymbol.! !!FlashCharacterMorph methodsFor: 'printing' stamp: 'ar 11/15/1998 15:44'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll:'(renderTime = '; print: renderTime;		"nextPutAll:' complexity = '; print: self complexity * bounds area // 1000 / 1000.0;"		"nextPutAll:' size = '; print: bounds area;"	 nextPutAll:')'.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 11/15/1998 17:12'!defaultLook: aMorph	"Assign the default look"	default _ aMorph.	self addMorph: aMorph.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 10/15/1998 21:13'!overLook: aMorph	"Assign the look if the mouse if over"	over _ aMorph.	self addMorph: aMorph.	aMorph visible: false.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 10/15/1998 21:13'!pressLook: aMorph	"Assign the look if the mouse is pressed"	press _ aMorph.	self addMorph: aMorph.	aMorph visible: false.! !!FlashButtonMorph methodsFor: 'looks' stamp: 'ar 11/16/1998 02:08'!sensitiveLook: aMorph	"Assign the look for the sensitive area."	sensitive _ aMorph.! !!FlashButtonMorph methodsFor: 'initialize' stamp: 'ar 10/15/1998 20:59'!initialize	super initialize.	menuFlag _ false.! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 21:16'!addSound: aSound forState: state	sounds ifNil:[sounds _ Dictionary new].	sounds at: state put: aSound.! !!FlashButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 20:59'!trackAsMenu: aBoolean	menuFlag _ aBoolean.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:06'!handlesMouseDown: evt	^events notNil! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:07'!handlesMouseOver: evt	^events notNil! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:07'!handlesMouseOverDragging: evt	^events notNil! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 02:06'!mouseDown: evt	self changed.	default visible: false.	over ifNotNil:[over visible: false].	press ifNotNil:[press visible: true].	self layoutChanged.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 02:06'!mouseEnter: evt	self changed.	default visible: false.	press ifNotNil:[press visible: false].	over ifNotNil:[over visible: true].	self layoutChanged.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 01:47'!mouseLeave: evt	self changed.	over ifNotNil:[over visible: false].	press ifNotNil:[press visible: false].	default visible: true.	self layoutChanged.! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:08'!mouseMove: evt! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 11/16/1998 02:06'!mouseUp: evt	| rcvr msg arg |	self changed.	default visible: false.	press ifNotNil:[press visible: false].	over ifNotNil:[over visible: true].	self layoutChanged.	(events at: #mouseUp ifAbsent:[#()]) do:[:action|		rcvr _ action at: 1.		msg _ action at: 2.		arg _ action at: 3.		rcvr perform: msg with: arg.	].! !!FlashButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/1998 21:05'!on: eventName send: selector to: recipient withValue: value	"Note: We handle more than the standard Morphic events here"	| actionList |	events ifNil:[events _ Dictionary new].	actionList _ events at: eventName ifAbsent:[#()].	actionList _ actionList copyWith: (Array with: recipient with: selector with: value).	events at: eventName put: actionList.! !!FlashButtonMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 02:08'!containsPoint: aPoint	| localPt |	sensitive ifNil:[^super containsPoint: aPoint].	localPt _ self transform globalPointToLocal: aPoint.	^sensitive bounds containsPoint: localPt! !!FlashButtonMorph methodsFor: 'changing' stamp: 'ar 11/16/1998 01:48'!layoutChanged	super layoutChanged.	self computeBounds.	self changed.! !!FlashGlyphMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:17'!color: aColor	super color: aColor.	submorphs do:[:m| m color: aColor].! !!FlashGlyphMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 02:51'!defaultAALevel	^4! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/16/1998 02:30'!initialize	super initialize.	color _ Color white.	borderColor _ Color black.	borderWidth _ 2.	frameNumber _ 1.	frames _ 100.	sounds _ Dictionary new.	actions _ Dictionary new.	self syncFrames: false.	self loopFrames: true.	stepTime _ 1.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/13/1998 13:54'!loadInitialFrame	activationKeys _ self collectActivationKeys.	activeMorphs _ SortedCollection new: 50.	activeMorphs sortBlock:[:m1 :m2| m1 depth > m2 depth].	activeMorphs addAll: activationKeys first.! !!FlashPlayerMorph methodsFor: 'initialize' stamp: 'ar 11/6/1998 23:55'!makeControls	| b r syncSwitch loopSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2.	r _ AlignmentMorph newRow.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	r addMorphBack: (b fullCopy label: 'Next';			actionSelector: #stepForward).	r addMorphBack: (b fullCopy label: 'Prev';			actionSelector: #stepBackward).	syncSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Sync';		actionSelector: #syncFrames:;		target: self;		setSwitchState: false.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'Loop';		actionSelector: #loopFrames:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	loopSwitch _ SimpleSwitchMorph new		borderWidth: 2;		label: 'cache';		actionSelector: #enableCache:;		target: self;		setSwitchState: false.	r addMorphBack: loopSwitch.	r addMorphBack: syncSwitch.	r addMorphBack: (b fullCopy label: 'Fastest'; 	actionSelector: #drawFastest).	r addMorphBack: (b fullCopy label: 'Medium';	actionSelector: #drawMedium).	r addMorphBack: (b fullCopy label: 'Nicest';		actionSelector: #drawNicest).	r addMorphBack: (b fullCopy label: '+10';		actionSelector: #jump10).	b target: self.	^ self world activeHand attachMorph: r! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 01:35'!aaLevel	^aaLevel ifNil:[2]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/14/1998 23:44'!aaLevel: aNumber	aaLevel _ aNumber min: 4 max: 1.	submorphs do:[:m|		m releaseCachedState.	].! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:18'!addActions: actionList atFrame: frame	actions ifNil:[actions _ Dictionary new].	actions at: frame put: actionList.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 14:31'!addLabel: labelString atFrame: frame	labels ifNil:[labels _ Dictionary new].	labels at: labelString put: frame.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:42'!addSound: aSound at: frameNr	| oldSound newSound |	oldSound _ sounds at: frameNr ifAbsent:[nil].	oldSound isNil 		ifTrue:[newSound _ Array with: aSound]		ifFalse:[newSound _ oldSound copyWith: newSound].	sounds at: frameNr put: newSound.! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:59'!frames	^frames! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:59'!frames: aNumber	frames _ aNumber! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/16/1998 00:56'!localBounds	^localBounds ifNil:[localBounds _ self transform globalBoundsToLocal: self bounds]! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:33'!localBounds: newBounds	bounds _ (newBounds origin // 20 corner: newBounds corner // 20).	transform _ MatrixTransform2x3 					transformFromLocal: newBounds 					toGlobal: bounds! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:51'!loopFrames: aBoolean	self setProperty: #loopFrames toValue: aBoolean! !!FlashPlayerMorph methodsFor: 'accessing' stamp: 'ar 10/15/1998 02:51'!syncFrames: aBoolean	self setProperty: #syncFrames toValue: aBoolean! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 01:05'!canvasForSubmorphs: canvasForMe	^(canvasForMe copyClipRect: (self bounds insetBy: borderWidth))		asBalloonCanvas transformBy: self transform; aaLevel: self aaLevel! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 02:59'!drawFastest	self aaLevel: 1.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 02:59'!drawMedium	self aaLevel: 2.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 02:59'!drawNicest	self aaLevel: 4.	self changed.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 01:05'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor box |	box _ self bounds.	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: box color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: box			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: box			fillColor: color			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: box		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/16/1998 01:10'!fullDrawOn: aCanvas	"Overridden to only the draw the currently active morphs"	| canvasForSubmorphs |	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:		[^ self].	(aCanvas isVisible: bounds) ifTrue:		[self drawOn: aCanvas].	canvasForSubmorphs _ self canvasForSubmorphs: aCanvas.	activeMorphs reverseDo:  "Display submorphs back to front"		[:m | m fullDrawOn: canvasForSubmorphs].  ! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 20:30'!invalidRect: rect	damageRecorder isNil ifTrue:[		super invalidRect: rect.	] ifFalse:[		damageRecorder recordInvalidRect: rect.	].! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 01:06'!computeBounds	"Do nothing."! !!FlashPlayerMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 16:07'!fullBounds	"The player clips its children"	^bounds! !!FlashPlayerMorph methodsFor: 'classification' stamp: 'ar 11/15/1998 19:05'!isFlashPlayer	^true! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 01:29'!frameNumber: frame	| fullRect postDamage |	frame = frameNumber ifTrue:[^self].	postDamage _ damageRecorder isNil.	postDamage ifTrue:[damageRecorder _ FlashDamageRecorder new].	frame > frameNumber ifTrue:[		self stepToFrameForward: frame.	] ifFalse:[		activeMorphs _ activeMorphs select:[:any| false].		submorphs do:[:m|			(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[				m stepToFrame: frame.				m visible ifTrue:[activeMorphs add: m].			]].	].	frameNumber _ frame.	(sounds at: frame ifAbsent:[#()]) do:[:sound| sound ifNotNil:[sound play]].	(actions at: frame ifAbsent:[#()]) do:[:action| action sentTo: self].	(postDamage and:[owner notNil]) ifTrue:[		damageRecorder updateIsNeeded ifTrue:[			fullRect _ damageRecorder fullDamageRect: self localBounds.			fullRect _ (self transform localBoundsToGlobal: fullRect).			owner invalidRect: (fullRect insetBy: -1).		].	].	postDamage ifTrue:[damageRecorder _ nil].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/6/1998 23:56'!jump10	1 to: 10 do:[:i| self stepForward].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 10/15/1998 02:45'!pause	self stopStepping.	SoundPlayer shutDown.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:54'!rewind	self frameNumber: 1.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:24'!step	self stepForward.! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 8/14/1998 21:59'!stepBackward	frameNumber > 1		ifTrue:[self frameNumber: frameNumber - 1]		ifFalse:[self frameNumber: frames].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 10/12/1998 23:54'!stepForward	frameNumber < frames		ifTrue:[self frameNumber: frameNumber + 1]		ifFalse:[(self valueOfProperty:#loopFrames) == true ifTrue:[self frameNumber: 1]].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:25'!stepTime	^stepTime! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:25'!stepTime: delta	stepTime _ delta! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/13/1998 16:31'!stepToFrameForward: frame	| activeRemoved resortNeeded morph |	frameNumber+1 to: frame do:[:f|		activeRemoved _ false.		resortNeeded _ false.		1 to: activeMorphs size do:[:i|			morph _ activeMorphs at: i.			morph stepToFrame: f.			morph visible ifFalse:[activeRemoved _ true].			(i > 1 and:[(activeMorphs at: i-1) depth < morph depth])				ifTrue:[resortNeeded _ true].		].		activeRemoved ifTrue:[			activeMorphs _ activeMorphs select:[:m| m visible].			resortNeeded _ false.		].		resortNeeded ifTrue:[activeMorphs reSort].		(activationKeys at: f) do:[:m|			m stepToFrame: f.			m visible ifTrue:[activeMorphs add: m].		].	].! !!FlashPlayerMorph methodsFor: 'stepping' stamp: 'ar 11/16/1998 02:17'!wantsSteps	^true! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/13/1998 13:41'!collectActivationKeys	| vis |	vis _ Array new: frames.	vis atAllPut: #().	submorphs do:[:m|		(m isFlashMorph and:[m isFlashCharacter]) ifTrue:[			m activationKeys do:[:key|				vis at: key put: ((vis at: key) copyWith: m)			].		].	].	^vis! !!FlashPlayerMorph methodsFor: 'private' stamp: 'ar 11/16/1998 02:58'!noticeRemovalOf: aFlashMorph	"The flash morph is removed from the player.	Remove it's activation keys so that we don't have any problems."	| morphs |	aFlashMorph activationKeys do:[:key|		morphs _ activationKeys at: key.		activationKeys at: key put: (morphs copyWithout: aFlashMorph).	].	"And remove it from the activeMorphs"	activeMorphs remove: aFlashMorph ifAbsent:[]! !!FlashPlayerMorph methodsFor: 'menu' stamp: 'ar 10/15/1998 23:20'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'make controls' action: #makeControls.	aCustomMenu addLine.	aCustomMenu add: 'Low Quality' action: #drawFastest.	aCustomMenu add: 'Med Quality' action: #drawMedium.	aCustomMenu add: 'High Quality' action: #drawNicest.	"aCustomMenu add: 'make slider' action: #makeSlider."	aCustomMenu addLine.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:29'!actionTarget: target	"Set the context of an action.	I'm not really sure what the context of an action is."	self halt.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/16/1998 01:55'!executeActions: actionList	actionList do:[:msg| msg sentTo: self].! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:24'!getURL: urlString window: windowString	"Load the given url in display it in the window specified by windowString.	Ignored for now."! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:21'!gotoFrame: frame	"Jump to the given frame"		self frameNumber: frame.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:31'!gotoLabel: labelString	"Go to the frame with the associated label string."	labels ifNil:[^nil].	self frameNumber: (labels at: labelString ifAbsent:[^nil]).! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:26'!gotoNextFrame	"Go to the next frame"	self frameNumber: self frameNumber+1.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:26'!gotoPrevFrame	"Go to the previous frame"	self frameNumber: self frameNumber-1.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:21'!isFrameLoaded: frame elseSkip: nActions	"Skip nActions if the given frame is not loaded yet.	Ignored for the moment."! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/16/1998 02:23'!play	"Start playing from the current frame"	self startStepping.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:27'!stop	"Stop playing at the current frame."	self stopStepping.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:28'!stopSounds	"Stop all sounds"	SoundPlayer shutDown.! !!FlashPlayerMorph methodsFor: 'actions' stamp: 'ar 11/15/1998 14:27'!toggleQuality	"Toggle the display quality.	Ignored for now - we're aiming at adaptive quality settings."! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 17:19'!color: aColor	| fillStyle |	color _ aColor.	fillStyle _ SolidFillStyle color: aColor.	shape _ shape copyAndCollectFills:[:fill| fillStyle]! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 15:31'!shape	^shape! !!FlashShapeMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 16:43'!shape: newShape	shape _ newShape.	self computeBounds.! !!FlashShapeMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 21:30'!drawOn: aCanvas 	"Display the receiver."	shape ifNil:[^aCanvas frameRectangle: self bounds color: Color black.].	aCanvas asBalloonCanvas drawCompressedShape: shape.! !!FlashShapeMorph methodsFor: 'geometry' stamp: 'ar 11/16/1998 01:01'!computeBounds	bounds _ shape bounds.	fullBounds _ nil.! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit _ position _ 0.! !FlashFileReader initialize!FlashFileWriter initialize!