'From Squeak3.2alpha of 17 December 2001 [latest update: #4642] on 4 January 2002 at 12:37:39 am'!"Change Set:		MethodAnnotations-arDate:			2 January 2002Author:			Andreas RaabWARNING: This CS has been manually re-arranged.Optional annotation for methods. All <mumble> expressions are now treated as property of the compiled method. In other words, a method may look like:Object>>mumble	<categories: #(basic eToy)>	<index: 42>	<value: 123.45>	<returnType: Array>After the method is compiled we may query it for those properties as in:	(Object compiledMethodAt: #mumble)		propertyAt: #categories; 	=> #(basic eToy)		propertyAt: #index;		=> 42		propertyAt: #value;		=> 123.45		propertyAt: #returnType.	=> Array"!ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries properties sourceText'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!Scanner subclass: #Parser	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties category'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!!CompiledMethod methodsFor: 'literals' stamp: 'ar 1/4/2002 00:32'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	| lit |	self properties ifNotNilDo:[:dict | (dict includesKey: literal) ifTrue:[^true]].	2 to: self numLiterals + 1 do: 		[:index | 		(lit _ self objectAt: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false ! !!Encoder methodsFor: 'private' stamp: 'ar 1/2/2002 14:53'!possibleNamesFor: proposedName	| results |	results _ class possibleVariablesFor: proposedName continuedFrom: nil.	^ proposedName correctAgainst: nil continuedFrom: results.! !!MethodNode methodsFor: 'initialize-release' stamp: 'ar 1/4/2002 00:23'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict	"Initialize the receiver with respect to the arguments given."	encoder _ anEncoder.	selectorOrFalse _ selOrFalse.	precedence _ p.	arguments _ args.	temporaries _ temps.	block _ blk.	primitive _ prim.	properties _ propDict.! !!MethodNode methodsFor: 'code generation' stamp: 'ar 1/4/2002 00:33'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method properties: properties.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method properties: properties.	^ method! !!Parser methodsFor: 'primitives' stamp: 'ar 1/3/2002 23:59'!primitive	"Temporarily inserted here"	^0! !!Parser methodsFor: 'private' stamp: 'ar 1/3/2002 23:52'!addProperty: propName value: value	| aSymbol |	properties ifNil:[properties _ MethodProperties new].	aSymbol _ propName asSymbol.	(properties propDict includesKey: aSymbol) ifTrue:[self notify: '<- duplicate property'].	properties propertyAt: aSymbol put: value! !!Parser methodsFor: 'primitives' stamp: 'ar 1/3/2002 23:56'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType _ descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == ')' asSymbol] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addProperty: #primitiveIndex value: 120.	^true! !!Parser methodsFor: 'primitives' stamp: 'ar 1/3/2002 23:59'!primitiveDeclaration	| prim module |	(self matchToken: 'primitive:') ifFalse:[^false].	prim _ here.	(self match: #number) ifTrue:[ "Indexed primitives"		self addProperty: #primitiveIndex value: prim.		^true].	(self match: #string) ifFalse:[^self expected:'Integer or String'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	(self allocateLiteral: (Array with: module with: prim asSymbol with: 0 with: 0)).	self addProperty: #primitiveIndex value: 117.	^true! !!Parser methodsFor: 'properties' stamp: 'ar 1/4/2002 00:19'!correctProperty: proposedName interval: spot	"Correct the proposedName to a known type.	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection |	"If we can't ask the user for correction, make it undefined"	self interactive ifFalse: [^nil].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleNamesFor: proposedName.	aStream _ WriteStream on: (String new: 200).	alternatives do:[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (alternatives size)))		startUpWithCaption:(('Unknown global: ', proposedName, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedName size).	(choice = 0) | (choice > (alternatives size))		ifTrue: [self fail. ^nil].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	"Spelling correction"	self substituteWord: (alternatives at: choice)			wordInterval: spot			offset: 0.	^(alternatives at: choice)! !!Parser methodsFor: 'properties' stamp: 'ar 1/4/2002 00:02'!hasProperty: propName	properties ifNil:[^false].	^properties includesKey: propName! !!Parser methodsFor: 'properties' stamp: 'ar 1/3/2002 23:55'!properties	"Parse method properties"	[true] whileTrue:[		(self matchToken: #<) ifFalse:[^self].		self property.		(self matchToken: #>) ifFalse: [^ self expected: '>'].	].! !!Parser methodsFor: 'properties' stamp: 'ar 1/4/2002 00:18'!property	"Read a single property. Primitives and others may have fixed spec.	Parse all generic properties in the form of:		<propKey: propValue>	and remember them as method properties."	| propName propValue varStart varEnd |	(self hasProperty: #primitiveIndex) ifFalse:[		"Only one primitive specification is allowed"		self externalFunctionDeclaration ifTrue:[^true].		self primitiveDeclaration ifTrue:[^true].	].	hereType == #keyword ifFalse:[^false].	propName _ self advance allButLast. "remove last colon"	(hereType == #number or:[hereType == #literal or:[hereType == #string]]) ifTrue:[		propValue _ self advance.		self addProperty: propName value: propValue.		^true].	"We shouldn't have any but #word hereTypes at this point"	hereType == #word ifFalse:[^self error:'*** FIX THIS ***'].	varStart _ self startOfNextToken + requestorOffset.	propValue _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	[true] whileTrue:[		Symbol hasInterned: propValue ifTrue:[:aSymbol|			encoder classEncoding scopeHas: aSymbol ifTrue:[:assoc|				propValue _ assoc value.				self addProperty: propName value: propValue.				^true			].		].		propValue _ self correctProperty: propValue interval: (varStart to: varEnd).		propValue ifNil:[^nil].	].	^true! !!Parser methodsFor: 'expression types' stamp: 'ar 1/2/2002 14:31'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword] whileTrue:[				selector nextPutAll: self advance.				args addLast: (encoder bindArg: self argumentName).			].			^ {selector contents asSymbol. args. 3}].	^ self expected: 'Message pattern'! !!Parser methodsFor: 'expression types' stamp: 'ar 1/4/2002 00:23'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [self interactive				ifFalse: [tempsMark _ 1]				ifTrue: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ (prevEnd ifNil: [0]) + 1.		tempsMark _ hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'ar 1/4/2002 00:23'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	encoder _ encoderToUse.	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporariesIn: (sap at: 1)..	messageComment _ currentComment.	currentComment _ nil.	doit ifFalse:[self properties].	prim _ 0.	properties ifNotNil:[		prim _ properties propertyAt: #primitiveIndex ifAbsent:[0].		"don't preserve primitive index"		properties propertyRemoveKey: #primitiveIndex.	].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !Parser removeSelector: #primitive!Parser removeSelector: #primitiveDeclarations!                                                                                                                    