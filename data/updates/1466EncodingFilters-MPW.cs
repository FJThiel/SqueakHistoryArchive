'From Squeak 2.5 of August 6, 1999 on 11 September 1999 at 6:32:15 pm'!Object subclass: #NullEncoder	instanceVariableNames: 'target filterSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!NullEncoder subclass: #FlattenEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!FlattenEncoder subclass: #ByteEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!ByteEncoder subclass: #PrintableEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!PrintableEncoder subclass: #PrintEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!PrintableEncoder subclass: #PropertyListEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!PrintableEncoder subclass: #StoreEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'EncodingFilters'!!Object methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:30'!propertyList	"Answer a String whose characters are a property-list description of the receiver."	^ PropertyListEncoder process:self.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:42'!byteEncode:aStream	self flattenOnStream:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:31'!elementSeparator	^nil.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:07'!flattenOnStream:aStream	self writeOnFilterStream:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:51'!printOnStream:aStream	self byteEncode:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:49'!putOn:aStream	^aStream nextPut:self.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:53'!storeOnStream:aStream	self printOnStream:aStream.! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:06'!writeOnFilterStream:aStream	aStream writeObject:self.! !!ActorState methodsFor: 'other' stamp: 'MPW 1/1/1901 21:53'!printOnStream: aStream	aStream print: 'ActorState for '; print:owningPlayer externalName; print:' '.	penDown ifNotNil: [aStream cr; print: 'penDown '; write:penDown].	penColor ifNotNil: [aStream cr; print: 'penColor '; write:penColor].	penSize ifNotNil: [aStream cr; print: 'penSize '; write:penSize].	instantiatedUserScriptsDictionary ifNotNil:		[aStream cr; print:			'+ '; write: instantiatedUserScriptsDictionary size; print:' user scripts'].! !!BalloonBezierSimulation methodsFor: 'private' stamp: 'MPW 1/1/1901 21:55'!printOnStream: aStream	aStream 		print: self class name;		print:'(';		write: start;		print:' - ';		write: via;		print:' - ';		write: end;		print:')'.! !!BalloonLineSimulation methodsFor: 'printing' stamp: 'MPW 1/1/1901 21:57'!printOnStream: aStream	aStream 		print: self class name;		print:'(';		write: start;		print:' - ';		write: end;		print:')'.! !!Behavior methodsFor: 'printing' stamp: 'MPW 1/1/1901 21:56'!printOnStream: aStream 	"Refer to the comment in Object|printOn:." 	aStream print: 'a descendent of '; write:superclass.! !!Bezier2Segment methodsFor: 'printing' stamp: 'MPW 1/1/1901 21:59'!printOnStream: aStream	aStream 		print: self class name;		print:'from: ';		write: start;		print:'via: ';		write: via;		print:'to: ';		write: end;		print:' '.! !!BlockContext methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:01'!printOnStream: aStream	home == nil ifTrue: [^aStream print: 'a BlockContext with home=nil'].	aStream print: '[] in '.	super printOnStream: aStream! !!CObjectAccessor methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:01'!printOnStream: aStream	super printOnStream: aStream.	aStream		print:' on: ';		write: object.! !!ChangeSet methodsFor: 'accessing' stamp: 'MPW 1/1/1901 22:02'!printOnStream: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOnStream: aStream.	aStream print: ' named ', self name! !!Character methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:04'!printOnStream: aStream	aStream print:'$', (String with:self).! !!ClassDescription methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:05'!printOnStream: aStream 	aStream print: self name! !!ClassOrganizer methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:16'!printOnStream: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex  |	elementIndex _ 1.	1 to: categoryArray size do: 		[:i | 		aStream print: '(';		write:(categoryArray at:i).		" is the asString redundant? "		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream print:' '; write:(elementArray at: elementIndex).				elementIndex _ elementIndex + 1].		aStream print:')'.		aStream cr]! !!Collection methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:09'!contents	^self.! !!Collection methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:15'!flattenOnStream:aStream	^aStream writeCollection:self.! !!Collection methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:08'!write:anObject	^self add:anObject.! !!ArrayedCollection methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:59'!flattenOnStream:aStream	aStream writeArrayedCollection:self.! !!Array methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:42'!byteEncode:aStream	aStream writeArray:self.! !!Array methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:55'!storeOnStream:aStream	self isLiteral ifTrue: [super storeOnStream:aStream] ifFalse:[aStream writeCollection:self].! !!Bitmap methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:00'!printOnStream: aStream	aStream print: 'a Bitmap of length '; write:self size.! !!Color methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:14'!byteEncode: aStream	aStream		print: '(';		print: self class name;		print: ' r: ';		write: (self red roundTo: 0.001);		print: ' g: ';		write: (self green roundTo: 0.001);		print: ' b: ';		write: (self blue roundTo: 0.001) ;		print: ')'.! !!CompiledMethod methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:09'!printOnStream: aStream 	"Overrides method inherited from the byte arrayed collection."	aStream print: 'a CompiledMethod'! !!ControlChangeEvent methodsFor: 'printing' stamp: 'MPW 1/1/1901 22:27'!printOnStream: aStream	aStream		print:'('; write:time;		print:': ctrl['; write:control;		print:']=';write:value;		print:')'.! !!LookupKey methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 02:35'!writeOnFilterStream: aStream	aStream write:key.! !!Association methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:31'!propertyListOn: aStream	aStream write:key; print:'='; write:value.! !!Association methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 20:53'!byteEncode: aStream	aStream writeAssocation:self.! !!NullEncoder methodsFor: 'initialization' stamp: 'MPW 1/1/1901 00:04'!initWithTarget:aTarget	target _ aTarget.	filterSelector _ self class filterSelector.	^self.! !!NullEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 01:17'!forward:anObject	anObject ~= nil ifTrue:[target write:anObject].! !!NullEncoder methodsFor: 'writing' stamp: 'mpw 8/13/1999 10:54'!write:anObject	filterSelector  ifNil:[filterSelector_self class filterSelector].	anObject ifNotNil: [anObject perform:filterSelector with:self].! !!NullEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 01:16'!writeObject:anObject	^self forward:anObject.! !!NullEncoder methodsFor: 'accessing' stamp: 'MPW 1/1/1901 00:56'!contents	^target contents.! !!NullEncoder methodsFor: 'accessing' stamp: 'MPW 1/1/1901 00:16'!target	^target.! !!NullEncoder methodsFor: 'processing' stamp: 'MPW 1/1/1901 01:19'!process:anObject	self write:anObject.	^self contents.! !!FlattenEncoder commentStamp: '<historical>' prior: 0!The simplest possible encoding:  leave the objects as is.!!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 21:51'!cr	^self print:String cr.! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 21:50'!writeArrayedCollection:anArrayedCollection	^self writeCollectionContents:anArrayedCollection.! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 01:03'!writeCollection:aCollection	^self writeCollectionContents:aCollection.! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/4/1901 08:26'!writeCollectionContents:aCollection    ^self writeCollectionContents:aCollection separator:self elementSeparator iterationMessage:#do:.! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/4/1901 08:26'!writeCollectionContents:aCollection separator:separator	^self writeCollectionContents:aCollection separator:separator iterationMessage:#do:.! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/4/1901 08:25'!writeCollectionContents:aCollection separator:separator iterationMessage:op	| first |	first _ true.	aCollection perform:op with: [ :each |  first ifFalse:[ self writeObject:separator ]. self write:each. first_false.].! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/4/1901 08:30'!writeDictionary:aCollection	^self writeDictionaryContents:aCollection separator:nil.! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/4/1901 08:29'!writeDictionaryContents:aCollection separator:separator	^self writeCollectionContents:aCollection separator:separator iterationMessage:#associationsDo:.! !!FlattenEncoder methodsFor: 'accessing' stamp: 'MPW 1/1/1901 01:32'!elementSeparator	^target elementSeparator.! !!ByteEncoder methodsFor: 'accessing' stamp: 'MPW 1/1/1901 01:33'!elementSeparator	^' '.! !!ByteEncoder methodsFor: 'accessing' stamp: 'MPW 1/1/1901 22:45'!numberDefaultBase	^self class numberDefaultBase.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 15:17'!cr	^target cr.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 00:48'!print:encodedObject	^target write:encodedObject.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 02:18'!space	^target space.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 15:16'!tab	^target tab.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 20:51'!writeArray:aCollection	^self writeArrayedCollection:aCollection.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 20:53'!writeAssocation:anAssociation	^self write:anAssociation key; print:'->'; write:anAssociation value.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 02:31'!writeCollection:aCollection	^self print:aCollection class name; 		writeCollectionContents:aCollection.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 02:31'!writeCollectionContents:aCollection	self print:'( '.		super writeCollectionContents:aCollection.		self print:')'.	^self.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 22:44'!writeNumber:aNumber	^self writeNumber:aNumber base:self numberDefaultBase.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 00:03'!writeNumber:aNumber base:aBase	^aNumber byteEncode:self base:aBase.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 01:25'!writeObject:anObject	^self print:anObject stringRepresentation.! !!ByteEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 00:21'!writeString:aString	^aString encodeDoublingQuoteOn:self.! !!NullEncoder class methodsFor: 'creation' stamp: 'MPW 1/1/1901 00:55'!stream	^self streamOn:self defaultTarget. ! !!NullEncoder class methodsFor: 'creation' stamp: 'MPW 1/1/1901 00:05'!stream:newTarget	^self new initWithTarget:newTarget.! !!NullEncoder class methodsFor: 'creation' stamp: 'MPW 1/1/1901 01:15'!streamOn:newTargetCollection	^self new initWithTarget:newTargetCollection.! !!NullEncoder class methodsFor: 'creation' stamp: 'MPW 1/1/1901 02:20'!streamOnFile:fileName	^self new initWithTarget:(FileStream newFileNamed: fileName).! !!NullEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 00:02'!defaultTarget	^OrderedCollection new.! !!NullEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 00:02'!filterSelector	^#writeOnFilterStream:! !!NullEncoder class methodsFor: 'processing' stamp: 'MPW 1/1/1901 01:20'!process:anObject	^self stream process:anObject.! !!FlattenEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 00:08'!filterSelector	^#flattenOnStream:! !!ByteEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 01:18'!defaultTarget	^WriteStream on:(String new: 40000).! !!ByteEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 00:41'!filterSelector	^#byteEncode:.! !!ByteEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 22:46'!numberDefaultBase	^10.! !!Number methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:07'!byteEncode:aStream	^aStream writeNumber:self.! !!Float methodsFor: 'printing' stamp: 'MPW 1/1/1901 01:59'!absByteEncode: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream print: 'Infinity'. ^ self].	significantBits _ 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase _ base asFloat.	exp _ self exponent.	baseExpEstimate _ (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r _ self.			s _ 1.0.			mPlus _ 1.0 timesTwoPower: exp - significantBits.			mMinus _ self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r _ self timesTwoPower: significantBits.			s _ 1.0 timesTwoPower:  significantBits.			mMinus _ 1.0 timesTwoPower: (exp max: -1024).			mPlus _				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[s _ s * (fBase raisedToInteger: baseExpEstimate).			exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r _ r / fBase.					s _ s / fBase.					mPlus _ mPlus / fBase.					mMinus _ mMinus / fBase]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d _ (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale _ fBase raisedToInteger: d.					r _ r * scale.					mPlus _ mPlus * scale.					mMinus _ mMinus * scale.					scale _ fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale _ fBase raisedToInteger: baseExpEstimate negated].			s _ s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate _ baseExpEstimate + 1]		ifFalse:			[s _ s / fBase].	(fixedFormat _ baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount _ baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream print: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount _ 1].	[d _ (r / s) truncated.	r _ r - (d * s).	(tc1 _ r <= mMinus) | (tc2 _ r + mPlus >= s)] whileFalse:		[aStream print: (Character digitValue: d).		r _ r * fBase.		mPlus _ mPlus * fBase.		mMinus _ mMinus * fBase.		decPointCount _ decPointCount - 1.		decPointCount = 0 ifTrue: [aStream print: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d _ d + 1]].	aStream print: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream print: $0].		aStream print: '.0'].	fixedFormat ifFalse:		[aStream print: $e.		aStream print: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:02'!byteEncode: aStream base: base	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:" 	self isNaN ifTrue: [aStream print: 'NaN'. ^ self]. "check for NaN before sign"	self > 0.0		ifTrue: [self absByteEncode: aStream base: base]		ifFalse:			[self sign = -1				ifTrue: [aStream print: '-'].			self = 0.0				ifTrue: [aStream print: '0.0'. ^ self]				ifFalse: [aStream writeNumber:self negated base: base]]! !!Integer methodsFor: 'truncation and round off' stamp: 'MPW 1/1/1901 02:13'!roundTo:aNumber 	^self.! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 01:04'!byteEncode: aStream base: b 	"Print a representation of the receiver on the stream, aStream, in base, b, 	where 2<=b<=16."	| digits source dest i j pos t rem |	self negative ifTrue:[aStream print:$-].	i _ self digitLength.	"Estimate size of result, conservatively"	digits _ self digitBuffer:i.	pos _ 0.	dest _ self destinationBuffer:i.	source _ self.	[i >= 1]		whileTrue: 			[rem _ 0.			j _ i.			[j > 0]				whileTrue: 					[t _ (rem bitShift: 8) + (source digitAt: j).					dest digitAt: j put: t // b.					rem _ t \\ b.					j _ j - 1].			pos _ pos + 1.			digits at: pos put: rem.			source _ dest.			(source digitAt: i) = 0 ifTrue: [i _ i - 1]].	"(dest digitAt: 1) printOn: aStream base: b."	[pos > 0]		whileTrue:			[aStream print:(Character digitValue: (digits at: pos)).			pos _ pos - 1]! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:14'!destinationBuffer:digitLength  digitLength <= 1		ifTrue: [self]		ifFalse: [LargePositiveInteger new: digitLength].! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:16'!digitBuffer:digitLength  ^Array new:digitLength*8.! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 01:04'!printOn: aStream base: b 	"Print a representation of the receiver on the stream, aStream, in base, b, 	where 2<=b<=16."	| digits source dest i j pos t rem |	self negative ifTrue:[aStream nextPut:$-].	b = 10 ifFalse: [aStream print: b; nextPut: $r].	i _ self digitLength.	"Estimate size of result, conservatively"	digits _ Array new: i * 8.	pos _ 0.	dest _ i <= 1		ifTrue: [self]		ifFalse: [LargePositiveInteger new: i].	source _ self.	[i >= 1]		whileTrue: 			[rem _ 0.			j _ i.			[j > 0]				whileTrue: 					[t _ (rem bitShift: 8) + (source digitAt: j).					dest digitAt: j put: t // b.					rem _ t \\ b.					j _ j - 1].			pos _ pos + 1.			digits at: pos put: rem.			source _ dest.			(source digitAt: i) = 0 ifTrue: [i _ i - 1]].	"(dest digitAt: 1) printOn: aStream base: b."	[pos > 0]		whileTrue:			[aStream nextPut: (Character digitValue: (digits at: pos)).			pos _ pos - 1]! !!PrintEncoder class reorganize!('configuring' filterSelector)!!PrintEncoder class methodsFor: 'configuring' stamp: 'MPW 1/1/1901 01:50'!filterSelector	^#printOnStream:! !!PrintableEncoder methodsFor: 'writing' stamp: 'MPW 1/1/1901 22:50'!writeNumber:aNumber base:aBase	aBase ~= self numberDefaultBase ifTrue:[ self write:aBase; print:'r'].	^super writeNumber:aNumber base:aBase.! !!PropertyListEncoder methodsFor: 'as yet unclassified' stamp: 'MPW 1/4/1901 08:22'!writeArrayedCollection:aCollection	self print:'/* '; print:aCollection class name; print:'*/'; cr.	self print:'( '; writeCollectionContents:aCollection separator:','; print:')'.! !!PropertyListEncoder methodsFor: 'as yet unclassified' stamp: 'MPW 1/4/1901 08:32'!writeDictionary:aCollection	self print:'{ '; writeDictionaryContents:aCollection separator:'; '; print:'}'.! !!PropertyListEncoder class methodsFor: 'as yet unclassified' stamp: 'MPW 1/1/1901 00:22'!filterSelector	^#propertyListOn:.! !!Rectangle methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:18'!propertyListOn: aStream 	" {x=a; y=b; width=c; height=d} "	aStream print:'{ x='; write:origin x;			print:' y='; write:origin y;			print:' width='; write:self extent x;			print:' height='; write:self extent y;			print:'};'.! !!Set methodsFor: 'testing' stamp: 'MPW 1/1/1901 01:58'!contains: anObject 	^ self includes:anObject.! !!Dictionary methodsFor: 'printing' stamp: 'MPW 1/4/1901 08:33'!flattenOnStream:aStream	^aStream writeDictionary:self.! !!SmallInteger methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:15'!destinationBuffer:digitLength  ^ LargePositiveInteger new: digitLength.! !!StoreEncoder class methodsFor: 'as yet unclassified' stamp: 'MPW 1/1/1901 01:52'!filterSelector    ^#storeOnStream:.! !!Stream methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 00:48'!write:encodedObject	^encodedObject putOn:self.! !!String methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:22'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do:		[:i |		aStream print: (x _ self at: i).		x == $' ifTrue: [aStream print: x]].	aStream print: $'! !!String methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:17'!byteEncode:aStream	^aStream writeString:self.! !!String methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 23:02'!putOn:aStream	^aStream nextPutAll:self.! !!Symbol methodsFor: 'filter streaming' stamp: 'mpw 1/1/1901 00:20'!byteEncode:aStream	^aStream writeSymbol:self.! !LargeNegativeInteger removeSelector: #printOn:base:!