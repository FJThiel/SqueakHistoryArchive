'From Squeak2.9alpha of 13 June 2000 [latest update: #2811] on 5 October 2000 at 8:26:14 pm'!"Change Set:		WeightWatchers-arDate:			5 October 2000Author:			Andreas RaabThe Weight Watchers came visiting HandMorph. After they left (only for a brief time) they reported that HandMorph lost:- 20 instance variables- ~110 methods- ~50k in source code.So HandMorph just lost half its weight in a single day. Try *that* in the real world ... what a 'Rosskur' (untranslatable)!!Known pitfall: Some of this has been achieved by moving code around to other parties. But their time will come soon."!Morph subclass: #HandMorph	instanceVariableNames: 'eventSubscribers keyboardFocus mouseDownMorph mouseOverMorphs mouseOverTimes dragOverMorphs clickClient clickState firstClickEvent firstClickTime userInitials lastEvent eventTransform argument targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset grid gridOn remoteConnections transmitBuffer lastEventTransmitted lastWorldExtent menuTargetOffset hasChanged savedPatch suppressDrawing formerOwner formerPosition addedFlexAtGrab currentCommand worldUnderCursor eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent mouseFocus '	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!!ActorState methodsFor: 'pen' stamp: 'ar 10/5/2000 18:50'!choosePenColor: evt	owningPlayer costume changeColorTarget: owningPlayer costume selector: #penColor: originalColor: owningPlayer penColor hand: evt hand.! !!Color methodsFor: 'Morphic menu' stamp: 'ar 10/5/2000 18:50'!changeColorIn: aMorph event: evt	"Note: This is just a workaround to make sure we don't use the old color inst var"	aMorph changeColorTarget: aMorph selector: #fillStyle: originalColor: self hand: evt hand! !!DisplayScreen methodsFor: 'other' stamp: 'ar 10/5/2000 18:59'!checkCurrentHandForObjectToPaste	| response |	self flag: #bob.		World currentHand pasteBuffer ifNil: [^self].	response _ (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			World currentHand pasteBuffer printString.	response = 1 ifTrue: [World currentHand pasteBuffer: nil].! !!DisplayScreen methodsFor: 'other' stamp: 'ar 10/5/2000 18:59'!checkCurrentHandForObjectToPaste2	self flag: #bob.		World currentHand pasteBuffer ifNil: [^self].	self inform: 'Hand is holding a Morph in its paste buffer:\' withCRs,		World currentHand pasteBuffer printString.! !!DisplayScreen methodsFor: 'other' stamp: 'ar 10/5/2000 16:17'!restoreMorphicDisplay	DisplayScreen startUp.	(self getOuterMorphicWorld ifNil: [^ self])		extent: self extent;		viewBox: self boundingBox;		handsDo: [:h | h visible: true; showTemporaryCursor: nil];		restoreFlapsDisplay;		fullRepaintNeeded! !!Morph methodsFor: 'classification' stamp: 'ar 10/5/2000 16:40'!isMorphicModel	^false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:00'!aboutToBeGrabbedBy: aHand	"The receiver is being grabbed by a hand.	Perform necessary adjustments (if any) and return the actual morph	that should be added to the hand."	| extentToHandToHand cmd |	self formerOwner: owner.	self formerPosition: self position.	cmd _ self undoGrabCommand.	cmd ifNotNil:[self setProperty: #undoGrabCommand toValue: cmd].	(extentToHandToHand _ self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand].	^self "Grab me"! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:13'!formerOwner	^self valueOfProperty: #formerOwner! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:13'!formerOwner: aMorphOrNil	aMorphOrNil == nil		ifTrue:[self removeProperty: #formerOwner]		ifFalse:[self setProperty: #formerOwner toValue: aMorphOrNil]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:13'!formerPosition	^self valueOfProperty: #formerPosition! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:12'!formerPosition: formerPosition	formerPosition == nil		ifTrue:[self removeProperty: #formerPosition]		ifFalse:[self setProperty: #formerPosition toValue: formerPosition]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:04'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow partsBinCase cmd |	self formerOwner: nil.	self formerPosition: nil.	cmd _ self valueOfProperty: #undoGrabCommand.	cmd ifNotNil:[aMorph rememberCommand: cmd.				self removeProperty: #undoGrabCommand].	(partsBinCase _ aMorph isPartsBin) ifFalse:		[self isPartsDonor: false].	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	(self isInWorld and: [partsBinCase not]) ifTrue:		[self world startSteppingSubmorphsOf: self]  	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 19:23'!rejectDropMorphEvent: evt	"The receiver has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is whisked to the Trash"	(self formerOwner notNil and: [self formerOwner isPartsBin not]) ifTrue:		[^ self slideBackToFormerSituation: evt].	self formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ self vanishAfterSlidingTo: self formerPosition event: evt].			self slideToTrash: evt! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:19'!slideBackToFormerSituation: evt	| slideForm formerOwner formerPosition aWorld startPoint endPoint trans |	formerOwner _ self formerOwner.	formerPosition _ self formerPosition.	aWorld _ self world.	trans _ formerOwner transformFromWorld.	trans isPureTranslation 		ifTrue: [slideForm _ self imageForm offset: 0@0]		ifFalse: [slideForm _ ((TransformationMorph new asFlexOf: self) transform: trans)								imageForm offset: 0@0].	startPoint _ evt hand fullBounds origin.	endPoint _ trans localPointToGlobal: formerPosition.	owner privateRemoveMorph: self.	aWorld displayWorld.	slideForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:15'!undoGrabCommand	"Return the undo command for grabbing the receiver"	| cmd |	^(cmd _ Command new)		cmdWording: 'move ', (self externalName truncateTo: 10);		undoTarget: self		selector: #undoMove:redo:owner:bounds:predecessor:		arguments: {cmd. false. owner. self bounds. (owner morphPreceding: self)}! !!Morph methodsFor: 'menus' stamp: 'ar 10/5/2000 19:20'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	self player ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' target: self action: #makeNewPlayerInstance:.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'].	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.self flag: #arNote. "fix this""	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn]."	aMenu defaultTarget: self.	aMenu addUpdating: #lockedString action: #lockUnlockMorph.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'ar 10/5/2000 18:24'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| realOwner realMorph |	"Add morph-specific items to the given menu which was invoked by the given hand.  Note the special-casing of Worlds, for which some of the the otherwise generic items are excluded."	self isWorldMorph		ifFalse:			[aCustomMenu add: 'add drop-shadow' action: #addDropShadow.			(self isKindOf: SystemWindow)				ifFalse: [aCustomMenu add: 'put in a window' action: #embedInWindow].			aCustomMenu addUpdating: #stickinessString target: self action: #toggleStickiness.			aCustomMenu add: 'adhere to edge...' action: #adhereToEdge]		ifTrue:			[aCustomMenu add: 'desktop menu...' target: self action: #putUpDesktopMenu:.			aCustomMenu addLine].	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aCustomMenu hand: aHandMorph].	realOwner _ (realMorph _ self topRendererOrSelf) owner.	(realOwner isKindOf: TextPlusPasteUpMorph) ifTrue:		[aCustomMenu add: 'GeeMail stuff...' subMenu: (realOwner textPlusMenuFor: realMorph)]! !!Morph methodsFor: 'menus' stamp: 'ar 10/5/2000 17:20'!allMenuWordings	| tempMenu |	tempMenu _ self buildHandleMenu: self currentHand.	tempMenu allMorphsDo: [:m | m step].  "Get wordings current"	^ tempMenu allWordings! !!Morph methodsFor: 'menus' stamp: 'ar 10/5/2000 18:47'!doMenuItem: menuString	| aMenu anItem aNominalEvent aHand |	aMenu _ self buildHandleMenu: (aHand _ self currentHand).	aMenu allMorphsDo: [:m | m step].  "Get wordings current"	anItem _ aMenu itemWithWording: menuString.	anItem ifNil:		[^ self player scriptingError: 'Menu item not found: ', menuString].	aNominalEvent _  MorphicEvent new		setMousePoint: 0@0		buttons: Sensor primMouseButtons		lastEvent: aHand lastEvent		hand: aHand.	anItem invokeWithEvent: aNominalEvent! !!Morph methodsFor: 'menus' stamp: 'ar 10/5/2000 16:55'!inspectInMorphic: evt	evt hand attachMorph: ((Inspector openAsMorphOn: self) extent: 300@200)! !!Morph methodsFor: 'e-toy support' stamp: 'ar 10/5/2000 18:19'!referencePlayfield	"Answer the PasteUpMorph to be used for cartesian-coordinate reference"	| former |	owner ifNotNil:		[owner isPlayfieldLike ifTrue: [^ owner].		(owner isHandMorph and: [(former _ self formerOwner) notNil])			ifTrue:				[^ former isPlayfieldLike 					ifTrue: [former]					ifFalse: [former referencePlayfield]]].	^ self world! !!Morph methodsFor: 'debug and other' stamp: 'ar 10/5/2000 17:04'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self buildDebugMenu: aHandMorph)! !!Morph methodsFor: 'debug and other' stamp: 'ar 10/5/2000 17:38'!buildDebugMenu: aHand	| aMenu aPlayer |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect].     aMenu add: 'explore morph' target: self selector: #explore.	(aPlayer _ self player) ifNotNil:		[aMenu add: 'inspect player' target: aPlayer action: #inspect.		Smalltalk isMorphic ifFalse: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic:]].	aMenu addLine.	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aPlayer ifNotNil: 		[aMenu add: 'browse player class' target: aPlayer action: #inspect].	aMenu 		addLine;		add: 'make own subclass' action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file'  action: #saveOnFile;		addLine;		add: 'call #tempCommand' action: #callTempCommand;		add: 'define #tempCommand' action: #defineTempCommand;		addLine;		add: 'control-menu...' target: self selector: #invokeMetaMenu:;		add: 'edit balloon help' action: #editBalloonHelpText.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'ar 10/5/2000 17:38'!inspectArgumentsPlayerInMorphic: evt	evt hand attachMorph: ((Inspector openAsMorphOn: self player) extent: 300@200)! !!Morph methodsFor: 'WiW support' stamp: 'ar 10/5/2000 19:25'!eToyRejectDropMorph: morphToDrop event: evt	| tm am |	tm _ TextMorph new 		beAllFont: ((TextStyle named: #ComicBold) fontOfSize: 24);		contents: 'GOT IT!!'.	(am _ AlignmentMorph new)		color: Color yellow;		inset: 10;		useRoundedCorners;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		addMorph: tm;		fullBounds;		position: (self bounds center - (am extent // 2));		openInWorld: self world.	(SampledSound soundNames includes: 'yum') ifFalse: [		(FileDirectory default fileExists: '') ifTrue: [			SampledSound addLibrarySoundNamed: 'yum' fromAIFFfileNamed: 'yum.aif'		].	].	(SampledSound soundNames includes: 'yum') ifTrue: [		SampledSound playSoundNamed: 'yum'	].	morphToDrop rejectDropMorphEvent: evt.		"send it back where it came from"	am delete! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/5/2000 17:06'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingTriggersFor: self. "balloon & halo"	anEvent wasHandled: true.	self flag: #arNote. "For now bail out into hand meta menu"	anEvent controlKeyPressed ifTrue:[^self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/5/2000 19:25'!rejectDropEvent: anEvent	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."	(self repelsMorph: anEvent contents event: anEvent) ifFalse:[^self]. "not repelled"	(self fullContainsPoint: anEvent position) ifFalse:[^self]. "not for me"	"Throw it away"	anEvent wasHandled: true.	anEvent contents rejectDropMorphEvent: anEvent.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:51'!beThisWorldsModel	self world setModel: self.	self model: nil slotName: nil.	"A world's model cannot have another model"! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 17:20'!buildHandleMenu: aHand	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	menu _ MenuMorph new defaultTarget: aHand.	menu addStayUpItem.	self addAddHandMenuItemsForHalo: menu hand: aHand.	menu defaultTarget: self.	self addCustomHaloMenuItems: menu hand: aHand.	menu addLine.	self player ifNotNil: [self player addPlayerMenuItemsTo: menu hand: aHand].	menu defaultTarget: aHand.	^ menu! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:56'!buildMetaMenu: evt	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph:.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	self maybeAddCollapseItemTo: menu.	menu add: 'delete' action: #dismissMorph:.	menu addLine.	menu add: 'copy Postscript' action: #clipPostscript.	menu add: 'print PS to file...' action: #printPSToFile.	menu addLine.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo:.	menu add: 'duplicate' action: #maybeDuplicateMorph:.self flag: #arNote. "fix this"	"self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn]."	menu add: 'resize' action: #resizeMorph:.	"Give the argument control over what should be done about fill styles"	self addFillStyleMenuItems: menu hand: evt hand.self flag: #arNote. "fix this""	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine."	menu add: 'inspect' action: #inspectInMorphic:.	menu add: 'explore' action: #explore.	menu add: 'browse hierarchy' action: #browseHierarchy.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' action: #choosePartName.	(self isMorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(self ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	(self hasProperty: #resourceFilePath)		ifTrue: [((self valueOfProperty: #resourceFilePath) endsWith: '.morph')				ifTrue: [menu add: 'save as resource' action: #saveAsResource].				menu add: 'update from resource' action: #updateFromResource]		ifFalse: [menu add: 'attach to resource' action: #attachToResource].	menu add: 'show actions' action: #showActions.	menu addLine.	self addCustomMenuItems: menu hand: evt hand.	^ menu! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 18:54'!changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"	^ ColorPickerMorph new		choseModalityFromPreference;		sourceHand: aHand;		target: anObject;		selector: aSymbol;		originalColor: aColor;		putUpFor: anObject near: (anObject isMorph					ifTrue:	 [Rectangle center: self position extent: 20]					ifFalse: [anObject == self world								ifTrue: [anObject viewBox bottomLeft + (20@-20) extent: 200]								ifFalse: [anObject fullBoundsInWorld]]);		yourself! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:44'!copyToPasteBuffer: evt	self okayToDuplicate ifTrue:[evt hand copyToPasteBuffer: self].! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:46'!dismissMorph: evt	| w |	w _ self world ifNil:[^self].	w abandonAllHalos; stopStepping: self.	self delete! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 19:33'!duplicateMorph: evt	"Make and return a duplicate of the receiver's argument"	| dup |	dup _ self duplicate.	evt hand grabMorphFromMenu: dup inWorld: self world.	^dup! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 19:33'!grabMorph: evt	evt hand grabMorphFromMenu: self inWorld: self world.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:54'!invokeMetaMenu: evt	| menu |	menu _ self buildMetaMenu: evt.	menu addTitle: self externalName.	menu popUpEvent: evt in: self world! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 19:20'!makeNewPlayerInstance: evt	"Make a duplicate of the receiver's argument.  This is called only where the argument has an associated Player as its costumee, and the intent here is to make another instance of the same uniclass as the donor Player itself.  Much works, but there are flaws so this shouldn't be used without recognizing the risks"	evt hand attachMorph: self usableSiblingInstance! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 17:32'!maybeDuplicateMorph: evt	self okayToDuplicate ifTrue:[^self duplicateMorph: evt]! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:49'!resizeMorph: evt	| handle minExtent |	self isAlignmentMorph		ifTrue: [minExtent _ self minWidth @ self minHeight]		ifFalse: [minExtent _ 1@1].	handle _ HandleMorph new forEachPointDo:		[:newPoint | self extent: (((self griddedPoint: newPoint)											 - self bounds topLeft)										max: minExtent)].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:50'!saveAsPrototype	(SelectionMenu confirm: 'Make this morph the prototype for ', self class printString, '?')		ifFalse: [^ self].	self class prototype: self.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:52'!showActions	"Put up a message list browser of all the code that this morphwould run for mouseUp, mouseDown, mouseMove, mouseEnter, mouseLeave, andmouseLinger.  tk 9/13/97"	| list cls selector |	"the eventHandler"	self eventHandler ifNil: [list _ SortedCollection new]			ifNotNil: [				list _ self eventHandler messageList.				(self eventHandler handlesMouseDown: nil) 					ifFalse:[list add: 'HandMorph grabMorph:']].	"If not those, then non-default raw events"	#(keyStroke: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp:	doButtonAction)		do: [:sel |			cls _ self class classThatUnderstands: sel.			cls ifNotNil: ["want more than default behavior"				cls == Morph ifFalse: [list add: cls name, ' ',sel]]].	"The mechanism on a Button"	(self respondsTo: #actionSelector) ifTrue: ["A button"		selector _ self actionSelector.		cls _ self target class classThatUnderstands: selector.			cls ifNotNil: ["want more than default behavior"				cls == Morph ifFalse: [list add: cls name, ' ',selector]]].	MessageSet openMessageList: list name: 'Actions of ', self printString.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 19:21'!showHiders	self allMorphsDo:[:m | m show]! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:50'!subclassMorph	"Create a new subclass of this morph's class and make this morph be an instance of it."	| oldClass newClassName newClass newMorph |	oldClass _ self class.	newClassName _ FillInTheBlank		request: 'Please give this new class a name'		initialAnswer: oldClass name.	newClassName = '' ifTrue: [^ self].	(Smalltalk includesKey: newClassName)		ifTrue: [^ self inform: 'Sorry, there is already a class of that name'].	newClass _ oldClass subclass: newClassName asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: oldClass category asString.	newMorph _ self as: newClass.	self become: newMorph.! !!BorderedMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:50'!changeBorderColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #borderColor: originalColor: self borderColor hand: aHand! !!BookMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:55'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'goto page' action: #goToPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide page controls' action: #hidePageControls.			subMenu add: 'fewer page controls' action: #fewerPageControls]		ifFalse:			[subMenu add: 'show page controls' action: #showPageControls].	self isInFullScreenMode ifTrue: [		subMenu add: 'exit full screen' action: #exitFullScreen.	] ifFalse: [		subMenu add: 'show full screen' action: #goFullScreen.	].	subMenu addLine.	subMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	subMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	subMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'uncache page sorter' action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	subMenu addLine.	subMenu add: 'search for text' action: #textSearch.	(aHandMorph pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	subMenu add: 'send all pages to server' action: #savePagesOnURL.	subMenu add: 'send this page to server' action: #saveOneOnURL.	subMenu add: 'reload all from server' action: #reload.	subMenu add: 'copy page url to clipboard' action: #copyUrl.	subMenu add: 'keep in one file' action: #keepTogether.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: 'book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:56'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'find...' action: #textSearch.	aMenu add: 'go to page...' action: #goToPage.	aMenu addLine.	aMenu addList:		#(('sort pages'			sortPages)		('uncache page sorter'	uncachePageSorter)).	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' selector: #setWrapPages: argument: false].	aMenu addList:		#(('make bookmark'		bookmarkForThisPage)		('make thumbnail'		thumbnailForThisPage)).	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu addLine.	aMenu add: 'sound effect for all pages' action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'   action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #toggleDragNDrop.	aMenu add: 'make all pages this size' action: #makeUniformPageSize.	aMenu add: 'send all pages to server' action: #savePagesOnURL.	aMenu add: 'send this page to server' action: #saveOneOnURL.	aMenu add: 'reload all from server' action: #reload.	aMenu add: 'copy page url to clipboard' action: #copyUrl.	aMenu add: 'keep in one file' action: #keepTogether.	aMenu addLine.	aMenu add: 'load PPT images from slide #1' action: #loadImagesIntoBook.	aMenu add: 'background color for all pages...' action: #setPageColor.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!ChineseCheckerPiece methodsFor: 'all' stamp: 'ar 10/5/2000 20:02'!justDroppedInto: newOwner event: evt	newOwner == myBoard ifFalse:		["Only allow dropping into my board."		^self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!ChineseCheckers methodsFor: 'drag and drop' stamp: 'ar 10/5/2000 19:23'!acceptDroppingMorph: aPiece event: evt	| dropLoc |	super acceptDroppingMorph: aPiece event: evt.	dropLoc _ self boardLocAt: evt cursorPoint.	dropLoc = aPiece boardLoc ifTrue:  "Null move"		[^ aPiece rejectDropMorphEvent: evt].	(plannedMove _ (self allMovesFrom: aPiece boardLoc)				detect: [:move | move last = dropLoc]				ifNone: [nil])		ifNil: [^ aPiece rejectDropMorphEvent: evt.   "Not a valid move"].	movePhase _ 1.  "Start the animation if any."! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:24'!acceptDroppingMorph: morphToDrop event: evt	| outData |	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [		"don't send these"		^morphToDrop rejectDropMorphEvent: evt	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we will keep a copy"	(morphToDrop isKindOf: EToySenderMorph) ifTrue: [		self class addRecipient: morphToDrop.		^self rebuild	].	self stopFlashing.	outData _ morphToDrop veryDeepCopy eToyStreamedRepresentationNotifying: self.	self resetIndicator: #working.	self class fridgeRecipients do: [ :each |		self transmitStreamedObject: outData to: each ipAddress	].! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:24'!acceptDroppingMorph: morphToDrop event: evt	(morphToDrop isKindOf: EToySenderMorph) ifFalse: [		^morphToDrop rejectDropMorphEvent: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we don't really want it"	self updateIPAddressField: targetIPAddresses,{morphToDrop ipAddress}.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:58'!aboutToBeGrabbedBy: aHand	| aFridge |	super aboutToBeGrabbedBy: aHand.	aFridge _ self ownerThatIsA: EToyFridgeMorph.	aFridge ifNil: [^self].	aFridge noteRemovalOf: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:24'!acceptDroppingMorph: morphToDrop event: evt	| myCopy outData |	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [			"don't send these"		^morphToDrop rejectDropMorphEvent: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we don't really want it"	myCopy _ morphToDrop veryDeepCopy.	"gradient fills require doing this second"	myCopy setProperty: #positionInOriginatingWorld toValue: morphToDrop position.	self stopFlashing.	outData _ myCopy eToyStreamedRepresentationNotifying: self.	self resetIndicator: #working.	self transmitStreamedObject: outData.! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/5/2000 20:09'!pauseIn: aWorld	"Suspend playing or recording, either as part of a stop command,	or as part of a project switch, after which it will be resumed."	state = #play ifTrue:		[state _ #suspendedPlay.		playHand delete.		aWorld removeHand: playHand.		playHand _ nil].	state = #record ifTrue:		[state _ #suspendedRecord.		recHand removeEventListener: self.		recHand _ nil].	voiceRecorder ifNotNil:		[voiceRecorder pause.		startSoundEvent ifNotNil:			[startSoundEvent sound: voiceRecorder recordedSound.			voiceRecorder clearRecordedSound.			startSoundEvent _ nil]].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/5/2000 20:08'!resumeRecordIn: aWorld	recHand _ aWorld activeHand ifNil: [aWorld primaryHand].	recHand newKeyboardFocus: aWorld.	recHand addEventListener: self.	lastEvent _ nil.	state _ #record.	voiceRecorder ifNotNil:		[voiceRecorder clearRecordedSound.		voiceRecorder resumeRecording.		startSoundEvent _ MorphicSoundEvent new.		startSoundEvent setCursorPoint: recHand lastEvent cursorPoint.		tapeStream nextPut: 0 -> startSoundEvent].	self synchronize.! !!FlashMorph methodsFor: 'events' stamp: 'ar 10/5/2000 19:58'!aboutToBeGrabbedBy: aHand	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player |	super aboutToBeGrabbedBy: aHand.	player _ self flashPlayer.	player ifNotNil:[player noticeRemovalOf: self].	self transform: (self transformFrom: self world).	"If extracted from player and no default AA level is set use prefs"	(player notNil and:[self defaultAALevel == nil]) ifTrue:[		Preferences extractFlashInHighQuality ifTrue:[self defaultAALevel: 2].		Preferences extractFlashInHighestQuality ifTrue:[self defaultAALevel: 4].	].	^self "Grab me"! !!FlashProgressMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:51'!changeProgressColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #progressColor: originalColor: self progressColor hand: aHand.! !!FlashSorterMorph methodsFor: 'interaction' stamp: 'ar 10/5/2000 18:42'!mouseStillDown: evt onItem: aMorph	| pt index m yOffset |	submorphs do:[:mm|		mm == aMorph ifFalse:[mm isSelected: false]].	pt _ evt cursorPoint.	yOffset _ self offset y.	index _ aMorph frameNumber. "What a fake hack@!!"	pt y - yOffset < 0 ifTrue:[		owner scrollBy: 0@owner scrollDeltaHeight].	pt y - yOffset > self extent y ifTrue:[		owner scrollBy: 0@owner scrollDeltaHeight negated].	(aMorph bounds containsPoint: pt) ifTrue:[^self].	(pt y > aMorph bottom or:[pt x > aMorph right]) ifTrue:[		"Select all morphs forward."		index+1 to: submorphs size do:[:i|			m _ submorphs at: i.			m isSelected: aMorph isSelected.			(m bounds containsPoint: pt) ifTrue:[^self]. "Done"		].		^self].	"Select morphs backwards"	index-1 to: 1 by: -1 do:[:i|		m _ submorphs at: i.		m isSelected: aMorph isSelected.		(m bounds containsPoint: pt) ifTrue:[^self].	].! !!GradientFillMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 18:52'!setGradientColor: evt	self changeColorTarget: self selector: #gradientFillColor: originalColor: fillColor2 hand: evt hand! !!GraphicalDictionaryMenu methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:29'!initializeFor: aTarget fromDictionary: aDictionary	|  imageWrapper anIndex aButton controlsWrapper asm |	self orientation: #vertical.	self addMorphBack: (controlsWrapper _ AlignmentMorph newRow).	self baseDictionary: aDictionary.	target _ aTarget.	coexistWithOriginal _ true.	color _ Color white.	borderColor _ Color blue darker.	borderWidth _ 1.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	controlsWrapper borderWidth: 0; inset: 0; hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlsWrapper centering: #topLeft; color: Color white; vResizing: #spaceFill.	controlsWrapper addTransparentSpacerOfSize: (18@0).	controlsWrapper addMorphBack: (IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'Menu'); color: Color transparent; 			actWhen: #buttonDown;			actionSelector: #showMenu; target: self;			setBalloonText: 'menu').	controlsWrapper  addTransparentSpacerOfSize: (14@0).	aButton _ SimpleButtonMorph new target: self; borderColor: Color black.	controlsWrapper addMorphBack: (aButton fullCopy		label: 'Prev';		actionSelector: #downArrowHit;		actWhen: #whilePressed;		setBalloonText: 'show previous picture';		yourself).	controlsWrapper addTransparentSpacerOfSize: (15@0).	controlsWrapper addMorphBack: (aButton fullCopy label: 'Next';	actionSelector: #upArrowHit; actWhen: #whilePressed; setBalloonText: 'show next pictutre').	self addMorphBack: controlsWrapper.	self addTransparentSpacerOfSize: (0 @ 12).	self addMorphBack:  (asm _ UpdatingStringMorph new contents: ' '; target: self; putSelector: #renameGraphicTo:; getSelector: #truncatedNameOfGraphic; useStringFormat).	asm setBalloonText: 'The name of the current graphic'. 	self addTransparentSpacerOfSize: (0 @ 12).	self addMorphBack: (AlignmentMorph newRow height: 4; borderWidth: 0; color: Color black).	imageWrapper _ Morph new color: Color transparent; extent: 190 @ 82.	imageWrapper addMorphBack: (formDisplayMorph _ ImageMorph new extent: 100 @ 100).	self addMorphBack: imageWrapper.	target ifNotNil: [(anIndex _ formChoices indexOf: target form ifAbsent: [nil]) ifNotNil:		[currentIndex _ anIndex]].	self updateThumbnail! !!GraphicalDictionaryMenu methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:31'!showMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList: #(		('remove'			removeEntry)		('rename'			renameEntry)		('repaint'			repaintEntry)		-		('find...'			findEntry)		-		('hand me one'		handMeOne)).	aMenu popUpInWorld: self currentWorld.! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/5/2000 17:05'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	evt shiftPressed ifTrue: 		[self delete.		^ innerTarget inspectInMorphic: evt].	menu _ innerTarget buildDebugMenu: evt hand.	menu addTitle: innerTarget externalName.	menu popUpEvent: evt in: self world.! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/5/2000 17:33'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	(target isKindOf: SelectionMorph) ifTrue:		[^ target doDup: evt fromHalo: self handle: dupHandle].	self setTarget: (target duplicateMorph: evt).	self removeAllHandlesBut: dupHandle.! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/5/2000 17:20'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my inner target."	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	menu _ innerTarget buildHandleMenu: evt hand.	self showingDirectionHandles		ifTrue: [menu add: 'hide direction handles' target: self selector: #showDirectionHandles: argument: false]		ifFalse: [menu add: 'show direction handles' target: self selector: #showDirectionHandles: argument: true].	target addDropShadowItemsTo: menu hand: evt hand.	innerTarget addTitleForHaloMenu: menu.	menu popUpEvent: evt in: self world.! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/5/2000 20:13'!initForEvents	lastEvent _ MorphicEvent new.	self resetClickState.! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/5/2000 20:17'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	cachedCanvasHasHoles _ false.	remoteConnections _ OrderedCollection new.	temporaryCursor _ temporaryCursorOffset _ nil! !!HandMorph methodsFor: 'accessing' stamp: 'ar 10/5/2000 20:12'!mouseFocus	^mouseFocus! !!HandMorph methodsFor: 'drawing' stamp: 'ar 10/5/2000 16:19'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds |	self visible ifFalse:[^self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas == nil or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])		ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: [aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:02'!checkForMoreKeyboard	"Quick check for more keyboard activity -- Allows, eg, many characters	to be accumulated into a single replacement during type-in."	| oldPoint |	self flag: #arNote. "This is very unlikely to work"	Sensor keyboardPressed ifFalse: [^ nil].	oldPoint _ lastEvent cursorPoint.	lastEvent _ MorphicEvent new		setKeyValue: Sensor keyboard asciiValue		mousePoint: oldPoint		buttons: Sensor primMouseButtons		hand: self.	remoteConnections size > 0 ifTrue: [self transmitEvent: lastEvent].	^ lastEvent! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:03'!flushEvents	"Flush any events that may be pending"	self flag: #arNote. "Remove it and fix senders"	Sensor flushEvents.	"And bring button state up to date."	lastEvent _ lastEvent copy setButtons: Sensor primMouseButtons.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 20:12'!handleEvent: anEvent	| evt prevEvt |	anEvent isMorphicEvent 		ifTrue:[evt _ anEvent]		ifFalse:[			prevEvt _ lastEvent.			lastEvent _ anEvent.			evt _ anEvent asNewEventFrom: prevEvt].	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: mouseFocus].ShowEvents == true ifTrue:[	evt printString displayAt: (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: 0@45.].	"Notify listeners"	self sendListenEvent: evt to: eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: keyboardListeners.		self sendEvent: evt focus: keyboardFocus.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[self sendListenEvent: evt to: mouseListeners].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[(mouseClickState handleEvent: evt from: self) ifFalse:[^self]].	evt isMove ifTrue:[		self position: evt position.		self sendEvent: evt focus: mouseFocus.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on non-move mouse events"		(self hasSubmorphs) ifTrue:[self dropMorphs: evt].		self sendEvent: evt focus: mouseFocus.	].	ShowEvents == true ifTrue:[mouseFocus printString displayAt: 0@15].	evt isMouse ifTrue:[lastMouseEvent _ evt].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:00'!moveToEvent: anEvent	"Issue a mouse move event to make the receiver appear at the given position"	self handleEvent: (MouseMoveEvent new		setType: #mouseMove 		startPoint: self position 		endPoint: anEvent position 		trail: #()		buttons: anEvent buttons		hand: self).! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 20:13'!newMouseFocus: aMorphOrNil	| itsPasteUp toView |	self flag: #arNote. "Clean this up"	aMorphOrNil ifNotNil: 		[((itsPasteUp  _ aMorphOrNil pasteUpMorph) notNil and:			[itsPasteUp automaticViewing]) ifTrue:				[toView _ itsPasteUp					submorphThat:						[:aMorph | aMorphOrNil hasOwner: aMorph]					ifNone:						[nil].				(toView notNil and: [toView isCandidateForAutomaticViewing]) ifTrue:					[toView openViewerForArgument]]].	mouseFocus _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 20:08'!pauseEventRecorderIn: aWorld	"Suspend any recorder prior to a project change, and return it.	It will be resumed after starting the new project."	eventListeners ifNil:[^nil].	eventListeners do:		[:er | (er isKindOf: EventRecorderMorph) ifTrue: [^ er pauseIn: aWorld]].	^ nil! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 20:15'!processEvents	"Process user input events from the local input devices.	Note: Ugly as it is, several places in Morphic currently rely on sending at least one mouse event per cycle. There's no way around this so we're checking if the first event is a mouse event and if not, we synthesize one.	Another interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized.	When event processing lags behind event gathering, as in drag operations, the loop in this method can cause the display never to get updated.  Also in this case, it is frequently a waste to process any but the most recent mouse move.  For this reason, lagging events will be skipped whenever possible, and the loop will be exited to allow a display update cycle."	| evt currentExtent evtBuf type hadMouse eventsLagging latestBuf |	hadMouse _ false. "see first note above"	eventsLagging _ false.	[evtBuf _ Sensor nextEvent.	eventsLagging		or: [evtBuf isNil and: [hadMouse]]]		whileFalse: [		evtBuf == nil ifTrue:[			"Make us a fake mouse event so hadMouse will be true"			evtBuf _ Array with: EventTypeMouse							with: Time millisecondClockValue							with: lastEvent cursorPoint x							with: lastEvent cursorPoint y							with: (lastEvent buttons bitAnd: 7)							with: (lastEvent buttons bitShift: 3)].		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		type = EventTypeMouse ifTrue:[			hadMouse _ true.			(mouseFocus notNil and: [mouseFocus wantsEveryMouseMove]) ifFalse:				["Unless forbidden, skip over any lagging events"				latestBuf _ self latestEventSimilarTo: evtBuf.				latestBuf == evtBuf ifFalse: [eventsLagging _ true.  evtBuf _ latestBuf]].			evt _ MorphicEvent new				setMousePoint: (evtBuf at: 3) @ (evtBuf at: 4)				buttons: (evtBuf at: 5)				modifiers: (evtBuf at: 6)				lastEvent: lastEvent				hand: self].		(type = EventTypeKeyboard) ifTrue:[			evt _ MorphicEvent new				setKeyValue: (evtBuf at: 3)				type: (evtBuf at: 4)				mousePoint: self position				modifiers: (evtBuf at: 5)				hand: self].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			self lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				self lastWorldExtent: currentExtent].			self transmitEvent: evt].		"Finally, handle it"		self handleEvent: evt.		"See the note on running a World in MVC in the method comment"		(hadMouse and:[Sensor eventQueue == nil]) ifTrue:[^self].	].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 20:12'!releaseAllFoci	mouseFocus _ nil.	keyboardFocus _ nil.! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 20:13'!releaseMouseFocus: aMorph	"If the given morph had the mouse focus before, release it"	self mouseFocus == aMorph ifTrue:[self releaseMouseFocus].! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:09'!testEvent: evt ifQuickClick: quickClickBlock ifMoved: movedBlock	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	| firstPt |self flag: #arNote. "Remove this - we have #waitForClicksOrDrag for this very purpose"	firstPt _ Sensor cursorPoint.	"evt may be translated from normal coords"	(Delay forMilliseconds: 200) wait.	Sensor anyButtonPressed ifFalse: [^ quickClickBlock value].	((Sensor cursorPoint - firstPt) abs < (3@3)) ifFalse: [^ movedBlock value]! !!HandMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:12'!updateMouseDownTransform	"To help with, eg, autoscrolling"self flag: #arNote. "Remove this"	"mouseDownMorph		ifNil: [eventTransform _ MorphicTransform identity]		ifNotNil: [eventTransform _ mouseDownMorph transformFrom: self]."! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 18:20'!attachMorph: m	"Position the center of the given morph under this hand, then grab it.	This method is used to grab far away or newly created morphs."	| delta |	delta _ m bounds extent // 2.	m position: (self position - delta).	m formerPosition: m position.	self addMorphBack: m.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 19:24'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event |	event _ DropEvent new setPosition: self position contents: aMorph hand: self."event printString displayAt: 0@30."	owner processEvent: event.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 16:23'!dropMorphs	"Drop the morphs at the hands position"	self dropMorphs: lastMouseEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 19:40'!grabMorph: aMorph	^self grabMorph: aMorph in: aMorph world! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 19:39'!grabMorph: aMorph in: aWorld	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor |	aMorph isTileLike ifTrue: [		editor _ aMorph topEditor	].	(aMorph owner isKindOf: DropShadowMorph) ifTrue: [		self grabMorph: aMorph owner in: aWorld.		^ editor ifNotNil: [editor scriptEdited]	].	self grabMorphInner: ((aMorph aboutToBeGrabbedBy: self) ifNil: [^self]) inWorld: aWorld.	editor ifNotNil: [editor scriptEdited].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 19:34'!grabMorphFromMenu: m inWorld: aWorld	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	(m owner isKindOf: DropShadowMorph)		ifTrue: [^ self grabMorphFromMenu: m owner inWorld: aWorld].	m aboutToBeGrabbedBy: self.	self grabMorphInner: m inWorld: aWorld.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 20:02'!grabMorphInner: aMorph inWorld: aWorld	"The real work of grabbing a morph.  Set up a command object to represent the forthcoming move (in support of Undo), then actually wrench the morph out of its old home and add it as one of MY submorphs."	| myPos morphPos localPt trans morphToGrab newT w |	self flag: #arNote. "Fix this stuff"	"Check if the morph will keep its transform while grabbed"	myPos _ self position.	morphPos _ aMorph position.	w _ aMorph world ifNil: [aWorld ifNil:[self world]]. 	aMorph keepsTransform ifTrue: [		localPt _ myPos	] ifFalse: [		"fix grabbing new morph in embedded world"		localPt _ (w globalPointToLocal: myPos) truncated.	].		(aMorph formerOwner == nil		or: [aMorph keepsTransform			or: [(trans _ aMorph formerOwner transformFromOutermostWorld) isPureTranslation]]) ifTrue: [		aMorph formerOwner ifNotNil: [			localPt _ (aMorph formerOwner transformFrom: w) globalPointToLocal: localPt.		].		aMorph position: myPos + (morphPos - localPt).		morphToGrab _ aMorph.	] ifFalse: ["Morph was in a flexed environment.  Flex it in the hand."		morphToGrab _ aMorph addFlexShell transform: trans asMorphicTransform.		aMorph position: morphPos.  "revert offset from addFlexShell"		newT _ trans withOffset: (trans offset + (trans localPointToGlobal: localPt) - myPos).		morphToGrab position: (morphToGrab localPointToGlobal: morphToGrab position).		morphToGrab transform: newT.	].	(morphToGrab isKindOf: PhraseTileMorph) ifTrue:		[morphToGrab position: Sensor cursorPoint].	self addMorphBack: morphToGrab! !!HandMorph methodsFor: 'paste buffer' stamp: 'ar 10/5/2000 19:50'!copyToPasteBuffer: aMorph	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	aMorph ifNil:[^PasteBuffer _ nil].	Cursor wait showWhile:[		PasteBuffer _ aMorph topRendererOrSelf veryDeepCopy.		PasteBuffer aboutToBeGrabbedBy: self].! !!HandMorph methodsFor: 'paste buffer' stamp: 'ar 10/5/2000 19:10'!objectToPaste	"It may need to be sent #startRunning by the client"	^ Cursor wait showWhile: [PasteBuffer veryDeepCopy]	"PasteBuffer usableDuplicateIn: self world"! !!HandMorph methodsFor: 'paste buffer' stamp: 'ar 10/5/2000 19:10'!pasteBuffer	"Return the paste buffer associated with this hand"	^ PasteBuffer! !!HandMorph methodsFor: 'paste buffer' stamp: 'ar 10/5/2000 19:11'!pasteBuffer: aMorphOrNil	"Set the contents of the paste buffer."	PasteBuffer _ aMorphOrNil.! !!HandMorph methodsFor: 'paste buffer' stamp: 'ar 10/5/2000 19:11'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee align: aPastee center with: self position.	aPastee player ifNotNil: [aPastee player startRunning]! !!HandMorph methodsFor: 'remote morphic' stamp: 'ar 10/5/2000 20:17'!lastEventTransmitted	^self valueOfProperty: #lastEventTransmitted! !!HandMorph methodsFor: 'remote morphic' stamp: 'ar 10/5/2000 20:16'!lastEventTransmitted: anEvent	^self setProperty: #lastEventTransmitted toValue: anEvent! !!HandMorph methodsFor: 'remote morphic' stamp: 'ar 10/5/2000 20:16'!lastWorldExtent	^self valueOfProperty: #lastWorldExtent! !!HandMorph methodsFor: 'remote morphic' stamp: 'ar 10/5/2000 20:16'!lastWorldExtent: extent	^self setProperty: #lastWorldExtent toValue: extent! !!HandMorph methodsFor: 'remote morphic' stamp: 'ar 10/5/2000 20:17'!transmitEvent: aMorphicEvent	"Transmit the given event to all remote connections."	| sock status firstEvt |	self lastEventTransmitted = aMorphicEvent ifTrue: [^ self].	transmitBuffer ifNil: [		transmitBuffer _ WriteStream on: (String new: 10000)].	transmitBuffer nextPutAll: aMorphicEvent storeString; cr.	self lastEventTransmitted: aMorphicEvent.	self readyToTransmit ifFalse: [^ self].	self cleanupDeadConnections.	remoteConnections do: [:triple |		sock _ triple first.		status _ triple at: 2.		sock isConnected			ifTrue: [				status = #opening ifTrue: [					"connection established; disable TCP delays on sends"					sock setOption: 'TCP_NODELAY' value: true.					"send worldExtent as first event"					firstEvt _ MorphicEvent newWorldExtent: self worldBounds extent.					sock sendData: firstEvt storeString, (String with: Character cr).					Transcript						show: 'Connection established with remote WorldMorph at ';						show: (NetNameResolver stringFromAddress: sock remoteAddress); cr.					triple at: 2 put: #connected].				sock sendData: transmitBuffer contents]			ifFalse: [				status = #connected ifTrue: [					"other end has closed; close our end"					Transcript						show: 'Closing connection with remote WorldMorph at ';						show: (NetNameResolver stringFromAddress: sock remoteAddress); cr.					sock close.					triple at: 2 put: #closing]]].	transmitBuffer reset.! !!HandMorph methodsFor: 'private' stamp: 'ar 10/5/2000 19:48'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	(refStrm project world hands includes: self) ifTrue: [		^ self].	"owned by the project"	dp _ DiskProxy global: #World selector: #primaryHand args: #().	refStrm replace: self with: dp.	^ dp	"Note, when this file is loaded in an MVC project, this will return nil.  The MenuItemMorph that has this in a field will have that item not work.  Maybe warn the user at load time?"! !!HandMorph methodsFor: 'private' stamp: 'ar 10/5/2000 20:13'!releaseCachedState	| oo |	super releaseCachedState.	cacheCanvas _ nil.	oo _ owner.	self removeAllMorphs.	self initialize.	"nuke everything"	self privateOwner: oo.	self releaseAllFoci.! !!FakeHandMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 16:10'!handleMouseMove: evt	"Dispatch a mouseMove event."self flag: #arNote. "This entire class is obsolete and broken"	"mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)]."! !!MenuItemMorph methodsFor: 'grabbing' stamp: 'ar 10/5/2000 19:58'!aboutToBeGrabbedBy: aHand	"Don't allow the receiver to act outside a Menu"	| menu box |	owner submorphs size = 1 ifTrue:[		"I am a lonely menuitem already; just grab my owner"		owner stayUp: true.		^owner 	aboutToBeGrabbedBy: aHand].	box _ self bounds.	menu _ MenuMorph new defaultTarget: owner defaultTarget.	menu addMorphFront: self.	menu bounds: box.	menu stayUp: true.	^menu! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/5/2000 19:59'!aboutToBeGrabbedBy: aHand	popUpOwner ifNotNil:["Detach submenu from popUpOwner and delete its menu"		popUpOwner delete.		popUpOwner _ nil].	(owner notNil and:[owner isModalShell]) ifTrue:[owner delete].	super aboutToBeGrabbedBy: aHand.	^self! !!MenuMorph methodsFor: 'control' stamp: 'ar 10/5/2000 19:31'!popUpInWorld: aWorld	"Present this menu under control of the given hand."	^self popUpAt: aWorld primaryHand position forHand: aWorld primaryHand in: aWorld! !!MenuMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:45'!setTarget: evt	"Set the default target object to be used for add item commands, and re-target all existing items to the new target or the the invoking hand."	| rootMorphs old |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [defaultTarget _ rootMorphs at: 2]		ifFalse: [^ self].	"re-target all existing items"	self items do: [:item |		old _ item target.		old isHandMorph			ifTrue: [item target: evt hand]			ifFalse: [item target: defaultTarget]].! !!MenuMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:16'!undoGrabCommand	^nil! !!MorphicModel methodsFor: 'testing' stamp: 'ar 10/5/2000 16:40'!isMorphicModel	^true! !!ComponentLikeModel methodsFor: 'components' stamp: 'ar 10/5/2000 17:25'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	super addAddHandMenuItemsForHalo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu add: 'inspect' target: self action: #inspectInMorphic.	aMenu add: 'delete' target: self action: #dismissMorph:.! !!ComponentLikeModel methodsFor: 'components' stamp: 'ar 10/5/2000 20:03'!justDroppedInto: aMorph event: anEvent	| theModel |	theModel _ aMorph modelOrNil.	((aMorph isKindOf: ComponentLayout) 		and: [theModel isKindOf: Component]) ifFalse:		["Disconnect prior to removal by move"		(theModel isKindOf: Component) ifTrue: [self unwire.  model _ nil].		^ super justDroppedInto: aMorph event: anEvent].	theModel == model ifTrue: [^ self  "Presumably just a move"].	self initComponentIn: aMorph.	super justDroppedInto: aMorph event: anEvent! !!AlansTextPlusMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:39'!mouseUp: evt inMorph: aMorph	evt hand grabMorph: aMorph in: self world	"old instances may have a handler we no longer use"! !!MouseEvent methodsFor: 'testing' stamp: 'ar 10/5/2000 19:43'!isDraggingEvent	source ifNil:[^false].	source hasSubmorphs ifTrue:[^true].	self anyButtonPressed ifTrue:[^true].	^false! !!MouseOverHandler methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:01'!processMouseOver: anEvent	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus |	hand _ anEvent hand.	leftMorphs _ mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs _ WriteStream on: (Array new: leftMorphs size).	enteredMorphs _ WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs size = 0 and:[enteredMorphs position = 0]) 		ifTrue:[^leftMorphs _ enteredMorphs _ overMorphs _ nil].	focus _ hand mouseFocus.	"Send #mouseLeave as appropriate"	leftMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[localEvt _ anEvent transformedBy: (m transformedFrom: hand).					m handleMouseLeave: localEvt]			ifFalse:[overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	enteredMorphs _ enteredMorphs contents.	enteredMorphs do:[:m|		(m hasOwner: focus) 			ifTrue:[	localEvt _ anEvent transformedBy: (m transformedFrom: hand).					m handleMouseEnter: localEvt]].	"And remember the over list"	mouseOverMorphs _ overMorphs contents.	leftMorphs _ enteredMorphs _ overMorphs _ nil.! !!NewHandleMorph methodsFor: 'all' stamp: 'ar 10/5/2000 18:16'!undoGrabCommand	^nil! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:01'!endColorSelection: evt	"Update current color and report it to paint box."	self selectColor: evt.	"restore mouseLeave handling"	self on: #mouseLeave send: #delete to: self.! !!PaintInvokingMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:17'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor ifFalse: [^ self].	(aPasteUpMorph isPlayfieldLike not or:		[aPasteUpMorph isPartsBin]) ifTrue: [self beep.  self delete.  ^ self].	self delete.	aPasteUpMorph makeNewDrawing: anEvent.! !!PasteUpMorph methodsFor: 'display' stamp: 'ar 10/5/2000 18:52'!setGradientColor: evt	"For backwards compatibility with GradientFillMorph"	self flag: #fixThis.	self changeColorTarget: self selector: #gradientFillColor:		originalColor: (self fillStyle isGradientFill			ifTrue: [self fillStyle colorRamp last value]			ifFalse: [color])		hand: evt hand.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:21'!morphToDropFrom: aMorph        | ownersChoice aNail representee handy posBlock tempPos |        handy _ self primaryHand.        posBlock _ [ :z |                tempPos _ handy position - (                        (handy targetOffset - aMorph formerPosition) * (z extent / aMorph extent)                ) rounded.                self pointFromWorld: tempPos        ].        owner ifNotNil: [                ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self.                ownersChoice ifNotNil: [^ ownersChoice]        ].        self alwaysShowThumbnail ifTrue: [                aNail _ aMorph                         representativeNoTallerThan: self maxHeightToAvoidThumbnailing                         norWiderThan: self maximumThumbnailWidth                         thumbnailHeight: self heightForThumbnails.                aNail == aMorph ifFalse: [                        aNail position: (posBlock value: aNail)                ].                ^ aNail        ].        ((aMorph isKindOf: MorphThumbnail) and:                                 [(representee _ aMorph morphRepresented) owner == nil]) ifTrue: [                representee position: (posBlock value: representee).                ^ representee        ].        self expandPhrasesToScripts ifFalse: [^ aMorph].        (aMorph hasProperty: #newPermanentScript) ifTrue: [                ^ self emptyPermanentScriptorFrom: aMorph        ].        (aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].        ^aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'ar 10/5/2000 17:04'!buildDebugMenu: aHandMorph	| aMenu |	aMenu _ super buildDebugMenu: aHandMorph.	aMenu add:  'abandon costume history' target: self action: #abandonCostumeHistory.	^ aMenu! !!PasteUpMorph methodsFor: 'painting' stamp: 'ar 10/5/2000 19:18'!makeNewDrawingWithin	| evt |	evt _ MouseEvent new setType: nil position: self center buttons: 0 hand: self world activeHand.	self primaryHand makeNewDrawing: evt! !!PasteUpMorph methodsFor: 'painting' stamp: 'ar 10/5/2000 19:11'!paintBackground	| pic rect |	self world abandonAllHalos.	self world stopRunningAll.	pic _ self backgroundSketch.	pic ifNotNil: [pic editDrawingIn: self forBackground: true]		"need to resubmit it? (tck comment)"		ifNil: [rect _ self bounds.			pic _ self world drawingClass new form: 				(Form extent: rect extent depth: Display depth).			pic bounds: rect.			"self world addMorphBack: pic.  done below"			pic _ self backgroundSketch: pic.	"returns a different guy"			pic ifNotNil: [pic editDrawingIn: self forBackground: true]]! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 10/5/2000 16:23'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(worldState hands includes: aHandMorph) ifFalse: [^self].	aHandMorph dropMorphs.	self invalidRect: aHandMorph fullBounds.	worldState removeHand: aHandMorph.! !!PasteUpMorph methodsFor: 'interaction loop' stamp: 'ar 10/5/2000 18:29'!keyStroke: anEvent	"A keystroke has been made.  Service event handlers and, if it's a keystroke presented to the world, dispatch it to #unfocusedKeystroke:"	super keyStroke: anEvent.  "Give event handlers a chance"	self isWorldMorph ifTrue:		[self keystrokeInWorld: anEvent]! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 18:30'!handlesKeyboard: evt	^self isWorldMorph! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 19:41'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph |	evt isMorphicEvent ifTrue:["e.g., new regime"		grabbedMorph _ self morphToGrab: evt.		grabbedMorph ifNotNil:[			evt hand grabMorph: grabbedMorph in: self.			^evt hand releaseMouseFocus: self].		(super handlesMouseDown: evt)			ifTrue:[^super mouseDown: evt].	].	self isWorldMorph		ifTrue:			[evt isMorphicEvent ifFalse:[evt hand newKeyboardFocus: self]. self flag: #arNote. "Why???"			evt hand testEvent: evt				ifQuickClick: [self abandonAllHalos.							^ self quickClickOnDesktop: evt]				ifMoved: [evt shiftPressed							ifTrue: [^ self dragThroughOnDesktop: evt]							ifFalse: [^ super mouseDown: evt]].			self abandonAllHalos.			self invokeWorldMenu: evt]		ifFalse:			[evt hand testEvent: evt				ifQuickClick: [^ super mouseDown: evt]				ifMoved: [evt shiftPressed							ifTrue: [^ self dragThroughOnDesktop: evt]							ifFalse: [^ super mouseDown: evt]].			^ super mouseDown: evt]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 18:34'!addUndoItemsTo: aWorldMenu	"Add undo-related items to the given menu.  Will add zero, one or two items, depending on the settings of the #useUndo and #infiniteUndo preferences"	Preferences useUndo ifFalse: [^ self].	Preferences infiniteUndo		ifFalse:			[aWorldMenu addUpdating: #undoOrRedoMenuWording target: self commandHistory action: #undoOrRedoCommand]		ifTrue:			[aWorldMenu addUpdating: #undoMenuWording target: self commandHistory  action: #undoLastCommand.			aWorldMenu addUpdating: #redoMenuWording target: self commandHistory action: #redoNextCommand.			self flag: #deferred.  "The following feature to be unblocked in due course"			"aWorldMenu add: 'undo to...' target: self commandHistory action: #undoTo"].	aWorldMenu addLine! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 18:27'!buildWorldMenu: evt	^(TheWorldMenu new		world: self		project: (self project ifNil: [Project current])       "mvc??"		hand: evt hand) buildWorldMenu.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:26'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:27'!collapseAll	"Collapse all windows"	(SystemWindow windowsIn: self satisfying: [:w | w isCollapsed not])		reverseDo: [:w | w collapseOrExpand.  self displayWorld].	self collapseNonWindows! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:27'!collapseNonWindows	self allNonFlapRelatedSubmorphs do:		[:m | m collapse]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:28'!deleteNonWindows	(SelectionMenu confirm:'Do you really want to discard all objectsthat are not in windows?')		ifFalse: [^ self].	self allNonFlapRelatedSubmorphs do:		[:m | m delete]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:29'!detachableScriptingSpace	ScriptingSystem newScriptingSpace openInWorld: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 19:11'!drawingClass	^ SketchMorph! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:33'!expandAll	"Expand all windows"	(SystemWindow windowsIn: self satisfying: [:w | w isCollapsed])		reverseDo: [:w | w collapseOrExpand.  self displayWorld]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:34'!findDirtyBrowsers: evt	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[menu popUpEvent: evt in: self]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:35'!findDirtyWindows: evt	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[menu popUpEvent: evt in: self]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:36'!findWindow: evt	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."	| menu expanded collapsed nakedMorphs |	menu _ MenuMorph new.	expanded _ SystemWindow windowsIn: self satisfying: [:w | w isCollapsed not].	collapsed _ SystemWindow windowsIn: self satisfying: [:w | w isCollapsed].	nakedMorphs _ self submorphsSatisfying:		[:m | ((m isKindOf: SystemWindow) not and: [(m isKindOf: StickySketchMorph) not]) and:			[(m isFlapTab) not]].	(expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty)) ifTrue: [^ self beep].	(expanded asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do:		[:w | menu add: w label target: w action: #activateAndForceLabelToShow.			w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	(expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty)) ifFalse: [menu addLine].	(collapsed asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do: 		[:w | menu add: w label target: w action: #collapseOrExpand.		w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asSortedCollection: [:w1 :w2 | w1 nameForFindWindowFeature caseInsensitiveLessOrEqual: w2 nameForFindWindowFeature]) do:		[:w | menu add: w nameForFindWindowFeature target: w action: #comeToFrontAndAddHalo].	menu addTitle: 'find window'.		menu popUpEvent: evt in: self.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 19:09'!getWorldMenu: aSymbol	^(TheWorldMenu new		world: self		project: (self project ifNil: [Project current])       "mvc??"		hand: self primaryHand) perform: aSymbol! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 19:12'!grabDrawingFromScreen: evt	"Allow the user to specify a rectangular area of the Display, capture the pixels from that area, and use them to create a new drawing morph. Attach the result to the hand."	| m |	m _ self drawingClass new form: Form fromUser.	evt hand attachMorph: m.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 18:28'!invokeWorldMenu: evt	| menu |	Utilities bringFlapsToFront.	evt yellowButtonPressed		ifTrue: [^ self yellowButtonClickOnDesktopWithEvent: evt].	evt shiftPressed ifTrue:[^self findWindow: evt].	"put put screen menu"	menu _ self buildWorldMenu: evt.	menu addTitle: Preferences desktopMenuTitle.	menu popUpEvent: evt in: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 18:28'!keystrokeInWorld: evt	|  aChar isCmd aMenu |	aChar _ evt keyCharacter.	(aChar == Character tab) ifTrue:		[(self hasProperty: #tabAmongFields)			ifTrue:[^ self tabHitWithEvent: evt]].	isCmd _ evt commandKeyPressed and: [Preferences cmdKeysInText].	(isCmd and: [Preferences eToyFriendly]) ifTrue:		[(aChar == $W) ifTrue:			["put put screen menu -- Explicit request from Kim Rose"			aMenu _ self buildWorldMenu: evt.			aMenu addTitle: Preferences desktopMenuTitle.			^ aMenu popUpEvent: evt in: self]].  	isCmd ifTrue:		[(aChar == $b) ifTrue: [^ Browser openBrowser].          "for example"		(aChar == $z) ifTrue: [^ self commandHistory undoOrRedoCommand]]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 19:16'!makeNewDrawing: evt	| w newSketch newPlayer sketchEditor aPaintBox aPalette tfx whereToPresent rect |	w _ self world.	w assureNotPaintingElse: [^ self].	rect _ self paintingBoundsAround: evt position.	aPalette _ self standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: self.	sketchEditor		afterNewPicDo: [:aForm :aRect |			whereToPresent _ self presenter.			newSketch form: aForm.			tfx _ self transformFrom: w.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			newSketch privateOwner: self. "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			self addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ w paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 17:40'!newDrawingFromMenu: evt	self assureNotPaintingElse: [^ self].	evt hand attachMorph: PaintInvokingMorph new markAsPartsDonor! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 19:00'!openScrapsBook: evt	evt hand attachMorph: Utilities scrapsBook! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 18:31'!putUpDesktopMenu: evt	"Put up the desktop menu"	^ ((self buildWorldMenu: evt) addTitle: Preferences desktopMenuTitle) popUpAt: evt position forHand: evt hand in: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/5/2000 18:28'!yellowButtonClickOnDesktopWithEvent: evt	"Put up either the personalized menu or the world menu when the user clicks on the morphic desktop with the yellow button.  The preference 'personalizedWorldMenu' governs which one is used"	| aMenu |	Preferences personalizedWorldMenu ifFalse:[		aMenu _ self buildWorldMenu: evt.		aMenu addTitle: 'World'.	] ifTrue:[		aMenu _ MenuMorph new defaultTarget: self.		Preferences personalizeUserMenu: aMenu.		aMenu addLine.		aMenu add: 'personalize...' target: Preferences action: #letUserPersonalizeMenu].	aMenu popUpEvent: evt in: self! !!Player methodsFor: 'pen' stamp: 'ar 10/5/2000 18:53'!choosePenColor: evt	self costume changeColorTarget:  self costume  selector: #penColor: originalColor: self getPenColor hand: evt hand! !!Player methodsFor: 'misc' stamp: 'ar 10/5/2000 19:28'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld aViewer |	aWorld _ aMorph world.	aViewer _ aMorph ownerThatIsA: Viewer.	aMenu _ MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes]].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	aMenu add: 'add a new script' target: aViewer action: #newPermanentScript.	aMenu add: 'expunge empty scripts' target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpEvent: aWorld primaryHand lastEvent in: aWorld.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect]! !!Component methodsFor: 'drag and drop' stamp: 'ar 10/5/2000 20:03'!justDroppedInto: aMorph event: anEvent	| theModel |	theModel _ aMorph model.	((aMorph isKindOf: ComponentLayout) 		and: [theModel isKindOf: Component]) ifFalse:		["Disconnect prior to removal by move"		(theModel isKindOf: Component) ifTrue: [self unwire.  model _ nil].		^ super justDroppedInto: aMorph event: anEvent].	theModel == model ifTrue: [^ self  "Presumably just a move"].	self initComponentIn: aMorph.	super justDroppedInto: aMorph event: anEvent.! !!Component methodsFor: 'misc' stamp: 'ar 10/5/2000 17:30'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	super addAddHandMenuItemsForHalo: aMenu hand: aHandMorph.	aMenu add: 'delete' target: self action: #dismissMorph:! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:01'!aboutToBeGrabbedBy: aHand	"I'm about to be grabbed by the hand.  If other cards are above me in a deck,	then move them from the deck to being submorphs of me"	| i |	super aboutToBeGrabbedBy: aHand.	i _ owner submorphs indexOf: self ifAbsent: [^ self].	i = 1 ifTrue: [^ self].	(owner submorphs copyFrom: 1 to: i-1) do:		[:m | m class = self class ifTrue: [self addMorphBack: m]].! !!PlayingCardMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: newOwner event: evt	(newOwner isKindOf: PlayingCardDeck)		ifFalse: ["Can't drop a card anywhere but on a deck"				self rejectDropMorphEvent: evt].	^super justDroppedInto: newOwner event: evt! !!Project methodsFor: 'file in/out' stamp: 'ar 10/5/2000 18:57'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."| is str ans revertSeg roots holder |"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World currentHand pasteBuffer: nil.	"don't ask"	"Display checkCurrentHandForObjectToPaste."Command initialize.world clearCommandHistory.world fullReleaseCachedState. world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).catList do: [:sysCat | 	(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |		roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].false ifTrue: [		is _ ImageSegment new copyFromRootsForExport: roots asArray]	"world, and all Players"	ifFalse: [is _ ImageSegment new copySmartRootsExport: roots asArray].is state = #tooBig ifTrue: [^ false].str _ ''.is segment size < 3000 ifTrue: [	str _ 'Segment is only ', is segment size printString, ' long.']."(is outPointers detect: [:out | out isMorph] ifNone: [nil]) ifNotNil: [	str _ str, '\Morphs are pointed at from the outside.' withCRs]."(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug') startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].		^ false].	ans = 3 ifTrue: [self halt: 'Segment not written']].is writeForExportWithSources: aFileName inDirectory: aDirectory.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.^ true! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: aMorph event: anEvent	self setProperty: #stickToTop toValue: nil.	self positionVertically.	LastManualPlacement _ {self position. self valueOfProperty: #stickToTop}.	^super justDroppedInto: aMorph event: anEvent! !!ProjectViewMorph methodsFor: 'events' stamp: 'ar 10/5/2000 19:26'!acceptDroppingMorph: morphToDrop event: evt	| myCopy smallR |	(project isNil or: [project isInMemory not or: [project class == DiskProxy]]) ifTrue: [		^morphToDrop rejectDropMorphEvent: evt.		"can't handle it right now"	].	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [	"don't send these"		^morphToDrop rejectDropMorphEvent: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we will send a copy"	myCopy _ morphToDrop veryDeepCopy.	"gradient fills require doing this second"	smallR _ (morphToDrop bounds scaleBy: image height / Display height) rounded.	smallR _ smallR squishedWithin: image boundingBox.	image getCanvas		paintImage: (morphToDrop imageForm scaledToSize: smallR extent)		at: smallR topLeft.	myCopy openInWorld: project world! !!RemoteHandMorph methodsFor: 'other' stamp: 'ar 10/5/2000 16:13'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent]! !!Scamper methodsFor: 'menus' stamp: 'ar 10/5/2000 19:32'!bookmark	| menu sub url |	menu _ (MenuMorph entitled: ' Bookmark ')				defaultTarget: self.	menu addStayUpItem.	menu addLine.	menu		add: 'add to bookmark'		target: self		selector: #addToBookmark.	menu add: 'Import...' target: self selector: #importBookmark. 	menu addLine.	bookmark		keysAndValuesDo: 			[:name :value | 			url _ value.			(url isKindOf: Dictionary)				ifTrue: 					[sub _ self addNewSubMenu: url.					menu add: name subMenu: sub]				ifFalse: [menu						add: name						selector: #jumpToUrl:						argument: url]].	menu popUpInWorld: self currentWorld! !!Scamper methodsFor: 'menus' stamp: 'ar 10/5/2000 19:32'!displayHistory	"Let the user selecet a previous page to view."	| menu |	menu _ MenuMorph entitled: 'Recent URLs'.	menu defaultTarget: self.	menu addStayUpItem.	menu addLine.	recentDocuments reverseDo:		[:doc |		menu add: doc url toText selector: #displayDocument: argument: doc].	menu popUpInWorld: self currentWorld! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/5/2000 20:10'!mouseMove: evt	self flag: #arNote. "Fix 'significant' events below"	actWhen == #buttonDown ifTrue: [^ self].	self updateVisualState: evt.	(actWhen == #whilePressed and: [			evt anyButtonPressed and: [self containsPoint: evt cursorPoint]])		ifTrue: [self doButtonAction.				"evt hand noteSignificantEvent: evt"]! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'ar 10/5/2000 16:07'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| poly cColor |	super mouseEnter: evt.	self flag: #arNote. "What is that code below doing???"	(self get: #action for: evt) == #scaleOrRotate ifTrue: [		self set: #action for: evt to: (self get: #priorAction for: evt).	].	evt hand showTemporaryCursor: (self getCursorFor: evt).	palette getSpecial == #polygon: ifFalse: [^self].	(poly _ self valueOfProperty: #polygon) ifNil: [^ self].	cColor _ self getColorFor: evt.	poly color: cColor; borderWidth: 1.	poly changed.! !!SketchMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:53'!erasePixelsOfColor: evt	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	| c r |	self changeColorTarget: self selector: #rememberedColor: originalColor: nil hand: evt hand.   "color to erase"	c _ self rememberedColor ifNil: [Color red].	originalForm mapColor: c to: Color transparent.	r _ originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: r).! !!SketchMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:53'!recolorPixelsOfColor: evt	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| c d newForm map newC |	self inform: 'choose the color you want to replace'.	self changeColorTarget: self selector: #rememberedColor: originalColor: nil hand: evt hand.   "color to replace"	c _ self rememberedColor ifNil: [Color red].	self inform: 'now choose the color you want to replace it with'.	self changeColorTarget: self selector:  #rememberedColor: originalColor: c hand: evt hand.  "new color"	newC _ self rememberedColor ifNil: [Color blue].	d _ originalForm depth.	newForm _ Form extent: originalForm extent depth: d.	map _ (Color cachedColormapFrom: d to: d) copy.	map at: (c indexInMap: map) put: (newC pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:39'!makeFlexMorphFor: aHand	aHand grabMorph: (FlexMorph new originalMorph: page) in: self world! !!FatBitsPaint methodsFor: 'menu' stamp: 'ar 10/5/2000 18:51'!setBackgroundColor: evt	self		changeColorTarget: self 		selector: #backgroundColor: 		originalColor: backgroundColor		hand: evt hand! !!FatBitsPaint methodsFor: 'menu' stamp: 'ar 10/5/2000 18:51'!setPenColor: evt	self changeColorTarget: self selector: #brushColor: originalColor: brushColor hand: evt hand.! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 18:52'!changeBorderColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #borderColor: originalColor: self borderColor hand: aHand.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'ar 10/5/2000 18:52'!setPenColor: evt	| state |	(drawState includesKey: evt hand) ifFalse: [self createDrawStateFor: evt hand].	state _ drawState at: evt hand.	self changeColorTarget: self selector: #brushColor:hand: originalColor: (state at: PenColorIndex) hand: evt hand! !!SoundMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: aMorph event: anEvent	| relPosition |	relPosition _ self position - aMorph innerBounds topLeft.	relPosition _ (relPosition x roundTo: 8) @ relPosition y.	self position: aMorph innerBounds topLeft + relPosition.	sound copy play.	^super justDroppedInto: aMorph event: anEvent! !!SystemWindow methodsFor: 'geometry' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [self position: ((self position max: 0@0) grid: 8@8).				collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds.				TopWindow ~~ self ifTrue: [self activate]].	^super justDroppedInto: aMorph event: anEvent! !!SystemWindow methodsFor: 'open/close' stamp: 'ar 10/5/2000 17:26'!closeBoxHit	"The user clicked on the close-box control in the window title.  For Mac users only, the Mac convention of option-click-on-close-box is obeyed if the mac option key is down."	Preferences dismissAllOnOptionClose ifTrue:		[Sensor rawMacOptionKeyPressed ifTrue:			[^ self world closeUnchangedWindows]].	self delete! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 18:54'!changeBackgroundColor	"Let the user select a new background color for the world"	myWorld changeColorTarget: myWorld selector: #color: originalColor: myWorld color hand: myWorld activeHand.! !!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 19:11'!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName _ Utilities chooseFileWithSuffixFromList:(#('.morph'), Utilities graphicsFileSuffixes) withCaption: 'Choose a fileto load'.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)'].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff _ FileStream oldFileNamed: aName.			morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			myWorld addMorphsAndModel: morphOrList]		ifFalse:			[f _ Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format'].			m _ myWorld drawingClass new form: f.			myHand attachMorph: m]! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 18:34'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu _ MenuMorph new defaultTarget: self.	self colorForDebugging: menu.	menu addStayUpItem.	self fillIn: menu from: {		{'previous project' . { #myWorld . #goBack } }.		{'jump to project...' . { #myWorld . #jumpToProject } }.		{'save project on file...' . { #myWorld  . #saveOnFile } }.		{'load project from file...' . { self  . #loadProject } }.		nil}.	myWorld addUndoItemsTo: menu.		self fillIn: menu from: {		{'restore display' . { Display . #restoreMorphicDisplay } }.		nil}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: { 			{'open...' . { self  . #openWindow } }.			{'windows & flaps...' . { self  . #windowsDo } }.			{'changes...' . { self  . #changesDo } }}].	self fillIn: menu from: { 		{'help...' . { self  . #helpDo } }.		{'appearance...' . { self  . #appearanceDo } }}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: {			{'do...' . { Utilities . #offerCommonRequests} } }].	self fillIn: menu from: { 		nil.		{'new morph...' . { self  . #newMorph } }.		{'authoring tools...' . { self  . #scriptingDo } }.		{'playfield options...' . { self  . #playfieldDo } }.		{'projects...' . { self  . #projectDo } }}.	Preferences simpleMenus ifFalse:		[self fillIn: menu from: { 			{'print PS to file...' . { self  . #printWorldOnFile } }.			{'debug...' . { self  . #debugDo } }}].	self fillIn: menu from: { 		nil.		{'save' . { self  . #saveSession } }.		{'save as...' . { Smalltalk . #saveAs } }.		{'save and quit' . { self  . #saveAndQuit } }.		{'quit' . { self  . #quitSession } }}.	^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 17:28'!debugMenu        | menu |        menu _ self menu: 'debug...'.        ^self fillIn: menu from: {                 { 'inspect world' . { #myWorld . #inspect } }.                { 'explore world' . { #myWorld . #explore } }.                { 'inspect model' . { self . #inspectWorldModel } }.                        " { 'talk to world...' . { self . #typeInMessageToWorld } }."                { 'start MessageTally' . { self . #startMessageTally } }.                { 'start/browse MessageTally' . { self . #startThenBrowseMessageTally } }.                nil.                        "(self hasProperty: #errorOnDraw) ifTrue:  Later make this come up only when needed."                { 'start drawing again' . { #myWorld . #resumeAfterDrawError } }.                { 'start stepping again' . { #myWorld . #resumeAfterStepError } }.                nil.                { 'call #tempCommand' . { #myWorld . #callTempCommand } }.                { 'define #tempCommand' . { #myWorld . #defineTempCommand } }.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 19:05'!fillIn: aMenu from: dataForMenu	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:			nil							Indicates to add a line			first element is symbol		Add updating item with the symbol as the wording selector			second element is a list		second element has the receiver and selector			first element is a string		Add menu item with the string as its wording			second element is a list		second element has the receiver and selector			a third element exists		Use it as the balloon text"	dataForMenu do: [ :itemData |		itemData ifNil: [aMenu addLine] ifNotNil:			[(itemData first isKindOf: Symbol)				ifTrue: 					[aMenu 						addUpdating: itemData first 						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}]				 ifFalse:					[aMenu 						add: itemData first 						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}].			itemData size >= 3 ifTrue:				[aMenu balloonTextForLastItem: itemData third]]].	^ aMenu! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 17:44'!helpMenu        "Build the help menu for the world."        | screenCtrl |        screenCtrl _ ScreenController new.        ^self fillIn: (self menu: 'help...') from:        {                {'about this system...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.                {'update code from server'. {Utilities. #updateFromServer}. 'load latest code updates via the internet'}.                {'preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.                nil.                {'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}.                {'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.                        "{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.'}."                {'font size summary' . { Utilities . #fontSizeSummary}.  'summary of names and sizes of available fonts.'}.                {'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.                {'graphical imports' . { Smalltalk . #viewImageImports}.  'view the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList'}.                {'standard graphics library' . { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.'}.                nil.                {'telemorphic...' . {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments'}.                {#soundEnablingString . { Preferences . #toggleSoundEnabling}. 'turning sound off will completely disable Squeak''s use of sound.'}.                {'definition for...' . { Utilities . #lookUpDefinition}.  'if connected to the internet, use this to look up the definition of an English word.'}.                nil.                {'set author initials...' . { screenCtrl . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.                {'vm statistics' . { screenCtrl . #vmStatistics}.  'obtain some intriguing data about the vm.'}.                {'space left' . { screenCtrl . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 19:12'!newMorph	| menu subMenu catDict shortCat class |	menu _ self menu: 'Add a new morph'.	menu 		add: 'from paste buffer' target: myHand action: #pasteMorph;		add: 'from a file...' target: self action: #readMorphFromAFile;		add: 'from alphabetical list' subMenu: self alphabeticalMorphMenu;		add: 'grab patch from screen' target: myWorld action: #grabDrawingFromScreen:;		add: 'make new drawing' target: myWorld action: #newDrawingFromMenu:;		add: 'make link to project...' target: self action: #projectThumbnail;		addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	self doPopUp: menu.! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 19:21'!scriptingMenu        "Build the scripting menu for the world."        ^self fillIn: (self menu: 'authoring tools...') from: {                 { 'standard parts bin' . { self . #createStandardPartsBin}. 'A bin of standard parts, from which you can drag out useful morphs.'}.                { 'custom parts bin' . { self . #launchCustomPartsBin}. 'A customized bin of parts.  To define what the custom parts bin is, edit any existing parts bin and tell it to be saved as the custom parts bin.'}.                { 'view trash contents' . { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.'}.                { 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.                { 'new scripting area' . { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.                nil.                { 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.                { 'unhide hidden objects' . { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 10/5/2000 17:36'!windowsMenu        "Build the windows menu for the world."        ^ self fillIn: (self menu: 'windows & flaps...') from: {                  { 'find window' . { #myWorld . #findWindow: }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.                { 'find changed browsers...' . { #myWorld . #findDirtyBrowsers: }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                { 'find changed windows...' . { #myWorld . #findDirtyWindows: }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.			 nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.                nil.                { 'collapse all windows' . { #myWorld . #collapseAll }. 'Reduce all open windows to collapsed forms that only show titles.'}.                { 'expand all windows' . { #myWorld . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.                nil.                { 'delete unchanged windows' . { #myWorld . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.                { 'delete non-windows' . { #myWorld . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.                { 'delete both of the above' . { self .#cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.                nil.                { #suppressFlapsString . { self . #toggleFlapSuppressionInProject }. 'Governs whether flaps should be shown in this project'}.                { #useGlobalFlapsString . { self. #toggleWhetherToUseGlobalFlaps }. 'Governs whether a universal set of "global" flaps should be used in all morphic projects that currently are showing flaps.'}.                nil.                { 'new global flap...'  . { Utilities . #addGlobalFlap }. 'Create a new flap that will be shared by all morphic projects'}.                { 'new project flap...'  . { Utilities . #addLocalFlap }. 'Create a new flap to be used only in this project.'}.                { 'about flaps...' . { Utilities . #explainFlaps }. 'Gives a window full of details about how to use flaps.'}.        }! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 10/5/2000 19:04'!doMenuItem: aCollection with: event	| realTarget selector nArgs |	selector _ aCollection second.	nArgs _ selector numArgs.	^[		realTarget _ aCollection first.		realTarget == #myWorld ifTrue: [realTarget _ myWorld].		realTarget == #myHand ifTrue: [realTarget _ myHand].		realTarget == #myProject ifTrue: [realTarget _ self projectForMyWorld].		nArgs = 0 			ifTrue:[realTarget perform: selector]			ifFalse:[realTarget perform: selector with: event].	] on: RequestCurrentWorldNotification do: [ :ex | ex resume: myWorld ]! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 10/5/2000 20:10'!mouseMove: evt	| aPoint label |	"See if arrows are being pressed and call arrowAction:..."	self flag: #arNote. "Fix 'significant' events below"	upArrow ifNotNil:		[aPoint _ evt cursorPoint.		(label _ self labelMorph) ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: 1].			^ evt "hand noteSignificantEvent: evt"].		(downArrow containsPoint: aPoint) ifTrue:			[self abandonLabelFocus.			self variableDelay:				[self arrowAction: -1].			^ evt "hand noteSignificantEvent: evt"]].	super mouseMove: evt.! !!ColorTileMorph methodsFor: 'events' stamp: 'ar 10/5/2000 18:51'!mouseUp: evt	self changeColorTarget: colorSwatch selector: #userSelectedColor: originalColor: colorSwatch color hand: evt hand! !!MenuTile methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 17:20'!mouseDown: evt	| aPoint aMenu reply |	aPoint _ evt cursorPoint.	nArrowTicks _ 0.	upArrow ifNotNil:		[(upArrow boundsInWorld containsPoint: aPoint) ifTrue: [^ self].		(downArrow boundsInWorld containsPoint: aPoint) ifTrue: [^ self]].	aMenu _ SelectionMenu selections: ((self ownerThatIsA: PhraseTileMorph) associatedPlayer costume allMenuWordings).	reply _ aMenu startUp.	reply ifNotNil: [self literal: reply; layoutChanged]! !!NumericReadoutTile methodsFor: 'mouse' stamp: 'ar 10/5/2000 20:10'!mouseMove: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	| p label |	self flag: #arNote. "Fix 'significant' events below"	upArrow ifNotNil:		[p _ evt cursorPoint.		self abandonLabelFocus.		label _ self findA: UpdatingStringMorph.		label ifNotNil:			[label step. literal _ label valueFromContents].		(upArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue + 1)].					^ evt "hand noteSignificantEvent: evt"].		(downArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue - 1)].					^ evt "hand noteSignificantEvent: evt"]].	super mouseMove: evt.! !!TinyPaint methodsFor: 'menu' stamp: 'ar 10/5/2000 18:54'!setPenColor: evt	self changeColorTarget: self selector: #brushColor: originalColor: brushColor hand: evt hand.! !!TransferMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:01'!aboutToBeGrabbedBy: aHand 	"The receiver is being grabbed by a hand.                           	Perform necessary adjustments (if any) and return the actual morph    	     that should be added to the hand."	"Since this morph has been initialized automatically with bounds origin   	     0@0, we have to move it to aHand position."	super aboutToBeGrabbedBy: aHand.	self draggedMorph.	self align: self bottomLeft with: aHand position! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 19:00'!mouseDown: evt	| paintBox palette |	self currentHand visible: true.	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox _ self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp: evt.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"	palette _ self standardPalette.	((palette notNil and: [palette isInWorld]) and: [palette hasScrapsTab])		ifTrue:			[palette showScrapsTab]		ifFalse:			[self world openScrapsBook: evt]! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:19'!mouseEnter: event	"Present feedback for potential deletion."	| hand firstSub |	hand _ event hand.	(((hand submorphCount > 0) and: [(firstSub _ hand submorphs first) ~~ self]) and:			[firstSub willingToBeDiscarded])		ifTrue: 			[Preferences soundsEnabled ifTrue: [self class playMouseEnterSound].			hand visible: false.			self world abandonAllHalos.			self state: #pressed]		ifFalse:			[self showStampIn: hand]! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:18'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue:			[Preferences soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand visible: true.			self state: #off]		ifFalse:			[self stopShowingStampIn: hand].! !!TrashCanMorph methodsFor: 'dropping' stamp: 'ar 10/5/2000 16:18'!acceptDroppingMorph: aMorph event: evt	Preferences soundsEnabled ifTrue:		[Preferences preserveTrash 			ifFalse:				[self playSoundNamed: 'scratch']			ifTrue:				[self class playDeleteSound]].	evt hand visible: true.	self state: #off.	aMorph delete.	aMorph == Utilities scrapsBook ifFalse:		[Utilities addToTrash: aMorph]! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'ar 10/5/2000 18:54'!mouseUp: evt	self changeColorTarget: self selector: #setTargetColor: originalColor: color hand: evt hand.! !!Utilities class methodsFor: 'flaps' stamp: 'ar 10/5/2000 19:09'!menuFlap	| aFlap aFlapTab aHolder verticalHolder aMenu |	aFlap _ PasteUpMorph newSticky color: Color transparent; extent: self currentWorld width @ 264; borderWidth: 0; padding: 0.	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab color: Color brown lighter.	aFlapTab assumeString: 'Menus' font: Preferences standardFlapFont orientation: #horizontal color: Color blue muchLighter.	aFlapTab setToPopOutOnMouseOver: true.	aFlapTab edgeToAdhereTo: #top; inboard: false.	aFlapTab position: ((Display width - aFlapTab width) // 2) @ 0.	aFlap beFlap: true.	aFlap color: (Color blue muchLighter alpha: 0.6).	aFlap extent: self currentWorld width @ 267.	aHolder _ AlignmentMorph newRow beSticky beTransparent.	#(openMenu helpMenu windowsMenu (changesMenu debugMenu ) (playfieldMenu scriptingMenu )) do:		[:elem |			(elem isKindOf: Array)				ifTrue:					[verticalHolder _ AlignmentMorph newColumn beSticky beTransparent.					verticalHolder hResizing: #shrinkWrap; inset: 0; centering: #center.					elem do:						[:aMenuSymbol |							verticalHolder addMorphBack: ((aMenu _ self currentWorld getWorldMenu: aMenuSymbol) beSticky; stayUp: true).							aMenu beSticky.							aMenu borderWidth: 1.							aMenu submorphs second delete].					aHolder addMorphBack: verticalHolder]				ifFalse:					[aHolder addMorphBack: ((aMenu _ self currentWorld getWorldMenu: elem) beSticky; stayUp: true).					aMenu submorphs second delete.					aMenu beSticky.					aMenu borderWidth: 1]].	aFlap addMorphBack: aHolder.	^ aFlapTab! !!Utilities class methodsFor: 'flaps' stamp: 'ar 10/5/2000 19:09'!updateMenuFlap        | aFlap selectors newMenu newMenuTitle oldMenu |        aFlap _ (self currentMenuFlap ifNil: [^self]) referent.        selectors _ #(openMenu helpMenu windowsMenu changesMenu                 debugMenu playfieldMenu scriptingMenu ).        selectors do: [:menuSelector |                (newMenu _ self currentWorld getWorldMenu: menuSelector)                        beSticky;                        stayUp: true.                newMenu submorphs second delete.        "remove the stay up item"                newMenu borderWidth: 1.                (newMenuTitle _ newMenu titleGuesstimate) ifNotNil: [                        oldMenu _ aFlap                                 findDeepSubmorphThat: [ :each |                                        (each isKindOf: MenuMorph) and:                                                 [each titleGuesstimate = newMenuTitle]                                ]                                 ifAbsent: [nil].                        oldMenu ifNotNil: [                                oldMenu owner                                        replaceSubmorph: oldMenu                                         by: newMenu.                        ].                ].        ].        ^ aFlap! !!Utilities class methodsFor: 'text styles and fonts' stamp: 'ar 10/5/2000 19:32'!promptForFont: aPrompt andSendTo: aTarget withSelector: aSelector        "Utilities promptForFont: 'Choose system font:' andSendTo: Utilities withSelector: #setSystemFontTo:"        "NOTE: Morphic ONLY!!!!.  Derived from a method written by Robin Gibson"        | menu subMenu |        menu _ MenuMorph entitled: aPrompt.        Utilities actualTextStyles keys do: [:styleName|                subMenu _ self fontMenuForStyle: styleName target: aTarget selector: aSelector.                menu add: styleName subMenu: subMenu.                menu lastItem font: ((TextStyle named: styleName) fontOfSize: 18)].        menu popUpInWorld: self currentWorld! !!WireMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 17:30'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	super addAddHandMenuItemsForHalo: aMenu hand: aHandMorph.	aMenu add: 'delete' target: self action: #dismissMorph:! !TheWorldMenu removeSelector: #detachableScriptingSpace!TheWorldMenu removeSelector: #doMenuItem:!TheWorldMenu removeSelector: #gridOnString!PasteUpMorph removeSelector: #buildWorldMenu!PasteUpMorph removeSelector: #debuggingMenuFor:!MenuMorph removeSelector: #popUpEvent:!MenuMorph removeSelector: #popUpForHand:!MenuMorph removeSelector: #popUpNearHand!HandMorphForReplay removeSelector: #addHalo:!HandMorph removeSelector: #addHalo:!HandMorph removeSelector: #addMouseOverMorph:!HandMorph removeSelector: #addUndoItemsTo:!HandMorph removeSelector: #argument!HandMorph removeSelector: #argumentOrNil!HandMorph removeSelector: #beThisWorldsModel!HandMorph removeSelector: #browsePlayerClass!HandMorph removeSelector: #buildDebugHandleMenuFor:!HandMorph removeSelector: #buildMorphHandleMenuFor:!HandMorph removeSelector: #buildMorphMenuFor:!HandMorph removeSelector: #buildWorldMenu!HandMorph removeSelector: #callTempCommand!HandMorph removeSelector: #changeColor!HandMorph removeSelector: #changeColorTarget:selector:!HandMorph removeSelector: #changeColorTarget:selector:originalColor:!HandMorph removeSelector: #changeVariableType!HandMorph removeSelector: #checkForDoubleClick:!HandMorph removeSelector: #chooseColor!HandMorph removeSelector: #chooseHaloSubmorphOf:caption:!HandMorph removeSelector: #chooseNewCostumeForArgument!HandMorph removeSelector: #chooseTargetSubmorphOf:caption:!HandMorph removeSelector: #classOfPasteBuffer!HandMorph removeSelector: #clearPasteBuffer!HandMorph removeSelector: #closeUnchangedWindows!HandMorph removeSelector: #collapseAll!HandMorph removeSelector: #collapseNonWindows!HandMorph removeSelector: #copyToPasteBuffer!HandMorph removeSelector: #defineTempCommand!HandMorph removeSelector: #deleteNonWindows!HandMorph removeSelector: #detachableScriptingSpace!HandMorph removeSelector: #dismissMorph!HandMorph removeSelector: #dragOverList:!HandMorph removeSelector: #dragOverListAt:!HandMorph removeSelector: #drawingClass!HandMorph removeSelector: #dropMorphsEvent:!HandMorph removeSelector: #dropTargetFor:event:!HandMorph removeSelector: #duplicateMorph!HandMorph removeSelector: #endDisplaySuppression!HandMorph removeSelector: #eventTransform!HandMorph removeSelector: #eventTransform:!HandMorph removeSelector: #expandAll!HandMorph removeSelector: #exploreArgument!HandMorph removeSelector: #findDirtyBrowsers!HandMorph removeSelector: #findDirtyWindows!HandMorph removeSelector: #findWindow!HandMorph removeSelector: #formerOwner!HandMorph removeSelector: #formerPosition!HandMorph removeSelector: #getWorldMenu:!HandMorph removeSelector: #goBehind!HandMorph removeSelector: #grabDrawingFromScreen!HandMorph removeSelector: #grabMorph!HandMorph removeSelector: #grabMorphFromMenu:!HandMorph removeSelector: #grabMorphInner:!HandMorph removeSelector: #gridOnString!HandMorph removeSelector: #handleDragOver:!HandMorph removeSelector: #handleMouseDown:!HandMorph removeSelector: #handleMouseMove:!HandMorph removeSelector: #handleMouseOver:!HandMorph removeSelector: #handleMouseUp:!HandMorph removeSelector: #inspectArgumentsPlayerInMorphic!HandMorph removeSelector: #inspectMorph!HandMorph removeSelector: #inspectMorphInMorphic!HandMorph removeSelector: #invokeMenu:event:!HandMorph removeSelector: #invokeMetaMenu:!HandMorph removeSelector: #invokeMetaMenu:argument:!HandMorph removeSelector: #invokeMetaMenuFor:!HandMorph removeSelector: #isDraggingEvent:!HandMorph removeSelector: #jumpToProject!HandMorph removeSelector: #lockMorph!HandMorph removeSelector: #makeNewDrawingInBounds:pasteUpMorph:!HandMorph removeSelector: #makeNewPlayerInstance!HandMorph removeSelector: #makeSelection!HandMorph removeSelector: #maybeDuplicateMorph!HandMorph removeSelector: #mouseOverList:!HandMorph removeSelector: #mouseOverList:rank:!HandMorph removeSelector: #nameMorph!HandMorph removeSelector: #newDrawingFromMenu!HandMorph removeSelector: #newHandleEvent:!HandMorph removeSelector: #noteSignificantEvent:!HandMorph removeSelector: #openFileDirectly!HandMorph removeSelector: #openPackageBrowser!HandMorph removeSelector: #openScrapsBook!HandMorph removeSelector: #openViewerForArgument!HandMorph removeSelector: #operateOnSubmorph:event:!HandMorph removeSelector: #placeArgumentIn!HandMorph removeSelector: #popUpHalo:!HandMorph removeSelector: #popUpHaloFor:event:!HandMorph removeSelector: #popUpHaloFromClick:!HandMorph removeSelector: #popUpHaloFromShiftClick:!HandMorph removeSelector: #popUpNewHaloFromClick:targets:!HandMorph removeSelector: #potentialEmbeddingTargets!HandMorph removeSelector: #putUpDesktopMenu!HandMorph removeSelector: #recipientForMouseDown:!HandMorph removeSelector: #rejectDropMorph:event:!HandMorph removeSelector: #resizeMorph!HandMorph removeSelector: #saveAsPrototype!HandMorph removeSelector: #saveOnFile!HandMorph removeSelector: #savePictureOfWorld!HandMorph removeSelector: #selectEmbedTargetMorph:!HandMorph removeSelector: #selectSubmorphToOperateOn:sending:event:!HandMorph removeSelector: #setArgument:!HandMorph removeSelector: #setGridSize!HandMorph removeSelector: #setGridding!HandMorph removeSelector: #showActions!HandMorph removeSelector: #showHiders!HandMorph removeSelector: #specialDrag:!HandMorph removeSelector: #specialGesture:!HandMorph removeSelector: #startDisplaySuppression!HandMorph removeSelector: #startReportingEventsTo:!HandMorph removeSelector: #stopReportingEventsTo:!HandMorph removeSelector: #subclassMorph!HandMorph removeSelector: #submorphNameFor:!HandMorph removeSelector: #suppressDisplay!HandMorph removeSelector: #transformEvent:!HandMorph removeSelector: #unfocusedKeystroke:!HandMorph removeSelector: #unlockContents!HandMorph removeSelector: #unlockOneSubpart!HandMorph removeSelector: #worldMenuBuilder!HandMorph removeSelector: #worldUnderCursor!HandMorph removeSelector: #writeInitMethodForModel!HandMorph removeSelector: #yellowButtonClickOnDesktopWithEvent:!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent lastEvent targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset remoteConnections transmitBuffer hasChanged savedPatch userInitials '	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Morphic-Kernel'!Morph removeSelector: #allMenuWordings:!Morph removeSelector: #debuggingMenuFor:!Morph removeSelector: #formerPositon:!