'From Squeak2.9alpha of 13 June 2000 [latest update: #2915] on 12 November 2000 at 6:06:13 pm'!"Change Set:		249CelesteEnc-bfDate:			9 March 2000Author:			Bert FreudenbergRequires:		ScamperEnc-bfMakes Celeste use iso8859-1 encoding internally while doing on-the-fly conversion to Squeak encoding for the UI. Also allows importing from Unix mailbox files by using CrLfFilestream.[This hasn't need test - remove it if it breaks Celeste --sma]"!Stream subclass: #MailAddressTokenizer	instanceVariableNames: 'cachedToken text pos '	classVariableNames: 'CSNonAtom CSNonSeparators CSParens CSSpecials '	poolDictionaries: ''	category: 'Network-RFC822'!!Celeste methodsFor: 'categories pane' stamp: 'dvf 4/26/2000 21:08'!setCategory: newCategory 	"Change the currently selected category. We must also compute the table  	of contents and message list for the new category."	| messageCount |	currentCategory _ newCategory.	newCategory isNil		ifTrue: [status _ currentMessages _ currentTOC _ currentMsgID _ nil]		ifFalse: 			[currentMessages _ self filteredMessagesIn: newCategory.			messageCount _ currentMessages size.			messageCount > self maxMessageCount				ifTrue: 					[self messages: self maxMessageCount from: messageCount.					currentMessages _ currentMessages copyLast: self maxMessageCount]				ifFalse: [self messages: messageCount from: messageCount].			self updateToc].	self changed: #category.	self changed: #tocEntryList.	self changed: #tocEntry.	self changed: #messageText.	self changed: #status! !!Celeste methodsFor: 'table of contents pane' stamp: 'bf 3/10/2000 11:29'!selectMessage: id	"Change the currently selected message."	currentMsgID _ id.	self changed: #tocEntry.	self changed: #messageText! !!Celeste methodsFor: 'message text pane' stamp: 'dvf 4/27/2000 00:14'!formatedMessageText	"Answer a string that is my formatted mail message."	| message header body bodyText |	currentMsgID isNil ifTrue: [^ ''].	message _ self currentMessage.	header _ message cleanedHeader.	body _ message body.	body contentType = 'text/html'		ifTrue: [bodyText _ (HtmlParser parse: (ReadStream on: body content)) formattedText]		ifFalse: [bodyText _ body content].	^ header asText , String cr , bodyText! !!Celeste methodsFor: 'message text pane' stamp: 'ls 4/30/2000 18:33'!messageText	"Answer the text which makes up the complete message (header+body)"	(currentMsgID isNil) ifTrue: [^''].	"Always show the full message header for messages in the category .tosend. so that all special header lines are preserved, shown and can be edited."	(currentCategory = '.tosend.')		ifTrue: [^ mailDB getText: currentMsgID].	SuppressWorthlessHeaderFields		ifTrue: [^ self currentMessage formattedText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'message text pane' stamp: 'bf 3/9/2000 17:54'!messageText: aStringOrText	currentCategory isNil | currentMsgID isNil ifTrue: [^ self].	mailDB newText: aStringOrText asString squeakToIso for: currentMsgID.	self updateTOC.  "in case the message header was changed"	messageTextView hasUnacceptedEdits: false.	self changed: #messageText.	^ true! !!Celeste methodsFor: 'sending mail' stamp: 'dvf 5/17/2000 20:48'!queueMessageWithText: aStringOrText 	"Queue a message to be sent later. The message is added to the database 	and filed in the '.tosend.' category."	| messageText id |	messageText _ 'X-Mailer: ' , Celeste versionString , String cr , 'Date: ' , MailMessage dateStampNow, ' ' , self timeZoneString, ' ', String cr.	messageText _ messageText , aStringOrText asString.	self requiredCategory: '.tosend.'.	"queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText).	mailDB file: id inCategory: '.tosend.'.	self category = '.tosend.' ifTrue: [self updateTOC]! !!Celeste class methodsFor: 'user preferences' stamp: 'bf 3/9/2000 18:11'!setUserName	"Change the user's email name for use in composing messages."	(UserName isNil) ifTrue: [UserName _ ''].	UserName _ FillInTheBlank		request: 'What is your email address?\(This is the address other people will reply to you)' withCRs		initialAnswer: UserName isoToSqueak.	UserName ifNotNil: [UserName _ UserName squeakToIso]! !!CelesteComposition methodsFor: 'access' stamp: 'bf 3/9/2000 18:02'!messageText	"return the current text"	^messageText isoToSqueak! !!CelesteComposition methodsFor: 'access' stamp: 'bf 3/9/2000 18:26'!messageText: aText	"change the current text"	messageText _ aText squeakToIso.	self changed: #messageText.	^true! !!CelesteComposition methodsFor: 'access' stamp: 'dvf 5/13/2000 16:51'!submit	"submit the message"	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	celeste queueMessageWithText: (MailMessage from: messageText asString) asSendableText.	morphicWindow ifNotNil: [morphicWindow delete].	mvcWindow ifNotNil: [mvcWindow controller close]! !!Character methodsFor: 'converting' stamp: 'bf 3/9/2000 16:52'!squeakToIso	"Convert from mac to iso8895-1 encoding. Does not do lf/cr conversion!!"	value < 128 ifTrue: [^self].	^ Character value: (#(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 185 176 162 163 167 130 182 223 174 169 142 180 168 173 198 216 141 177 178 179 165 181 166 183 184 160 188 170 186 189 230 248 191 161 172 146 128 129 140 171 187 131 190 192 195 213 145 147 208 132 150 148 149 144 247 215 255 221 152 151 134 153 222 164 136 135 137 139 138 194 202 193 203 200 205 206 207 204 211 212 240 210 218 219 217 155 154 133 143 157 156 158 159 253 254 175) at: value - 127)! !!Collection methodsFor: 'enumerating' stamp: 'sma 4/30/2000 11:17'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!Collection methodsFor: 'enumerating' stamp: 'bf 3/10/2000 08:51'!noneSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:item | (aBlock value: item) ifTrue: [^ false]].	^ false! !!Collection methodsFor: 'testing' stamp: 'bf 3/10/2000 09:29'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ self isEmpty! !!IndexFileEntry methodsFor: 'printing' stamp: 'bf 3/9/2000 16:09'!computeTOCString	"Answer a string for the table of contents."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	| fromFieldSize s |	fromFieldSize _ 18.	s _ WriteStream on: (String new: 200).	s nextPutAll: self dateString.	[s position < 9] whileTrue: [s space].	s nextPutAll: (self fromStringLimit: fromFieldSize).	[s position <= (9 + fromFieldSize + 2)] whileTrue: [s space].	s nextPutAll: subject decodeMimeHeader.	^ s contents! !!IndexFileEntry methodsFor: 'printing' stamp: 'bf 3/9/2000 16:05'!fromStringLimit: limit	"Answer a cleaned up 'from' field for the table of contents."	| editedFrom s ch i |	editedFrom _ WriteStream on: (String new: limit + 1).	s _ ReadStream on: from decodeMimeHeader.	s skipSeparators.	('"<' includes: s peek) ifTrue: [s next].	((i _ from indexOf: $() > 0) ifTrue: [s position: i].	[s atEnd] whileFalse: [		ch _ s next.		(('@<>)$"' includes: ch) or: [editedFrom position >= limit])			ifTrue: [^editedFrom contents]			ifFalse: [editedFrom nextPut: ch]].	^editedFrom contents! !!MailAddressParser methodsFor: 'parsing' stamp: 'bf 3/12/2000 20:06'!grabAddresses	"grab all the addresses in the string"	| token |	"remove comments"	tokens removeAllSuchThat: [:t | t type == #Comment].	"grab one address or address group each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		"check whether any tokens are left"		tokens isEmpty 	] whileFalse: [		token _ tokens last.		"delegate, depending on what form the address is in"		"the from can be determined from the last token"		token type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: token type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			token type = $; ifTrue: [				self grabGroupAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ] ]	].	^addresses! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'bf 3/12/2000 19:59'!nextComment	| start nestLevel paren |	start _ pos.	pos _ pos + 1.	nestLevel _ 1.	[ nestLevel > 0 ] whileTrue: [		pos _ text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren _ self nextChar.		paren = $( ifTrue: [ nestLevel _ nestLevel + 1 ] ifFalse: [ nestLevel _ nestLevel - 1 ]].	^ MailAddressToken type: #Comment		text: (text copyFrom: start to: pos + 1)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'bf 3/12/2000 19:53'!nextToken	| c |	self skipSeparators.	c _ self peekChar.	c ifNil: [ ^nil ].	c = $( ifTrue: [ ^self nextComment ].	c = $" ifTrue: [ ^self nextQuotedString ].	c = $[ ifTrue: [ ^self nextDomainLiteral ].	(CSSpecials includes: c) ifTrue: [ ^self nextSpecial ].	^self nextAtom! !!MailInboxFile methodsFor: 'scanning' stamp: 'bf 3/9/2000 18:36'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText |	fileStream _ CrLfFileStream readOnlyFileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	self scanToNextMessageIn: stream.	MailDB skipRestOfLine: stream.  "skip message delimiter"	msgStart _ stream position.	[self scanToNextMessageIn: stream] whileTrue: [		msgSize _ stream position - msgStart.		stream position: msgStart.		msgText _ stream next: msgSize.		MailDB skipRestOfLine: stream.  "skip message delimiter"		msgStart _ stream position.		aBlock value: msgText].	"process final message"	msgSize _ stream position - msgStart.	msgSize > 0 ifTrue: [		stream position: msgStart.		msgText _ stream next: msgSize.		aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MailMessage methodsFor: 'initialize-release' stamp: 'bf 3/10/2000 10:01'!cacheFieldsFrom: aStream andDo: aBlock	"Parse aStream to initialize myself. Also, report to aBlock like fieldsFrom:do: does"	time _ 0.	from _ to _ cc _ subject _ ''.	self fieldsFrom: aStream do:		[:fName :fValue |			fName asLowercase caseOf: {				['date'] -> [time _ self timeFrom: fValue].				['from'] -> [from _ fValue].				['to'] -> [to isEmpty					ifTrue: [to _ fValue]					ifFalse: [to _ to , ', ' , fValue]].				['cc'] -> [cc isEmpty					ifTrue: [cc _ fValue]					ifFalse: [cc _ cc , ', ' , fValue]].				['subject'] -> [subject _ fValue]}				otherwise: [].			aBlock value: fName value: fValue].! !!MailMessage methodsFor: 'initialize-release' stamp: 'bf 3/10/2000 10:03'!cachedFields	^ #('Date' 'From' 'To' 'Cc' 'Subject')! !!MailMessage methodsFor: 'initialize-release'!from: aString 	"Parse aString to initialize myself."	| parseStream isMime contentType bodyText contentTransferEncoding |	time _ 0.	from _ to _ cc _ subject _ '' copy.	text _ aString withoutTrailingBlanks, String cr.	parseStream _ ReadStream on: text.	isMime _ false.  "mdr: This variable is later set but never seems to be used???"	contentType _ 'text/plain'.	contentTransferEncoding _ nil.	fields := Dictionary new.	self fieldsFrom: parseStream do: 		[:fName :fValue | 		fName = 'date' ifTrue: [time _ (self timeFrom: fValue) ifNil: [ 0 ]].		fName = 'from' ifTrue: [from _ fValue].		fName = 'to'			ifTrue: [to isEmpty					ifTrue: [to _ fValue]					ifFalse: [to _ to , ', ' , fValue]].		fName = 'cc'			ifTrue: [cc isEmpty					ifTrue: [cc _ fValue]					ifFalse: [cc _ cc , ', ' , fValue]].		fName = 'subject' ifTrue: [subject _ fValue].		fName = 'mime-version' ifTrue: [isMime _ true].		fName = 'content-type' ifTrue: [contentType _ (fValue copyUpTo: $;) asLowercase].		fName = 'content-transfer-encoding' ifTrue: [contentTransferEncoding _ fValue asLowercase].		fields at: fName put: (MIMEHeaderValue fromString: fValue)].	bodyText _ parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText _ Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText _ bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [bodyText _ bodyText decodeQuotedPrintable].	body _ MIMEDocument contentType: contentType content: bodyText! !!MailMessage methodsFor: 'parsing' stamp: 'bf 3/10/2000 09:44'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value. The streams position is left right after the empty line separating header and body."	| savedLine line s |	savedLine _ MailDB readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line _ savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine _ MailDB readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s _ ReadStream on: savedLine.			s skipSeparators.			line _ line, s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!MailMessage methodsFor: 'parsing' stamp: 'bf 3/10/2000 08:37'!headerFieldsNamed: fieldName do: aBlock	"Evalue aBlock once for each header field which matches fieldName.  The block is valued with one parameter, the value of the field"	self fieldsFrom: (ReadStream on: text) do:		[: fName : fValue |			(fieldName sameAs: fName) ifTrue: [aBlock value: fValue]].! !!MailMessage methodsFor: 'parsing' stamp: 'bf 3/10/2000 11:04'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field is malformed."	| s fieldName fieldValue |	(aString includes: $:) ifFalse: [^self].	s _ ReadStream on: aString.	fieldName _ s upTo: $:.	fieldValue _ s upToEnd withBlanksTrimmed.	fieldValue isEmpty ifFalse: [aBlock value: fieldName value: fieldValue].! !!MailMessage methodsFor: 'printing/formatting' stamp: 'bf 3/10/2000 09:34'!cleanedHeader	"Reply with a cleaned up version email header.  First show fields people would normally want to see (in a regular order for easy browsing), and then any other fields not explictly excluded"	| new priorityFields omittedFields |	new _ WriteStream on: (String new: text size).	priorityFields _ #('Date' 'From' 'Subject' 'To' 'Cc').	omittedFields _ MailMessage omittedHeaderFields.	"Show the priority fields first, in the order given in priorityFields"	priorityFields do: [ :pField |		"We don't check whether the priority field is in the omitted list!!"		self headerFieldsNamed: pField do:			[: fValue | new nextPutAll: pField, ': ', fValue; cr]].	"Show the rest of the fields, omitting the uninteresting ones and ones we have already shown"	omittedFields _ omittedFields, priorityFields.	self fieldsFrom: (ReadStream on: text) do:		[: fName : fValue |		 (omittedFields anySatisfy: [: omitted | fName sameAs: omitted]) ifFalse:			[new nextPutAll: fName, ': ', fValue; cr]].	^new contents! !!MailMessage methodsFor: 'fields' stamp: 'bf 3/10/2000 15:22'!canonicalFields	"Break long header fields and escape those containing high-ascii characters according to RFC2047"	self rewriteFields:		[ :fName :fValue | 			(fName size + fValue size < 72 and: [fValue allSatisfy: [:c | c asciiValue <= 128]])				ifFalse: [RFC2047MimeConverter mimeEncode: fName, ': ', fValue]]		append: [].! !!MailMessage methodsFor: 'fields' stamp: 'bf 3/10/2000 14:07'!replaceFields: fieldsArray	"Replace existing fields or append to the header. fieldsArray is an array of entire header lines."	| found fields |	fields _ Dictionary new.	fieldsArray do: [:f | fields at: (f copyUpTo: $:) asLowercase put: f withoutTrailingBlanks].	found _ Set new.	self rewriteFields:		[ :fName :fValue | | fieldString |			fieldString _ fields at: fName asLowercase ifAbsent: [].			fieldString ifNotNil: [				found add: fName asLowercase.				(fieldString last = $:)					ifTrue: ['']					ifFalse: [fieldString]]]		append: [String streamContents: [:append |			fields keysAndValuesDo: [:fk :fv | 				((found includes: fk) or: [fv last = $:])					ifFalse: [append nextPutAll: fv; cr]]]].! !!MailMessage methodsFor: 'fields' stamp: 'bf 3/10/2000 14:10'!rewriteFields: aBlock append: appendBlock	"Rewrite header fields. The body is not modified.	Each field's key and value is reported to aBlock. The block's return value is the replacement for the entire header line. Nil means don't change the line, empty means delete it. After all fields are processed, evaluate appendBlock and append the result to the header."	| old new result appendString |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do: [ :fName :fValue |		result _ aBlock value: fName value: fValue.		result ifNil: [new nextPutAll: fName, ': ', fValue; cr]			ifNotNil: [result isEmpty				ifFalse: [new nextPutAll: result.					result last = Character cr ifFalse: [new cr]]]].	appendString _ appendBlock value.	appendString isEmptyOrNil ifFalse:		[new nextPutAll: appendString.		appendString last = Character cr ifFalse: [new cr]].	new cr. "End of header"	text _ new contents, old upToEnd.	self cacheFieldsFrom: (ReadStream on: text) andDo: [:f :n | "Just chache it"]! !!MailMessage class methodsFor: 'preferences' stamp: 'mdr 1/24/2000 11:49'!omittedHeaderFields	"Reply a list of fields to omit when displaying a nice simple message"	^ #(			'comments'			'priority'			'disposition-notification-to'			'x-envelope-info'			'x-mime-autoconverted'			'content-id'			'received'			'x-accept-language'			'x-mailer-version'			'x-unityuser'			'return-path'			'newsgroups'			'message-id'			'path'			'in-reply-to'			'sender'			'x-sender'			'fonts'			'x-mailer'			'mime-version'			'x-uidl'			'status'			'content-type'			'content-transfer-encoding'			'errors-to'			'keywords'			'references'			'x-vms-to'			'x-delivery-notice'			'x-reply-of'			'x-newsreader'			'x-icon'			'x-mailing-list'			'x-loop'			'x-priority'			'x-msmail-priority'			'x-mimeole'			'x-organization'			'x-originating-ip'			'x-sun-charset'			'x-url'			'x-nextstep-mailer'			'x-authentication-warning'			'x-lotus-fromdomain'			'x-blackmail'			'x-authenticated-timestamp'			'nntp-posting-host'			'lines'			'return-receipt-to'			'precedence'			'originator'			'distribution'			'content-disposition'			'importance'			'resent-to'			'resent-cc'			'resent-message-id'			'resent-date'			'resent-sender'			'resent-from'		)! !!MimeConverter class methodsFor: 'convenience' stamp: 'bf 3/10/2000 14:47'!forEncoding: encodingString	"Answer a converter class for the given encoding or nil if unknown"	encodingString ifNil: [^nil].	^ encodingString asLowercase caseOf: 		{ ['base64'] -> [Base64MimeConverter].		  ['quoted-printable'] -> [QuotedPrintableMimeConverter]}		otherwise: [].! !!MimeConverter class methodsFor: 'convenience' stamp: 'bf 3/10/2000 14:43'!mimeDecode: aStringOrStream as: contentsClass	^ contentsClass streamContents: [:out |		self mimeDecode: aStringOrStream to: out]! !!MimeConverter class methodsFor: 'convenience' stamp: 'bf 3/10/2000 14:40'!mimeDecode: aStringOrStream to: outStream	self new		mimeStream: (aStringOrStream isStream			ifTrue: [aStringOrStream]			ifFalse: [ReadStream on: aStringOrStream]);		dataStream: outStream;		mimeDecode! !!MimeConverter class methodsFor: 'convenience' stamp: 'bf 3/10/2000 14:40'!mimeEncode: aCollectionOrStream	^ String streamContents: [:out |		self mimeEncode: aCollectionOrStream to: out]! !!MimeConverter class methodsFor: 'convenience' stamp: 'bf 3/10/2000 14:40'!mimeEncode: aCollectionOrStream to: outStream	self new		dataStream: (aCollectionOrStream isStream			ifTrue: [aCollectionOrStream]			ifFalse: [ReadStream on: aCollectionOrStream]);		mimeStream: outStream;		mimeEncode! !!RFC2047MimeConverter methodsFor: 'conversion' stamp: 'bf 3/10/2000 16:06'!mimeEncode	"Do conversion reading from dataStream writing to mimeStream. Break long lines and escape non-7bit chars."	| word pos wasGood isGood max |	true ifTrue: [mimeStream nextPutAll: dataStream upToEnd].	pos _ 0.	max _ 72.	wasGood _ true.	[dataStream atEnd] whileFalse: [		word _ self readWord.		isGood _ word allSatisfy: [:c | c asciiValue < 128].		wasGood & isGood ifTrue: [			pos + word size < max				ifTrue: [dataStream nextPutAll: word.					pos _ pos + word size]				ifFalse: []		]	].	^ mimeStream! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/11/2000 23:16'!encodeChar: aChar to: aStream	aChar = Character space		ifTrue: [^ aStream nextPut: $_].	((aChar asciiValue between: 32 and: 127) and: [('?=_' includes: aChar) not])		ifTrue: [^ aStream nextPut: aChar].	aStream nextPut: $=;		nextPut: (Character digitValue: aChar asciiValue // 16);		nextPut: (Character digitValue: aChar asciiValue \\ 16)! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/11/2000 23:13'!encodeWord: aString	(aString allSatisfy: [:c | c asciiValue < 128])		ifTrue: [^ aString].	^ String streamContents: [:stream |		stream nextPutAll: '=?iso-8859-1?Q?'.		aString do: [:c | self encodeChar: c to: stream].		stream nextPutAll: '?=']! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/12/2000 14:36'!isStructuredField: aString	| fName |	fName _ aString copyUpTo: $:.	('Resent' sameAs: (fName copyUpTo: $-))		ifTrue: [fName _ fName copyFrom: 8 to: fName size].	^#('Sender' 'From' 'Reply-To' 'To' 'cc' 'bcc') anySatisfy: [:each | fName sameAs: each]! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/11/2000 22:30'!readWord	| strm |	strm _ WriteStream on: (String new: 20)	dataStream skipSeparators.	[dataStream atEnd] whileFalse: 		[ | c |		c _ dataStream next.		strm nextPut: c.		c isSeparator ifTrue: [^ strm contents]].	^ strm contents! !!String methodsFor: 'internet' stamp: 'bf 3/9/2000 16:46'!squeakToIso	^self collect: [:c | c squeakToIso ]! !!Text methodsFor: 'converting' stamp: 'bf 3/9/2000 18:25'!isoToSqueak	^ self class new setString: string isoToSqueak setRuns: runs copy! !!Text methodsFor: 'converting' stamp: 'bf 3/9/2000 18:25'!squeakToIso	^ self class new setString: string squeakToIso setRuns: runs copy! !!RFC2047MimeConverter reorganize!('conversion' mimeDecode mimeEncode)('private-encoding' encodeChar:to: encodeWord: isStructuredField: readWord)!!MimeConverter class reorganize!('convenience' forEncoding: mimeDecode:as: mimeDecode:to: mimeEncode: mimeEncode:to:)!MailMessage removeSelector: #replace:with:in:!MailAddressTokenizer removeSelector: #skipComment!MailAddressTokenizer removeSelector: #skipSeparatorsAndComments!