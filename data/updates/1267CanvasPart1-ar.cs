'From Squeak 2.4b of April 23, 1999 on 24 June 1999 at 6:40:25 pm'!"Change Set:		CanvasPart1-arDate:			17 June 1999Author:			Andreas RaabOkay, here's the first part of the changes to Morphic drawing. All of this stuff is (or at least should be ;-) *purely* structural - nothing at all should change in the way stuff looks or behaves. Here is an overview of the major changes:* Morph>>canvasForSubmorphs: has been removed; use Morph>>drawSubmorphsOn: instead for changing canvas attributes for the submorphs (see the implementors of #drawSubmorphsOn:).IMPORTANT: Check your stuff for any implementors of #canvasForSubmorphs: - it will no longer be called.* Canvas copyXYZ have been moved down to FormCanvas>>copyXYZ and replaced by state-preserving methods (see below). Unless you *know* that you're dealing with a FormCanvas (because you just created it) you should never ever send any of the copyXYZ messages - use the new stuff instead.* A new Canvas category: 'drawing-general' containing	Canvas>>draw: anObject	Canvas>>fullDraw: anObject	Canvas>>drawMorph: aMorph	Canvas>>fullDrawMorph: aMorph	The messages #drawMorph: and fullDrawMorph: should be used for drawing Morphs - this is the hook for getting rid of #fullDrawOn:without:andStopThere: stuff as well as #setShadowDrawing later in the process. #draw: and #fullDraw: are even more general hooks but not yet used.* new Canvas category: 'drawing-support'The category contains the new state-preserving methods for clipping, translation etc. (implemented in FormCanvas as #copyXYZ; see the implementors of #translateBy:clippingTo:during:). Also contains #cache:using:during: which should be used in Morphs drawing methods instead of simply #image:at: if the image is only a cache for more general drawing method (see the senders of #cache:using:during:). Also contains #transformBy:clippingTo:during: moving the TransformMorph's use of WarpBlt to the right place (e.g., into the FormCanvas).* Canvas' drawing methods are no longer empty - they are either implemented in a more general way (such as #fillColor: or #frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor:) or subclass responsibilities so as to minimize implementation efforts for new canvases (see the class comment of Canvas).* A cleanup of some methods such as EllipseMorph>>drawOn: where the special case of translucent borders has been moved into the right place (e.g. FormCanvas itself)"!!Canvas commentStamp: 'ar 6/24/1999 18:38' prior: 0!A canvas is a two-dimensional medium on which morphs are drawn in a device-independent manner. Canvases keep track of the origin and clipping rectangle, as well as the underlying drawing medium (such as a window, pixmap, or postscript script).Subclasses must implement (at least) the following methods:	* Accessing:		#origin		#extent		#clipRect	* Drawing:		#fillOval:color:borderWidth:borderColor:		#frameAndFillRectangle:fillColor:borderWidth:borderColor:		#image:at:sourceRect:rule:		#stencil:at:sourceRect:color:		#line:to:width:color:		#paragraph:bounds:color:		#text:bounds:font:color:	* Support		#clipBy:during:		#translateBy:during:		#translateBy:clippingTo:during:		#transformBy:clippingTo:during:!!Canvas reorganize!('initialization' flush reset)('copying' copy)('accessing' clipRect depth extent form origin)('testing' isBalloonCanvas isShadowDrawing isVisible:)('drawing' fillColor: fillOval:color: fillOval:color:borderWidth:borderColor: fillRectangle:color: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameOval:color: frameOval:width:color: frameRectangle:color: frameRectangle:width:color: image:at: image:at:rule: image:at:sourceRect:rule: imageWithOpaqueWhite:at: line:to:brushForm: line:to:color: line:to:width:color: paragraph:bounds:color: point:color: render: stencil:at:color: stencil:at:sourceRect:color: text:at:font:color: text:bounds:font:color:)('drawing-general' draw: drawMorph: fullDraw: fullDrawMorph:)('drawing-support' cache:using:during: clipBy:during: preserveStateDuring: transformBy:clippingTo:during: translateBy:clippingTo:during: translateBy:during: translateTo:clippingTo:during:)('private')('converting' asShadowDrawingCanvas asShadowDrawingCanvas:)!!Canvas methodsFor: 'initialization' stamp: 'ar 6/22/1999 14:05'!reset	"Reset the canvas"! !!Canvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:07'!clipRect	"Return the currently active clipping rectangle"	^self subclassResponsibility! !!Canvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:15'!extent	"Return the physical extent of the output device"	^self subclassResponsibility! !!Canvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:11'!origin	"Return the current origin for drawing operations"	^self subclassResponsibility! !!Canvas methodsFor: 'testing' stamp: 'ar 6/22/1999 14:10'!isVisible: aRectangle	"Return true if the given rectangle is (partially) visible"	^self clipRect intersects: aRectangle! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:18'!fillColor: aColor	"Fill the receiver with the given color.	Note: This method should be named differently since it is intended to fill the background and thus fills even if the color is transparent"	^self fillRectangle: self clipRect color: (aColor alpha: 1.0).! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:18'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Fill the given oval."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:19'!fillRectangle: r color: c	"Fill the rectangle using the given color"	^self 		frameAndFillRectangle: r		fillColor: c		borderWidth: 0		borderColor: Color transparent! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:20'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:28'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw the rectangle using the given attributes.	Note: This is a *very* simple implementation"	| bw pt |	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: bottomRightColor.	bw _ borderWidth asPoint.	pt _ r topLeft + (bw // 2).	self line: pt to: pt + ((r extent x - bw x)@0) width: borderWidth color: topLeftColor.	self line: pt to: pt + (0@(r extent y - bw y)) width: borderWidth color: topLeftColor.! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:30'!frameRectangle: r width: w color: c	^self frameAndFillRectangle: r fillColor: Color transparent borderWidth: w borderColor: c.! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:30'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the given form."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:30'!line: pt1 to: pt2 brushForm: brush	"Obsolete - will be removed in the future"! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:31'!line: pt1 to: pt2 width: w color: c	"Draw a line using the given width and color"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:31'!paragraph: paragraph bounds: bounds color: c	"Draw the given paragraph"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:32'!point: p color: c	"Obsolete - will be removed in the future"! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:32'!text: s bounds: boundsRect font: fontOrNil color: c	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 5/29/1999 05:14'!draw: anObject	^anObject drawOn: self! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 5/29/1999 05:15'!drawMorph: aMorph	(self isVisible: aMorph bounds) ifTrue:[self draw: aMorph]! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 5/29/1999 05:14'!fullDraw: anObject	^anObject fullDrawOn: self! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 5/29/1999 05:14'!fullDrawMorph: aMorph	(self isVisible: aMorph fullBounds) ifTrue:[self fullDraw: aMorph].! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 00:59'!cache: aRectangle using: aCache during: aBlock	"Cache the execution of aBlock by the given cache.	Note: At some point we may want to actually *create* the cache here;		for now we're only using it."	(aCache notNil and:[(aCache isKindOf: Form) and:[aCache extent = aRectangle extent]]) 		ifTrue:[^self image: aCache at: aRectangle origin].	aBlock value: self.! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 02:53'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 01:43'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock"	^aBlock value: self copy! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 02:59'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	"Transform the receiver by the given display transformation during the execution of aBlock. The given clip rectangle defines the *global* (e.g., outer) rectangle against which the receiver should clip (which would be equivalent to 'self clipRect: aClipRect; transformBy: aDisplayTransform')."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 02:59'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:00'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 14:08'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	self translateBy: newOrigin - self origin 		clippingTo: (aRectangle translateBy: self origin negated) 		during: aBlock! !!FormCanvas reorganize!('initialize-release' reset)('accessing' clipRect depth extent form origin)('testing' isShadowDrawing isVisible:)('copying' copy copyClipRect: copyForShadowDrawingOffset: copyOffset: copyOffset:clipRect: copyOrigin:clipRect:)('drawing' fillColor: fillOval:color:borderWidth:borderColor: fillRectangle:color: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameRectangle:width:color: image:at:sourceRect:rule: line:to:brushForm: line:to:width:color: paragraph:bounds:color: point:color: stencil:at:color: stencil:at:sourceRect:color: text:bounds:font:color:)('drawing-support' clipBy:during: fillTranslucentOval:color:borderWidth:borderColor: setShadowDrawing transformBy:clippingTo:during: translateBy:clippingTo:during: translateBy:during: translateTo:clippingTo:during:)('other' asBalloonCanvas showAt: showAt:invalidRects: warpFrom:toRect:)('private' drawColor: drawRule:color: resetGrafPort setForm: setOrigin:clipRect: stipple stipple:)('converting' asShadowDrawingCanvas:)!!FormCanvas methodsFor: 'initialize-release' stamp: 'ar 6/22/1999 14:03'!reset	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	shadowDrawing _ false.					"draw translucent shadows when true"! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:06'!clipRect	"Return the currently active clipping rectangle"	^ clipRect translateBy: origin negated! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:10'!origin	"Return the current origin for drawing operations"	^ origin! !!FormCanvas methodsFor: 'testing' stamp: 'ar 6/22/1999 14:02'!isShadowDrawing	^ shadowDrawing! !!FormCanvas methodsFor: 'testing' stamp: 'ar 6/22/1999 14:08'!isVisible: aRectangle	"Optimization"	(aRectangle right + origin x) < clipRect left	ifTrue: [^ false].	(aRectangle left + origin x) > clipRect right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clipRect top	ifTrue: [^ false].	(aRectangle top + origin y) > clipRect bottom	ifTrue: [^ false].	^ true! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:51'!copyClipRect: aRectangle	^ self copyOrigin: origin clipRect: (aRectangle translateBy: origin)! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyForShadowDrawingOffset: aPoint	^ (self copyOrigin: origin + aPoint clipRect: clipRect) setShadowDrawing! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOffset: aPoint	^ self copyOrigin: origin + aPoint clipRect: clipRect! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOffset: aPoint clipRect: sourceClip	"Make a copy of me offset by aPoint, and further clipped	by sourceClip, a rectangle in the un-offset coordinates"	^ self copyOrigin: aPoint + origin		clipRect: ((sourceClip translateBy: origin) intersect: clipRect)! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOrigin: aPoint clipRect: aRectangle	"Return a copy of this canvas with the given origin. The clipping rectangle of this canvas is the intersection of the given rectangle and the receiver's current clipping rectangle. This allows the clipping rectangles of nested clipping morphs to be composed."	^ self copy		setOrigin: aPoint		clipRect: (clipRect intersect: aRectangle)! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 02:10'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC borderRule |	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: ["Translucent border requires use of temporary forms"				^self fillTranslucentOval: r color: c borderWidth: borderWidth borderColor: borderColor].	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [fillC == nil ifTrue: [^ self].  "both border and fill are transparent"				borderC _ nil.				rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor.				borderRule _ self drawRule: Form over color: borderColor].	port combinationRule: (self drawRule: Form over color: c).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC		borderRule: borderRule.! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:02'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	^aBlock value: (self copyClipRect: aRectangle)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 02:41'!fillTranslucentOval: bounds color: color borderWidth: borderWidth borderColor: borderColor	"Translucent border requires use of temporary forms"	| tempCanvas fillForm borderForm |	tempCanvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black.	tempCanvas translateBy: bounds topLeft negated during:[:c|		c fillOval: bounds color: color			borderWidth: borderWidth borderColor: Color transparent].	fillForm _ tempCanvas form.	tempCanvas _ (FormCanvas extent: bounds extent depth: 1)		setShadowDrawing; stipple: Color black.	tempCanvas translateBy: bounds topLeft negated during:[:c|		c fillOval: bounds color: Color transparent			borderWidth: borderWidth borderColor: borderColor].	borderForm _ tempCanvas form copy offset: 0@0.	fillForm copy: borderForm boundingBox from: borderForm				to: 0@0 rule: Form erase.	self stencil: fillForm at: bounds topLeft color: color.	self stencil: borderForm at: bounds topLeft color: borderColor! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 17:21'!setShadowDrawing	"Put this canvas into 'shadow drawing' mode, which is used to draw translucent shadows. While in this mode, all drawing operations are done in black through a gray mask. The mask allows some of the underlying pixels to show through, providing a crude sense of transparency."	| screen blackWord |	shadowDrawing _ true.	"Build a 50% stipple of black for the given depth."	form depth >= 16		ifTrue: [shadowStipple _ Color black alpha: 0.5]		ifFalse: [screen _ Color pixelScreenForDepth: form depth.				blackWord _ Color black pixelWordForDepth: form depth.				shadowStipple _ (screen collect: [:maskWord | maskWord bitAnd: blackWord])]! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 14:04'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal:					(self clipRect intersect: innerRect).	sourceQuad _ (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: self stipple].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:03'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	^aBlock value: (self copyOffset: delta clipRect: aRectangle)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:02'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	^aBlock value: (self copyOffset: delta)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 02:55'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	aBlock value: (self copyOrigin: newOrigin clipRect: aRectangle)! !!FormCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 14:06'!setOrigin: aPoint clipRect: aRectangle	origin _ aPoint.	clipRect _ aRectangle.	port clipRect: aRectangle.! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 5/29/1999 08:59'!transformBy: aDisplayTransform during: aBlock	| myTransform result |	myTransform _ transform.	self transformBy: aDisplayTransform.	result _ aBlock value: self.	transform _ myTransform.	^result! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 6/17/1999 02:39'!test2	"FormCanvas test2"	| baseCanvas p |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		baseCanvas translateBy: (Sensor cursorPoint - p) during:[:canvas|			canvas fillColor: Color white.			canvas line: 10@10 to: 50@30 width: 1 color: Color red.			canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.			canvas point: 100@100 color: Color black.			canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.			canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.			canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.			canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.			canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.			canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.			canvas showAt: 0@0]].! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 6/17/1999 02:36'!test3	"FormCanvas test3"	| baseCanvas |	baseCanvas _ FormCanvas extent: 200@200.	baseCanvas fillColor: Color white.	baseCanvas translateBy: 10@10 during:[:canvas|		canvas setShadowDrawing.		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0.	].! !!Morph methodsFor: 'drawing' stamp: 'ar 5/29/1999 05:23'!drawSubmorphsOn: aCanvas	"Display submorphs back to front"	submorphs reverseDo:[:m | aCanvas fullDrawMorph: m].! !!Morph methodsFor: 'drawing' stamp: 'ar 5/29/1999 05:16'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	aCanvas drawMorph: self.	self drawSubmorphsOn: aCanvas.! !!Morph methodsFor: 'drawing' stamp: 'ar 6/17/1999 02:14'!imageForm: depth forRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent depth: depth.	canvas translateBy: rect topLeft negated		during:[:tempCanvas| self fullDrawOn: tempCanvas].	^ canvas form offset: rect topLeft! !!BackgroundMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/17/1999 01:06'!drawOn: aCanvas	"The tiling is solely determined by bounds, subBounds and offset.	The extent of display is determined by bounds and the clipRect of the canvas."	| start d subBnds |	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	subBnds _ self subBounds.	running ifFalse:		[super drawOn: aCanvas.		^ aCanvas fillRectangle: subBnds color: Color lightBlue].	start _ subBnds topLeft + offset - bounds topLeft - (1@1) \\ subBnds extent - subBnds extent + (1@1).	d _ subBnds topLeft - bounds topLeft."Sensor redButtonPressed ifTrue: [self halt]."	start x to: bounds width - 1 by: subBnds width do:		[:x |		start y to: bounds height - 1 by: subBnds height do:			[:y | aCanvas translateBy: (x@y) - d clippingTo: bounds				during:[:tileCanvas| self drawSubmorphsOn: tileCanvas]]].! !!BackgroundMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/29/1999 08:32'!fullDrawOn: aCanvas	running ifFalse: [		^aCanvas clipBy: (bounds translateBy: aCanvas origin)				during:[:clippedCanvas| super fullDrawOn: clippedCanvas]].	aCanvas drawMorph: self.! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/29/1999 05:45'!fullDrawOn: aCanvas	self updateCacheCanvasDepth: aCanvas depth.	aCanvas cache: self fullBounds			using: cacheCanvas form			during:[:cachingCanvas| super fullDrawOn: cachingCanvas].! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/17/1999 02:49'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList |	myBnds _ self fullBounds.	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		cacheCanvas translateBy: myBnds origin negated			during:[:tempCanvas| super fullDrawOn: tempCanvas].		^self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: myBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			super fullDrawOn: c]].! !!EllipseMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/17/1999 02:12'!drawOn: aCanvas 	aCanvas fillOval: bounds color: color borderWidth: borderWidth borderColor: borderColor! !!GraphMorph methodsFor: 'drawing' stamp: 'ar 6/22/1999 13:47'!drawOn: aCanvas	| c |	cachedForm = nil ifTrue:  [		c _ FormCanvas extent: bounds extent.		c translateBy: bounds origin negated			during:[:tempCanvas| self drawDataOn: tempCanvas].		cachedForm _ c form].	aCanvas cache: bounds			using: cachedForm			during:[:cachingCanvas| self drawDataOn: cachingCanvas].	self drawCursorOn: aCanvas.! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 02:50'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| subBnds rectList |	depth >= 16 ifTrue:		["Check for real translucency -- can't be cached in a form"		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: subBnds extent depth: depth.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'ar 5/29/1999 09:01'!drawSubmorphsOn: aCanvas	aCanvas asBalloonCanvas transformBy: self transform		during:[:myCanvas| super drawSubmorphsOn: myCanvas].! !!FlashMorph methodsFor: 'accessing' stamp: 'ar 6/17/1999 02:13'!imageFormAALevel: aNumber color: aColor	| canvas |	self defaultAALevel: aNumber.	canvas _ FormCanvas extent: self extent depth: 32.	canvas fillRectangle: (0@0 extent: self extent) color: aColor.	canvas translateBy: self topLeft negated			during:[:tempCanvas| self fullDrawOn: tempCanvas].	^ canvas form mapColor: aColor to: Color transparent! !!FlashMorph methodsFor: 'drawing' stamp: 'ar 5/29/1999 09:08'!drawSubmorphsOn: aCanvas	| aaLevel |	aCanvas asBalloonCanvas preserveStateDuring:[:myCanvas|		colorTransform ifNotNil:[myCanvas colorTransformBy: colorTransform].		(aaLevel _ self defaultAALevel) ifNotNil:[myCanvas aaLevel: aaLevel].		super drawSubmorphsOn: myCanvas].! !!FlashPlayerMorph methodsFor: 'drawing' stamp: 'ar 5/29/1999 09:49'!drawSubmorphsOn: aCanvas	| myCanvas |	aCanvas clipBy: self bounds during:[:tempCanvas|		myCanvas _ tempCanvas asBalloonCanvas.		myCanvas aaLevel: (self defaultAALevel ifNil:[1]).		myCanvas deferred: self deferred.		myCanvas transformBy: self transform during:[:childCanvas| 			activeMorphs reverseDo:[:m| childCanvas fullDrawMorph: m]].		myCanvas flush].! !!MouseSensorMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 00:50'!fullDrawOn: aCanvas	self installed ifFalse: [aCanvas drawMorph: self]! !!PasteUpMorph methodsFor: 'display' stamp: 'ar 5/29/1999 05:03'!drawSubmorphsOn: aCanvas	aCanvas clipBy: self innerBounds			during:[:clippedCanvas| super drawSubmorphsOn: clippedCanvas].! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/29/1999 05:03'!drawSubmorphsOn: aCanvas	aCanvas clipBy: self innerBounds			during:[:clippedCanvas| super drawSubmorphsOn: clippedCanvas].! !!PolygonMorph methodsFor: 'private' stamp: 'ar 6/17/1999 02:21'!borderForm	"A form must be created for drawing the border whenever the borderColor is translucent."	| borderCanvas |	borderForm ifNotNil: [^ borderForm].	borderCanvas _ (FormCanvas extent: bounds extent depth: 1)		setShadowDrawing; stipple: Color black.	borderCanvas translateBy: bounds topLeft negated		during:[:tempCanvas| self drawBorderOn: tempCanvas].	borderForm _ borderCanvas form.	self arrowForms do:		[:f |  "Eliminate overlap between line and arrowheads if transparent."		borderForm copy: f boundingBox from: f to: f offset - self position rule: Form erase].	^ borderForm! !!ScreeningMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 00:50'!fullDrawOn: aCanvas	| mergeForm |	submorphs size = 0 ifTrue: [^ super fullDrawOn: aCanvas].	(submorphs size = 1 or: [displayMode == #showScreenOnly]) ifTrue:		[^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showSourceOnly ifTrue:		[^ aCanvas fullDrawMorph: self sourceMorph].	displayMode == #showScreenOverSource ifTrue:		[aCanvas fullDrawMorph: self sourceMorph.		^ aCanvas fullDrawMorph: self screenMorph].	displayMode == #showScreened ifTrue:		[aCanvas fullDrawMorph: self screenMorph.		self flag: #fixCanvas. "There should be a more general way than this"		mergeForm _ self sourceMorph imageFormForRectangle: self screenMorph bounds.		(BitBlt toForm: mergeForm) copyForm: self screenForm to: 0@0 rule: Form and			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas image: mergeForm at: self screenMorph position]! !!TextContainer methodsFor: 'private' stamp: 'ar 6/17/1999 02:24'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph meOrMyDropShadow.	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: tempCanvas]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back _ tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [m fullDrawOn: tempCanvas]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!ThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/17/1999 02:25'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee diag viewedMorphBox myBox scale c shrunkForm |	super drawOn: aCanvas.	actualViewee _ self actualViewee.	actualViewee ifNil: [^ self]. 	actualViewee isInWorld		ifTrue:			[(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].			(actualViewee isKindOf: SketchMorph)				ifTrue:					[diag _ actualViewee form extent r asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds].			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.			c translateBy: viewedMorphBox topLeft negated 				"recursion happens here"				during:[:tempCanvas| actualViewee fullDrawOn: tempCanvas].			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter]! !!TransformMorph methodsFor: 'drawing' stamp: 'ar 5/29/1999 05:11'!drawSubmorphsOn: aCanvas	aCanvas transformBy: self transform			clippingTo: self innerBounds			during:[:myCanvas| super drawSubmorphsOn: myCanvas].! !!WonderlandTextureMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 00:46'!drawSubmorphsOn: aCanvas	^aCanvas clipBy: self bounds			during:[:clippingCanvas| super drawSubmorphsOn: clippingCanvas].! !!WonderlandTextureMorph methodsFor: 'private' stamp: 'ar 6/17/1999 02:26'!updateContents	"Update the texture"	| canvas |	changeFlag _ false.	(myTexture == nil or:[myTexture extent ~= self fullBounds extent]) ifTrue:[		myTexture _ B3DTexture extent: self extent depth: 32.		myTexture interpolate: false.		myTexture wrap: false.		myTexture envMode: 0.		^self].	canvas _ FormCanvas on: myTexture.	canvas translateBy: self fullBounds topLeft negated			during:[:tempCanvas| self fullDrawOn: tempCanvas].! !Canvas removeSelector: #copyOffset:!Canvas removeSelector: #setShadowDrawing!Canvas removeSelector: #copyForShadowDrawingOffset:!Canvas removeSelector: #shadowDrawing!Canvas removeSelector: #copyOrigin:clipRect:!Canvas removeSelector: #copyOffset:clipRect:!Canvas removeSelector: #setOrigin:clipRect:!Canvas removeSelector: #copyClipRect:!Morph removeSelector: #canvasForSubmorphs:!MatrixTransformMorph removeSelector: #fullDrawOn:!MatrixTransformMorph removeSelector: #canvasForSubmorphs:!FlashMorph removeSelector: #canvasForSubmorphs:!FlashPlayerMorph removeSelector: #fullDrawOn:!FlashPlayerMorph removeSelector: #canvasForSubmorphs:!PasteUpMorph removeSelector: #canvasForSubmorphs:!PianoRollScoreMorph removeSelector: #canvasForSubmorphs:!TransformMorph removeSelector: #fullDrawOn:!TransformMorph removeSelector: #canvasForSubmorphs:!WonderlandTextureMorph removeSelector: #canvasForSubmorphs:!