'From Squeak 2.3 beta of Nov 25, 1998 on 17 December 1998 at 1:45 pm'!!FormCanvas methodsFor: 'drawing' stamp: 'di 12/17/1998 12:16'!stencil: aForm at: aPoint color: aColor	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	| bb |	bb _ BitBlt destForm: port destForm		sourceForm: aForm		fillColor: aColor		combinationRule: (self drawRule: Form paint color: aColor)		destOrigin: aPoint + origin		sourceOrigin: 0@0		extent: aForm extent		clipRect: clipRect truncated.	shadowDrawing		ifTrue: [bb colorMap: (Color maskingMap: aForm depth).				bb fillColor: shadowStipple]		ifFalse: [bb colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)].	bb copyBits.! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 12/17/1998 12:32'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[^ (self filledForm pixelValueAt: aPoint - bounds topLeft + 1) > 0].	self lineSegmentsDo:		[:p1 :p2 |		(aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)				ifTrue: [^ true]].	self arrowForms do:		[:f | (f pixelValueAt: aPoint - f offset) > 0 ifTrue: [^ true]].	^ false! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 12/17/1998 12:33'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[aCanvas stencil: self filledForm at: bounds topLeft-1 color: color].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset color: borderColor]! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:31'!arrowForms	"ArrowForms are computed only upon demand"	arrowForms ifNotNil: [^ arrowForms].	arrowForms _ Array new.	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue:		[^ arrowForms].	(arrows == #forward or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices last from: self nextToLastPoint)].	(arrows == #back or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices first from: self nextToFirstPoint)].	^ arrowForms! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:25'!computeArrowFormAt: endPoint from: priorPoint	"Compute a triangle oriented along the line from priorPoint to endPoint.	Then draw those lines in a form and return that form, with appropriate offset"	| d v p1 pts box arrowForm bb origin angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	box _ ((pts first rect: pts last) encompass: (pts at: 2)) expandBy: 1.	arrowForm _ Form extent: box extent asIntegerPoint.	bb _ (BitBlt toForm: arrowForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ box topLeft.	p1 _ pts last - origin.	pts do: [:p | bb drawFrom: p1 to: p-origin.  p1 _ p-origin].	arrowForm convexShapeFill: Color black.	^ arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 13:09'!computeBounds	self changed.	self releaseCachedState.	bounds _ self curveBounds.	self arrowForms do:		[:f | bounds _ bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	self layoutChanged.	self changed! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:22'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ Form extent: bounds extent+2.	"Draw the border..."	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	"Fill it in..."	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ filledForm anyShapeFill].	^ filledForm! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:33'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms do: [:f | f offset: f offset + delta]! !!CurveMorph methodsFor: 'private' stamp: 'di 12/17/1998 13:44'!updateHandles	| midPts nextVertIx tweens newVert |	midPts _ OrderedCollection new.	nextVertIx _ 2.	tweens _ OrderedCollection new.	self lineSegmentsDo:		[:p1 :p2 | 		tweens addLast: p2 asIntegerPoint.		p2 = (vertices atWrap: nextVertIx) ifTrue:			["Found endPoint."			midPts addLast: (tweens at: tweens size // 2)						+ (tweens at: tweens size + 1 // 2) // 2.			tweens _ OrderedCollection new.			nextVertIx _ nextVertIx + 1]].	midPts withIndexDo:		[:midPt :vertIndex |		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ handles at: vertIndex*2.			newVert position: midPt - (newVert extent // 2)]].! !