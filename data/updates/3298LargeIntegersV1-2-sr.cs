'From Squeak2.9alpha of 21 November 2000 [latest update: #2998] on 29 November 2000 at 6:19:32 pm'!"Change Set:		LargeIntegersV1.2-srDate:			29 November 2000Author:			Stephan RudlofFix:	LargeIntegersPlugin>>anyBitOfBytes: aBytesOop from: start to: stopArg Minor Fix/Improvement:>>testTwoComplementRightShift:	moved it from LargePositiveInteger to Integer and corrected user messages.ToDo:(If commented out) you have to uncomment the primitive call inInteger>>anyBitOfMagnitudeFrom: start to: stopArgif you have updated the LargeIntegers module to v1.2 (or a VM with it). This is also made by fileIn the InstallLargeIntegersV1.2-sr changeset."!!LargeIntegersPlugin commentStamp: 'sr 11/29/2000 13:39' prior: 0!LargeIntegersPlugin provides functions for speeding up LargeInteger arithmetics.Inst vars:	andOpIndex			C constant	orOpIndex			C constant	xorOpIndex 			C constantUsed like an enum, in ST one would use symbols instead.Class vars:	noneEvaluations-------------Try	LargeIntegersTest getModuleName.If it is nil, you probably have an older LargeInteger module or none at all; it works for version number 'v1.1' or higher.History--------v1.2- fix: >>anyBitOfBytes: aBytesOop from: start to: stopArgv1.1- >>primGetModuleName for checking the version of the plugin;- >>primDigitBitShiftMagnitude and >>primAnyBitFrom:to: for supporting - not installing!! - unification of shift semantics of negative Integers;v1.0- speeds up digitDiv:neg: at about 20%.	In >>cCoreDigitDivDiv:len:rem:len:quo:len: the 'nibble' arithmetic is removed.!!Integer class methodsFor: 'testing' stamp: 'sr 11/29/2000 14:41'!testTwoComplementRightShift	"self testTwoComplementRightShift"	| large small |	small _ 2 << 16.	large _ 2 << 32.	"2-complement test"	(small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1)		== ((large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1))		ifFalse: [^ self inform: 'ERROR: Two-complement shifts of negative Integers are NOT consistent!!'].	(small bitShift: -1) ~= (small + 1 bitShift: -1)		== ((large bitShift: -1) ~= (large + 1 bitShift: -1))		ifFalse: [^ self inform: 'ERROR: Two-complement shifts of positive Integers are NOT consistent!!'].	^ self inform: 'OK: Two-complement shifts of small and large Integers are consistent!!'.! !!LargeIntegersPlugin methodsFor: 'util' stamp: 'sr 11/29/2000 13:41'!anyBitOfBytes: aBytesOop from: start to: stopArg 	"Argument has to be aBytesOop!!"	"Tests for any magnitude bits in the interval from start to stopArg."	| magnitude rightShift leftShift stop firstByteIx lastByteIx |	self		debugCode: [self msg: 'anyBitOfBytes: aBytesOop from: start to: stopArg'].	start < 1 | (stopArg < 1)		ifTrue: [^ interpreterProxy primitiveFail].	magnitude _ aBytesOop.	stop _ stopArg				min: (self highBitOfBytes: magnitude).	start > stop		ifTrue: [^ false].	firstByteIx _ start - 1 // 8 + 1.	lastByteIx _ stop - 1 // 8 + 1.	rightShift _ 0 - (start - 1 \\ 8).	leftShift _ 7 - (stop - 1 \\ 8).	firstByteIx = lastByteIx		ifTrue: [| digit mask | 			mask _ (255 bitShift: 0 - rightShift)						bitAnd: (255 bitShift: 0 - leftShift).			digit _ self digitOfBytes: magnitude at: firstByteIx.			^ (digit bitAnd: mask)				~= 0].	((self digitOfBytes: magnitude at: firstByteIx)			bitShift: rightShift)			~= 0		ifTrue: [^ true].	firstByteIx + 1		to: lastByteIx - 1		do: [:ix | (self digitOfBytes: magnitude at: ix)					~= 0				ifTrue: [^ true]].	(((self digitOfBytes: magnitude at: lastByteIx)			bitShift: leftShift)			bitAnd: 255)			~= 0		ifTrue: [^ true].	^ false! !!LargeIntegersPlugin class methodsFor: 'translation' stamp: 'sr 11/29/2000 13:36'!version	"Answer the receiver's version info as String."	^ 'v1.2'! !LargePositiveInteger class removeSelector: #testTwoComplementRightShift!