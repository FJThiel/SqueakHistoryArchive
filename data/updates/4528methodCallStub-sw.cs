'From Squeak3.2alpha of 3 October 2001 [latest update: #4527] on 20 November 2001 at 1:36:01 pm'!"Change Set:		methodCallStub-swDate:			20 November 2001Author:			Scott WallaceStub definition of class MethodCall, whose uses will become manifest in the fullness of time"!MessageSend subclass: #MethodCall	instanceVariableNames: 'lastValue methodInterface timeStamp '	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Kernel'!!MethodCall commentStamp: 'sw 11/20/2001 12:44' prior: 0!A MethodCall is a resendable message-send, complete with receiver, instantiated arguments, and a memory of when it was last evaluated and what the last value was.  The methodInterface with which it is associated can furnish argument names, documentation, and other information.!!MethodCall methodsFor: 'initialization' stamp: 'sw 11/20/2001 13:34'!receiver: aReceiver methodInterface: aMethodInterface	"Initialize me to have the given receiver and methodInterface"	| aResultType |	receiver _ aReceiver.	selector _ aMethodInterface selector.	methodInterface _ aMethodInterface.	arguments _ aMethodInterface defaultArguments.	self flag: #noteToTed.	"the below can't really survive, I know.  The intent is that if the method has a declared result type, we want the preferred readout type to be able to handle the initial #lastValue even if the MethodCall has not been evaluated yet; thus we'd rather have a boolean value such as true rather than a nil here if we're showing a boolean readout such as a checkbox, and likewise for color-valued and numeric-valued readouts etc, "	(aResultType _ methodInterface resultType) ~~ #unknown ifTrue:		[lastValue _ (Vocabulary vocabularyForType: aResultType) initialValueForASlotFor: aReceiver]        ! !!MethodCall methodsFor: 'initialization' stamp: 'sw 10/3/2001 15:28'!receiver: aReceiver methodInterface: aMethodInterface initialArguments: initialArguments	"Set up a method-call for the given receiver, method-interface, and initial arguments"	receiver _ aReceiver.	selector _ aMethodInterface selector.	methodInterface _ aMethodInterface.	arguments _ initialArguments ifNotNil: [initialArguments asArray]! !!MethodCall methodsFor: 'initialization' stamp: 'sw 11/20/2001 12:16'!valueOfArgumentNamed: aName	"Answer the value of the given arguement variable"	| anIndex |	anIndex _ self methodInterface argumentVariables findFirst:		[:aVariable | aVariable variableName = aName].	^ anIndex > 0		ifTrue:			[arguments at: anIndex]		ifFalse:			[self error: 'variable not found']! !!MethodCall methodsFor: 'argument access' stamp: 'sw 11/20/2001 12:16'!setArgumentNamed: aName toValue: aValue	"Set the argument of the given name to the given value"	| anIndex |	anIndex _ self methodInterface argumentVariables findFirst:		[:aVariable | aVariable variableName = aName].	anIndex > 0		ifTrue:			[arguments at: anIndex put: aValue]		ifFalse:			[self error: 'argument missing'].	self changed: #argumentValue! !!MethodCall methodsFor: 'evaluation' stamp: 'sw 11/20/2001 12:15'!evaluate	"Evaluate the receiver, and if value has changed, signal value-changed"	| result |	result _ arguments isEmptyOrNil		ifTrue: [self receiver perform: selector]		ifFalse: [self receiver perform: selector withArguments: arguments asArray].	timeStamp _ Time dateAndTimeNow.	result ~= lastValue ifTrue:		[lastValue _ result.		self changed: #value]	! !!MethodCall methodsFor: 'evaluation' stamp: 'sw 11/20/2001 12:21'!everEvaluated	"Answer whether this method call has ever been evaluated"	^ timeStamp notNil! !!MethodCall methodsFor: 'evaluation' stamp: 'sw 11/20/2001 13:31'!lastValue	"Answer the last value I remember obtaining from an evaluation"	^ lastValue! !!MethodCall methodsFor: 'method interface' stamp: 'sw 11/20/2001 13:31'!ephemeralMethodInterface	"Answer a methodInterface for me.  If I have one stored, answer it; if not, conjure up an interface and answer it but do NOT store it internally.  You can call this directly if you need a method interface for me but do not want any conjured-up interface to persist."	^ methodInterface ifNil: 		[MethodInterface new conjuredUpFor: selector class: (self receiver class classThatUnderstands: selector)]! !!MethodCall methodsFor: 'method interface' stamp: 'sw 11/20/2001 12:43'!methodInterface	"Answer the receiver's methodInterface, conjuring one up on the spot (and remembering) if not present"	^ methodInterface ifNil:		[methodInterface _ self ephemeralMethodInterface]! !!MethodCall methodsFor: 'method interface' stamp: 'sw 11/20/2001 12:39'!methodInterface: anInterface	"Set my methodInterface"	methodInterface _ anInterface! !!MethodCall methodsFor: 'method interface' stamp: 'sw 11/20/2001 12:40'!methodInterfaceOrNil	"Answer my methodInterface, whether it is nil or not"	^ methodInterface! !