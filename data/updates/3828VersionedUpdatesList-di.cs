'From Squeak3.1alpha of 28 February 2001 [latest update: #3760] on 14 March 2001 at 3:34:56 pm'!"Change Set:		VersionedUpdatesListDate:			14 March 2001Author:			Dan IngallsSaves the prior version of 'updates.list' when writing a new version to the update server."!!ServerDirectory methodsFor: 'do ftp' stamp: 'di 3/14/2001 15:34'!putFileSavingOldVersion: fileStream named: fileNameOnServer	| tempName oldName |	"Put a copy of this file out after saving the prior version.	Nothing happens to the old version until the new vers is successfully stored." 	tempName _ fileNameOnServer , '.beingWritten'.	oldName _ fileNameOnServer , '.prior'.	self putFile: fileStream named: tempName retry: true.	(self includesKey: oldName) ifTrue: [self deleteFileNamed: oldName].	self rename: fileNameOnServer toBe: oldName.	self rename: tempName toBe: fileNameOnServer.! !!ServerDirectory methodsFor: 'updates' stamp: 'di 3/14/2001 15:05'!putUpdate: fileStrm 	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:."	| myServers updateStrm sequence newName myName response local restOfText seq fileContents |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	fileStrm size = 0		ifTrue: [^ self inform: 'That file has zero bytes!!  May have a new name.'].	fileContents _ fileStrm contentsOfEntireFile.	(fileContents includes: Character linefeed)		ifTrue: [self notify: 'That file contains linefeeds.Proceed if you know that this is okay (e.g. the file contains raw binary data).'].	fileStrm reset.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"illegal characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	sequence _ Utilities lastUpdateNum: updateStrm.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil].	"abort"		sequence _ Utilities olderVersNum: restOfText from: updateStrm default: sequence.		].	"get last number and add 1"	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do:		[:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFileSavingOldVersion: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.! !!ServerDirectory methodsFor: 'updates' stamp: 'di 3/14/2001 15:05'!putUpdateMulti: list fromDirectory: updateDirectory 	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm lastNum myName response restOfText newNames file numStr insertion |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	(myServers _ self checkServers) size = 0 ifTrue: [self closeGroup.  ^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	lastNum _ Utilities lastUpdateNum: updateStrm.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil	"abort"].		numStr _ FillInTheBlank 			request: 'Please confirm or change the starting update number' 			initialAnswer: (lastNum+1) printString.		lastNum _ numStr asNumber - 1].	newNames _ list with: (lastNum+1 to: lastNum+list size) collect:		[:each :num | (num printString padded: #left to: 4 with: $0) , each].	insertion _ String streamContents:		[:s | newNames do: [:n | s nextPutAll: n; cr]].	"append name to updates"	(updateStrm skip: -1; next) = Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: insertion; nextPutAll: restOfText.	myServers do:		[:aServer |		list doWithIndex: [:local :ind |			file _ updateDirectory oldFileNamed: local.			aServer putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		aServer putFileSavingOldVersion: updateStrm named: 'updates.list'.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].	self closeGroup.		Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally"	list with: newNames do:		[:local :newName | updateDirectory rename: local toBe: newName].! !!ServerDirectory methodsFor: 'updates' stamp: 'di 3/14/2001 15:05'!updateInstallVersion: newVersion	"For each server group, ask whether we want to put the new version marker (#Squeak2.3) at the end of the file.  Current version of Squeak must be the old one when this is done.	ServerDirectory new updateInstallVersion: 'Squeak2.3'      "	| myServers updateStrm names choice |[names _ ServerDirectory groupNames asSortedArray.choice _ (SelectionMenu labelList: names selections: names) startUp.choice == nil] whileFalse: [	myServers _ (ServerDirectory groupNamed: choice) checkServers.	myServers size = 0 ifTrue: [self inform: 'checkServers failed on one of those'].	updateStrm _ myServers first getFileNamed: 'updates.list'.	Utilities position: updateStrm 	"checks for current OLD version"			atVersion: (Smalltalk at: #EToySystem) version.			"append name to updates"	updateStrm setToEnd.	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: '#', newVersion; nextPut: Character cr.	myServers do:		[:aServer | updateStrm reset.		aServer putFileSavingOldVersion: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update.list written on server ', aServer moniker].			]! !