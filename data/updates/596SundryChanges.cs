'From Squeak 2.3 of January 14, 1999 on 15 January 1999 at 1:12:11 am'!"Change Set:		SundryChangesDate:			14 January 1999Author:			Dan IngallsFixes a problem with ChangeList selection.Fixes a failure of FileLists to sort by size.Makes Color transparent print nicely.Adds some protection to Contexts.Makes inspectors update regardless of how big the printString is.Fixes a performace bug in comparing long texts.Fixes multiple selection in morphic."!!BlockContext methodsFor: 'private' stamp: 'di 1/14/1999 22:28'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!BlockContext class methodsFor: 'as yet unclassified' stamp: 'di 1/14/1999 22:05'!basicNew: frameSize	frameSize = CompiledMethod fullFrameSize		ifFalse: [self error: 'All contexts must be the same size'].	^ super basicNew: CompiledMethod fullFrameSize! !!ChangeList methodsFor: 'viewing access' stamp: 'di 1/15/1999 01:12'!toggleListIndex: newListIndex	listIndex ~= 0 ifTrue: [listSelections at: listIndex put: false].	newListIndex ~= 0 ifTrue: [listSelections at: newListIndex put: true].	listIndex _ newListIndex.	self changed: #listIndex.	self changed: #contents! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 1/14/1999 21:25'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles sortBlock |	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	"create block to decide what order to display the entries"	sortBlock _ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x fileSize = y fileSize 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ].	newList _ (SortedCollection new: 30) sortBlock: sortBlock.	allFiles _ pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: entry]].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray.! !!Inspector methodsFor: 'accessing' stamp: 'di 1/14/1999 22:45'!step	"Continuously update the value of the selected item"	| newText |	newText _ self contentsIsString		ifTrue: [self selection]		ifFalse: [self selection printString].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!MethodContext methodsFor: 'private' stamp: 'di 1/14/1999 22:30'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!MethodContext class methodsFor: 'instance creation' stamp: 'di 1/14/1999 22:06'!basicNew: frameSize	frameSize = CompiledMethod fullFrameSize		ifFalse: [self error: 'All contexts must be the same size'].	^ super basicNew: CompiledMethod fullFrameSize! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 1/15/1999 01:03'!mouseDown: event onItem: aMorph	| index oldIndex oldVal |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane border drag"].	"Set meaning for subsequent dragging of selection"	dragOnOrOff _ (model listSelectionAt: index) not.	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ model listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [model listSelectionAt: oldIndex put: oldVal].	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'di 1/15/1999 00:49'!mouseEnterDragging: event onItem: aMorph	| index oldIndex oldVal |	dragOnOrOff ifNil: [^ self "spurious drag did not start with mouseDown"].	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ model listSelectionAt: oldIndex].	index _ scroller submorphs indexOf: aMorph.	dragOnOrOff ifTrue: [self setSelectedMorph: aMorph].	oldIndex ~= 0 ifTrue: [model listSelectionAt: oldIndex put: oldVal].	"Extend the selection with the current state of dragOnOrOff"	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!SequenceableCollection methodsFor: 'comparing' stamp: 'di 1/15/1999 00:03'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's size, and each of the receiver's elements equal the corresponding element of otherCollection.  This should probably replace the current definition of = ."	| size |	(size _ self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index | (self at: index) = (otherCollection at: index) ifFalse: [^false]].	^true! !!RunArray methodsFor: 'accessing' stamp: 'di 1/15/1999 00:04'!= otherArray 	"Test if all my elements are equal to those of otherArray"	(otherArray isMemberOf: RunArray) ifFalse: [^ self hasEqualElements: otherArray].	"Faster test between two RunArrays" 	^ (runs hasEqualElements: otherArray runs)		and: [values hasEqualElements: otherArray values]! !!TranslucentColor methodsFor: 'printing' stamp: 'di 1/14/1999 14:31'!storeOn: aStream	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !