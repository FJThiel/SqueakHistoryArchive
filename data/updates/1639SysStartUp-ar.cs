'From Squeak2.6 of 13 October 1999 [latest update: #1637] on 24 November 1999 at 1:10:58 am'!"Change Set:		SysStartUp-arDate:			19 November 1999Author:			Andreas RaabModifies the startUp/shutDown notification from SystemDictionary to take an additional parameter (indicating whether the system is about to quit in #shutDown: or whether the system came up on a new platform in #startUp:). Also provides default implementations in class Behavior (avoids nasty start problems when one misspells #startUp or #shutDown)."!!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!shutDown	"This message is sent on system shutdown to registered classes"! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!shutDown: quitting	"This message is sent on system shutdown to registered classes"	^self shutDown.! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!startUp	"This message is sent to registered classes when the system is coming up."! !!Behavior methodsFor: 'system startup' stamp: 'ar 11/16/1999 20:15'!startUp: resuming	"This message is sent to registered classes when the system is coming up."	^self startUp! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/19/1999 22:36'!add: aClass toList: startUpOrShutDownList after: predecessor	"Add the name of aClass to the startUp or shutDown list.	Add it after the name of predecessor, or at the end if predecessor is nil."	| name earlierName |	name _ aClass name.	(self at: name ifAbsent: [nil]) == aClass ifFalse:		[self error: name , ' cannot be found in Smalltalk dictionary.'].	predecessor == nil		ifTrue: ["No-op if alredy in the list."				(startUpOrShutDownList includes: name) ifFalse:					[startUpOrShutDownList == StartUpList						ifTrue: ["Add to end of startUp list"								startUpOrShutDownList addLast: name]						ifFalse: ["Add to front of shutDown list"								startUpOrShutDownList addFirst: name]]]		ifFalse: ["Add after predecessor, moving it if already there."				earlierName _ predecessor name.				(self at: earlierName) == predecessor ifFalse:					[self error: earlierName , ' cannot be found in Smalltalk dictionary.'].				(startUpOrShutDownList includes: earlierName) ifFalse:					[self error: earlierName , ' cannot be found in the list.'].				startUpOrShutDownList remove: name ifAbsent:[].				startUpOrShutDownList add: name after: earlierName]! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/16/1999 20:12'!processShutDownList: quitting	"Send #shutDown to each class that needs to wrap up before a snapshot."	self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/16/1999 20:12'!processStartUpList: resuming	"Send #startUp to each class that needs to run initialization after a snapshot."	self send: #startUp: toClassesNamedIn: StartUpList with: resuming.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/16/1999 20:18'!send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument	"Send the message #startUp: or #shutDown: to each class named in the list.	The argument indicates if the system is about to quit (for #startUp:) or if	the image is resuming (for #startUp:).	If any name cannot be found, then remove it from the list."	| removals class |	removals _ OrderedCollection new.	startUpOrShutDownList do:		[:name |		class _ self at: name ifAbsent: [nil].		class == nil			ifTrue: [removals add: name]			ifFalse: [class perform: startUpOrShutDown with: argument]].	"Remove any obsolete entries, but after the iteration"	startUpOrShutDownList removeAll: removals! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/16/1999 20:16'!snapshot: save andQuit: quit	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString.		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		self assureStartupStampLogged.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming _ self snapshotPrimitive.  "<-- PC frozen here on image file"				resuming ifFalse:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming _ false].	quit & resuming not ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming ifTrue: [self clearExternalObjects].	self processStartUpList: resuming.	resuming ifTrue: [self readDocumentFile].	^resuming! !!SystemTracer class methodsFor: 'instance creation' stamp: 'ar 11/16/1999 20:17'!writeClone  "SystemTracer writeClone"	| tracer |	tracer _ self new.	"Delay shutDown."  "part of Smalltalk processShutDownList."	tracer doit.   " <-- execution in clone resumes after this send"	tracer == nil "will be nil in clone, since it is clamped"		ifTrue: [Smalltalk processStartUpList: true].	^ tracer! !!Transcripter class methodsFor: 'instance creation' stamp: 'ar 11/16/1999 20:16'!startTranscriptProcess   "Transcripter startTranscriptProcess"	| activeProcess |	Transcript _ self newInFrame: Display boundingBox.	activeProcess _ [Transcript readEvalPrint.					Smalltalk processShutDownList: true; quitPrimitive]						newProcess					priority: Processor userSchedulingPriority.	activeProcess resume.	Processor terminateActive! !SystemDictionary removeSelector: #processShutDownList!SystemDictionary removeSelector: #processStartUpList!SystemDictionary removeSelector: #send:toClassesNamedIn:!