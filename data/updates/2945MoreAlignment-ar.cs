'From Squeak2.9alpha of 13 June 2000 [latest update: #2994] on 10 November 2000 at 3:51:11 pm'!"Change Set:		MoreAlignment-arDate:			10 November 2000Author:			Andreas RaabMore alignment related stuff, in particular aiming at AlignmentMorphBob1 and its uses."!!FancyCelesteComposition methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 15:46'!openInMorphic	"open an interface for sending a mail message with the given initial 	text "	| buttonsList container toField subjectField |	buttonsList _ self newRow.	buttonsList wrapCentering: #center; cellPositioning: #leftCenter.	buttonsList		addMorphBack: (			(self 				buttonWithAction: #submit				label: 'send later'				help: 'add this to the queue of messages to be sent')		);		addMorphBack: (			(self 				buttonWithAction: #sendNow				label: 'send now'				help: 'send this message immediately')		);		addMorphBack: (			(self 				buttonWithAction: #forgetIt				label: 'forget it'				help: 'forget about sending this message')		).	morphicWindow _ container _ AlignmentMorphBob1 new		borderWidth: 8;		borderColor: self borderAndButtonColor;		color: Color white.	container 		addMorphBack: (buttonsList vResizing: #shrinkWrap; minHeight: 25; yourself);		addMorphBack: ((self simpleString: 'To:') vResizing: #shrinkWrap; minHeight: 18; yourself);		addMorphBack: ((toField _ PluggableTextMorph			on: self			text: #to			accept: #to:) hResizing: #spaceFill; vResizing: #rigid; height: 50; yourself		);		addMorphBack: ((self simpleString: 'Subject:') vResizing: #shrinkWrap; minHeight: 18; yourself);		addMorphBack: ((subjectField _ PluggableTextMorph			on: self			text: #subject			accept: #subject:) hResizing: #spaceFill; vResizing: #rigid; height: 50; yourself		);		addMorphBack: ((self simpleString: 'Message:') vResizing: #shrinkWrap; minHeight: 18; yourself);		addMorphBack: ((textEditor _ PluggableTextMorph			on: self			text: #messageText			accept: #messageText:) hResizing: #spaceFill; vResizing: #spaceFill; yourself		).	textFields _ {toField. subjectField. textEditor}.	container 		extent: 300@400;		openInWorld.! !!Morph methodsFor: 'layout' stamp: 'ar 11/10/2000 14:55'!minExtent	"Layout specific. Return the minimum size the receiver can be represented in.	Implementation note: When this message is sent from an owner trying to lay out its children it will traverse down the morph tree and recompute the minimal arrangement of the morphs based on which the minimal extent is returned. When a morph with some layout strategy is encountered, the morph will ask its strategy to compute the new arrangement. However, since the final size given to the receiver is unknown at the point of the query, the assumption is made that the current bounds of the receiver are the base on which the layout should be computed. This scheme prevents strange layout changes when for instance, a table is contained in another table. Unless the inner table has been resized manually (which means its bounds are already enlarged) the arrangement of the inner table will not change here. Thus the entire layout computation is basically an iterative process which may have different results depending on the incremental changes applied."	| layout minExtent extra |self flag: #arNote. "take a clipping receiver into account..."	"optimize for #rigid receiver (doesn't require layout computation)"	(self hResizing == #rigid and:[self vResizing == #rigid]) 		ifTrue:[^self fullBounds extent].	layout _ self layoutPolicy.	layout == nil		ifTrue:[minExtent _ 0@0]		ifFalse:[minExtent _ layout minExtentOf: self in: self layoutBounds].	self hResizing == #rigid		ifTrue:[	minExtent _ self fullBounds extent x @ minExtent y]		ifFalse:[	extra _ self bounds width - self layoutBounds width.				minExtent _ (minExtent x + extra) @ minExtent y].	self vResizing == #rigid		ifTrue:[minExtent _ minExtent x @ self fullBounds extent y]		ifFalse:[extra _ self bounds height - self layoutBounds height.				minExtent _ minExtent x @ (minExtent y + extra)].	minExtent _ minExtent max: (self minWidth@self minHeight).	^minExtent! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/10/2000 14:39'!spaceFillWeight	"Layout specific. This property describes the relative weight that should be given to the receiver when extra space is distributed between different #spaceFill cells."	extension == nil ifTrue:[^1]. "get out quickly"	^self valueOfProperty: #spaceFillWeight ifAbsent:[1]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/10/2000 14:38'!spaceFillWeight: aNumber	"Layout specific. This property describes the relative weight that should be given to the receiver when extra space is distributed between different #spaceFill cells."	aNumber = 1		ifTrue:[self removeProperty: #spaceFillWeight]		ifFalse:[self setProperty: #spaceFillWeight toValue: aNumber].	self layoutChanged.! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 15:18'!initialize	super initialize.	self listDirection: #topToBottom.	self layoutInset: 0.	borderWidth _ 0.	self hResizing: #rigid. "... this is very unlikely..."	self vResizing: #rigid.! !!AlignmentMorphBob1 methodsFor: 'object fileIn' stamp: 'ar 11/10/2000 15:51'!convertbosfcebbhmm0: varDict bosfcebb0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('heights' 'minWidth' 'minHeight').  Possibly store their info in another variable?"! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 15:30'!initialize	super initialize.	acceptOnCR _ true.	self listDirection: #topToBottom.	color _ Color paleYellow.	self layoutInset: 0.	borderColor _ self standardBorderColor.	borderWidth _ 8.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self rubberBandCells: false.	self minWidth: 200.	self minHeight: 200.	bounds _ 400@100 extent:  200@150.	self rebuild.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 15:17'!rebuild	| r1 r2 |	r1 _ self addARow: {		self simpleToggleButtonFor: self attribute: #acceptOnCR help: 'Send with Return?'.		self inAColumn: {StringMorph new contents: 'Your message to:'; lock}.		self textEntryFieldNamed: #ipAddress with: ''					help: 'IP address for chat partner'.	}.	recipientForm ifNotNil: [		r1 addMorphBack: recipientForm asMorph lock	].	sendingPane _ PluggableTextMorph				on: self				text: nil				accept: #acceptTo:forMorph:.	sendingPane hResizing: #spaceFill; vResizing: #spaceFill.	self		addMorphBack: sendingPane.	r2 _ self addARow: {self inAColumn: {StringMorph new contents: 'Replies'; lock}}.	receivingPane _ PluggableTextMorph				on: self				text: nil				accept: nil.	receivingPane hResizing: #spaceFill; vResizing: #spaceFill.	self		addMorphBack: receivingPane.	receivingPane spaceFillWeight: 3.	{r1. r2} do: [ :each |		each			vResizing: #shrinkWrap; minHeight: 18;			color: Color veryLightGray.	].	sendingPane acceptOnCR: (acceptOnCR ifNil: [acceptOnCR _ true])! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 15:20'!rebuild	| r1 r2 |	r1 _ self addARow: {		self simpleToggleButtonFor: self attribute: #acceptOnCR help: 'Send with Return?'.		self inAColumn: {StringMorph new contents: 'Multi chat with:'; lock}.		self textEntryFieldNamed: #ipAddress with: ''					help: 'Click to edit participant list'.	}.	sendingPane _ PluggableTextMorph				on: self				text: nil				accept: #acceptTo:forMorph:.	sendingPane hResizing: #spaceFill; vResizing: #spaceFill.	self		addMorphBack: sendingPane.	r2 _ self addARow: {self inAColumn: {StringMorph new contents: 'Replies'; lock}}.	receivingPane _ PluggableTextMorph				on: self				text: nil				accept: nil.	receivingPane hResizing: #spaceFill; vResizing: #spaceFill.	self		addMorphBack: receivingPane.	receivingPane spaceFillWeight: 3.	{r1. r2} do: [ :each |		each			vResizing: #shrinkWrap; minHeight: 18;			color: Color veryLightGray.	].	self updateIPAddressField: targetIPAddresses.	sendingPane acceptOnCR: (acceptOnCR ifNil: [acceptOnCR _ true]).! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 14:23'!killExistingChat	| oldOne |	self rubberBandCells: true. "disable growing"	(oldOne _ self valueOfProperty: #embeddedChatHolder) ifNotNil: [		oldOne delete.		self removeProperty: #embeddedChatHolder	].	(oldOne _ self valueOfProperty: #embeddedAudioChatHolder) ifNotNil: [		oldOne delete.		self removeProperty: #embeddedAudioChatHolder	].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/10/2000 15:10'!startChat: toggleMode	| chat r |	(self valueOfProperty: #embeddedChatHolder) ifNotNil: [		toggleMode ifFalse: [^self].		^self killExistingChat	].	(EToyChatMorph doChatsInternalToBadge and: 				[(self ownerThatIsA: EToyFridgeMorph) isNil]) ifTrue: [		chat _ EToyChatMorph basicNew			recipientForm: userPicture; 			initialize;			setIPAddress: self ipAddress.		chat			vResizing: #spaceFill;			hResizing: #spaceFill;			borderWidth: 2;			insetTheScrollbars.		r _ (self addARow: {chat}) vResizing: #spaceFill.		self rubberBandCells: false. "enable growing"		self height: 350. "an estimated guess for allowing shrinking as well as growing"		self world startSteppingSubmorphsOf: chat.		self setProperty: #embeddedChatHolder toValue: r.	] ifFalse: [		chat _ EToyChatMorph 			chatWindowForIP: self ipAddress			name: self userName 			picture: userPicture 			inWorld: self world.		chat owner addMorphFront: chat.	]! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 11/10/2000 15:23'!installAsActiveSubprojectIn: enclosingWorld at: newBounds titled: aString	| window howToOpen tm boundsForWorld |	howToOpen _ self embeddedProjectDisplayMode.					"#scaled may be the only one that works at the moment"	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	boundsForWorld _ howToOpen == #naked ifTrue: [newBounds] ifFalse: [bounds].	worldState canvas: nil.	worldState viewBox: boundsForWorld.	self bounds: boundsForWorld.	"self viewBox: Display boundingBox."	"worldState handsDo: [:h | h initForEvents]."	self installFlaps.	"SystemWindow noteTopWindowIn: self."	"self displayWorldSafely."	howToOpen == #naked ifTrue: [		enclosingWorld addMorphFront: self.	].	howToOpen == #window ifTrue: [		window _ (NewWorldWindow labelled: aString) model: self.		window addMorph: self frame: (0@0 extent: 1.0@1.0).		window openInWorld: enclosingWorld.	].	howToOpen == #frame ifTrue: [		window _ AlignmentMorphBob1 new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			bounds: newBounds.		window addMorph: self.		window openInWorld: enclosingWorld.	].	howToOpen == #scaled ifTrue: [		self position: 0@0.		window _ EmbeddedWorldBorderMorph new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			bounds: newBounds.		tm _ BOBTransformationMorph new.		window addMorph: tm.		tm addMorph: self.		window openInWorld: enclosingWorld.		tm changeWorldBoundsToShow: bounds.		self arrangeToStartSteppingIn: enclosingWorld.		"tm scale: (tm width / self width min: tm height / self height) asFloat."	].! !!ScrollPane methodsFor: 'scrolling' stamp: 'ar 11/10/2000 12:46'!isScrollbarShowing	"Return true if a retractable scroll bar is currently showing"	retractableScrollBar ifFalse:[^true].	^submorphs includes: scrollBar! !!TableLayout methodsFor: 'layout' stamp: 'ar 11/10/2000 15:21'!computeExtraSpacing: arrangement in: newBounds horizontal: aBool target: aMorph	"Compute the required extra spacing for laying out the cells"	| extent extra centering n extraPerCell cell last hFill vFill max amount allow |	"match newBounds extent with arrangement's orientation"	extent _ newBounds extent.	aBool ifFalse:[extent _ extent transposed].	"figure out if we have any horizontal or vertical space fillers"	hFill _ vFill _ false.	max _ 0@0.	arrangement do:[:c|		max _ (max x max: c cellSize x) @ (max y + c cellSize y).		max _ max max: c cellSize.		hFill _ hFill or:[c hSpaceFill].		vFill _ vFill or:[c vSpaceFill]].	"Take client's shrink wrap constraints into account.	Note: these are only honored when there are no #spaceFill children,	or when #rubberBandCells is set."	allow _ aMorph rubberBandCells not.	aMorph hResizing == #shrinkWrap ifTrue:[		aBool 			ifTrue:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifFalse:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	aMorph vResizing == #shrinkWrap ifTrue:[		aBool 			ifFalse:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifTrue:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	"Now compute the extra v space"	extra _ extent y - (arrangement inject: 0 into:[:sum :c| sum + c cellSize y]).	extra > 0 ifTrue:[		"Check if we have any #spaceFillers"		vFill ifTrue:[ "use only #spaceFillers"			n _ arrangement inject: 0 into:[:sum :c| 				c vSpaceFill ifTrue:[sum + 1] ifFalse:[sum]].			n isZero ifFalse:[extraPerCell _ extra asFloat / n asFloat].			extra _ last _ 0.			arrangement do:[:c|				c vSpaceFill ifTrue:[					extra _ (last _ extra) + extraPerCell.					amount _ 0 @ (extra truncated - last truncated).					c do:[:cc| cc cellSize: cc cellSize + amount]]].		] ifFalse:[ "no #spaceFillers; distribute regularly"			centering _ aMorph wrapCentering.			"centering == #topLeft ifTrue:[]." "add all extra space to the last cell; e.g., do nothing"			centering == #bottomRight "add all extra space to the first cell"				ifTrue:[arrangement first addExtraSpace: 0@extra].			centering == #center "add 1/2 extra space to the first and last cell"				ifTrue:[arrangement first addExtraSpace: 0@ (extra // 2)].			centering == #justified "add extra space equally distributed to each cell"				ifTrue:[	n _ (arrangement size - 1) max: 1.						extraPerCell _ extra asFloat / n asFloat.						extra _ last _ 0.						arrangement do:[:c|							c addExtraSpace: 0@(extra truncated - last truncated).							extra _ (last _ extra) + extraPerCell]].		].	].	"Now compute the extra space for the primary direction"	centering _ aMorph listCentering.	1 to: arrangement size do:[:i|		cell _ (arrangement at: i).		extra _ extent x - cell cellSize x.		extra > 0 ifTrue:[			"Check if we have any #spaceFillers"			cell hSpaceFill ifTrue:[ "use only #spaceFillers"				cell _ cell nextCell.				n _ cell inject: 0 into:[:sum :c| 					c hSpaceFill ifTrue:[sum + c target spaceFillWeight] ifFalse:[sum]].				n isZero ifFalse:[extraPerCell _ extra asFloat / n asFloat].				extra _ last _ 0.				cell do:[:c|					c hSpaceFill ifTrue:[						extra _ (last _ extra) + (extraPerCell * c target spaceFillWeight).						amount _ extra truncated - last truncated.						c cellSize: c cellSize + (amount@0)]].			] ifFalse:[ "no #spaceFiller; distribute regularly"				cell _ cell nextCell.				"centering == #topLeft ifTrue:[]" "add all extra space to the last cell; e.g., do nothing"				centering == #bottomRight "add all extra space to the first cell"					ifTrue:[cell addExtraSpace: extra @ 0].				centering == #center "add 1/2 extra space to the first and last cell"					ifTrue:[cell addExtraSpace: (extra // 2) @ 0].				centering == #justified "add extra space equally distributed to each cell"					ifTrue:[	n _ (cell size - 1) max: 1.							extraPerCell _ extra asFloat / n asFloat.							extra _ last _ 0.							cell do:[:c|								c addExtraSpace: (extra truncated - last truncated) @ 0.								extra _ (last _ extra) + extraPerCell]].			].		].	].! !ScrollPane removeSelector: #minExtent!ScrollPane removeSelector: #minHeight!AlignmentMorphBob1 removeSelector: #heights:!AlignmentMorphBob1 removeSelector: #minHeight:!AlignmentMorphBob1 removeSelector: #minWidth:!AlignmentMorph subclass: #AlignmentMorphBob1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!