'From Squeak2.9alpha of 13 June 2000 [latest update: #2838] on 10 October 2000 at 3:32:27 pm'!"Change Set:		SevenOfScottDate:			10 October 2000Author:			Andreas RaabThe next seven items from Scott's bug list. Resistance is futile. All bugs will be assimilated."!!HaloMorph methodsFor: 'events' stamp: 'ar 10/10/2000 15:04'!popUpFor: aMorph event: evt	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| tfm hand inTransfer anEvent |	self flag: #arNote.	self flag: #workAround. "We really need an event here to trigger drags etc. but too many senders still use the obsolete #addHalo so we'll make a less than educated guess if the event is nil."	evt isNil		ifTrue:[	hand _ aMorph world activeHand.				hand ifNil:[hand _ aMorph world primaryHand].				anEvent _ hand lastEvent]		 ifFalse:[hand _ evt hand.				anEvent _ evt].	self target: aMorph.	self flag: #workAround.	"Distinguish between putting up a new halo (e.g., from a click on aMorph) and transferring the halo. See the comment in HaloMorph>>transferHalo: for an explanation."	inTransfer _ hand halo notNil and:[hand halo hasProperty: #haloTransfer].	hand halo: self.	hand world addMorphFront: self.	positionOffset _ anEvent position - aMorph position.	self startStepping.	"wait for drags or ignore"	tfm _ (aMorph transformedFrom: nil) inverseTransformation.	self flag: #workAround. "Don't allow dragging if no event. The issuing event might be completely different from what we think it really is."	(evt isNil or:[inTransfer]) ifFalse:[		hand newMouseFocus: self. "Necessary or else we won't get #mouseMove..."		hand 			waitForClicksOrDrag: self 			event: (anEvent transformedBy: tfm)			selectors: { nil. nil. #startDragTarget:. }			threshold: 5.	].! !!HaloMorph methodsFor: 'stepping' stamp: 'ar 10/10/2000 15:17'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ self localHaloBoundsFor: target renderedMorph].	newBounds = self bounds ifTrue: [^ self].	newBounds extent = self bounds extent ifTrue:[^self position: newBounds origin].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!MenuMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/10/2000 15:30'!justDroppedInto: aMorph event: evt	| halo |	super justDroppedInto: aMorph event: evt.	halo _ evt hand halo.	(halo notNil and:[halo target hasOwner: self]) ifTrue:[		"Grabbed single menu item"		self addHalo.		self flag: #arNote. "Make an extra 'possible drag transition' in halo morph and use event here but without dragging invokation."	].! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/10/2000 15:22'!handlesKeyboard: evt	^self isWorldMorph or:[evt keyCharacter == Character tab and:[self hasProperty: #tabAmongFields]]! !!SelectionMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 15:10'!hasHalo: aBool	super hasHalo: aBool.	aBool ifFalse:[self delete].! !!SelectionMorph methodsFor: 'drag and drop' stamp: 'ar 10/10/2000 15:02'!aboutToBeGrabbedBy: aHand	slippage _ 0@0.	^ super aboutToBeGrabbedBy: aHand! !!SelectionMorph methodsFor: 'drag and drop' stamp: 'ar 10/10/2000 15:01'!justDroppedInto: newOwner event: evt	selectedItems isEmpty ifTrue:		["Hand just clicked down to draw out a new selection"		^ self extendByHand: evt hand].	dupLoc ifNotNil: [dupDelta _ self position - dupLoc].	selectedItems reverseDo: [:m | newOwner addMorphFront: m].	^ super justDroppedInto: newOwner event: evt! !!SimpleButtonMorph methodsFor: 'events' stamp: 'ar 10/10/2000 15:24'!mouseDown: evt	| now dt w |	now _ Time millisecondClockValue.	oldColor _ color. 	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [	self updateVisualState: evt; refreshWorld].	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	(actWhen == #whilePressed) ifTrue:[		self setProperty: #doesButtonAction toValue: true.		w _ self world.		w ifNotNil:[w startStepping: self]].! !!TextMorph methodsFor: 'editing' stamp: 'ar 10/10/2000 15:22'!handleKeystroke: anEvent	"System level event handling."	| pasteUp |	anEvent wasHandled ifTrue:[^self].	(self handlesKeyboard: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	anEvent keyCharacter = Character tab ifTrue:[		"Allow passing through text morph inside pasteups"		pasteUp _ self pasteUpMorph.		(self wouldAcceptKeyboardFocusUponTab  and:[pasteUp hasProperty: #tabAmongFields])			ifTrue:[^ pasteUp tabHitWithEvent: anEvent]].	^self keyStroke: anEvent! !