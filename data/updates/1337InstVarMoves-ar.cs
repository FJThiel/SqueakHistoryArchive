'From Squeak 2.4b of April 23, 1999 on 20 July 1999 at 12:34:58 pm'!"Change Set:		InstVarMoves-arDate:			20 July 1999Author:			Andreas RaabThis change set provides the ability to move instance variables of a living class to another class while keeping its value."!Object subclass: #ClassBuilder	instanceVariableNames: 'environ classMap instVarMap progress maxClassIndex currentClassIndex '	classVariableNames: 'QuietMode '	poolDictionaries: ''	category: 'Kernel-Classes'!!Behavior methodsFor: 'initialize-release' stamp: 'ar 7/19/1999 23:00'!forgetDoIts	"get rid of old DoIt methods"	self 		removeSelectorSimply: #DoIt;		removeSelectorSimply: #DoItIn:! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 7/19/1999 23:29'!initialize	environ _ Smalltalk.	instVarMap _ IdentityDictionary new.! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/19/1999 23:27'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category	"Define a new class in the given environment"	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	(self validateClassName: className) ifFalse:[^nil].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	"Run validation checks so we know that we have a good chance for recompilation"	(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].	(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].	(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].	(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass.	newClass == nil ifTrue:[^nil]. "Some error"	newClass setName: className.	"Export the new class into the environment.	Note: It is absolutely necessary to remove any outdated association first,	since these are used to indicate the method class and any older class	with sends to super might go nuts over the changed class."	(environ at: className ifAbsent:[nil]) == newClass ifFalse:[		environ removeKey: className ifAbsent:[].		environ declare: className from: Undeclared.		environ at: newClass name put: newClass.	]. "So far, so good."	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	"... record any new class ..."	oldClass == nil ifTrue:[Smalltalk changes addClass: newClass].	"... and recompile."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/19/1999 23:28'!recompile: force from: oldClass to: aClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	| newClass |	newClass _ aClass.	oldClass == nil ifTrue:[		newClass superclass addSubclass: newClass.		^newClass]. "newClass has an empty method dictionary"	(newClass == oldClass and:[force not and:[forceMutation not]])			ifTrue:[^newClass]. "No recompilation necessary"	Smalltalk changes changeClass: newClass from: oldClass.	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		"Recompile from newClass without mutating"		self informUserDuring:[			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	oldClass becomeUncompact.	classMap _ WeakValueDictionary new.	oldClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	self informUserDuring:[		self showProgressFor: oldClass.		"newClass will recompiled later but we need the methodDict for the source"		newClass methodDictionary: oldClass methodDictionary.		newClass _ self reshapeClass: newClass toSuper: newClass superclass.		"Adopt all the instances of the old class"		oldClass autoMutateInstances			ifTrue:[newClass updateInstancesFrom: oldClass].		"Record the change"		self recordClass: oldClass replacedBy: newClass.		self mutate: oldClass to: newClass.		"Fix all global references"		self fixGlobalReferences.		Smalltalk flushClassNameCache.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/19/1999 23:57'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given old class to the new super class"	| fmt newClass newMeta newSuperMeta oldMeta instVars |	oldClass becomeUncompact.	"Compute the new format of the class"	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	fmt _ self computeFormat: oldClass typeOfClass				instSize: instVars size				forSuper: newSuper				ccIndex: 0."Known to be 0 since we uncompacted oldClass first"	fmt == nil ifTrue:[^nil].	oldClass isMeta ifFalse:["Create a new meta class"		oldMeta _ oldClass class.		newMeta _ oldMeta clone.		newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].		newMeta 			superclass: newSuperMeta			methodDictionary: MethodDictionary new			format: (self computeFormat: oldMeta typeOfClass 							instSize: oldMeta instVarNames size 							forSuper: newSuperMeta							ccIndex: 0);			setInstVarNames: oldMeta instVarNames;			organization: oldMeta organization.	].	newClass _ newMeta == nil		ifTrue:[oldClass clone]		ifFalse:[newMeta adoptInstance: oldClass from: oldMeta].	newClass		superclass: newSuper		methodDictionary: MethodDictionary new		format: fmt;		setInstVarNames: instVars;		organization: oldClass organization.	"Note: This is a possibly dangerous state. As long as the 	meta class is not recompiled we should not send any 	messages to the non-meta class."	oldClass isMeta ifFalse:[		"Note: It is deadly important to remove the Smalltalk association name->class		before exporting the class -- sends to super are encoded by the ST association		and exporting the old class by simply doing 			Smalltalk at: newClass name put: newClass		would result in a (possibly fatal) redefinition of the method class.		Unfortunately, exporting newClass might be problem too. Since it is		not yet recompiled sending messages to it during the recompilation		might be fatal. This, however, should not happen as long as the		new class is not referenced from recompilation by means of a message		send -- e.g., the old association is still kept around all direct refs		to the global are still okay. Trouble would start if in the recompilation		something like 'Smalltalk at: #Array' occurs and we were just about		to recompile Array."		environ removeKey: oldClass name ifAbsent:[].		environ at: newClass name put: newClass.		"Recompile the meta class"		oldMeta hasMethods 			ifTrue:[newMeta compileAllFrom: oldMeta].		"Fix up meta class structure"		oldMeta superclass removeSubclass: oldMeta.		newMeta superclass addSubclass: newMeta.		"And record the change so we can fix global refs later"		self recordClass: oldMeta replacedBy: newMeta].	"Recompile the class"	oldClass hasMethods 		ifTrue:[newClass compileAllFrom: oldClass].	"Fix up the class hierarchy"	oldClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Adopt all the instances of the old class"	oldClass autoMutateInstances		ifTrue:[newClass updateInstancesFrom: oldClass].	"And record the change"	self recordClass: oldClass replacedBy: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 7/20/1999 11:13'!silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName	"Move the instvar from srcClass to dstClass.	Do not perform any checks."	| srcVars dstVars dstIndex |	srcVars _ srcClass instVarNames copyWithout: instVarName.	srcClass == dstClass		ifTrue:[dstVars _ srcVars]		ifFalse:[dstVars _ dstClass instVarNames].	dstIndex _ dstVars indexOf: prevInstVarName.	dstVars _ (dstVars copyFrom: 1 to: dstIndex),				(Array with: instVarName),				(dstVars copyFrom: dstIndex+1 to: dstVars size).	instVarMap at: srcClass name put: srcVars.	instVarMap at: dstClass name put: dstVars.	(srcClass inheritsFrom: dstClass) ifTrue:[		self recompile: false from: dstClass to: dstClass mutate: true.	] ifFalse:[		(dstClass inheritsFrom: srcClass) ifTrue:[			self recompile: false from: srcClass to: srcClass mutate: true.		] ifFalse:[ "Disjunct hierarchies"			srcClass == dstClass ifFalse:[				self recompile: false from: dstClass to: dstClass mutate: true.			].			self recompile: false from: srcClass to: srcClass mutate: true.		].	].! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/20/1999 00:41'!validateClass: srcClass forMoving: iv downTo: dstClass	"Make sure that we don't have any accesses to the instVar left"	srcClass withAllSubclassesDo:[:cls|		(cls == dstClass or:[cls inheritsFrom: dstClass]) ifFalse:[			cls forgetDoIts.			(cls whichSelectorsAccess: iv) isEmpty ifFalse:[				self notify: (iv printString asText allBold), ' is still used in ', cls name asText allBold,'.Proceed to move it to Undeclared'.			].		].	].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/20/1999 00:39'!validateClass: srcClass forMoving: iv upTo: dstClass	"Make sure we don't have this instvar already"	dstClass withAllSubclassesDo:[:cls|		(cls == srcClass or:[cls inheritsFrom: srcClass]) ifFalse:[			cls isPointers ifFalse:[				self error: dstClass name, ' cannot have instance variables'.				^false].			cls instSize >= 254 ifTrue:[				self error: cls name, ' has more than 254 instance variables'.				^false].			(cls instVarNames includes: iv) ifTrue:[				self notify: (iv printString asText allBold),' is defined in ', cls name asText allBold,'Proceed to move it up to ', dstClass name asText allBold,' as well'.				instVarMap at: cls name put: (cls instVarNames copyWithout: iv)].		].	].	^true! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/19/1999 23:57'!fixGlobalReferences	"Fix all the references to globals which are now outdated.	Care must be taken that we do not accidentally 'fix' dangerous stuff."	| oldClasses newClasses |	instVarMap _ nil.	(classMap contains:[:any| any notNil and:[any isObsolete]])		ifFalse:[^self]. "Great - no references pending"	any _ nil. "Grrrr. Must clean up the temp of the block above"	Smalltalk garbageCollect. "Try to get rid of as many refs as we can"	"Collect the old and the new refs"	oldClasses _ OrderedCollection new.	newClasses _ OrderedCollection new.	classMap keysAndValuesDo:[:new :old|		old == nil ifFalse:[			newClasses add: new.			oldClasses add: old]].	oldClasses isEmpty ifTrue:[^self]. "GC cleaned up the rest"	"Now fix all the known dangerous pointers to old classes by creating	copies of those still needed. Dangerous pointers should come only	from obsolete subclasses (where the superclass must be preserved)."	self fixObsoleteReferencesTo: oldClasses.	"After this has been done fix the remaining references"	progress == nil ifFalse:[progress value: 'Fixing references to globals'].	"Forward all old refs to the new ones"	oldClasses asArray		elementsForwardIdentityTo:			newClasses asArray.	"Done"! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 10:45'!fixObsoleteMethodsFrom: oldClasses map: obsoleteClasses	"Fix the methods of the obsolete classes"	| nLits tempMethod |	oldClasses do:[:class|		obsoleteClasses at: class ifPresent:[:tempClass|			class selectorsAndMethodsDo:[:sel :meth|				"Create a clean copy for the temps"				tempMethod _ meth copy.				"Fix the super sends"				tempMethod sendsToSuper ifTrue:[					nLits _ tempMethod numLiterals.					"Hack the method class in the temp class"					tempMethod literalAt: nLits put: 						(Association new value: 							(obsoleteClasses at: class ifAbsent:[class])).				].				"Install in tempClass"				tempClass addSelector: sel withMethod: tempMethod.			].		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 11:03'!fixObsoleteReferencesTo: oldClasses	"Fix all obsolete references to the given set of outdated classes"	| obsoleteClasses obj |	progress == nil ifFalse:[progress value:'Fixing obsolete class references...'].	"Prepare a map of obsolete classes"	obsoleteClasses _ self mapObsoleteClassesToTemps: oldClasses.	"Sanity check for debugging"	"oldClasses size = obsoleteClasses size ifFalse:[self error:'Obsolete classes size mismatch']."	"Fix the methods"	self fixObsoleteMethodsFrom: oldClasses map: obsoleteClasses.	"Now search and fix all dangerous objects"	obj _ 0 someObject.	[0 == obj] whileFalse:[		"Try to avoid proxies or somesuch"		obj class superclass == nil ifFalse:[			(obj isBehavior and:[obsoleteClasses includesKey: obj superclass]) ifTrue:[				(obsoleteClasses includesKey: obj) ifFalse:[						obj superclass: (obsoleteClasses at: obj superclass)]].		].		obj _ obj nextObject.	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 00:07'!informUserDuring: aBlock	self class isSilent ifTrue:[^aBlock value].	Utilities informUserDuring:[:bar|		progress _ bar.		aBlock value].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 01:18'!mapObsoleteClassesToTemps: oldClasses	"Map the old classes to temporary classes"	| oldMeta tempMeta obsoleteClasses |	obsoleteClasses _ IdentityDictionary new: oldClasses size.	oldClasses do:[:oldClass| 		"Note: If a class is getting obsolete here so is its metaclass"		oldMeta _ oldClass isMeta ifTrue:[oldClass] ifFalse:[oldClass class].		tempMeta _ obsoleteClasses at: oldMeta ifAbsentPut:[oldMeta clone].		oldClass isMeta ifFalse:[			tempMeta adoptInstance: oldClass from: oldMeta.			obsoleteClasses at: oldClass put: tempMeta soleInstance.			"Note: If we haven't mutated the instances of the old class to the new			layout we must do it here."			oldClass autoMutateInstances ifFalse:[				tempMeta soleInstance updateInstancesFrom: oldClass]]].	"Fix the superclasses of the clones"	obsoleteClasses keysAndValuesDo:[:old :temp|		temp superclass: 			(obsoleteClasses 				at: temp superclass				"Might be a subclass of a live class"				ifAbsent:[temp superclass])].	"And install new method dictionaries"	obsoleteClasses valuesDo:[:temp|		temp methodDictionary: temp methodDictionary copy.	].	^obsoleteClasses! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 00:00'!recordClass: oldClass replacedBy: newClass	"Record the replacement of oldClass by newClass so that we can	fix any references to oldClass later on."	classMap at: newClass put: oldClass.	(classMap includesKey: oldClass) ifTrue:[		"This will happen if we recompile from Class		in which case the metaclass gets recorded twice"		classMap at: newClass put: (classMap at: oldClass).		classMap removeKey: oldClass.	].	"And keep the changes up to date"	(instVarMap includesKey: oldClass name) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.	].! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!class: oldClass instanceVariableNames: instVarString	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass |	oldClass isMeta ifFalse:[^self error: oldClass name, 'is not a Metaclass'].	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	"Run validation checks so we know that we have a good chance for recompilation"	(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].	(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass.	newClass == nil ifTrue:[^nil]. "Some error"	newClass _ self recompile: false from: oldClass to: newClass mutate: false.	^newClass! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:40'!moveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName	"Move the given instVar from srcClass to dstClass"	(srcClass instVarNames includes: instVarName)		ifFalse:[^self error: instVarName,' is not an instance variable of ', srcClass name].	(prevInstVarName isNil or:[dstClass instVarNames includes: prevInstVarName])		ifFalse:[^self error: prevInstVarName, 'is not an instance variable of', dstClass name].	(srcClass inheritsFrom: dstClass) ifTrue:[		"Move the instvar up the hierarchy."		(self validateClass: srcClass forMoving: instVarName upTo: dstClass)			ifFalse:[^false].	].	(dstClass inheritsFrom: srcClass) ifTrue:[		"Move the instvar down the hierarchy"		(self validateClass: srcClass forMoving: instVarName downTo: dstClass)			ifFalse:[^false].	].	^self silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: newSuper	subclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class."	^self 		name: t		inEnvironment: newSuper environment		subclassOf: newSuper		type: newSuper typeOfClass		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #bytes		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: aClass	variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #variable		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:30'!superclass: aClass	variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable word-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a word subclass of a class with named fields'].	(aClass isVariable and: [aClass isBytes])		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a word subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #words		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:30'!superclass: aClass	weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #weak		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassDescription methodsFor: 'compiling' stamp: 'ar 7/20/1999 11:04'!moveInstVarNamed: instVarName to: anotherClass after: prevInstVarName	"Move the given instance variable to another class."	self == anotherClass ifFalse:[		self notify:'Warning:' asText allBold,' moving ', instVarName printString,' from ', self name,' to ', anotherClass name,' will not be recorded in the change set correctly.Proceed to do it anyways.'].	^(ClassBuilder new)		moveInstVarNamed: instVarName 		from: self 		to: anotherClass 		after: prevInstVarName! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/20/1999 11:23'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	subclasses _ nil. "Important for moving down the subclasses field into Class"! !!ClassBuilder class methodsFor: 'instance creation' stamp: 'ar 7/19/1999 23:28'!new	^super new initialize.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'ar 7/19/1999 23:00'!forgetDoIts	"Smalltalk forgetDoIts"	Smalltalk allBehaviorsDo: "get rid of old DoIt methods"		[:cl | cl forgetDoIts]! !ClassBuilder removeSelector: #recompile:from:to:!