'From Squeak 2.3 beta of Nov 25, 1998 on 4 December 1998 at 1:24:22 pm'!ReadStream subclass: #InflateStream	instanceVariableNames: 'state bitBuf bitPos source sourcePos sourceLimit litTable distTable '	classVariableNames: 'BlockProceedBit BlockTypes MaxBits StateNewBlock StateNoMoreData '	poolDictionaries: ''	category: 'Streams-Compressed'!InflateStream subclass: #FastInflateStream	instanceVariableNames: ''	classVariableNames: 'DistanceMap LiteralLengthMap '	poolDictionaries: ''	category: 'Streams-Compressed'!FastInflateStream subclass: #GZipStream	instanceVariableNames: ''	classVariableNames: 'GZipAsciiFlag GZipCommentFlag GZipContinueFlag GZipDeflated GZipEncryptFlag GZipExtraField GZipMagic GZipNameFlag GZipReservedFlags '	poolDictionaries: ''	category: 'Streams-Compressed'!FastInflateStream subclass: #ZLibStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Streams-Compressed'!!FileList methodsFor: 'file list menu' stamp: 'ar 12/4/1998 13:21'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile putUpdate)].	(suffix = 'swf') | (suffix = '*') ifTrue:[		labels add:'open as Flash'.		selectors add: #openAsFlash].	(suffix = 'ttf') | (suffix = '*') ifTrue:[		labels add: 'open true type font'.		selectors add: #openAsTTF].	(suffix = 'gz') | (suffix = '*') ifTrue:[		labels add: 'view decompressed'.		selectors add: #viewGZipContents].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'ar 12/4/1998 00:28'!viewGZipContents	"Open a MoviePlayerMorph on the given file (must be in .movie format)."	| f |	f _ (directory readOnlyFileNamed: self fullName) binary.	contents _ f contentsOfEntireFile.	Cursor wait showWhile:[contents _ (GZipStream on: contents) upToEnd].	contents _ contents asString.	contents replaceAll: Character lf with: Character cr.	(StringHolder new)		contents: contents;		openLabel:'Contents of ', fileName printString! !!InflateStream class methodsFor: 'class initialization' stamp: 'ar 12/3/1998 23:04'!initialize	"ZLibStream initialize"	MaxBits _ 16.	StateNewBlock _ 0.	StateNoMoreData _ 1.	BlockProceedBit _ 8.	BlockTypes _ #(	processStoredBlock	"New block in stored format"					processFixedBlock	"New block with fixed huffman tables"					processDynamicBlock	"New block with dynamic huffman tables"					errorBadBlock		"Bad block format"					proceedStoredBlock	"Continue block in stored format"					proceedFixedBlock	"Continue block in fixed format"					proceedDynamicBlock	"Continue block in dynamic format"					errorBadBlock		"Bad block format").! !!FastInflateStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 02:33'!initialize	"FastInflateStream initialize"	| low high |	"Init literal/length map"	low _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258).	high _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0).	LiteralLengthMap _ Array new: 256 + 30.	1 to: 257 do:[:i| LiteralLengthMap at: i put: i-1].	1 to: 29 do:[:i| LiteralLengthMap at: 257+i put: (low at:i) + ( (high at: i) + 1 << 16)].	"Init distance map"	high _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).	low _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769			1025 1537 2049 3073 4097 6145 8193 12289 16385 24577).	DistanceMap _ Array new: 30.	1 to: 30 do:[:i| DistanceMap at: i put: (low at: i) + ( (high at: i) << 16)].! !!GZipStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 00:12'!initialize	"GZipStream initialize"	GZipMagic _ 16r8B1F.		"GZIP magic number"	GZipDeflated _ 8.		"Compression method"	GZipAsciiFlag _ 16r01.		"Contents is ASCII"	GZipContinueFlag _ 16r02.	"Part of a multi-part archive"	GZipExtraField _ 16r04.		"Archive has extra fields"	GZipNameFlag _ 16r08.		"Archive has original file name"	GZipCommentFlag _ 16r10.	"Archive has comment"	GZipEncryptFlag _ 16r20.		"Archive is encrypted"	GZipReservedFlags _ 16rC0.	"Reserved" ! !!PositionableStream methodsFor: 'converting' stamp: 'ar 12/3/1998 22:06'!asZLibStream	^ZLibStream on: collection from: position+1 to: readLimit! !!InflateStream commentStamp: 'ar 12/4/1998 13:20' prior: 0!This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table _ initialTable.	bitsNeeded _ high 8 bits of (table at: 1).		"Determine initial bits"	table _ initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits _ fetch next bitsNeeded bits.			"Grab the bits"	value _ table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table _ initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded _ high 8 bit of value].		"Compute additional number of bits needed"	^value!!InflateStream reorganize!('initialize' on: on:from:to: reset)('accessing' next next: size upTo: upToEnd)('testing' atEnd)('inflating' decodeValueFrom: decompressBlock:with: proceedDynamicBlock proceedFixedBlock proceedStoredBlock processDynamicBlock processStoredBlock)('private' assert: decompressAll getNextBlock pastEndRead profile)('huffman trees' computeHuffmanValues:counts:from:to: createHuffmanTables:counts:from:to: decodeDynamicTable:from: distanceMap growHuffmanTable: huffmanTableFrom:mappedBy: increment:bits: literalLengthMap mapValues:by:)('bit access' nextBits: nextByte nextSingleBits:)!!InflateStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 16:35'!on: aCollection	^self on: aCollection from: 1 to: aCollection size! !!InflateStream methodsFor: 'initialize' stamp: 'ar 12/4/1998 13:08'!on: aCollection from: firstIndex to: lastIndex	bitBuf _ bitPos _ 0.	"The decompression buffer has a size of at 64k,	since we may have distances up to 32k back and	repetitions of at most 32k length forward"	collection _ aCollection species new: 1 << 16.	readLimit _ 0. "Not yet initialized"	position _ 0.	source _ aCollection.	sourceLimit _ lastIndex.	sourcePos _ firstIndex-1.	state _ StateNewBlock.! !!InflateStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 16:32'!reset	"Position zero - nothing decoded yet"	position _ readLimit _ 0.	sourcePos _ 0.	bitBuf _ bitPos _ 0.	state _ 0.! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 22:10'!next	"Answer the next decompressed object in the Stream represented by the	receiver."	"<primitive: 65>"	position >= readLimit		ifTrue: [^self pastEndRead]		ifFalse: [^collection at: (position _ position + 1)]! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:18'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for simplicity"	| newArray |	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19'!size	"This is a compressed stream - we don't know the size beforehand"	^self shouldNotImplement! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream _ WriteStream on: (collection species new: 100).	[self atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:20'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream el |	newStream _ WriteStream on: (collection species new: 100).	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].	^ newStream contents! !!InflateStream methodsFor: 'testing' stamp: 'ar 12/3/1998 23:21'!atEnd	^position >= readLimit and:[state = StateNoMoreData]! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:24'!decodeValueFrom: table	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value |	bitsNeeded _ (table at: 1) bitShift: -24.	"Initial bits needed"	tableIndex _ 2.							"First real table"	[bits _ self nextSingleBits: bitsNeeded.	"Get bits"	value _ table at: (tableIndex + bits).		"Lookup entry in table"	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"		whileFalse:["Fetch sub table"			tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"			bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].	^value! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:34'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance inPos decoded oldPos oldBits oldBitPos |	decoded _ 0.	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection at: (readLimit _ readLimit + 1) put: value.			decoded _ decoded+1.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^decoded].			"Compute the actual length value (including possible extra bits)"			extra _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0) at: value - 256.			length _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258) at: value - 256.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13) at: value+1.			distance _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769						1025 1537 2049 3073 4097 6145 8193 12289 16385 24577) at: value+1.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length > collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^decoded].			inPos _ readLimit - distance.			[(length _ length - 1 ) >= 0] whileTrue:[				collection at: (readLimit _ readLimit + 1) put: (collection at: (inPos _ inPos + 1))].		].	].	^decoded! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!proceedDynamicBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!proceedFixedBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 21:12'!proceedStoredBlock	"Proceed decompressing a stored (e.g., uncompressed) block"	| length decoded |	"Literal table must be nil for a stored block"	litTable == nil ifFalse:[^self error:'Bad state'].	length _ distTable.	[length > 0 and:[readLimit <= collection size and:[sourcePos <= sourceLimit]]] 		whileTrue:[			collection at: (readLimit _ readLimit + 1) put: 				(source at: (sourcePos _ sourcePos + 1)).			length _ length - 1].	length = 0 ifTrue:[state _ state bitAnd: StateNoMoreData].	decoded _ length - distTable.	distTable _ length.	^decoded! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 01:46'!processDynamicBlock	| nLit nDist nLen codeLength lengthTable bits |	nLit _ (self nextBits: 5) + 257.	nDist _ (self nextBits: 5) + 1.	nLen _ (self nextBits: 4) + 4.	codeLength _ Array new: 19.	codeLength atAllPut: 0.	1 to: nLen do:[:i|		bits _ #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15) at: i.		codeLength at: bits+1 put: (self nextBits: 3).	].	lengthTable _ self huffmanTableFrom: codeLength mappedBy: nil.	"RFC 1951: In other words, all code lengths form a single sequence..."	codeLength _ self decodeDynamicTable: nLit+nDist from: lengthTable.	litTable _ self 				huffmanTableFrom: (codeLength copyFrom: 1 to: nLit)				mappedBy: self literalLengthMap.	distTable _ self 				huffmanTableFrom: (codeLength copyFrom: nLit+1 to: codeLength size)				mappedBy: self distanceMap.	state _ state bitOr: BlockProceedBit.	self proceedDynamicBlock.! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:01'!processStoredBlock	| chkSum length |	"Skip to byte boundary"	self nextBits: (bitPos bitAnd: 7).	length _ self nextBits: 16.	chkSum _ self nextBits: 16.	chkSum bitInvert32 = length		ifFalse:[^self error:'Bad block length'].	litTable _ nil.	distTable _ length.	^self proceedStoredBlock! !!InflateStream methodsFor: 'private' stamp: 'ar 12/2/1998 17:17'!assert: aBlock	aBlock value ifFalse:[^self error:'Assertion failed']! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!decompressAll	"Profile the decompression speed"	[self atEnd] whileFalse:[		position _ readLimit.		self next "Provokes decompression"	].! !!InflateStream methodsFor: 'private' stamp: 'ar 12/3/1998 17:32'!getNextBlock	^self nextBits: 3! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 13:04'!pastEndRead	"A client has attempted to read beyond the read limit.	Check in what state we currently are and perform	the appropriate action"	| blockType delta |	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"	"Check if we can move data to front"	readLimit > 32768 ifTrue:[		delta _ readLimit - 32767.		collection replaceFrom: 1 to: collection size - delta + 1 with: collection startingAt: delta.		position _ position - delta + 1.		readLimit _ readLimit - delta + 1.	].	state = StateNewBlock ifTrue:[state _ self getNextBlock].	state = StateNoMoreData ifTrue:[^nil].	blockType _ state bitShift: -1.	self perform: (BlockTypes at: blockType+1).	^collection at: (position _ position + 1)! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!profile	"Profile the decompression speed"	MessageTally spyOn:[self decompressAll].! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/2/1998 19:27'!computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits	"Assign numerical values to all codes.	Note: The values are stored according to the bit length"	| offsets values baseOffset codeLength |	offsets _ Array new: maxBits.	offsets atAllPut: 0.	baseOffset _ 1.	minBits to: maxBits do:[:bits|		offsets at: bits put: baseOffset.		baseOffset _ baseOffset + (counts at: bits+1)].	values _ Array new: aCollection size.	1 to: aCollection size do:[:i|		codeLength _ aCollection at: i.		codeLength > 0 ifTrue:[			baseOffset _ offsets at: codeLength.			values at: baseOffset put: i-1.			offsets at: codeLength put: baseOffset + 1]].	^values! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:21'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table _ Array new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart _ 2. "See above"	tableSize _ 1 bitShift: minBits.	tableEnd _ tableStart + tableSize.	"Store the terminal symbols"	valueIndex _ (counts at: minBits+1).	tableIndex _ 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex _ self increment: tableIndex bits: minBits].	"Fill up remaining entries with invalid entries"	tableStack _ OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex _ valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues _ counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable _ tableStack last.			lastTableStart _ lastTable at: 2.			lastTableIndex _ lastTable at: 3.			deltaBits _ bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize _ 1 bitShift: deltaBits.			tableStart _ tableEnd.			tableEnd _ tableEnd + tableSize.			tableEnd > table size 				ifTrue:[table _ self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) isNil]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: (self increment: lastTableIndex bits: (lastTable at: 4)).			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries _ numValues min: tableSize.			tableIndex _ 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex _ valueIndex + 1.				numValues _ numValues - 1.				tableIndex _ self increment: tableIndex bits: deltaBits].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:25'!decodeDynamicTable: nItems from: aHuffmanTable	"Decode the code length of the literal/length and distance table	in a block compressed with dynamic huffman trees"	| values index value repCount theValue |	values _ Array new: nItems.	index _ 1.	theValue _ 0.	[index <= nItems] whileTrue:[		value _ self decodeValueFrom: aHuffmanTable.		value < 16 ifTrue:[			"Immediate values"			theValue _ value.			values at: index put: value.			index _ index+1.		] ifFalse:[			"Repeated values"			value = 16 ifTrue:[				"Repeat last value"				repCount _ (self nextBits: 2) + 3.			] ifFalse:[				"Repeat zero value"				theValue _ 0.				value = 17 					ifTrue:[repCount _ (self nextBits: 3) + 3]					ifFalse:[value = 18 								ifTrue:[repCount _ (self nextBits: 7) + 11]								ifFalse:[^self error:'Invalid bits tree value']]].			0 to: repCount-1 do:[:i| values at: index+i put: theValue].			index _ index + repCount].	].	^values! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:51'!distanceMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/3/1998 13:16'!growHuffmanTable: table	| newTable |	newTable _ table species new: table size * 2.	newTable replaceFrom: 1 to: table size with: table startingAt: 1.	^newTable! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:27'!huffmanTableFrom: aCollection mappedBy: valueMap	"Create a new huffman table from the given code lengths.	Map the actual values by valueMap if it is given.	See the class comment for a documentation of the huffman	tables used in this decompressor."	| counts  values table minBits maxBits |	minBits _ MaxBits + 1.	maxBits _ 0.	"Count the occurences of each code length and compute minBits and maxBits"	counts _ Array new: MaxBits+1.	counts atAllPut: 0.	aCollection do:[:length| 		length > 0 ifTrue:[			length < minBits ifTrue:[minBits _ length].			length > maxBits ifTrue:[maxBits _ length].			counts at: length+1 put: (counts at: length+1)+1]].	maxBits = 0 ifTrue:[^nil]. "Empty huffman table"	"Assign numerical values to all codes."	values _ self computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits.	"Map the values if requested"	self mapValues: values by: valueMap.	"Create the actual tables"	table _ self createHuffmanTables: values counts: counts from: minBits to: maxBits.	^table! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment a value of nBits length.	The fast decompressor will do this differently"	^value+1! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:50'!literalLengthMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:28'!mapValues: values by: valueMap	| oldValue |	valueMap ifNil:[^values].	1 to: values size do:[:i|		oldValue _ values at: i.		"Note: there may be nil values if not all values are used"		oldValue isNil			ifTrue:[^values]			ifFalse:[values at: i put: (valueMap at: oldValue+1)]].! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:00'!nextBits: n	| bits |	[bitPos < n] whileTrue:[		bitBuf _ bitBuf + (self nextByte bitShift: bitPos).		bitPos _ bitPos + 8].	bits _ bitBuf bitAnd: (1 bitShift: n)-1.	bitBuf _ bitBuf bitShift: 0 - n.	bitPos _ bitPos - n.	^bits! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:01'!nextByte	^source at: (sourcePos _ sourcePos + 1)! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:01'!nextSingleBits: n	| out |	out _ 0.	1 to: n do:[:i| out _ (out bitShift: 1) + (self nextBits: 1)].	^out! !!FastInflateStream commentStamp: '<historical>' prior: 0!This class adds the following optimizations to the basic Inflate decompression:a) Bit reversed accessIf we want to fetch the bits efficiently then we have them in the wrong bit order (e.g., when we should fetch 2r100 we would get 2r001). But since the huffman tree lookup determines the efficiency of the decompression, reversing the bits before traversal is expensive. Therefore the entries in each table are stored in REVERSE BIT ORDER. This is achieved by a reverse increment of the current table index in the huffman table construction phase (see method increment:bits:). According to my measures this speeds up the implementation by about 30-40%.b) Inplace storage of code meanings and extra bitsRather than looking up the meaning for each code during decompression of blocks we store the appropriate values directly in the huffman tables, using a pre-defined mapping. Even though this does not make a big difference in speed, it cleans up the code and allows easier translation into primitive code (which is clearly one goal of this implementation). !!FastInflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:33'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance inPos decoded oldPos oldBits oldBitPos |	decoded _ 0.	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection at: (readLimit _ readLimit + 1) put: value.			decoded _ decoded+1.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^decoded].			"Compute the actual length value (including possible extra bits)"			extra _ (value bitShift: -16) - 1.			length _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ (value bitShift: -16).			distance _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length > collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^decoded].			inPos _ readLimit - distance.			[(length _ length - 1 ) >= 0] whileTrue:[				collection at: (readLimit _ readLimit + 1) put: (collection at: (inPos _ inPos + 1))].		].	].	^decoded! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26'!distanceMap	^DistanceMap! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment value in reverse bit order, e.g. 	for a 3 bit value count as follows:		000 / 100 / 010 / 110		001 / 101 / 011 / 111	See the class comment why we need this."	| result bit |	result _ value.	"Test the lowest bit first"	bit _ 1 << (nBits - 1).	"If the currently tested bit is set then we need to	turn this bit off and test the next bit right to it"	[(result bitAnd: bit) = 0] whileFalse:[ 		"Turn off current bit"		result _ result bitXor: bit.		"And continue testing the next bit"		bit _ bit bitShift: -1].	"Turn on the right-most bit that we haven't touched in the loop above"	^result bitXor: bit! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26'!literalLengthMap	^LiteralLengthMap! !!FastInflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:02'!nextSingleBits: n	"Fetch the bits all at once"	^self nextBits: n.! !!GZipStream commentStamp: '<historical>' prior: 0!This class can be used to read from Gnu Zip (GZIP) compressed streams. For more information see the file "algorithm.doc" from the Gnu Zip source distribution.!!GZipStream methodsFor: 'initialize' stamp: 'ar 12/4/1998 00:07'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the GZIP stream."	| method magic flags length |	super on: aCollection from: firstIndex to: lastIndex.	magic _ self nextBits: 16.	(magic = GZipMagic) 		ifFalse:[^self error:'Not a GZipped stream'].	method _ self nextBits: 8.	(method = GZipDeflated)		ifFalse:[^self error:'Bad compression method'].	flags _ self nextBits: 8.	(flags anyMask: GZipEncryptFlag) 		ifTrue:[^self error:'Cannot decompress encrypted stream'].	(flags anyMask: GZipReservedFlags)		ifTrue:[^self error:'Cannot decompress stream with unknown flags'].	"Ignore stamp, extra flags, OS type"	self nextBits: 16; nextBits: 16. "stamp"	self nextBits: 8. "extra flags"	self nextBits: 8. "OS type"	(flags anyMask: GZipContinueFlag) "Number of multi-part archive - ignored"		ifTrue:[self nextBits: 16]. 	(flags anyMask: GZipExtraField) "Extra fields - ignored"		ifTrue:[	length _ self nextBits: 16.				1 to: length do:[:i| self nextBits: 8]].	(flags anyMask: GZipNameFlag) "Original file name - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].	(flags anyMask: GZipCommentFlag) "Comment - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].! !!ZLibStream commentStamp: '<historical>' prior: 0!This class can be used to read from ZLib compressed streams. For more information see the RFC1950 "ZLIB Compressed Data Format Specification version 3.3" available for instance from	http://www.leo.org/pub/comp/doc/standards/rfc/index.html!!ZLibStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 21:04'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the ZLib stream."	| method byte |	super on: aCollection from: firstIndex to: lastIndex.	method _ self nextBits: 8.	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].	byte _ self nextBits: 8.	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].! !InflateStream initialize!FastInflateStream initialize!GZipStream initialize!