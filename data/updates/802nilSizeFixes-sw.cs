'From Squeak 2.3 of January 14, 1999 on 7 April 1999 at 9:47:00 pm'!"Change Set:		nilSizeFixes-swDate:			7 April 1999Author:			Scott WallaceFixes a further score of methods that were compromised by the recent disenfranchising of UndefinedObject.size."!!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 4/7/1999 17:45'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents isEmptyOrNil])		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]! !!Collection methodsFor: 'testing' stamp: 'sw 4/7/1999 17:28'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ self size = 0! !!EmphasizedMenu methodsFor: 'private' stamp: 'sw 4/5/1999 13:59'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  "	| selStart selEnd currEmphasis |	labelString _ labelString asText.	emphases isEmptyOrNil ifTrue: [^ self].	selStart _ 1.	1 to: selections size do:		[:line |			selEnd _ selStart + (selections at: line) size - 1.			((currEmphasis _ emphases at: line) size > 0 and: [currEmphasis ~~ #plain]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart _ selEnd + 2]! !!GraphicalDictionaryMenu methodsFor: 'as yet unclassified' stamp: 'sw 4/5/1999 12:34'!renameEntry	| reply curr |	reply _ FillInTheBlankMorph  request: 'New key? '		initialAnswer: (curr _ entryNames at: currentIndex)		centerAt: self center.	(reply isEmptyOrNil or: [reply = curr]) ifTrue: [^ self beep].	(baseDictionary includesKey: reply) ifTrue:		[^ self inform: 'sorry that conflicts withthe name of anotherentry in this dictionary'].	baseDictionary at: reply put: (baseDictionary at: curr).	baseDictionary removeKey: curr.	self baseDictionary: baseDictionary.	self updateThumbnail! !!GraphicalDictionaryMenu methodsFor: 'as yet unclassified' stamp: 'sw 4/5/1999 12:34'!renameGraphicTo: newName	| curr |	curr _ entryNames at: currentIndex.	(newName isEmptyOrNil or: [newName = curr]) ifTrue: [^ self beep].	(baseDictionary includesKey: newName) ifTrue:		[^ self inform: 'sorry that conflicts withthe name of anotherentry in this dictionary'].	baseDictionary at: newName put: (baseDictionary at: curr).	baseDictionary removeKey: curr.	self baseDictionary: baseDictionary.	currentIndex _ entryNames indexOf: newName.	self updateThumbnail! !!PartsViewer methodsFor: 'private' stamp: 'sw 4/5/1999 13:56'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 4/5/1999 13:55'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!Player methodsFor: 'costume' stamp: 'sw 4/5/1999 13:48'!availableCostumesForArrows	^ costumes ifNil: [Array new]! !!Player methodsFor: 'costume' stamp: 'sw 4/7/1999 21:20'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph _ self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes isEmptyOrNil ifFalse:		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 4/7/1999 21:22'!knownSketchCostumeWithSameFormAs: aSketchMorph	| itsForm rend |	itsForm _ aSketchMorph form.	(((rend _ costume renderedMorph) isKindOf: SketchMorph) and: [rend form == itsForm])		ifTrue:	[^ rend].	^ costumes ifNotNil: [costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]]! !!Player methodsFor: 'costume' stamp: 'sw 4/7/1999 21:20'!wearSketchCostumeResembling: aSketchMorph	| newCostume itsForm cur degs chgd |	itsForm _ aSketchMorph form.	((cur _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[cur form == itsForm ifTrue: [^ self]].	(costumes notNil and: [costumes size > 0]) ifTrue:		[newCostume _ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]].	chgd _ false.	newCostume ifNil:		[newCostume _ SketchMorph new player: self.		newCostume originalForm: itsForm;		rotationCenter: aSketchMorph rotationCenter;		framesToDwell: aSketchMorph framesToDwell.		chgd _ true].	((cur isKindOf: SketchMorph) and: [cur rotationStyle ~~ #normal])			ifTrue:				[newCostume rotationStyle: cur rotationStyle.				newCostume rotationDegrees: cur rotationDegrees.				degs _ cur valueOfProperty: #setupAngle ifAbsent: [nil].				degs ifNotNil: [newCostume setupAngle: degs].				chgd _ true].	chgd ifTrue: [newCostume layoutChanged].	self renderedCostume: newCostume! !!Player methodsFor: 'slots-user' stamp: 'sw 4/7/1999 17:42'!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	self flag: #deferred.  "sound should be reinstated but too much difficulty at present"	typeChoices _ #(number player boolean color string "sound point costume").	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'slots-user' stamp: 'sw 4/5/1999 13:55'!chooseUserSlot	| names aMenu result |	(names _ self slotNames) size == 1		ifTrue: [^ names first].	aMenu _ SelectionMenu selections: names.	result _ aMenu startUpWithCaption: 'Please choose a variable'.	result isEmptyOrNil ifTrue: [^ nil].	^ result! !!Player methodsFor: 'misc' stamp: 'sw 4/7/1999 21:19'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld aViewer |	aWorld _ aMorph world.	aViewer _ aMorph ownerThatIsA: Viewer.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume]])			ifTrue:				[aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes]].	aMenu addLine.	aMenu add: 'add a new instance variable' target: self action: #addInstanceVariable.	"aMenu add: 'add an empty new script' target: aViewer action: #newEmptyScript."	aMenu add: 'add a new script' target: aViewer action: #newPermanentScript.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent.	aMenu addLine.	aMenu add: 'inspect morph' target: costume selector: #inspect.	aMenu add: 'inspect player' target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' target: self action: #browsePlayerClass.		aMenu add: 'inspect class' target: self class action: #inspect]."	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 4/5/1999 13:53'!dismiss	| aMenu reply |	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	self isAnonymous		ifTrue:			[((submorphs size > 3) or: [self scriptInstantiation status ~~ #normal]) ifTrue:				[aMenu _ SelectionMenu selections: #('yes, name it' 'no, discard it' 'cancel').				reply _ aMenu startUpWithCaption: 'Do you want to give thisscript a name and save it? '.				(reply isEmptyOrNil or: [reply = 'cancel']) ifTrue: [^ self].				(reply = 'yes, name it') ifTrue: [^ self renameScript]].		self actuallyDestroyScript].	self delete! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 4/7/1999 21:43'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self contentsChanged! !!UndefinedObject methodsFor: 'testing' stamp: 'sw 4/7/1999 17:44'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ true! !!UserScript methodsFor: 'versions' stamp: 'sw 4/5/1999 13:50'!revertScriptVersionFrom: anEditor	| aMenu result aPosition oldOwner |	formerScriptEditors isEmptyOrNil ifTrue: [^ self beep].	aMenu _ SelectionMenu labelList: (formerScriptEditors collect: [:e | e timeStamp])		selections: formerScriptEditors.	result _ aMenu startUp.	result ifNotNil:		[aPosition _ anEditor position.		oldOwner _ anEditor topRendererOrSelf owner.		anEditor delete.		currentScriptEditor _ result bringUpToDate install.		player costume viewAfreshIn: oldOwner showingScript: selector at: aPosition]! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 4/7/1999 17:26'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter ifNotNil: [self presenter updateViewer: self]! !!Viewer methodsFor: 'as yet unclassified' stamp: 'sw 4/7/1999 17:26'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter ifNotNil: [self presenter updateViewer: self]! !CategoryViewer removeSelector: #nextCostume!