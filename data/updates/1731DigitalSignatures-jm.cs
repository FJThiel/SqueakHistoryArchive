'From Squeak2.6 of 11 October 1999 [latest update: #1726] on 24 December 1999 at 12:15:24 am'!"Change Set:		DigitalSignatures-jmDate:			24 December 1999Author:			John MaloneyThis is an implementation of the U.S. Government Digital Signature Standard.To use it, you will need a set of primitives currently packaged as DSAPrims;as usual, just put this file in the directory that holds the Squeak executable.Note that this includes some primitives for fast multiplication and division.Please see the class comments for further info."!InterpreterPlugin subclass: #DSAPlugin	instanceVariableNames: 'dsaRemainder dsaDivisor dsaQuotient remainderDigitCount divisorDigitCount '	classVariableNames: ''	poolDictionaries: ''	category: 'Digital Signatures'!!DSAPlugin commentStamp: 'jm 12/22/1999 10:35' prior: 0!This plugin defines primitives that support the DigitalSignatureAlgorithm class. Three of these primitives support fast multiplication and division of very large integers, three others support the SecureHashAlgorithm.!!DSAPlugin methodsFor: 'primitives-SHA' stamp: 'jm 12/21/1999 22:52'!primitiveExpandBlock	"Expand a 64 byte ByteArray (the first argument) into and an Bitmap of 80 32-bit words (the second argument). When reading a 32-bit integer from the ByteArray, consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	| expanded buf wordPtr bytePtr src v |	self export: true.	self var: #wordPtr declareC: 'unsigned int *wordPtr'.	self var: #bytePtr declareC: 'unsigned char *bytePtr'.	expanded _ interpreterProxy stackObjectValue: 0.	buf _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: expanded).	interpreterProxy success: (interpreterProxy isBytes: buf).	interpreterProxy failed ifTrue: [^ nil].	interpreterProxy success: ((interpreterProxy stSizeOf: expanded) = 80).	interpreterProxy success: ((interpreterProxy stSizeOf: buf) = 64).	interpreterProxy failed ifTrue: [^ nil].	wordPtr _ interpreterProxy firstIndexableField: expanded.	bytePtr _ interpreterProxy firstIndexableField: buf.	src _ 0.	0 to: 15 do: [:i |		v _ ((bytePtr at: src) << 24) +			((bytePtr at: src + 1) << 16) +			((bytePtr at: src + 2) << 8) +			(bytePtr at: src + 3).		wordPtr at: i put: v.		src _ src + 4].	16 to: 79 do: [:i |		v _ (((wordPtr at: i - 3) bitXor:			 (wordPtr at: i - 8)) bitXor:			 (wordPtr at: i - 14)) bitXor:			 (wordPtr at: i - 16).		v _ self leftRotate: v by: 1.		wordPtr at: i put: v].	interpreterProxy pop: 2.! !!DSAPlugin methodsFor: 'primitives-SHA' stamp: 'jm 12/21/1999 20:43'!primitiveHasSecureHashPrimitive	"Answer true if the secure hash primitive is implemented."	self export: true.	interpreterProxy pop: 1.	interpreterProxy pushBool: true.! !!DSAPlugin methodsFor: 'primitives-SHA' stamp: 'jm 12/21/1999 23:35'!primitiveHashBlock	"Hash a Bitmap of 80 32-bit words (the first argument), using the given state (the second argument)."	| state buf statePtr bufPtr a b c d e tmp |	self export: true.	self var: #statePtr declareC: 'unsigned int *statePtr'.	self var: #bufPtr declareC: 'unsigned int *bufPtr'.	state _ interpreterProxy stackObjectValue: 0.	buf _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: state).	interpreterProxy success: (interpreterProxy isWords: buf).	interpreterProxy failed ifTrue: [^ nil].	interpreterProxy success: ((interpreterProxy stSizeOf: state) = 5).	interpreterProxy success: ((interpreterProxy stSizeOf: buf) = 80).	interpreterProxy failed ifTrue: [^ nil].	statePtr _ interpreterProxy firstIndexableField: state.	bufPtr _ interpreterProxy firstIndexableField: buf.	a _ statePtr at: 0.	b _ statePtr at: 1.	c _ statePtr at: 2.	d _ statePtr at: 3.	e _ statePtr at: 4. 	0 to: 19 do: [:i |		tmp _ 16r5A827999 + ((b bitAnd: c) bitOr: (b bitInvert32 bitAnd: d)) +				(self leftRotate: a by: 5) +  e + (bufPtr at: i).		e _ d.  d _ c.  c _ self leftRotate: b by: 30.  b _ a.  a _ tmp].	20 to: 39 do: [:i |		tmp _ 16r6ED9EBA1 + ((b bitXor: c) bitXor: d) +				(self leftRotate: a by: 5) +  e + (bufPtr at: i).		e _ d.  d _ c.  c _ self leftRotate: b by: 30.  b _ a.  a _ tmp].	40 to: 59 do: [:i |		tmp _ 16r8F1BBCDC + (((b bitAnd: c) bitOr: (b bitAnd: d)) bitOr: (c bitAnd: d)) +				(self leftRotate: a by: 5) +  e + (bufPtr at: i).		e _ d.  d _ c.  c _ self leftRotate: b by: 30.  b _ a.  a _ tmp].	60 to: 79 do: [:i |		tmp _ 16rCA62C1D6 + ((b bitXor: c) bitXor: d) +				(self leftRotate: a by: 5) +  e + (bufPtr at: i).		e _ d.  d _ c.  c _ self leftRotate: b by: 30.  b _ a.  a _ tmp].	statePtr at: 0 put: (statePtr at: 0) + a.	statePtr at: 1 put: (statePtr at: 1) + b.	statePtr at: 2 put: (statePtr at: 2) + c.	statePtr at: 3 put: (statePtr at: 3) + d.	statePtr at: 4 put: (statePtr at: 4) + e.	interpreterProxy pop: 2.! !!DSAPlugin methodsFor: 'primitives-integers' stamp: 'jm 12/21/1999 18:48'!primitiveBigDivide	"Called with three LargePositiveInteger arguments, rem, div, quo. Divide div into rem and store the quotient into quo, leaving the remainder in rem."	"Assume: quo starts out filled with zeros."	| rem div quo |	self export: true.	quo _ interpreterProxy stackObjectValue: 0.	div _ interpreterProxy stackObjectValue: 1.	rem _ interpreterProxy stackObjectValue: 2.	interpreterProxy success:		(interpreterProxy fetchClassOf: rem) = interpreterProxy classLargePositiveInteger.	interpreterProxy success:		(interpreterProxy fetchClassOf: div) = interpreterProxy classLargePositiveInteger.	interpreterProxy success:		(interpreterProxy fetchClassOf: quo) = interpreterProxy classLargePositiveInteger.	interpreterProxy failed ifTrue:[^ nil].	dsaRemainder _ interpreterProxy firstIndexableField: rem.	dsaDivisor _ interpreterProxy firstIndexableField: div.	dsaQuotient _ interpreterProxy firstIndexableField: quo.	divisorDigitCount _ interpreterProxy stSizeOf: div.	remainderDigitCount _ interpreterProxy stSizeOf: rem.	"adjust pointers for base-1 indexing"	dsaRemainder _ dsaRemainder - 1.	dsaDivisor _ dsaDivisor - 1.	dsaQuotient _ dsaQuotient - 1.	self bigDivideLoop.	interpreterProxy pop: 3.! !!DSAPlugin methodsFor: 'primitives-integers' stamp: 'jm 12/21/1999 08:09'!primitiveBigMultiply	"Multiple f1 by f2, placing the result into prod. f1, f2, and prod must be LargePositiveIntegers, and the length of prod must be the sum of the lengths of f1 and f2."	"Assume: prod starts out filled with zeros"	| prod f2 f1 prodLen f1Len f2Len prodPtr f2Ptr f1Ptr digit carry k sum |	self export: true.	self var: #prodPtr declareC: 'unsigned char *prodPtr'.	self var: #f2Ptr declareC: 'unsigned char *f2Ptr'.	self var: #f1Ptr declareC: 'unsigned char *f1Ptr'.	prod _ interpreterProxy stackObjectValue: 0.	f2 _ interpreterProxy stackObjectValue: 1.	f1 _ interpreterProxy stackObjectValue: 2.	interpreterProxy success: (interpreterProxy isBytes: prod).	interpreterProxy success: (interpreterProxy isBytes: f2).	interpreterProxy success: (interpreterProxy isBytes: f1).	interpreterProxy success:		(interpreterProxy fetchClassOf: prod) = interpreterProxy classLargePositiveInteger.	interpreterProxy success:		(interpreterProxy fetchClassOf: f2) = interpreterProxy classLargePositiveInteger.	interpreterProxy success:		(interpreterProxy fetchClassOf: f1) = interpreterProxy classLargePositiveInteger.	interpreterProxy failed ifTrue:[^ nil].	prodLen _ interpreterProxy stSizeOf: prod.	f1Len _ interpreterProxy stSizeOf: f1.	f2Len _ interpreterProxy stSizeOf: f2.	interpreterProxy success: (prodLen = (f1Len + f2Len)).	interpreterProxy failed ifTrue:[^ nil].	prodPtr _ interpreterProxy firstIndexableField: prod.	f2Ptr _ interpreterProxy firstIndexableField: f2.	f1Ptr _ interpreterProxy firstIndexableField: f1.	0 to: f1Len-1 do: [:i | 		(digit _ f1Ptr at: i) ~= 0 ifTrue: [			carry _ 0.			k _ i.			"Loop invariants: 0 <= carry <= 16rFF, k = i + j - 1"			0 to: f2Len-1 do: [:j | 				sum _ ((f2Ptr at: j) * digit) + (prodPtr at: k) + carry.				carry _ sum bitShift: -8.				prodPtr at: k put: (sum bitAnd: 255).				k _ k + 1].			prodPtr at: k put: carry]].	interpreterProxy pop: 3.! !!DSAPlugin methodsFor: 'primitives-integers' stamp: 'jm 12/21/1999 09:31'!primitiveHighestNonZeroDigitIndex	"Called with one LargePositiveInteger argument. Answer the index of the top-most non-zero digit."	| arg bigIntPtr i |	self export: true.	self var: #bigIntPtr declareC: 'unsigned char *bigIntPtr'.	arg _ interpreterProxy stackObjectValue: 0.	interpreterProxy success:		(interpreterProxy fetchClassOf: arg) = interpreterProxy classLargePositiveInteger.	interpreterProxy failed ifTrue: [^ nil].	bigIntPtr _ interpreterProxy firstIndexableField: arg.	i _ interpreterProxy stSizeOf: arg.	[(i > 0) and: [(bigIntPtr at: (i _ i - 1)) = 0]]		whileTrue: ["scan down from end to first non-zero digit"].	interpreterProxy pop: 1.	interpreterProxy pushInteger: i + 1.! !!DSAPlugin methodsFor: 'private' stamp: 'jm 12/21/1999 08:10'!addBackDivisorDigitShift: digitShift	"Add back the divisor shifted left by the given number of digits. This is done only when the estimate of quotient digit was one larger than the correct value."	| carry rIndex sum |	carry _ 0.	rIndex _ digitShift + 1.	1 to: divisorDigitCount do: [:i |		sum _ (dsaRemainder at: rIndex) + (dsaDivisor at: i) + carry.		dsaRemainder at: rIndex put: (sum bitAnd: 16rFF).		carry _ sum bitShift: -8.		rIndex _ rIndex + 1].	"do final carry"	sum _ (dsaRemainder at: rIndex) + carry.	dsaRemainder at: rIndex put: (sum bitAnd: 16rFF).	"Note: There should be a final carry that cancels out the excess borrow."	"Assert: (sum bitShift: -8) ~= 1 ifTrue: [self halt: 'no carry!!']."! !!DSAPlugin methodsFor: 'private' stamp: 'jm 12/21/1999 18:48'!bigDivideLoop	"This is the core of the divide algorithm. This loop steps through the digit positions of the quotient, each time estimating the right quotient digit, subtracting from the remainder the divisor times the quotient digit shifted left by the appropriate number of digits. When the loop terminates, all digits of the quotient have been filled in and the remainder contains a value less than the divisor. The tricky bit is estimating the next quotient digit. Knuth shows that the digit estimate computed here will never be less than it should be and cannot be more than one over what it should be. Furthermore, the case where the estimate is one too large is extremely rare. For example, in a typical test of 100000 random 60-bit division problems, the rare case only occured five times. See Knuth, volume 2 ('Semi-Numerical Algorithms') 2nd edition, pp. 257-260"	| d1 d2 firstDigit firstTwoDigits thirdDigit q digitShift qTooBig |	"extract the top two digits of the divisor"	d1 _ dsaDivisor at: divisorDigitCount.	d2 _ dsaDivisor at: divisorDigitCount - 1.	remainderDigitCount to: divisorDigitCount + 1 by: -1 do: [:j |		"extract the top several digits of remainder."		firstDigit _ dsaRemainder at: j.		firstTwoDigits _ (firstDigit bitShift: 8) + (dsaRemainder at: j - 1).		thirdDigit _ dsaRemainder at: j - 2.		"estimate q, the next digit of the quotient"		firstDigit = d1			ifTrue: [q _ 255]			ifFalse: [q _ firstTwoDigits // d1].		"adjust the estimate of q if necessary"		(d2 * q) > (((firstTwoDigits - (q * d1)) bitShift: 8) + thirdDigit) ifTrue: [				q _ q - 1.			(d2 * q) > (((firstTwoDigits - (q * d1)) bitShift: 8) + thirdDigit) ifTrue: [				q _ q - 1]].		digitShift _ j - divisorDigitCount - 1.		q > 0 ifTrue: [			qTooBig _ self subtractDivisorMultipliedByDigit: q digitShift: digitShift.			qTooBig ifTrue: [  "this case is extremely rare"				self addBackDivisorDigitShift: digitShift.				q _ q - 1]].		"record this digit of the quotient"		dsaQuotient at: digitShift + 1 put: q].! !!DSAPlugin methodsFor: 'private' stamp: 'jm 12/21/1999 21:54'!leftRotate: anInteger by: bits	"Rotate the given 32-bit integer left by the given number of bits and answer the result."	self var: #anInteger declareC: 'unsigned int anInteger'.	^ (anInteger << bits) bitOr: (anInteger >> (32 - bits))! !!DSAPlugin methodsFor: 'private' stamp: 'jm 12/21/1999 08:13'!subtractDivisorMultipliedByDigit: digit digitShift: digitShift	"Multiply the divisor by the given digit (an integer in the range 0..255), shift it left by the given number of digits, and subtract the result from the current remainder. Answer true if there is an excess borrow, indicating that digit was one too large. (This case is quite rare.)"	| borrow rIndex prod resultDigit |	borrow _ 0.	rIndex _ digitShift + 1.	1 to: divisorDigitCount do: [:i |		prod _ ((dsaDivisor at: i) * digit) + borrow.		borrow _ prod bitShift: -8.		resultDigit _ (dsaRemainder at: rIndex) - (prod bitAnd: 16rFF).		resultDigit < 0 ifTrue: [  "borrow from the next digit"			resultDigit _ resultDigit + 256.			borrow _ borrow + 1].		dsaRemainder at: rIndex put: resultDigit.		rIndex _ rIndex + 1].	"propagate the final borrow if necessary"	borrow = 0 ifTrue: [^ false].	resultDigit _ (dsaRemainder at: rIndex) - borrow.	resultDigit < 0		ifTrue: [  "digit was too large (this case is quite rare)"			dsaRemainder at: rIndex put: resultDigit + 256.			^ true]		ifFalse: [			dsaRemainder at: rIndex put: resultDigit.			^ false].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DSAPlugin class	instanceVariableNames: ''!!DSAPlugin class methodsFor: 'plugin translation' stamp: 'jm 12/21/1999 09:33'!declareCVarsIn: cg	cg var: 'dsaRemainder' declareC: 'unsigned char *dsaRemainder'.	cg var: 'dsaDivisor' declareC:  'unsigned char *dsaDivisor'.	cg var: 'dsaQuotient' declareC: 'unsigned char *dsaQuotient'.! !!DSAPlugin class methodsFor: 'plugin translation' stamp: 'jm 12/14/1999 19:08'!moduleName	"Time millisecondsToRun: [		DSAPlugin translateDoInlining: true]"	^ 'dsaPlugin'! !Object subclass: #DigitalSignatureAlgorithm	instanceVariableNames: 'randKey randSeed '	classVariableNames: 'HighBitOfByte SmallPrimes '	poolDictionaries: ''	category: 'Digital Signatures'!!DigitalSignatureAlgorithm commentStamp: 'jm 12/14/1999 13:22' prior: 0!This class implements the Digital Signature Algorithm (DSA) of the U.S. government's "Digital Signature Standard" (DSS). The DSA algorithm was proposed in 1991 and became a standard in May 1994. The official description is available as a Federal Information Processing Standards Publication (FIPS PUB 186, May 19, 1994). A companion standard, the Secure Hash Standard, or SHS (FIPS PUB 180-1, April 17, 1995), describes a 160-bit message digest algorithm known as the Secure Hash Algorithm (SHA). This message digest is used to compute the document signature.Here's how to use it:  1. The "signer" creates a pair of keys. One of these must be kept private. The other may be freely distributed. For example, it could be built into the signature checking code of an application.  2. When the signer wishes to sign a packet of data (a "message") , he uses the secure hash algorithm to create a 160-bit message digest (hash) which is used as the input to DSA. The result of this is a pair of large numbers called a "signature" that is attached to the original message.  3. When someone receives a signed message purported to have come from the signer, they compute the 160-bit hash of the message and pass that, along with the message signature and the signer's public key, to the signature verification algorithm. If the signature checks, then it is virtually guaranteed that the message originated from someone who had the signer's private key. That is, the message is not a forgery and has not been modified since it was signed. For example, if the message contains a program, and the recipient trusts the signer, then the recipient can run the program with the assurance that it won't do anything harmful. (At least, not intentionally. A digital signature is no guarantee against bugs!! :->)The signer must keep the private key secure, since anyone who has the private key can forge the signer's signature on any message they like. As long as the secret key is not stolen, cryptographers believe it to be virtually impossible either to forge a signature, to find a message that matches an existing sigature, or to discover the signer's private key by analyzing message signatures. Knowing the public key (which, for example, could be recovered from an application that had it built in), does not weaken the security at all.An excellent reference work on digital signatures and cryptography in general is:  Schneier, Bruce  "Applied Cryptography: Protocols, Algorithms, and Source Code in C"  John Wiley and Sons, 1996.I used this book as a guide to implementing many of the numerical algorithms required by DSA.Patents and Export Restrictions:Many digital signature technologies are patented. DSA is also patented, but the patent is owned by the U.S. government which has made DSA available royalty-free. There is a claim that the government patent infringes on an earlier patent by Schnorr, but the government is requiring the use of DSA, so they apparently believe this claim is not strong enough to be a serious threat to their own patent.Most cryptography technology, including digital signature technology, requires an export license for it to be distributed outside the U.S. Recent legislation may have relaxed the export license requirements, but it would be prudent to check the current regulations before exporting this code.!!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jm 12/14/1999 13:22'!initRandom: randomInteger	"Initialize the the secure random number generator with the given value. The argument should be a positive integer of up to 512 bits chosen randomly to avoid someone being able to predict the sequence of random values generated."	"Note: The random generator must be initialized before generating a key set or signature. Signature verification does not require initialization of the random generator."	randSeed _ 16rEFCDAB8998BADCFE10325476C3D2E1F067452301.  "initial seed"	randKey _ randomInteger.! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jm 12/12/1999 23:08'!initRandomFromUser	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s _ FillInTheBlank request: 'Enter a long random string to seed the random generator.'.	k _ LargePositiveInteger new: (s size min: 64).	srcIndex _ 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex _ srcIndex + 1)) asciiValue].	k _ k + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k _ k bitShift: k highBit - 512].	self initRandom: k.! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/22/1999 11:35'!computeSignatureForMessageHash: hash privateKey: privateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p _ privateKey first.	q _ privateKey second.	g _ privateKey third.	x _ privateKey fourth.	r _ s _ 0.	[r = 0 or: [s = 0]] whileTrue: [		k _ self remainder: self nextRandom160 mod: q.		r _ self remainder: (self raise: g to: k mod: p) mod: q.		tmp _ self remainder: (hash + (x * r)) mod: q.		s _ self remainder: ((self inverseOf: k mod: q) * tmp) mod: q].	^ Array with: r with: s! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/21/1999 19:05'!generateKeySet	"Generate and answer a key set for DSA. The result is a pair (<private key><public key>). Each key is an array of four large integers. The private key is (p, q, g, x); the public one is (p, q, g, y). The signer must be sure to record (p, q, g, x), and must keep x secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	| qAndPandS q p exp g h x y |	qAndPandS _ self generateQandP.	Transcript show: 'Computing g...'.	q _ qAndPandS first.	p _ qAndPandS second.	exp _ (p - 1) / q.	h _ 2.	[g _ self raise: h to: exp mod: p. g = 1] whileTrue: [h _ h + 1].	Transcript show: 'done.'; cr.	Transcript show: 'Computing x and y...'.	x _ self nextRandom160.	y _ self raise: g to: x mod: p.	Transcript show: 'done.'; cr.	Transcript show: 'Key generation complete!!'; cr.	^ Array		with: (Array with: p with: q with: g with: x)		with: (Array with: p with: q with: g with: y)! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 13:34'!signatureToString: aSignature	"Answer a string representation of the given signature. This string can be parsed using the stringToSignature: method."	| s hex |	s _ WriteStream on: (String new: 2000).	s nextPutAll: '[DSA digital signature '.	hex _ aSignature first printStringBase: 16.	s nextPutAll: (hex copyFrom: 4 to: hex size).	s space.	hex _ aSignature second printStringBase: 16.	s nextPutAll: (hex copyFrom: 4 to: hex size).	s nextPutAll: ']'.	^ s contents! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 13:33'!stringToSignature: aString	"Answer the signature stored in the given string. A signature string has the format:		 '[DSA digital signature <r> <s>]'	where <r> and <s> are large positive integers represented by strings of hexidecimal digits."	| prefix stream r s |	prefix _ '[DSA digital signature '.	(aString beginsWith: prefix) ifFalse: [self error: 'bad signature prefix'].	stream _ ReadStream on: aString.	stream position: prefix size.	r _ Integer readFrom: stream base: 16.	stream next.	s _ Integer readFrom: stream base: 16.	^ Array with: r with: s! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/22/1999 11:40'!verifySignature: aSignature ofMessageHash: hash publicKey: publicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p _ publicKey first.	q _ publicKey second.	g _ publicKey third.	y _ publicKey fourth.	r _ aSignature first.	s _ aSignature last.	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"	w _ self inverseOf: s mod: q.	u1 _ self remainder: (hash * w) mod: q.	u2 _ self remainder: (r * w) mod: q.	v0 _ (self raise: g to: u1 mod: p) * (self raise: y to: u2 mod: p).	v _ self remainder: (self remainder: v0 mod: p) mod: q.	^ v = r! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/21/1999 18:39'!divide: x by: y	"Answer the result of dividing x by y, where x and y are both large positive integers, typically very large ones. The result is the pair (quotient, remainder)."	"Assume: x and y are both positive integers of at least two digits."	"DSAPlugin divide: 10000 by: 1000"	| remainder divisor shift quotient  |	remainder _ x.	divisor _ y.	"Pre-scale operands so the divisor's top digit is >= 128. This makes it	 possible to estimate the next digit of the division with very high	 probability that the first guess is correct. Knuth says so!!"	shift _ 8 - (HighBitOfByte at: ((divisor digitAt: divisor digitLength) + 1)).	shift > 0 ifTrue: [		remainder _ remainder bitShift: shift.		divisor _ divisor bitShift: shift].	"copy remainder with a leading zero and allocate quotient"	remainder _ remainder		copyto: (LargePositiveInteger new: remainder digitLength + 1).	divisor digitLength < 5 ifTrue: [divisor _ self asLargePositiveInteger: divisor].	quotient _ LargePositiveInteger new: remainder digitLength - divisor digitLength.	"do the actual division"	self primDivideLoopPrimRem: remainder div: divisor quo: quotient.	"normalize quotient and rescale remainder if necessary"	quotient _ self normalize: quotient.	shift > 0		ifTrue: [remainder _ remainder bitShift: shift negated]		ifFalse: [remainder _ self normalize: remainder].	^ Array with: quotient with: remainder! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/9/1999 21:49'!inverseOf: x mod: n	"Answer the inverse of x modulus n. That is, the integer y such that (x * y) \\ n is 1. Both x and n must be positive, and it is assumed that x < n and that x and n are integers."	"Details: Use the extended Euclidean algorithm, Schneier, p. 247."	| v u k u1 u2 u3 t1 t2 t3 tmp |	((x <= 0) or: [n <= 0]) ifTrue: [self error: 'x and n must be greater than zero'].	x >= n ifTrue: [self error: 'x must be < n'].	v _ x.	u _ n.	k _ 0.	[x even and: [n even and: [u > 0]]] whileTrue: [  "eliminate common factors of two"		k _ k + 1.		u _ u bitShift: -1.		v _ v bitShift: -1].	u1 _ 1. u2 _ 0. u3 _ u.	t1 _ v. t2 _ u - 1. t3 _ v.	[	[u3 even ifTrue: [			((u1 odd) or: [u2 odd]) ifTrue: [				u1 _ u1 + v.				u2 _ u2 + u].			u1 _ u1 bitShift: -1.			u2 _ u2 bitShift: -1.			u3 _ u3 bitShift: -1].		((t3 even) or: [u3 < t3]) ifTrue: [			tmp _ u1. u1 _ t1. t1 _ tmp.			tmp _ u2. u2 _ t2. t2 _ tmp.			tmp _ u3. u3 _ t3. t3 _ tmp].		u3 even and: [u3 > 0]] whileTrue: ["loop while u3 is even"].		[((u1 < t1) or: [u2 < t2]) and: [u1 > 0]] whileTrue: [			u1 _ u1 + v.			u2 _ u2 + u].			u1 _ u1 - t1.		u2 _ u2 - t2.		u3 _ u3 - t3.		t3 > 0] whileTrue: ["loop while t3 > 0"].	[u1 >= v and: [u2 >= u]] whileTrue: [		u1 _ u1 - v.		u2 _ u2 - u].	u1 _ u1 bitShift: k.	u2 _ u2 bitShift: k.	u3 _ u3 bitShift: k.	u3 = 1 ifFalse: [self error: 'no inverse'].	^ u - u2! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/22/1999 11:36'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations _ 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes _ Integer primesUpTo: 2000.		SmallPrimes _ SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor _ SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ false].	pMinusOne _ p - 1.	b _ self logOfLargestPowerOfTwoDividing: pMinusOne.	m _ pMinusOne // (2 raisedTo: b).	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r _ Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a _ (r next * 16rFFFFFF) truncated.		j _ 0.		z _ self raise: a to: m mod: p.		couldBePrime _ z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime _ true]				ifFalse: [					(j _ j + 1) < b						ifTrue: [z _ self remainder: (z * z) mod: p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/21/1999 18:03'!multiply: x by: y	"Answer the product of x and y using the fast large integer multiply primitive."	| f1 f2 product |	"ensure factors are large integers"	f1 _ x.  f2 _ y.	f1 class == SmallInteger ifTrue: [f1 _ self asLargePositiveInteger: f1].	f2 class == SmallInteger ifTrue: [f2 _ self asLargePositiveInteger: f2].	"allocate large integer to hold the result"	product _ Integer		new: f1 digitLength + f2 digitLength		neg: (x sign * y sign) < 0.	f1 digitLength < f2 digitLength		ifTrue: [self primDigitMultiply: f1 with: f2 into: product]		ifFalse: [self primDigitMultiply: f2 with: f1 into: product].	^ self normalize: product! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/21/1999 18:09'!normalize: aLargeInteger	"Answer the given large integer or a copy of it without leading zero digits."	| len out |	len _ self primHighestNonZeroDigitIndex: aLargeInteger.	len = aLargeInteger digitLength ifTrue: [^ aLargeInteger].	out _ aLargeInteger class new: len.	out replaceFrom: 1 to: len with: aLargeInteger startingAt: 1.	^ out! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/21/1999 17:54'!raise: x to: y mod: n	"Answer ((x raisedTo: y) \\ n) for integers x, y and n, but computed efficiently when x, y, and n are very large positive integers. From Schneier, p. 244."	| s t u |	s _ 1.	t _ x.	u _ y.	[u = 0] whileFalse: [		u odd ifTrue: [			s _ self multiply: s by: t.			s >= n ifTrue: [s _ self remainder: s mod: n]].		t _ self multiply: t by: t.		t >= n ifTrue: [t _ self remainder: t mod: n].		u _ u bitShift: -1].	^ s! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/21/1999 17:53'!remainder: x mod: y	"Answer the remainder of dividing x by y, where x and y are both large positive integers of at least two digits."	| remainder divisor shift quotient  |	remainder _ x.	divisor _ y.	"Pre-scale operands so the divisor's top digit is >= 128. This makes it	 possible to estimate the next digit of the division with very high	 probability that the first guess is correct. Knuth says so!!"	shift _ 8 - (HighBitOfByte at: (divisor digitAt: divisor digitLength)).	shift > 0 ifTrue: [		remainder _ remainder bitShift: shift.		divisor _ divisor bitShift: shift].	"copy remainder with a leading zero and allocate quotient"	remainder _ remainder		copyto: (LargePositiveInteger new: remainder digitLength + 1).	divisor digitLength < 5 ifTrue: [divisor _ self asLargePositiveInteger: divisor].	quotient _ LargePositiveInteger new: remainder digitLength - divisor digitLength.	"do the actual division"	self primDivideLoopPrimRem: remainder div: divisor quo: quotient.	"rescale or normalize the remainder"	shift > 0		ifTrue: [remainder _ remainder bitShift: shift negated]		ifFalse: [remainder _ self normalize: remainder].	^ remainder! !!DigitalSignatureAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 17:35'!primDigitMultiply: x with: y into: product	"Multiple x by y, placing the result into product. Assume that x, y, and product are all large integers and that product starts out filled with zero digits."	<primitive: 'primitiveBigMultiply' module: 'DSAPrims'>	^ self primitiveFailed! !!DigitalSignatureAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 17:34'!primDivideLoopPrimRem: remainder div: divisor quo: quotient	"Perform the inner loop of long division. Assume that remainder, divisor, and quotient are all LargePositiveIntegers of two or more digits, and that quotient is non-zero and has enough digits to hold the result. Initially, remainder holds the total to be divided by the divisor and the quotient contains all zero digits. On successful completion, the remainder and quotient have been computed in place."	<primitive: 'primitiveBigDivide' module: 'DSAPrims'>	^ self primitiveFailed! !!DigitalSignatureAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 17:36'!primHighestNonZeroDigitIndex: aLargeInteger	"Answer the index of the highest non-zero digit of the argument, which is assumed to be a large positive or negative integer. Used to eliminate leading zeros from calculation results."	<primitive: 'primitiveHighestNonZeroDigitIndex' module: 'DSAPrims'>	^ self primitiveFailed! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 17:19'!asLargePositiveInteger: anInteger	"Answer the argument integer as a LargePositiveInteger."	| sz out |	sz _ anInteger digitLength.	out _ LargePositiveInteger new: sz.	1 to: sz do: [:i | out digitAt: i put: (anInteger digitAt: i)].	^ out! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/22/1999 11:35'!generateQandP	"Generate the two industrial-grade primes, q (160-bits) and p (512-bit) needed to build a key set. Answer the array (q, p, s), where s is the seed that from which q and p were created. This seed is normally discarded, but can be used to verify the key generation process if desired."	| pBits halfTwoToTheP chunkCount sAndq q twoQ n c w x p s |	pBits _ 512.  "desired size of p in bits"	halfTwoToTheP _ 2 raisedTo: (pBits - 1).	chunkCount _ pBits // 160.	Transcript show: 'Searching for primes q and p...'; cr.	[true] whileTrue: [		sAndq _ self generateSandQ.		Transcript show: '  Found a candidate q.'; cr.		s _ sAndq first.		q _ sAndq last.		twoQ _ q bitShift: 1.		n _ 2.		c _ 0.		[c < 4096] whileTrue: [			w _ self generateRandomLength: pBits s: s n: n.			x _ w + halfTwoToTheP.			p _ (x - (self remainder: x mod: twoQ)) + 1.			p highBit = pBits ifTrue: [				Transcript show: '    Testing potential p ', (c + 1) printString, '...'; cr.				(self isProbablyPrime: p) ifTrue: [					Transcript show: '  Found p!!'; cr.					^ Array with: q with: p with: s]].			n _ n + chunkCount + 1.			c _ c + 1]].! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 16:36'!generateRandomLength: bitLength s: s n: n	"Answer a random number of bitLength bits generated using the secure hash algorithm."	| sha out count extraBits v |	sha _ SecureHashAlgorithm new.	out _ 0.	count _ (bitLength // 160).	extraBits _ bitLength - (count * 160).	0 to: count do: [:k |		v _ sha hashInteger: (s + n + k).		k = count ifTrue: [			v _ v - ((v >> extraBits) << extraBits)].		out _ out bitOr: (v bitShift: (160 * k))].	^ out! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/22/1999 11:36'!generateSandQ	"Generate a 160-bit random seed s and an industrial grade prime q."	| hasher s sPlusOne u q |	hasher _ SecureHashAlgorithm new.	[true] whileTrue: [		s _ self nextRandom160.		sPlusOne _ s + 1.		sPlusOne highBit > 160 ifTrue: [self remainder: sPlusOne mod: (2 raisedTo: 160)].		u _ (hasher hashInteger: s) bitXor: (hasher hashInteger: sPlusOne).		q _ u bitOr: ((1 bitShift: 159) bitOr: 1).		(self isProbablyPrime: q) ifTrue: [^ Array with: s with: q]].! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 11:12'!logOfLargestPowerOfTwoDividing: aPositiveInteger	"Answer the base-2 log of the largest power of two that divides the given integer. For example, the largest power of two that divides 24 is 8, whose log base-2 is 3. Do this efficiently even when the given number is a large integer. Assume that the given integer is > 0."	"DigitalSignatureAlgorithm new largestPowerOfTwoDividing: (32 * 3)"	| digitIndex power d |	digitIndex _ (1 to: aPositiveInteger digitLength) detect: [:i | (aPositiveInteger digitAt: i) ~= 0].	power _ (digitIndex - 1) * 8.	d _ aPositiveInteger digitAt: digitIndex.	[d odd] whileFalse: [		power _ power + 1.		d _ d bitShift: -1].	^ power! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 14:39'!nextRandom160	"Answer a newly generated 160-bit random number in the range [1..(2^160 - 1)]."	"Details: Try again in the extremely unlikely chance that zero is encountered."	| result |	result _ 0.	[result = 0] whileTrue: [		result _ SecureHashAlgorithm new hashInteger: randKey seed: randSeed.		randKey _ randKey + result + 1].	^ result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DigitalSignatureAlgorithm class	instanceVariableNames: ''!!DigitalSignatureAlgorithm class methodsFor: 'class initialization' stamp: 'jm 12/21/1999 19:15'!initialize	"DigitalSignatureAlgorithm initialize"	"SmallPrimes is a list of small primes greater than two."	SmallPrimes _ Integer primesUpTo: 2000.	SmallPrimes _ SmallPrimes copyFrom: 2 to: SmallPrimes size.	"HighBitOfByte maps a byte to the index of its top non-zero bit."	HighBitOfByte _ (0 to: 255) collect: [:byte | byte highBit].! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:30'!generateKeySet	"Generate and answer a key set for code signing. The result is a pair (<private key><public key>). Each key is an array of four large integers. The signer must be sure to record this keys set and must keep the private key secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	"Note: Unguessable random numbers are needed for key generation. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before generating a key set. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	"DigitalSignatureAlgorithm generateKeySet"	| dsa |	dsa _ DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	^ dsa generateKeySet! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:18'!sign: aStringOrStream privateKey: privateKey	"Sign the given message (a stream or string) and answer a signature string."	"Note: Unguessable random numbers are needed for message signing. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before signing a message. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	| dsa hasher h sig |	dsa _ DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	hasher _ SecureHashAlgorithm new.	(aStringOrStream class isBytes)		ifTrue: [h _ hasher hashMessage: aStringOrStream]		ifFalse: [h _ hasher hashStream: aStringOrStream].	sig _ dsa computeSignatureForMessageHash: h privateKey: privateKey.	^ dsa signatureToString: sig! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:20'!verify: signatureString isSignatureOf: aStringOrStream publicKey: publicKey	"Answer true if the given signature string signs the given message (a stream or string)."	"Note: Random numbers are not needed for signature verification; thus, there is no need to call initRandomFromUser before verifying a signature."	| dsa hasher h sig |	dsa _ DigitalSignatureAlgorithm new.	hasher _ SecureHashAlgorithm new.	(aStringOrStream class isBytes)		ifTrue: [h _ hasher hashMessage: aStringOrStream]		ifFalse: [h _ hasher hashStream: aStringOrStream].	sig _ dsa stringToSignature: signatureString.	^ dsa verifySignature: sig ofMessageHash: h publicKey: publicKey! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'jm 12/22/1999 11:23'!example	"Example of signing a message and verifying its signature."	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm example"	| msg keys sig |	msg _ 'This is a test...'.	keys _ self testKeySet.	sig _ self sign: msg privateKey: keys first.	self inform: 'Signature created'.	(self verify: sig isSignatureOf: msg publicKey: keys last)		ifTrue: [self inform: 'Signature verified.']		ifFalse: [self error: 'ERROR!! Signature verification failed'].! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'jm 12/22/1999 11:28'!testKeySet	"Answer a pair of keys for testing. The first key is the private key, the second one is the public key."	"WARNING: This test key set is public should be used only for testing!! In a real application, the user would create a set of keys using generateKeySet and would keep the private key secret."	^ #(		(8343811888543852523216773185009428259187948644369498021763210776677854991854533186365944349987509452133156416880596803846631577352387751880552969116768071 1197175832754339660404549606408619548226315875117 1433467472198821951822151391684734233265646022897503720591270330985699984763922266163182803556189497900262038518780931942996381297743579119123094520048965 957348690772296812)		(8343811888543852523216773185009428259187948644369498021763210776677854991854533186365944349987509452133156416880596803846631577352387751880552969116768071 1197175832754339660404549606408619548226315875117 1433467472198821951822151391684734233265646022897503720591270330985699984763922266163182803556189497900262038518780931942996381297743579119123094520048965 4645213122572190617807944614677917601101008235397095646475699959851618402406173485853587185431290863173614335452934961425661774118334228449202337038283799))! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'jm 12/21/1999 18:46'!exerciseDivide: iterationCount	"Exercise the divide primitive on iterationCount pairs of random 60 bit integers."	"DigitalSignatureAlgorithm exerciseDivide: 10000"	| dsa r c d tmp pair |	dsa _ DigitalSignatureAlgorithm new.	r _ Random new.	iterationCount timesRepeat: [		c _ ((r next * 16r3FFFFFFF highBit) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		d _ ((r next * 16r3FFFFFFF) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		c < d ifTrue: [tmp _ c. c _ d. d _ tmp].		pair _ dsa divide: c by: d.		pair first = (c // d) ifFalse: [self error: 'bad quotient'].		pair second = (c \\ d) ifFalse: [self error: 'bad remainder']].	self inform: 'divide passed ', iterationCount printString, ' tests'.! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'jm 12/21/1999 18:58'!exerciseMultiply: iterationCount	"Exercise the multiply primitive on iterationCount pairs of random 60 bit integers."	"DigitalSignatureAlgorithm exerciseMultiply: 10000"	| dsa r x y product |	dsa _ DigitalSignatureAlgorithm new.	r _ Random new.	iterationCount timesRepeat: [		x _ ((r next * 16r3FFFFFFF highBit) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		y _ ((r next * 16r3FFFFFFF) asInteger bitShift: 30) +			 (r next * 16r3FFFFFFF) asInteger.		product _ dsa multiply: x by: y.		product = (x * y) ifFalse: [self error: 'bad product']].	self inform: 'multiply passed ', iterationCount printString, ' tests'.! !!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'jm 12/21/1999 18:54'!exerciseRareCaseDivides	"The follow pairs of numbers exercise a very rare case in the divide code."	"DigitalSignatureAlgorithm exerciseRareCaseDivides"	| dsa x y result |	dsa _ DigitalSignatureAlgorithm new.	#((1832218686 4583075)	   (523616514 1170198)	   (2004265174 222697382)	   (946291092 16898368)	   (484650860 2202979)	   (367540221 10501267)	   (1921328186 17626969)	   (2137533470 237504433)	   (4344326861102001986 173775161299117524)	   (4327536487058529168 1442517738695691206)	   (3705760221957076390 90385633403416087)	   (4343990903983304523 13967821852761865)	   (4611268610911433200 547007020913498)	   (3551468784674751209 9546996743334032)) do: [:pair |			x _ pair first.			y _ pair second.			result _ dsa divide: x by: y.			result first = (x // y) ifFalse: [self error: 'bad quotient'].			result second = (x \\ y) ifFalse: [self error: 'bad remainder']].	self inform: 'divide passed rare case tests'.! !Object subclass: #SecureHashAlgorithm	instanceVariableNames: 'totalA totalB totalC totalD totalE totals '	classVariableNames: 'K1 K2 K3 K4 '	poolDictionaries: ''	category: 'Digital Signatures'!!SecureHashAlgorithm commentStamp: 'jm 12/14/1999 11:52' prior: 0!This class implements the Secure Hash Algorithm (SHA) described in the U.S. government's Secure Hash Standard (SHS). This standard is described in FIPS PUB 180-1, "SECURE HASH STANDARD", April 17, 1995.The Secure Hash Algorithm is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996.See the comment in class DigitalSignatureAlgorithm for details on its use.Implementation notes:The secure hash standard was created with 32-bit hardware in mind. All arithmetic in the hash computation must be done modulo 2^32. This implementation uses ThirtyTwoBitRegister objects to simulate hardware registers; this implementation is about six times faster than using LargePositiveIntegers (measured on a Macintosh G3 Powerbook). Implementing a primitive to process each 64-byte buffer would probably speed up the computation by a factor of 20 or more.!!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:56'!hashInteger: aPositiveInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in key generation."	| buffer dstIndex |	self initializeTotals.	"pad integer with zeros"	aPositiveInteger highBit <= 512		ifFalse: [self error: 'integer cannot exceed 512 bits'].	buffer _ ByteArray new: 64.	dstIndex _ 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex _ dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/21/1999 19:39'!hashInteger: aPositiveInteger seed: seedInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in the production of random numbers"	| buffer dstIndex |	"Initialize totalA through totalE to their seed values."	totalA _ ThirtyTwoBitRegister new		load: ((seedInteger bitShift: - 128) bitAnd: 16rFFFFFFFF).	totalB _ ThirtyTwoBitRegister new		load: ((seedInteger bitShift: - 96) bitAnd: 16rFFFFFFFF).	totalC _ ThirtyTwoBitRegister new		load: ((seedInteger bitShift: - 64) bitAnd: 16rFFFFFFFF).	totalD _ ThirtyTwoBitRegister new		load: ((seedInteger bitShift: - 32) bitAnd: 16rFFFFFFFF).	totalE _ ThirtyTwoBitRegister new		load: (seedInteger bitAnd: 16rFFFFFFFF).	self initializeTotalsArray.	"pad integer with zeros"	buffer _ ByteArray new: 64.	dstIndex _ 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex _ dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:28'!hashMessage: aStringOrByteArray	"Hash the given message using the Secure Hash Algorithm."	^ self hashStream: (ReadStream on: aStringOrByteArray asByteArray)! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:41'!hashStream: aPositionableStream	"Hash the contents of the given stream from the current position to the end using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."	"SecureHashAlgorithm new hashStream: (ReadStream on: 'foo')"	| startPosition buf bitLength |	self initializeTotals.	aPositionableStream atEnd ifTrue: [self error: 'empty stream'].	startPosition _ aPositionableStream position.	[aPositionableStream atEnd] whileFalse: [		buf _ aPositionableStream next: 64.		(aPositionableStream atEnd not and: [buf size = 64])			ifTrue: [self processBuffer: buf]			ifFalse: [				bitLength _ (aPositionableStream position - startPosition) * 8.				self processFinalBuffer: buf bitLength: bitLength]].	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 20:11'!primExpandBlock: aByteArray into: wordBitmap	"Expand the given 64-byte buffer into the given Bitmap of length 80."	<primitive: 'primitiveExpandBlock' module: 'DSAPrims'>	^ self primitiveFailed! !!SecureHashAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 22:58'!primHasSecureHashPrimitive	"Answer true if this platform has primitive support for the Secure Hash Algorithm."	<primitive: 'primitiveHasSecureHashPrimitive' module: 'DSAPrims'>	^ false! !!SecureHashAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 20:13'!primHashBlock: blockBitmap using: workingTotalsBitmap	"Hash the given block (a Bitmap) of 80 32-bit words, using the given workingTotals."	<primitive: 'primitiveHashBlock' module: 'DSAPrims'>	^ self primitiveFailed! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/7/1999 23:25'!constantForStep: i	"Answer the constant for the i-th step of the block hash loop. We number our steps 1-80, versus the 0-79 of the standard."	i <= 20 ifTrue: [^ K1].	i <= 40 ifTrue: [^ K2].	i <= 60 ifTrue: [^ K3].	^ K4! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 20:06'!expandedBlock: aByteArray	"Convert the given 64 byte buffer into 80 32-bit registers and answer the result." 	| out src v |	out _ Array new: 80.	src _ 1.	1 to: 16 do: [:i |		out at: i put: (ThirtyTwoBitRegister new loadFrom: aByteArray at: src).		src _ src + 4].	17 to: 80 do: [:i |		v _ (out at: i - 3) copy.		v	bitXor: (out at: i - 8);			bitXor: (out at: i - 14);			bitXor: (out at: i - 16);			leftRotateBy: 1.		out at: i put: v].	^ out! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 20:02'!finalHash	"Concatenate the final totals to build the 160-bit integer result."	"Details: If the primitives are supported, the results are in the totals array. Otherwise, they are in the instance variables totalA through totalE."	| r |	totals ifNil: [  "compute final hash when not using primitives"		^ (totalA asInteger bitShift: 128) +		  (totalB asInteger bitShift:  96) +		  (totalC asInteger bitShift:  64) +		  (totalD asInteger bitShift:  32) +		  (totalE asInteger)].	"compute final hash when using primitives"	r _ 0.	1 to: 5 do: [:i |		r _ r bitOr: ((totals at: i) bitShift: (32 * (5 - i)))].	^ r! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/7/1999 22:15'!hashFunction: i of: x with: y with: z	"Compute the hash function for the i-th step of the block hash loop. We number our steps 1-80, versus the 0-79 of the standard."	"Details: There are four functions, one for each 20 iterations. The second and fourth are the same."	i <= 20 ifTrue: [^ x copy bitAnd: y; bitOr: (x copy bitInvert; bitAnd: z)].	i <= 40 ifTrue: [^ x copy bitXor: y; bitXor: z].	i <= 60 ifTrue: [^ x copy bitAnd: y; bitOr: (x copy bitAnd: z); bitOr: (y copy bitAnd: z)].	^ x copy bitXor: y; bitXor: z! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:38'!initializeTotals	"Initialize totalA through totalE to their seed values."	"total registers for use when primitives are absent"	totalA _ ThirtyTwoBitRegister new load: 16r67452301.	totalB _ ThirtyTwoBitRegister new load: 16rEFCDAB89.	totalC _ ThirtyTwoBitRegister new load: 16r98BADCFE.	totalD _ ThirtyTwoBitRegister new load: 16r10325476.	totalE _ ThirtyTwoBitRegister new load: 16rC3D2E1F0.	self initializeTotalsArray.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:38'!initializeTotalsArray	"Initialize the totals array from the registers for use with the primitives."	totals _ Bitmap new: 5.	totals at: 1 put: totalA asInteger.	totals at: 2 put: totalB asInteger.	totals at: 3 put: totalC asInteger.	totals at: 4 put: totalD asInteger.	totals at: 5 put: totalE asInteger.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:43'!processBuffer: aByteArray	"Process given 64-byte buffer, accumulating the results in totalA through totalE."	| a b c d e w tmp |	self primHasSecureHashPrimitive		ifTrue: [^ self processBufferUsingPrimitives: aByteArray]		ifFalse: [totals _ nil].	"initialize registers a through e from the current totals" 	a _ totalA copy.	b _ totalB copy.	c _ totalC copy.	d _ totalD copy.	e _ totalE copy.	"expand and process the buffer"	w _ self expandedBlock: aByteArray.	1 to: 80 do: [:i |		tmp _ (a copy leftRotateBy: 5)			+= (self hashFunction: i of: b with: c with: d);			+= e;			+= (w at: i);			+= (self constantForStep: i).		e _ d.		d _ c.		c _ b copy leftRotateBy: 30.		b _ a.		a _ tmp].	"add a through e into total accumulators"	totalA += a.	totalB += b.	totalC += c.	totalD += d.	totalE += e.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 23:32'!processBufferUsingPrimitives: aByteArray	"Process given 64-byte buffer using the primitives, accumulating the results in totals."	| w |	"expand and process the buffer"	w _ Bitmap new: 80.	self primExpandBlock: aByteArray into: w.	self primHashBlock: w using: totals.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/14/1999 11:40'!processFinalBuffer: buffer bitLength: bitLength	"Process given buffer, whose length may be <= 64 bytes, accumulating the results in totalA through totalE. Also process the final padding bits and length."	| out |	out _ ByteArray new: 64.	out replaceFrom: 1 to: buffer size with: buffer startingAt: 1.	buffer size < 56 ifTrue: [  "padding and length fit in last data block"		out at: buffer size + 1 put: 128.  "trailing one bit"		self storeLength: bitLength in: out.  "end with length"		self processBuffer: out.		^ self].	"process the final data block"	buffer size < 64 ifTrue: [		out at: buffer size + 1 put: 128].  "trailing one bit"	self processBuffer: out.	"process one additional block of padding ending with the length"	out _ ByteArray new: 64.  "filled with zeros"	buffer size = 64 ifTrue: [		"add trailing one bit that didn't fit in final data block"		out at: 1 put: 128].	self storeLength: bitLength in: out.	self processBuffer: out.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/14/1999 11:10'!storeLength: bitLength in: aByteArray	"Fill in the final 8 bytes of the given ByteArray with a 64-bit big-endian representation of the original message length in bits."	| n i |	n _ bitLength.	i _ aByteArray size.	[n > 0] whileTrue: [		aByteArray at: i put: (n bitAnd: 16rFF).		n _ n bitShift: -8.		i _ i - 1].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SecureHashAlgorithm class	instanceVariableNames: ''!!SecureHashAlgorithm class methodsFor: 'class initialization' stamp: 'jm 12/7/1999 23:25'!initialize	"SecureHashAlgorithm initialize"	"For the curious, here's where these constants come from:	  #(2 3 5 10) collect: [:x | ((x sqrt / 4.0) * (2.0 raisedTo: 32)) truncated hex]"	K1 _ ThirtyTwoBitRegister new load: 16r5A827999.	K2 _ ThirtyTwoBitRegister new load: 16r6ED9EBA1.	K3 _ ThirtyTwoBitRegister new load: 16r8F1BBCDC.	K4 _ ThirtyTwoBitRegister new load: 16rCA62C1D6.! !!SecureHashAlgorithm class methodsFor: 'examples' stamp: 'jm 12/7/1999 23:26'!example	"Here are the first two examples from the specification document (FIPS PUB 180-1)."	"SecureHashAlgorithm example"	| hash |	hash _ SecureHashAlgorithm new hashMessage: 'abc'.	hash = 16rA9993E364706816ABA3E25717850C26C9CD0D89D		ifTrue: [self inform: 'Passed Test #1']		ifFalse: [self error: 'Test #1 failed!!'].	hash _ SecureHashAlgorithm new hashMessage:		'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'.	hash = 16r84983E441C3BD26EBAAE4AA1F95129E5E54670F1 		ifTrue: [self inform: 'Passed Test #2']		ifFalse: [self error: 'Test #2 failed!!'].! !!SecureHashAlgorithm class methodsFor: 'examples' stamp: 'jm 12/14/1999 11:45'!example2	"Here is the third example from the specification document (FIPS PUB 180-1). This example may take several minutes."	"SecureHashAlgorithm example2"	| hash |	hash _ SecureHashAlgorithm new hashMessage: (String new: 1000000 withAll: $a).	hash = 16r34AA973CD4C4DAA4F61EEB2BDBAD27316534016F		ifTrue: [self inform: 'Passed Test #3']		ifFalse: [self error: 'Test #3 failed!!'].! !Object subclass: #ThirtyTwoBitRegister	instanceVariableNames: 'hi low '	classVariableNames: ''	poolDictionaries: ''	category: 'Digital Signatures'!!ThirtyTwoBitRegister commentStamp: 'jm 12/22/1999 10:37' prior: 0!I represent a 32-bit register. An instance of me can hold any non-negative integer in the range [0..(2^32 - 1)]. Operations are performed on my contents in place, like a hardware register, and results are always modulo 2^32.This class is primarily meant for use by the SecureHashAlgorithm class.!!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/14/1999 16:03'!asInteger	"Answer the integer value of my current contents."	^ (hi bitShift: 16) + low! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/7/1999 15:26'!hi	^ hi! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/14/1999 16:07'!load: anInteger	"Set my contents to the value of given integer."	low _ anInteger bitAnd: 16rFFFF.	hi _ (anInteger bitShift: -16) bitAnd: 16rFFFF.	self asInteger = anInteger		ifFalse: [self error: 'out of range: ', anInteger printString].! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/14/1999 16:07'!loadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	hi _ ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).	low _ ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/7/1999 15:26'!low	^ low! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:36'!+= aThirtTwoBitRegister	"Replace my contents with the sum of the given register and my current contents."	| lowSum |	lowSum _ low + aThirtTwoBitRegister low.	hi _ (hi + aThirtTwoBitRegister hi + (lowSum bitShift: -16)) bitAnd: 16rFFFF.	low _ lowSum bitAnd: 16rFFFF.! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:41'!bitAnd: aThirtTwoBitRegister	"Replace my contents with the bitwise AND of the given register and my current contents."	hi _ hi bitAnd: aThirtTwoBitRegister hi.	low _ low bitAnd: aThirtTwoBitRegister low.! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:40'!bitInvert	"Replace my contents with the bitwise inverse my current contents."	hi _ hi bitXor: 16rFFFF.	low _ low bitXor: 16rFFFF.! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:40'!bitOr: aThirtTwoBitRegister	"Replace my contents with the bitwise OR of the given register and my current contents."	hi _ hi bitOr: aThirtTwoBitRegister hi.	low _ low bitOr: aThirtTwoBitRegister low.! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:38'!bitXor: aThirtTwoBitRegister	"Replace my contents with the bitwise exclusive OR of the given register and my current contents."	hi _ hi bitXor: aThirtTwoBitRegister hi.	low _ low bitXor: aThirtTwoBitRegister low.! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 23:09'!leftRotateBy: bits	"Rotate my contents left by the given number of bits, retaining exactly 32 bits."	"Details: Perform this operation with as little LargeInteger arithmetic as possible."	| bitCount s1 s2 newHi |	"ensure bitCount is in range [0..32]"	bitCount _ bits \\ 32.	bitCount < 0 ifTrue: [bitCount _ bitCount + 32].	bitCount > 16		ifTrue: [			s1 _ bitCount - 16.			s2 _ s1 - 16.			newHi _ ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			low _ ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			hi _ newHi]		ifFalse: [			s1 _ bitCount.			s2 _ s1 - 16.			newHi _ ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			low _ ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			hi _ newHi]! !!ThirtyTwoBitRegister methodsFor: 'copying' stamp: 'jm 12/7/1999 15:26'!copy	"Use the clone primitive for speed."	<primitive: 148>	^ super copy! !!ThirtyTwoBitRegister methodsFor: 'printing' stamp: 'jm 12/14/1999 16:05'!printOn: aStream	"Print my contents in hex with a leading 'R' to show that it is a register object being printed."	aStream nextPutAll: 'R:'.	self asInteger printOn: aStream base: 16.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ThirtyTwoBitRegister class	instanceVariableNames: ''!!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'jm 12/14/1999 16:05'!new	"Answer a new instance whose initial contents is zero."	^ super new load: 0! !SecureHashAlgorithm initialize!DigitalSignatureAlgorithm initialize!