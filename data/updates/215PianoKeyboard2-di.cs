'From Squeak 2.1 of June 30, 1998 on 5 September 1998 at 11:02:39 am'!"Change Set:		PianoKeyboard2-diDate:			5 September 1998Author:			Dan IngallsThis change set defines a piano keyboard and integrates it with the Envelope Editor.This changeSet also makes significant changes to the handling of dragOver, including...¥ dragOver, as originally intended, now includes the case of mouse button held down but no morphs in the hand, as well as the usual condition of mouse laden with submorphs.¥ If a morph handles dragOver as well as mouseDown, it will be entered in the list of dragOver morphs at mouseDown time.  In this way, it will receive a mouseLeaveLaden event when the mouse leaves the morph.  Other morphs may then receive mouseEnterLaden and mouseLeaveLaden events, until the original morph receives mouseUp at mouseUp time.¥ Previously dragOver events only generated the mouseEnter and mouseLeave protocol (requiring the user to test the mouse state to discriminate).  Now mouseEnterLaden and mouseLeaveLaden events are generated, but these default to mouseEnter and mouseLeave for backward compatibility."!RectangleMorph subclass: #EnvelopeEditorMorph	instanceVariableNames: 'sound soundName envelope hScale vScale graphArea pixPerTick limits limitXs limitHandles line prevMouseDown sampleDuration showAllEnvelopes denominator keyboard '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!RectangleMorph subclass: #PianoKeyboardMorph	instanceVariableNames: 'whiteKeyColor blackKeyColor playingKeyColor nOctaves target noteOnSelector noteOffSelector soundPrototype soundPlaying '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!AbstractSound methodsFor: 'sound generation' stamp: 'di 9/4/1998 11:52'!stopGracefully	"End this note, but do so if possible by entering the decay phase properly"! !!EventHandler methodsFor: 'events' stamp: 'di 9/3/1998 16:22'!mouseEnterLaden: event fromMorph: sourceMorph	^ self send: mouseEnterLadenSelector to: mouseEnterLadenRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/3/1998 16:13'!mouseLeaveLaden: event fromMorph: sourceMorph	^ self send: mouseLeaveLadenSelector to: mouseLeaveLadenRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'di 9/3/1998 16:18'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterLadenSelector ifNotNil: [^ mouseEnterLadenSelector].	mouseLeaveLadenSelector ifNotNil: [^ mouseLeaveLadenSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'di 9/3/1998 16:18'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterLadenRecipient ifNotNil:		[list add: (mouseEnterLadenRecipient class classThatUnderstands:					mouseEnterLadenSelector) name , ' ', mouseEnterLadenSelector].	mouseLeaveLadenRecipient ifNotNil:		[list add: (mouseLeaveLadenRecipient class classThatUnderstands:					mouseLeaveLadenSelector) name , ' ', mouseLeaveLadenSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!FMSound methodsFor: 'sound generation' stamp: 'di 9/4/1998 12:19'!stopGracefully	"End this note, but do so if possible by entering the decay phase properly"	| decayInMs env |	envelopes isEmpty ifTrue: [^ count _ 0].	env _ envelopes first.	decayInMs _ envelopes first decayTime.	count _ (decayInMs*self samplingRate//1000) rounded.	mSecsSinceStart _ env duration - env decayTime! !!Morph methodsFor: 'event handling' stamp: 'di 9/3/1998 16:31'!mouseEnterLaden: evt	"Handle a mouseEnterLaden event, meaning the mouse just entered my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[^ self eventHandler mouseEnterLaden: evt fromMorph: self].	"If there is no implementation, then send mouseEnter:"	^ self mouseEnter: evt! !!Morph methodsFor: 'event handling' stamp: 'di 9/3/1998 16:31'!mouseLeaveLaden: evt	"Handle a mouseLeaveLaden event, meaning the mouse just left my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseLeaveLaden: evt fromMorph: self].	"If there is no implementation, then send mouseLeave:"	^ self mouseLeave: evt! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/4/1998 17:13'!editSound: aSound	sound _ aSound.	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 11:02'!initialize	super initialize.	prevMouseDown _ false.	showAllEnvelopes _ true.	self editSound: (sound ifNil: [FMSound brass1 copy]).	soundName ifNil: [soundName _ 'test'].	sampleDuration _ 250.  sound duration: sampleDuration.	sound duration: sampleDuration / 1000.0.	denominator _ 7.	self extent: 10@10.  "ie the minimum"! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 10:40'!initOnSound: aSound title: title	sound _ aSound.	soundName _ title.	self initialize.! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:59'!addControls	| chooser |	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'editing ' , envelope name;		target: self;		actionSelector: #chooseFrom:envelopeItem:;		getItemsSelector: #curveChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topLeft with: graphArea bounds bottomLeft + (0@5).	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'duration: ' , self durationName;		target: self;		actionSelector: #chooseFrom:durationItem:;		getItemsSelector: #durationChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topRight with: graphArea bounds bottomRight + (-50@5).! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:49'!addKeyboard	keyboard _ PianoKeyboardMorph new soundPrototype: sound.	keyboard align: keyboard bounds bottomCenter with: bounds bottomCenter - (0@4).	self addMorph: keyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:56'!buildGraphAreaIn: frame	| r y |	graphArea _ RectangleMorph		newBounds: ((frame left + 40) @ (frame top + 40)		corner: (frame right+1) @ (frame bottom - 60))		color: Color lightGreen lighter lighter.	graphArea borderWidth: 1.	self addMorph: graphArea.	(envelope updateSelector = #pitch: and: [envelope scale <= 2.0]) ifTrue:		["Show half-steps"		r _ graphArea innerBounds.		0.0 to: 1.0 by: 1.0/12.0/envelope scale do:			[:val |			y _ self yFromValue: val.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].	(envelope updateSelector = #ratio: and: [denominator ~= 9999]) ifTrue:		["Show denominator gridding"		r _ graphArea innerBounds.		(0.0 to: 1.0 by: 1.0/denominator/envelope scale) do:			[:v |			y _ self yFromValue: v.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 13:16'!buildView	| frame |	self color: Color lightGreen.	self removeAllMorphs.	frame _ self innerBounds.	self buildGraphAreaIn: frame.	self buildScalesIn: frame.	self addHandlesIn: frame.	self addCurves.	line addHandles.	self addControls.	self addKeyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:57'!durationChoices	^ #(	'125ms'	'250ms'	'500ms'	'1000ms'	'2000ms'	'other'	'held'	)! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:29'!durationName	self durationChoices do:		[:c | c asNumber = sampleDuration ifTrue: [^ c]].	sampleDuration = 9999 ifTrue: [^ 'held'].	^ sampleDuration printString! !!EnvelopeEditorMorph methodsFor: 'scaling' stamp: 'di 9/4/1998 16:03'!extent: newExtent	super extent: (newExtent max: (self maxTime//10*3+50 max: 355) @ 284).	self buildView! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:45'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	menu addLine.	envelope updateSelector = #ratio: ifTrue:		[menu add: 'choose denominator...' action: #chooseDenominator:].	menu add: 'adjust scale...' action: #adjustScale:.	SoundPlayer isReverbOn		ifTrue: [menu add: 'turn reverb off' target: SoundPlayer selector: #stopReverb]		ifFalse: [menu add: 'turn reverb on' target: SoundPlayer selector: #startReverb].	menu addLine.	menu add: 'get sound from lib' action: #chooseSound:.	menu add: 'put sound in lib' action: #saveSound:.	menu add: 'read sound from disk...' action: #readFromDisk:.	menu add: 'save sound on disk...' action: #saveToDisk:.	menu add: 'save library on disk...' action: #saveLibToDisk:.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:49'!chooseFrom: chooserMorph durationItem: item	| str |	item asNumber ~= 0 ifTrue: [sampleDuration _ item asNumber].	item = 'other' ifTrue:		[str _ FillInTheBlank request: 'duration in milliseconds'						initialAnswer: sampleDuration printString.		sampleDuration _ str asNumber].	item = 'held' ifTrue: [sampleDuration _ 9999].	sound duration: sampleDuration / 1000.0.	chooserMorph contentsClipped: 'duration: ' , self durationName! !!EnvelopeEditorMorph methodsFor: 'stepping' stamp: 'di 9/5/1998 10:56'!step	| mouseDown hand |	hand _ self world hands first.	(bounds containsPoint: hand position) ifFalse: [^ self].	mouseDown _ hand lastEvent redButtonPressed.	mouseDown not & prevMouseDown ifTrue:		["Mouse just went up"		limitXs = (limits collect: [:i | (envelope points at: i) x]) ifFalse:			["Redisplay after changing limits"			self editEnvelope: envelope]].	prevMouseDown _ mouseDown! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 16:32'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesDragOver: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveLaden: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterLaden: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 16:04'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				mouseDownMorph _ m.				eventTransform _ m transformFrom: self.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesDragOver: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 15:58'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed				ifTrue: [self handleDragOver: evt]				ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 16:45'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).	dragOverMorphs copy do: [:m |		dragOverMorphs remove: m.		m mouseLeaveLaden: (evt transformedBy: (m transformFrom: self))].! !!PianoKeyboardMorph reorganize!('all' buildKeyboard initialize mouseDownEvent:noteMorph:pitch: mouseUpEvent:noteMorph:pitch: soundPrototype:)!!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 08:41'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterLaden send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveLaden send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterLaden send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveLaden send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 17:05'!initialize	super initialize.	self color: Color black.	whiteKeyColor _ Color veryLightGray.	blackKeyColor _ Color black.	playingKeyColor _ Color red.	nOctaves _ 6.	self buildKeyboard.	soundPrototype _ FMSound brass1 duration: 9.9! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/5/1998 10:35'!mouseDownEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: playingKeyColor.	soundPlaying ifNil:		[soundPlaying _ soundPrototype				soundForPitch: (AbstractSound pitchForMIDIKey: pitch+24)				dur: soundPrototype duration				loudness: 0.4.		soundPlaying play.		"Only leave soundPlying non-nil for held notes (dur > 9 seconds)"		soundPlaying duration < 9.0 ifTrue: [soundPlaying _ nil]]! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 12:46'!mouseUpEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: ((#(0 1 3 5 6 8 10) includes: pitch\\12)					ifTrue: [whiteKeyColor]					ifFalse: [blackKeyColor]).	soundPlaying ifNotNil:		[soundPlaying stopGracefully.		soundPlaying _ nil]! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 12:57'!soundPrototype: aSound	soundPrototype _ aSound! !EnvelopeEditorMorph removeSelector: #playLongNote!EnvelopeEditorMorph removeSelector: #spawnKeyboard!EnvelopeEditorMorph removeSelector: #chooseSamplePitch:!EnvelopeEditorMorph removeSelector: #setPlayMode:!EnvelopeEditorMorph removeSelector: #sampleToPlay:!EnvelopeEditorMorph removeSelector: #playSample!EnvelopeEditorMorph removeSelector: #playVeryLongNote!EnvelopeEditorMorph removeSelector: #sampleChoices!EnvelopeEditorMorph removeSelector: #playChord!EnvelopeEditorMorph removeSelector: #playScale!EnvelopeEditorMorph removeSelector: #setSamplePitch:!EnvelopeEditorMorph removeSelector: #playShortNote!