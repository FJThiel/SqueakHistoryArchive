'From Squeak2.9alpha of 13 June 2000 [latest update: #2982] on 8 November 2000 at 7:37:18 pm'!"Change Set:		AlignmentPreps-arDate:			8 November 2000Author:			Andreas RaabPreparations for the alignment work to come. Makes all direct accessors of alignment related state use messages so they can be rewritten during the conversion."!!AlignmentMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:22'!initialize	super initialize.	borderWidth _ 0.	self orientation: #horizontal.	"#horizontal or #vertical  or #free"	self centering: #topLeft.		"#topLeft, #center, or #bottomRight"	self hResizing: #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	self vResizing: #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	self inset: 2.					"pixels inset within owner's bounds"	self minCellSize: 0.				"minimum space between morphs; useful for tables"	layoutNeeded _ true.	color _ Color r: 0.8 g: 1.0 b: 0.8.! !!AlignmentMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:32'!openInWindowLabeled: aString inWorld: aWorld	self inset: 0.	^super openInWindowLabeled: aString inWorld: aWorld.! !!AlignmentMorph methodsFor: 'accessing' stamp: 'ar 11/8/2000 18:27'!chooseOrientation	| aMenu emphases reply |	emphases _ #(vertical horizontal).	aMenu _ EmphasizedMenu selections: emphases.	aMenu onlyBoldItem: (emphases indexOf: self orientation).	reply _ aMenu startUpWithCaption: 'Choose orientation'.	(reply == nil or: [reply == self orientation]) ifTrue: [^ self].	self orientation: reply.	self layoutChanged! !!AlignmentMorph methodsFor: 'layout' stamp: 'ar 11/8/2000 18:47'!maxWidth	"Return the minimum width for this morph."	| spaceNeeded minW |	self hResizing = #rigid ifTrue: [^ self fullBounds width].	submorphs isEmpty ifTrue: [^ self minWidthWhenEmpty].	self orientation == #horizontal ifTrue:		[spaceNeeded _ 2 * (self inset asPoint x + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minWidth max: self minCellSize)]].	self orientation == #vertical ifTrue:		[minW _ 0.		submorphs do: [:m | minW _ minW max: m minWidth].		spaceNeeded _ minW + (2 * (self inset asPoint x + borderWidth))].	^ spaceNeeded! !!AlignmentMorph methodsFor: 'layout' stamp: 'ar 11/8/2000 18:47'!minHeight	"Return the minimum height for this morph."	| minH spaceNeeded |	self vResizing = #rigid ifTrue: [^ self fullBounds height].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	self orientation == #horizontal ifTrue:		[minH _ 0.		submorphs do: [:m | minH _ minH max: m minHeight].		spaceNeeded _ minH + (2 * (self inset asPoint y + borderWidth))].	self orientation == #vertical ifTrue:		[spaceNeeded _ 2 * (self inset asPoint y + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minHeight max: self minCellSize)]].	^ spaceNeeded! !!AlignmentMorph methodsFor: 'layout' stamp: 'ar 11/8/2000 18:47'!minWidth	"Return the minimum width for this morph."	| spaceNeeded minW |	self hResizing = #rigid ifTrue: [^ self fullBounds width].	submorphs isEmpty ifTrue: [^ self minWidthWhenEmpty].	self orientation == #horizontal ifTrue:		[spaceNeeded _ 2 * (self inset asPoint x + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minWidth max: self minCellSize)]].	self orientation == #vertical ifTrue:		[minW _ 0.		submorphs do: [:m | minW _ minW max: m minWidth].		spaceNeeded _ minW + (2 * (self inset asPoint x + borderWidth))].	^ spaceNeeded! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 18:47'!extraSpacePerMorph	| spaceFillingMorphs spaceNeeded extra |	spaceFillingMorphs _ 0.	spaceNeeded _ 2 * (self inset + borderWidth).	self orientation = #horizontal ifTrue: [		spaceNeeded _ spaceNeeded asPoint x.		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minWidth max: self minCellSize).			(m isAlignmentMorph and: [m hResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds width - spaceNeeded) max: 0.	] ifFalse: [		spaceNeeded _ spaceNeeded asPoint y.		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minHeight max: self minCellSize).			(m isAlignmentMorph and: [m vResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds height - spaceNeeded) max: 0].	(submorphs size <= 1 or: [spaceFillingMorphs <= 1]) ifTrue: [^ extra].	^ extra asFloat / spaceFillingMorphs! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 18:46'!fixLayout	| extraPerMorph fractionalExtra fractionAccumulator nextPlace extra space |	extraPerMorph _ self extraSpacePerMorph asFloat.	fractionalExtra _ extraPerMorph fractionPart.	extraPerMorph _ extraPerMorph truncated.	self orientation = #horizontal		ifTrue: [nextPlace _ bounds left + self inset asPoint x + borderWidth]		ifFalse: [nextPlace _ bounds top + self inset asPoint y + borderWidth].	fractionAccumulator _ 0.0.	submorphs do: [:m |		fractionAccumulator _ fractionAccumulator + fractionalExtra.		fractionAccumulator > 0.5			ifTrue: [				extra _ extraPerMorph + 1.				fractionAccumulator _ fractionAccumulator - 1.0]			ifFalse: [extra _ extraPerMorph].		space _ self placeAndSize: m at: nextPlace padding: extra.		nextPlace _ nextPlace + space].! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 18:26'!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	| newCenter |	newCenter _ aMorph fullBounds center.	self orientation == #horizontal ifTrue:		[submorphs doWithIndex: [:m :i |			newCenter x < m fullBounds center x ifTrue: [^ i]]].	self orientation == #vertical ifTrue:		[submorphs doWithIndex: [:m :i |			newCenter y < m fullBounds center y ifTrue: [^ i]]].	^ submorphs size + 1  "insert after the last submorph"! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 18:28'!layoutInWidth: w height: h	"Adjust the size of the receiver in its space-filling dimensions during layout. This message is sent to only to layout submorphs."	((self hResizing = #spaceFill) and: [bounds width ~= w]) ifTrue: [		bounds _ bounds origin extent: (w @ bounds height).		self layoutChanged].	((self vResizing = #spaceFill) and: [bounds height ~= h]) ifTrue: [		bounds _ bounds origin extent: (bounds width @ h).		self layoutChanged].! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 18:48'!placeAndSize: m at: nextPlace padding: padding	| space fullBnds left top insetX insetY |	self inset isPoint		ifTrue: [insetX _ self inset x + borderWidth.  insetY _ self inset y + borderWidth]		ifFalse: [insetX _ insetY _ self inset + borderWidth].	self orientation = #horizontal ifTrue: [		space _ m minWidth max: self minCellSize.		m isAlignmentMorph ifTrue: [			(m hResizing = #spaceFill) ifTrue: [space _ space + padding].			m layoutInWidth: space height: (bounds height - (2 * insetY))].	] ifFalse: [		space _ m minHeight max: self minCellSize.		m isAlignmentMorph ifTrue: [			(m vResizing = #spaceFill) ifTrue: [space _ space + padding].			m layoutInWidth: (bounds width - (2 * insetX)) height: space]].	fullBnds _ m fullBounds.	self orientation = #horizontal ifTrue: [		left _ nextPlace.		self centering = #topLeft			ifTrue: [top _ bounds top + insetY].		self centering = #bottomRight			ifTrue: [top _ bounds bottom - insetY - fullBnds height].		self centering = #center			ifTrue: [top _ bounds top + ((bounds height - fullBnds height) // 2)].	] ifFalse: [		top _ nextPlace.		self centering = #topLeft			ifTrue: [left _ bounds left + insetX].		self centering = #bottomRight			ifTrue: [left _ bounds right - insetX - fullBnds width].		self centering = #center			ifTrue: [left _ bounds left + ((bounds width - fullBnds width) // 2)]].	m position: (left + (m bounds left - fullBnds left)) @ (top + (m bounds top - fullBnds top)).	^ space! !!AlignmentMorph methodsFor: 'private' stamp: 'ar 11/8/2000 18:28'!resizeIfNeeded	"Resize this morph if it is space-filling or shrink-wrap and its owner is not a layout morph."	| newWidth newHeight |	newWidth _ bounds width.	newHeight _ bounds height.	(owner == nil or: [owner isAlignmentMorph not]) ifTrue:		"if spaceFill and not in a LayoutMorph, grow to enclose submorphs"		[self hResizing = #spaceFill ifTrue:			[newWidth _ self minWidth max: self bounds width.			owner ifNotNil:				[(self hasProperty: #clipToOwnerWidth) ifTrue:					[newWidth _ newWidth min: (owner right - bounds left)]]].		self vResizing = #spaceFill ifTrue:			[newHeight _ self minHeight max: self bounds height]].	"if shrinkWrap, adjust size to just fit around submorphs"	self hResizing = #shrinkWrap ifTrue: [newWidth _ self minWidth].	self vResizing = #shrinkWrap ifTrue: [newHeight _ self minHeight].	((newWidth ~= bounds width) or: [newHeight ~= bounds height])		ifTrue: ["bounds really changed"				bounds _ bounds origin extent: newWidth@newHeight].! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:27'!initialize	super initialize.	self orientation: #vertical.	self inset: 0.	borderWidth _ 0.	self hResizing: #rigid.	self vResizing: #rigid.	heights _ OrderedCollection new.! !!BookMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:26'!setInitialState	self orientation: #vertical.	self centering: #topLeft.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self inset: 5.	color _ Color white.							"pageSize _ 1060@800."	pageSize _ 160@300.		"back to the original since the pother was way too big"	self enableDragNDrop! !!CommandTilesMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:28'!initialize	super initialize.	self centering: #center.	self hResizing: #shrinkWrap.	borderWidth _ 0.	self inset: 0.	self extent: 5@5.  "will grow to fit"! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:30'!initialize	super initialize.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	resultQueue _ SharedQueue new.	fields _ Dictionary new.	self useRoundedCorners.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:31'!initialize	super initialize.	acceptOnCR _ true.	self orientation: #vertical.	color _ Color paleYellow.	self inset: 0.	borderColor _ self standardBorderColor.	borderWidth _ 8.	self hResizing: #rigid.	self vResizing: #rigid.	minWidth _ minHeight _ 200.	bounds _ 400@100 extent:  200@150.	self rebuild.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:27'!initialize	super initialize.	groupMode _ true.	color _ Color paleRed.	self orientation: #vertical.	self inset: 10.	borderColor _ #raised.	borderWidth _ 4.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self setProperty: #normalBorderColor toValue: borderColor.	self setProperty: #flashingColors toValue: {Color red. Color yellow}.	self rebuild.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/2000 18:30'!rebuild	| row filler fudge people maxPerRow |	updateCounter _ self class updateCounter.	self removeAllMorphs.	(self addARow: {		filler _ Morph new color: Color transparent; extent: 4@4.	}) vResizing: #shrinkWrap.	self addARow: {		(StringMorph contents: 'the Fridge') lock.		self groupToggleButton.	}.	row _ self addARow: {}.	people _ self class fridgeRecipients.	maxPerRow _ people size < 7 ifTrue: [2] ifFalse: [3].			"how big can this get before we need a different approach?"	people do: [ :each |		row submorphCount >= maxPerRow ifTrue: [row _ self addARow: {}].		row addMorphBack: (			groupMode ifTrue: [				(each userPicture scaledToSize: 35@35) asMorph lock			] ifFalse: [				each veryDeepCopy killExistingChat			]		)	].	fullBounds _ nil.	self fullBounds.	"htsBefore _ submorphs collect: [ :each | each height]."	fudge _ 20.	filler extent: 4 @ (self height - filler height * 0.37 - self inset - borderWidth - fudge) truncated.	"self fixLayout.	htsAfter _ submorphs collect: [ :each | each height].	{htsBefore. htsAfter} explore."! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:22'!initialize	super initialize.	self orientation: #vertical.	color _ Color lightGray.	self inset: 4.	borderColor _ #raised "Color brown".	borderWidth _ 4.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self useRoundedCorners.	self rebuild.	! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:22'!initialize	super initialize.	self orientation: #vertical.	color _ Color lightBlue.	self inset: 4.	borderColor _ Color blue.	borderWidth _ 4.	self rebuild.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:24'!initialize	super initialize.	self orientation: #vertical.	color _ Color lightBrown.	self inset: 4.	borderColor _ #raised "Color brown".	borderWidth _ 4.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self useRoundedCorners.	self rebuild.	! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:29'!initialize	super initialize.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	self setColorsAndBorder.	self rebuild.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:31'!setColorsAndBorder	color _ Color paleYellow.	borderWidth _ 8.	borderColor _ color darker.	self inset: 4.	self useRoundedCorners.! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:32'!setColorsAndBorder	color _ Color r: 0.545 g: 0.47 b: 0.621.	borderWidth _ 8.	borderColor _ color darker.	self inset: 4.	self useRoundedCorners. ! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:20'!initialize	Socket initializeNetwork.				"we may want our IP address"	Preferences defaultAuthorName.		"seems like a good place to insure we have a name"	super initialize.	self orientation: #vertical.	color _ Color lightMagenta.	self inset: 4.	borderColor _ Color magenta.	borderWidth _ 4.	self setProperty: #normalBorderColor toValue: borderColor.	self setProperty: #flashingColors toValue: {Color red. Color yellow}.! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:20'!initialize	super initialize.	saved _ true.	borderWidth _ 2.	borderColor _ #raised.	color _ Color red.	self orientation: #vertical.	self centering: #center.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self inset: 2.	self minCellSize: 4.	self addButtons.! !!FloatingBookControlsMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:29'!initialize	super initialize.	borderWidth _ 1.	borderColor _ Color black.	self inset: 0.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.! !!FreeCell methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:25'!initialize	super initialize.	Statistics newSession.	autoMoveRecursionCount _ 0.	self orientation: #vertical.	self centering: #center.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	self		color: self colorNearTop;		borderWidth: 2;		addMorph: self makeControls;		addMorph: self board;		newGame.! !!FreeCellBoard methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:23'!initialize	super initialize.	self orientation: #vertical.	self hResizing: #shrinkWrap.	self vResizing: #rigid.	self height: 500.	borderWidth _ 0.	color _ Color green.	self layout.! !!GeePrinterDialogMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:30'!initialize	super initialize.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	color _ Color paleYellow.	borderWidth _ 8.	borderColor _ color darker.	self inset: 4.	self useRoundedCorners.	printSpecs ifNil: [printSpecs _ PrintSpecifications defaultSpecs].	self rebuild.! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:25'!initialize	| slider |	super initialize.	self orientation: #vertical.	self centering: #center.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self color: (Color r: 0.484 g: 0.613 b: 0.0).	self borderWidth: 1.	channel _ 0.	controller _ 7.  "channel volume"	slider _ SimpleSliderMorph new		target: self;		actionSelector: #newSliderValue:;		minVal: 0;		maxVal: 127;		extent: 128@10.	self addMorphBack: slider.	self addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel.! !!MenuMorph methodsFor: 'initialization' stamp: 'ar 11/1/2000 02:07'!initialize	super initialize.	bounds _ 0@0 corner: 40@10.	self setDefaultParameters.	self orientation: #vertical.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	defaultTarget _ nil.	selectedItem _ nil.	stayUp _ false.	popUpOwner _ nil.	Preferences roundedMenuCorners ifTrue: [self useRoundedCorners]! !!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:32'!setDefaultParameters	| worldColor |	((Preferences menuColorFromWorld and: [Display depth > 4]) and: [(worldColor _ self currentWorld color) isColor])		ifTrue: [self setColor: (worldColor luminance > 0.7						ifTrue: [worldColor mixed: 0.8 with: Color black]						ifFalse: [worldColor mixed: 0.4 with: Color white])						"Think about whether alpha should be included."					borderWidth: Preferences menuBorderWidth					borderColor: #raised]		ifFalse: [self setColor: Preferences menuColor					borderWidth: Preferences menuBorderWidth					borderColor: Preferences menuBorderColor].	self inset: 3.! !!MidiInputMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:26'!initialize	super initialize.	self orientation: #vertical.	self centering: #center.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self inset: 3.	color _ Color veryLightGray.	self borderWidth: 2.	midiPortNumber _ nil.	midiSynth _ MIDISynth new.	instrumentSelector _ Array new: 16.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack:		(AlignmentMorph newColumn color: color; inset: 0).	self addChannelControlsFor: 1.	self extent: 20@20.! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject	"Set the receiver's representee.  This clears out any preexisting state in the receiver"	objectRepresented _ anObject.	self removeAllMorphs.	self hResizing: #shrinkWrap.  	self vResizing: #shrinkWrap.	self addMorphBack: (StringMorph new contents: anObject name asString).	self setNameTo: anObject name	! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject labelString: aLabel	"Set the receiver's representee as indicated, and use the given label to tag it"	objectRepresented _ anObject.	self removeAllMorphs.	self hResizing: #shrinkWrap.  	self vResizing: #shrinkWrap.	self addMorphBack: (StringMorph new contents: aLabel asString).	self setNameTo: aLabel asString	! !!ListViewLine methodsFor: 'object represented' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject	"Set the object represented by the receiver to be as requested"	objectRepresented _ anObject.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self setNameTo: anObject name.	self removeAllMorphs.! !!PasteUpMorph methodsFor: 'initialization' stamp: 'ar 11/8/2000 18:14'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	color _ Color r: 0.8 g: 1.0 b: 0.6.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	self enableDragNDrop.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/8/2000 18:14'!toggleAutoLineLayout	"Toggle the auto-line-layout setting"	self autoLineLayout: self autoLineLayout not.	self autoLineLayout ifFalse: [self restoreBoundsOfSubmorphs].	self fixLayout.	self layoutChanged! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/8/2000 18:13'!viewByIcon	"The receiver has been being viewed in some constrained layout view; now restore it to its normal x-y-layout view"	|  oldSubs |	self showingListView		ifTrue:			[oldSubs _ submorphs.			self removeAllMorphs.			self autoLineLayout: false.			oldSubs do:				[:aSubmorph |					self addMorphBack:  aSubmorph objectRepresented].			self restoreBoundsOfSubmorphs.			self removeProperty: #showingListView.			self layoutChanged]		ifFalse:			[self autoLineLayout == true ifTrue: [self toggleAutoLineLayout]]		! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/8/2000 18:13'!viewingByIconString	"Answer a string to show in a menu representing whether the receiver is currently viewing its subparts by icon or not"	^ (self showingListView or: [self autoLineLayout == true])		ifFalse:	['<yes>view by icon']		ifTrue:	['<no>view by icon']! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/8/2000 18:14'!viewingNonOverlappingString	"Answer a string to show in a menu representing whether the receiver is currently viewing its subparts by non-overlapping-icon (aka auto-line-layout)"	^ (self showingListView or: [self autoLineLayout ~~ true])		ifFalse:	['<yes>view with line layout']		ifTrue:	['<no>view with line layout']! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/8/2000 18:13'!viewingNormally	"Answer whether the receiver is being viewed normally, viz not in list-view or auto-line-layout"	^ (self showingListView or: [self autoLineLayout == true]) not! !!PhonemeRecognizerMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:20'!initialize	| r |	super initialize.	borderWidth _ 2.	self orientation: #vertical.	soundInput _ SoundInputStream new samplingRate: 22050.	phonemeRecords _ OrderedCollection new.	silentPhoneme _ PhonemeRecord new initialize name: '...'.	currentPhoneme _ silentPhoneme.  "the PhonemeRecord of the current match"	self addTitle.	self addButtonRows.	self addLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeLevelMeter.	self addMorphBack: r.	self addPhonemeDisplay.	self extent: 10@10.  "make minimum size"! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:28'!initialize	super initialize.	resultType = #unknown.	brightenedOnEnter _ false.	self centering: #center.	self hResizing: #shrinkWrap.	borderWidth _ 0.	self inset: 0.	self extent: 5@5.  "will grow to fit"! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 18:29'!fixLayoutPile	| nextPlace |	self orientation = #horizontal		ifTrue: [nextPlace _ bounds left + self inset + borderWidth]		ifFalse: [nextPlace _ bounds top + self inset + borderWidth].	submorphs reverseDo: [:m |		self placeAndSize: m at: nextPlace padding: 0].! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 18:29'!fixLayoutStagger	| nextPlace |	self orientation = #horizontal		ifTrue: [nextPlace _ bounds left + self inset + borderWidth]		ifFalse: [nextPlace _ bounds top + self inset + borderWidth].	submorphs reverseDo: [:m |		self placeAndSize: m at: nextPlace padding: 0.		nextPlace _ nextPlace + self staggerOffset].! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 18:29'!minHeight	"Return the minimum height for this morph."	| spaceNeeded |	self vResizing = #shrinkWrap ifFalse: [^super minHeight].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	self orientation == #horizontal ifTrue: [^super minHeight].	self orientation == #vertical ifTrue:		[spaceNeeded _ 2 * (self inset + borderWidth).		spaceNeeded _ spaceNeeded + (PlayingCardMorph height).		layout = #stagger ifTrue: [spaceNeeded _ spaceNeeded + 									((self submorphCount - 1) * self staggerOffset)]].	^ spaceNeeded! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 18:29'!minHeightWhenEmpty	^(PlayingCardMorph height) + (2*(borderWidth + self inset))! !!PlayingCardDeck methodsFor: 'layout' stamp: 'ar 11/8/2000 18:29'!minWidthWhenEmpty	^(PlayingCardMorph width) + (2*(borderWidth + self inset))! !!PlayingCardDeck methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:29'!initialize	super initialize.	layout _ #grid.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	borderWidth _ 0.	self inset: 0.	stackingPolicy _ #stagger.	stackingOrder _ #ascending.	emptyDropPolicy _ #any.	self newSeed.	^self! !!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'ar 10/30/2000 15:27'!initialize 	super initialize.	self orientation: #vertical.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self centering: #center.	borderWidth _ 1.	model _ nil.	label _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	shortcutCharacter _ nil.	askBeforeChanging _ false.	triggerOnMouseDown _ false.	color _ Color lightGreen.	onColor _ color darker.	offColor _ color.	feedbackColor _ Color red.	showSelectionFeedback _ false.	allButtons _ nil.	self extent: 20@15.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:30'!initialize	super initialize.	self useRoundedCorners.	self inset: 6.	color _ Color orange.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	mouseInside _ false.	self addButtons.! !!KidNavigationMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:31'!initialize	| fill |	super initialize.	self inset: 12.	fill _ GradientFillStyle ramp: {		0.0->(Color r: 0.032 g: 0.0 b: 0.484).		1.0->(Color r: 0.194 g: 0.032 b: 1.0)	}.	fill origin: self bounds topLeft.	fill direction: 0@200.	fill radial: false.	self fillStyle: fill.	self removeAllMorphs.	self addButtons.! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:25'!initialize	| r |	super initialize.	borderWidth _ 2.	self orientation: #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!SameGame methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:23'!initialize	super initialize.	self orientation: #vertical.	self centering: #center.	self vResizing: #shrinkWrap.	self hResizing: #spaceFill.	self inset: 3.	color _ Color lightGray.	self addMorph: self makeControls.	self addMorph: self board.	helpText _ nil.	self newGame.! !!SameGameBoard methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:28'!initialize	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	self hResizing: #rigid.	self vResizing: #rigid.	borderWidth _ 2.	borderColor _ Color black.	rows _ self preferredRows.	columns _ self preferredColumns.	color _ Color gray.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self fixLayout.	self resetBoard.! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:20'!initialize	super initialize.	self orientation: #vertical.	self centering: #center.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self inset: 3.	color _ Color veryLightGray.	self borderWidth: 2.	self onScorePlayer: (ScorePlayer new initialize) title: ' '.	self extent: 20@20.! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'ar 11/1/2000 13:23'!initialize	super initialize.	color _ ScriptingSystem colorBehindTiles.	self orientation: #vertical.	self hResizing: #spaceFill.	self vResizing: #shrinkWrap.	self setDefaultBorderCharacteristics.	firstTileRow _ 1.  "index of first tile-carrying submorph"	self addNewRow.	showingMethodPane _ false.! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:32'!setDefaultBorderCharacteristics		borderWidth _ 1.	borderColor _ Color black.	self inset: 2.	self useRoundedCorners! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 11/8/2000 18:29'!minHeight	| extra |	extra _ 2 * (self inset + borderWidth).	^ (super minHeight - extra max: TileMorph defaultH) + extra! !!ScriptEvaluatorMorph methodsFor: 'display' stamp: 'ar 10/30/2000 15:32'!setDefaultBorderCharacteristics		borderWidth _ 2.	borderColor _ Color blue.	self inset: 2.	self useRoundedCorners! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:30'!initializeFor: aScriptInstantiation	"Answer a control that will serve to reflect and allow the user to change the status of the receiver"	|  statusReadout |	self hResizing: #shrinkWrap.	scriptInstantiation _ aScriptInstantiation.	tickPauseButtonsShowing _ false.	tickPauseWrapper _ AlignmentMorph newColumn beTransparent; yourself.	self addMorphBack: tickPauseWrapper.	"self addTransparentSpacerOfSize: 5@0."	self addMorphBack: (statusReadout _ UpdatingSimpleButtonMorph new).	statusReadout setNameTo: 'trigger'.	statusReadout target: aScriptInstantiation; wordingSelector: #status; actionSelector: #chooseTriggerFrom:; arguments: {self}.	statusReadout setBalloonText: 'when this script should run'.	statusReadout actWhen: #buttonDown.	self assurePauseTickControlsShow! !!SoundDemoMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:21'!initialize	super initialize.	self orientation: #vertical.	self centering: #center.	self hResizing: #spaceFill.	self vResizing: #spaceFill.	self inset: 3.	color _ Color lightGray.	self borderWidth: 2.	self addMorph: self makeControls.	soundColumn _ AlignmentMorph newColumn.	soundColumn enableDragNDrop.	self addMorphBack: soundColumn.	self extent: 118@150.! !!SpectrumAnalyzerMorph methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:24'!initialize	super initialize.	borderWidth _ 2.	self orientation: #vertical.	soundInput _ SoundInputStream new samplingRate: 22050.	fft _ FFT new: 512.	displayType _ 'sonogram'.	self addButtonRow.	self addLevelSlider.	self addMorphBack: self makeLevelMeter.	self addMorphBack: (Morph new extent: 10@10; color: Color transparent).  "spacer"	self resetDisplay.  "adds the display morph"! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:31'!initialize	super initialize.	self hResizing: #spaceFill.	self vResizing: #spaceFill.! !!TabbedPalette methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:32'!setInitialState	super setInitialState.	self inset: 0.	pageSize _ 156 @ 232! !!Tetris methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:21'!initialize	super initialize.	board _ TetrisBoard new game: self.	color _ Color lightGray.	self orientation: #vertical.	self centering: #center.	self vResizing: #shrinkWrap.	self hResizing: #spaceFill.	self inset: 3.	self 		addMorphBack: self makeGameControls;		addMorphBack: self makeMovementControls;		addMorphBack: self showScoreDisplay;		addMorphBack: board.	board newGame.! !!TetrisBoard methodsFor: 'initialization' stamp: 'ar 11/8/2000 18:14'!initialize	super initialize.	bounds _ 0@0 extent: (self numColumns @ self numRows) * self cellSize + (1@1).	color _ Color r: 0.8 g: 1.0 b: 1.0.! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/30/2000 15:31'!initialize	super initialize.	self useRoundedCorners.	self inset: 6.	color _ Color red lighter.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	listOfPages _ OrderedCollection new.	currentIndex _ 0.	self addButtons.! !!ViewerEntry methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:32'!initialize	super initialize.	color _ Color r: 1.0 g: 0.985 b: 0.985.	self inset: 0! !!ViewerRow methodsFor: 'initialization' stamp: 'ar 10/30/2000 15:31'!initialize	super initialize.	self inset: 1! !