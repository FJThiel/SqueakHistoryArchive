'From Squeak2.8alpha of 13 January 2000 [latest update: #1988] on 6 April 2000 at 1:19:11 pm'!!Project commentStamp: 'tk 4/6/2000 13:18' prior: 0!A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet.  A project knows who its parent project is.  When you change projects, whether by entering or exiting, the screen state of the project being exited is saved in that project.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Project named: 'xxx') exportSegment, or choose 'store project on file...'.  Projects may be loaded from a server and stored back.  Storing on a server never overwrites;  it always makes a new version.  A project remembers the url of where it lives in urlList.  The list is length one, for now.  The url may point to a local disk instead of a server.  All projects that the user looks at, are cached in the Squeaklet folder.  Sorted by server.  The cache holds the most recent version only.  IsolationWhen you accept a method, the entire system feels the change, except projects that are "isolated".  In an isolated project, all new global variables (including new classes) are stored in the project-local environment, and all changes to preexisting classes are revoked when you leave the project.  When you enter another project, that project's changes are invoked.  Invocation and revocation are handled efficiently by swapping pointers.  To make a project be isolated, choose 'isolate changes of this project' from the 'changes...' section of the screen menu.  You can use an isolated project for making dangerous change to a system, and you can get out if it crashes.  A foreign application can have the separate environment it wants.  Also, you can freeze part of the system for a demo that you don't want to disturb.  An isolated project shares methods with all subprojects inside it, unless they are isolated themselves.   Each isolated project is the head of a tree of projects with which it shares all methods.You may 'assert' all changes ever made in the current project to take effect above this project.  This amounts to exporting all the globals in the current environment, and zapping the revocation lists to that the current state of the world will remain in force upon exit from this project.[Later: A project may be 'frozen'.  Asserts do not apply to it after that.  (Great for demos.)  You should be informed when an assert was blocked in a frozen project.]Class definitions are layered by the isolation mechanism.  You are only allowed to change the shape of a class in projects that lie within its isolation scope.  All versions of the methods are recompiled, in all projects.  If you remove an inst var that is in use in an isolated project, it will become an Undeclared global.  It is best not to remove an inst var when it is being used in another isolated project. [If we recompile them all, why can't we diagnose the problem before allowing the change??]Senders and Implementors do not see versions of a method in isolated projects.  [again, we might want to make this possible at a cost].  When you ask for versions of a method, you will not get the history in other isolated projects.Moving methods and classes between changeSets, and merging changeSets has no effect on which methods are in force.  But, when you look at a changeSet from a different isolated project, the methods will contain code that is not in force.  A changeSet is just a list of method names, and does not keep separate copies of any code.When finer grained assertion is needed, use the method (aProject assertClass: aClass from: thisProject warn: warnConflicts).How isolated changes work: The first time a class changes, store its MethodDictionary object.  Keep parallel arrays of associations to Classes and MethodDictionaries.  Traverse these and install them when you enter an "ioslated project".  When you leave, store this project's own MethodDictionaries there.	To do an assert, we must discover which methods changed here, and which changed only in the project we are asserting into.  There is one copy of the 'virgin' method dictionaries in the system.  It is always being temporarily stored by the currently inForce isolated project.isolatedHead - true for the top project, and for each isolated project.  false or nil for any subproject that shares all methods with its parent project.inForce -  true if my methods are installed now.  false if I am dormant. [is this equivalent to self == Project Current?]classArray - list of associations to classes methodDictArray - the method dictionaries of those classes before we started changing methods.  They hang onto the original compiledMethods.  (If this project is dormant, it contains the method dictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - No longer used.When you want to save a project in export format from within that very project, it gets tricky.  We set two flags in parentProject, exit to it, and let parentProject write the project.  ProjectViewMorph in parentProject checks in its step method, does the store, clears the flags, and reenters the subProject.!!DiskProxy methodsFor: 'as yet unclassified' stamp: 'tk 4/5/2000 15:38'!comeFullyUpOnReload: smartRefStream	"Internalize myself into a fully alive object after raw loading from a DataStream. (See my class comment.)  DataStream will substitute the object from this eval for the DiskProxy."	| globalObj symbol pr nn |	symbol _ globalObjectName.	"See if class is mapped to another name"	(smartRefStream respondsTo: #renamed) ifTrue: [		symbol _ smartRefStream renamed at: symbol ifAbsent: [symbol]].	globalObj _ Smalltalk at: symbol 		ifAbsent: [^ self halt: 'Global not found'].	((symbol == #World) and: [World == nil]) ifTrue: [		self inform: 'These objects will work better if opened in a Morphic World.Dismiss and reopen all menus.'].	preSelector ifNotNil: [		Symbol hasInterned: preSelector ifTrue: [:selector |			globalObj _ globalObj perform: selector]].	symbol == #Project ifTrue: [		(constructorSelector = #fromUrl:) ifTrue: [			nn _ (constructorArgs first findTokens: '/') last.			nn _ (nn findTokens: '.|') first.			pr _ Project named: nn. 			^ pr ifNil: [self] ifNotNil: [pr]].		pr _ globalObj perform: constructorSelector withArguments: constructorArgs.		^ pr ifNil: [self] ifNotNil: [pr]].	"keep the Proxy if Project does not exist"	constructorSelector ifNil: [^ globalObj].	constructorSelector ifNotNil: [		Symbol hasInterned: constructorSelector ifTrue: [:selector |			^ globalObj perform: selector					withArguments: constructorArgs]].					"args not checked against Renamed"	^ nil 	"was not in proper form"! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!initMorphic	"Written so that Morphic can still be removed."	Smalltalk verifyMorphicAvailability ifFalse: [^ nil].	self initialize.	world _ PasteUpMorph newWorldForProject: self.! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!setProjectHolder: aProject	self initialize.	world _ ControlManager new.! !!Project methodsFor: 'initialization' stamp: 'tk 4/5/2000 13:57'!setServer	"Mark me as a new project.  See if a server is known, remember it."	self projectParameters at: #exportState put: #nacent.	(urlList == nil or: [urlList size = 0]) ifTrue: [		urlList _ parentProject urlList].! !!Project methodsFor: 'accessing' stamp: 'tk 4/5/2000 16:29'!changeSet	^ changeSet! !!Project methodsFor: 'accessing' stamp: 'tk 4/5/2000 17:00'!findProjectView: projectDescription	| pName dpName |	"In this world, find the morph that holds onto the project described by projectDescription.  projectDescription can be a project, or the name of a project.  The project may be represented by a DiskProxy.  The holder morph may be at any depth in the world.	Need to fix this if Projects have subclasses, or if a class other than ProjectViewMorph can officially hold onto a project.  (Buttons, links, etc)"	pName _ (projectDescription isKindOf: String) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	world allMorphsDo: [:pvm |		pvm class == ProjectViewMorph ifTrue: [			(pvm project class == Project and: 				[pvm project name = pName]) ifTrue: [^ pvm].			pvm project class == DiskProxy ifTrue: [ 				dpName _ pvm project constructorArgs first.				dpName _ (dpName findTokens: '/') last.				dpName _ (dpName findTokens: '.|') first.				dpName = pName ifTrue: [^ pvm]]]].	^ nil! !!Project methodsFor: 'accessing' stamp: 'tk 4/5/2000 13:57'!urlList	^ urlList! !!Project methodsFor: 'menu messages' stamp: 'tk 4/6/2000 12:56'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject makeThumbnail].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph		ifTrue:			[self spawnNewProcessAndTerminateOld: true]		ifFalse:			[showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'file in/out' stamp: 'tk 4/5/2000 16:01'!fromMyServerLoad: otherProjectName	| servers pair pr strm pvm proj projViewer |	"If a newer version of me is on the server, load it."	(pr _ Project named: otherProjectName) ifNotNil: ["it appeared"		^ pr enter].	(servers _ self serverList) isEmpty 		ifTrue: [^ self inform: 			'Current project does not know a server either.'].	pair _ self class mostRecent: otherProjectName onServer: servers first.	pair first ifNil: [		pvm _ ProjectViewMorph newMorphicProjectOn: nil.		pvm _ pvm findA: ProjectViewMorph.		(proj _ pvm project) changeSet name: otherProjectName.		projViewer _ self findProjectView: otherProjectName.		proj setParent: Project current.		(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].		^ projViewer project: proj].	strm _ servers first oldFileNamed: pair first.	self installRemoteFrom: strm named: otherProjectName.! !!Project methodsFor: 'file in/out' stamp: 'tk 4/5/2000 16:21'!objectForDataStream: refStrm	| uu |	"I am about to be written on an object file.  Write a path to me in the other system instead."	(uu _ self url) size > 0 ifTrue: [		^ DiskProxy global: #Project selector: #namedUrl: args: 			(Array with: uu)].	^ DiskProxy global: #Project selector: #named: args: (Array with: self name)"	self inform: 'Project ', self name, ' is being written'.	super objectForDataStream: refStrm."! !!Project methodsFor: 'file in/out' stamp: 'tk 4/5/2000 14:58'!url	| vv |	"compose my url on the server"	vv _ version.	version ifNil: [vv _ 'AA'].	urlList ifNotNil: [urlList size > 0 ifTrue: [		^ urlList first, self name,'|',vv,'.pr']].	^ ''! !!Project class methodsFor: 'squeaklet on server' stamp: 'tk 4/5/2000 16:29'!fromUrl: urlString	| serverFile pair pvm thumbnailWindow nn proj projViewer |	"Load the project, and make a thumbnail to it in the current project.  Replace the old one if necessary.Project fromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/SqueakEasy.extSeg'."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	World ifNil: [^ self inform: 			'Later, allow jumping from MVC to Morphic Projects.'].	serverFile _ ServerFile new fullPath: urlString.	(proj _ Project named: (nn _ (serverFile fileName findTokens: '|.') first))		ifNotNil: ["it appeared" ^ proj enter].	pair _ self mostRecent: serverFile fileName onServer: serverFile.	pair first ifNil: [		pvm _ ProjectViewMorph newMorphicProjectOn: nil.		pvm _ pvm findA: ProjectViewMorph.		(proj _ pvm project) changeSet name: nn.		projViewer _ Project current findProjectView: nn.		proj setParent: Project current.		(projViewer owner isKindOf: SystemWindow) ifTrue: [				projViewer owner model: proj].		^ projViewer project: proj].	"Find parent project, go there, zap old thumbnail"	World submorphsDo: [:sub | 		(sub isKindOf: SystemWindow) ifTrue: [			(pvm _ sub findA: ProjectViewMorph) ifNotNil: [				(pvm class == DiskProxy and: 					[pvm constructorArgs first = urlString])						ifTrue: [thumbnailWindow _ sub]]]].	thumbnailWindow ifNotNil: [		thumbnailWindow delete.		thumbnailWindow owner ifNotNil: [^ self]].	"user refused"	"replace with a new one"	ProjectViewMorph openFromFile: serverFile asStream.! !