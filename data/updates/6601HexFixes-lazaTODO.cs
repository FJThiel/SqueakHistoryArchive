'From Squeak3.9alpha of ''2 November 2004'' [latest update: #6599] on 16 March 2005 at 8:29:18 am'!"Change Set:		HexFixesDate:			16 March 2005Author:			Boris Gaertnerwith changes set #6217 the method Integer>>hex was deprecated. This change set is an attempt to replace the remaining senders of hex with either storeStringHex or printStringHex"!!Color class methodsFor: 'other' stamp: 'BG 3/16/2005 08:18'!hex: aFloat	"Return an hexadecimal two-digits string between 00 and FF	for a float between 0.0 and 1.0"	| str |	str := ((aFloat * 255) asInteger printStringHex) asLowercase.	str size = 1 ifTrue: [^'0',str] ifFalse: [^str]! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'BG 3/16/2005 08:22'!override: chars with: otherFileName ranges: pairArray transcodingTable: table additionalRange: additionalRange	| other rangeStream currentRange newChars code form u newArray j |	other _ BDFFontReader readOnlyFileNamed: otherFileName.	rangeStream _ ReadStream on: pairArray.	currentRange _ rangeStream next.	newChars _ PluggableSet new.	newChars hashBlock: [:elem | (elem at: 2) hash].	newChars equalBlock: [:a :b | (a at: 2) = (b at: 2)].	other readChars do: [:array | 		code _ array at: 2.		"code printStringHex printString displayAt: 0@0."		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange _ rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [				newChars addAll: chars.				^ newChars.			].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form _ array at: 1.			form ifNotNil: [				j _ array at: 2.				u _ table at: (((j // 256) - 33 * 94 + ((j \\ 256) - 33)) + 1).				u ~= -1 ifTrue: [					array at: 2 put: u.					newChars add: array.					additionalRange do: [:e |						e first = (array at: 2) ifTrue: [							newArray _ array clone.							newArray at: 2 put: e second.							newChars add: newArray						].					]				].			].		].	].	self error: 'should not reach here'.! !!FileList methodsFor: 'private' stamp: 'BG 3/16/2005 08:22'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read' translated].	f binary.	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc printStringHex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) printStringHex; space].		s cr].	hexData := s contents.	^ contents := ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. size. hexData}]		ifFalse: [hexData]).! !!InputSensor methodsFor: 'joystick' stamp: 'BG 3/16/2005 08:23'!testJoystick: index	"Sensor testJoystick: 3"	| f pt buttons status |	f _ Form extent: 110@50.	[Sensor anyButtonPressed] whileFalse: [		pt _ Sensor joystickXY: index.		buttons _ Sensor joystickButtons: index.		status _'xy: ', pt printString, 'buttons: ', buttons printStringHex.		f fillWhite.		status displayOn: f at: 10@10.		f displayOn: Display at: 10@10.	].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'BG 3/16/2005 08:24'!parseNextMarker	"Parse the next marker of the stream"	| byte discardedBytes |	discardedBytes _ 0.	[(byte _ self next) = 16rFF] whileFalse: [discardedBytes _ discardedBytes + 1].		[[(byte _ self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:		[discardedBytes _ discardedBytes + 2].	discardedBytes > 0 ifTrue: [self "notifyWithLabel: 'warning: extraneous data discarded'"].	self perform:		(JFIFMarkerParser			at: byte			ifAbsent:				[(self okToIgnoreMarker: byte)					ifTrue: [#skipMarker]					ifFalse: [self error: 'marker ', byte printStringHex , ' cannot be handled']])! !!MultiCharacter methodsFor: 'printing' stamp: 'BG 3/16/2005 08:25'!hex	^ value storeStringHex.  " is this ok or is printStringHex the preferred writing form? "! !!PNGReadWriter methodsFor: 'writing' stamp: 'BG 3/16/2005 08:26'!writeChunk: crcStream	| bytes length crc debug |	debug _ self debugging.	bytes := crcStream originalContents.	length := crcStream position.	crc := self updateCrc: 16rFFFFFFFF from: 1 to: length in: bytes.	crc := crc bitXor: 16rFFFFFFFF.	debug ifTrue: [ Transcript cr;		print: stream position; space;		nextPutAll: (bytes copyFrom: 1 to: 4) asString;		nextPutAll: ' len='; print: length;		nextPutAll: ' crc=0x'; nextPutAll: crc printStringHex  ].	stream nextNumber: 4 put: length-4. "exclude chunk name"	stream next: length putAll: bytes startingAt: 1.	stream nextNumber: 4 put: crc.	debug ifTrue: [ Transcript nextPutAll: ' afterPos='; print: stream position ].	crcStream resetToStart.! !!POP3Client methodsFor: 'private protocol' stamp: 'BG 3/16/2005 08:27'!apopLogin	"Attempt to authenticate ourselves to the server without sending the password as cleartext."	"For secure authentication, we look for a timestamp in the initial response string we get from the server, and then try the APOP command as specified in RFC 1939.  If the initial response from the server is	+OK POP3 server ready <1896.697170952@dbc.mtview.ca.us>we extract the timestamp	<1896.697170952@dbc.mtview.ca.us>then form a string of the form	<1896.697170952@dbc.mtview.ca.us>USERPASSWORDand then send only the MD5 hash of that to the server.  Thus the password never hits the wire"	| timestamp hash |	[	"Look for a timestamp in the response we received from the server"	timestamp _ self lastResponse findTokens: '<>' includes: '@'.	timestamp		ifNil: [(POP3LoginError protocolInstance: self) signal: 'APOP not supported.'].	(Smalltalk includesKey: #MD5)		ifTrue: [			hash _ ((Smalltalk at: #MD5) hashMessage: ('<', timestamp, '>', self password)) storeStringHex asLowercase.			"trim starting 16r and zero pad it to 32 characters if needed"			hash _ hash  padded: #left to: 32 with: $0]		ifFalse: [(POP3LoginError protocolInstance: self) signal: 'APOP (MD5) not supported.'].	self sendCommand: 'APOP ', self user, ' ', hash.	self checkResponse.	self logProgress: self lastResponse]		on: ProtocolClientError		do: [:ex |			self close.			(LoginFailedException protocolInstance: self) signal: 'Login failed.']! !!StrikeFont methodsFor: 'displaying' stamp: 'BG 3/16/2005 08:27'!fontDisplay	"TextStyle default defaultFont fontDisplay."	Display restoreAfter:		[(Form extent: 440@400) displayAt: 90@90.		 0 to: 15 do:			[:i |			i storeStringHex displayAt: 100 @ (20 * i + 100).			0 to: 15 do:				[:j |				((16*i+j) between: 1 and: (self xTable size - 2)) ifTrue:					[(self characterFormAt: (16 * i + j) asCharacter)						displayAt: (20 * j + 150) @ (20 * i + 100)]]].			'Click to continue...' asDisplayText displayAt: 100@450]! !!StrikeFontSet methodsFor: 'displaying' stamp: 'BG 3/16/2005 08:27'!fontDisplay	"TextStyle default defaultFont fontDisplay."	Display restoreAfter:		[(Form extent: 440@400) displayAt: 90@90.		 0 to: 15 do:			[:i |			i storeStringHex displayAt: 100 @ (20 * i + 100).			0 to: 15 do:				[:j |				((16*i+j) between: 1 and: (self xTable size - 2)) ifTrue:					[(self characterFormAt: (16 * i + j) asCharacter)						displayAt: (20 * j + 150) @ (20 * i + 100)]]].			'Click to continue...' asDisplayText displayAt: 100@450]! !!X11Drawable methodsFor: 'printing' stamp: 'BG 3/16/2005 08:28'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self xid printStringHex;		nextPut: $) ! !!ZipArchive methodsFor: 'private' stamp: 'BG 3/16/2005 08:28'!readMembersFrom: stream named: fileName	| newMember signature |	[		newMember _ self memberClass newFromZipFile: stream named: fileName.		signature _ self readSignatureFrom: stream.		signature = EndOfCentralDirectorySignature ifTrue: [ ^self ].		signature = CentralDirectoryFileHeaderSignature			ifFalse: [ self error: 'bad CD signature at ', (stream position - 4) printStringHex ].		newMember readFrom: stream.		newMember looksLikeDirectory ifTrue: [ newMember _ newMember asDirectory ].		self addMember: newMember.	] repeat.! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'BG 3/16/2005 08:19'!crc32String	| hexString |	hexString _ crc32 storeStringHex.	^('00000000' copyFrom: 1 to: 11 - (hexString size)) , (hexString copyFrom: 4 to: hexString size)! !!ZipFileMember methodsFor: 'private-reading' stamp: 'BG 3/16/2005 08:28'!readLocalDirectoryFileHeaderFrom: aStream 	"Positions stream as necessary. Will return stream to its original position"	| fileNameLength extraFieldLength xcrc32 xcompressedSize xuncompressedSize sig oldPos |	oldPos _ aStream position.	aStream position: localHeaderRelativeOffset.	sig _ aStream next: 4.	sig = LocalFileHeaderSignature asByteArray		ifFalse: [ aStream position: oldPos.				^self error: 'bad LH signature at ', localHeaderRelativeOffset printStringHex ].	versionNeededToExtract _ aStream nextLittleEndianNumber: 2.	bitFlag _ aStream nextLittleEndianNumber: 2.	compressionMethod _ aStream nextLittleEndianNumber: 2.	lastModFileDateTime _ aStream nextLittleEndianNumber: 4.	xcrc32 _ aStream nextLittleEndianNumber: 4.	xcompressedSize _ aStream nextLittleEndianNumber: 4.	xuncompressedSize _ aStream nextLittleEndianNumber: 4.	fileNameLength _ aStream nextLittleEndianNumber: 2.	extraFieldLength _ aStream nextLittleEndianNumber: 2.	fileName _ (aStream next: fileNameLength) asString asSqueakPathName.	localExtraField _ (aStream next: extraFieldLength) asByteArray.	dataOffset _ aStream position.	"Don't trash these fields if we already got them from the central directory"	self hasDataDescriptor ifFalse: [		crc32 _ xcrc32.		compressedSize _ xcompressedSize.		uncompressedSize _ xuncompressedSize.	].	aStream position: oldPos.! !!ZipReadStream methodsFor: 'crc' stamp: 'BG 3/16/2005 08:28'!verifyCrc	"Verify the CRC-32 checksum calculated from the input against the expected CRC-32, if any.	Answer the calculated CRC-32 in any case.	Note that the CRC-32 used in Zip files is actually the bit inverse of the calculated value, so that is what is returned."	| invertedCrc |	invertedCrc _ crc bitXor: 16rFFFFFFFF.	(expectedCrc notNil and: [ expectedCrc ~= invertedCrc ])		ifTrue: [ ^ self crcError: ('Wrong CRC-32 (expected {1} got {2}) (proceed to ignore)' translated format: { expectedCrc printStringHex. invertedCrc printStringHex }) ].	^invertedCrc! !