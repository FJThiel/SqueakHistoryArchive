'From Squeak2.8alpha of 12 January 2000 [latest update: #1974] on 1 April 2000 at 12:03:05 pm'!"Change Set:		ModularProjectsDate:			19 March 2000Author:			Dan IngallsDefines a complete replacement for the existing ChangeSet class, and reworks all the isolated project logic to use it."!Object subclass: #ChangeSet	instanceVariableNames: 'classChanges methodChanges classRemoves methodRemoves name preamble postscript structures superclasses isolationSet '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!Object subclass: #ChangeSetRevertable	instanceVariableNames: 'name preamble postscript revertable isolationSet isolatedProject changeRecords structures superclasses '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!Object subclass: #ClassChangeRecord	instanceVariableNames: 'inForce revertable changeTypes thisDefinition priorDefinition thisName priorName thisOrganization priorOrganization thisComment priorComment thisMD priorMD methodChanges '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!ChangeSetRevertable class	instanceVariableNames: ''!Object subclass: #MethodChangeRecord	instanceVariableNames: 'changeType currentMethod infoFromRemoval '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail nextProject guards projectParameters isolatedHead inForce version urlList environment '	classVariableNames: 'CurrentProject GoalFreePercent GoalNotMoreThan '	poolDictionaries: ''	category: 'System-Support'!!Behavior methodsFor: 'creating method dictionary' stamp: 'di 4/1/2000 10:11'!recompileNonResidentMethod: method atSelector: selector from: oldClass	"Recompile the method supplied in the context of this class."	| trailer methodNode |	trailer _ (method size - 3 to: method size) collect: [:i | method at: i].	methodNode _ self compilerClass new				compile: (method getSourceFor: selector in: oldClass)				in: self				notifying: nil				ifFail: ["We're in deep doo-doo if this fails (syntax error).						Presumably the user will correct something and proceed,						thus installing the result in this methodDict.  We must						retrieve that new method, and restore the original (or remove)						and then return the method we retrieved."						^ self error: 'see comment'].	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ methodNode generate: trailer! !!Browser methodsFor: 'message category functions' stamp: 'di 3/28/2000 15:55'!alphabetizeMessageCategories	classListIndex = 0		ifTrue: [^ false].	self okToChange ifFalse: [^ false].	Smalltalk changes reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer categories: self rawMessageCategoryList asSortedCollection asArray.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'di 3/28/2000 15:56'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	Smalltalk changes reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer changeFromString: aString.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'di 3/28/2000 15:56'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(oldIndex _ messageCategoryListIndex) = 0 ifTrue: [^ self].	oldName _ self selectedMessageCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	newName = oldName ifTrue: [^ self].	Smalltalk changes reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self classListIndex: classListIndex.	self messageCategoryListIndex: oldIndex.	self changed: #messageCategoryList.! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/23/2000 23:40'!isRevertable	^ false! !!ChangeSet methodsFor: 'accessing' stamp: 'di 3/29/2000 13:59'!isolationSet: setOrNil	setOrNil == self		ifTrue: [isolationSet _ nil]  "Means this IS the isolation set"		ifFalse: [isolationSet _ setOrNil]! !!ChangeSet methodsFor: 'accessing' stamp: 'di 3/23/2000 13:33'!methodInfoFromRemoval: classSelectorPair	^ methodRemoves at: classSelectorPair ifAbsent: [nil]! !!ChangeSet methodsFor: 'testing' stamp: 'di 3/26/2000 17:27'!contentString   "Smalltalk changes contentString"	^ String streamContents: [:strm | self fileOutOn: strm]! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/19/2000 08:36'!addSelector: selector class: class 	"Include indication that a method has been added."	class wantsChangeSetLogging ifFalse: [^ self].	self atSelector: selector class: class put: #add! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/29/2000 11:00'!atSelector: selector class: class put: changeType	(selector==#DoIt) | (selector==#DoItIn:) ifTrue: [^self].	(methodChanges at: class name		ifAbsent: 			[methodChanges at: class name put: (IdentityDictionary new)])				at: selector put: changeType.! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/29/2000 11:00'!changeSelector: selector class: class 	"Include indication that a method has been edited. 	This method must be called before the new method in actually installed, so old methodDictionary state can be saved.  It is now -- keep it that way!!"		class wantsChangeSetLogging ifFalse: [^ self].	(self atSelector: selector class: class) = #add 		ifFalse: [self atSelector: selector class: class put: #change]! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/29/2000 11:07'!noteNewMethod: newMethod forClass: class selector: selector priorMethod: priorMethodOrNil	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		[isolationSet noteNewMethod: newMethod forClass: class selector: selector				priorMethod: priorMethodOrNil].	priorMethodOrNil		ifNotNil: [self changeSelector: selector class: class]		ifNil: [self addSelector: selector class: class]! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/29/2000 12:26'!removeSelector: selector class: class priorMethod: priorMethod lastMethodInfo: infoOrNil	"Include indication that a method has been forgotten."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil: [isolationSet removeSelector: selector class: class							priorMethod: priorMethod lastMethodInfo: infoOrNil].	(self atSelector: selector class: class) = #add		ifTrue: [self atSelector: selector					class: class					put: #addedThenRemoved]		ifFalse: [self atSelector: selector					class: class					put: #remove].	infoOrNil ifNotNil:		["Save the source code pointer and category so can still browse old versions"		methodRemoves at: {class name. selector} put: infoOrNil]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 3/29/2000 13:12'!addClass: class 	"Include indication that a new class was created."	class wantsChangeSetLogging ifTrue:		[isolationSet ifNotNil:			["If there is an isolation layer above me, inform it as well."			isolationSet addClass: class].		self atClass: class add: #new.		self atClass: class add: #change.		self addCoherency: class name]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 3/29/2000 13:13'!changeClass: class from: oldClass	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifTrue: 		[isolationSet ifNotNil:			["If there is an isolation layer above me, inform it as well."			isolationSet changeClass: class from: oldClass].		self atClass: class add: #change.		self addCoherency: class name.		self noteClassStructure: oldClass.		]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 3/29/2000 13:12'!renameClass: class as: newName 	"Include indication that a class has been renamed."	| value |	isolationSet ifNotNil:			["If there is an isolation layer above me, inform it as well."			isolationSet renameClass: class as: newName].	(self atClass: class includes: #rename) ifFalse:		[self atClass: class add: 'oldName: ', class name. 	"only original name matters"		self atClass: class add: #rename]. 	"copy changes using new name (metaclass too)"	(Array with: classChanges with: methodChanges) do:		[:changes |		(value _ changes at: class name ifAbsent: [nil]) == nil ifFalse:			[changes at: newName put: value.			changes removeKey: class name].		(value _ changes at: class class name ifAbsent: [nil]) == nil ifFalse:			[changes at: (newName, ' class') put: value.			changes removeKey: class class name]]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 3/23/2000 23:16'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now.  *** Classes renamed in otherChangeSet may have problems"	| cls info selector pair |	otherChangeSet changedClassNames do: [:className |	  (cls _ Smalltalk classNamed: className) ifNotNil:		[info _ otherChangeSet classChangeAt: className.		info do: [:each | self atClass: cls add: each].		self absorbStructureOfClass: cls from: otherChangeSet.		info _ otherChangeSet methodChanges at: className 			ifAbsent: [Dictionary new].		info associationsDo: [:assoc |			assoc value == #remove				ifTrue:					[selector _ assoc key.					pair _ otherChangeSet methodInfoFromRemoval: {cls name. selector}.					self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]				ifFalse: 					[self atSelector: assoc key class: cls put: assoc value]]]].		classRemoves addAll: otherChangeSet classRemoves.	"names of them"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/27/2000 09:05'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self notify: 'Warning: no changes to file out'].	classList _ ChangeSet superclassOrder: self changedClasses asOrderedCollection.	classList do:		[:aClass |  "if class defn changed, put it onto the file now"			self fileOutClassDefinition: aClass on: stream].	classList do:		[:aClass |  "nb: he following no longer puts out class headers"			self fileOutChangesFor: aClass on: stream].	stream cr.	classList do:		[:aClass |		self fileOutPSFor: aClass on: stream].	classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/27/2000 09:22'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict changeType |	dict _ methodChanges at: class name ifAbsent: [^ self].	dict keysSortedSafely do: [:key | changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue:				[stream nextChunkPut: class name,					' removeSelector: ', key storeString; cr]			ifFalse:				[(key = #initialize and: [class isMeta]) ifTrue:					[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]]! !!ChangeSetRevertable commentStamp: '<historical>' prior: 0!ChangeSets keep track of the changes made to a system, so the user can write the changes on a file as source code (a "fileOut").  Every project has an associated changeSet.  For isolated (modular) projects, this binding is permanent.  For other projects, a different changeSet may be designated to record changes at different times.  Every project exists in an isolation layer defined by its closest enclosing parent that is isolated (or itself).  If a project is not isolated, then cahnges reported to its designated changeSet must also be reported to the permanent changeSet for that layer, designated in the isolated project.  This ensures that that project will be able to revert all changes upon exit.Note that only certain changes may be reverted.  Classes may not be renamed or reshaped except in the layer in which they are defined because renaming and reshaping are not currently revertable.If a Squeak Project is established as being isolated, then its associated changeSet will be declared to be revertable.  In this case all changes stored can be reverted.  The changeSet associated with an isolated project is tied to that project, and cannot be edited in a changeSorter.Isolation layers only control the upward propagation of change.  Changes made in super projects immediately effect code that might run in a sub project.------name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.revertable - a BooleanIf this variable is true, then all of the changes recorded by this changeSet can be reverted.isolationSet - a ChangeSet or nilAn isolationSet is the designated changeSet for an isolation layer.  If this changeSet is an isolationSet, then this variable will be nil.  If not, then it points to the isolationSet for this layer, and all changes reported here must also be reported to the isolationSet.isolatedProject - a Project or nilIf this is an isolationSet, then this variable points to the project with which it is associated.changeRecords -  Dictionary {class name -> a ClassChangeRecord}.The classChangeRecords (qv) remember all of the system changes.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.Of all classes in classChanges, and all of their superclasses.	Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).!!ChangeSetRevertable reorganize!('initialize-release' beIsolationSetFor: clear initialize isMoribund isRevertable veryDeepCopyWith: wither)('change logging' addClass: changeClass:from: noteNewMethod:forClass:selector:priorMethod: removeSelector:class:priorMethod:lastMethodInfo: renameClass:as:)('isolation layers' compileAll:from: invoke isolationSet: revoke uninstall)('accessing' classRemoves editPostscript hasPostscript methodChanges methodInfoFromRemoval: name name: postscriptHasDependents printOn: printOnStream: removePostscript structures superclasses)('testing' belongsToAProject contentString correspondingProject isEmpty okayToRemove okayToRemoveInforming: projectsBelongedTo)('converting')('method changes' atSelector:class:put: browseMessagesWithPriorVersions changedMessageList changedMessageListAugmented forgetChange:forSelector:class: methodChangesAtClass: removeSelectorChanges:class: selectorsInClass:)('class changes' changedClassNames changedClasses classChangeAt: commentClass: fatDefForClass: noteClassForgotten: noteClassStructure: noteRemovalOf: reorganizeClass:)('moving changes' absorbClass:from: absorbMethod:class:from: absorbStructureOfClass:from: assimilateAllChangesFoundIn: editPreamble expungeEmptyClassChangeEntries forgetAllChangesFoundIn: hasPreamble removeClassAndMetaClassChanges: removeClassChanges: removePreamble)('fileIn/Out' assurePostscriptExists assurePreambleExists checkForConversionMethods checkForSlips checkForUnsentMessages fileOut fileOutChangesFor:on: fileOutOn: fileOutPSFor:on: fileOutPostscriptOn: fileOutPreambleOn: lookForSlips postscriptString postscriptString: preambleString preambleString: preambleTemplate summaryString summaryStringDelta:)('private' addCoherency: atClass:add: atClass:includes: atSelector:class: changeRecorderFor: fileOutClassDefinition:on: oldNameFor:)!!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 3/29/2000 20:42'!beIsolationSetFor: aProject	self isEmpty ifFalse: [self error: 'Must be empty at the start.'].	isolatedProject _ aProject.	revertable _ true.! !!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 4/1/2000 12:00'!clear 	"Reset the receiver to be empty.  "	changeRecords _ Dictionary new.	preamble _ nil.	postscript _ nil! !!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 3/29/2000 20:02'!initialize 	"Reset the receiver to be empty."	revertable _ false.	self clear. 	"Avoid duplicate entries in AllChanges if initialize gets called twice"	name _ ChangeSetRevertable defaultName.! !!ChangeSetRevertable methodsFor: 'initialize-release'!isMoribund	"Answer whether the receiver is obsolete and about to die; part of an effort to get such guys cleared out from the change sorter.  2/7/96 sw"	^ name == nil ! !!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 3/23/2000 23:40'!isRevertable	^ true! !!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'sw 3/6/1999 09:31'!veryDeepCopyWith: deepCopier	"Return self; this is NOT the way to launch new change sets!! Having this method here allows Change Sorters to be in parts bins"! !!ChangeSetRevertable methodsFor: 'initialize-release' stamp: 'di 3/23/2000 12:14'!wither	"The receiver is to be clobbered.  Clear it out.  2/7/96 sw"	self clear.	name _ nil! !!ChangeSetRevertable methodsFor: 'change logging' stamp: 'di 3/29/2000 13:10'!addClass: class 	"Include indication that a new class was created."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet addClass: class].	self atClass: class add: #new.	self atClass: class add: #change.	self addCoherency: class name! !!ChangeSetRevertable methodsFor: 'change logging' stamp: 'di 3/29/2000 13:08'!changeClass: class from: oldClass	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifFalse: [^ self]. 	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet changeClass: class from: oldClass].	self atClass: class add: #change.	self addCoherency: class name.	(self changeRecorderFor: class) notePriorDefinition: oldClass.	self noteClassStructure: oldClass! !!ChangeSetRevertable methodsFor: 'change logging' stamp: 'di 3/29/2000 11:08'!noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet noteNewMethod: newMethod forClass: class selector: selector				priorMethod: methodOrNil].	(self changeRecorderFor: class)		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil! !!ChangeSetRevertable methodsFor: 'change logging' stamp: 'di 3/29/2000 12:29'!removeSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info	"Include indication that a method has been forgotten.	info is a pair of the source code pointer and message category	for the method that was removed."	class wantsChangeSetLogging ifFalse: [^ self].	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet removeSelector: selector class: class				priorMethod: priorMethod lastMethodInfo: info].	(self changeRecorderFor: class)		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info! !!ChangeSetRevertable methodsFor: 'change logging' stamp: 'di 3/29/2000 13:11'!renameClass: class as: newName 	"Include indication that a class has been renamed."	| recorder |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: class)		noteChangeType: #rename;		noteNewName: newName.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: class name.	recorder _ changeRecords at: class class name ifAbsent: [^ nil].	changeRecords at: (newName, ' class') put: recorder.	changeRecords removeKey: class class name.! !!ChangeSetRevertable methodsFor: 'isolation layers' stamp: 'di 4/1/2000 09:25'!compileAll: newClass from: oldClass	"If I have changes for this class, recompile them"	(changeRecords at: newClass ifAbsent: [^ self])		compileAll: newClass from: oldClass! !!ChangeSetRevertable methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:47'!invoke	"Do the first part of the invoke operation -- no particular hurry."	changeRecords do: [:changeRecord | changeRecord invokePhase1].	"Complete the invoke process -- this must be very simple."	"Replace method dicts for any method changes."	changeRecords do: [:changeRecord | changeRecord invokePhase2].	Behavior flushCache.! !!ChangeSetRevertable methodsFor: 'isolation layers' stamp: 'di 3/29/2000 13:59'!isolationSet: setOrNil	setOrNil == self		ifTrue: [isolationSet _ nil]  "Means this IS the isolation set"		ifFalse: [isolationSet _ setOrNil]! !!ChangeSetRevertable methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:47'!revoke	"Do the first part of the revoke operation -- this must be very simple."	"Replace original method dicts if there are method changes."	changeRecords do: [:changeRecord | changeRecord revokePhase1].	Behavior flushCache.	"Complete the revoke process -- no particular hurry."	changeRecords do: [:changeRecord | changeRecord revokePhase2].! !!ChangeSetRevertable methodsFor: 'isolation layers' stamp: 'di 3/23/2000 12:00'!uninstall	self halt.! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!classRemoves	^ changeRecords keys select:		[:className | (changeRecords at: className) isClassRemoval]! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'sw 7/1/1999 22:14'!editPostscript	"edit the receiver's postscript, in a separate window.  "	| deps found |	self assurePostscriptExists.	deps _ postscript dependents select:		[:m | (m isKindOf: SystemWindow) or:			[m isKindOf: StandardSystemView]].	deps size > 0 ifTrue:		[Smalltalk isMorphic			ifTrue:				[found _ deps detect: [:obj | (obj isKindOf: SystemWindow) and: [obj world == self currentWorld]] ifNone: [nil].				found ifNotNil:  [^ found activate]]			ifFalse:				[found _ deps detect: [:obj | (obj isKindOf: StandardSystemView) and: [ScheduledControllers scheduledControllers includes: obj controller]] ifNone: [nil].				found ifNotNil: [^ ScheduledControllers activateController: found controller]]..		self inform:'Caution -- there', (deps size isOrAreStringWith: 'other window'), 'already open on this postscript elsewhere'].	postscript openLabel: 'Postscript for ChangeSetRevertable named ', name! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:44'!hasPostscript	^ postscript notNil! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!methodChanges	| methodChangeDict changeTypes |	methodChangeDict _ Dictionary new.	changeRecords associationsDo:		[:assn |		changeTypes _ assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'di 3/29/2000 16:22'!methodInfoFromRemoval: classAndSelector	^ (self changeRecorderFor: classAndSelector first)		infoFromRemoval: classAndSelector last! !!ChangeSetRevertable methodsFor: 'accessing'!name	"The name of this changeSet.	 2/7/96 sw: If name is nil, we've got garbage.  Help to identify."	^ name == nil		ifTrue:			['<no name -- garbage?>']		ifFalse:			[name]! !!ChangeSetRevertable methodsFor: 'accessing'!name: anObject	name _ anObject! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'sw 6/29/1999 20:51'!postscriptHasDependents	^ postscript dependents size > 0! !!ChangeSetRevertable methodsFor: 'accessing'!printOn: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOn: aStream.	aStream nextPutAll: ' named ', self name! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'MPW 1/1/1901 22:02'!printOnStream: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOnStream: aStream.	aStream print: ' named ', self name! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:48'!removePostscript	postscript _ nil! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!structures	^structures! !!ChangeSetRevertable methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!superclasses	^superclasses! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'di 9/10/1999 15:55'!belongsToAProject	Smalltalk at: #Project ifPresent:		[:projClass | projClass allSubInstancesDo:			[:proj | proj projectChangeSetRevertable == self ifTrue: [^ true]]].	^ false! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'di 3/26/2000 17:27'!contentString   "Smalltalk changes contentString"	^ String streamContents: [:strm | self fileOutOn: strm]! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'tk 6/23/1999 07:14'!correspondingProject	"If the receiver is the current change set for any project, answer it, else answer nil"	Project allSubInstancesDo: [:proj |		proj projectChangeSetRevertable == self ifTrue: [^ proj]].	^ nil! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'di 4/1/2000 12:00'!isEmpty	"Answer whether the receiver contains any elements."	^ changeRecords isEmpty ! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == Smalltalk changes ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSetRevertable methodsFor: 'testing' stamp: 'sw 8/17/1999 19:00'!projectsBelongedTo	"Answer a list of all the projects for which the receiver is the current change set"	^ Project allSubInstances select: [:proj |		proj projectChangeSetRevertable == self]! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'di 3/29/2000 11:01'!atSelector: selector class: class put: changeType	(selector == #DoIt or: [selector == #DoItIn:]) ifTrue: [^ self].	(self changeRecorderFor: class) atSelector: selector put: changeType.! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'sw 10/19/1999 15:01'!browseMessagesWithPriorVersions	"Open a message list browser on the new and changed methods in the receiver which have at least one prior version.  6/28/96 sw"	| aList aSelector aClass |	aList _ self changedMessageListAugmented select:		[:msg |  Utilities setClassAndSelectorFrom: msg in: 				[:cl :sl | aClass _ cl.  aSelector _ sl].			(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1].	aList size > 0 ifFalse: [self inform: 'None!!'.  ^ nil].	Smalltalk browseMessageList: aList name: (self name, ' methods that have prior versions')! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!changedMessageList	"Used by a message set browser to access the list view information."	| messageList |	messageList _ SortedCollection new.	changeRecords associationsDo: 		[:clAssoc | 		clAssoc value methodChangeTypes associationsDo: 			[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add: clAssoc key asString, ' ' , mAssoc key]]].	^ messageList asArray! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'tk 6/7/1999 18:57'!changedMessageListAugmented	"Even added classes have all messages in changedMessageList."	^ self changedMessageList asArray! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!forgetChange: actionToSubtract forSelector: selector class: class 	"If the receiver records a change that can be subsumed by the change given by the parameters, which characterize a change in another change set which is being 'subtracted' from the receiver, remove it from the receiver."	| recorder |	recorder _ changeRecords at: class ifAbsent: [^ self].	(class includesSelector: selector)		ifTrue: [(#(add change) includes: actionToSubtract)					ifTrue: [recorder removeKey: selector ifAbsent: []]]		ifFalse: [(#(remove addedThenRemoved) includes: actionToSubtract)					ifTrue: [recorder removeKey: selector ifAbsent: []]]! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!methodChangesAtClass: className	"Return an old-style dictionary of method change types."	^(changeRecords at: className ifAbsent: [^ Dictionary new])		methodChangeTypes! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!removeSelectorChanges: selector class: class 	"Remove all memory of changes associated with the argument, selector, in 	this class."	(changeRecords at: class name ifAbsent: [^ self])		removeSelector: selector! !!ChangeSetRevertable methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!selectorsInClass: aClass	"Used by a ChangeSorter to access the list methods."	^ (changeRecords at: aClass ifAbsent: [^#()]) changedSelectors! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!changedClassNames	"Answer a OrderedCollection of the names of changed or edited classes.	DOES include removed classes.  Sort alphabetically."	^ changeRecords keysSortedSafely ! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'di 3/23/2000 08:12'!changedClasses	"Answer an OrderedCollection of changed or edited classes.	Does not include removed classes.  Sort alphabetically by name."	"Much faster to sort names first, then convert back to classes.  Because metaclasses reconstruct their name at every comparison in the sorted collection.	8/91 sw chgd to filter out non-existent classes (triggered by problems with class-renames"	^ self changedClassNames		collect: [:className | Smalltalk classNamed: className]		thenSelect: [:aClass | aClass notNil]! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!classChangeAt: className	"Return what we know about class changes to this class."	^ (changeRecords at: className ifAbsent: [^ Set new])		allChangeTypes! !!ChangeSetRevertable methodsFor: 'class changes'!commentClass: class 	"Include indication that a class comment has been changed."	self atClass: class add: #comment! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'di 3/28/2000 11:44'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |	newDef _ class definition.	oldDef _ (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm _ ReadStream on: oldDef.	newStrm _ ReadStream on: newDef.	outStrm _ WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames:'; upTo: $'.	outStrm nextPutAll: (newStrm upToAll: 'instanceVariableNames:'); nextPutAll: 'instanceVariableNames:';		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars _ (oldStrm upTo: $') findTokens: Character separators.	newVars _ (newStrm upTo: $') findTokens: Character separators.	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars _ (oldStrm upTo: $') findTokens: Character separators.		newVars _ (newStrm upTo: $') findTokens: Character separators.		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'tk 6/9/1999 19:54'!noteClassForgotten: className	"Remove from structures if class is not a superclass of some other one we are remembering"	structures ifNil: [^ self].	Smalltalk at: className ifPresent: [:cls |		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [			^ self]]].  "No delete"	structures removeKey: className ifAbsent: [].! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'tk 6/9/1999 21:51'!noteClassStructure: aClass	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."	| clsName |	aClass ifNil: [^ self].	structures ifNil: [structures _ Dictionary new.				superclasses _ Dictionary new].	clsName _ (aClass name asLowercase beginsWith: 'anobsolete') 		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]		ifFalse: [aClass name].	(structures includesKey: clsName) ifFalse: [		structures at: clsName put: 			((Array with: aClass classVersion), (aClass allInstVarNames)).		superclasses at: clsName put: aClass superclass name].	"up the superclass chain"	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].! !!ChangeSetRevertable methodsFor: 'class changes' stamp: 'di 3/28/2000 14:40'!noteRemovalOf: class	"The class is about to be removed from the system.	Adjust the receiver to reflect that fact."	(self changeRecorderFor: class)		noteChangeType: #removeClass fromClass: class! !!ChangeSetRevertable methodsFor: 'class changes'!reorganizeClass: class 	"Include indication that a class was reorganized."	self atClass: class add: #reorganize! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 3/23/2000 11:51'!absorbClass: aClass from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.  If aClass has been removed, aClass is the name instead of the class.  *** Classes renamed in otherChangeSet may have problems"	| info |	aClass class == Symbol ifTrue: [		(otherChangeSet classRemoves includes: aClass "name") ifTrue: [			^ self noteRemovalOf: aClass]].	info _ otherChangeSet classChangeAt: aClass name.	info do: [:each | self atClass: aClass add: each].	self absorbStructureOfClass: aClass from: otherChangeSet.	info _ otherChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	info associationsDo: [:ass |		self atSelector: ass key class: aClass put: ass value].! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 3/23/2000 11:52'!absorbMethod: selector class: aClass from: aChangeSet	"Absorb into the receiver all the changes for the method in the class in the other change set."	| info |	info _ aChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	self atSelector: selector class: aClass put: (info at: selector).! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'tk 6/10/1999 12:56'!absorbStructureOfClass: aClass from: otherChangeSetRevertable	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSetRevertable structures ifNil: [^ self].	(otherChangeSetRevertable structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil: [structures _ Dictionary new.		superclasses _ Dictionary new].	sup _ aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [			structures at: sup put: (otherChangeSetRevertable structures at: sup).			next _ otherChangeSetRevertable superclasses at: sup.			superclasses at: sup put: next.			(sup _ next) = 'nil']	] whileFalse.! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 3/26/2000 12:59'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now."	| cls info selector pair |otherChangeSet isRevertable ifTrue: [	otherChangeSet changedClassNames do:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[self absorbStructureOfClass: cls from: otherChangeSet.			(self changeRecorderFor: className)				assimilateAllChangesIn: (otherChangeSet changeRecorderFor: className)]].	otherChangeSet classRemoves do:		[:className | self noteRemovalOf: className]] ifFalse: [	otherChangeSet changedClassNames do:		[:className |	  	(cls _ Smalltalk classNamed: className) ifNotNil:			[info _ otherChangeSet classChangeAt: className.			info do: [:each | self atClass: cls add: each].			self absorbStructureOfClass: cls from: otherChangeSet.			info _ otherChangeSet methodChanges at: className 				ifAbsent: [Dictionary new].			info associationsDo:				[:assoc | selector _ assoc key.				(assoc value == #remove or: [assoc value == #addedThenRemoved])					ifTrue:						[assoc value == #addedThenRemoved							ifTrue: [self atSelector: selector class: cls put: #add].						pair _ otherChangeSet methodInfoFromRemoval: {cls name. selector}.						self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]					ifFalse: 						[self atSelector: selector class: cls put: assoc value]]]].		otherChangeSet classRemoves do:			[:className | self noteRemovalOf: className].	"names of them"]! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'tk 5/4/1998 17:00'!editPreamble	"edit the receiver's preamble, in a separate window.  "	self assurePreambleExists.	preamble openLabel: 'Preamble for ChangeSetRevertable named ', name! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!expungeEmptyClassChangeEntries	| toRemove |	toRemove _ OrderedCollection new.	changeRecords associationsDo:		[:assoc | assoc value hasNoChanges ifTrue:			[toRemove add: assoc key]]. 	toRemove do:		[:aKey | changeRecords removeKey: aKey]! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!forgetAllChangesFoundIn: aChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner.	sw rewrote Aug 98."	| cls itsMethodChanges myClassChange recorder |	aChangeSet == self ifTrue: [^ self].	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	aChangeSet classRemoves do:  "names of them"		[:className | (recorder _ changeRecords at: className ifAbsent: [])			ifNotNil: [recorder forgetClassRemoval]].	self expungeEmptyClassChangeEntries! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:27'!hasPreamble	^ preamble notNil! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassAndMetaClassChanges: class	"Remove all memory of changes associated with this class and its metaclass.  7/18/96 sw"	changeRecords removeKey: class name ifAbsent: [].	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	changeRecords removeKey: cname ifAbsent: [].	self noteClassForgotten: cname.! !!ChangeSetRevertable methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:32'!removePreamble	preamble _ nil! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 9/11/1998 16:13'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 4/7/1999 17:45'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents isEmptyOrNil])		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'ls 10/10/1999 11:37'!checkForConversionMethods	"See if any conversion methods are needed"	| needConversion oldList newList tell choice list need oldVer newVersel smart restore |	"Check preference"	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	structures ifNil: [^ self].	needConversion _ false.	list _ OrderedCollection new.	smart _ SmartRefStream on: (RWBinaryOrTextStream on: '12345').	self changedClasses do: [:class |		need _ (self atClass: class includes: #new) not.		need ifTrue: [			"Also consider renamed classes."			(self atClass: class includes: #rename) ifTrue: [				needConversion _ true.  list add: class].			need _ (self atClass: class includes: #change)].		need ifTrue: [oldList _ structures at: class name 								ifAbsent: [need _ false.  #()]].		need ifTrue: [			newList _ (Array with: class classVersion), (class allInstVarNames).			need _ (oldList ~= newList)].		need ifTrue: [			oldVer _ smart versionSymbol: oldList.			newVer _ smart versionSymbol: newList.			sel _ 'convert',oldVer,':',newVer, ':'.				(Symbol hasInterned: sel ifTrue: [:ignored |]) ifFalse: [				need _ false.				needConversion _ true.				list add: class]].		need ifTrue: [sel _ sel asSymbol.			(#(add change) includes: (self atSelector: sel class: class))ifFalse: [				needConversion _ true.				list add: class]].		].	needConversion ifTrue: ["Ask user if want to do this"		tell _ 'If there might be instances of ', list asArray printString,		'\in a file full of objects on someone''s disk, please fill inconversion methods.\'			withCRs,		'After you edit the methods, you''ll have to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut controls this feature.'.		choice _ (PopUpMenu labels: 'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.') startUpWithCaption:tell. 		choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].		choice = 2 ifTrue: [				list do: [:cls | cls withAllSubclassesDo: [:ccc | 						structures removeKey: ccc name ifAbsent: []]]].		choice ~= 1 ifTrue: [^ self]].	list isEmpty ifTrue: [^ self].	smart structures: structures.	"we will test all classes in structures."	smart superclasses: superclasses.	(restore _ Smalltalk changes) == self ifFalse: [		Smalltalk newChanges: self].	[smart verifyStructure = 'conversion method needed'] whileTrue.		"new method is added to changeSet.  Then filed out with the rest."	restore == self ifFalse: [Smalltalk newChanges: restore].	"tell 'em to fileout again after modifying methods."	self inform: 'Remember to fileOut again after modifying thesemethods.'.! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 3/26/2000 10:06'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips method |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 3/1/2000 15:47'!checkForUnsentMessages	| nameLine allChangedSelectors augList unsent messageList |	nameLine _ '"', self name, '"'.	allChangedSelectors _ Set new.	(augList _ self changedMessageListAugmented) do:		[:aChange |			MessageSet parse: aChange toClassAndSelector: [:cls :sel | cls ifNotNil: [allChangedSelectors add: sel]]].	unsent _ Smalltalk allUnSentMessagesIn: allChangedSelectors.	unsent size = 0		ifTrue:			[self inform: 'There are no unsent messages in change set', nameLine]		ifFalse:			[messageList _ augList select:				[:aChange |					MessageSet parse: aChange toClassAndSelector:						[:cls :sel | unsent includes: sel]].			Smalltalk browseMessageList: messageList name: 'Unsent messages in ', nameLine]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 1/9/2000 10:54'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and either of the date & time or chosen to have a unique numeric tag, depending on the preference 'sequentialChangeSetRevertableFileNames'"	| file slips nameToUse |	self checkForConversionMethods.	nameToUse _ Preferences changeSetVersionNumbers		ifTrue:			[FileDirectory default nextNameFor: self name extension: 'cs']		ifFalse:			[(self name, FileDirectory dot, Utilities dateTimeSuffix, 				FileDirectory dot, 'cs') asFileName].	Cursor write showWhile:		[file _ FileStream newFileNamed: nameToUse.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	Preferences suppressCheckForSlips ifTrue: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 09:35'!fileOutChangesFor: class on: stream 	"Write out all the method changes for this class."	| changes |	changes _ Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | (mAssoc value = #remove or: [mAssoc value = #addedThenRemoved])			ifFalse: [changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		stream cr]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 07:39'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self notify: 'Warning: no changes to file out'].	classList _ ChangeSetRevertable superclassOrder: self changedClasses asOrderedCollection.	"First put out rename, max classDef and comment changes."	classList do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	classList do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	classList reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 4/1/2000 12:00'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict changeType classRecord currentDef |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	dict keysSortedSafely do:		[:key | changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((self atClass: class includes: #change)		and: [(currentDef _ class definition) ~= (self fatDefForClass: class)]) ifTrue:		[stream command: 'H3'; nextChunkPut: currentDef; cr; command: '/H3'].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 13:35'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	aString _ self postscriptString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 14:58'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	aString _ self preambleString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 3/8/1999 12:07'!lookForSlips	| slips nameLine msg |	nameLine _ '"', self name, '"'.	(slips _ self checkForSlips) size == 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg _ slips size == 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(self confirm: msg)		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 5/7/1998 12:16'!postscriptString	"Answer the string representing the postscript.  "	^ postscript == nil		ifTrue:			[postscript]		ifFalse:			[postscript contents asString]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!postscriptString: aString	"Establish aString as the new contents of the postscript.  "	postscript _ StringHolder new contents: aString! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 5/7/1998 12:08'!preambleString	"Answer the string representing the preamble"	^ preamble == nil		ifTrue:			[preamble]		ifFalse:			[preamble contents asString]! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ StringHolder new contents: aString! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'sw 9/10/1998 12:37'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"Smalltalk changes preambleTemplate"! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:33'!summaryString	"Answer the string summarizing this changeSet"	^ self summaryStringDelta: 0"To summarize all recent changeSets on a file...(FileStream newFileNamed: 'Summaries.txt') nextPutAll:	(String streamContents:		[:s | (ChangeSorter changeSetsNamedSuchThat:			[:name | name first isDigit and: [name initialIntegerOrNil >= 948]])			 do: [:cs | s nextPutAll: cs summaryString; cr]]);		closeTo list all changeSets with a certain string in the preamble...	(FileStream newFileNamed: 'MyUpdates.txt') nextPutAll:		(String streamContents:			[:s | ChangeSorter gatherChangeSetRevertables do:				[:cs | (cs preambleString notNil					and: [cs preambleString includesSubString: 'Author Name'])				 	ifTrue: [s nextPutAll: cs summaryString; cr]]]);		close"! !!ChangeSetRevertable methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:27'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"	| ps s2 date author line intName |	^ String streamContents:		[:s |		intName _ self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date _ s2 upTo: Character cr.			s2 match: 'Author:'; skipSeparators.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 3/23/2000 08:37'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	(self changeRecorderFor: className)		checkCoherence."	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]"! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 3/28/2000 14:40'!atClass: class add: changeType	(self changeRecorderFor: class)		noteChangeType: changeType fromClass: class! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atClass: class includes: changeType	^(changeRecords at: class name ifAbsent: [^false])		includesChangeType: changeType! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atSelector: selector class: class	^ (changeRecords at: class name ifAbsent: [^ #none])		atSelector: selector ifAbsent: [^ #none]! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 3/29/2000 20:46'!changeRecorderFor: class	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname			ifAbsent: [^ changeRecords at: cname							put: (ClassChangeRecord new initFor: cname revertable: revertable)]! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 3/28/2000 09:23'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	((self atClass: class includes: #change) or: [self atClass: class includes: #add]) ifTrue:		[stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass].! !!ChangeSetRevertable methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!oldNameFor: class	^ (changeRecords at: class name) priorName! !!ChangeSorter methodsFor: 'message list' stamp: 'di 3/23/2000 13:34'!browseVersions	"Create and schedule a changelist browser on the versions of the 	selected message."	| class selector method category pair sourcePointer |	(selector _ self selectedMessageName) ifNil: [^ self].	class _ self selectedClassOrMetaClass.	(class includesSelector: selector)		ifTrue: [method _ class compiledMethodAt: selector.				category _ class whichCategoryIncludesSelector: selector.				sourcePointer _ nil]		ifFalse: [pair _ myChangeSet methodInfoFromRemoval: {class name. selector}.				pair ifNil: [^ nil].				sourcePointer _ pair first.				method _ CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category _ pair last].	VersionsBrowser		browseVersionsOf: method		class: self selectedClass meta: class isMeta		category: category selector: selector		lostMethodPointer: sourcePointer.! !!ChangeSorter methodsFor: 'code pane' stamp: 'di 3/28/2000 12:02'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents _ strm contents].! !Smalltalk renameClassNamed: #ClassChangeRecorder as: #ClassChangeRecord!!ClassChangeRecord commentStamp: '<historical>' prior: 0!A ClassChangeRecorder keeps track of most substantive changes premissible in a project, isolated or not.Structure:inForce		a boolean			Tells whether these changes are in effect.			true for all changeSets in and above the current project.			It should be sufficient only to record this for the changeSet			as a whole, but this redundancy could help in error recovery.classIsLocal	a boolean			True if and only if this class is defined in this layer of the			project structure.changeTypes an identitySet			Summarizes which changes have been made in this class.			Values include #comment, #reorganize, #rename,			and the four more summarized below.thisName	a string			Retains the class name for this layer.priorName	a string			Preserves the prior name.thisComment	a text			Retains the class comment for this layer.priorComment	a text			Preserves the prior comment.thisOrganization	a classOrganizer			Retains the class organization for this layer.priorOrganization	a classOrganizer			Preserves the prior organization.thisMD	a methodDictionary			Used to prepare changes for nearly atomic invocation			of this layer (see below).priorMD	a methodDictionary			Preserves the state of an altered class as it exists in the next			outer layer of the project structure.methodChanges		a dictionary of classChangeRecords			Retains all the method changes for this layer.Four of the possible changeTypes are maintained in a mutually exclusive set, analogously to MethodChangeRecords.  Here is a simple summary of the relationship between these four changeType symbols and the recording of prior state			|	prior == nil			|	prior not nil		---------	|----------------------------	|--------------------	add		|	add					|	change	---------	|----------------------------	|--------------------	remove	|	addedThenRemoved	|	removeA classChangeRecorder is notified of changes by the method		noteMethodChange: <ClassChangeRecord>.ClassChangeRecorders are designed to invoke a set of changes relative to the definition of a class in an prior layer.  It is important that both invocation and revocation of these changes take place in a nearly atomic fashion so that interdependent changes will be adopted as a whole, and so that only one flush of the method cache should be necessary.  A further reason for revocation to be simple is that it may be requested as an attempt to recover from an error in a project that is failing.!!ClassChangeRecord reorganize!('all changes' allChangeTypes hasNoChanges includesChangeType: noteChangeType: noteChangeType:fromClass:)('isolation layers' invokePhase1 invokePhase2 realClass revokePhase1 revokePhase2)('definition' checkCoherence notePriorDefinition: priorDefinition)('rename' noteNewName: priorName)('comment')('removal' forgetClassRemoval isClassRemoval)('organization')('method changes' atSelector:ifAbsent: atSelector:put: changedSelectors compileAll:from: findOrMakeMethodChangeAt:priorMethod: infoFromRemoval: methodChangeTypes noteNewMethod:selector:priorMethod: noteRemoveSelector:priorMethod:lastMethodInfo: removeSelector:)('initialization' initFor:revertable:)!!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 10:58'!allChangeTypes	^ changeTypes! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 10:59'!hasNoChanges	^ changeTypes isEmpty and: [methodChanges isEmpty]! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/24/2000 09:36'!includesChangeType: changeType	changeType == #new ifTrue: [^ changeTypes includes: #add].  "Backwd compat"	^ changeTypes includes: changeType! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 15:14'!noteChangeType: changeSymbol	^ self noteChangeType: changeSymbol fromClass: nil! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 23:12'!noteChangeType: changeSymbol fromClass: class	changeSymbol = #new ifTrue:		[changeTypes add: #add.		changeTypes remove: #change ifAbsent: [].		^ self].	changeSymbol = #change ifTrue:		[(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol = #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue:		["Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName _ changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	(changeSymbol = #removeClass or: [changeSymbol = #remove]) ifTrue:		[(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAllFoundIn: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 22:00'!invokePhase1	| selector changeRecord type elements |	revertable ifFalse: [^ self].	inForce ifTrue: [self error: 'Can invoke only when not in force.'].	"Do the first part of the invoke operation -- no particular hurry."	"Save the outer method dictionary for quick revert of method changes."	priorMD _ self realClass methodDict.	"Prepare a methodDictionary for switcheroo."	thisMD _ self realClass methodDict copy.	methodChanges associationsDo:		[:assn | selector _ assn key. changeRecord _ assn value.		type _ changeRecord changeType.		type = #remove ifTrue: [thisMD removeKey: selector].		type = #add ifTrue: [thisMD at: selector put: changeRecord currentMethod].		type = #change ifTrue: [thisMD at: selector put: changeRecord currentMethod].		].	"Replace the original organization (and comment)."	priorOrganization _ self realClass organization.	thisOrganization elementArray copy do:		[:sel | (thisMD includesKey: sel) ifFalse: [thisOrganization removeElement: sel]].	#(DoIt DoItIn:) do: [:sel | thisMD removeKey: sel ifAbsent: []].	thisOrganization elementArray size = thisMD size ifFalse:		[elements _ thisOrganization elementArray asSet.		thisMD keysDo:			[:sel | (elements includes: sel) ifFalse:				[thisOrganization classify: sel					under: (priorOrganization categoryOfElement: sel)]]].	self realClass organization: thisOrganization.! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!invokePhase2	revertable ifFalse: [^ self].	"Do the second part of the revert operation.  This must be very simple."	"Replace original method dicts if there are method changes."	self realClass methodDictionary: thisMD.  "zap.  Must flush Cache in outer loop."	inForce _ true.! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/30/2000 18:03'!realClass	"Return the actual class (or meta), as determined from my name."	thisName ifNil: [^ nil].	(thisName endsWith: ' class')		ifTrue: [^ (Smalltalk at: (thisName copyFrom: 1 to: thisName size - 6) asSymbol						ifAbsent: [^ nil]) class]		ifFalse: [^ Smalltalk at: thisName ifAbsent: [^ nil]]! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!revokePhase1	revertable ifFalse: [^ self].	inForce ifFalse: [self error: 'Can revoke only when in force.'].	"Do the first part of the revoke operation.  This must be very simple."	"Replace original method dict if there are method changes."	self realClass methodDictionary: priorMD  "zap.  Must flush Cache in outer loop."! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!revokePhase2	revertable ifFalse: [^ self].	"Replace the original organization (and comment)."	thisOrganization _ self realClass organization.	self realClass organization: priorOrganization.	inForce _ false.! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:06'!checkCoherence	"If I recreate the class then don't remove it"	(changeTypes includes: #remove) ifTrue:		[changeTypes remove: #remove.		changeTypes add: #change].	(changeTypes includes: #addedThenRemoved) ifTrue:		[changeTypes remove: #addedThenRemoved.		changeTypes add: #add].! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:08'!notePriorDefinition: oldClass	oldClass ifNil: [^ self].	priorDefinition ifNil: [priorDefinition _ oldClass definition]! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/28/2000 09:12'!priorDefinition	^ priorDefinition! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 3/28/2000 22:45'!noteNewName: newName	thisName _ newName asSymbol! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 3/24/2000 09:38'!priorName	^ priorName! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 3/23/2000 12:27'!forgetClassRemoval	self halt.! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 3/27/2000 08:35'!isClassRemoval	"NOTE: there are other removals with changeType #addedThenRemoved,	but this message is used to write out removals in fileOut, and those	cases should not be written out."	^ changeTypes includes: #remove! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 10:38'!atSelector: selector ifAbsent: absentBlock	^ (methodChanges at: selector ifAbsent: absentBlock)		changeType! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 11:01'!atSelector: selector put: changeType	(self findOrMakeMethodChangeAt: selector priorMethod: nil)		noteChangeType: changeType! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 10:07'!changedSelectors	"Return a set of the changed or removed selectors."	^ methodChanges keys! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 4/1/2000 10:45'!compileAll: newClass from: oldClass	"Something about this class has changed.  Locally retained methods must be recompiled.	NOTE:  You might think that if this changeSet is in force, then we can just note	the new methods but a lower change set may override and be in force which	would mean that only the overriding copies go recompiled.  Just do it."	| sel changeType changeRecord newMethod |	methodChanges associationsDo:		[:assn | sel _ assn key.  changeRecord _ assn value.		changeType _ changeRecord changeType.		(changeType == #add or: [changeType == #change]) ifTrue:			[newMethod _ newClass				recompileNonResidentMethod: changeRecord currentMethod				atSelector: sel from: oldClass.			changeRecord noteNewMethod: newMethod]]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 11:01'!findOrMakeMethodChangeAt: selector priorMethod: priorMethod	^ methodChanges at: selector		ifAbsent: [methodChanges at: selector						put: (MethodChangeRecord new priorMethod: priorMethod)]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/29/2000 16:26'!infoFromRemoval: selector	^ (methodChanges at: selector ifAbsent: [^ nil])		methodInfoFromRemoval! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/24/2000 09:46'!methodChangeTypes	"Return an old-style dictionary of method change types."	| dict selector record |	dict _ IdentityDictionary new.	methodChanges associationsDo:		[:assn | selector _ assn key.  record _ assn value.		dict at: selector put: record changeType].	^ dict! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 23:28'!noteNewMethod: newMethod selector: selector priorMethod: methodOrNil	| methodChange |	methodChange _ self findOrMakeMethodChangeAt: selector priorMethod: methodOrNil.	methodOrNil == nil		ifTrue: [methodChange noteChangeType: #add]		ifFalse: [methodChange noteChangeType: #change].	methodChange noteNewMethod: newMethod.! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/23/2000 23:00'!noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: infoOrNil	| methodChange |	methodChange _ self findOrMakeMethodChangeAt: selector priorMethod: priorMethod.	methodChange changeType == #add		ifTrue: [methodChange noteChangeType: #addedThenRemoved]		ifFalse: [methodChange noteChangeType: #remove].	infoOrNil ifNotNil:		["Save the source code pointer and category so can still browse old versions"		methodChange noteMethodInfoFromRemoval: infoOrNil]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/23/2000 11:58'!removeSelector: selector	"Remove all memory of changes associated with the argument, selector, in 	this class."	methodChanges removeKey: selector ifAbsent: []! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'di 3/29/2000 22:06'!initFor: className revertable: isRevertable	inForce _ isRevertable.	revertable _ isRevertable.	changeTypes _ IdentitySet new.	methodChanges _ IdentityDictionary new.	priorName _ thisName _ className.	revertable ifTrue:		[priorMD _ self realClass methodDict copy.		priorOrganization _ self realClass organization deepCopy].! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/23/2000 23:08'!removeSelector: selector 	| priorMethod | 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	(self methodDict includesKey: selector) ifFalse: [^ nil].	priorMethod _ self compiledMethodAt: selector.	Smalltalk changes removeSelector: selector class: self		priorMethod: priorMethod		lastMethodInfo: {priorMethod sourcePointer.						(self whichCategoryIncludesSelector: selector)}.	super removeSelector: selector.	self organization removeElement: selector.	self acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange: self name , ' removeSelector: #' , selector]! !!ClassDescription methodsFor: 'compiling' stamp: 'di 3/23/2000 20:47'!compile: code notifying: requestor trailer: bytes 		ifFail: failBlock		elseSetSelectorAndNode: selAndNodeBlock	"Intercept this message in order to remember system changes.	 5/15/96 sw: modified so that if the class does not wish its methods logged in the changes file, then they also won't be accumulated in the current change set.	7/12/96 sw: use wantsChangeSetLogging to determine whether to put in change set"	| methodNode selector newMethod priorMethodOrNil |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	selector _ methodNode selector.	selAndNodeBlock value: selector value: methodNode.	requestor ifNotNil:		["Note this change for recent submissions list"		Utilities noteMethodSubmission: selector forClass: self].	methodNode encoder requestor: requestor.  "Why was this not preserved?"	newMethod _ methodNode generate: bytes.	priorMethodOrNil _ (methodDict includesKey: selector)		ifTrue: [self compiledMethodAt: selector]		ifFalse: [nil].	Smalltalk changes noteNewMethod: newMethod forClass: self		selector: selector priorMethod: priorMethodOrNil.	self addSelector: selector withMethod: newMethod.	^ newMethod! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 14:34'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ self organization classComment: aString].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	Smalltalk changes commentClass: self.	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).! !!Class methodsFor: 'class name' stamp: 'di 3/28/2000 11:34'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	newName _ aString asSymbol.	(Smalltalk includesKey: newName)		ifTrue: [^self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [^ SelectionMenu notify: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	Smalltalk renameClass: self as: newName.	name _ newName.! !!Class methodsFor: 'class variables' stamp: 'di 3/27/2000 21:54'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol |	aString first isLowercase		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		subclass scopeHas: symbol			ifTrue: [:temp | 					^ self error: aString 						, ' is already used as a variable name in class ' 						, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		Smalltalk changes changeClass: self from: self.		classPool declare: symbol from: Undeclared]! !!ChangeSetRevertable class methodsFor: 'fileIn/Out' stamp: 'RAA 9/30/1999 14:34'!superclassOrder: classes 	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in."	| all list i aClass |	list _ classes copy. 			"list is indexable"	all _ OrderedCollection new: list size.	[list size > 0] whileTrue: [		i _ 0.		[			i _ i + 1.			aClass _ list at: i.			(list includesAnyOf: aClass allSuperclasses) or: [				aClass isMeta and: [					(list includes: aClass soleInstance) or: [						list includesAnyOf: aClass soleInstance allSuperclasses					] 				].			].		] whileTrue.		all addLast: aClass.		list _ list copyWithout: aClass	].	^all! !!ChangeSetRevertable class methodsFor: 'defaults' stamp: 'di 3/23/2000 15:20'!defaultName	| namesInUse try |	namesInUse _ ChangeSorter gatherChangeSets					collect: [:each | each name].	1 to: 999999 do:		[:i | try _ 'Unnamed' , i printString.		(namesInUse includes: try) ifFalse: [^ try]]! !!ChangeSetRevertable class methodsFor: 'defaults' stamp: 'di 3/23/2000 15:44'!test"	ChangeSetRevertable new initialize assimilateAllChangesFoundIn:		(ChangeSorter changeSetNamed: 'ModularProjects')"! !!ClassOrganizer methodsFor: 'method dictionary' stamp: 'di 3/29/2000 21:41'!allMethodSelectors	"give a list of all method selectors."	^ elementArray copy sort! !!ClassOrganizer methodsFor: 'private' stamp: 'di 3/29/2000 21:42'!elementArray	^ elementArray! !!Dictionary methodsFor: 'printing' stamp: 'di 3/8/2000 09:14'!printOn: aStream	aStream nextPutAll: self class name, ' ('.	self keysSortedSafely do:		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key); space].	aStream nextPut: $)! !!MethodChangeRecord commentStamp: '<historical>' prior: 0!MethodChangeRecords are used to record method changes.  Here is a simple summary of the relationship between the changeType symbol and the recording of prior state			|	prior == nil			|	prior not nil		---------	|----------------------------	|--------------------	add		|	add					|	change	---------	|----------------------------	|--------------------	remove	|	addedThenRemoved	|	removeStructure:changeType			symbol -- as summarized abovecurrentMethod	method				This is the current version of the method.				It can be used to assert this change upon entry to a layer. infoFromRemoval -- an array of size 2.				The first element is the source index of the last version of the method.				The second element is the category in which it was defined, so it				can be put back there if re-accepted from a version browser.Note that the above states each have an associated revoke action:	add --> remove	change --> change back	remove --> add back	addedThenRemoved --> no changeHowever all of these are accomplished trivially by restoring the original method dictionary.!!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!changeType	^ changeType! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 3/28/2000 23:34'!currentMethod	^ currentMethod! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!methodInfoFromRemoval	"Return an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	(changeType == #remove or: [changeType == #addedThenRemoved])		ifTrue: [^ infoFromRemoval]		ifFalse: [^ nil]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!noteChangeType: newChangeType	changeType _ newChangeType! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 11:05'!noteMethodInfoFromRemoval: info	"Store an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	infoFromRemoval _ info! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 3/28/2000 23:32'!noteNewMethod: newMethod	currentMethod _ newMethod! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!printOn: strm	super printOn: strm.	strm nextPutAll: ' ('; print: changeType; nextPutAll: ')'! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 10:47'!priorMethod: ignored	"We do not save original versions of changed methods because we only	revoke changes at the level of entire classes, and that is done by	restoration of the entire methodDictionary."! !!Project commentStamp: '<historical>' prior: 0!A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet.  A project knows who its parent project is.  When you change projects, whether by entering or exiting, the screen state of the project being exited is saved in that project.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Project named: 'xxx') exportSegment, or choose 'store project on file...'.  Projects may be loaded from a server and stored back.  Storing on a server never overwrites;  it always makes a new version.  A project remembers the url of where it lives in urlList.  The list is length one, for now.  The url may point to a local disk instead of a server.  All projects that the user looks at, are cached in the Squeaklet folder.  Sorted by server.  The cache holds the most recent version only.  For now, control of saving an reloading is from the thumbnail that owns the project.IsolationWhen you accept a method, the entire system feels the change, except projects that are "isolated".  In an isolated project, all new global variables (including new classes) are stored in the project-local environment, and all changes to preexisting classes are revoked when you leave the project.  When you enter another project, that project's changes are invoked.  Invocation and revocation are handled efficiently by swapping pointers.  To make a project be isolated, choose 'isolate changes of this project' from the 'changes...' section of the screen menu.  You can use an isolated project for making dangerous change to a system, and you can get out if it crashes.  A foreign application can have the separate environment it wants.  Also, you can freeze part of the system for a demo that you don't want to disturb.  An isolated project shares methods with all subprojects inside it, unless they are isolated themselves.   Each isolated project is the head of a tree of projects with which it shares all methods.You may 'assert' all changes ever made in the current project to take effect above this project.  This amounts to exporting all the globals in the current environment, and zapping the revocation lists to that the current state of the world will remain in force upon exit from this project.[Later: A project may be 'frozen'.  Asserts do not apply to it after that.  (Great for demos.)  You should be informed when an assert was blocked in a frozen project.]Class definitions are layered by the isolation mechanism.  You are only allowed to change the shape of a class in projects that lie within its isolation scope.  All versions of the methods are recompiled, in all projects.  If you remove an inst var that is in use in an isolated project, it will become an Undeclared global.  It is best not to remove an inst var when it is being used in another isolated project. [If we recompile them all, why can't we diagnose the problem before allowing the change??]Senders and Implementors do not see versions of a method in isolated projects.  [again, we might want to make this possible at a cost].  When you ask for versions of a method, you will not get the history in other isolated projects.Moving methods and classes between changeSets, and merging changeSets has no effect on which methods are in force.  But, when you look at a changeSet from a different isolated project, the methods will contain code that is not in force.  A changeSet is just a list of method names, and does not keep separate copies of any code.When finer grained assertion is needed, use the method (aProject assertClass: aClass from: thisProject warn: warnConflicts).How isolated changes work: The first time a class changes, store its MethodDictionary object.  Keep parallel arrays of associations to Classes and MethodDictionaries.  Traverse these and install them when you enter an "ioslated project".  When you leave, store this project's own MethodDictionaries there.	To do an assert, we must discover which methods changed here, and which changed only in the project we are asserting into.  There is one copy of the 'virgin' method dictionaries in the system.  It is always being temporarily stored by the currently inForce isolated project.isolatedHead - true for the top project, and for each isolated project.  false or nil for any subproject that shares all methods with its parent project.inForce -  true if my methods are installed now.  false if I am dormant. [is this equivalent to self == Project Current?]classArray - list of associations to classes methodDictArray - the method dictionaries of those classes before we started changing methods.  They hang onto the original compiledMethods.  (If this project is dormant, it contains the method dictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - No longer used.!!Project reorganize!('initialization' backgroundColorForMorphicProject backgroundColorForMvcProject defaultBackgroundColor initMorphic initialExtent initialProject initialize installPasteUpAsWorld: setChangeSet: setProjectHolder: windowActiveOnFirstClick windowReqNewLabel:)('accessing' addGuard: displayDepth: environment inForce: isMorphic isTopProject labelString leaveThisWorld name nextProject parent previousProject projectChangeSet setParent: setThumbnail: setViewSize: thumbnail urlList: viewSize world)('menu messages' enter enter: enter:revert:saveForRevert: exit fileOut makeThumbnail saveState viewLocFor:)('release' addDependent: canDiscardEdits deletingProject: okToChange release)('active process' activeProcess interruptName: maybeForkInterrupt resumeProcess: spawnNewProcess spawnNewProcessAndTerminateOld: spawnNewProcessIfThisIsUI:)('printing' printOn:)('file in/out' exportSegment exportSegmentWithCatagories:classes: fromMyServerLoad: installRemoteFrom:named: loadFromServer newVersion: objectForDataStream: revert saveForRevert serverList storeDataOn: storeOnServer storeSegment storeSegmentNoFile storeSomeSegment storeToMakeRoom url versionFrom:)('object fileIn' convertdwctppdaevtngpiicmo0:dwctppdaevtngpiicmovu0: convertdwctppdaevtngpiicmovu0:dwctppdaevtngpiicmovue0:)('project parameters' flapsSuppressed flapsSuppressed: initializeProjectParameters projectParameters rawParameters removeParameter:)('displaying' displayZoom: imageForm imageFormOfSize:depth: showZoom)('isolation layers' assert beIsolated compileAll:from: compileAllIsolated:from: invoke invokeFrom: isolationHead isolationSet layersToTop revoke)!!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!initMorphic	"Written so that Morphic can still be removed."	Smalltalk verifyMorphicAvailability ifFalse: [^ nil].	self initialize.	world _ PasteUpMorph newWorldForProject: self.! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:15'!initialize	changeSet _ ChangeSet new initialize.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ CurrentProject.	isolatedHead _ false.! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 13:54'!setChangeSet: aChangeSet	isolatedHead ifTrue: [^ self].  "ChangeSet of an isolated project cannot be changed"	changeSet _ aChangeSet! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!setProjectHolder: aProject	self initialize.	world _ ControlManager new.! !!Project methodsFor: 'accessing' stamp: 'di 3/29/2000 15:37'!isTopProject	"Return true only if this is the top project (its own parent).	Also include the test here for malformed project hierarchy."	parentProject == self ifTrue: [^ true].	parentProject == nil ifTrue: [self error: 'No project should have a nil parent'].	^ false! !!Project methodsFor: 'menu messages' stamp: 'di 3/29/2000 17:06'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg |	self == CurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject makeThumbnail].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	World isMorph ifTrue: [World triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	World isMorph ifTrue:		[recorderOrNil _ World pauseEventRecorder].	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: World].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	"Complete the enter: by launching a new process"	world isMorph		ifTrue:			[self spawnNewProcessAndTerminateOld: true]		ifFalse:			[showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:17'!assert	"Assert these changes in the next higher isolation layer of the system."	isolatedHead ifFalse: [self error: 'You can only assert changes from isolated projects'].	self halt."This will be done by either clearing out the project changeSet or installing a new one (initted for isolation).  If the changeSet is empty, then not revert will happen when we leave, and the changes will have effectively propagated up a level.  NOTE: for this to work in general, the changes here must be assimilated into the isolationSet for the next layer."! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 20:44'!beIsolated	"Establish an isolation layer at this project.	This requires clearing the current changeSet or installing a new one."	isolatedHead ifTrue: [^ self error: 'Already isolated'].	Project current == self ifFalse:		[^ self inform: 'Must be in this project to isolate it'.].	changeSet isEmpty ifFalse: [changeSet _ ChangeSorter newChangeSet].	[changeSet isMemberOf: ChangeSetRevertable]		whileFalse: [changeSet _ ChangeSorter newChangeSet].	changeSet beIsolationSetFor: self.	isolatedHead _ true.	inForce _ true.	environment _ Environment new setName: self name outerEnvt: Smalltalk.! !!Project methodsFor: 'isolation layers' stamp: 'di 4/1/2000 09:22'!compileAll: newClass from: oldClass	"Make sure that shadowed methods in isolation layers get recompiled.	Traversal is done elsewhere.  This simply handles the current project."	isolatedHead == true ifFalse: [^ self].   "only isolated projects need to act on this."		changeSet compileAll: newClass from: oldClass! !!Project methodsFor: 'isolation layers' stamp: 'di 4/1/2000 10:27'!compileAllIsolated: newClass from: oldClass	"Whenever a recompile is needed in a class, look in other isolated projects for saved methods and recompile them also.	At the time this method is called, the recompilation has already been done for the project now in force."	Project allSubInstancesDo: [:proj | proj compileAll: newClass from: oldClass].! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:04'!invoke	"Install all methods changed here into method dictionaries.	Make my versions be the ones that will be called."	isolatedHead ifFalse: [^ self error: 'This isnt an isolation layer.'].	inForce ifTrue: [^ self error: 'This layer is already in force.'].	changeSet invoke.		inForce _ true.! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 15:49'!invokeFrom: otherProject	"Revoke the changes in force for this project, and then invoke those in force for otherProject.  This method shortens the process to the shortest path up then down through the isolation layers."	| pathUp pathDown |	pathUp _ otherProject layersToTop.  "Full paths to top"	pathDown _ self layersToTop.	"Shorten paths to nearest common ancestor"	[pathUp isEmpty not		and: [pathDown isEmpty not		and: [pathUp last == pathDown last]]]		whileTrue: [pathUp removeLast.  pathDown removeLast].	"Now revoke changes up from otherProject and invoke down to self."	pathUp do: [:p | p revoke].	pathDown reverseDo: [:p | p invoke].! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 17:16'!isolationHead	"Go up the parent chain and find the nearest isolated project."	isolatedHead == true ifTrue: [^ self].	self isTopProject ifTrue: [^ self].	^ parentProject isolationHead! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 17:00'!isolationSet	"Return the changeSet for this isolation layer or nil"	isolatedHead == true ifTrue: [^ changeSet].	self isTopProject ifTrue: [^ nil].  "At the top, but not isolated"	^ parentProject isolationSet! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 15:40'!layersToTop	"Return an OrderedCollection of all the projects that are isolation layers from this one up to the top of the project hierarchy, inclusive."	| layers |	self isTopProject		ifTrue: [layers _ OrderedCollection new]		ifFalse: [layers _ parentProject layersToTop].	isolatedHead ifTrue: [layers addFirst: self].	^ layers! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:06'!revoke	"Take back all methods changed here.	Install the original method dictionaries and organizations.	The orignal method versions will now be the ones used."	isolatedHead ifFalse: [^ self error: 'This isnt an isolation layer.'].	inForce ifFalse: [^ self error: 'This layer should have been in force.'].	changeSet revoke.		inForce _ false.! !!SystemDictionary methodsFor: 'class names' stamp: 'di 3/26/2000 09:06'!classNamed: className 	"className is either a class name or a class name followed by ' class'.	Answer the class or metaclass it names"	| meta baseName baseClass |	(className endsWith: ' class')		ifTrue: [meta _ true.				baseName _ className copyFrom: 1 to: className size - 6]		ifFalse: [meta _ false.				baseName _ className].	baseClass _ Smalltalk at: baseName asSymbol ifAbsent: [^ nil].	meta		ifTrue: [^ baseClass class]		ifFalse: [^ baseClass]! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 3/29/2000 14:23'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChanges isolationSet: nil.	SystemChanges _ aChangeSet.	Smalltalk currentProjectDo:		[:proj |		proj setChangeSet: aChangeSet.		aChangeSet isolationSet: proj isolationSet]! !!Environment methodsFor: 'instance creation' stamp: 'di 3/16/2000 12:54'!setName: name outerEnvt: outer	outerEnvt _ outer.	envtName _ name.! !!Environment methodsFor: 'printing' stamp: 'di 3/16/2000 12:53'!printOn: aStream	envtName ifNil: [aStream nextPutAll: self name]		ifNotNil: [aStream nextPutAll: 'An Environment named ' , envtName]! !!Environment methodsFor: 'fileIn/out' stamp: 'di 4/1/2000 10:57'!isInMemory	self associationsDo:		[:a | ^ a value isInMemory].	^ true! !!Utilities class methodsFor: 'recent method submissions' stamp: 'di 3/19/2000 08:28'!noteMethodSubmission: selectorName forClass: class	| submission className |	class wantsChangeSetLogging ifFalse: [^ self].	className _ class name.	self purgeRecentSubmissionsOfMissingMethods.	submission _ className asString, ' ', selectorName.	(self recentMethodSubmissions includes: submission)		ifTrue: [RecentSubmissions remove: submission]		ifFalse: [(RecentSubmissions size >= self numberOfRecentSubmissionsToStore) 					ifTrue: [RecentSubmissions removeFirst]].	RecentSubmissions addLast: submission! !ChangeSet removeSelector: #absorbChangesInChangeSetsNamed:!ChangeSet removeSelector: #flushClassRemoves!ChangeSet removeSelector: #hasClassChangesFor:!ChangeSet removeSelector: #inspectMethodChanges!ChangeSet removeSelector: #methodRemoves!ChangeSet removeSelector: #noteNewSelector:forClass:!ChangeSet removeSelector: #removeAllMemoryOfChangesTo:!ChangeSet removeSelector: #removeAllMemoryOfChangesToClassNamed:!ChangeSet removeSelector: #removeSelector:class:!ChangeSet removeSelector: #selectorList!ChangeSet removeSelector: #undoChange:for:class:!ChangeSet removeSelector: #verifyClassRemoves!ChangeSetRevertable removeSelector: #addSelector:class:!ChangeSetRevertable removeSelector: #assert!ChangeSetRevertable removeSelector: #changeSelector:class:!ChangeSetRevertable removeSelector: #fileOutClassModifications:on:!ChangeSetRevertable removeSelector: #noteNewSelector:forClass:!ChangeSetRevertable removeSelector: #removeSelector:class:!ChangeSetRevertable removeSelector: #revert!ClassChangeRecord removeSelector: #addChangeType:!ClassChangeRecord removeSelector: #assertPhase1!ClassChangeRecord removeSelector: #assertPhase2!ClassChangeRecord removeSelector: #ensureMethodChangeAt:!ClassChangeRecord removeSelector: #initFor:!ClassChangeRecord removeSelector: #noteNewMethod:selector:priorMethod:fromClass:!ClassChangeRecord removeSelector: #revertPhase1!ClassChangeRecord removeSelector: #revertPhase2!Project removeSelector: #assertAll:from:orWriteOn:!Project removeSelector: #assertClass:from:warn:!Project removeSelector: #classArray!Project removeSelector: #deltaMD!Project removeSelector: #inForce!Project removeSelector: #informOfConflictsIn:!Project removeSelector: #isolateClass:!Project removeSelector: #methodDictArray!Project removeSelector: #orgArray!Project removeSelector: #renew!Project removeSelector: #topIsolated!Project removeSelector: #writeMethods:from:on:first:!"Postscript:Various inits."Project allInstancesDo: [:p | p instVarNamed: 'isolatedHead' put: false].!