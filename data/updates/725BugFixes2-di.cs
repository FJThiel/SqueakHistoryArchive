'From Squeak 2.3 of January 14, 1999 on 15 March 1999 at 1:55:21 am'!"Change Set:		BugFixes2Date:			15 March 1999Author:			Dan IngallsMore subtle repairs to event recording...Made ScriptEditors properly track tile insertions.Made SimpleButtons and TileMorphs record multiple mouseDown events.Did my best to deal with synthetic mouseMove inserted after mouseDown.Improved the simplicity and accuracy of repetition timing in PhraseTileMorph>>try and TileMorph>>mouseMove:.Fixed a missing implementation of #scale in CompositeTransform.Fixed PopUpMenu>>startUpWithCaption: to use activeHand's location in morphic."!AlignmentMorph subclass: #ScriptEditorMorph	instanceVariableNames: 'scriptName firstTileRow timeStamp playerScripted handWithTile '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!CompositeTransform methodsFor: 'transformations' stamp: 'di 3/14/1999 22:09'!scale	^ localTransform scale * globalTransform scale! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'di 3/14/1999 23:22'!handleEvent: newEvent	"Ignores repeated events such as unmoving mouse"	newEvent = lastEvent ifTrue: [^ self].	self handleSignificantEvent: newEvent! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'di 3/14/1999 23:19'!handleSignificantEvent: newEvent 	| now |	state == #record ifFalse: [^ self].	newEvent hand == recHand ifFalse: [^ self].	newEvent keyCharacter = (Character value: 27 "esc")		ifTrue: [^ self stop].	now _ Time millisecondClockValue.	now < time ifTrue:		["If the ms clock wraps, output a small delta"		time _ now-10].	tapeStream nextPut: (now - time) -> newEvent.	journalFile ifNotNil:		[journalFile store: (now - time); space; store: newEvent; cr; flush]."Transcript cr; print: ((now - time) -> newEvent); endEntry."	lastEvent _ newEvent.	time _ now.! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'di 3/14/1999 23:24'!noteSignificantEvent: newEvent	"Force a repeated event to be handled with significance, assuming it got	dropped by the repetition filter in normal handleEvent:.	Useful for, eg, repeat-button held down"	newEvent = lastEvent ifTrue: [self handleSignificantEvent: newEvent]! !!HandMorph methodsFor: 'event handling' stamp: 'di 3/14/1999 23:27'!noteSignificantEvent: evt		eventSubscribers do: [:m | m noteSignificantEvent: evt].! !!HandMorphForReplay methodsFor: 'event dispatching' stamp: 'di 3/15/1999 00:54'!processEvents	"Play back the next event"	| evt |	(evt _ recorder nextEventToPlay) ifNil: [^ self].	evt type = #EOF ifTrue: [recorder pauseIn: self world.  ^ self].	(evt type = #mouseMove and: [lastEvent type = #mouseDown])		ifTrue: ["Since I will have inserted an extra mouseMove after the				mouseDown, skip the first one on the tape."				lastEvent _ evt]		ifFalse: [self handleEvent: (evt setHand: self)].! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 3/15/1999 01:52'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ selectedItem! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 3/14/1999 23:06'!stopPlay	playDirection _ 0.	scorePlayer _ nil! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 3/15/1999 00:02'!try	| aPlayer now dt |	now _ Time millisecondClockValue.	userScriptSelector == nil		ifFalse:			[aPlayer _ self objectViewed player.			aPlayer perform: userScriptSelector]		ifTrue:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false].	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 3/15/1999 01:50'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor, so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil		at: (World ifNil: [Sensor cursorPoint]				ifNotNil: [World primaryHand lastEvent cursorPoint])! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 3/14/1999 22:36'!mouseEnter: evt	| hand tile |	hand _ evt hand.	(hand submorphs size = 1 and: [hand lastEvent redButtonPressed]) ifTrue:		[tile _ hand firstSubmorph.		(self wantsDroppedMorph: tile) ifTrue:			[(tile isKindOf: PhraseTileMorph) ifTrue: [tile brightenTiles].			handWithTile _ hand.			self startStepping]].! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 3/14/1999 22:36'!mouseLeave: evt	| hand tile |	owner ifNil: [^ self].	"left by being removed, not by mouse movement"	self stopStepping.	handWithTile _ nil.	self removeSpaces.	hand _ evt hand.	(hand submorphs size = 1) & (hand lastEvent redButtonPressed) ifTrue:		[tile _ hand firstSubmorph.		(tile isKindOf: PhraseTileMorph) ifTrue: [tile unbrightenTiles]].! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 3/14/1999 22:40'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii |	hand _ handWithTile ifNil: [self primaryHand].	(hand lastEvent redButtonPressed)		ifTrue:		[hand submorphCount > 0 ifTrue:			[insertion _ hand firstSubmorph.			insHt _ insertion height.			self removeSpaces.			i _ (ii _ self indexOfMorphAbove: insertion fullBounds topLeft)					min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty					ifTrue: [insertion]					ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (insertion top - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))					color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]]		ifFalse:		[self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (ScriptingSystem unbrightColorFor: m color)]]]! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'di 3/15/1999 01:55'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.scriptName _ scriptName veryDeepCopyWith: deepCopier.firstTileRow _ firstTileRow veryDeepCopyWith: deepCopier.timeStamp _ timeStamp veryDeepCopyWith: deepCopier.playerScripted _ playerScripted.		"Weakly copied"handWithTile _ handWithTile.  "Just a cache"! !!SimpleButtonMorph methodsFor: 'events' stamp: 'di 3/14/1999 23:27'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [oldColor ifNotNil: [self color: (oldColor mixed: 1/2 with: Color white)].				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction.							evt hand noteSignificantEvent: evt]]		ifFalse: [oldColor ifNotNil: [self color: oldColor]].! !!TileMorph methodsFor: 'mouse handling' stamp: 'di 3/15/1999 01:01'!mouseMove: evt	"See if arrows are being pressed and call arrowAction:..."	upArrow ifNotNil:		[(upArrow containsPoint: evt cursorPoint) ifTrue:			[self variableDelay: [self arrowAction: 1].			^ evt hand noteSignificantEvent: evt].		(downArrow containsPoint: evt cursorPoint) ifTrue:			[self variableDelay: [self arrowAction: -1].			^ evt hand noteSignificantEvent: evt]].	super mouseMove: evt.! !!TileMorph methodsFor: 'arrows' stamp: 'di 3/15/1999 00:22'!variableDelay: aBlock	| now delay dt |	nArrowTicks ifNil: [nArrowTicks _ 1].	now _ Time millisecondClockValue.	aBlock value.	delay _ nArrowTicks > 5 ifTrue: [100] ifFalse: [300].	nArrowTicks _ nArrowTicks + 1.	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do."	dt < delay ifTrue: [(Delay forMilliseconds: delay - dt) wait].! !!NumericReadoutTile methodsFor: 'all' stamp: 'di 3/15/1999 01:01'!mouseMove: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	| p label |	upArrow ifNotNil:		[p _ evt cursorPoint.		label _ self findA: UpdatingStringMorph.		label ifNotNil: [literal _ label valueFromContents].		(upArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue + 1) width: label width].					^ evt hand noteSignificantEvent: evt].		(downArrow containsPoint: p)			ifTrue: [self variableDelay:						[self literal: (self numericValue - 1) width: label width].					^ evt hand noteSignificantEvent: evt]].	super mouseMove: evt.! !TileMorph removeSelector: #readyForAnotherTick!