'From Squeak2.9alpha of 16 June 2000 [latest update: #3012] on 15 November 2000 at 4:32:36 pm'!"Change Set:		ParseScript5-tkDate:			15 November 2000Author:			Ted Kaehler (with Dan Ingalls)Installs SyntaxMorph tiles in the EToy viewer and into EToy scripts.  Choose 'use new universal tiles' from the script menu to irreversibly use new tiles in this world.Removes several classes not really needed.[ ] 	Opens up the parse of BraceNodes (Had been just a single tile with text).[ ] 	Takes another tack on the default display as colored tiles.[ ] 	Verified that most allowable pastes are reasonable, and that most reasonable pastes are allowable."!AlignmentMorph subclass: #ScriptEditorMorph	instanceVariableNames: 'scriptName firstTileRow timeStamp playerScripted handWithTile showingMethodPane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!SyntaxMorph commentStamp: 'tk 11/2/2000 10:43' prior: 0!A single class of morph that holds any piece of Smalltalk, and allows it to be a tile.  Tiles can be dragged in or out of a method. In the message list pane of a Browser, choose 'tile scriptor'.  Bring up a second one to steal parts from.Dragging a statement removes it from a block.  Dragging anything else drags off a copy.  (Can't drag out the original -- it leaves an illegal hole.)Each SyntaxMorph points at a ParseNode.  After editing, the parseNode is only good as a part-of-speech indicator.  Only the classes of the parseNodes are important.  It's state is not kept up to date with the tile edits (but maybe it should be).The correspondence with parseNodes in not one-to-one.  Several extra levels of SyntaxMorph were added as aligners to make the horizontal and vertical layout right.  These have nil for the parseNode.To accept, pass over the tree of SyntaxMorphs, gathering their printStrings and inserting punctuation.  See (SyntaxMorph>>printOn:indent:).  Accept that.  Pretty print to make it look better.Biggies...[ ]	Integrate with EToy scriptors[ ]	Introduce notion of an UnparsedNode -- maybe a flag in ParseNode	Text -> Unparsed -> Parsed -> CodeGen	    (where currently we combine first two steps), or...	Direct manip -> Unparsed -> Parsed -> CodeGen[ ]	Show/hide syntax markers (like [], (), ., :, ;, etc)	driver's ed for Squeak syntax[ ]	ParsedTextMorph -- looks like text but has all same substructure	The idea is it's a theory for DnD code in text[ ]	Need DnD evaluator, or some sort of '!!' button on any entity (halo?)	Also inspector / browser[ ]	All the type help we can getDetails...[ ] Green spacer have dark green border. [ ] Click any text name to edit.[ ] arrows and popups for sounds, numbers[ ]	Brown highlight is not consistently visible[ ]	Green highlight stays on sometimes[ ]	Both highlights won't show on multi-keyword expr[ ]	Need a special highlight for selector parts -- if they are useful at all[ ]	Green stmt insertion space should be yellow;	show green border when mouse in[ ]	Return box border interferes with green, brown highlight[ ]	Layout needs work -- centering of block keyword NG on big blocks	Reason is can't see expr in which block exists.	How about PP guidelines for all on one line vs		rcvr, kwds on separate lines.[ ]	Stmt nodes should duplicate on drag like everything else[ ]	Use, eg, shift-drag to move, del to delete[ ]	Click out of parse tree should bring window to front if not[ ]	ReturnNodes doesn't seem to get enter/leave	Same with AssignmentNodesThings to do:[ ] Up/down arrows and extend arrow in tiles.  [ ] Some literals, braceNodes, etc must have (Character cr) in them.  Use something better than a StringMorph?.  It can only show one line.[ ] In order to do layout, there are extra morph layers with no corresponding node in the parseTree.  individual keywords are one example, as are a keyword-arg pair.  I have created new parseNode classes whose sole purpose is to mark those morphs.  (done)[ ] MessageNode is used in two different ways.  One is with a receiver, and one is without.  They have different colors to distinguish them.  CascadeNodes are the same.  Test the color, if necessary. (done) [ ] In large statements, make tile be narrow on left, expanding out to tall on the right.[ ] Keep the parseNodes legal and up to date as editing occurs.  Go from parse tree directly to byteCodes.[ ] When user retypes a selector with more colons, split it and put in arg2.  Allow dropping in extra keywords and extra args.[ ] Dan's pretty green slider code when dropping in new line.  Also indicate places in existing tiles where the new tile could drop.[ ] if drop in an illegal place, keep tile in the hand[ ] spacers need attention in temp var list, statements in blocks.[ ] click on window needs to bring it to front.[ ] Change title of window when edit selector name.[ ] remember category and put new message there.[ ] Undo!!Based on Bob Arning's SyntaxMorph exploration in early 2000.!!MessageSend methodsFor: 'tiles' stamp: 'tk 11/15/2000 10:51'!asTiles	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me."	"This is really cheating!!  Make a true parse tree later. -tk"	code _ String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: (self stringFor: receiver).		keywords _ selector keywords.		strm space; nextPutAll: keywords first.		(num _ selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree _ Compiler new 		parse: code 		in: Player		notifying: nil.	(syn _ tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: Player.	block _ syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase _ block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!MessageSend methodsFor: 'tiles' stamp: 'tk 11/15/2000 15:19'!asTilesIn: playerClass	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me."	"This is really cheating!!  Make a true parse tree later. -tk"	code _ String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: (self stringFor: receiver).		keywords _ selector keywords.		strm space; nextPutAll: keywords first.		(num _ selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree _ Compiler new 		parse: code 		in: playerClass		notifying: nil.	syn _ tree asMorphicSyntaxUsing: SyntaxMorph.	block _ syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase _ block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!MessageSend methodsFor: 'tiles' stamp: 'tk 11/15/2000 10:48'!stringFor: anObject	"Return a string suitable for compiling.  Literal or reference from global ref dictionary.  self is always named via the ref dictionary."	anObject isLiteral ifTrue: [^ anObject printString].	^ anObject uniqueNameForReference! !!Morph methodsFor: 'structure' stamp: 'tk 11/13/2000 23:27'!ownerThat: aBlock	"Return the first enclosing morph for whom the block is true, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[(aBlock value: current) ifTrue: [^ current].			current _ current owner].	^ current! !!CategoryViewer methodsFor: 'entries' stamp: 'tk 11/15/2000 12:39'!phraseForSlot: slotSpec	"Return a PhraseTileMorph representing a variable belonging to the player"	"The slot spec if a tuple with the following structure:		1	#slot		2	slot name		3	balloon help		4	slot type		5	#readOnly,# readWrite, or #writeOnly		6	getter receiver indicator		7	getter selector		8	setter receiver indicator		9	setter selector	NB:	all are symbols except #3, which is a string"	| r anArrow slotName getterButton ut inner cover |	r _ ViewerRow newRow		color: self color;		beSticky;		elementSymbol: (slotName _ slotSpec second);		wrapCentering: #center;		cellPositioning: #leftCenter.	r addMorphBack: (self slotHeaderFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self infoButtonFor: slotName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	ut _ scriptedPlayer costume world valueOfProperty: #universalTiles ifAbsent: [false].	ut ifTrue: [inner _ self newTilesFor: scriptedPlayer getter: slotSpec.			cover _ (Morph new) color: Color transparent.			cover extent: inner extent.			(getterButton _ cover copy) addMorph: cover; addMorphBack: inner.			cover on: #mouseDown send: #newMakeGetter:from:forPart:					to: self withValue: slotSpec]		ifFalse: [r addMorphBack: self tileForSelf bePossessive.			r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"			getterButton _ self getterButtonFor: slotName type: slotSpec fourth].	r addMorphBack: getterButton.	getterButton setBalloonText: slotSpec third.	(slotName == #isOverColor)		ifTrue:			[self addIsOverColorDetailTo: r]		ifFalse:			[(slotSpec fifth == #readOnly) ifFalse:				[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"				anArrow _ ut 					ifTrue: [self arrowSetterButton: #newMakeSetter:from:forPart:								args: slotSpec]					ifFalse: [self arrowSetterButton: #makeSetter:from:forPart:								args: (Array with: slotName with: slotSpec fourth)].				r addMorphBack: anArrow.				].			r addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"			(#(colorSees playerSeeingColor copy) includes: slotName) ifFalse:		 		[r addMorphBack: (self readoutFor: slotName type: slotSpec fourth readOnly: slotSpec fifth getSelector: slotSpec seventh putSelector: slotSpec ninth)]].	anArrow ifNotNil: [anArrow step].	^ r! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/8/2000 21:59'!arrowSetterButton: sel args: argArray	| m |	m _ RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 0.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m setBalloonText: 'drag from here to obtain an assignment phrase.'.	m on: #mouseDown send: sel		to: self		withValue: argArray.	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/9/2000 13:48'!newMakeGetter: evt from: aMorph forPart: aSpec	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m _ self newTilesFor: scriptedPlayer getter: aSpec.	owner ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m].! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/9/2000 13:48'!newMakeSetter: evt from: aMorph forPart: aSpec	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m _ self newTilesFor: scriptedPlayer setter: aSpec.	owner ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m].! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/15/2000 15:19'!newTilesFor: aPlayer command: aSpec	| ms messageNodeMorph argTile argArray |	"Return universal tiles for a command.  Record who self is."	aSpec size > 3 		ifTrue: [aSpec fourth == #player 			ifTrue: [argArray _ Array with: aPlayer]			ifFalse: [argTile _ aPlayer tileForArgType: aSpec fourth inViewer: nil.					argArray _ Array with: argTile literal]]	"default value for each type"		ifFalse: [argArray _ #()].	ms _ MessageSend receiver: aPlayer selector: aSpec second arguments: argArray.	messageNodeMorph _ ms asTilesIn: aPlayer class.	^ messageNodeMorph setProperty: #whoIsSelf toValue: aPlayer. ! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/15/2000 15:19'!newTilesFor: aPlayer getter: aSpec	| ms messageNodeMorph |	"Return universal tiles for a getter on this property.  Record who self is."	ms _ MessageSend receiver: aPlayer selector: aSpec seventh arguments: #().	messageNodeMorph _ ms asTilesIn: aPlayer class.	^ messageNodeMorph setProperty: #whoIsSelf toValue: aPlayer. ! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 11/15/2000 15:19'!newTilesFor: aPlayer setter: aSpec	| ms messageNodeMorph argValue |	"Return universal tiles for a getter on this property.  Record who self is."	argValue _ aPlayer perform: (ScriptingSystem getterSelectorFor: aSpec second asSymbol).	ms _ MessageSend receiver: aPlayer selector: aSpec ninth arguments: (Array with: argValue).	messageNodeMorph _ ms asTilesIn: aPlayer class.	^ messageNodeMorph setProperty: #whoIsSelf toValue: aPlayer. ! !!ParseNode methodsFor: 'tiles' stamp: 'di 11/14/2000 16:52'!addCommentToMorph: aMorph	| row |	(comment isNil or: [comment isEmpty]) ifTrue: [^ self].	row _ aMorph addTextRow:		(String streamContents: [:strm | self printCommentOn: strm indent: 1]).	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/10/2000 21:03'!morphToDropFrom: aMorph	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| aNail representee handy posBlock tempPos |	handy _ self primaryHand.	posBlock _ [:z | 			tempPos _ handy position - (handy targetOffset - aMorph formerPosition * (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail		ifTrue: [aNail _ aMorph						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph				ifFalse: [aNail						position: (posBlock value: aNail)].			^ aNail].	((aMorph isKindOf: MorphThumbnail)			and: [(representee _ aMorph morphRepresented) owner == nil])		ifTrue: [representee				position: (posBlock value: representee).			^ representee].	self showingListView ifTrue:		[^ aMorph listViewLineForFieldList: (self valueOfProperty: #fieldListSelectors)].	self automaticPhraseExpansion		ifFalse: [^ aMorph].	(aMorph hasProperty: #newPermanentScript)		ifTrue: [^ aMorph asEmptyPermanentScriptor].	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isKindOf: SyntaxMorph])		ifFalse: [^ aMorph].	^ aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'misc' stamp: 'tk 11/2/2000 12:00'!viewerFlapTabFor: anObject	"Open up a Viewer on aMorph in its own flap, creating it if necessary"	| bottomMost aPlayer aFlapTab |	bottomMost _ self top.	aPlayer _ anObject isMorph ifTrue: [anObject assuredPlayer] ifFalse: [anObject objectRepresented].	self flapTabs do:		[:aTab | (aTab isKindOf: ViewerFlapTab)			ifTrue:				[bottomMost _ aTab bottom max: bottomMost.				aTab scriptedPlayer == aPlayer					ifTrue:						[^ aTab]]].	"Not found; make a new one"	aFlapTab _ (Utilities newFlapTitled: anObject nameForViewer onEdge: #right inPasteUp: self)		as: ViewerFlapTab.	aFlapTab initializeFor: aPlayer topAt: bottomMost + 2.	aFlapTab referent color: (Color green muchLighter alpha: 0.5).	aFlapTab referent borderWidth: 0.	aFlapTab referent setProperty: #automaticPhraseExpansion toValue: true.	self addMorphFront: aFlapTab.	aFlapTab adaptToWorld: self.	^ aFlapTab! !!Player methodsFor: 'slots-kernel' stamp: 'tk 11/14/2000 15:24'!tileForArgType: typeSymbol inViewer: aViewer	"Answer a tile to represent a value of the given type in the given viewer"	| aColor aPlayer |	typeSymbol == #player ifTrue:		[aPlayer _ self presenter			ifNotNil:				[self presenter standardPlayer]			ifNil:  "It happens, if costume is not currently in a world"				[self].		^ (CategoryViewer new) tileForPlayer:  aPlayer].	aColor _ ScriptingSystem colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #menu ifTrue: [^ MenuTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	typeSymbol == #buttonPhase ifTrue: [^ SymbolListTile new choices: #(buttonDown whilePressed buttonUp) dataType:  typeSymbol].	typeSymbol == #text ifTrue: [^ ("(TextMorph new contents: 'setup')" 'aborning' newTileMorphRepresentative) typeColor:  aColor].	self error: 'Unrecognized type'! !!Player methodsFor: 'scripts-kernel' stamp: 'tk 11/13/2000 22:05'!commandPhraseFor: commandSpec inViewer: aViewer	"Translate commandSpec into a PhraseTileMorph.  Put appropriate balloon help into the phrase"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst ut |	names _ self class namedTileScriptSelectors.	resultType _ (commandSpec at: 1).	cmd _ (commandSpec at: 2).	ut _ costume world valueOfProperty: #universalTiles ifAbsent: [false].	ut ifTrue: [aPhrase _ (CategoryViewer new) newTilesFor: self command: commandSpec]		ifFalse: [commandSpec size = 3			ifTrue:				[aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player]			ifFalse: "commandSpec size is four"				[argType _ commandSpec at: 4.				aPhrase _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ self tileForArgType: argType inViewer: aViewer.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(self slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector _ #userSlot].	(self belongsToUniClass and:			[self class includesSelector: cmd])		ifTrue: [balloonTextSelector _ #userScript].	(ut ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	aPhrase markAsPartsDonor.	ut ifFalse: [		selfTile _ aViewer tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow _ ViewerRow newRow borderWidth: 0; color: aViewer color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 4@2; beTransparent).	aRow addMorphBack: (aViewer infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		aPhrase beTransparent.		aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.		aRow addMorphBack: (stat _ (inst _ self scriptInstantiationForSelector: cmd) statusControlMorph).		inst updateStatusMorph: stat.].	aRow beSticky; disableDragNDrop.	^ aRow! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/8/2000 17:27'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |	self prepareToUndoDropOf: aMorph.	"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/8/2000 17:25'!repelsMorph: aMorph event: ev	(showingMethodPane and: 		[self world valueOfProperty: #universalTiles ifAbsent: [false]]) ifTrue: [			^ (aMorph respondsTo: #parseNode) not].	^ aMorph isTileLike not! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/8/2000 17:28'!wantsDroppedMorph: aMorph event: evt	aMorph isTileLike ifFalse: [^false].	aMorph resultType == #command ifFalse: [^false].	self isTextuallyCoded ifTrue: [^false].	^true! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 11/8/2000 16:05'!showSourceInScriptor	"Remove tile panes, if any, and show textual source instead"	| aCodePane |	self isTextuallyCoded ifFalse: [self becomeTextuallyCoded].		"Mostly to fix up grandfathered ScriptEditors"	self submorphs allButFirst do: [:m | m delete].	aCodePane _ MethodHolder isolatedCodePaneForClass: playerScripted class selector: scriptName.	showingMethodPane _ true.	self addMorphBack: aCodePane.	(self world valueOfProperty: #universalTiles ifAbsent: [false]) 		ifTrue: [self useNewTilesNow].	"grab aCodePane, get model, and remove it" 	self currentWorld startSteppingSubmorphsOf: self! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 11/2/2000 10:57'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	count _ self savedTileVersionsCount.		(self isTextuallyCoded and: [self showingMethodPane not]) ifTrue:		["Fix up old guys that  are not showing the code in place"		self showSourceInScriptor].	self showingMethodPane		ifFalse:				"currently showing tiles"			[aMenu add: 'show code textually' action: #showSourceInScriptor.			count > 1 ifTrue: 				[aMenu add: 'revert to tile version...' action:	#revertScriptVersion].			aMenu add: 'save this version'	action: #saveScriptVersion]		ifTrue:				"current showing textual source"			[count >= 1 ifTrue:				[aMenu add: 'revert to tile version' action: #revertToTileVersion].			aMenu add: 'make tiles from this code' action: #recreateTileVersion].	Preferences noviceMode ifFalse: ["just for now, not for kids"		aMenu add: 'use new universal tiles' action: #useNewTiles].				aMenu addList: #(		-		('fires per tick...'				chooseFrequency)		('destroy this script'				destroyScript)		('rename this script'				renameScript)		('explain status alternatives' 	explainStatusAlternatives)		('button to fire this script'		tearOfButtonToFireScript)).	aMenu popUpInWorld: self currentWorld.	"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 11/15/2000 10:59'!useNewTiles	"At the next request for textual script, use new tiles instead.  Make that request."	self world setProperty: #universalTiles toValue: true. 	"for all scriptors and viewers"	Preferences enable: #capitalizedReferences.	self showSourceInScriptor. ! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 11/15/2000 14:41'!useNewTilesNow	| mp source aSelector aClass tree syn widget |	"First make it show source with a method pane, then substitute tiles!!"	(mp _ self findA: MethodMorph) ifNil: [^ self].	"code pane must be present"	aSelector _ mp model selectedMessageName.	aClass _ mp model selectedClassOrMetaClass.	source _ aClass sourceCodeAt: aSelector.    	tree _ Compiler new 		parse: source 		in: aClass 		notifying: nil.	(syn _ tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass.	widget _ syn inAScrollPane.	mp delete.	self addMorphBack: widget.	widget extent: (self width - 10 @ 150).! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 11/2/2000 11:50'!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color colorFrom: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: aBrowser defaultBackgroundColor."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 11/14/2000 13:54'!showingMethodPane: val	"Whether the receiver will show the textual method pane"	showingMethodPane _ val! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'tk 11/2/2000 11:42'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	scriptName _ scriptName veryDeepCopyWith: deepCopier.	firstTileRow _ firstTileRow veryDeepCopyWith: deepCopier.	timeStamp _ timeStamp veryDeepCopyWith: deepCopier.	playerScripted _ playerScripted.		"Weakly copied"	handWithTile _ handWithTile.  "Just a cache"	showingMethodPane _ showingMethodPane.	"boolean"! !!ScriptEditorMorph methodsFor: 'object fileIn' stamp: 'tk 11/15/2000 14:19'!convertbosfcebbochvimlpsftphs0: varDict bosfcebbsftphs0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'borderWidth' 'borderColor' 'scriptName' 'firstTileRow' 'timeStamp' 'playerScripted' 'handWithTile' 'showingMethodPane').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('orientation' 'centering' 'hResizing' 'vResizing' 'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds').  Possibly store their info in another variable?"! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 11/12/2000 14:27'!actualObject	"Who is self in these tiles?  A Player"	^ self valueOfProperty: #whoIsSelf! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 11/15/2000 14:39'!parsedInClass: x	self parsedInClass == x ifFalse: [self error: 'inconsistent value']! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 11/12/2000 14:42'!userScriptSelector	"user wrote this script"	^ self valueOfProperty: #userScriptSelector! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 11/12/2000 14:41'!userScriptSelector: sel	"user wrote this script"	self setProperty: #userScriptSelector toValue: sel.! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 11/15/2000 16:27'!mouseDown: evt 	| dup |	evt yellowButtonPressed ifTrue: [^ self showMenu: evt].	owner isSyntaxMorph ifTrue:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == outerMorph or: [self hasOwner: outerMorph]])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"bare, out in the world"	(self nodeClassIs: MethodNode) ifTrue:		[^ self]. "whole method not draggable"	self isPartsDonor 		ifTrue: [dup _ self duplicate.				"dup isPartsDonor: false.  done in duplicate"				dup setProperty: #beScript toValue: true]		ifFalse: [dup _ self].	evt hand attachMorph: dup.	^ dup align: dup topLeft with: evt hand position + self cursorBaseOffset.! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/15/2000 14:12'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks.  see wantsDroppedMorph:event:"	"We know it is acceptable.  Just a matter of which case"	itNoun _ aMorph isNoun.	self allOwnersDo:		[:m | (m isSyntaxMorph and: [m nodeClassIs: BlockNode])			ifTrue: [m stopStepping; hideCaret]].	(self nodeClassIs: BlockNode) & itNoun		ifTrue:			[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				^ (self addBlockArg: aMorph) ifFalse:					["if already declared, start new line of code with it"					self addToBlock: aMorph event: evt]]			ifFalse:			[^ self addToBlock: aMorph event: evt]].	"If I am a BlockNode and it is a noun add it as a new line"	(self nodeClassIs: BlockNode) ifTrue: [		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[((aMorph nodeClassIs: TempVariableNode)				or: [aMorph nodeClassIs: VariableNode])  ifFalse: [ ^ self]]]].	(old _ owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	old cleanupAfterItDroppedOnMe.	"now owned by no one"! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/13/2000 23:28'!cleanupAfterItDroppedOnMe	| mm |	"A tile just dropped into me.  Clean up"	self layoutChanged.	("scriptor _" self ownerThatIsA: ScriptEditorMorph) ifNotNil: [		(mm _ self ownerThat: [:ow | 			(ow respondsTo: #parseNode) and: [ow parseNode class == MethodNode]]) 				ifNotNil: [mm accept]].! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/12/2000 16:32'!justDroppedInto: aMorph event: evt	aMorph isSyntaxMorph ifFalse:		["Drop my topLeft at the tip of the cursor if not in a scriptor."		self align: self topLeft with: self topLeft - self cursorBaseOffset].	self removeProperty: #beScript.	^ super justDroppedInto: aMorph event: evt! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 11/14/2000 15:08'!morphToDropInPasteUp: aPasteUp	| actualObject itsSelector aScriptor anEditor adjustment handy tw blk |	"If property #beScript is true, create a scriptor around me."	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	(actualObject _ self actualObject) ifNil: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	aScriptor _ (itsSelector ~~ nil and: [itsSelector size > 0])		ifTrue:	"user script"			[actualObject isFlagshipForClass				ifFalse: 					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: self.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					[(aPasteUp world valueOfProperty: #universalTiles ifAbsent: [false]) not &					(actualObject class userScriptForPlayer: actualObject selector: itsSelector) 						isTextuallyCoded ifTrue:							[^ aPasteUp scriptorForTextualScript: itsSelector ofPlayer: actualObject].					adjustment _ 0@0.					aScriptor _ actualObject scriptEditorFor: itsSelector]]		ifFalse:			["It's a system-defined selector; construct an anonymous scriptor around it"			itsSelector _ nil.			adjustment _ 60 @ 20.			actualObject newScriptorAround: self].	handy _ aPasteUp primaryHand.	aScriptor ifNotNil: [		aScriptor position: handy position - adjustment.		aPasteUp addMorphFront: aScriptor.	"do this early so can find World"		aScriptor useNewTiles.		itsSelector ifNil: ["blank script"			tw _ aScriptor findA: TwoWayScrollPane.			blk _ tw scroller firstSubmorph "MethodNode" lastSubmorph "BlockNode".			blk addMorphFront: self.			self position: self topLeft + (7@14)]].	(aScriptor isMemberOf: ScriptEditorMorph) ifTrue:		[aScriptor playerScripted expungeEmptyUnRenamedScripts].	^ aScriptor ifNil: [self]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/14/2000 17:13'!select	self deselect.	self color: Color lightBrown.	self borderColor: #raised! !!SyntaxMorph methodsFor: 'insertion caret' stamp: 'tk 11/14/2000 15:36'!trackCaret	| hand i pt localPt sub |	hand _ self primaryHand.	(hand lastEvent redButtonPressed and: [(self hasOwner: hand) not]) ifTrue:		[localPt _ self globalPointToLocal: hand position.		(i _ self insertionIndexForCaret: localPt) = 0 ifFalse: [			sub _ submorphs at: i.			pt _ localPt y < sub center y				ifTrue: [sub topLeft + (-4@-2)]				ifFalse: [sub bottomLeft + (-4@2)].			^ self showCaretAt: pt]].	self stopStepping.	self hideCaret.! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/15/2000 14:14'!addBlockArg: aMorph	| tempHolder tt var nn row |	"Add a temporary to a block or the method.  Return true if succeed"	owner parseNode class == MethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not insided the block"		"If exists, drop the temp in this block and let use extend it."	tt _ self firstSubmorph.	tempHolder _ tt firstSubmorph class == SyntaxMorph 				ifTrue: [tt parseNode class == BlockArgsNode 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	nn _ (aMorph allMorphs detect: [:rr | rr class == StringMorph]) contents.	"name"	tempHolder ifNil: ["make whole row"		row _ self addRow: #blockarg1 on: (BlockArgsNode new).		self addMorphFront: row.		aMorph parseNode name: nn key: nn code: nil.		var _ row addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		self cleanupAfterItDroppedOnMe.		^ true].	tempHolder ifNotNil: [		"If this variable is not present, add it"		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].				"is present. caller adds the temp as a new line of code to be extended"		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		var cleanupAfterItDroppedOnMe.		^ true].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/15/2000 14:18'!addTempVar: aMorph 	| tempHolder ii tt var nn tempMorph |	"know we are a block inside a MethodNode" 	tempHolder _ (ii _ owner submorphIndexOf: self) = 1				ifFalse: [tt _ owner submorphs at: ii - 1.						(tt isSyntaxMorph and: [tt parseNode class == MethodTempsNode])					 		ifTrue: [tt] ifFalse: [nil]]				ifTrue: [nil].	nn _ (aMorph allMorphs detect: [:rr | rr class == StringMorph]) contents.	"name"	tempHolder ifNil: [		tempMorph _ owner addRow: #tempVariable on: MethodTempsNode new.		owner addMorph: tempMorph inFrontOf: self.		tempMorph color: tempMorph color darker.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempMorph.		tempMorph cleanupAfterItDroppedOnMe.		^ true].	tempHolder ifNotNil: [		tempHolder allMorphs do: [:rr | 					rr class == StringMorph ifTrue: [rr contents = nn ifTrue: [^ false]]].		aMorph parseNode name: nn key: nn code: nil.		var _ tempHolder addColumn: #tempVariable on: aMorph parseNode.		var layoutInset: 1.		var addMorphBack: (StringMorph contents: nn).		var cleanupAfterItDroppedOnMe.		^ true]! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 11/13/2000 23:43'!addToBlock: aMorph event: evt	"Insert a new line of code"	| whereDropped dropBefore |	whereDropped _ "self pointFromWorld:" evt cursorPoint.	dropBefore _ self submorphs 		detect: [:each | each isSyntaxMorph and: [whereDropped y < each center y]] 		ifNone: [nil].	(aMorph nodeClassIs: ReturnNode) ifTrue: [dropBefore _ nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [self addMorph: aMorph inFrontOf: dropBefore].	self addMorph: (			AlignmentMorph newRow 				vResizing: #rigid; 				color: Color transparent;				extent: 2@2)		behind: aMorph.	self cleanupAfterItDroppedOnMe.! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 11/15/2000 15:35'!printOn: strm indent: level 	| lev nodeClass first |	"Tree walk and produce text of the code.  #ST80.  Just do it in one big ugly method."	lev _ level.	(nodeClass _ parseNode class) == BlockNode ifTrue: [		(owner respondsTo: #parseNode) ifTrue: [			owner parseNode class == MethodNode ifFalse: [strm nextPut: $[.  lev _ lev+1]]].				"normal block has []"	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $( ]].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; space].	first _ true.	submorphs do: [:sub |		(sub respondsTo: #printOn:indent:) ifTrue: [			nodeClass == CascadeNode & first not ifTrue: [				color = (SyntaxMorph translateColor: #cascade2) ifTrue: [strm nextPut: $;; space ]].			nodeClass == BlockArgsNode ifTrue: [strm nextPut: $:].			sub printOn: strm indent: lev.			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not	& 				(sub parseNode class == ReturnNode) not					ifTrue: [strm nextPut: $.].			(nodeClass == BlockNode) & (sub parseNode class == BlockArgsNode) not					ifTrue: [strm crtab: lev]				ifFalse: [nodeClass == MethodNode ifTrue: [strm crtab: lev] ifFalse: [strm space]].			first _ false].		sub class == StringMorph ifTrue: [strm nextPutAll: sub contents].		"return indent for ifTrue: ifFalse:"].	nodeClass == MessageNode ifTrue: [		color = (SyntaxMorph translateColor: #message) ifTrue: [strm nextPut: $) ]].	nodeClass  == BlockNode ifTrue: [		(owner respondsTo: #parseNode) ifTrue: [			owner parseNode class == MethodNode ifFalse: [strm nextPut: $] ]]].				"normal block has []"	nodeClass == BlockArgsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodTempsNode ifTrue: [strm nextPut: $|; crtab: lev].	nodeClass == MethodNode ifTrue: [		strm contents last "ugh!!" == $. ifTrue: [strm skip: -1]].	"erase last period"! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/15/2000 15:17'!accept	"Turn my current state into the text of a method.  Compile it in my class."	| cls |	(self nodeClassIs: MethodNode) ifFalse: [^ self root accept  "always accept at the root"].	(cls _ self parsedInClass) ifNil: [^ self].	cls compile: self decompile notifying: nil.! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 11/15/2000 15:14'!showMenu: evt	| menu |	menu _ MenuMorph new.	menu add: 'accept method' target: self selector: #accept.	menu add: 'show code' target: self selector: #showCode.	menu popUpAt: evt hand position forHand: evt hand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 11/10/2000 21:20'!try	| rec |	"Evaluate me once"	parseNode class == MessageNode ifFalse: [^ self].	(self firstSubmorph) parseNode class == VariableNode ifFalse: [^ self].	rec _ self valueOfProperty: #whoIsSelf ifAbsent: [^ self]. 	"aPlayer"	Compiler evaluate: self decompile				for: rec				logged: false.	"should do something to the player"! !!SyntaxMorph methodsFor: 'test' stamp: 'di 11/14/2000 14:54'!toDo"Biggies...[ ]	Integrate with EToy scriptors	releaseCachedState can discard all morphic structure.[ ]	Options:	Show / hide syntax markers (like [], (), ., :, ;, etc)	No color / color-in-focus / full color	Tiles / textiles / text[ ]	ParsedTextMorph -- looks like text but has all same substructure[ ]	Introduce notion of an UnParsedNode -- maybe a flag in ParseNode	Text -> UnParsed -> Parsed -> CodeGen[ ]	Need DnD evaluator, or some sort of '!!' button on any entity (halo?)	Also inspector / browser[ ]	All the type help we can getDetails ...[ ]	Open up the parse of BraceNodes[ ]	Verify that all pastes are OK[ ]	Colors not yet right for colored version.[ ]	Start work on show / hide of syntax markers -- (), [], etc.[ ]	Start work on textiles (grabable entites in 'normal' text)[ ]	Need autoscroll during drag for drop[ ]	Use, eg, shift-drag to move, del to delete[ ]	What about invalid drops -- stick on cursor?System...[ ]	Only keep history 7 deep; option to clear on quit	clear command above spaceLeft[ ]	Compute each page of prefs viewer on demand instead of as now.[ ]	Offer a search command that will gather up all preferences that match a given string (name or help string)Preferences enable: #noTileColor.Preferences disable: #noTileColor.Smalltalk browseAllSelect: [:cm | cm size > 600]SyntaxMorph testAll"! !!SyntaxMorph methodsFor: 'copying' stamp: 'tk 11/13/2000 22:48'!veryDeepCopyWith: deepCopier	| player |	"I may point to the player whose script I am in.  If that player is not already being copied, don't make a new duplicate of him.  My copy should still be a tile for the same player!!	There may be references to players in other kinds of objects that have this same problem."	(player _ self valueOfProperty: #whoIsSelf) ifNotNil: [		(deepCopier references includesKey: player) ifFalse: [			"not recorded, outside our tree, use same player"			deepCopier references at: player put: player]].	^ super veryDeepCopyWith: deepCopier! !VariableNode removeSelector: #getMenuItemsIn:!SyntaxMorph removeSelector: #cleanup!SyntaxMorph removeSelector: #getMenuItemsIn:!SyntaxMorph removeSelector: #implant!SyntaxMorph removeSelector: #veryDeepFixupWith:!SyntaxMorph removeSelector: #veryDeepInner:!!SyntaxMorph reorganize!('initialization' inAScrollPane openInWindow)('accessing' actualObject color: externalName getCurrentValue isNoun isSyntaxMorph nodeClassIs: parseNode parseNode: parsedInClass parsedInClass: userScriptSelector userScriptSelector:)('event handling' cursorBaseOffset handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseEnterDragging:inCaret: mouseLeave: mouseLeaveDragging: mouseLeaveDragging:inCaret: mouseMove: mouseUp: step stepTime)('dropping/grabbing' acceptDroppingMorph:event: cleanupAfterItDroppedOnMe justDroppedInto:event: morphToDropInPasteUp: wantsDroppedMorph:event:)('drawing' drawOn:)('highlighting' borderColor: dropColor grabColor highlightForDrop: highlightForGrab: stdBorderColor unhighlight unhighlightOwner)('selection' currentSelectionDo: deselect isSelectable root select setSelection:)('insertion caret' addCaretFront: hideCaret insertionIndexForCaret: removeCaret: showCaretAt: trackCaret)('layout' addBlockArg: addColumn:on: addRow:on: addTempVar: addTextRow: addToBlock:event: addToken:type:on: foldMessage foldMessageOneArg unfoldMessage)('printing' printOn: printOn:indent: structure)('menus' accept decompile getMenuBlock showCode showMenu: try)('debugging' balloonText debugger debugger: hostContext update:)('test' test testForNode:andDo: toDo)('copying' veryDeepCopyWith:)!ParseNode removeSelector: #getMenuItemsIn:!Smalltalk removeClassNamed: #DebugSyntaxMorph!Smalltalk removeClassNamed: #NonEditableTextMorph!Smalltalk removeClassNamed: #SyntaxMenuMorph!Smalltalk removeClassNamed: #SyntaxMorphStream!