'From Squeak 2.1 of June 30, 1998 on 11 August 1998 at 5:22:16 pm'!"Change Set:		noCostumee-swDate:			11 August 1998Author:			Scott WallaceBring this in on top of Dan's morphRestruct; removes all mention of the term 'costumee', converting to 'player'.  Thus, for example,	costumee			-> 	player	costumee:			->	player:	assuredCostumee		->	assuredPlayeretc.Those few morphs that had defined #player as a selector to return something other than the costumee have had that protocol renamed to be #associatedPlayer."!!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:56'!veryDeepCopyWithoutPlayer	| hold copy holdState |	hold _ self player.	holdState _ self actorStateOrNil.	holdState ifNotNil: [self actorState: nil].	self player: nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy actorState: (holdState copyWithPlayerReferenceNilled)].	self player: hold.	holdState ifNotNil: [self actorState: holdState].	^ copy! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 8/11/1998 16:59'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	owner ifNotNil:		[self player ifNotNil: [aWorld _ self world].		owner privateRemoveMorph: self.		owner _ nil.		self player ifNotNil: [self player noteDeletionOf: self fromWorld: aWorld]].! !!Morph methodsFor: 'stepping' stamp: 'sw 8/11/1998 16:55'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message"	self player ifNotNil: [self player step]! !!Morph methodsFor: 'stepping' stamp: 'sw 8/11/1998 16:55'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ self player ifNotNil: [125] ifNil: [1000]! !!Morph methodsFor: 'stepping' stamp: 'sw 8/11/1998 16:56'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self player ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menu' stamp: 'sw 8/11/1998 16:53'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument].	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [GIFImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	(aHandMorph argument pasteUpMorph morphsAt: aHandMorph menuTargetOffset) size > 2 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menu' stamp: 'sw 8/11/1998 16:45'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ TransformationMorph new asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self player ifNotNil:		[flexMorph player: self player.		self player rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:46'!choosePartNameSilently	^ self world model namePartSilently: self assuredPlayer! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:59'!restoreTypeColor	self player ifNotNil: [self player allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:55'!useUniformTileColor	self player ifNotNil:		[self player allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!Morph methodsFor: 'naming' stamp: 'sw 8/11/1998 16:54'!renameTo: aName	| aPresenter putInViewer |	self setNameTo: aName.	(aPresenter _ self world presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		aPresenter flushViewerCache.		putInViewer ifTrue: [aPresenter viewMorph: self]].	self world allTileScriptingElements do:		[:m | m bringUpToDate]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/11/1998 16:54'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." 	self player ifNotNil:		[self player justClonedFrom: aDonor player]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/11/1998 16:54'!justDuplicatedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the dup gets a chance to get things right.  If a player  is involved, the duplication involved the creation of a fresh Player subclass rather than another instance of the original." 	self player ifNotNil:		[self player justDuplicatedFrom: aDonor player]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/11/1998 16:55'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile viewer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:	[NumericReadoutTile new typeColor: aColor]		ifFalse:	[StringReadoutTile new typeColor: aColor]. 	viewer _ UpdatingStringMorph new		target: self player;		getSelector: getSelector;		growable: false;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	typeSymbol == #string		ifTrue:			[viewer useStringFormat]		ifFalse:			[viewer useDefaultFormat].	aTile addMorphBack: viewer.	putSelector == #unused ifFalse: [aTile addArrows].	aTile setLiteralTo: (self scriptPerformer perform: getSelector) width: 30.	^ aTile! !!Morph methodsFor: 'extended access' stamp: 'sw 8/11/1998 16:48'!convertToExtendedFormat	"This method moves all property variables as well as eventHandler, and costumee into a morphicExtension.  It assumes that the convertedTo... compatibility method has been set to return true.  Once this has been run, (and the methods that access them have been changed), these fields can be removed from Morph"	| propVal |	"Move refs to eventhandler and costumee into extension"	eventHandler == nil ifFalse: [self eventHandler: eventHandler].	costumee == nil ifFalse: [self player: costumee].	properties == nil ifFalse:		[properties keys do:			[:key |  "Move property extensions into extension"			propVal _ properties at: key.			propVal ifNotNil:				[key == #possessive				ifTrue: [propVal == true ifTrue: [self bePossessive]]				ifFalse: [self setProperty: key toValue: propVal]]].			properties removeKey: key].	properties _ nil.! !!Morph methodsFor: 'extended access' stamp: 'sw 8/11/1998 16:19'!convertedToExtendedFormat	^ true! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:45'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	self player ifNil:		[self externalName.  "a default may be given if not named yet"		self player: self newPlayerInstance.  			"Different morphs may demand different player types"		self player costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ self player! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:46'!choosePenColor: evt	self assuredPlayer choosePenColor: evt! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:46'!choosePenSize	self assuredPlayer choosePenSize! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:53'!getPenColor	^ self player ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:53'!getPenDown	self player ifNil: [^ false].	^ self actorState getPenDown! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:53'!getPenSize	self player ifNil: [^ 1].	^ self actorState getPenSize! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:53'!jettisonScripts	self player ifNotNil: [self player class jettisonScripts]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:46'!liftPen	self assuredPlayer liftPen! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:46'!lowerPen	self assuredPlayer lowerPen! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:46'!penColor: aColor	self assuredPlayer penColor: aColor! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:44'!playerself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [^ nil].	^ extension player].	"Old code..."	^ costumee! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:43'!player: anObjectself convertedToExtendedFormat ifTrue: ["New code..."	extension == nil ifTrue: [self assureExtension].	extension player: anObject.^ self].	"Old code..."	costumee _ anObject! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:46'!scriptEditorFor: aScriptName	^ self assuredPlayer scriptEditorFor: aScriptName! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:54'!scriptPerformer	^ self player ifNil: [self]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:54'!showPlayerMenu	self player ifNotNil:		[self player showPlayerMenu]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:55'!tearOffTile	| aValue |	self player ifNotNil: [^ self player tearOffTileForSelf].		(aValue _ self valueAsConstant) ifNotNil:		[^ self world primaryHand attachMorph: aValue newTileMorphRepresentative]. 	^ self assuredPlayer tearOffTileForSelf! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/11/1998 16:56'!viewAfreshShowingScript: aScriptName at: aPosition	| anEditor |	self player updateAllViewers.	self world addMorph: (anEditor _ self player scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/11/1998 16:46'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state _ self actorStateOrNil.	state ifNil:		[state _ ActorState new initializeFor: self assuredPlayer.		self actorState: state].	^ state! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/11/1998 16:53'!addDebuggingItemsTo: aMenu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: aHandMorph.	subMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	subMenu add: 'inspect morph' action: #inspectArgument.	World ifNil:		[subMenu add: 'inspect morph (morphic)' action: #inspectArgumentInMorphic].	subMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[subMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [subMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		subMenu add: 'browse player class' action: #browsePlayerClass].	subMenu add: 'make own subclass' action: #subclassMorph.	subMenu add: 'internal name' action: #nameMorph.	subMenu add: 'save morph in file' action: #saveOnFile.	subMenu defaultTarget: self.	subMenu add: 'edit balloon help' action: #editBalloonHelpText.	subMenu add: 'temp command' action: #tempCommand.	aMenu add: 'debug...' subMenu: subMenu! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/11/1998 16:54'!okayToDuplicate	self player ifNil: [^ true].	self instantiatedUserScriptsDo:		[:aScript | aScript isAnonymous ifTrue:			[self inform: 'This object has one or moreunnamed, unsaved scripts,which would not be partof a duplicate.  So, for now,we just won''t let you dothis.  Sorry!!'.			^ false]].	^ true! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/11/1998 16:55'!usableDuplicateIn: aWorld	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	self player ifNotNil:		[newPlayer _ self player duplicatedPlayerForCostume: newMorph.			"nb newPlayer has had his costume set to newMorph in the above-called method"		self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"		newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer)].	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ aWorld allKnownNames copyWith: aName.		newMorph setNameTo: (			Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph justDuplicatedFrom: self.	newMorph isPartsDonor: false.	newMorph privateOwner: nil.	(newPlayer ~~ nil and: [newMorph renderedMorph eventHandler ~~ nil]) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	newPlayer ifNotNil: [self presenter flushPlayerListCache].	^ newMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/11/1998 16:55'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	self flag: #noteToTed.  "Note I've fallen back on veryDeepCopyWithoutPlayer here, because I want another instance of my Player's class rather than a new Player subclass."	newMorph _ self veryDeepCopyWithoutPlayer.	newPlayer _ self player class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"	newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'jun98 additions' stamp: 'sw 8/11/1998 16:55'!succeededInRevealing: aPlayer	aPlayer == self player ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 8/11/1998 16:51'!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage _ self currentPage) ifNil: [^ self].	(aPlayer _ aPage player) ifNotNil:		[aBlock value: aPlayer]! !!BookMorph methodsFor: 'other' stamp: 'sw 8/11/1998 16:50'!succeededInRevealing: aPlayer	currentPage ifNotNil: [currentPage player == aPlayer ifTrue: [^ true]].	pages do:		[:aPage |			(aPage succeededInRevealing: aPlayer) ifTrue:				[self goToPageMorph: aPage.				^ true]].	^ false! !!CompoundTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!DataMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:46'!becomeField	| aStack slotNameChosen  |	aStack _ self pasteUpMorph assuredPlayer.	slotNameChosen _ aStack addSlotNamedLike: self externalName withValue: self valueFromContents.	self getSelector: (Utilities getterSelectorFor: slotNameChosen).	self putSelector: (Utilities setterSelectorFor: slotNameChosen).	self target: aStack.	status _ #field.	aStack updateAllViewers! !!EToyPalette methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:46'!viewMorph: aMorph		| aPlayer aPresenter |	currentPalette ifNotNil: [currentPalette delete].  "was the Paint palette"	currentPalette _ nil.	aPlayer _ aMorph assuredPlayer.	aPresenter _ self presenter.	viewPalette _ aPresenter viewerCache at: aPlayer ifAbsent:		[self world "temp" addMorph: (viewPalette _ self partsViewerClass newSticky).		viewPalette setPlayer: aPlayer.		aPresenter cacheViewer: viewPalette forPlayer: aPlayer.		viewPalette delete.		viewPalette].	BookMorph classPool at: #PageFlipSoundOn put: true.		"In case an error turned 		the sound off"	self presenter coloredTilesEnabled ifFalse:		[viewPalette makeAllTilesGreen].	self showViewPalette.! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:52'!browsePlayerClass	Browser newOnClass: argument player class label: 'Compiled scripts for ', argument player externalName! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:51'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == owner "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	argMorph player ifNotNil: [argMorph player addPlayerMenuItemsTo: menu hand: self].	menu defaultTarget: self.	Preferences noviceMode ifFalse:		[argMorph addDebuggingItemsTo: menu hand: self].	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:46'!changeVariableType	argument ifNotNil:		[argument assuredPlayer changeVariableType]! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:46'!chooseNewCostumeForArgument	argument notNil ifTrue:		[argument assuredPlayer newCostume]! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:51'!duplicateMorph	| newMorph |	newMorph _ argument veryDeepCopy.		false ifTrue: [newMorph _ argument usableDuplicateIn: self world].	"old"	self grabMorphFromMenu: newMorph.	newMorph player ifNotNil: [newMorph player startRunning].	" -- End of presently active code -- "	self flag: #noteToDan.  "The following code was formerly in duplicateMorph, and 		may need to be reincorporated somewhere:""	oldModel _ argument findA: MorphicModel.	oldModel ifNotNil:		[oldModel model duplicate: (new findA: MorphicModel) from: oldModel]."	self flag: #noteToTed.  "the following corrsponds to the hook you had in for getting script tiles straightened out:""	newMorph justDuplicatedFrom: argument.		We depend on nameInModel working, and hand having grabbed already (old tck note)"! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:51'!inspectArgumentsPlayerInMorphic	self attachMorph: ((Inspector openAsMorphOn: argument player) extent: 300@200)! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:52'!inspectPlayer	argument player inspect! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/11/1998 16:53'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee player ifNotNil: [aPastee player startRunning]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 8/11/1998 16:44'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette |	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ Player newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!MorphExtension methodsFor: 'other properties' stamp: 'sw 8/11/1998 16:16'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	propName == #locked ifTrue: [self halt. ^ locked ~~ nil].	propName == #visible ifTrue: [self halt. ^ visible ~~ nil].	propName == #sticky ifTrue: [self halt. ^ sticky ~~ nil].	propName == #balloonText ifTrue: [self halt. ^ balloonText ~~ nil].	propName == #balloonTextSelector ifTrue: [self halt. ^ balloonTextSelector ~~ nil].	propName == #partsDonor ifTrue: [self halt. ^ isPartsDonor ~~ nil].	propName == #possessive ifTrue: [self halt].	propName == #actorState ifTrue: [self halt. ^ actorState ~~ nil].	propName == #player ifTrue: [self halt. ^ player ~~ nil].	propName == #name ifTrue: [self halt. ^ externalName ~~ nil].  "*OLD*"	otherProperties == nil ifTrue: [^ false].	prop _ otherProperties at: propName ifAbsent: [nil].	prop == nil ifTrue: [^ false].	prop == false ifTrue: [^ false].	^ true! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:56'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!liftAllPens	submorphs do: [:m | m assuredPlayer liftPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!lowerAllPens	submorphs do: [:m | m assuredPlayer lowerPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:57'!recordTurtlePositions	"Record the current positions of all turtles (Actors) whose pens are down."	| aPlayer |	lastTurtlePositions _ IdentityDictionary new: submorphs size * 4.	submorphs do: [:m |		(aPlayer _ m player) ifNotNil:			[aPlayer getPenDown ifTrue:				[lastTurtlePositions at: aPlayer put: m referencePosition]]].! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:47'!becomeStack	currentDataInstance _ self assuredPlayer.	dataInstances _ OrderedCollection with: currentDataInstance.	isStackLike _ true.	self borderWidth: (self borderWidth + 1).	submorphs do:		[:aMorph | aMorph holdsDataForEachInstance			ifTrue:				[aMorph becomeField]].! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:50'!installAsCurrent: anInstance	self flag: #deferred.	currentDataInstance _ anInstance.	"aList _ self world allViewersOn: currentDataInstance."	anInstance costume: self.	self player: anInstance.	self morphsForInstanceData do:			[:m | m dockUpToInstance: anInstance]."	aList do:		[:aViewer |  ... remove it, or install the new instance into it."! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!actualObject	"Answer the player that's the object of my attention"	^ self associatedPlayer! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!associatedPlayer	"Answer the player that's the object of my attention"	^ self firstSubmorph firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:57'!try	| aPlayer |	userScriptSelector == nil		ifFalse:			[aPlayer _ self objectViewed player.			aPlayer perform: userScriptSelector]		ifTrue:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false].	(Delay forMilliseconds: 200) wait! !!Player methodsFor: 'costume' stamp: 'sw 8/11/1998 16:49'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	((costume isKindOf: SketchMorph) and: [(aMorph isKindOf: SketchMorph)])		ifTrue:			[^ costume wearCostume: aMorph].	self costumeDictionary		at: aMorph formalCostumeName		put: (aMorph fullCopy player: nil).	costume ifNotNil:		[itsBounds _ costume bounds.		costume pasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/11/1998 16:47'!getValueAtCursor	| costumeToUse anObject renderedMorph |	costumeToUse _ ((renderedMorph _ costume renderedMorph) respondsTo: #valueAtCursor) 		ifTrue:			[renderedMorph]		ifFalse:			[self costumeNamed: #PasteUpMorph].	anObject _ costumeToUse valueAtCursor.	^ anObject == 0  "weird return from Holder & Graph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'misc' stamp: 'sw 8/11/1998 16:58'!owner	"Answer the player who wears my costume's owner as its costume"	| itsOwner |	costume ifNotNil:		[(itsOwner _ costume owner) ifNotNil:			[^ itsOwner player]].	^ nil! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 8/11/1998 16:47'!mouseDown: evt	"Allow the user to respecify this by direct clicking"	| aMorph |	putSelector == #unused ifTrue: [^ self].	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	objectToView perform: putSelector with: aMorph assuredPlayer.	self changed! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 8/11/1998 16:47'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formDictionary at: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot'.	aMorph setBalloonText: 'hrrumph, grr'.	self positionStandardPlayer.	^ standardPlayer	"ScriptingSystem formDictionary at: 'standardPlayer' put: (GIFImports at: 'broom')"! !!Presenter methodsFor: 'viewer' stamp: 'sw 8/11/1998 16:47'!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[(aPalette _ aMorph standardPalette) ifNotNil:			[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	aViewer makeAllTilesGreen.	aMorph primaryHand attachMorph: aViewer! !!Presenter methodsFor: 'playerList' stamp: 'sw 8/11/1998 16:58'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ (associatedMorph allMorphsIncludingBookPages select: [:m | m player ~~ nil] thenCollect: [:m | m player]) asArray! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:58'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted _ anActorMorph player! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:41'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!TabMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:59'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be a TabbedPalette"	self player ifNotNil: [self player runAllOpeningScripts ifTrue: [^ self]].	(owner isKindOf: IndexTabs) ifFalse: [^ self beep].	(owner owner isKindOf: TabbedPalette) ifFalse: [^ self beep].	owner owner selectTab: self! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 8/11/1998 16:47'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	self hasViewerTab ifFalse: [self addViewerTab].	self selectViewerTab.	currentPage setPlayer: aMorph assuredPlayer.	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self layoutChanged.	self ownerChanged.! !!TransformationMorph methodsFor: 'menu' stamp: 'sw 8/11/1998 16:49'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	(anActorState _ self actorStateOrNil) ifNotNil:		[unflexed actorState: anActorState].	(aName _ self knownName) ifNotNil:		[unflexed setNameTo: aName].	unflexed player: self player.	self player ifNotNil:		[self player rawCostume: unflexed.		self player: nil].	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !Morph removeSelector: #veryDeepCopyWithoutCostumee!Morph removeSelector: #costumee!Morph removeSelector: #assuredCostumee!Morph removeSelector: #costumee:!CompoundTileMorph removeSelector: #player!HandMorph removeSelector: #inspectArgumentsCostumee!HandMorph removeSelector: #inspectArgumentsCostumeeInMorphic!HandMorph removeSelector: #inspectCostumee!PhraseTileMorph removeSelector: #player!SystemQueryPhrase removeSelector: #player!