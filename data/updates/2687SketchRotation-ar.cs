'From Squeak2.9BJ of 22 September 2000 [latest update: #2364] on 23 September 2000 at 1:40:40 pm'!"Change Set:		SketchRotation-arDate:			23 September 2000Author:			Andreas RaabThe ultimate fix for any problems related to center of rotation. Throws out *all* rotation related code from SketchMorph (the only thing Sketches do is resizing) and generalizes the notion of the reference point wrt. rotation and scale into morph. The reference point is now defined relative inside the morphs bounds. Also cleans up the notion of 'heading' and 'forward direction'. Removes tons of special cases (ala 'something isKindOf: SketchMorph') by simply making center of rotation and forward direction accessible to any morph.All in all the change set removes more code than it adds ;-)"!Morph subclass: #SketchMorph	instanceVariableNames: 'originalForm rotationStyle scalePoint framesToDwell rotatedForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 13:36'!forwardDirection	"Return the receiver's forward direction (in eToy terms)"	^self valueOfProperty: #forwardDirection ifAbsent:[0.0]! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 14:29'!forwardDirection: newDirection	"Set the receiver's forward direction (in eToy terms)"	self setProperty: #forwardDirection toValue: newDirection.! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 13:37'!heading	"Return the receiver's heading (in eToy terms)"	^self forwardDirection +		(self isFlexed			ifTrue:[owner rotationDegrees]			ifFalse:[0.0])! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 13:37'!heading: newHeading	"Set the receiver's heading (in eToy terms)"	self isFlexed ifFalse:[self addFlexShell].	owner rotationDegrees: (newHeading - self forwardDirection).! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 20:12'!referencePosition	"Return the current reference position of the receiver"	| box |	box _ self bounds.	^box origin + (self rotationCenter * box extent).! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 20:12'!referencePosition: aPosition	"Move the receiver to match its reference position with aPosition"	self position: self position + (aPosition - self referencePosition)! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 20:10'!rotationCenter	"Return the rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	^self valueOfProperty: #rotationCenter ifAbsent:[0.5@0.5]! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 20:11'!rotationCenter: aPointOrNil	"Set the new rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	aPointOrNil isNil		ifTrue:[self removeProperty: #rotationCenter]		ifFalse:[self setProperty: #rotationCenter toValue: aPointOrNil]! !!Morph methodsFor: 'menus' stamp: 'ar 9/22/2000 20:36'!resetForwardDirection	self forwardDirection: 0.! !!Morph methodsFor: 'menus' stamp: 'ar 9/22/2000 20:15'!setRotationCenter	| p |	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton].	Sensor waitNoButton.	self setRotationCenterFrom: (self transformFromWorld globalPointToLocal: p).! !!Morph methodsFor: 'menus' stamp: 'ar 9/22/2000 20:14'!setRotationCenterFrom: aPoint	self rotationCenter: (aPoint - self bounds origin) / self bounds extent asFloatPoint.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 9/22/2000 20:41'!addOptionalHandlesTo: aHalo box: box	aHalo addDirectionHandles! !!Morph methodsFor: 'testing' stamp: 'ar 9/22/2000 13:44'!isFlexed	"Return true if the receiver is currently flexed"	owner ifNil:[^false].	^owner isFlexMorph! !!HaloMorph methodsFor: 'private' stamp: 'ar 9/22/2000 20:41'!addDirectionHandles	| centerOfRotationHandle |	self addDirectionShaft.	centerOfRotationHandle _ self		addGraphicalHandle: #RotationCenter at: target referencePosition			on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self.	centerOfRotationHandle			on: #mouseStillDown send: #trackCenterOfRotation:with: to: self.	centerOfRotationHandle			on: #mouseUp send: #setCenterOfRotation:with: to: self! !!HaloMorph methodsFor: 'private' stamp: 'ar 9/22/2000 14:26'!addDirectionShaft	| directionHandle shaft info |	directionArrowAnchor _ target referencePositionInWorld.	self addMorphFront: (shaft _ PolygonMorph newSticky).	shaft makeOpen; borderWidth: 5; borderColor: Color orange.	shaft setCenteredBalloonText: 'Forward direction'.	info _ self positionDirectionShaft: shaft.	directionHandle _ self addGraphicalHandle: #Direction at: info first  on: #mouseDown send: #doDirection:with: to: self.	self correctlyRotateDirectionArrow: directionHandle forDegrees: target heading.	directionHandle center: info first.	directionHandle on: #mouseStillDown send: #trackDirectionArrow:with: to: self.	directionHandle on: #mouseUp send: #setDirection:with: to: self.	directionHandle setProperty: #helpAtCenter toValue: true.	self completeDisplayFor: directionHandle centeringTipAt: (self directionArrowTipCenterFor: directionHandle).! !!HaloMorph methodsFor: 'private' stamp: 'ar 9/22/2000 20:48'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |	degrees _ (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	self addDirectionShaft.	target rotationDegrees: degrees.	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	(self valueOfProperty: #commandInProgress) doIfNotNil:		[:cmd | "Update the final rotation"		cmd redoTarget: target selector: #rotationDegrees: argument: degrees].	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'ar 9/23/2000 13:15'!doScale: evt with: scaleHandle	"Update the scale of my target if it is scalable."	| newHandlePos |	newHandlePos _ evt cursorPoint - (scaleHandle extent // 2).	target scaleToMatch: newHandlePos.	target scale = 1.0		ifTrue: [scaleHandle color: Color yellow]		ifFalse: [scaleHandle color: Color orange].	scaleHandle position: newHandlePos.	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'ar 9/22/2000 20:14'!setCenterOfRotation: evt with: rotationHandle	| localPt |	localPt _ innerTarget transformFromWorld globalPointToLocal: evt cursorPoint.	innerTarget setRotationCenterFrom: localPt.	self endInteraction! !!HaloMorph methodsFor: 'private' stamp: 'ar 9/22/2000 21:37'!setDirection: anEvent with: directionHandle	"The user has let up after having dragged the direction arrow; now set the forward direction of the actual SketchMorph accordingly"	| delta degrees |	delta _ (innerTarget transformFromWorld globalPointToLocal: directionHandle center) - innerTarget referencePosition.	degrees _ delta degrees + 90.0.	target forwardDirection: (degrees \\ 360) rounded.	self endInteraction! !!HandMorph methodsFor: 'from EToyHand' stamp: 'ar 9/22/2000 20:35'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette tfx whereToPresent |	self world assureNotPaintingElse: [^ self].	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			whereToPresent _ aPasteUpMorph presenter.			newSketch form: aForm.			tfx _ aPasteUpMorph transformFrom: aPasteUpMorph world.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!MovieMorph methodsFor: 'private' stamp: 'ar 9/23/2000 12:44'!setFrame: newFrameIndex	| oldFrame p newFrame |	oldFrame _ self currentFrame.	oldFrame ifNil: [^ self].	self changed.	p _ oldFrame referencePosition.	currentFrameIndex _ newFrameIndex.	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	newFrame _ frameList at: currentFrameIndex.	newFrame referencePosition: p.	oldFrame delete.	self addMorph: newFrame.	dwellCount _ newFrame framesToDwell.	self layoutChanged.	self changed.! !!Player methodsFor: 'costume' stamp: 'ar 9/22/2000 14:52'!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph known anEventHandler |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	anEventHandler _ renderedMorph eventHandler.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner replaceSubmorph: costume by: aMorph.			aMorph player: self.			aMorph actorState: costume actorState.			(known _ costume knownName) ifNotNil:				[aMorph setNameTo: known].			costume _ aMorph].	aMorph eventHandler: anEventHandler! !!Player methodsFor: 'costume' stamp: 'ar 9/22/2000 20:34'!wearSketchCostumeWithForm: itsForm using: existingSketchMorph	|  aSketchMorph chgd refPos |	refPos _ (aSketchMorph _ costume renderedMorph) referencePosition.	(aSketchMorph isKindOf: SketchMorph)		ifFalse:			[aSketchMorph _ SketchMorph new player: self].	chgd _ false.	aSketchMorph form: itsForm.	existingSketchMorph ifNotNil:		[aSketchMorph			rotationCenter: existingSketchMorph rotationCenter;			framesToDwell: existingSketchMorph framesToDwell;			rotationStyle: existingSketchMorph rotationStyle;			referencePosition: refPos.		(existingSketchMorph rotationStyle ~~ #normal)			ifTrue:				[aSketchMorph rotationStyle: existingSketchMorph rotationStyle.				aSketchMorph forwardDirection: existingSketchMorph forwardDirection.				chgd _ true]].	chgd ifTrue: [aSketchMorph layoutChanged].	self renderedCostume: aSketchMorph! !!Player methodsFor: 'slot getters/setters' stamp: 'ar 9/22/2000 13:42'!getHeadingUnrounded	^ self costume heading asSmallAngleDegrees! !!Player methodsFor: 'slot getters/setters' stamp: 'ar 9/22/2000 21:25'!setHeading: newHeading	| aCostume |	aCostume _ self costume.	aCostume heading: newHeading.	(aCostume isFlexMorph and:[aCostume hasNoScaleOrRotation]) 		ifTrue:[aCostume removeFlexShell].! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'ar 9/22/2000 20:31'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	"NB: if aPosition is nil, then it's assumed that the paintbox is obtained from a flap or some such, so do nothing special regarding a palette in this case.  The palette needs already to be in the world for this to work."	| w  |	(w _ aPasteUpMorph world) addMorphFront: self.	enclosingPasteUpMorph _ aPasteUpMorph.	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	palette _ w paintBox focusMorph: self.	palette beStatic.		"give Nebraska whatever help we can"	palette fixupButtons.	palette addWeakDependent: self.	aPosition ifNotNil:		[w addMorphFront: palette.  "bring to front"		palette position: aPosition].	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'access' stamp: 'ar 9/22/2000 20:35'!forwardDirection	"The direction object will go when issued a sent forward:.  Up iszero.  Clockwise like a compass.  From the arrow control."	^ hostView forwardDirection! !!SketchMorph methodsFor: 'initialization' stamp: 'ar 9/22/2000 20:38'!initializeWith: aForm	super initialize.	originalForm _ aForm.	self rotationCenter: 0.5@0.5.		"relative to the top-left corner of the Form"	rotationStyle _ #normal.		"styles: #normal, #leftRight, #upDown, or #none"	scalePoint _ 1.0@1.0.	framesToDwell _ 1.	rotatedForm _ originalForm.	"cached rotation of originalForm"	self extent: originalForm extent.! !!SketchMorph methodsFor: 'accessing' stamp: 'ar 9/22/2000 20:33'!form: aForm	originalForm _ aForm.	self rotationCenter: 0.5@0.5.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing' stamp: 'ar 9/22/2000 22:31'!forwardDirection: degrees	"If not rotating normally, update my rotatedForm"	super forwardDirection: degrees.	rotationStyle == #normal ifFalse:[self layoutChanged].! !!SketchMorph methodsFor: 'accessing' stamp: 'ar 9/22/2000 21:19'!heading: newHeading	"If not rotating normally, change forward direction rather than heading"	rotationStyle == #normal ifTrue:[^super heading: newHeading].	self isFlexed		ifTrue:[self forwardDirection: newHeading - owner rotationDegrees]		ifFalse:[self forwardDirection: newHeading].	self layoutChanged! !!SketchMorph methodsFor: 'drawing' stamp: 'ar 9/22/2000 20:25'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| scalePt smoothPix pair |	scalePoint ifNil:[scalePoint _ 1@1].	scalePt _ scalePoint x abs @ scalePoint y abs.	rotationStyle == #none ifTrue:[scalePt _ 1@1].	((scalePt x < 1.0) or: [scalePt y < 1.0])		ifTrue: [smoothPix _ 2]		ifFalse: [smoothPix _ 1].	rotationStyle = #leftRight ifTrue:[		self heading asSmallAngleDegrees < 0.0 			ifTrue:[scalePt _ scalePt x negated @ scalePt y]].	rotationStyle = #upDown ifTrue:[		self heading asSmallAngleDegrees abs > 90.0			ifTrue:[scalePt _ scalePt x @ scalePt y negated]].	scalePt = (1@1) ifTrue:[		rotatedForm _ originalForm.	] ifFalse:[		pair _ WarpBlt current			rotate: originalForm			degrees: 0			center: originalForm boundingBox center			scaleBy: scalePt			smoothing: smoothPix.		rotatedForm _ pair first.	].! !!SketchMorph methodsFor: 'geometry' stamp: 'ar 9/22/2000 21:23'!extent: newExtent	"Change my scale to fit myself into the given extent."	self extent = newExtent ifTrue:[^self].	scalePoint _ newExtent asFloatPoint / originalForm extent.	self layoutChanged.! !!SketchMorph methodsFor: 'menu' stamp: 'ar 9/22/2000 20:35'!editDrawingIn: aPasteUpMorph forBackground: forBackground	| w bnds sketchEditor pal aPaintTab aWorld aPaintBox tfx |	self world assureNotPaintingElse: [^ self].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	forBackground		ifTrue:			[bnds _ aPasteUpMorph boundsInWorld]		ifFalse:			[bnds _ (self boundsInWorld expandBy: (60 @ 60)) intersect: self world bounds.			bnds _ (aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds].	sketchEditor _ SketchEditorMorph new.	forBackground ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor initializeFor: self inBounds: bnds pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			self form: aForm.			tfx _ aPasteUpMorph transformFrom: aPasteUpMorph world.			self topRendererOrSelf position: (tfx globalPointToLocal: aRect origin).			self rotationStyle: sketchEditor rotationStyle.			self forwardDirection: sketchEditor forwardDirection.			self presenter drawingJustCompleted: self.			forBackground ifTrue: [self goBehind]]  "shouldn't be necessary"		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aWorld _ self currentWorld.				"sometimes by now I'm no longer in a world myself, but we still need				 to get ahold of the world so that we can deal with the palette"			((pal _ aPasteUpMorph standardPalette) notNil and: [pal isInWorld])				ifTrue:					[(aPaintBox _ aWorld paintBox) ifNotNil: [aPaintBox delete].					pal viewMorph: self]				ifFalse:					[(aPaintTab _ aWorld paintingFlapTab)						ifNotNil:							[aPaintTab hideFlap]						ifNil:							[(aPaintBox _ aWorld paintBox) ifNotNil: [aPaintBox delete]]]]! !!SketchMorph methodsFor: 'menu' stamp: 'ar 9/22/2000 21:13'!setRotationStyle	| selections labels sel reply |	selections _ #(normal leftRight upDown none).	labels _ #('rotate smoothly' 'left-right flip only' 'top-down flip only' 'don''t rotate').	sel _ labels at: (selections indexOf: self rotationStyle ifAbsent:[1]).	labels _ labels collect:[:lbl| sel = lbl ifTrue:['<on>',lbl] ifFalse:['<off>',lbl]].	reply _ (SelectionMenu labelList: labels selections: selections) startUp.	reply ifNotNil: [self rotationStyle: reply].! !!SketchMorph methodsFor: 'change reporting' stamp: 'ar 9/22/2000 14:00'!layoutChanged	"Update rotatedForm and compute new bounds."	self changed.	self generateRotatedForm.	bounds _ bounds origin extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'object fileIn' stamp: 'ar 9/23/2000 12:46'!convertbosfceorrrsfro0: varDict bosfceorsfr0: smartRefStrm	"These variables are automatically stored into the new instance #('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'extension' 'originalForm' 'rotationStyle' 'scalePoint' 'framesToDwell' 'rotatedForm').	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."		"These are going away #('rotationCenter' 'rotationDegrees' 'offsetWhenRotated').  Possibly store their info in another variable?"! !!TransformationMorph methodsFor: 'accessing' stamp: 'ar 9/22/2000 14:17'!rotationDegrees: degrees	self adjustAfter:[self angle: degrees degreesToRadians negated]! !!TransformationMorph methodsFor: 'accessing' stamp: 'ar 9/23/2000 13:40'!scaleToMatch: aPoint	| scaleFactor tfm originalScale |	tfm _ transform withScale: 1.0.	originalScale _ ((tfm localBoundsToGlobal: self renderedMorph fullBounds) corner -		(tfm localPointToGlobal: self renderedMorph referencePosition)) r.	"Catch cases where the reference point is on fullBounds corner"	originalScale < 1.0 ifTrue:[originalScale _ 1.0].	scaleFactor _ (aPoint - self referencePosition) r / originalScale.	scaleFactor _ scaleFactor < 1.0		ifTrue: [scaleFactor detentBy: 0.05 atMultiplesOf: 0.25 snap: false]		ifFalse: [scaleFactor detentBy: 0.1 atMultiplesOf: 0.5 snap: false].	self adjustAfter:[self scale: ((scaleFactor min: 8.0) max: 0.1)].! !!TransformationMorph methodsFor: 'e-toy support' stamp: 'ar 9/22/2000 20:44'!forwardDirection	^self renderedMorph forwardDirection! !!TransformationMorph methodsFor: 'e-toy support' stamp: 'ar 9/22/2000 20:44'!forwardDirection: degrees	^self renderedMorph forwardDirection: degrees! !!TransformationMorph methodsFor: 'e-toy support' stamp: 'ar 9/22/2000 13:38'!heading	^self renderedMorph heading! !!TransformationMorph methodsFor: 'e-toy support' stamp: 'ar 9/22/2000 13:38'!heading: newHeading	self renderedMorph heading: newHeading! !TransformationMorph removeSelector: #referencePosition:!TransformationMorph removeSelector: #scaleToFit:!SystemWindow removeSelector: #isFlexed!SketchMorph removeSelector: #addOptionalHandlesTo:box:!SketchMorph removeSelector: #doesOwnRotation!SketchMorph removeSelector: #forwardDirection!SketchMorph removeSelector: #referencePosition!SketchMorph removeSelector: #referencePosition:!SketchMorph removeSelector: #resetForwardDirection!SketchMorph removeSelector: #rotationCenter!SketchMorph removeSelector: #rotationCenter:!SketchMorph removeSelector: #rotationDegrees!SketchMorph removeSelector: #rotationDegrees:!SketchMorph removeSelector: #rotationDegrees:scalePoint:!SketchMorph removeSelector: #setRotationCenter!SketchMorph removeSelector: #setRotationCenterFromGlobalPosition:!SketchMorph removeSelector: #setupAngle!SketchMorph removeSelector: #setupAngle:!SketchMorph removeSelector: #wearCostume:!MovieMorph removeSelector: #rotationDegrees:!MovieMorph removeSelector: #setRotationCenter!