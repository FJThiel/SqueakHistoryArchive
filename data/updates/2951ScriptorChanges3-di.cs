'From Squeak2.9alpha of 12 June 2000 [latest update: #2997] on 11 November 2000 at 12:35:50 pm'!"Change Set:		ScriptorChanges3Date:			10 November 2000Author:			Dan IngallsSeveral more changes to the new tile scriptors, including...	Establishes uniform vertical offset.	Eliminates extra vertical spacing in blocks.	Extends message folding to case where arg is wide as well.	But also unfolds keyword messges that are not too wide.	Drops horizontal inset of all morphs.	Introduces a vertical bar icon for block scope."!!AssignmentNode methodsFor: 'tiles' stamp: 'di 11/10/2000 17:55'!asMorphicSyntaxIn: parent	| row |	row _ parent addRow: #assignment on: self.	variable asMorphicSyntaxIn: row.	row addToken: ' _ ' type: #assignment on: self.	value asMorphicSyntaxIn: row.	^row! !!BlockNode methodsFor: 'tiles' stamp: 'di 11/11/2000 10:49'!asMorphicSyntaxIn: parent	| len shown row column |	(column _ parent addColumn: #block on: self) minBorderWidth: 1.	column layoutInset: 2@-1.	self addCommentToMorph: column.	len _ shown _ statements size.	column explanation: 'A block of ',len printString,' Smalltalk statements',(		arguments size = 0 ifTrue: [''] ifFalse: [' and ',arguments size printString,' arguments']	).		"(levelOrZero = 0 and: [statements last isReturnSelf]) ifTrue: [shown _ 1 max: shown - 1]."	arguments size = 0 ifFalse: [		row _ column addRow: #blockarg1 on: (BlockArgsNode new).		arguments do: [:arg | 			(arg asMorphicSyntaxIn: row) color: #blockarg2		].	].	(statements copyFrom: 1 to: shown) do: [ :each | 		(each asMorphicSyntaxIn: column) borderWidth: 1.		each addCommentToMorph: column.	].	^column! !!MessageNode methodsFor: 'tiles' stamp: 'di 11/10/2000 23:59'!morphFromKeywords: key arguments: args on: parent indent: ignored	| keywords column row selType explanation receiverString getMenuBlock receiverMorph firstArgMorph receiverWidth messageWidth |	getMenuBlock _ [ :aClass | self buildMenuForClass: aClass andSelector: key].	receiver ifNotNil: [	"i.e. not a cascade"		receiverMorph _ receiver asMorphicSyntaxIn: parent.	].	parent getMenuBlock: getMenuBlock.	keywords _ key keywords.	selType _ precedence asPrecedenceName.	receiverString _ receiver ifNil: [		''	] ifNotNil: [		' sent to ',receiver explanation	].	args size = 0 ifTrue: [		row _ parent 			addTextRow: key getMenuBlock: getMenuBlock explanation: nil.		parent explanation: selType,' message #',keywords first,receiverString.		^ row parseNode: selector.	].	receiverWidth _ receiver ifNil: [0] ifNotNil: [receiverMorph fullBounds width].	(receiverWidth <= 80 and: [args size = 1]) ifTrue: [		row _ parent 			addTextRow: keywords first  			getMenuBlock: getMenuBlock			explanation: selType,' selector'.		row parseNode: selector.		firstArgMorph _ args first asMorphicSyntaxIn: parent.		receiver ifNil: [^ self].		(firstArgMorph fullBounds height > 100 or: [firstArgMorph fullBounds width > 250])			ifTrue: [parent foldMessageOneArg].		^ self	].		explanation _ 'A keyword message #',key,				' with ',keywords size printString,' arguments'.	column _ parent addColumn: #keyword1 on: self.	column explanation: explanation;  getMenuBlock: getMenuBlock.	messageWidth _ 0.	keywords with: (args copyFrom: 1 to: keywords size) do:		[:kwd :arg |		(row _ column addRow: #keyword2 on: self)			borderWidth: 1;			parseNode: (self as: MessagePartNode);			borderColor: row stdBorderColor.		row addToken: kwd type: #keyword2 on: (KeyWordNode new).		arg asMorphicSyntaxIn: row.		messageWidth _ messageWidth + row fullBounds width].	explanation _ explanation,receiverString.	parent explanation: explanation.	receiverMorph ifNotNil:		[(receiverWidth + messageWidth) < 350			ifTrue: [^ parent unfoldMessage].		((receiverWidth > 200			or: [receiverWidth > 80 and: [column fullBounds height > 20]])		or: [receiverMorph fullBounds width > 30			and: [column fullBounds height > 100 or: [column fullBounds width > 250]]])			ifTrue: [^ parent foldMessage]]! !!MethodNode methodsFor: 'tiles' stamp: 'di 11/10/2000 18:23'!asMorphicSyntaxIn: morph	| header tempMorph selNode |	selNode _ selectorOrFalse class == SelectorNode 		ifTrue: [selectorOrFalse] 		ifFalse: [SelectorNode new key: selectorOrFalse code: nil].	header _ morph addRow: Color white on: selNode.	header explanation: precedence asPrecedenceName,' message header for: #',self selector.	precedence = 1		ifTrue: [header addToken: self selector type: #keyword1 on: self]		ifFalse: [self selector keywords with: arguments do:					[:kwd :arg | 					header addToken: kwd type: #keyword2 on: self.					(arg asMorphicSyntaxIn: header) color: #blockarg2]].	self addCommentToMorph: morph.	temporaries size > 0 ifTrue: [		tempMorph _ morph addRow: #tempVariable on: (MethodTempsNode new).		tempMorph 			color: tempMorph color darker;			explanation: 'These temporary variables are defined for the duration of this method'.		temporaries do: [:temp | 			temp asMorphicSyntaxIn: tempMorph		] separatedBy: [			tempMorph addMorphBack: (tempMorph transparentSpacerOfSize: 4@4)		].	].	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue: [		" Dont decompile <prim> for, eg, ^ self "		(morph addTextRow: (String streamContents: [ :strm | self printPrimitiveOn: strm]))			explanation: 'A primitive is in the VM. This is where all the hard stuff happens'.	].	block asMorphicSyntaxIn: morph.	^morph! !!SyntaxMorph methodsFor: 'drawing' stamp: 'di 11/11/2000 11:12'!drawOn: aCanvas	(self nodeClassIs: BlockNode) ifTrue:		[aCanvas fillRectangle: (self topLeft + (1@0) extent: 2@(self height-1)) color: Color blue.		aCanvas fillRectangle: (self topLeft + (1@0) extent: 4@1) color: Color blue.		aCanvas fillRectangle: (self bottomLeft + (1@-1) extent: 4@1) color: Color blue].	super drawOn: aCanvas! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'di 11/11/2000 10:04'!stdBorderColor 	"several choices of how to do the border"	(Preferences valueOfFlag: #noTileColor) 		ifTrue: [^ "color" Color transparent]		ifFalse: [^ "color darker" Color transparent]! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/10/2000 12:53'!addColumn: aColorOrSymbol on: aNode	| col |	self addMorphBack: (col _ self class column: aColorOrSymbol on: aNode).	^ col! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/11/2000 01:24'!addTextRow: aStringLikeItem getMenuBlock: aBlock explanation: aString	| row text |	(row _ self class row: #text on: nil) borderWidth: 1; layoutInset: 1.	text _ "NonEditableTextMorph" StringMorph new contents: aStringLikeItem.	row addMorph: text.	self addMorphBack: row.	row		getMenuBlock: aBlock;		explanation: aString.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/11/2000 01:24'!addToken: aString type: aColorOrSymbol on: aNode	^ (self addColumn: aColorOrSymbol on: aNode)		layoutInset: 1;		addMorphBack: (StringMorph contents: aString)! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/11/2000 12:23'!foldMessage	"I am a message whose receiver is wide, and whose message part is a column.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow |	messageRow _ SyntaxMorph row: #keyword1 on: parseNode.	messageRow addMorph: (self transparentSpacerOfSize: 20@10);			addMorphBack: submorphs second.	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/11/2000 12:23'!foldMessageOneArg	"I am a message that is wide, a row with receiver and a row with selector and arg.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow |	messageRow _ SyntaxMorph row: #keyword1 on: parseNode.	messageRow addMorph: (self transparentSpacerOfSize: 20@10);			addMorphBack: submorphs second;			addMorphBack: submorphs second.  "was the third"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'di 11/10/2000 23:52'!unfoldMessage	"I am a message whose message part is a column.	Rearrange me so that the entire message is one row."	| messageRow |	messageRow _ self submorphs last.	self privateRemoveMorph: messageRow.	messageRow submorphs do: [:m | self addMorphBack: m].! !!SyntaxMorph methodsFor: 'as yet unclassified' stamp: 'di 11/11/2000 09:37'!toDo"Biggies...[ ]	Integrate with EToy scriptors	releaseCachedState can discard all morphic structure.[ ]	Options:	Show / hide syntax markers (like [], (), ., :, ;, etc)	No color / color-in-focus / full color	Tiles / textiles / text[ ]	ParsedTextMorph -- looks like text but has all same substructure[ ]	Introduce notion of an UnParsedNode -- maybe a flag in ParseNode	Text -> UnParsed -> Parsed -> CodeGen[ ]	Need DnD evaluator, or some sort of '!!' button on any entity (halo?)	Also inspector / browser[ ]	All the type help we can getDetails ...[ ]	Introduce a vertical bar icon for blocks.[ ]	Introduce a notion of successive clicks to expand a selection.[ ]	Makes 'tearing off' a copy require a 5-pixel drag.[ ]	Start work on show / hide of syntax markers -- (), [], etc.[ ]	Start work on textiles (grabable entites in 'normal' text)[ ]	Option for full color within the current grab-focus.[ ]	Need autoscroll during drag for drop[ ]	Use, eg, shift-drag to move, del to delete[ ]	What about invalid drops -- stick on cursor?System...[ ]	Only keep history 7 deep; option to clear on quit	clear command above spaceLeft[ ]	Compute each page of prefs viewer on demand instead of as now.[ ]	Offer a search command that will gather up all preferences that match a given string (name or help string)Preferences enable: #noTileColor.Preferences disable: #noTileColor.Smalltalk browseAllSelect: [:cm | cm size > 600]SyntaxMorph testAll"! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/11/2000 10:26'!standardInset	^ -1@-1! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/11/2000 00:05'!testAllMethodsOver: methodSize  "MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 600]"	"Add up the total layout area for syntax morphs representing all methods	over the given size.  This is a stress-test for SyntaxMorph layout.	A small value for the total area is also a figure of merit in the presentation	of Squeak source code in general.""Results:	#(69 600 180820874 103700)  11/4	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoffFolded wide receivers, don't center keywords any more.	#(68 600 160033784 127727)  11/9	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoffFolded more messages, dropped extra vertical spacing in blocks.	#(68 600 109141704 137308)  11/10	79% build morphs, 6% get source, 8% layout, 7% parse, 0% roundoffFolded more messages, dropped extra horizontal spacing.	#(68 600 106912968 132171)  11/10	80% build morphs, ??% get source, 11% layout, 7% parse, ?% roundoffUnfolded keyword messages that will fit on one line.	#(68 600 96497372 132153)  11/10	81% build morphs, ??% get source, 8% layout, 8% parse, ?% roundoff"	| tree source biggies morph stats time area |	biggies _ Smalltalk allSelect: [:cm | cm size > methodSize].	stats _ OrderedCollection new.'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'	displayProgressAt: Sensor cursorPoint	from: 1 to: biggies size	during:		[:bar |		biggies withIndexDo:			[:methodRef :i | bar value: i.			Utilities setClassAndSelectorFrom: methodRef in: 				[:aClass :aSelector |				source _ (aClass compiledMethodAt: aSelector) getSourceFromFile.				time _ Time millisecondsToRun:					[tree _ Compiler new 						parse: source 						in: aClass 						notifying: nil.					morph _ tree asMorphicSyntaxUsing: SyntaxMorph.					area _ morph fullBounds area]].			stats add: {methodRef. area. time}]		].	^ {{biggies size.  methodSize. stats detectSum: [:a | a second]. stats detectSum: [:a | a third]}.		(stats asSortedCollection: [:x :y | x third >= y third]) asArray}! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 11/11/2000 12:33'!translateColor: aColorOrSymbol	aColorOrSymbol == #comment  ifTrue: [^ Color blue lighter].	aColorOrSymbol == #block  ifTrue: [^ Color transparent].	aColorOrSymbol == #text  ifTrue: [^ Color transparent].	aColorOrSymbol isColor  ifTrue: [^ aColorOrSymbol].	(Preferences valueOfFlag: #noTileColor) ifTrue: [^ Color paleOrange].	"override"	aColorOrSymbol == #assignment  ifTrue: [^ Color paleGreen].	aColorOrSymbol == #keyword1  ifTrue: [^ Color paleBuff].	aColorOrSymbol == #keyword2  ifTrue: [^ Color paleBuff lighter].	aColorOrSymbol == #cascade  ifTrue: [^ Color paleYellow darker].	aColorOrSymbol == #cascade2  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #literal  ifTrue: [^ Color paleMagenta].	aColorOrSymbol == #message  ifTrue: [^ Color paleYellow].	aColorOrSymbol == #method  ifTrue: [^ Color white].	aColorOrSymbol == #error  ifTrue: [^ Color red].	aColorOrSymbol == #return  ifTrue: [^ Color lightGray].	aColorOrSymbol == #variable  ifTrue: [^ Color paleTan].	aColorOrSymbol == #brace  ifTrue: [^ Color paleOrange].	aColorOrSymbol == #tempVariable  ifTrue: [^ Color paleYellow mixed: 0.75 with: Color paleGreen		"Color yellow lighter lighter"].	aColorOrSymbol == #blockarg2  ifTrue: [			^ Color paleYellow mixed: 0.75 with: Color paleGreen].	"arg itself"	aColorOrSymbol == #blockarg1  ifTrue: [^ Color paleRed].	"container"		"yellow mixed: 0.5 with: Color white"	^aColorOrSymbol! !!VariableNode methodsFor: 'tiles' stamp: 'di 11/10/2000 16:43'!asMorphicSyntaxIn: parent	^ parent addToken: name type: #variable on: self! !!TempVariableNode methodsFor: 'tiles' stamp: 'di 11/10/2000 16:43'!asMorphicSyntaxIn: parent	^ parent addToken: name type: #tempVariable on: self! !SyntaxMorph removeSelector: #foldWideReceiver!