'From Squeak 2.2 of Sept 23, 1998 on 12 November 1998 at 7:07:16 pm'!Dictionary subclass: #PluggableDictionary	instanceVariableNames: 'hashBlock equalBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!Set subclass: #PluggableSet	instanceVariableNames: 'hashBlock equalBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!PluggableDictionary commentStamp: 'ar 11/12/1998 19:06' prior: 0!Class PluggableDictionary allows the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the dictionary. See the class comment of PluggableSet for an example.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.!!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!copy	^super copy postCopyBlocks! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2].! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!PluggableSet commentStamp: 'ar 11/12/1998 19:06' prior: 0!PluggableSets allow the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the set which in turn can heavily improve the performance of sets and dictionaries.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.Example: Adding 1000 integer points in the range (0@0) to: (100@100) to a set.	| rnd set max pt |	set _ Set new: 1000.	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].The above is way slow since the default hashing function of points leads to an awful lot of collisions in the set. And now the same, with a somewhat different hash function:	| rnd set max pt |	set _ PluggableSet new: 1000.	set hashBlock:[:item| (item x bitShift: 16) + item y].	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].!!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:47'!copy	^super copy postCopyBlocks! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2]! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:40'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !