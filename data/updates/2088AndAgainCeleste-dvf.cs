'From Squeak2.8alpha of 4 February 2000 [latest update: #2052] on 3 May 2000 at 11:17:03 pm'!"Change Set:		037AndAgainCeleste-dvfDate:			2 May 2000Author:			Daniel VainsencherWARNING: I lost control over the order of changes. I'm not sure that Celeste still works as expected. Please keep in mind that this is for test pilots only.  Don't use it with important emails.  --smaEspecially for people with large mail databases...I find this is quite a change in quality of life in Celeste, so I'msending this out though it's a bit raw. Please help me flush out problems by reviewing the code.(Yes, this CS has all the class definitions it requires...)From the CS preamble -For test pilots only!! Backup your mail database!!(Actually, this shouldn't do anything retracting the cs and doing acompact can't fix, but I'd backup anyway).This modification changes the way Celeste save data changes afterfetching mail, sending it and so forth. This means no more waiting !!!!!!(BIG difference if you have a 2MB index file).Instead of saving the index file, a log of every change to the index iswritten as the actions are performed. This log is deleted when Celestedoes save the complete index (upon exiting). If Celeste should diebefore saving, the log will be read when Celeste comes up and the indexkept consistent with it.Several things I'd like your review, consideration and comments on -* Are there other methods that should use complete saving (nowconsolidateDB, rather than saveDB. Not much of a name, I know.Suggestions?)* The file classes were factored a certain way, and I've messed withthat. Maybe an abstract ""AppendOnlyFile"" class is in order? maybe thisis something more generally useful than just in Celeste? Anybody usesuch file DBs for other things from Squeak?* I'd like to see the index file imprevious to being lost by crash andmaybe able to handle (or warn about) concurrent instances of Celestemessing with it at the same time. Suggestions? Anyone feel like doingthis?Also includes a bug fix (specification detail kindly pointed out bySteve Elkins) - now keeps case of header value parameters (though notthe values themselves). This the defined default , and should workunless if someone finds specific parameters defined as case insensitive.Lastly, a small modification to the MailNotifier - if it fails toconnect due to not having a network connection, wait 3 minutes beforeretrying. I found it annoying."!MailDBFile subclass: #IndexFile	instanceVariableNames: 'msgDictionary timeSortedEntries logfile '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!Object subclass: #MailNotifier	instanceVariableNames: 'socket messageCount lastConnectTime password '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Mail Reader'!!MIMEHeaderValue class methodsFor: 'as yet unclassified' stamp: 'dvf 5/2/2000 00:53'!fromString: aString 	| parts newValue parms temp |	parts _ ReadStream on: (aString findTokens: ';').	newValue _ self new mainValue: parts next asLowercase.	parms _ Dictionary new.	parts do: 		[:e | 		temp _ e withBlanksTrimmed findTokens: '="'.		parms at: temp first put: temp second].	newValue parameters: parms.	^ newValue! !!MailDB methodsFor: 'initialize-release' stamp: 'dvf 5/1/2000 20:14'!close	"Save and close the messageFile."	self consolidateDB.	messageFile notNil ifTrue: [messageFile close].	rootFilename _ nil.	messageFile _ indexFile _ categoriesFile _ nil! !!MailDB methodsFor: 'open-create-save' stamp: 'dvf 5/1/2000 20:13'!consolidateDB	"Write all database files to disk."	rootFilename notNil		ifTrue: [Transcript show: 'Saving mail database ''' , rootFilename , '''...']		ifFalse: [Transcript show: 'Saving mail database...'].	messageFile notNil ifTrue: [messageFile save].	indexFile notNil ifTrue: [indexFile save].	categoriesFile notNil ifTrue: [categoriesFile save].	Transcript show: 'Done.';	 cr! !!MailDB methodsFor: 'open-create-save' stamp: 'dvf 5/1/2000 20:12'!saveDB	"Write all database files to disk."	rootFilename notNil		ifTrue: [Transcript show: 'Saving mail database ''' , rootFilename , '''...']		ifFalse: [Transcript show: 'Saving mail database...'].	messageFile notNil ifTrue: [messageFile save].	"indexFile notNil ifTrue: [indexFile save]."	categoriesFile notNil ifTrue: [categoriesFile save].	Transcript show: 'Done.';	 cr! !!MailDBFile methodsFor: 'file operations' stamp: 'dvf 4/29/2000 22:05'!save	"Atomically save a representation of this object to its file. The old file is 	renamed to '<oldname>.bak' before the new file is written. If the write 	operation fails, the old file may be restored by renaming it. If it 	succeeds, the .bak file is deleted."	"create the file if it doesn't already exist"	| f dir shortName |	(StandardFileStream isAFileNamed: filename)		ifFalse: 			[f _ StandardFileStream new open: filename forWrite: true.			f close].	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory forFileName: filename.	dir rename: shortName toBe: shortName , '.bak'.	Cursor write showWhile: [f _ FileStream fileNamed: filename.	self writeOn: f.	f setToEnd; close.].	dir deleteFileNamed: shortName , '.bak' ifAbsent: []! !!IndexFile methodsFor: 'file operations' stamp: 'dvf 5/1/2000 21:26'!openOn: aFileName messageFile: messageFile 	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: (ReadStream on: fileStream contentsOfEntireFile)		messageFile: messageFile.	self readLogMessageFile: messageFile .	"close and release the file stream"	fileStream _ nil! !!IndexFile methodsFor: 'file operations' stamp: 'dvf 4/30/2000 00:38'!readLogMessageFile: messageFile 	| file msgID entry |	file _ self logStream position: 0.	[file atEnd]		whileFalse: [(file peekFor: $r)				ifTrue: 					[MailDB readStringLineFrom: file.					self privateRemove: (MailDB readIntegerLineFrom: file)]				ifFalse: 					[msgID _ MailDB readIntegerLineFrom: file.					entry _ IndexFileEntry								readFrom: file								messageFile: messageFile								msgID: msgID. self privateAt: msgID put: entry]]! !!IndexFile methodsFor: 'dictionary access' stamp: 'dvf 4/30/2000 00:17'!at: msgID put: anIndexFileEntry 	"Associate the given IndexFileEntry with the given message ID."	timeSortedEntries removeAllSuchThat: [:assoc | assoc key = msgID].	"don't duplicate the entry!!"	self privateAt: msgID put: anIndexFileEntry.	self logStream print: msgID;	 cr.	"message ID"	anIndexFileEntry writeOn: self logStream.	self logStream close! !!IndexFile methodsFor: 'dictionary access' stamp: 'dvf 4/30/2000 00:21'!logStream	logfile ifNil: [logfile _ StandardFileStream new open: (filename,'.log') forWrite: true;				 setToEnd]		ifNotNil: [logfile closed ifTrue: [logfile open; setToEnd]].	^ logfile! !!IndexFile methodsFor: 'dictionary access' stamp: 'dvf 4/30/2000 00:10'!privateAt: msgID put: anIndexFileEntry 	"Associate the given IndexFileEntry with the given message ID."	timeSortedEntries removeAllSuchThat: [:assoc | assoc key = msgID].	"don't duplicate the entry!!"	msgDictionary at: msgID put: anIndexFileEntry.	timeSortedEntries add: (Association key: msgID value: anIndexFileEntry).	! !!IndexFile methodsFor: 'dictionary access' stamp: 'dvf 4/30/2000 00:09'!privateRemove: msgID 	"Remove the entry with the given ID from my Dictionary."	timeSortedEntries removeAllSuchThat: [:assoc | assoc key = msgID].	msgDictionary removeKey: msgID ifAbsent: [].	! !!IndexFile methodsFor: 'dictionary access' stamp: 'dvf 4/30/2000 00:59'!remove: msgID 	"Remove the entry with the given ID from my Dictionary."	self privateRemove: msgID.	self logStream nextPutAll: 'remove';	 cr;	 print: msgID;	 cr;	 close! !!IndexFile methodsFor: 'read-write' stamp: 'dvf 4/30/2000 00:51'!readFrom: aStream messageFile: messageFile 	"Initialize myself from the given text stream. It is assumed that the 	.index file was written in order of ascending message timestamps, 	although this method is only less efficient, not incorrect, if this is not 	the case."	| sorted lastTime msgID entry |	msgDictionary _ IdentityDictionary new: 1000.	timeSortedEntries _ (SortedCollection new: 1000)				sortBlock: [:m1 :m2 | m1 value time <= m2 value time].	sorted _ true.	lastTime _ nil.	[aStream atEnd]		whileFalse: 			[msgID _ MailDB readIntegerLineFrom: aStream.			entry _ IndexFileEntry						readFrom: aStream						messageFile: messageFile						msgID: msgID.			msgDictionary at: msgID put: entry.			timeSortedEntries addLast: (Association key: msgID value: entry).			(sorted & lastTime notNil and: [lastTime > entry time])				ifTrue: [sorted _ false].			lastTime _ entry time].	sorted ifFalse: [timeSortedEntries reSort]! !!IndexFile methodsFor: 'read-write' stamp: 'dvf 5/1/2000 20:19'!save	| dir shortName |	super save. 	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory forFileName: filename.	dir deleteFileNamed: shortName , '.log' ifAbsent: []! !!MailNotifier methodsFor: 'accessing' stamp: 'dvf 4/29/2000 21:50'!messageCount	"if no socket, try to connect in background, when done, remove socket."	socket		ifNil: 			[socket _ POPSocket new.						[socket serverName: Celeste popServer.			socket userName: Celeste popUserName.			socket password: self password.			"socket addProgressObserver: Transcript."			([socket connectToPOP]				on: Error do: 				[Transcript show: 'Couldn''t connect to POP.';				 cr. (Delay forSeconds: 180) wait.				false])				ifTrue: 					[messageCount _ socket numMessages.					socket disconnectFromPOP.					lastConnectTime _ Time now].			socket _ nil]				forkAt: Processor userBackgroundPriority].	^ messageCount! !