'From Squeak2.9alpha of 13 June 2000 [latest update: #3059] on 1 December 2000 at 10:50:40 pm'!"Change Set:		MacVMSource2.9.6-JMMDate:			1 December 2000Author:			johnmci@smalltalkconsulting.comMac VM Source code for 2.9.6, includes sound support, plus embedded image support"!!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 12/1/2000 22:45'!macArchiveBinaryFile	"Answer the binary contents of a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be a folder containing the project files."	"To create the text for this method evaulate:		| in out |		in _ (FileStream oldFileNamed: 'projectArchive.sit') binary.		out _ WriteStream on: (String new: 100000).		out nextPutAll: '#('.		[in atEnd] whileFalse: [out nextPutAll: in next printString; space].		out skip: -1.		out nextPutAll: ')'.		in close.		ParagraphEditor clipboardTextPut: out contents asText	  and then do paste into this method."	^ #(83 116 117 102 102 73 116 32 40 99 41 49 57 57 55 45 49 57 57 56 32 65 108 97 100 100 105 110 32 83 121 115 116 101 109 115 44 32 73 110 99 46 44 32 104 116 116 112 58 47 47 119 119 119 46 97 108 97 100 100 105 110 115 121 115 46 99 111 109 47 83 116 117 102 102 73 116 47 13 10 26 0 5 16 0 0 114 250 0 0 0 114 0 8 0 0 0 114 148 6 0 43 0 5 1 24 2 0 0 0 0 0 0 0 165 165 165 165 1 0 0 61 0 0 172 94 103 33 181 100 42 6 0 0 0 0 0 0 13 31 0 0 0 0 0 13 218 2 0 0 7 218 0 0 2 139 0 0 0 0 15 0 77 121 80 108 117 103 105 110 46 112 114 111 106 0 1 186 192 77 77 80 82 67 87 73 69 1 0 4 47 0 245 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 27 0 0 9 179 0 0 0 0 15 0 66 193 212 194 19 180 140 109 220 205 78 57 63 90 66 84 57 156 71 10 240 179 194 234 180 76 49 136 61 86 193 33 87 165 51 39 174 141 114 32 57 229 43 22 87 128 72 84 38 117 129 4 182 215 234 186 97 240 130 6 7 168 37 149 122 3 125 3 195 87 185 151 254 22 251 249 238 210 167 130 219 121 155 186 134 229 95 75 152 58 93 250 123 38 106 43 222 218 75 149 20 150 219 56 44 81 228 23 54 251 165 214 237 251 0 192 205 43 113 64 228 181 201 133 51 84 209 66 37 59 176 144 234 4 186 142 81 128 228 2 55 216 158 134 41 177 194 7 95 252 212 255 73 83 237 231 200 33 245 234 99 190 79 33 76 97 115 253 35 55 46 42 13 118 116 73 161 215 249 23 162 74 26 161 34 208 52 177 148 31 2 225 128 147 212 218 175 235 77 215 179 45 41 42 83 138 73 222 20 4 247 49 227 152 237 224 96 210 249 218 162 93 24 168 187 8 67 87 106 36 240 23 14 253 32 32 233 250 182 103 110 104 23 208 218 230 121 74 225 57 124 53 128 60 111 91 170 168 211 245 68 13 214 181 216 230 12 119 31 218 154 171 103 239 30 230 22 188 226 29 238 162 224 59 253 70 31 56 103 224 36 245 159 238 139 104 201 201 132 39 227 128 0 62 234 60 136 63 255 195 11 172 202 17 37 216 84 146 63 219 54 56 151 166 38 241 106 221 197 103 27 237 182 165 6 183 114 101 218 141 240 64 148 45 222 37 21 103 254 127 46 56 173 37 215 210 155 156 143 214 184 249 118 238 209 196 193 63 132 149 152 85 92 181 13 27 221 176 225 145 152 79 7 62 97 181 120 39 91 165 74 115 184 46 199 3 192 153 218 145 229 140 225 48 115 235 24 105 61 157 168 6 39 4 200 157 182 175 112 130 106 48 11 175 17 0 192 51 97 61 92 231 192 128 4 202 158 82 84 178 6 244 58 194 143 198 197 84 245 194 178 69 38 193 153 99 228 73 197 137 51 95 234 74 220 141 111 161 135 191 121 33 201 254 51 7 28 164 179 195 57 17 73 210 193 161 123 149 11 73 41 75 25 196 86 100 212 137 148 255 191 61 249 212 167 243 124 178 252 243 230 210 105 103 137 88 244 8 170 166 127 33 239 33 76 177 46 165 94 119 60 57 69 82 53 93 97 113 18 211 180 59 221 195 107 202 4 125 117 172 218 169 252 32 46 1 54 41 228 135 201 89 109 105 202 112 20 196 166 41 173 208 173 27 148 202 143 245 25 142 72 111 18 240 135 44 9 113 199 4 252 36 142 207 253 43 184 119 116 86 138 249 177 138 141 63 33 191 93 190 139 209 129 212 216 83 151 194 200 24 252 41 196 242 80 71 41 30 226 43 28 209 35 219 218 177 65 128 188 55 183 237 64 231 242 161 168 189 135 114 61 217 9 64 19 4 196 99 134 88 34 235 184 97 44 234 25 195 176 83 127 209 207 190 234 196 243 14 19 177 134 74 190 120 202 207 65 100 1 59 62 46 48 80 135 3 9 73 242 18 57 109 183 245 222 178 216 183 84 76 56 208 27 8 158 248 66 214 155 165 188 137 94 194 111 156 211 2 200 53 127 166 203 170 79 164 98 8 33 169 242 184 152 189 171 140 226 112 193 38 34 179 149 178 39 37 88 11 56 158 240 172 153 69 71 107 203 187 140 154 176 235 8 151 194 172 241 194 59 173 162 204 166 181 114 97 224 92 71 116 144 235 121 221 159 124 218 189 170 239 83 135 28 243 178 223 131 227 17 146 169 220 93 31 64 246 60 114 194 162 48 94 192 255 37 210 128 223 90 148 255 167 134 204 96 230 126 180 73 114 139 161 17 171 76 130 56 199 160 130 180 229 165 79 185 10 128 134 241 79 80 147 118 89 165 116 61 94 67 177 61 154 226 10 230 26 219 235 251 35 12 194 40 38 35 252 251 191 11 198 3 254 127 229 204 232 61 105 255 53 135 108 128 24 78 193 229 23 109 141 167 141 113 72 6 184 7 83 149 143 141 161 13 193 130 105 121 159 72 83 255 218 246 207 168 2 188 251 220 106 202 121 24 137 85 236 151 184 191 38 29 12 123 142 42 244 196 40 124 66 26 203 78 220 166 73 142 150 63 166 17 119 99 243 166 176 210 220 215 118 253 59 143 35 122 222 50 58 29 51 211 19 174 220 236 227 198 71 227 70 156 97 25 76 78 210 252 109 98 200 134 0 148 114 221 154 66 23 196 248 37 253 225 184 18 33 116 236 252 67 236 135 114 205 157 120 160 155 132 133 60 83 40 206 205 65 122 27 3 244 137 119 158 91 42 59 189 57 230 202 3 71 214 181 17 91 237 71 219 25 87 69 187 54 79 222 40 229 9 229 71 160 174 72 187 107 25 142 156 159 128 201 103 230 130 228 230 37 21 220 76 245 164 173 70 236 120 248 32 0 235 8 226 156 150 195 159 49 115 251 27 199 242 115 185 77 140 190 205 244 7 223 191 94 162 200 1 170 101 82 196 36 62 145 104 149 184 123 177 153 15 220 14 50 253 40 5 192 198 227 129 195 234 3 23 1 199 104 182 67 51 17 31 177 252 147 96 76 24 221 202 12 236 136 115 123 75 165 115 55 2 242 194 9 252 13 250 160 95 132 217 253 162 222 168 205 117 26 224 163 41 136 164 32 42 40 60 7 24 87 230 249 31 58 236 150 135 184 249 22 205 31 97 180 112 137 182 250 89 4 221 38 113 74 247 168 206 215 112 54 174 17 124 134 22 229 141 40 117 220 60 36 142 159 28 196 12 79 250 234 136 200 220 192 151 253 59 63 143 176 44 197 118 7 251 9 88 225 69 165 197 229 146 92 13 230 142 60 188 7 204 81 241 42 116 68 128 100 171 169 163 137 188 9 17 212 4 231 195 226 170 216 196 24 94 172 65 211 52 75 97 206 167 143 24 61 168 230 229 31 239 42 70 74 67 179 96 52 199 96 80 117 42 122 92 36 146 138 21 213 65 96 75 175 232 31 107 43 33 91 231 154 123 5 24 28 139 122 138 127 91 147 185 79 21 150 196 39 242 145 196 148 195 22 235 187 30 46 175 109 249 30 33 44 231 138 19 255 207 171 119 184 201 171 190 52 6 187 143 13 176 206 38 141 52 54 14 234 19 13 72 228 115 134 239 231 78 161 68 240 39 189 238 92 137 134 220 92 228 98 165 0 223 127 16 233 228 150 150 183 157 213 170 18 108 187 193 244 40 94 214 27 214 103 133 11 23 106 140 153 150 249 216 192 173 245 226 15 71 223 152 10 15 241 34 209 142 177 116 19 237 153 115 235 149 33 51 8 136 185 42 26 124 13 143 64 6 191 151 249 2 34 136 141 198 23 227 78 45 51 175 180 143 131 177 93 122 47 116 190 243 99 42 32 159 106 87 251 223 159 179 37 63 143 200 173 119 171 27 79 79 149 2 209 224 156 255 224 213 5 208 114 14 166 128 135 141 222 107 146 148 60 212 87 95 249 62 108 29 151 193 171 48 111 202 218 27 135 180 253 254 184 223 129 63 91 60 123 221 98 165 199 70 36 4 155 209 197 95 213 90 27 172 67 75 182 52 134 225 138 50 128 100 245 153 1 73 95 228 92 254 186 19 225 208 85 38 151 24 215 131 149 191 230 74 57 107 248 227 229 111 209 108 16 211 152 104 163 251 128 215 147 85 150 15 43 134 83 159 42 239 54 28 40 73 52 207 84 129 239 98 214 179 21 102 137 178 110 247 152 202 120 33 245 91 121 128 234 177 58 4 101 109 183 205 222 157 164 79 7 109 210 19 253 233 66 110 212 180 156 55 124 37 83 157 36 52 71 108 27 185 118 84 11 222 1 186 180 176 54 75 2 134 10 200 41 247 243 115 198 166 236 142 190 189 239 126 125 106 88 219 213 89 86 112 164 28 237 40 73 163 214 41 167 51 226 144 185 109 128 31 24 46 11 81 151 124 82 134 29 127 35 25 190 38 212 98 223 126 203 32 60 74 103 251 72 156 19 78 206 72 239 13 5 249 184 234 54 28 128 245 0 249 90 69 3 123 98 160 210 186 41 73 17 3 28 112 129 216 217 199 108 97 59 3 225 73 152 69 217 146 229 62 27 45 119 23 226 20 9 145 94 46 115 121 134 233 179 133 155 94 199 108 100 28 131 175 206 140 90 173 14 18 76 19 202 83 159 22 214 223 144 183 119 149 129 120 70 181 99 68 133 35 149 192 17 182 40 216 129 186 185 222 109 72 135 219 119 115 196 249 44 150 83 58 212 26 210 154 53 109 49 36 39 146 188 84 202 107 117 165 30 161 103 160 138 30 154 85 67 10 214 221 117 225 102 176 143 120 211 187 176 196 245 60 28 179 165 154 167 22 55 97 242 45 252 235 170 218 20 43 72 243 201 54 123 101 20 33 48 168 180 233 60 232 203 7 66 56 124 146 214 112 254 140 37 96 243 38 179 116 69 25 227 129 70 166 160 195 95 119 149 251 212 214 138 62 183 247 149 85 11 116 61 189 17 187 149 100 21 248 121 103 245 72 14 36 248 191 128 103 91 132 118 39 131 121 52 247 206 93 47 82 113 11 31 148 91 121 169 110 211 31 34 248 177 165 90 108 123 99 171 35 104 32 238 176 63 65 30 99 58 169 225 58 211 237 4 229 142 123 59 108 223 136 197 220 218 91 179 0 121 93 76 67 65 204 151 161 33 65 74 212 79 82 70 71 34 30 120 110 193 0 36 170 193 44 45 143 228 131 205 150 244 160 150 106 22 65 152 121 20 125 25 104 52 133 104 165 184 88 121 83 121 93 99 250 114 15 118 56 143 178 96 88 189 162 5 211 244 73 153 40 207 205 71 138 167 60 186 201 213 118 68 181 199 75 78 195 34 132 17 127 183 98 72 65 22 255 140 196 232 205 157 2 110 42 175 37 4 30 101 25 242 48 107 25 105 159 30 213 210 157 118 121 51 157 187 180 131 3 44 5 185 15 215 79 162 2 26 65 168 188 175 126 122 46 117 97 63 225 223 18 22 211 203 44 218 82 158 29 119 110 57 91 14 143 66 109 2 240 56 94 247 35 47 101 146 49 98 29 193 204 226 150 16 203 189 11 251 203 208 29 186 250 218 53 107 74 41 140 45 140 4 31 27 113 69 36 188 128 46 81 132 34 77 101 50 169 28 156 133 164 129 253 215 241 194 174 172 194 42 220 190 205 227 223 125 42 185 109 222 61 100 144 193 147 66 193 232 72 220 164 225 179 24 189 206 106 11 94 84 43 63 244 25 229 114 152 79 232 252 147 54 43 138 6 104 248 81 78 162 136 226 36 206 113 106 248 66 115 193 28 216 164 130 112 222 54 251 213 143 169 214 127 195 37 79 48 191 31 239 222 47 54 197 188 194 74 4 90 50 70 38 100 59 49 223 218 178 37 231 49 12 152 217 227 91 99 20 154 159 152 122 106 149 86 103 187 70 156 1 251 186 172 207 166 67 51 147 24 159 0 66 193 212 209 173 202 54 121 186 247 106 241 139 248 136 144 151 199 247 80 188 144 101 75 21 223 57 158 220 219 236 232 23 100 202 212 173 34 206 147 90 245 218 205 94 143 37 178 123 245 10 207 222 177 255 205 243 59 2 92 205 14 246 210 227 42 114 60 115 43 247 225 110 54 179 180 171 8 226 94 227 206 84 12 108 245 165 220 186 62 202 190 198 31 48 221 104 253 145 8 22 239 235 157 224 89 115 154 66 225 233 26 132 65 101 103 113 198 133 195 218 235 163 15 66 48 130 138 254 104 191 21 132 73 188 3 18 49 233 212 33 173 203 85 255 167 237 129 60 173 232 204 54 14 112 18 11 20 121 253 133 205 30 128 169 42 1 114 138 184 35 247 111 197 232 255 8 125 197 39 27 123 188 217 183 113 101 115 55 200 76 41 136 182 194 36 115 226 46 180 223 15 180 184 199 127 207 175 183 18 108 253 224 68 225 189 230 145 197 113 58 99 64 169 236 231 55 89 138 194 172 139 126 15 235 114 7 190 146 185 206 38 26 160 116 201 4 85 157 75 151 138 219 4 150 5 192 67 120 123 231 151 29 125 34 237 37 125 175 14 219 63 40 148 37 198 227 142 220 5 165 190 80 20 226 226 188 106 110 189 68 213 83 144 111 161 33 212 140 77 52 244 117 247 254 247 134 221 112 95 223 125 162 95 247 113 127 148 138 20 251 103 234 125 73 19 94 81 44 249 114 11 173 196 15 63 229 13 115 251 195 11 98 206 183 202 33 193 89 219 11 110 155 116 53 252 253 48 32 153 170 120 19 185 239 38 248 134 53 99 79 234 178 251 112 68 87 151 119 91 159 228 132 234 207 90 233 251 86 23 140 87 198 204 228 239 33 97 205 23 105 57 191 169 94 234 175 182 54 157 209 165 39 1 23 153 99 4 83 250 118 150 110 225 141 205 108 23 85 157 117 151 134 213 237 178 162 80 51 220 165 2 220 8 167 35 52 225 141 195 156 254 21 76 95 231 237 249 231 199 223 249 56 16 105 49 246 179 86 86 199 222 103 162 50 165 41 77 133 132 4 246 90 221 161 237 175 20 1 224 5 208 134 151 85 245 81 241 166 113 128 176 170 18 208 148 167 107 165 84 201 247 77 110 178 243 212 76 28 185 151 25 3 254 91 135 233 7 181 194 191 189 100 178 100 20 92 126 239 85 113 127 203 20 251 252 161 1 63 35 197 97 30 51 62 136 236 104 162 216 84 86 49 130 181 92 215 169 183 20 181 106 88 75 233 118 139 43 234 2 58 27 15 194 152 140 103 217 39 100 170 4 96 201 205 75 153 189 203 211 117 177 25 176 204 93 16 68 7 53 84 183 210 189 91 68 187 188 136 34 168 145 152 249 26 42 26 225 31 239 15 249 137 120 247 29 172 107 103 137 180 207 217 121 27 149 32 90 137 141 176 165 165 165 165 1 0 0 64 0 0 172 94 103 33 181 100 23 240 0 0 0 114 0 0 25 110 0 0 0 0 0 16 49 217 0 0 7 90 0 0 2 148 0 0 0 0 15 0 77 121 80 108 117 103 105 110 54 56 75 46 112 114 111 106 0 1 220 45 77 77 80 82 67 87 73 69 1 0 4 110 0 1 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 37 135 0 0 9 73 0 0 0 0 15 0 66 193 212 169 9 210 149 55 104 18 166 123 198 254 115 231 189 56 26 63 233 107 89 215 26 41 64 39 168 254 239 247 106 245 213 179 37 162 85 150 47 25 75 142 73 147 42 103 39 18 89 87 185 158 183 144 191 121 197 58 247 237 47 168 4 250 221 80 196 140 250 2 153 82 24 7 101 152 165 56 154 236 133 124 32 161 65 134 202 240 234 38 74 220 207 29 183 187 78 143 128 78 228 25 224 83 50 226 241 200 15 193 111 178 15 246 78 206 228 147 246 197 203 10 10 242 105 41 4 66 205 9 1 225 252 22 138 140 209 6 181 240 179 154 27 24 6 94 118 33 215 71 251 65 6 46 194 156 224 245 152 248 245 163 117 106 184 81 55 44 43 63 12 15 131 173 177 63 58 108 90 116 237 57 130 18 45 207 39 168 184 124 14 234 151 77 158 24 238 174 149 45 154 30 127 131 200 231 47 199 96 208 217 78 147 104 4 219 175 174 33 142 236 210 130 219 100 211 116 254 15 231 119 8 95 0 178 98 122 210 142 229 104 67 70 12 175 141 92 58 110 110 125 213 36 115 84 117 144 245 75 148 181 55 130 172 219 99 192 169 188 102 174 245 3 98 201 249 187 198 155 60 173 205 234 41 227 58 211 109 39 124 98 234 206 156 15 73 86 25 233 109 125 254 184 178 214 178 133 136 246 117 48 173 55 248 26 8 190 78 97 200 67 23 26 223 148 9 135 229 250 93 43 221 207 238 48 11 146 126 167 202 57 129 122 208 16 68 11 171 85 193 55 197 75 206 6 101 225 159 104 37 53 24 149 113 98 108 118 35 180 159 124 25 241 188 82 51 147 186 228 19 144 214 103 241 33 199 95 1 89 148 121 49 217 177 30 75 206 83 68 131 49 235 210 72 87 124 132 117 54 28 248 36 131 82 144 238 147 41 18 75 146 21 97 35 176 24 27 156 45 171 65 232 213 217 183 86 97 199 127 122 105 229 192 146 21 171 163 104 83 164 85 85 159 97 16 133 250 117 123 35 109 109 221 183 95 120 25 237 167 23 213 43 6 178 186 44 154 201 162 86 26 136 87 11 90 163 230 224 102 104 162 19 246 228 233 218 91 12 199 141 183 74 205 224 12 153 150 177 85 0 41 202 28 63 57 160 34 129 152 15 10 240 140 213 45 91 151 230 63 252 32 81 62 58 251 113 147 52 74 212 214 30 114 32 135 185 204 7 224 181 26 172 91 169 81 65 140 201 52 185 195 170 193 233 103 214 112 109 65 219 94 83 253 182 167 152 47 211 90 104 203 34 241 216 55 162 73 128 24 254 18 243 43 51 199 224 93 181 216 4 195 100 21 1 142 111 89 99 181 120 228 69 89 150 166 67 160 133 83 74 25 120 228 202 151 213 197 238 169 7 25 75 215 132 139 13 128 148 42 185 174 244 128 76 188 161 166 164 16 51 147 115 251 235 205 105 232 86 142 76 237 244 167 29 43 177 248 156 194 246 97 15 7 255 213 141 41 156 105 175 207 13 3 192 68 119 2 85 97 230 126 53 40 79 97 45 221 168 205 66 34 36 28 180 173 22 22 180 51 194 56 193 255 243 75 101 57 141 155 154 6 150 42 8 180 204 128 177 95 60 122 220 131 125 225 225 49 227 224 60 187 72 148 80 225 109 173 250 161 103 80 190 248 119 106 225 182 172 156 189 14 39 39 172 51 134 119 87 74 119 174 13 184 80 179 206 211 203 197 4 98 108 88 244 9 167 90 0 179 111 74 175 93 37 151 71 255 226 242 57 3 70 223 10 238 143 109 72 108 218 5 38 140 97 70 133 196 185 229 124 137 190 203 76 81 53 60 4 82 244 201 125 216 66 13 237 218 214 208 120 143 242 251 23 135 220 72 32 82 237 68 189 70 62 224 254 70 62 224 229 134 119 188 130 31 152 255 212 226 149 189 221 60 223 148 73 202 157 18 249 54 56 126 101 207 255 58 91 68 133 67 118 98 230 235 242 45 38 75 183 17 235 204 212 204 222 45 249 140 101 163 86 59 125 195 111 43 228 127 205 120 199 85 241 203 115 36 38 114 138 200 134 12 65 52 23 170 58 186 89 15 23 144 208 141 125 252 131 154 213 103 133 164 20 24 181 20 212 220 255 114 55 158 205 47 147 146 107 120 61 236 170 84 104 212 61 32 201 252 208 92 120 214 182 30 6 28 5 1 22 67 109 244 114 222 27 168 58 178 108 199 187 12 57 225 72 255 253 245 130 250 31 222 250 246 10 101 46 52 182 55 251 253 245 81 49 245 105 93 45 82 221 74 249 125 1 22 82 12 24 109 64 86 153 199 117 92 85 16 118 131 199 159 35 198 115 25 194 53 204 76 60 91 61 99 94 137 235 45 223 47 205 83 53 161 9 165 132 157 86 145 51 163 200 190 148 205 153 118 167 140 3 86 133 127 81 179 26 56 173 105 221 157 174 25 29 252 191 134 231 205 247 66 63 40 168 20 174 40 253 99 88 50 93 57 46 77 42 38 230 44 152 237 96 246 158 174 127 80 223 21 171 208 218 64 83 60 6 39 178 161 246 16 149 28 35 238 182 210 44 48 166 87 16 17 60 128 20 135 242 84 199 79 197 192 216 159 45 88 172 97 28 155 254 95 247 229 19 84 119 64 208 127 23 119 239 50 27 133 55 86 37 222 63 40 63 237 92 219 43 139 185 171 144 78 174 41 45 134 33 179 81 222 241 244 47 230 107 206 53 93 206 223 25 220 198 187 145 188 22 208 189 21 158 201 29 156 207 162 236 106 151 65 58 250 220 39 200 228 244 143 101 56 32 72 194 32 92 161 170 95 226 91 247 74 68 91 243 111 13 53 30 159 155 43 194 142 72 76 100 240 231 155 202 2 170 87 103 101 137 13 158 138 204 152 21 128 163 227 158 239 113 74 203 205 138 28 253 172 176 47 237 128 246 167 129 252 181 12 189 44 9 25 249 55 100 198 20 247 11 221 58 43 244 154 235 66 177 195 182 215 227 81 34 233 12 208 171 215 60 228 237 247 68 237 254 101 72 11 189 214 132 0 237 192 83 247 146 44 29 115 128 161 61 99 89 134 224 142 199 58 193 76 75 167 233 190 242 240 211 62 140 149 132 19 231 30 187 11 119 216 16 130 123 220 109 76 105 8 8 51 177 93 127 176 168 236 224 185 239 147 241 252 89 235 117 89 232 240 134 105 5 97 209 251 211 122 163 130 146 101 27 0 163 26 227 99 143 189 100 252 184 92 204 15 249 41 66 137 162 186 236 108 107 110 37 6 27 122 43 43 183 9 177 188 52 107 174 190 52 142 8 234 72 246 140 207 86 16 62 58 111 246 174 164 206 167 225 25 226 156 194 36 44 43 216 74 52 246 175 115 93 50 77 141 193 52 62 121 123 202 32 231 159 172 154 127 94 71 139 59 99 60 95 93 5 219 230 131 152 119 71 166 108 172 186 159 236 122 151 241 89 190 225 248 70 6 59 222 41 63 1 165 51 242 86 140 13 190 182 4 62 76 202 29 142 235 136 247 213 221 89 87 129 198 64 125 243 139 125 99 248 77 77 161 154 149 206 132 228 19 219 21 20 117 100 106 17 25 129 82 47 223 238 149 91 209 180 62 152 199 225 74 120 88 182 193 105 50 55 18 249 249 177 21 79 110 42 239 129 88 200 29 133 34 98 15 45 175 191 221 140 248 216 149 245 89 166 178 80 182 78 190 69 50 222 205 239 161 190 224 7 58 209 212 252 3 217 253 195 183 64 52 49 155 161 91 219 253 14 98 134 170 152 67 190 151 34 0 244 30 29 40 140 166 74 48 227 156 179 126 37 235 250 104 255 27 136 65 183 130 244 43 240 35 123 226 134 15 235 124 3 209 133 214 35 208 2 203 15 238 71 79 163 249 77 38 232 160 127 174 99 90 151 104 248 47 21 102 40 10 75 7 38 213 12 191 187 208 175 51 104 120 67 247 117 94 241 128 200 6 166 210 115 55 169 169 217 14 21 75 98 182 140 181 241 103 66 242 210 58 92 215 100 223 168 223 224 23 185 68 213 123 36 81 24 49 168 209 69 245 79 245 26 172 28 132 233 201 18 122 188 2 206 212 185 33 163 205 123 122 253 31 107 244 225 171 154 126 238 192 76 97 3 130 6 136 89 106 53 55 117 226 25 20 196 35 147 112 210 205 162 106 50 158 32 159 46 222 213 182 51 197 240 80 51 244 161 110 150 205 10 210 29 211 191 134 8 62 165 173 11 212 161 149 21 59 192 148 10 206 136 162 153 70 254 239 231 184 38 59 63 15 77 159 36 158 37 220 110 219 185 101 189 130 102 113 59 89 8 251 111 16 111 199 206 9 183 37 71 67 15 254 146 122 128 22 246 172 83 255 83 89 0 246 254 92 199 238 49 177 50 56 60 7 47 70 50 98 209 93 12 210 64 75 186 162 82 59 16 42 28 252 150 217 13 179 131 109 44 168 155 109 124 107 172 34 39 56 93 136 156 226 51 195 139 240 86 22 205 163 244 246 122 13 115 134 172 202 203 8 83 178 251 160 6 219 89 67 181 18 209 214 63 231 59 24 227 158 23 7 240 58 71 177 7 113 158 183 64 244 85 7 107 227 60 68 82 254 89 181 121 244 154 127 239 164 100 253 201 24 40 247 95 2 117 74 39 105 8 93 65 60 200 39 164 174 113 104 28 234 29 2 248 240 139 89 240 62 145 199 95 144 239 95 112 133 161 248 7 69 77 160 179 10 214 118 130 47 36 196 113 185 107 12 184 128 166 184 156 240 64 39 22 137 148 42 166 209 186 106 148 29 222 181 182 12 140 98 107 232 202 192 126 214 67 12 90 3 7 248 95 36 76 59 188 66 63 98 47 55 72 103 196 189 55 155 89 36 43 7 171 26 228 14 129 26 180 143 57 83 243 131 55 10 86 141 23 182 84 53 42 118 71 72 221 140 17 103 43 14 243 168 38 236 161 104 222 196 131 99 100 2 95 182 238 89 158 129 168 152 135 33 197 190 201 123 56 211 17 219 71 63 164 17 28 210 229 135 70 215 21 37 111 40 118 238 71 231 185 92 225 238 138 15 196 191 125 76 175 41 229 73 155 45 56 91 234 166 249 104 4 179 127 38 179 30 101 157 148 54 199 109 249 21 239 65 56 118 173 182 77 172 225 67 185 168 180 146 85 179 50 125 131 216 129 42 197 47 124 221 171 199 98 155 4 245 181 64 165 225 148 159 88 65 126 225 27 188 72 65 126 66 80 88 14 250 23 35 36 212 224 92 173 32 66 193 212 120 244 150 156 45 75 143 253 186 160 103 148 110 138 210 209 163 125 11 126 208 172 225 255 129 97 133 7 117 173 34 14 198 74 241 119 114 179 69 78 241 172 212 89 124 91 120 8 205 235 82 98 142 194 32 245 179 201 44 162 110 214 68 254 158 4 147 19 254 191 118 156 232 12 254 184 209 40 217 121 173 182 158 0 168 203 19 227 183 248 42 166 119 134 20 184 72 174 2 197 58 133 29 213 233 74 101 1 85 71 25 150 55 32 225 207 234 168 1 132 48 188 104 84 53 145 212 222 88 12 164 128 218 29 207 78 77 249 16 88 28 232 164 142 192 159 5 8 135 38 217 75 132 1 169 131 180 254 194 85 160 186 146 180 24 82 91 133 163 169 12 134 152 70 138 133 74 186 173 245 88 137 116 233 235 3 118 28 107 126 133 54 54 53 235 170 9 149 65 194 190 72 136 43 247 87 106 245 14 28 216 174 131 61 75 2 32 48 18 90 42 185 42 139 107 94 143 236 239 204 214 131 5 194 198 84 239 253 129 60 182 156 134 15 194 224 152 87 64 148 238 6 49 222 188 124 178 199 34 127 212 174 139 147 19 174 19 177 25 35 173 239 20 162 133 142 35 21 226 49 117 215 117 82 150 137 206 32 224 106 132 88 229 130 225 121 252 199 118 93 193 14 161 171 76 13 36 30 78 89 226 51 243 117 178 220 71 194 253 155 147 117 169 112 214 170 151 80 176 47 113 137 200 71 128 223 66 205 149 141 14 174 254 215 224 212 209 129 71 42 114 80 117 179 6 107 207 86 126 92 5 186 201 125 182 1 242 50 66 210 232 200 192 245 137 242 31 142 235 147 161 97 3 161 124 80 122 86 211 86 19 222 78 188 48 94 226 5 28 139 115 71 189 71 214 76 63 3 208 118 242 103 42 218 166 31 193 172 90 1 221 207 45 41 132 69 109 253 53 20 18 46 39 129 112 108 97 15 218 100 16 0 87 235 39 246 68 156 112 218 135 240 49 235 29 171 113 255 41 197 77 237 159 181 64 19 122 215 56 164 218 187 2 68 137 251 240 202 132 181 223 81 212 100 47 233 101 78 16 141 85 48 151 108 6 121 86 47 13 210 187 225 178 157 228 22 177 139 131 77 189 136 67 214 106 21 35 156 24 206 241 20 160 172 42 105 163 82 42 95 198 28 128 214 182 183 18 226 9 84 238 73 67 7 6 79 149 143 81 6 165 26 204 217 230 127 245 25 64 156 2 31 40 230 31 152 83 16 27 19 48 88 183 13 234 44 214 230 142 115 130 245 184 253 244 91 188 169 175 129 42 172 27 94 36 204 250 103 164 187 225 237 171 117 127 191 201 200 10 17 53 9 251 134 12 155 134 192 93 150 96 13 18 25 200 160 243 9 207 137 253 198 235 76 86 159 204 94 141 69 7 244 119 142 65 54 80 199 204 199 217 168 184 53 128 33 0 165 165 165 165 1 0 0 59 0 16 181 174 127 194 181 175 1 132 0 0 13 31 0 0 27 191 0 0 0 0 0 11 26 238 0 0 2 170 0 0 1 124 0 0 0 0 15 0 83 113 117 101 97 107 65 112 112 46 114 0 1 48 155 84 69 88 84 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 154 0 0 0 104 0 0 0 0 15 0 66 193 212 165 47 158 104 38 183 219 249 217 33 168 151 12 136 53 189 184 158 14 233 171 185 188 252 36 85 186 68 105 32 221 147 163 179 129 148 246 162 31 24 235 185 98 218 101 160 56 155 179 209 51 153 16 169 186 131 139 49 67 115 239 159 135 201 102 194 30 232 134 74 94 72 73 53 209 51 0 164 170 218 80 239 206 105 215 91 90 51 83 245 201 43 25 56 235 71 7 130 202 80 0 66 193 212 157 170 210 35 52 27 93 136 197 106 52 54 31 166 122 205 231 32 32 112 160 40 138 126 3 77 99 4 251 242 199 125 87 169 103 99 226 123 60 70 128 113 18 28 85 6 189 121 109 31 26 249 161 83 169 157 62 74 239 8 51 45 186 94 58 49 252 46 209 169 153 202 106 248 205 178 15 4 139 59 160 209 168 125 168 73 48 103 120 110 199 109 171 159 179 239 33 94 118 136 247 133 234 179 177 46 218 151 77 116 44 159 93 94 44 99 70 93 125 137 53 84 131 32 59 239 13 28 34 65 92 91 104 119 79 119 174 134 219 228 67 30 37 182 200 207 220 0 237 187 20 146 233 200 152 182 39 167 14 242 53 180 240 195 154 154 94 91 182 52 134 249 136 119 67 194 147 228 97 60 211 48 22 65 190 202 99 103 114 208 10 131 161 3 87 31 64 250 4 254 133 169 217 77 183 225 106 142 240 240 180 146 248 39 192 170 88 102 69 95 13 89 148 174 206 78 162 131 133 161 167 150 32 158 248 178 173 101 227 217 102 143 206 171 62 75 41 237 239 9 58 126 14 226 107 122 250 208 40 209 10 252 105 101 26 155 10 18 126 136 104 210 186 8 64 134 82 245 212 110 151 241 61 69 16 181 128 165 251 123 137 63 121 161 161 183 56 176 164 4 136 161 23 48 88 225 129 48 129 37 151 67 233 215 152 90 89 82 27 227 240 224 102 238 138 80 14 201 181 17 19 136 193 127 207 108 171 212 101 238 237 175 10 248 251 8 248 107 203 87 203 119 235 140 103 161 208 168 170 55 199 88 185 214 52 170 233 214 179 94 170 196 230 181 174 40 0 165 165 165 165 1 0 0 68 0 0 172 94 103 33 181 192 88 206 0 0 25 110 0 0 52 58 0 0 0 0 0 20 153 121 0 0 95 218 0 0 14 61 0 0 0 0 15 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 112 114 111 106 0 1 103 92 77 77 80 82 67 87 73 69 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 43 99 0 0 9 200 0 0 0 0 15 0 66 193 213 34 167 232 170 96 73 254 125 109 219 133 91 226 173 79 60 72 84 69 81 149 82 193 195 62 243 118 100 84 239 248 172 131 161 136 154 59 198 96 8 244 185 108 41 50 222 100 82 26 215 37 53 108 220 21 203 219 50 66 180 190 240 141 157 173 170 51 45 136 236 170 181 44 84 47 113 175 150 67 195 75 236 38 36 167 98 30 128 9 4 41 81 183 33 61 198 230 33 33 195 250 238 170 88 161 29 121 215 132 249 179 85 186 248 47 89 143 35 147 13 241 188 47 106 188 213 166 78 146 43 51 69 235 43 123 213 57 185 38 233 121 77 22 85 192 31 62 122 83 240 101 109 114 223 183 50 167 38 210 143 43 59 159 239 99 72 61 124 93 191 17 21 83 3 152 165 163 27 121 26 80 54 26 252 240 48 4 84 254 49 236 152 0 103 136 176 199 240 231 0 194 156 73 207 15 40 147 116 179 184 5 5 136 95 237 112 137 98 147 232 94 70 169 140 6 38 233 82 238 90 178 104 247 205 99 160 29 2 244 112 1 102 227 165 33 98 62 144 81 48 112 194 159 232 104 107 9 234 39 163 254 174 8 179 133 36 15 64 6 127 201 175 184 95 26 128 250 3 254 214 205 44 226 99 194 21 234 107 90 77 26 63 72 211 192 220 142 63 104 189 115 120 208 168 6 20 59 32 49 42 156 170 101 144 121 106 2 6 248 154 32 163 150 233 170 134 166 28 209 215 205 3 25 81 239 109 122 95 124 97 23 247 91 178 236 59 254 102 182 86 238 105 102 201 185 89 42 29 235 233 127 96 56 84 85 170 216 13 61 54 236 10 174 146 165 113 230 253 188 205 13 160 113 165 217 127 153 113 145 3 81 155 44 85 123 48 191 148 49 61 113 83 28 196 245 22 152 167 135 24 210 146 195 155 64 50 69 230 199 214 97 69 98 22 167 2 7 61 68 222 242 25 237 175 203 226 122 144 173 149 129 72 126 105 119 160 153 101 226 214 106 226 164 129 176 215 112 221 78 69 152 245 75 166 51 20 51 94 133 150 157 123 112 129 194 53 100 194 125 123 241 192 205 208 243 18 63 160 206 168 132 79 71 253 76 89 221 100 213 42 225 139 183 137 94 174 83 19 147 113 99 133 59 62 216 64 182 144 131 214 164 151 238 16 75 240 56 4 3 194 72 101 70 155 58 114 37 71 113 205 90 148 234 228 253 91 181 193 210 197 186 107 39 157 180 87 72 45 153 204 109 187 145 107 217 38 219 248 164 171 146 117 141 43 3 105 255 126 119 16 102 203 167 63 148 44 32 214 73 202 7 111 121 175 193 163 185 101 66 137 200 21 225 76 192 228 15 124 219 249 221 50 204 210 144 224 107 121 231 51 174 29 32 1 24 22 233 26 90 61 246 36 93 169 151 177 160 222 171 223 198 204 121 12 254 228 102 158 174 158 60 207 115 92 255 234 192 73 250 14 63 97 204 177 209 67 137 2 92 155 69 72 73 106 32 144 187 92 150 178 223 187 214 208 180 8 134 236 156 93 168 142 15 184 65 222 195 116 76 148 64 134 244 240 116 207 171 233 133 234 180 228 244 83 195 166 244 191 127 224 183 237 240 221 61 42 239 234 246 81 217 79 17 126 234 252 215 240 252 68 247 147 209 132 101 0 102 72 133 23 214 229 252 119 27 130 211 103 142 159 198 238 246 86 229 235 108 226 71 22 224 70 236 26 110 142 61 33 6 218 50 186 146 104 251 177 98 66 156 38 82 60 80 231 227 52 31 89 147 105 121 183 88 2 254 69 76 66 227 65 236 223 60 217 12 98 12 19 104 147 45 196 11 240 191 107 162 239 211 166 44 41 249 39 37 63 131 158 97 247 131 129 244 22 112 218 137 123 26 15 243 2 182 190 153 209 112 8 135 78 189 236 94 158 54 199 68 222 176 75 80 118 44 130 210 38 124 197 161 122 197 40 223 224 186 158 200 128 140 152 136 210 37 103 180 217 56 77 18 191 65 83 243 71 174 176 56 156 55 186 91 193 189 72 99 194 241 223 83 16 18 36 127 111 244 32 116 144 212 11 152 136 20 25 71 73 141 81 48 132 238 222 101 79 109 211 6 94 240 82 117 99 67 1 158 172 228 182 48 42 250 91 145 204 104 115 51 24 2 235 209 127 112 71 109 172 75 167 216 207 47 118 227 119 254 51 22 159 247 168 93 42 138 74 227 79 143 50 129 172 150 126 149 88 29 57 40 39 155 51 217 207 188 37 166 138 104 87 180 47 247 57 71 98 69 164 178 190 179 15 236 99 230 33 120 112 14 117 178 125 170 196 51 249 210 32 70 222 9 192 150 12 116 148 255 37 212 77 222 201 196 51 191 234 89 33 236 189 101 14 124 148 160 149 221 45 103 7 22 10 193 2 228 76 34 36 20 29 5 141 248 124 47 6 159 53 130 140 66 124 100 130 251 89 227 179 247 81 101 146 156 137 197 215 142 213 63 237 98 34 232 170 15 43 117 149 33 108 109 17 54 51 16 50 44 2 34 122 22 164 103 189 10 38 71 187 83 159 162 62 46 245 228 103 212 102 180 202 7 163 106 252 104 98 47 227 140 130 195 68 252 232 227 17 111 112 180 119 186 253 143 246 189 114 125 173 4 142 73 116 112 240 253 154 94 10 22 98 155 32 98 52 250 134 13 164 13 250 243 153 77 233 17 89 170 177 62 205 50 107 249 213 254 119 54 110 201 2 66 120 6 72 18 241 126 66 4 53 68 160 231 107 171 202 144 220 176 103 66 217 82 82 198 51 124 239 193 203 28 202 168 180 143 253 110 106 202 216 204 124 170 170 134 250 206 148 180 130 105 7 212 153 173 74 14 138 49 205 172 243 7 239 116 117 52 67 227 155 135 50 207 18 183 1 78 221 99 35 155 64 166 27 145 7 134 169 166 186 139 30 195 144 225 72 240 97 115 199 74 17 15 212 44 103 26 48 41 242 15 105 219 134 238 188 233 232 20 11 91 88 254 65 86 161 147 173 111 156 248 34 122 142 162 88 82 252 62 124 49 86 32 49 241 111 189 76 248 145 251 15 194 36 35 218 174 121 252 64 170 226 77 111 29 50 236 224 177 241 185 255 219 186 172 136 213 222 154 48 237 168 101 222 205 180 92 47 220 253 189 241 32 200 243 128 30 58 250 11 252 8 203 216 76 202 167 20 34 181 123 219 129 193 40 197 197 210 75 139 151 188 42 41 127 7 90 139 69 214 4 72 107 7 112 65 182 1 239 74 239 51 173 169 166 130 95 25 4 3 183 225 64 100 47 243 225 242 24 109 201 75 96 182 28 87 112 94 111 24 18 74 202 69 46 71 222 230 176 94 154 169 221 58 60 208 251 1 199 26 238 60 250 63 35 143 164 195 118 102 26 246 178 104 121 21 132 106 90 238 183 214 166 7 129 38 26 24 161 214 93 46 167 114 235 51 84 139 165 108 221 95 254 251 204 149 172 30 42 138 143 218 222 230 61 126 132 156 186 75 0 193 131 148 163 22 243 69 109 202 235 200 67 69 241 76 65 94 144 147 126 133 55 212 204 107 220 44 235 205 19 254 9 248 98 225 208 149 165 223 6 51 120 195 149 186 131 239 72 174 207 27 204 102 201 171 45 68 92 4 76 199 184 96 176 177 5 144 28 240 12 207 211 135 147 179 50 12 234 125 29 194 157 151 86 235 143 195 236 225 73 109 168 86 167 106 97 112 133 105 4 252 186 207 134 211 73 3 162 110 134 96 204 0 243 82 152 0 39 134 196 55 172 181 168 171 234 161 89 155 63 233 141 144 114 83 212 58 241 128 45 212 8 31 238 245 143 225 247 59 2 114 227 60 153 162 91 228 131 154 117 60 208 209 129 119 131 243 132 26 91 189 99 112 51 115 140 190 79 96 231 231 42 168 189 10 40 35 101 218 21 238 249 99 69 71 43 92 41 233 98 9 183 204 140 47 155 121 197 204 27 52 38 0 184 189 1 80 212 206 164 8 4 105 184 116 254 165 76 151 50 180 144 40 14 78 109 44 46 18 156 161 162 46 248 14 57 178 96 71 87 210 247 225 51 204 42 71 144 255 10 49 68 88 60 33 218 87 35 85 166 236 3 93 156 130 121 41 50 6 47 76 4 88 154 243 127 160 118 8 39 27 69 130 201 211 215 204 171 5 42 182 80 125 87 73 253 8 248 76 114 89 25 126 228 185 105 83 174 81 25 67 128 13 193 121 182 27 140 240 93 235 42 117 238 100 15 168 212 5 11 252 113 215 196 140 32 127 69 82 203 103 117 199 108 170 121 159 120 194 230 1 202 20 79 79 146 18 171 140 88 90 23 158 150 31 69 99 196 240 245 161 35 65 171 81 80 67 174 134 79 191 177 52 247 188 169 163 188 158 170 20 230 84 197 27 148 212 122 204 156 46 202 243 128 71 81 154 3 216 49 164 36 74 64 252 145 2 71 64 173 35 220 27 114 224 97 175 86 133 68 210 184 214 59 239 149 213 28 106 2 250 14 15 2 178 236 34 212 149 18 247 151 15 113 248 88 180 45 32 238 115 186 167 173 159 254 150 72 85 21 26 142 39 52 92 160 72 25 71 236 166 154 18 95 171 223 49 118 165 14 157 250 1 174 233 101 178 138 165 195 68 236 169 115 0 27 7 118 131 24 248 96 95 130 158 153 178 178 67 17 11 81 181 123 110 241 196 62 203 69 185 46 93 247 49 87 16 231 0 210 223 112 219 34 230 28 83 98 1 112 4 251 145 237 209 187 179 152 228 78 162 166 107 166 82 102 164 153 167 122 206 87 54 156 168 231 152 204 172 142 90 169 111 121 71 62 194 28 126 194 19 5 110 49 225 70 135 91 221 194 210 237 201 33 177 123 252 64 190 50 162 245 161 163 48 56 188 69 137 31 117 107 28 51 145 58 82 87 109 172 229 116 20 134 19 204 182 61 118 243 236 190 49 238 253 251 53 61 16 212 101 8 215 165 64 123 203 83 168 95 48 64 209 235 197 213 186 206 123 7 104 152 214 78 36 192 226 235 176 135 179 55 227 220 182 208 109 194 184 126 193 218 39 152 187 203 125 249 182 124 155 110 132 54 134 238 247 130 248 192 251 81 222 71 14 212 169 243 105 94 13 213 255 78 164 23 16 75 150 25 235 84 154 34 87 251 212 195 53 236 106 25 73 128 140 57 6 148 248 205 213 12 143 228 113 19 235 5 77 72 51 126 79 218 10 0 1 121 41 34 18 29 67 89 221 67 50 90 121 69 17 163 184 29 180 230 17 143 172 200 69 31 144 224 203 81 189 177 99 86 115 36 198 59 133 191 147 154 206 213 33 211 160 80 201 180 183 34 241 132 245 7 103 81 244 205 231 207 239 192 37 249 138 46 4 27 50 106 215 153 252 38 7 208 27 53 164 77 189 113 48 205 87 135 42 23 170 37 252 217 147 234 177 5 141 10 247 162 152 128 128 21 161 121 109 166 103 96 236 9 248 125 64 91 175 238 188 244 21 163 162 203 40 188 44 76 255 24 229 68 168 155 17 46 224 154 17 150 78 213 144 0 66 193 212 210 108 229 211 185 50 163 125 227 237 145 120 79 89 27 32 142 106 58 64 12 158 0 71 68 58 113 24 81 4 16 174 92 12 198 221 223 102 6 169 131 127 129 105 197 82 81 89 229 183 209 64 139 197 242 244 108 83 157 79 54 254 251 225 61 167 216 21 215 226 105 101 225 7 161 178 76 212 124 148 181 135 120 125 154 179 190 245 216 203 187 235 99 129 241 55 117 94 47 175 195 176 55 212 221 184 84 161 142 233 245 56 147 38 138 58 77 201 191 102 6 157 232 64 228 225 105 104 219 244 66 175 84 250 238 210 215 212 237 18 185 240 27 19 92 65 103 153 5 83 116 120 255 198 73 132 46 195 161 140 200 161 156 139 69 55 142 122 174 8 99 198 217 92 9 207 80 24 176 179 188 78 192 168 237 112 183 118 200 87 45 153 111 8 223 87 10 36 21 141 245 241 158 17 52 70 16 189 190 197 187 19 167 51 4 214 137 38 214 46 73 105 207 42 146 109 217 132 252 171 239 241 211 219 202 29 115 86 61 184 177 92 239 59 53 62 207 200 24 181 70 176 38 98 212 77 77 237 27 167 187 17 85 1 239 132 45 224 186 10 242 62 209 134 108 106 248 190 17 205 167 1 199 154 8 102 146 47 110 235 249 113 53 116 4 209 187 97 115 123 119 111 231 234 232 233 92 221 133 131 113 255 185 187 221 152 111 126 54 18 83 97 246 168 179 65 89 157 3 199 108 172 31 200 6 228 177 8 192 6 122 78 249 9 79 175 199 12 161 22 85 212 99 214 21 219 154 136 244 248 163 152 218 23 5 242 129 115 67 31 10 186 120 60 58 105 88 93 196 115 101 200 103 42 150 19 195 104 56 30 230 167 133 60 21 110 186 168 12 51 203 198 14 119 109 60 183 141 59 203 181 114 53 174 148 81 178 69 175 56 89 195 110 42 145 176 191 85 248 60 178 173 103 214 104 125 214 141 223 178 32 58 152 73 198 1 71 8 132 152 113 93 30 240 145 200 143 3 233 99 212 165 130 12 138 15 23 78 120 158 172 105 218 177 246 23 180 88 25 39 231 236 77 130 13 220 144 95 97 208 216 158 81 152 40 199 212 225 51 3 80 10 67 20 214 252 183 35 153 64 27 164 20 48 120 177 95 167 68 33 149 229 7 155 241 77 229 39 138 14 219 237 228 102 122 128 122 21 179 248 223 110 159 88 219 59 8 209 58 194 150 102 90 129 77 23 198 139 56 46 163 119 251 178 122 239 214 169 119 167 77 77 65 4 105 160 110 217 239 132 155 84 120 97 13 109 75 14 32 98 205 175 37 191 174 27 87 55 172 121 201 153 245 18 8 127 148 227 29 241 63 95 201 126 250 13 32 215 159 15 69 21 159 218 204 183 173 196 54 168 77 139 46 103 4 73 227 51 127 238 153 141 118 186 62 5 24 53 202 125 158 243 68 203 38 151 0 222 24 134 182 32 155 43 247 22 123 165 247 34 212 226 121 134 197 165 189 69 223 27 170 34 207 174 64 23 135 158 197 242 154 232 5 207 99 131 169 94 202 161 155 195 56 110 221 65 228 142 168 236 189 238 108 162 27 15 24 1 118 170 123 220 25 211 234 169 102 64 58 1 102 103 45 63 170 193 201 212 138 93 6 28 189 41 21 150 225 119 61 22 26 227 44 60 65 76 200 1 123 4 155 150 88 64 34 90 236 28 229 84 179 126 194 230 28 21 10 94 133 178 158 182 195 43 135 241 4 233 36 255 131 180 177 92 49 165 17 73 29 52 30 30 80 229 78 53 99 175 237 90 12 73 26 219 45 58 118 214 173 237 4 150 45 142 83 229 221 215 121 41 189 202 218 145 185 179 237 10 160 215 216 179 32 221 135 222 65 197 164 11 68 209 128 156 166 94 235 211 165 170 140 151 210 51 198 12 191 151 125 52 227 227 28 74 87 58 15 232 202 247 183 10 132 172 214 136 123 92 206 216 55 32 120 160 65 81 180 244 25 205 138 137 167 42 110 212 104 140 22 211 146 144 122 191 56 21 213 54 226 158 102 44 71 228 189 218 29 222 32 0 239 91 45 236 142 136 188 130 4 239 229 110 192 16 17 28 94 90 195 99 217 178 206 100 87 224 85 25 42 88 246 167 111 23 12 202 13 171 98 8 199 181 162 27 32 254 18 115 79 252 146 65 41 224 46 118 112 71 1 58 173 199 173 235 206 240 244 222 70 228 187 15 180 155 172 115 4 220 47 100 218 97 238 193 81 43 48 187 181 143 199 203 55 210 111 61 252 250 100 218 57 6 197 87 137 16 6 159 237 197 44 44 193 104 31 217 158 12 252 238 151 133 95 2 47 23 67 96 71 11 154 75 127 160 213 141 41 5 115 129 42 81 229 82 143 121 155 187 46 82 46 132 7 143 81 37 98 2 168 71 202 182 162 162 157 226 163 78 129 76 27 221 106 61 105 133 147 58 2 111 141 15 219 75 196 106 238 105 74 1 136 76 39 208 172 93 30 89 7 92 72 172 253 43 123 85 116 252 129 236 157 108 13 125 214 181 254 18 248 121 57 125 151 147 165 254 126 55 184 23 227 128 50 30 45 98 242 77 19 89 120 38 153 97 118 186 206 111 231 126 244 158 48 38 223 164 151 250 247 254 152 86 245 92 20 209 214 97 44 133 80 1 85 17 66 6 222 47 165 44 190 49 242 254 255 190 103 148 29 135 125 54 184 224 174 177 231 214 44 63 165 158 102 92 250 113 120 139 2 186 225 141 8 154 193 122 96 165 59 221 220 103 162 194 102 206 97 10 207 157 226 50 70 70 81 129 24 113 160 25 145 246 184 66 56 38 29 47 4 163 253 218 16 71 29 182 238 252 252 231 160 216 103 109 144 163 19 245 202 61 19 53 255 58 175 38 18 70 180 46 72 231 238 66 255 79 68 64 63 51 16 37 247 138 54 116 45 35 182 248 224 20 94 10 46 180 241 47 178 52 70 136 236 90 102 86 79 106 100 21 4 158 100 172 95 0 97 1 61 64 117 17 231 151 169 131 215 12 221 159 145 182 153 15 18 8 75 23 92 82 9 236 148 49 88 181 193 178 29 244 83 153 128 116 74 136 158 149 92 71 204 159 172 173 20 235 95 209 11 45 57 55 70 78 109 210 93 166 164 95 207 107 214 240 231 125 249 76 245 2 230 216 245 201 224 217 243 5 29 10 36 187 193 86 183 152 69 136 60 63 84 7 158 180 224 162 237 69 120 85 92 35 227 179 49 149 91 57 199 112 192 138 22 234 195 201 85 223 210 199 36 112 72 129 143 131 132 243 235 89 68 129 129 215 93 144 29 0 28 161 109 143 9 245 179 238 181 65 132 89 183 104 59 155 37 174 223 78 73 24 226 212 234 128 110 122 41 209 224 150 242 167 197 245 73 14 253 194 105 150 76 214 234 30 176 202 46 213 65 48 194 251 243 9 111 114 45 171 175 0 193 226 163 203 192 242 101 77 20 128 73 27 41 39 223 237 6 97 61 84 91 158 231 169 79 210 251 225 188 96 167 127 69 1 161 145 191 232 148 175 164 167 41 155 204 164 159 125 128 169 151 32 197 137 63 81 185 201 67 87 132 63 216 106 254 201 244 202 247 144 246 31 150 117 69 162 191 191 70 204 98 35 135 25 63 105 24 53 55 236 135 147 84 95 52 103 74 140 76 165 102 94 62 51 23 13 70 55 230 118 115 174 12 132 110 181 21 224 123 28 5 87 109 226 102 235 72 142 172 226 189 212 153 218 1 13 246 223 95 214 119 195 232 200 203 247 17 117 12 43 40 240 67 244 80 178 83 71 136 129 56 182 208 247 83 115 253 221 133 64 14 129 242 59 184 57 141 243 192 179 224 178 127 56 7 196 116 246 32 97 183 235 248 46 174 237 66 236 16 45 71 87 3 154 123 106 127 165 146 0 66 112 31 239 110 20 89 22 15 44 162 45 231 86 252 4 168 14 83 171 180 249 83 224 103 33 89 197 187 206 134 7 246 109 99 69 1 32 127 66 247 56 38 27 48 197 103 195 132 27 166 241 210 66 227 89 237 43 183 63 87 209 135 237 156 250 60 95 195 209 93 37 166 230 132 252 182 192 9 216 49 139 160 2 53 10 51 76 154 102 183 132 97 223 210 175 135 247 252 137 40 79 202 215 230 148 128 124 90 46 210 230 144 218 181 63 32 245 139 83 207 98 217 90 22 251 182 220 90 222 189 197 179 196 17 114 208 138 12 156 49 61 50 214 22 113 94 197 115 102 85 120 136 128 19 232 237 4 88 131 210 92 163 212 183 139 70 133 176 20 20 115 176 30 217 119 201 204 188 81 61 208 14 123 60 23 93 62 28 152 167 71 181 227 10 168 235 171 57 30 151 131 185 70 81 151 87 242 130 145 148 174 133 166 33 147 103 252 50 138 248 111 215 142 1 35 189 84 95 66 104 237 166 39 88 131 33 200 142 48 244 30 148 243 53 16 56 245 140 221 24 184 114 241 44 87 113 81 8 231 80 226 79 102 186 205 122 125 207 89 137 139 47 226 122 112 46 186 51 246 141 224 233 136 44 150 189 160 133 94 7 50 206 145 46 79 245 119 37 5 90 78 156 30 234 102 187 122 177 41 144 200 65 11 220 85 11 22 81 32 231 155 192 3 11 193 167 214 187 81 94 75 53 3 2 243 189 106 204 15 140 190 240 52 60 27 170 36 243 197 190 207 139 135 117 237 45 83 216 228 19 246 197 185 63 204 126 210 206 193 164 102 34 134 194 97 28 175 229 130 22 59 146 36 137 177 70 140 143 40 20 218 153 14 216 56 31 153 122 232 18 16 234 108 196 97 208 148 151 59 165 200 79 110 10 120 138 114 197 108 171 110 229 95 226 234 45 76 120 203 38 237 23 196 30 40 150 28 110 102 110 108 89 148 79 242 115 255 249 51 96 62 210 236 144 70 45 221 139 156 214 18 5 59 187 129 190 184 89 38 197 231 170 89 244 234 186 31 229 46 146 0 109 118 220 72 112 122 103 220 121 51 218 177 184 52 68 213 158 231 224 127 86 96 170 133 44 50 55 66 193 198 20 105 121 98 8 231 4 228 209 113 231 54 69 63 101 245 220 240 222 140 62 162 195 60 239 204 84 149 32 71 162 40 145 198 64 17 240 173 4 135 192 159 190 111 221 183 91 27 160 237 25 93 91 128 230 96 12 14 72 175 23 33 123 232 175 21 207 173 5 67 200 73 152 149 83 110 47 166 72 144 164 48 78 174 51 253 83 246 5 111 16 241 187 55 86 250 214 50 226 186 67 168 153 66 121 23 189 229 119 13 223 215 168 213 67 242 86 18 214 171 201 184 178 153 187 165 220 172 65 111 4 192 207 173 93 245 121 9 181 139 50 245 20 239 226 128 132 216 116 136 162 47 218 231 101 81 173 163 191 85 77 15 80 192 47 119 164 154 85 98 199 35 243 74 239 199 66 221 16 47 195 51 88 229 160 228 108 6 69 191 167 113 207 18 71 96 75 225 86 150 111 219 101 117 66 92 162 201 19 19 164 142 90 129 83 9 108 226 144 166 93 250 90 186 43 210 131 210 188 136 224 114 164 214 107 230 103 169 214 47 106 43 3 205 97 155 241 236 200 99 226 135 59 6 157 7 53 58 193 90 116 51 20 136 232 58 99 29 237 103 232 153 224 195 79 6 129 54 246 177 106 89 21 185 45 102 212 48 224 198 79 3 67 45 102 185 42 26 27 128 0 250 52 62 137 165 100 200 72 159 168 245 235 87 16 102 213 217 117 69 200 119 220 64 72 165 219 243 132 163 97 184 249 27 191 98 153 240 138 6 223 186 220 76 13 229 188 64 234 203 116 115 9 69 115 107 226 106 179 16 169 171 73 145 188 201 110 54 44 149 242 17 151 98 44 20 247 253 203 206 241 175 19 184 75 38 119 71 245 229 64 43 10 50 132 247 219 180 153 61 93 117 108 71 29 57 157 144 75 213 31 5 138 175 172 135 178 199 47 98 100 149 188 14 64 52 221 206 156 136 138 75 56 177 30 178 158 129 41 51 142 194 123 224 144 51 83 145 141 200 146 88 117 247 233 242 117 101 181 145 154 173 67 173 143 25 156 82 45 69 112 7 220 89 73 2 34 115 97 15 126 137 83 91 2 153 96 227 85 147 223 63 187 185 107 166 88 24 139 238 9 197 152 38 48 185 204 158 148 206 185 59 224 91 251 249 90 167 59 54 237 125 96 249 130 97 70 191 90 183 34 228 6 223 43 81 226 226 76 231 58 173 172 18 190 250 183 247 149 112 227 113 149 236 38 55 109 229 41 192 160 160 32 193 0 165 251 188 180 98 106 216 200 160 108 228 52 182 141 185 82 23 186 150 87 246 234 3 221 120 175 165 114 247 51 80 185 223 143 182 88 25 41 133 38 38 171 202 74 237 146 101 99 78 208 98 83 210 44 105 225 114 117 228 236 130 78 20 222 41 174 100 51 149 5 209 122 232 69 58 115 254 85 239 26 22 137 91 237 177 157 27 67 23 19 203 144 150 30 94 92 167 104 179 123 154 70 199 13 148 63 135 100 195 14 177 185 136 253 198 114 130 66 115 146 167 140 104 111 219 234 99 60 159 173 230 151 251 80 95 105 116 195 29 221 27 13 31 99 185 225 56 133 236 241 161 159 99 48 75 131 248 162 70 212 198 190 56 145 173 9 156 252 107 13 43 143 204 179 251 85 29 106 113 124 120 42 240 45 43 248 167 128 110 180 192 91 163 110 44 126 146 157 253 98 76 42 150 85 173 117 81 229 214 162 133 88 123 156 216 78 230 134 218 250 39 179 65 238 55 212 183 232 19 189 53 187 178 247 28 235 19 79 121 249 147 130 143 71 239 234 199 23 60 210 1 36 150 68 215 235 137 243 201 126 143 38 7 235 188 153 212 209 193 50 105 97 192 58 202 65 2 130 196 76 46 54 218 127 205 146 217 45 251 254 55 76 180 180 89 32 48 36 130 96 111 25 32 67 222 131 55 73 86 168 157 146 194 172 175 117 121 112 167 28 167 244 108 115 137 182 224 181 4 62 104 195 5 109 87 177 53 212 206 29 228 232 20 187 188 254 137 41 105 239 98 145 176 192 82 149 97 209 172 29 93 122 155 157 133 139 103 86 149 215 77 0 98 141 234 13 154 202 48 81 197 182 90 124 42 229 36 44 242 106 60 158 50 163 141 87 223 230 184 200 211 97 254 24 192 231 199 152 162 234 156 109 16 88 33 222 195 19 135 66 2 82 251 82 55 175 0 132 99 199 34 165 132 61 138 162 229 88 37 116 144 118 157 16 157 59 181 16 132 98 145 95 160 77 26 115 103 250 242 28 195 81 55 155 209 35 220 244 235 38 5 241 128 174 252 224 251 225 177 185 188 84 240 22 121 11 72 98 195 245 33 49 27 197 160 54 69 120 200 35 246 220 111 49 32 222 143 156 192 184 231 113 78 6 1 73 110 149 7 215 154 48 6 249 196 81 45 163 85 138 190 101 176 195 187 28 211 165 43 234 219 34 41 138 213 54 42 105 227 10 200 157 1 5 123 90 175 97 216 129 205 103 137 168 28 72 204 251 217 209 42 167 93 151 203 240 51 96 176 39 186 6 125 77 224 23 155 193 82 95 177 38 18 219 84 242 221 16 236 221 78 149 119 186 12 68 34 176 144 238 187 93 155 226 237 165 226 193 8 49 39 161 62 110 111 53 158 12 95 43 200 151 106 71 143 174 75 27 2 175 48 190 188 49 30 95 116 85 125 14 143 141 159 226 194 245 84 191 89 70 39 173 6 41 177 39 19 209 220 240 58 48 123 124 119 7 159 34 22 189 71 67 75 19 228 79 248 124 31 112 6 9 103 12 74 94 249 95 220 106 167 126 22 39 37 80 116 245 73 166 59 251 58 221 190 129 231 77 52 170 140 31 87 156 66 13 150 107 206 210 135 19 14 250 60 229 95 192 82 254 144 171 179 247 140 178 104 123 116 56 17 36 12 76 115 179 206 34 125 53 126 234 180 152 222 14 177 138 199 0 174 79 111 42 192 31 82 157 249 173 32 217 107 238 38 69 240 19 165 166 232 151 82 142 24 165 165 165 165 1 0 0 62 0 0 172 94 90 110 181 192 83 165 0 0 27 191 0 0 74 39 0 0 0 0 0 14 34 54 0 0 87 188 0 0 12 167 0 0 0 0 15 0 83 113 117 101 97 107 54 56 75 46 112 114 111 106 0 1 161 103 77 77 80 82 67 87 73 69 1 0 0 0 1 233 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 42 61 0 0 8 214 0 0 0 0 15 0 66 193 212 177 152 127 146 222 243 33 86 175 90 50 8 89 67 135 137 27 141 183 161 206 42 22 96 87 116 152 233 42 230 166 223 93 16 6 173 110 181 222 55 15 183 81 106 64 84 85 160 125 218 100 35 39 25 39 155 84 32 38 58 140 69 8 21 146 69 1 191 80 0 201 126 125 46 66 83 22 20 130 143 170 158 63 106 140 213 92 209 255 135 216 159 84 99 38 148 146 107 157 136 129 110 237 72 101 148 131 63 192 78 85 109 81 50 24 101 40 56 111 173 14 205 235 213 3 133 142 139 114 241 203 123 254 58 185 51 2 27 48 37 153 96 209 175 238 195 126 222 65 173 21 29 98 248 206 60 216 203 5 186 73 219 168 119 207 161 113 94 190 25 51 139 204 212 164 34 245 135 95 247 177 89 209 27 77 68 0 114 87 89 133 253 149 81 148 65 243 35 66 243 110 6 52 113 77 148 239 180 7 50 82 101 26 204 48 217 149 125 164 129 157 244 29 151 52 60 126 49 90 159 229 54 202 101 245 206 193 50 84 135 81 82 100 145 234 215 136 203 133 45 176 76 224 80 244 244 173 206 12 207 6 81 163 207 31 88 57 18 55 165 124 147 130 64 197 116 90 222 158 59 48 52 215 224 53 120 25 95 221 249 251 67 77 98 168 2 27 65 2 238 87 196 69 14 90 244 83 197 232 144 5 174 26 205 221 163 142 95 46 209 104 66 143 121 34 164 244 187 84 132 47 210 55 220 108 157 46 143 116 47 30 219 141 27 211 204 204 195 213 3 133 192 155 236 120 26 238 11 206 184 123 159 126 130 26 105 198 86 34 236 106 174 241 147 247 239 180 150 134 67 115 92 233 6 198 53 12 253 113 156 46 77 193 24 135 51 238 247 75 61 237 121 249 243 164 174 124 224 119 204 52 49 253 52 19 221 243 48 23 71 25 42 22 96 98 48 239 251 226 164 105 154 90 43 96 74 136 255 45 80 186 74 71 116 36 145 25 47 245 42 233 145 174 158 52 177 211 229 98 60 208 239 203 21 37 124 152 77 192 13 153 139 87 217 119 72 165 238 218 187 209 202 147 47 81 85 214 251 234 72 178 172 121 14 140 58 81 62 50 189 26 2 249 128 63 118 163 16 194 181 99 236 173 44 56 73 73 133 224 180 170 115 214 115 248 62 229 50 42 175 243 16 152 37 0 115 108 72 212 92 124 106 204 180 224 193 90 110 210 25 27 52 91 23 74 169 8 27 247 211 45 85 133 132 228 133 147 94 42 205 187 139 94 141 64 6 37 161 68 154 60 22 99 135 94 249 61 146 137 121 49 183 13 129 208 8 146 110 93 248 117 36 160 225 156 145 121 254 150 108 214 78 71 67 162 217 210 130 110 149 214 242 190 45 176 193 197 139 141 93 201 61 68 158 243 234 78 36 204 133 90 204 173 80 29 190 2 74 107 18 163 210 245 2 26 126 230 164 222 139 35 19 90 137 87 151 168 240 194 20 239 25 232 126 32 229 34 25 83 85 86 201 195 46 117 233 177 193 171 240 199 75 138 137 40 104 162 91 24 108 42 69 110 77 119 11 111 102 154 147 231 134 65 107 234 57 255 60 63 175 128 22 235 179 251 26 30 159 51 32 205 195 146 242 53 74 214 181 70 161 89 99 71 30 183 228 45 73 217 121 159 66 154 71 75 178 149 212 222 47 224 45 141 179 173 105 184 136 249 82 179 248 13 33 13 122 193 72 225 20 113 155 200 14 116 120 106 7 92 41 203 147 234 94 109 159 144 45 110 227 65 60 38 121 79 233 250 128 89 1 232 40 40 22 202 90 192 186 58 161 211 131 190 161 75 60 208 235 1 156 52 85 235 103 144 76 53 99 25 4 178 114 57 153 89 172 18 177 102 186 60 255 108 255 128 124 113 44 108 228 216 52 244 12 239 76 124 91 58 220 107 5 56 210 70 224 153 20 75 179 45 79 216 208 190 50 16 112 122 200 98 85 173 128 166 54 121 147 80 125 45 82 32 155 244 49 61 133 153 117 115 41 9 36 82 20 226 111 143 198 244 182 222 88 60 225 63 5 226 149 116 184 144 167 105 205 158 35 132 166 199 54 142 91 6 44 10 24 201 117 32 111 116 70 225 95 248 163 80 208 198 67 214 59 218 134 249 253 151 166 19 155 188 170 179 205 215 156 68 146 113 125 16 43 192 112 157 155 119 73 48 167 103 119 77 151 14 222 168 146 185 130 234 6 1 125 151 95 22 203 138 211 170 200 28 70 129 169 82 83 38 32 21 17 193 37 80 207 189 1 232 82 248 169 50 14 13 174 52 150 49 16 152 156 188 208 119 162 221 141 177 54 116 199 234 189 177 190 170 25 238 164 236 219 92 80 210 70 106 15 91 192 136 51 233 176 179 151 227 43 202 52 16 185 107 1 93 93 1 150 183 91 137 85 71 100 111 142 242 150 215 34 253 219 90 128 24 3 52 86 121 93 88 44 206 137 148 70 181 123 153 10 29 239 143 233 34 232 246 90 214 217 73 209 89 129 195 98 162 10 255 204 166 104 50 125 104 15 126 253 135 96 174 84 142 188 0 127 232 133 189 170 162 39 31 120 102 21 197 102 185 32 214 135 69 53 86 43 209 97 149 52 182 40 9 175 26 87 172 113 118 232 228 28 62 101 98 186 76 211 108 105 152 100 16 123 107 79 115 84 52 32 14 71 172 101 148 112 2 150 230 8 57 23 165 222 82 3 128 81 28 176 108 37 97 90 128 86 119 169 196 12 165 126 137 196 183 136 86 157 149 17 223 7 37 1 53 76 12 234 96 108 92 1 163 21 66 138 131 152 91 197 108 177 71 94 54 255 212 225 129 186 105 110 141 19 227 83 123 135 139 8 240 100 22 97 119 148 73 50 165 31 9 16 240 162 92 180 209 142 117 74 192 251 28 160 210 24 11 31 208 21 52 97 46 230 165 71 243 141 117 163 72 197 163 240 104 4 192 165 208 81 41 50 3 83 151 255 197 9 166 177 28 175 165 1 214 131 14 220 121 31 69 213 215 253 191 174 220 207 31 111 174 164 208 127 75 79 82 211 205 21 69 29 120 37 214 124 3 231 148 98 174 152 138 124 248 155 243 38 211 71 230 4 31 31 11 66 121 190 134 117 72 134 111 110 130 8 24 112 177 209 44 179 86 238 139 46 23 193 206 115 156 120 161 238 252 102 122 189 88 148 93 176 88 133 91 110 179 173 154 2 32 93 178 153 64 82 62 34 48 100 130 100 223 133 211 113 183 191 241 228 108 147 79 78 5 102 206 61 37 221 74 168 6 7 230 124 189 191 225 112 169 142 30 97 121 194 149 33 142 166 250 168 22 250 125 110 253 134 166 165 120 193 224 31 79 41 206 20 187 97 90 212 109 255 69 178 30 68 228 121 243 17 20 3 75 95 209 10 74 68 245 223 21 202 180 79 224 12 253 233 250 226 91 26 5 56 89 192 137 59 44 98 153 34 236 152 210 44 126 111 110 230 14 155 64 240 171 108 142 243 120 22 239 138 169 87 199 111 142 170 187 193 14 90 209 227 111 115 55 68 72 212 186 63 55 34 211 56 203 208 9 238 180 250 194 48 239 242 15 168 59 138 115 189 179 21 140 242 118 211 7 212 179 209 251 132 32 69 174 15 218 121 235 161 92 80 210 34 173 213 220 243 7 176 61 0 47 218 186 251 123 207 252 93 42 254 130 125 210 143 1 7 184 182 124 36 88 161 25 48 136 236 99 159 96 176 7 84 112 110 181 179 5 192 236 116 19 137 96 42 222 82 252 233 129 78 86 142 215 175 126 100 81 17 170 118 12 177 240 122 19 184 106 50 41 131 233 138 208 32 118 234 89 251 255 154 189 62 177 92 223 211 39 239 124 42 152 72 27 93 118 163 243 230 238 96 174 230 244 179 120 71 153 116 155 66 213 155 189 187 177 81 120 237 73 12 202 204 99 228 207 252 228 199 10 234 30 84 14 58 241 211 86 201 103 251 213 196 248 130 3 60 67 146 172 210 122 223 35 171 229 92 185 125 83 123 251 3 198 81 147 140 227 247 16 244 73 231 176 21 44 90 23 41 76 222 54 166 33 217 237 68 225 142 77 31 40 148 183 55 126 172 225 228 202 23 152 244 253 116 147 202 152 13 65 47 55 39 76 44 130 211 107 70 201 135 161 8 85 185 17 76 61 219 98 169 93 155 3 252 180 95 141 3 102 136 49 116 61 60 221 139 194 244 101 243 71 116 251 48 215 182 80 108 214 156 178 137 201 103 217 143 131 193 160 112 27 109 109 105 12 151 31 246 64 148 32 214 202 158 113 228 251 184 134 40 99 150 28 205 96 224 41 15 238 128 62 81 179 9 152 137 146 105 243 201 19 32 75 200 3 116 156 247 105 154 214 210 209 236 170 205 203 125 30 22 51 244 45 97 173 107 145 214 27 7 107 205 84 142 87 96 197 155 132 28 255 48 4 255 139 118 220 15 166 170 90 28 137 181 166 225 93 186 191 51 100 40 26 198 141 244 53 18 152 172 252 247 84 220 213 24 141 131 235 134 27 253 181 134 153 0 182 70 195 38 101 155 245 69 163 20 35 5 71 254 160 204 89 253 232 253 233 53 87 120 191 225 237 181 192 201 86 165 85 168 29 20 153 156 213 195 246 188 61 35 232 102 44 221 31 91 96 232 37 243 11 140 141 4 238 246 149 187 195 8 49 240 125 199 97 65 120 22 200 102 181 14 197 45 139 61 123 131 168 186 208 168 126 54 207 237 118 77 125 213 54 8 255 185 229 203 202 97 114 173 37 65 196 57 46 238 31 143 143 36 23 202 37 14 102 2 117 216 55 39 83 93 63 181 220 206 119 11 209 126 255 148 144 149 58 236 198 221 190 156 15 160 214 72 3 198 122 182 38 13 63 41 226 119 84 170 104 242 106 54 114 33 225 207 58 75 237 237 252 125 62 89 118 181 207 80 111 227 148 0 223 218 159 220 93 40 134 184 129 177 151 205 176 166 90 208 2 241 128 60 0 66 193 212 216 191 219 184 241 11 253 181 9 81 160 233 115 36 244 172 68 140 78 110 150 75 207 21 69 167 173 40 179 48 7 172 215 128 45 180 54 88 237 245 31 155 42 17 134 148 46 82 231 168 100 45 110 137 233 26 169 221 15 61 7 37 170 10 253 91 47 101 1 7 246 181 106 157 109 255 248 150 43 35 32 186 230 167 250 157 1 237 16 148 206 225 131 103 45 51 219 184 144 19 208 148 37 222 210 175 170 141 65 225 196 99 95 160 120 89 220 121 152 247 54 49 105 177 175 8 123 216 11 2 9 182 10 121 7 121 185 97 23 128 30 207 9 6 32 15 17 108 80 130 196 164 53 135 253 128 118 127 84 210 1 226 50 233 243 207 59 110 231 71 107 194 186 238 210 152 37 102 210 8 5 128 152 124 231 140 133 162 151 22 188 138 132 251 90 17 234 50 118 203 193 228 3 101 19 149 70 25 24 114 217 250 206 254 173 148 247 183 206 65 242 61 123 155 69 45 174 84 232 185 33 58 28 214 132 190 234 148 77 169 27 37 55 129 115 119 70 173 201 95 130 160 195 254 244 165 255 165 98 62 115 46 241 172 2 245 85 46 88 183 241 104 162 38 153 210 61 172 7 68 219 155 64 166 107 196 230 39 92 77 72 181 143 33 253 173 118 197 111 230 225 1 53 50 66 185 228 127 216 161 161 36 64 36 166 61 232 46 52 152 14 121 66 31 249 44 137 171 107 178 34 208 227 236 169 227 14 131 227 243 188 61 167 5 201 99 234 37 227 174 27 48 209 125 197 124 14 40 155 182 226 106 129 145 105 133 5 55 88 50 33 202 30 100 71 68 122 87 30 229 131 3 111 25 101 158 3 26 61 40 87 175 63 127 111 225 17 82 184 202 213 193 200 173 82 102 208 199 107 97 41 252 139 68 121 92 82 235 25 97 208 190 61 209 230 79 62 97 158 96 18 179 30 105 46 140 158 43 55 231 141 120 48 42 177 24 192 209 88 22 26 231 76 136 9 57 28 241 246 178 7 64 251 105 113 52 42 189 22 177 3 254 122 132 178 230 194 24 72 201 52 93 77 19 14 55 254 122 168 87 148 191 183 146 94 21 52 93 135 94 163 73 193 3 24 98 179 130 232 240 159 14 208 105 41 36 2 99 93 178 230 182 160 96 188 50 100 43 141 26 40 13 78 212 43 11 83 228 126 31 166 95 170 204 77 250 114 253 65 218 123 98 49 164 122 170 220 252 111 240 250 38 191 63 130 166 195 209 135 158 161 176 238 19 55 104 29 92 205 35 215 22 169 212 198 186 183 168 233 184 251 8 130 177 159 239 20 43 164 73 202 43 187 53 76 200 56 7 224 100 60 73 42 112 10 4 239 114 25 72 131 46 236 69 41 207 246 175 19 154 152 52 70 51 151 81 159 123 94 201 251 67 45 6 221 225 4 251 161 145 13 210 121 249 237 190 145 240 32 139 38 196 218 119 208 196 69 157 129 82 42 98 25 24 61 10 31 188 59 220 12 157 225 16 247 183 208 199 215 54 195 233 67 218 35 233 123 225 45 204 142 252 27 149 121 239 144 90 212 194 199 222 47 51 124 144 33 63 182 252 209 154 141 179 27 47 61 145 99 98 73 77 171 116 201 16 12 87 214 74 250 174 5 209 82 5 229 58 35 5 1 182 17 119 250 126 76 5 245 108 121 119 29 211 112 195 128 124 202 211 84 167 180 218 201 206 227 237 233 139 177 39 21 192 190 80 254 207 200 172 45 3 179 33 148 64 245 154 8 82 20 2 23 4 35 87 4 232 92 201 77 252 180 252 243 204 139 166 147 222 167 115 184 137 67 155 163 246 76 255 152 222 204 71 36 113 61 195 8 128 11 23 80 173 27 59 56 244 125 137 193 55 36 84 81 157 96 109 179 33 192 242 197 113 223 119 196 96 54 159 143 25 152 56 43 33 184 151 187 41 77 177 180 99 71 137 49 196 6 229 36 247 217 24 99 195 132 120 123 88 61 189 154 40 186 154 90 17 31 210 114 229 123 187 7 235 74 112 59 185 61 12 118 104 215 180 87 216 28 63 243 138 185 131 105 30 83 46 60 152 91 133 29 202 189 173 106 103 136 232 249 107 69 27 25 243 26 157 118 154 40 198 87 193 211 57 137 183 19 11 38 67 105 255 107 98 8 178 154 191 153 119 112 54 98 181 201 116 167 46 41 128 248 62 91 67 201 134 17 56 156 233 232 140 202 162 138 162 183 249 47 224 120 54 60 251 166 236 122 216 87 152 176 75 243 253 247 208 135 132 75 111 20 163 104 234 7 190 19 112 36 94 43 152 60 65 9 127 183 90 170 113 75 119 81 169 198 244 182 244 10 92 103 25 206 89 12 147 209 59 67 35 41 91 70 185 54 92 158 168 234 138 21 254 43 84 243 140 29 224 198 185 152 74 14 102 5 215 200 118 50 86 101 238 19 124 130 173 249 38 76 37 77 229 118 109 47 242 108 181 237 99 251 126 191 15 41 179 141 159 15 170 82 68 253 47 197 133 25 26 18 249 131 34 35 122 203 200 11 248 77 167 52 84 172 200 105 243 48 169 55 189 20 216 135 214 30 122 237 21 73 83 5 192 48 94 152 84 185 6 50 32 132 116 61 141 94 50 110 183 126 97 107 15 239 220 46 231 158 7 122 157 45 177 56 186 18 60 132 87 168 61 20 198 121 144 31 96 138 12 160 172 61 39 1 241 86 101 95 1 17 238 16 55 35 245 12 148 65 14 80 102 152 151 134 238 186 91 231 63 25 4 89 163 120 44 216 107 229 217 210 175 94 64 169 170 255 35 174 110 199 149 167 111 95 167 78 97 187 103 183 90 222 141 89 3 164 102 222 230 137 121 202 154 69 184 200 116 6 151 69 182 24 211 122 210 108 85 207 201 63 182 12 148 53 110 150 25 204 187 114 242 198 151 167 187 103 20 170 53 12 52 192 190 185 43 199 152 170 208 64 73 11 36 192 237 157 62 50 104 232 84 84 185 24 198 45 170 219 173 173 241 209 94 237 231 114 188 197 115 181 212 195 152 16 48 155 110 61 42 188 8 66 131 247 231 70 11 16 132 108 110 105 200 243 4 95 50 143 90 90 168 30 56 178 183 211 30 240 206 22 199 56 134 68 203 61 222 19 213 235 204 77 230 135 147 59 82 42 109 167 220 65 67 90 47 198 58 188 77 191 203 4 45 14 148 4 16 92 216 106 118 168 167 120 23 228 151 41 237 94 238 211 2 80 175 106 107 237 187 193 250 181 187 246 63 134 41 35 24 103 59 71 60 80 143 215 197 133 71 132 255 191 181 188 171 122 225 177 147 53 123 118 229 246 56 137 176 190 109 153 40 127 102 228 192 215 40 155 166 173 237 180 160 98 39 204 29 173 119 34 242 211 121 78 126 12 39 229 127 13 208 245 152 227 133 29 252 188 187 63 129 158 209 176 216 28 185 140 85 177 7 112 237 204 91 75 52 124 51 222 69 57 179 45 155 65 127 247 184 154 3 151 30 71 190 49 106 82 124 234 240 252 50 145 113 85 18 37 4 228 181 103 239 7 47 60 189 24 194 58 127 20 14 102 84 177 161 150 18 20 159 116 10 141 222 57 175 198 227 244 247 162 25 217 20 230 237 8 191 212 194 36 223 85 97 213 62 17 158 141 230 228 219 239 254 146 221 68 111 196 115 90 123 55 140 222 234 35 224 255 95 3 138 235 16 150 112 222 6 180 47 60 102 4 152 66 76 25 76 100 245 14 247 227 188 53 13 232 255 181 223 60 175 16 21 73 229 96 136 50 134 153 250 97 207 157 15 169 101 200 187 168 56 62 130 222 136 231 118 95 125 81 204 2 244 102 221 115 38 148 165 153 238 87 93 124 184 226 83 195 222 232 97 99 105 231 31 204 39 84 230 91 37 235 41 197 12 3 91 217 194 30 62 150 135 69 78 65 154 90 170 177 26 92 149 59 112 5 173 199 24 25 239 137 230 84 121 55 191 130 1 196 255 230 39 72 92 90 27 14 47 229 242 48 24 28 16 101 115 104 65 210 6 249 187 102 203 130 84 14 107 53 76 77 252 151 85 20 91 163 13 71 115 166 22 163 94 108 252 226 193 236 42 202 54 236 17 106 217 113 211 205 198 121 107 166 58 94 181 144 197 179 88 253 179 53 59 143 243 161 109 39 37 230 50 55 72 104 243 224 234 85 195 178 96 176 120 249 6 48 148 110 30 52 108 114 96 33 151 10 108 133 17 135 32 100 170 97 87 181 78 198 102 72 255 108 251 148 24 52 36 47 5 40 59 63 107 90 215 245 170 6 59 234 186 232 121 98 91 211 116 22 162 227 227 190 222 147 207 168 226 5 125 184 50 87 217 226 208 66 195 124 86 89 37 91 214 80 229 71 4 151 108 152 11 218 90 16 195 35 239 42 87 41 5 171 125 161 226 37 103 169 38 161 7 186 1 210 110 184 80 8 57 126 31 123 22 133 226 151 214 177 58 93 71 122 59 133 25 204 99 253 246 6 132 238 115 247 160 201 202 198 15 255 143 159 58 38 225 73 119 189 141 22 26 95 30 246 110 245 253 45 2 129 248 93 191 57 93 160 10 149 25 82 249 218 131 4 51 94 59 51 114 223 45 21 44 93 23 36 198 25 172 5 48 169 20 67 96 139 21 8 108 227 181 106 197 147 41 220 203 234 5 5 225 98 238 86 50 36 40 210 16 147 144 106 223 102 2 104 245 122 48 115 80 13 189 221 226 38 78 63 217 168 33 192 195 174 194 60 47 77 52 177 168 163 127 188 150 238 71 13 118 153 42 243 111 189 85 48 151 2 105 42 89 236 33 215 242 171 165 53 234 196 230 219 8 54 88 173 4 249 223 88 236 163 185 76 34 39 106 72 1 187 230 70 171 171 207 82 171 10 4 224 85 75 175 209 156 159 51 87 111 129 76 173 195 119 143 176 184 104 77 213 76 156 190 240 92 210 47 98 35 150 164 130 170 47 163 238 239 224 67 114 14 108 172 42 171 97 128 143 133 10 49 126 56 212 188 250 198 166 248 77 42 189 101 173 44 160 252 208 128 34 23 129 207 192 80 91 138 130 170 13 143 145 140 247 251 38 236 86 175 75 213 81 46 45 58 143 117 88 4 92 103 66 141 56 218 102 98 149 26 147 219 40 187 202 66 214 138 18 211 42 208 97 6 13 69 113 237 72 99 215 107 190 98 153 56 17 103 89 142 234 237 87 118 226 213 63 203 209 253 31 242 80 100 178 205 243 244 254 225 181 124 53 237 171 79 172 36 68 173 40 254 139 242 76 220 196 85 65 209 83 208 241 22 81 48 9 174 21 198 69 177 28 25 206 38 18 240 223 34 77 54 248 35 252 127 77 118 239 11 222 20 170 234 130 98 93 61 119 92 139 231 130 166 216 197 66 113 183 46 0 220 105 235 211 29 235 37 136 246 14 248 189 42 11 121 88 71 9 88 206 168 133 31 196 150 29 103 31 57 111 183 254 157 78 212 206 141 98 88 211 157 102 116 155 145 192 72 107 225 255 157 14 172 224 155 173 25 171 171 203 43 239 28 82 240 44 33 14 8 254 78 9 66 59 55 207 143 247 4 244 187 32 41 13 163 100 223 39 141 4 196 61 51 108 93 92 22 104 44 16 240 126 217 121 221 103 57 30 86 38 68 136 153 244 241 175 48 181 105 45 182 36 203 101 241 180 88 156 248 109 58 62 199 200 104 3 48 93 180 4 226 84 118 72 242 91 233 51 5 181 185 233 112 186 169 254 124 231 5 175 156 36 42 250 177 140 206 141 0 108 225 94 130 228 178 38 27 129 21 93 220 21 48 192 211 107 27 128 254 35 102 65 147 64 8 110 249 143 15 129 72 123 0 159 155 85 0 60 113 162 202 233 239 144 132 2 218 83 195 52 29 14 75 27 54 141 113 203 135 107 36 110 115 19 75 190 87 152 88 39 100 243 14 233 43 170 186 66 139 236 34 231 235 174 57 153 203 102 24 16 5 151 184 156 94 242 23 131 166 210 79 72 18 138 201 235 52 112 232 134 185 72 75 157 186 144 211 190 246 181 121 1 54 84 177 64 145 95 191 129 210 231 203 8 192 121 119 129 175 107 16 234 79 253 164 192 204 40 209 61 64 49 72 94 117 83 255 73 93 87 16 30 155 229 40 192 120 151 140 142 149 172 117 221 212 246 251 153 189 150 221 236 224 34 83 7 60 252 155 78 87 104 61 193 77 219 229 252 180 5 161 87 141 172 247 143 127 65 33 254 157 240 140 171 165 18 220 106 185 182 142 39 128 123 249 186 17 214 15 21 145 47 209 90 87 62 55 174 127 246 21 69 89 169 136 159 81 123 116 28 150 69 122 31 225 168 118 18 30 69 241 148 93 123 245 141 83 201 111 47 255 19 9 240 223 70 215 132 56 114 141 97 70 140 102 149 199 45 122 183 158 236 64 137 58 111 22 253 5 238 65 41 92 236 40 158 203 161 244 60 96 179 20 205 9 254 49 210 94 235 127 205 16 75 45 76 35 29 79 39 134 252 76 136 75 169 114 151 114 194 90 112 173 26 30 210 61 5 34 72 18 74 114 52 4 145 94 253 90 165 15 236 210 229 101 220 179 159 122 54 92 159 181 135 54 32 121 144 208 62 249 50 49 225 5 117 127 198 182 239 67 18 57 189 7 88 14 67 41 142 199 125 22 11 126 138 21 184 244 48 159 190 71 188 66 164 241 212 157 83 209 140 241 201 1 131 110 195 109 150 231 192 203 183 31 209 210 55 237 74 73 41 74 96 167 28 89 104 249 45 184 219 29 57 208 201 222 11 133 203 217 48 158 187 178 30 129 93 122 131 8 9 145 74 208 61 67 122 114 154 184 212 174 187 27 122 187 198 145 60 133 71 24 131 148 20 51 97 233 69 126 115 255 10 197 134 69 11 43 215 18 86 43 14 90 179 193 159 35 203 7 199 45 30 16 44 52 53 191 15 206 55 153 30 59 81 34 6 209 252 14 56 191 191 4 6 65 92 118 123 142 150 21 214 126 64 72 134 12 106 54 160 39 246 179 2 96 230 101 106 230 156 156 110 215 137 223 166 23 121 187 145 134 27 91 59 63 199 41 181 229 130 145 22 171 217 116 112 85 25 217 147 1 156 32 136 72 13 120 200 1 147 189 59 254 218 104 65 177 71 0 165 165 165 165 1 0 0 62 0 0 174 236 103 92 181 192 83 131 0 0 52 58 0 0 99 99 0 0 0 0 0 14 67 2 0 0 88 176 0 0 13 22 0 0 0 0 15 0 83 113 117 101 97 107 80 80 67 46 112 114 111 106 0 1 43 249 77 77 80 82 67 87 73 69 1 0 0 0 1 111 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 72 39 0 0 60 122 0 0 11 182 0 0 0 0 15 0 66 193 212 151 230 44 187 242 126 170 58 34 133 163 140 183 17 157 122 10 120 46 3 129 230 154 177 115 133 125 213 209 224 242 22 126 25 154 214 216 196 174 96 243 128 109 90 179 117 245 139 187 167 47 156 119 182 214 72 195 139 171 20 66 248 252 82 0 64 157 2 33 34 208 126 128 38 5 124 153 220 3 74 5 116 126 162 108 152 131 142 94 103 164 83 214 149 156 193 237 25 14 251 53 196 247 119 62 179 57 145 84 220 160 162 72 185 133 115 102 11 210 135 91 2 226 49 250 205 130 31 155 169 189 44 214 24 71 141 229 22 65 166 252 244 182 95 118 167 148 57 203 124 189 46 57 190 101 213 12 241 37 185 67 67 25 128 143 47 7 84 243 26 234 72 46 29 24 17 114 248 113 83 22 187 21 44 85 249 227 43 20 191 51 9 99 1 66 78 252 228 7 65 214 203 195 80 200 133 152 254 16 156 143 131 61 195 84 158 92 145 215 206 167 70 203 126 167 110 199 180 127 205 226 95 181 158 123 6 132 215 203 1 33 24 233 5 55 159 245 126 241 241 149 105 55 174 7 1 28 236 157 6 164 210 12 70 151 64 216 55 25 151 64 204 145 168 43 129 208 41 106 51 41 161 109 218 46 90 82 191 110 156 51 89 250 158 93 78 200 17 188 4 65 171 244 208 30 31 132 180 19 184 64 184 173 188 148 200 151 252 248 72 43 199 99 34 242 60 218 170 242 23 101 90 111 182 215 129 253 142 164 230 79 127 62 175 9 235 48 39 183 232 92 44 242 3 55 24 131 73 89 246 236 93 247 115 158 24 159 102 149 226 84 246 166 197 250 225 25 63 207 203 147 113 84 21 240 194 45 245 11 171 143 31 187 10 162 218 71 107 150 243 42 36 25 30 214 154 163 44 245 212 134 67 244 226 178 157 147 51 221 212 46 198 166 226 170 237 15 182 225 202 191 204 203 167 176 126 210 44 70 11 60 125 10 141 221 61 81 244 134 10 215 67 176 231 110 101 153 138 172 62 46 178 146 199 81 24 236 145 188 206 171 233 43 123 76 157 172 147 32 67 14 204 21 161 133 48 174 207 70 249 66 251 115 236 190 206 85 242 54 241 248 240 187 95 196 119 54 106 216 81 191 155 249 197 192 3 205 27 63 161 8 200 146 178 192 37 155 136 82 89 83 116 214 8 8 10 105 148 90 137 118 193 25 107 28 191 91 10 149 250 221 61 24 134 106 32 68 94 70 252 171 40 117 235 52 237 144 33 106 247 219 84 213 77 229 8 164 181 208 22 162 198 103 29 216 156 223 0 12 192 39 88 40 45 73 140 179 147 168 169 154 132 82 44 23 150 14 157 12 2 235 88 100 173 72 150 165 54 225 234 104 68 122 81 111 236 17 101 218 153 178 254 241 69 6 22 118 152 146 18 56 39 33 26 114 87 239 181 72 102 239 207 2 37 95 166 152 158 15 34 90 40 208 35 225 11 85 200 247 234 185 141 172 42 24 101 58 221 55 246 131 140 219 38 164 255 199 101 64 144 160 76 205 35 184 232 213 123 16 56 86 177 31 11 146 144 119 14 28 150 154 67 167 204 48 51 78 112 49 81 90 116 63 111 157 82 57 147 88 112 120 164 112 107 125 20 134 77 233 29 198 78 25 103 48 22 134 1 93 182 119 221 12 40 91 181 212 88 135 182 34 155 27 160 128 192 76 19 28 138 77 29 88 184 157 183 168 221 79 89 28 91 139 253 138 31 188 196 250 167 253 2 44 126 83 70 208 118 158 124 77 57 78 104 153 193 251 93 56 51 12 130 124 40 116 109 214 44 61 142 194 63 129 93 43 162 67 43 51 49 180 216 131 187 36 51 243 148 79 20 126 32 3 213 176 90 110 25 166 103 202 210 111 104 169 118 165 119 64 149 241 114 11 232 216 129 67 70 195 71 85 149 132 63 39 55 104 34 179 44 94 126 195 78 166 166 131 38 183 107 109 72 186 10 32 221 104 106 114 147 34 174 127 99 22 3 15 73 247 205 217 210 28 71 20 33 73 227 145 250 202 94 127 82 254 119 41 39 240 249 29 159 90 20 173 127 238 127 2 231 245 212 21 235 116 57 230 35 198 207 137 61 176 200 201 218 105 192 5 241 5 108 28 101 80 144 30 160 254 151 165 142 213 109 119 35 66 34 204 46 220 40 109 247 54 190 226 113 160 198 185 73 244 231 43 76 31 162 248 102 158 76 144 84 77 226 6 197 235 182 139 106 146 114 92 91 238 83 12 53 232 195 40 95 21 112 146 194 82 208 91 162 163 75 32 209 25 72 45 108 129 45 54 152 90 179 175 137 153 142 160 53 190 35 254 48 66 57 57 235 191 84 74 232 99 53 143 175 217 232 65 128 127 207 102 246 229 113 92 130 232 54 157 214 106 242 176 84 7 216 56 72 18 33 168 214 219 209 119 202 155 142 148 184 18 198 112 104 102 25 238 30 24 89 231 250 244 242 153 116 15 100 162 11 59 51 40 101 113 140 73 231 40 244 151 17 177 116 153 27 61 144 105 36 46 216 46 253 183 22 151 38 199 159 11 176 120 81 189 114 52 3 231 81 192 122 170 93 84 101 105 225 231 57 47 105 228 43 156 0 2 33 206 79 54 193 157 66 134 197 182 134 228 150 223 233 66 88 168 86 235 227 125 185 247 101 50 205 97 244 169 72 49 53 24 25 139 190 206 5 74 42 111 168 89 70 143 232 11 30 162 112 51 174 93 242 203 147 45 55 80 90 48 161 51 13 245 234 93 234 218 138 184 188 67 211 115 5 252 186 204 92 94 231 193 110 178 217 195 49 2 109 4 214 199 158 86 133 128 200 127 213 131 151 0 57 223 101 64 223 37 128 213 77 176 195 177 148 31 94 204 71 93 200 77 175 43 200 244 234 212 93 183 246 66 54 127 222 8 177 180 177 45 183 110 152 55 209 18 74 189 107 13 147 174 245 9 162 243 63 94 13 237 103 179 41 53 194 73 42 218 55 122 147 139 255 142 121 112 23 7 205 254 68 14 246 186 156 21 235 222 152 4 224 53 143 57 11 149 112 36 125 47 103 141 124 142 120 12 178 86 8 188 202 98 210 249 255 125 95 83 26 122 183 39 131 41 217 9 69 98 74 209 13 236 238 88 69 249 198 54 126 97 241 73 163 68 255 84 107 110 129 104 81 17 219 113 147 204 170 235 10 244 225 64 236 18 216 190 11 140 177 106 205 79 36 168 11 203 86 91 186 225 216 209 220 193 176 17 22 48 27 197 24 42 24 196 95 208 210 43 154 242 175 94 88 39 66 165 138 226 45 112 168 244 228 115 231 107 243 192 16 242 63 125 177 91 93 132 50 95 215 98 201 23 230 56 146 168 94 55 223 119 71 178 152 95 31 42 225 137 42 80 217 220 189 254 106 23 13 142 135 106 13 164 206 252 118 27 238 5 26 151 117 54 69 39 53 7 16 17 198 174 117 154 48 70 61 16 212 101 144 128 118 44 204 207 130 117 187 221 141 32 14 164 186 208 110 10 126 70 111 78 179 132 185 31 220 20 1 230 138 49 112 37 172 230 140 185 24 219 66 154 144 217 199 64 1 247 86 105 69 78 100 250 167 232 33 88 35 162 144 91 88 155 192 218 243 126 36 180 150 50 206 29 1 123 152 39 40 192 38 122 162 179 178 91 244 177 136 40 193 94 78 43 126 44 0 176 69 71 232 13 165 33 9 252 240 15 8 69 6 68 163 95 214 196 83 148 46 43 202 157 18 225 189 55 144 120 190 113 27 108 13 170 139 6 78 28 176 228 118 91 177 164 156 6 197 237 255 156 38 209 125 89 77 153 8 229 199 32 240 181 3 138 236 156 9 33 48 246 245 8 94 111 126 250 187 235 174 222 19 126 197 3 17 50 104 58 199 23 162 174 1 207 104 183 133 108 191 133 150 45 192 220 128 63 163 147 217 188 223 12 31 157 17 128 99 59 212 195 149 128 181 137 129 0 226 66 198 112 66 246 176 6 233 244 11 19 18 12 136 235 196 210 197 44 134 205 238 145 128 169 19 132 48 79 193 120 157 123 187 118 200 15 243 3 85 227 53 15 68 229 241 47 159 28 105 5 244 128 67 2 36 54 240 129 99 122 195 140 44 105 26 141 55 165 103 131 238 193 165 95 62 119 12 148 225 204 56 41 235 210 40 16 109 166 65 31 240 13 97 136 233 13 189 108 65 51 35 150 15 31 16 11 33 0 52 57 110 225 62 226 14 194 111 201 122 28 216 127 67 212 232 244 148 131 214 143 83 2 145 163 132 61 176 94 138 28 220 17 45 164 169 125 104 50 81 223 15 128 35 155 30 253 112 53 65 30 90 144 58 221 47 251 131 103 154 144 128 157 138 97 253 136 62 89 208 3 140 188 58 211 22 37 160 20 196 42 24 175 204 220 74 89 170 77 124 203 3 217 110 44 69 83 103 77 86 251 71 207 195 6 209 195 156 226 128 21 184 158 63 51 49 76 228 20 103 214 68 193 65 132 134 224 149 25 86 210 61 41 125 246 25 49 88 250 223 179 25 14 19 179 200 125 191 92 26 118 117 50 26 23 199 232 167 135 150 137 221 247 193 201 159 249 222 184 143 138 85 194 111 84 229 138 156 123 188 9 184 40 81 241 41 176 246 69 181 47 109 194 96 161 152 96 0 109 177 99 77 69 169 100 211 181 43 33 135 231 234 153 177 36 24 253 109 229 214 63 87 101 19 254 170 34 161 203 34 228 187 181 2 151 72 146 135 60 111 109 239 178 217 75 58 81 20 163 237 95 197 251 145 147 44 109 44 169 101 97 72 251 100 242 148 94 162 183 188 115 7 101 188 209 220 25 236 80 234 181 35 139 4 27 3 183 2 151 50 241 147 36 71 166 214 32 168 167 239 92 97 231 55 152 71 150 80 227 186 139 175 123 43 195 134 118 247 169 147 115 96 190 45 160 162 172 98 215 128 45 138 67 171 36 65 127 153 125 191 243 226 251 21 176 73 143 136 126 210 4 219 30 104 13 249 10 118 106 221 143 113 168 43 95 48 70 206 56 211 169 55 135 135 71 250 35 204 55 92 27 109 22 8 110 18 199 67 49 102 244 22 203 33 14 95 10 106 41 202 54 30 255 230 136 9 69 115 10 50 248 2 75 187 55 204 15 145 198 43 159 88 185 44 245 185 120 203 81 22 99 194 107 72 70 60 238 190 101 119 247 21 244 83 14 0 92 94 163 115 172 84 149 224 97 118 147 253 133 123 250 223 210 205 185 225 188 137 162 241 248 69 189 228 204 70 91 237 0 133 225 117 11 179 144 95 202 161 15 119 235 182 221 245 11 83 225 108 209 167 210 173 177 69 71 24 67 103 246 98 210 212 63 35 56 121 35 18 231 141 13 122 245 54 3 192 88 11 148 106 216 72 253 89 193 26 204 128 81 117 54 202 166 5 40 252 92 212 116 246 85 253 185 20 185 152 135 39 192 248 12 162 234 141 210 139 180 190 22 119 220 172 8 92 48 107 80 183 85 168 140 194 172 138 38 115 190 81 139 235 203 231 16 213 159 186 244 208 77 38 88 251 58 167 155 180 123 43 3 196 135 74 191 204 112 243 255 212 247 120 52 174 5 253 169 46 134 164 46 154 2 233 110 62 210 186 85 88 106 137 47 240 57 168 113 68 63 232 19 3 253 245 55 213 201 169 246 210 44 151 143 148 139 124 158 148 241 71 249 59 93 23 184 108 236 39 20 245 227 154 143 253 176 158 41 96 212 147 158 102 131 110 115 67 134 253 236 76 222 88 232 153 13 92 165 193 69 138 30 252 95 197 165 141 9 164 136 86 156 175 254 61 37 21 116 230 117 107 249 229 28 2 85 106 150 221 89 115 74 115 215 224 36 175 160 93 221 158 53 223 83 216 21 198 235 111 136 132 195 161 196 205 71 189 247 31 241 136 218 35 55 210 230 248 105 62 121 46 92 81 172 66 59 237 75 229 251 250 26 25 7 66 38 207 227 99 109 123 165 162 17 154 175 134 150 220 125 210 99 24 71 133 94 248 194 123 77 160 79 149 33 191 133 191 50 160 67 42 8 138 2 26 179 84 15 198 171 176 55 168 71 217 69 188 175 58 76 255 42 76 25 176 71 108 231 14 184 68 132 192 221 108 113 181 52 163 90 55 43 185 75 179 93 154 252 189 16 194 104 82 159 152 221 241 230 151 172 46 201 16 141 189 91 182 160 169 41 151 2 181 104 55 23 20 20 139 133 170 159 146 197 17 70 227 86 63 8 126 42 188 77 72 254 118 61 128 203 218 249 156 233 201 115 144 72 156 99 221 98 224 148 39 118 123 22 42 147 184 48 21 164 133 168 233 90 242 124 252 200 183 193 188 167 178 216 237 23 146 139 132 126 225 188 157 188 128 97 175 42 227 94 214 221 202 121 93 228 152 159 95 179 91 29 118 67 3 203 22 152 234 126 253 128 253 105 134 132 43 230 42 104 130 148 173 109 220 134 87 21 46 19 187 144 96 250 246 57 169 122 209 246 108 128 225 250 252 217 67 237 197 111 35 143 21 116 85 75 209 144 19 179 169 105 159 229 63 83 91 55 182 139 95 84 134 198 105 126 210 150 29 207 176 251 33 171 141 244 121 52 221 128 29 83 93 54 128 0 66 193 213 16 181 48 169 180 14 221 180 40 225 44 39 13 57 227 112 140 78 231 242 215 8 190 198 120 110 65 28 120 86 141 129 25 22 126 80 56 36 217 189 29 58 190 208 142 45 216 134 104 63 99 44 107 71 209 38 205 252 120 46 39 213 57 134 40 9 109 184 211 216 98 177 234 68 53 25 27 164 55 66 222 63 158 39 202 178 130 26 101 32 159 150 12 59 145 52 234 168 185 178 117 87 130 34 20 141 50 120 192 146 240 134 124 85 160 107 21 99 147 173 18 224 23 57 195 45 253 254 55 95 110 76 132 155 192 227 106 159 48 255 57 23 131 122 195 98 219 210 28 187 43 184 147 218 78 54 233 8 96 18 170 199 37 161 61 15 138 119 36 14 241 185 245 144 255 53 58 176 18 99 131 142 101 13 161 213 251 186 29 94 242 223 167 157 176 41 16 172 60 245 238 86 153 69 214 86 139 159 121 139 252 58 214 115 19 165 123 63 18 81 222 83 99 102 129 192 40 150 67 239 46 115 245 28 9 131 203 72 211 210 213 225 73 165 35 255 130 60 53 153 197 202 16 201 228 90 243 25 143 141 116 85 53 228 42 200 48 181 207 84 13 88 67 33 66 104 70 55 118 50 154 109 95 4 76 17 219 219 120 9 116 115 48 138 34 246 5 188 198 100 106 203 105 90 18 102 145 89 118 241 242 180 29 85 228 250 110 108 8 63 126 250 113 65 33 192 134 246 170 8 122 110 65 118 119 129 133 102 244 85 107 136 43 60 118 209 197 107 18 62 46 156 123 173 170 119 45 162 179 193 167 7 185 246 42 119 179 22 30 121 81 57 2 30 141 73 90 92 237 181 73 143 96 45 198 53 192 112 161 85 215 104 63 20 164 18 167 185 60 32 179 4 26 62 114 218 61 136 215 153 244 60 144 25 24 120 159 196 76 181 23 173 11 234 226 170 3 82 139 56 127 96 32 56 202 143 24 188 134 85 39 182 8 163 218 241 217 230 196 182 238 212 86 234 13 189 87 42 54 169 169 79 255 112 0 56 166 76 155 202 233 61 131 74 58 109 218 54 116 93 40 197 204 129 212 246 121 136 223 202 116 169 248 244 168 144 161 64 111 95 87 162 222 212 127 91 67 180 22 27 60 230 136 115 253 197 49 141 210 230 125 246 220 3 213 124 156 192 116 158 247 199 202 212 242 88 90 46 200 140 83 23 190 233 76 154 244 145 60 191 54 86 90 181 1 249 223 250 58 88 250 249 218 202 206 148 62 90 89 143 139 232 122 103 132 208 200 33 123 196 78 146 160 70 158 143 233 74 128 90 86 70 75 159 159 59 104 145 24 218 202 219 117 121 54 1 240 224 41 224 157 144 101 46 95 87 16 225 123 126 192 201 205 216 5 232 127 235 215 170 233 149 5 8 112 128 141 93 235 196 51 49 32 56 213 119 64 126 212 190 100 37 239 3 68 208 94 130 24 124 123 29 223 153 92 165 251 190 247 102 221 125 232 89 21 188 167 103 19 113 216 4 93 193 216 204 173 213 156 10 229 255 158 101 60 160 240 44 231 173 74 117 61 177 160 195 118 210 232 153 46 90 143 165 198 160 235 93 113 57 80 0 165 105 174 107 91 89 128 83 6 115 141 54 169 201 88 227 110 85 107 99 242 1 74 28 99 67 122 206 94 50 180 136 137 193 185 125 1 24 125 30 29 54 129 215 188 231 89 27 57 129 168 10 80 120 71 64 242 137 151 191 193 91 239 36 163 237 57 236 35 32 101 173 75 211 138 172 109 184 244 131 248 134 150 199 200 154 12 46 10 51 209 81 248 85 113 159 178 160 205 106 184 175 44 46 32 242 220 208 209 39 8 103 92 233 215 254 182 178 226 227 153 128 74 5 31 79 112 18 247 21 90 239 198 132 21 129 185 250 104 218 29 210 101 202 245 120 249 216 212 224 116 231 10 195 200 208 250 38 30 8 108 191 26 0 72 193 113 120 146 174 9 118 160 57 144 49 8 228 121 171 230 71 137 3 59 77 141 161 83 233 55 173 113 115 28 254 56 223 121 184 212 18 222 145 35 206 72 202 97 150 175 131 220 93 120 72 63 53 225 171 149 37 184 43 80 62 72 249 9 42 148 115 74 87 177 59 87 176 230 109 102 77 41 162 220 184 52 206 201 33 142 172 203 119 162 112 221 224 185 191 89 100 237 175 213 89 152 240 142 210 116 196 93 18 34 150 158 202 19 62 218 102 44 22 140 234 76 255 16 88 84 226 7 159 187 84 200 32 110 32 183 238 69 132 138 161 11 129 100 154 144 96 119 98 85 167 252 167 195 156 134 224 2 150 160 145 225 134 70 181 37 211 8 26 165 105 90 39 176 116 135 230 137 200 201 89 152 244 233 192 27 176 219 4 227 2 42 230 134 129 207 168 70 239 196 93 18 61 55 35 188 79 26 115 221 121 201 238 99 151 108 72 148 96 45 170 113 49 238 104 193 207 208 187 78 86 207 156 51 211 227 43 100 49 207 28 177 242 36 193 238 62 183 29 78 157 121 12 193 60 174 48 21 195 92 77 211 103 67 233 220 76 233 44 145 234 144 229 20 52 87 48 196 31 235 43 1 220 142 47 41 255 234 208 239 78 115 131 56 218 154 167 145 183 3 219 218 73 110 218 84 101 42 159 127 85 236 155 184 229 39 251 5 179 31 218 216 255 49 94 248 245 160 241 38 234 161 51 111 179 196 15 19 220 188 236 206 142 77 153 79 152 3 239 72 219 219 69 55 31 120 188 213 42 201 36 82 21 190 90 161 144 241 160 141 120 162 63 133 22 162 21 237 156 171 109 132 84 40 230 202 34 182 205 249 170 189 3 97 50 27 191 173 229 42 35 172 64 204 162 51 212 143 161 37 241 130 81 103 51 28 230 184 228 178 57 217 157 91 86 4 200 82 41 73 127 143 200 189 128 160 132 161 44 85 83 105 244 177 128 141 95 226 34 234 123 68 169 47 162 216 80 140 31 150 229 129 185 106 48 190 105 40 63 168 126 57 165 21 122 236 250 247 121 99 255 228 237 85 173 198 7 146 14 173 184 45 199 149 219 28 26 34 150 31 129 8 6 238 129 51 1 177 93 200 194 34 38 102 40 69 23 207 148 95 171 101 47 1 234 227 157 206 154 52 163 201 33 167 155 185 205 105 58 197 148 248 134 230 2 95 110 188 2 242 20 200 132 7 47 53 194 214 165 80 15 134 134 219 149 9 198 192 203 117 215 232 59 252 189 101 107 204 42 50 15 123 251 91 150 197 169 239 49 254 66 198 66 248 146 134 133 54 227 18 15 87 156 187 146 92 81 176 169 146 213 1 167 238 148 242 199 179 157 112 198 163 241 207 227 84 101 189 149 74 154 59 157 100 87 173 245 87 126 159 237 49 203 48 205 224 19 168 253 230 8 238 89 124 107 89 112 198 130 92 248 195 188 203 126 166 2 178 94 253 41 226 3 254 104 127 7 108 140 162 133 21 12 177 95 50 65 134 10 120 100 146 231 252 86 254 138 126 157 234 131 195 124 120 121 210 172 149 213 22 200 126 3 194 179 99 162 185 138 77 4 38 129 91 172 31 15 173 23 50 153 113 3 184 59 172 221 99 214 240 45 108 6 52 185 80 113 83 194 28 74 233 139 177 226 246 99 175 168 146 42 155 83 224 164 134 205 132 102 178 219 170 153 123 116 151 59 14 143 189 172 4 71 227 83 241 73 189 139 62 247 103 196 170 231 198 243 250 25 232 32 139 134 217 94 219 180 147 54 104 20 73 226 170 27 129 179 195 248 182 137 110 29 112 192 59 3 158 147 131 4 191 12 184 253 122 158 11 143 49 179 94 221 140 71 33 200 242 190 190 255 10 213 202 94 221 121 238 207 136 175 137 133 39 243 15 187 20 120 195 203 218 10 68 121 17 201 80 155 64 191 109 147 78 79 8 180 155 108 30 218 155 231 185 217 131 133 216 188 5 90 232 55 47 150 4 137 70 224 113 215 225 2 186 86 182 187 154 224 228 32 123 221 241 142 10 104 43 47 57 246 47 182 248 82 149 37 125 112 72 77 26 177 59 34 172 188 48 245 155 39 161 186 40 157 5 171 111 86 199 30 150 251 57 137 191 37 179 4 96 154 20 17 135 160 218 84 192 53 47 129 166 16 126 120 192 15 226 0 203 89 183 27 123 105 24 173 77 22 177 81 129 88 67 171 36 228 95 163 137 144 32 183 44 126 45 36 178 148 6 212 3 175 2 243 4 188 43 204 209 157 145 85 229 207 206 162 18 168 100 185 69 207 132 61 8 44 19 224 204 252 47 129 39 236 163 134 71 244 39 65 61 66 86 165 65 155 255 203 77 175 21 183 60 7 117 1 63 218 173 79 253 241 42 143 27 25 235 123 14 144 167 13 101 39 96 15 102 34 235 18 40 46 63 166 72 82 40 134 240 194 164 176 2 83 92 227 255 239 139 234 252 252 115 53 119 241 97 22 113 93 198 171 183 102 173 24 39 247 110 111 229 188 232 235 201 129 159 247 156 206 108 23 49 12 177 246 60 25 25 220 26 93 104 30 140 183 100 80 146 212 86 82 194 221 58 31 43 28 141 69 190 194 219 53 37 55 183 59 238 229 144 157 245 156 59 198 244 132 195 254 146 169 90 83 236 23 4 179 96 241 237 221 66 178 2 182 124 248 107 98 51 25 2 172 167 8 218 239 216 65 225 217 174 51 65 129 13 229 83 110 108 187 202 253 0 60 1 66 250 236 184 216 103 129 216 192 188 72 254 149 144 171 57 117 19 192 163 21 110 215 161 160 20 11 182 233 8 131 206 252 206 75 173 253 80 70 236 205 140 177 21 141 183 103 37 90 196 2 154 183 134 46 130 17 148 241 105 88 42 15 224 221 18 54 173 102 52 93 13 139 77 192 189 75 136 39 161 202 117 111 204 234 114 83 36 69 134 106 176 43 170 31 8 118 16 183 142 74 139 171 112 113 234 97 42 97 237 42 8 187 103 158 41 1 17 225 79 145 133 173 33 165 145 227 188 206 90 64 107 197 87 195 240 75 131 247 75 7 62 91 138 125 68 197 215 93 104 211 251 65 136 152 14 96 31 181 185 255 90 130 165 147 91 36 130 78 155 91 240 192 91 190 190 130 239 193 85 1 10 172 233 117 225 54 0 156 66 183 165 231 51 21 55 76 220 43 180 66 114 95 233 180 236 74 75 53 115 148 14 99 228 71 168 46 60 50 95 193 97 175 200 128 124 234 171 109 195 73 234 85 62 175 167 8 36 130 112 33 235 202 30 173 236 249 40 110 84 56 168 145 64 224 85 145 68 216 85 126 59 234 166 207 104 113 201 44 180 23 70 154 226 184 212 89 255 3 183 86 142 56 144 174 62 61 138 214 7 249 78 68 34 16 143 61 172 225 186 188 126 124 213 203 50 228 34 124 21 69 187 56 230 201 144 158 37 110 116 68 27 125 85 203 127 19 36 222 212 15 198 14 84 181 42 0 254 196 247 127 70 189 100 24 51 11 69 91 147 163 230 189 50 144 134 186 46 103 249 242 17 97 153 185 77 185 240 149 215 217 118 149 129 217 217 212 144 80 233 93 172 107 190 128 235 214 244 2 130 242 36 113 49 215 165 245 165 157 80 162 167 0 190 189 155 107 58 156 231 199 140 158 237 122 227 204 142 61 243 93 237 12 178 165 142 158 182 28 127 171 131 190 36 175 20 154 152 172 163 193 197 115 67 112 251 241 159 136 129 102 123 8 106 130 51 42 17 140 224 0 134 138 176 209 106 65 163 94 244 92 192 94 87 32 146 118 246 20 82 2 222 233 5 227 148 249 127 109 71 148 127 196 154 172 110 224 143 97 36 52 172 41 80 134 39 43 115 18 202 14 164 31 246 5 114 156 9 252 179 227 187 57 215 240 57 129 70 203 15 42 95 49 23 142 169 87 102 217 125 102 164 233 245 59 192 51 60 103 18 99 234 200 215 177 95 146 114 90 101 243 156 230 74 43 45 20 180 33 221 209 170 19 78 186 227 191 45 193 115 228 252 57 101 113 7 139 16 23 140 148 31 201 115 144 45 179 249 103 208 118 7 21 241 229 152 207 181 142 98 4 47 137 144 99 147 208 74 116 194 245 134 146 123 229 228 204 161 110 25 13 160 222 148 179 203 79 140 49 111 98 75 233 61 114 63 229 55 249 157 184 124 6 43 181 56 133 123 138 170 172 222 252 9 139 215 40 205 134 230 197 63 75 210 109 54 39 203 25 95 162 147 33 208 21 57 230 32 111 87 218 144 153 203 31 10 85 15 149 95 129 87 247 247 98 191 63 230 169 142 47 143 130 93 152 50 108 117 140 41 154 101 254 193 175 118 67 204 146 229 74 80 211 250 16 207 128 106 235 62 105 9 133 35 141 216 87 28 164 71 113 183 213 248 143 67 45 213 84 250 141 60 5 107 114 248 102 28 119 167 35 190 163 144 128 254 24 241 93 39 85 26 234 188 226 179 58 211 195 29 170 57 89 152 77 30 18 249 218 194 80 170 227 175 18 213 44 26 160 76 54 71 51 118 13 113 104 13 59 164 209 3 174 94 139 28 183 57 228 110 120 213 14 104 68 219 53 105 87 128 227 165 228 24 162 220 111 221 146 67 190 153 215 91 146 208 227 164 203 6 57 208 123 118 203 122 32 12 76 249 110 221 246 244 32 83 252 153 0 89 34 69 189 89 229 241 244 251 173 172 144 166 186 181 13 19 119 184 180 61 174 0 170 252 250 245 231 7 224 133 132 3 123 223 6 158 137 63 172 160 233 145 50 9 234 114 188 174 247 220 109 254 118 193 118 209 48 248 63 149 233 234 98 83 68 242 75 39 74 60 235 204 5 235 101 220 123 151 138 84 34 2 41 21 49 209 247 249 182 213 0 158 176 84 126 247 68 64 109 141 20 33 179 249 106 127 148 23 255 223 50 39 236 42 109 38 127 37 151 221 161 125 170 173 223 234 245 240 206 123 154 246 139 26 177 26 35 2 33 181 250 14 151 172 88 42 11 136 224 73 89 227 197 89 171 51 88 206 67 234 129 94 248 59 168 32 136 31 162 243 127 161 246 94 49 243 239 10 160 184 47 126 171 13 34 59 127 37 26 86 135 191 180 193 58 160 73 46 189 138 240 35 55 165 157 239 64 183 233 225 217 249 234 84 208 8 159 51 227 109 158 179 87 220 158 175 210 131 177 204 209 48 240 231 24 222 11 187 85 11 97 101 66 21 205 94 126 85 236 39 241 196 175 219 38 238 245 159 49 77 199 196 110 218 150 223 145 49 49 127 62 140 140 27 53 37 79 19 49 135 176 144 235 28 123 245 229 175 31 167 163 2 135 209 2 223 60 132 10 79 182 23 8 132 44 197 24 123 193 91 106 116 79 97 249 8 77 185 136 105 128 110 4 9 27 235 203 1 128 127 125 0 165 165 165 165 1 0 0 68 0 0 180 207 51 128 182 14 50 169 0 0 74 39 0 0 101 98 0 0 0 0 0 20 194 229 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 73 110 66 114 111 119 115 101 114 46 114 115 114 99 0 1 134 53 114 115 114 99 82 83 69 68 1 0 4 0 0 129 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 1 253 0 0 1 137 0 0 0 0 15 0 66 193 212 234 64 99 97 40 139 5 15 124 31 121 65 120 146 200 173 211 210 149 182 129 158 205 118 129 207 95 40 49 56 157 177 180 70 149 83 54 3 21 101 109 192 23 68 207 158 18 100 184 200 57 166 54 189 7 10 8 35 160 31 189 69 96 6 251 36 144 52 46 122 224 140 131 142 107 203 86 133 196 231 193 118 175 248 52 27 9 237 188 57 72 178 184 251 102 202 113 145 140 10 144 242 70 217 116 15 106 131 246 74 196 1 22 89 124 130 39 36 161 170 59 206 175 126 171 28 60 247 201 113 130 115 211 207 61 71 255 51 103 85 164 106 4 45 107 151 164 234 135 37 154 140 172 36 162 124 138 123 134 131 22 222 204 0 143 209 176 180 40 40 83 131 32 200 202 141 130 221 88 227 19 175 6 121 236 249 59 11 214 118 118 203 22 70 160 90 245 161 227 255 229 122 250 193 135 203 10 226 24 65 203 79 121 182 197 210 18 129 97 215 101 195 170 225 244 234 54 162 2 70 49 242 208 45 192 209 41 192 140 163 193 203 28 229 201 202 3 215 230 23 44 15 110 165 188 64 227 33 30 189 93 89 180 203 179 31 169 10 141 180 17 200 146 27 13 238 56 10 29 23 62 248 208 13 168 201 252 10 236 197 19 236 183 94 95 27 17 242 58 179 242 109 147 121 193 155 144 46 248 52 226 149 176 250 202 4 58 89 131 34 148 100 124 228 53 56 166 208 218 140 69 213 223 84 198 170 44 98 130 94 24 65 112 50 62 107 104 26 218 230 148 65 52 215 139 174 49 8 141 106 8 247 50 218 37 118 118 249 63 141 166 56 43 243 68 242 131 7 252 7 29 103 22 146 152 169 150 22 142 32 165 165 165 165 1 0 0 62 0 0 181 174 119 219 182 77 216 118 0 0 99 99 0 0 0 0 0 0 0 0 0 14 103 216 0 0 0 0 0 0 0 0 0 0 0 0 0 0 83 113 117 101 97 107 65 112 112 46 114 115 114 99 0 1 218 217 114 115 114 99 82 83 69 68 1 0 255 255 255 255 0 0 0 0 0 0 0 0 0 0 128 0 0 0 0 0 0 0 0 0 40 104 0 0 13 40 0 0 0 0 15 0 66 193 212 197 152 42 182 125 7 209 253 179 246 11 43 249 23 162 71 36 169 250 206 186 205 66 199 226 98 55 7 177 53 236 55 58 79 128 26 51 183 167 240 97 86 128 242 71 242 67 174 16 134 228 55 218 207 53 158 128 112 186 172 232 44 219 195 5 180 24 55 31 245 94 187 102 126 16 225 179 154 193 117 248 105 117 137 150 166 228 202 174 98 128 190 102 60 144 107 20 18 75 136 179 30 85 35 195 28 12 247 213 107 204 112 228 106 25 110 4 221 123 213 59 16 187 58 94 158 27 188 245 213 128 9 187 130 72 240 30 18 151 45 85 48 180 5 174 122 71 58 54 143 167 128 15 181 234 211 148 60 98 50 11 144 242 246 177 192 149 156 85 165 182 226 173 152 245 203 119 112 220 233 96 107 53 59 249 50 154 14 247 103 36 101 32 250 43 139 76 121 77 153 238 120 50 78 196 146 143 89 11 166 238 44 175 144 152 163 178 112 169 179 103 226 51 222 50 173 237 139 145 162 210 63 68 250 39 244 117 11 92 69 182 204 20 110 203 107 28 152 74 89 68 140 252 178 251 139 206 236 1 31 160 134 231 48 71 246 252 66 249 35 122 4 209 145 48 70 240 233 126 104 2 47 204 88 178 155 109 195 129 244 240 81 167 114 214 18 144 131 73 169 35 230 68 150 251 95 220 251 117 22 186 127 175 169 13 235 137 211 56 50 114 113 53 35 23 73 238 70 94 196 46 93 245 233 196 175 248 31 199 194 45 248 43 56 209 224 247 48 231 70 62 181 117 249 241 143 47 190 228 101 185 117 82 48 249 145 171 27 146 252 3 200 220 146 109 217 227 112 120 57 54 164 101 212 114 247 40 244 177 184 166 140 54 130 49 116 50 115 29 177 14 114 213 40 244 211 3 90 221 26 25 251 45 1 226 81 146 137 162 26 131 89 169 44 97 25 167 10 141 134 209 150 115 100 170 60 142 38 78 118 161 100 10 178 72 69 44 58 161 188 43 226 48 17 124 149 125 13 90 82 60 202 14 56 90 55 83 89 66 117 231 200 238 140 51 113 69 149 224 131 185 225 75 101 192 217 120 23 0 198 25 227 166 27 177 149 232 124 148 80 123 62 189 232 223 176 7 144 111 105 250 111 133 237 167 129 109 211 225 145 239 23 226 245 181 66 69 66 133 132 83 190 152 254 108 193 2 94 18 209 199 117 204 70 221 245 139 68 110 211 141 193 251 18 9 241 78 245 7 200 116 236 156 64 176 236 204 122 179 165 233 163 43 5 26 50 222 240 131 172 0 89 159 186 176 3 21 182 112 18 227 250 222 236 26 99 160 219 162 118 217 47 123 104 42 105 148 67 20 127 185 244 232 254 213 66 139 5 52 240 142 2 127 59 32 245 12 159 87 243 126 180 225 198 21 81 117 169 59 2 173 149 90 248 17 50 77 39 124 242 224 189 137 91 145 56 130 73 192 106 124 172 72 31 228 141 133 3 148 132 243 242 101 195 171 219 161 141 22 233 139 235 186 141 186 89 25 101 33 229 92 84 50 19 191 175 209 88 207 89 174 223 19 197 28 10 219 142 73 199 74 24 43 188 224 215 60 241 161 76 83 193 182 59 14 193 133 95 238 105 29 42 94 205 150 154 164 227 29 137 40 239 113 134 188 186 116 115 151 108 43 204 147 73 59 10 169 136 223 188 62 145 228 215 123 117 145 189 216 254 33 80 103 236 221 103 169 91 117 130 101 57 124 183 196 243 179 67 75 122 248 62 225 8 141 159 167 151 46 229 82 70 34 71 65 33 97 177 11 119 51 12 253 244 11 41 26 31 56 103 9 142 180 80 149 96 199 3 179 95 26 75 109 202 192 97 146 255 123 10 183 120 117 187 41 151 167 69 14 99 130 173 149 73 72 94 84 40 154 18 192 247 172 42 125 12 149 6 196 255 82 136 130 244 149 67 66 144 83 127 74 176 46 251 132 227 231 176 130 227 51 120 83 84 13 43 102 123 38 171 245 29 13 141 59 169 232 90 172 218 123 238 251 136 255 137 97 254 107 223 252 155 49 62 95 180 123 229 81 0 146 135 130 82 8 225 29 2 223 236 130 58 163 44 114 134 2 202 80 160 220 202 159 66 81 31 85 189 221 199 92 24 84 105 74 254 192 253 28 87 145 161 163 21 186 254 52 94 42 250 246 151 29 180 44 76 139 66 0 205 253 216 187 171 178 162 133 238 37 77 177 24 181 173 161 108 32 139 24 164 154 252 201 135 112 82 176 198 66 241 23 249 137 31 165 82 148 80 5 125 158 149 121 158 215 191 173 198 239 220 112 227 155 129 19 190 73 167 3 195 125 1 192 199 125 155 89 137 241 65 210 146 36 196 30 180 171 201 250 102 54 255 103 116 81 102 76 115 43 233 15 132 185 194 38 167 199 125 167 169 142 69 163 225 186 146 109 191 42 154 250 162 48 70 120 194 109 253 160 90 20 245 237 75 193 20 2 246 1 208 117 19 242 50 218 120 226 131 254 89 59 200 32 177 138 199 170 89 20 231 9 185 179 213 233 140 91 87 239 179 120 30 130 231 59 19 8 236 225 203 156 138 95 84 213 13 53 20 73 83 48 172 156 64 169 49 176 145 245 141 146 194 178 13 122 13 224 139 18 104 23 38 86 151 229 93 169 192 143 207 133 23 152 163 240 155 78 158 59 142 86 33 107 204 195 184 123 43 175 2 183 149 211 242 18 178 162 49 101 190 114 156 131 159 104 18 255 174 66 67 29 251 127 225 78 196 146 11 75 128 10 163 64 179 23 216 176 108 7 126 94 174 12 67 23 152 92 182 216 43 57 222 112 146 12 13 108 166 175 82 46 112 75 73 26 136 187 252 185 161 15 224 48 189 26 96 147 221 32 237 67 119 48 208 64 175 149 240 238 20 20 204 108 191 106 175 2 61 98 21 90 228 214 151 14 61 199 231 23 133 234 240 25 18 134 67 238 191 212 247 218 6 112 232 138 207 66 174 183 187 79 124 93 58 181 171 156 155 94 235 68 18 50 138 96 134 233 206 48 75 165 10 55 137 234 228 143 44 4 94 133 87 18 13 183 184 161 16 105 58 118 4 132 168 2 202 110 182 177 7 211 127 17 97 211 127 168 56 25 240 11 197 47 12 220 220 220 223 246 163 123 247 89 47 203 127 186 92 145 184 152 85 142 34 23 220 192 74 23 129 98 229 117 92 12 248 77 209 248 173 72 166 34 191 57 112 2 91 5 194 142 64 38 248 156 68 216 180 109 54 145 241 67 40 105 255 226 217 12 44 175 219 29 255 163 121 156 176 101 144 218 211 7 98 203 101 21 148 125 79 40 177 70 85 4 145 207 124 158 107 192 15 182 78 131 108 198 143 75 192 80 197 74 135 208 28 248 123 177 244 83 57 154 229 0 103 90 4 4 161 254 200 18 161 54 113 234 178 111 194 227 233 137 200 51 202 170 30 57 101 5 53 92 245 201 151 139 114 83 133 235 118 230 19 84 68 86 232 37 217 13 112 46 103 211 146 116 112 221 40 73 31 178 1 86 184 146 61 239 186 65 121 90 250 185 172 110 79 26 87 220 10 127 176 253 194 48 207 174 185 215 40 166 83 157 74 129 65 253 248 171 153 219 78 73 225 220 246 100 5 31 252 118 223 28 208 61 177 129 74 99 86 50 232 54 243 233 219 89 92 202 153 170 133 17 38 169 221 62 209 122 67 170 96 177 144 31 61 39 248 107 140 133 205 169 139 25 168 20 195 116 236 41 148 68 122 169 200 20 187 14 127 185 206 245 187 167 99 46 149 94 88 208 65 132 19 58 222 108 48 204 197 71 13 63 182 59 97 213 222 58 111 220 124 145 92 129 195 151 19 242 113 213 153 58 41 89 150 148 52 175 102 243 180 163 164 103 70 127 180 218 186 85 83 79 239 242 96 50 249 146 232 238 84 3 155 56 121 174 242 1 104 196 21 3 44 39 70 101 93 136 211 187 101 132 211 159 186 225 186 191 83 15 172 214 118 168 6 92 55 224 125 63 177 80 109 227 132 29 176 179 247 7 150 202 227 144 90 245 193 81 29 186 181 60 201 174 159 129 141 106 224 89 151 48 21 22 163 162 146 199 236 25 44 243 191 30 239 66 8 235 253 61 62 26 45 97 66 73 141 225 179 88 16 198 101 129 120 158 63 232 171 42 214 128 249 123 69 97 155 94 177 164 184 230 220 48 103 18 5 172 211 65 180 63 48 174 36 50 190 179 29 10 100 27 236 55 222 41 119 87 61 250 30 117 183 144 25 219 68 234 240 168 6 32 254 82 29 201 231 49 134 227 150 99 150 64 200 13 19 149 212 96 71 201 46 123 44 46 155 236 10 241 29 210 99 154 83 202 171 210 206 76 73 191 78 143 11 175 88 251 218 47 42 224 243 230 198 175 11 31 144 155 116 156 216 13 244 194 45 183 93 193 237 206 1 245 51 109 155 22 193 65 225 93 87 41 240 133 187 138 165 83 126 119 228 142 31 143 23 182 190 16 209 55 165 18 21 94 242 88 177 86 97 22 7 235 80 76 159 40 52 26 202 239 65 176 79 64 187 221 132 84 12 144 228 187 53 250 43 11 9 105 74 240 172 182 42 75 170 116 74 27 182 206 72 18 11 209 158 251 23 4 252 23 78 40 120 184 36 244 217 133 201 133 134 243 185 113 72 155 244 44 138 39 1 35 109 206 112 111 135 175 30 220 225 109 41 162 45 217 212 98 122 10 32 249 179 36 189 187 123 29 44 197 33 9 190 224 155 89 124 183 214 167 243 39 255 202 24 13 245 112 204 160 85 9 112 72 104 19 202 137 75 106 227 223 10 195 3 156 92 151 183 165 126 37 93 188 165 168 20 215 106 123 67 169 68 189 23 75 62 213 206 107 4 254 7 24 81 133 14 78 4 91 1 255 95 176 232 254 66 68 84 99 123 62 114 169 246 184 202 222 51 57 178 111 81 122 87 144 153 176 236 72 128 11 75 46 193 66 41 92 238 139 28 194 83 215 154 201 18 94 122 90 62 143 22 77 216 10 72 134 144 117 196 200 188 155 138 84 185 143 245 221 104 31 162 243 181 6 231 243 176 169 192 20 237 232 66 7 109 101 249 215 29 216 42 92 233 93 229 118 229 199 252 160 20 20 213 149 230 166 41 111 172 94 194 206 60 221 127 66 167 117 26 128 168 128 243 28 89 8 166 81 32 30 0 238 16 224 139 7 91 218 94 153 187 134 53 145 144 20 98 10 126 252 63 134 142 198 33 227 98 249 26 147 30 14 25 75 26 209 75 209 80 45 78 35 110 242 202 30 130 202 106 225 183 8 151 189 72 150 237 191 206 46 119 12 177 5 81 86 162 152 143 29 158 103 241 40 76 65 114 245 198 231 24 29 180 212 109 56 12 55 204 92 123 240 63 124 194 160 36 38 199 236 148 244 184 98 242 75 13 203 243 190 86 35 119 234 249 174 178 21 122 136 103 136 46 112 56 44 62 220 92 24 124 159 84 245 142 21 209 56 205 183 187 168 197 146 107 148 57 93 110 42 41 182 160 83 36 199 182 93 191 248 224 166 170 147 143 201 21 51 42 235 9 81 193 226 52 45 121 120 94 239 22 253 39 27 198 183 39 67 107 43 174 65 180 229 184 128 215 81 166 191 161 207 15 107 124 74 106 200 110 48 7 33 233 57 248 102 5 241 219 65 152 60 220 56 47 193 8 53 14 174 4 81 93 254 88 59 209 31 12 165 208 185 53 178 113 12 193 61 80 70 51 122 113 34 29 236 155 119 62 187 129 110 18 244 159 47 216 76 29 168 177 138 124 80 215 220 28 47 80 219 9 39 130 105 8 245 82 185 51 109 58 104 133 200 194 74 128 153 124 140 25 212 46 199 17 35 185 134 216 247 42 189 68 2 200 68 60 181 129 216 25 44 187 135 230 235 147 102 121 37 66 47 110 123 253 21 83 65 120 102 70 2 23 90 25 61 45 249 248 174 60 182 186 153 124 179 252 210 126 225 63 180 2 159 113 44 88 173 215 239 103 224 196 193 231 170 119 227 106 120 98 234 198 44 233 17 112 9 203 178 134 215 177 95 30 215 105 70 189 15 16 8 210 42 223 189 170 43 56 146 211 189 12 81 103 174 101 26 147 68 240 45 64 22 172 40 97 40 129 25 98 48 219 244 135 13 93 163 105 64 28 193 67 8 239 241 26 30 218 148 178 92 95 172 126 113 154 37 213 120 155 5 96 143 52 203 246 60 255 23 133 251 90 80 184 215 94 14 35 226 114 209 63 105 224 231 246 6 73 136 28 34 177 78 242 57 228 135 108 104 144 48 142 238 199 230 86 199 179 222 57 208 179 209 231 82 222 98 101 254 229 8 185 213 235 117 220 132 6 116 38 237 23 227 205 0 60 69 43 81 3 64 33 183 171 158 60 100 223 63 184 147 252 84 228 166 102 130 46 149 190 130 206 254 174 228 193 78 71 62 122 252 60 56 231 128 120 139 143 36 38 68 3 109 58 4 58 82 31 109 197 211 56 176 126 70 33 112 81 201 58 231 88 18 7 178 168 179 225 94 112 231 52 93 71 28 68 99 155 211 101 195 165 121 208 115 189 190 254 164 155 118 20 228 86 219 221 220 47 193 102 12 195 159 148 12 108 236 226 110 105 223 169 115 43 174 84 183 120 219 130 103 117 123 249 249 248 229 184 135 216 186 90 124 151 185 105 67 38 223 126 180 175 103 89 83 228 36 34 144 185 71 236 79 213 67 75 96 34 81 88 68 27 193 161 27 225 48 228 91 242 83 216 196 238 38 5 136 81 104 99 174 78 41 226 89 67 102 168 52 98 209 41 213 41 219 229 50 245 250 86 170 149 218 44 178 0 204 157 61 193 38 204 227 134 99 116 45 37 53 156 133 81 0 224 166 93 57 92 235 8 143 228 164 57 24 31 236 70 229 198 43 96 24 247 81 36 210 148 107 26 182 43 60 112 78 75 26 82 238 109 60 134 32 0 148 210 106 59 221 255 221 248 124 235 235 231 201 242 163 145 180 174 12 219 5 176 54 19 189 119 40 20 232 177 182 116 239 183 108 73 185 104 103 112 44 61 53 137 190 135 160 216 66 223 140 190 56 174 227 250 106 119 94 174 197 223 214 81 148 199 105 191 143 180 74 189 105 238 91 211 71 181 150 166 201 114 127 97 125 125 4 74 146 10 227 86 179 126 10 227 40 41 146 63 4 139 163 200 245 209 102 122 24 163 190 10 27 80 206 190 222 59 31 252 104 44 167 216 242 110 166 245 113 205 219 194 92 102 88 235 10 211 187 20 225 4 63 197 19 77 131 24 67 200 124 155 46 35 48 139 87 156 191 151 93 83 115 31 186 147 241 169 119 121 65 227 83 165 145 164 222 208 13 211 176 88 30 249 165 195 114 24 200 229 79 111 54 64 41 230 138 224 119 9 10 96 167 14 68 246 111 32 164 88 65 155 0)! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 12/1/2000 22:26'!macNetworkFile	^ '#include <ConditionalMacros.h>#if TARGET_CPU_PPC || GENERATINGPOWERPC#if TARGET_API_MAC_CARBON	#define OTCARBONAPPLICATION 1#endif#include <OpenTransport.h>#include <OpenTptInternet.h>#include <OpenTptClient.h>#include <stropts.h>#include <Gestalt.h>#include <TextUtils.h>#include <files.h>#if !!TARGET_API_MAC_CARBON    #ifndef NewOTNotifyUPP    	typedef struct OTConfiguration* OTConfigurationRef;    	#define OTNotifyUPP OTNotifyProcPtr     	#define NewOTNotifyUPP(userRoutine) userRoutine    	#define DisposeOTNotifyUPP(userRoutine)    #endif#endif#include "sq.h"#include "SocketPlugin.h"//#define OTSERVER/*  May 1st 2000	An Open Transport 2.0 version of source code for TCP/IP & UDP support	Some of this the code was descended from Apple sample source written by: Eric Okholm	However getting it to work was done by	John M Mcintosh of Corporate Smalltalk Consulting Ltd	johnmci@smalltalkconsulting.com 	http://www.smalltalkconsulting.com 	In May of 2000 under contract to Disney		Some of the original source code was written by John Maloney of Disney thoughout the 1990''s		The basic intent was to make the code fully interrupt driven	No limits.... Well maybe we throttle read buffers to some parcel of memory to prevent us	from using all the memory on the box. Sends depend on lowerlayer buffering/flow control.	Testing from a 500Mhz PowerBook showed we could saturate a 100MB ethernet when sending data oneway.		UDP and TCP/IP are all supported.	Note for TCP we turn on two options IP_REUSEADDR, and IP_KEEPALIVE.	We do NOT handle T_EXDATA  data		V1.0 May 18th 2000, JMM (TCP/IP and UDP)	V1.1 May 19th 2000, JMM Cleanup	V1.2 may 20th 2000, JMM UDP free buffer cleanup, relook at resolver terminate to fix crash	V1.3 may 23rd 2000, JMM fix T_UDERR crash	V1.3.1 may 24th 2000, JMM UDP work	V1.3.2 may 25th 2000, JMM socket options work	V1.3.3 may 27th 2000, JMM rewrote resolver	V1.3.4 Jun 7th 2000, JMM some integration	V1.3.5 Jun 9th 2000, JMM Dan Ingalls found some interesting bugs with a T_GODATA on T_CONNECT.	V1.3.6 Jun 10th 2000, JMM fix a fatal but in close/close pattern I made on the 9th.	V1.3.7 Aug 1st 2000, JMM Some carbon work, reviewed open non-existent port logic fix so unavailable port causes immediate failure	V1.3.8 Aug 29th 2000, JMM Fix problem with recusion on make me an EP.	v1.3.9 Sept 28th 2000, JMM Problem with accept somewhere (so harden code)	v1.3.10 Oct 4th 2000, JMM Issue with destory and free buffers, and disconnect on read with buffer restriction	v1.3.11 Nov 11th 2000, JMM extra buffer for server version		Notes beware semaphore''s lurk for socket support. Three semaphores lives in Smalltalk, waiting for	connect/disconnect/listen, sending data, and receiving data. When to tap the semaphore is based on	inferences driven from the smalltalk code. We really need a call to tell us intent.		waitForDisconnectUntil:	    via closeAndDestroy: after primSocketCloseConnection:	    	waitForDataUntil:	    Usually before primitiveSocketReceiveDataBufCount: after checking SocketReceiveDataAvailable	    	waitForSendDoneUntil:	    via sendData: or sendSomeData:startIndex;count: before calls to primitiveSocketSendDataBufCount	    	waitForConnectionUntil:	    via waitForAcceptUntil and many places afer doing primitiveSocketConnectToPort*/								/*** Socket Type Constants ***/#define TCPSocketType 0#define UDPSocketType 1#define TCPListenerSocketType 2   //These are special to enable the right options for listening. Not Exposed to Smalltalk#define UDPListenerSocketType 3   //Very special not really linked to an EP structure.  Not Exposed to Smalltalk/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3#define RESOLVER_NAMETOADDR     4#define RESOLVER_ADDRTONAME     5/*** TCP Socket Status Constants ***/#define InvalidSocket           -1#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4	// Overall program statesenum{	kProgramRunning		= 1,	kProgramDone		= 2};	// Bit numbers in EPInfo stateFlags fieldsenum{	kOpenInProgressBit				= 0,  	kUnConnected    				= 1,	kWaitingForConnection           = 2,	kConnected                      = 3,	kSendIsBlocked                  = 4,    kOtherEndClosed                 = 5,    kThisEndClosed                  = 6,	kPassconBit                     = 7};	// Bit numbers in EPInfo stateFlags2 fieldsenum{	kFlushDisconnectInProgressBit	= 0,	kMakeEPIdle                     = 1,	kEPIsBroken                     = 2,	kReadFlowControl                = 3,	kPassconNeeded                  = 4,	kTapSemaphore                   = 5,	kTapSemaphoreReadData           = 6,	kTapSemaphoreWriteData          = 7};	// Bit numbers in EPInfo stateFlags3 fieldsenum{    kKeepAliveOptionNeeded          = 0,    kSleepKilledMe                  = 1,    kWaitingForBind                 = 2}; enum{	kOTVersion111				= 0x01110000,	kOTVersion112				= 0x01120000,	kOTVersion113				= 0x01130000,	kOTVersion130				= 0x01300000};const kTCPKeepAliveInMinutes		= 10;		// 10 minutes  keep alive#ifdef OTSERVERconst kReadBuffersToAllocate	    = 256;		// Memory Allocation issue how big, this means 256x mtu size * 4 But for 68K we do 1/2 size#elseconst kReadBuffersToAllocate	    = 50;		// Memory Allocation issue how big, this means 50x mtu size * 4 But for 68K we do 1/2 size#endif	// Endpoint Info Structurestruct EPInfo{	EndpointRef		erf;				//	actual endpoint	OTLink			link;				//	link into an OT LIFO (atomic)	OTLink          globalLink;         //  link that follows all allocated EPs    SInt32          outstandingSends;   //  number of sends outstanding    OTList          readBuffers;        //  Read buffers    SInt32          bytesPendingToRead; //  bytes outstanding to read	SInt32			semaIndex;			//	semaphore index	SInt32          readSemaIndex;      //  read semaphore	SInt32          writeSemaIndex;     //  write semaphore	SInt32          UDPMaximumSize;     //  max size if a UDP endpoint	SInt32			lastError;          //  last error code	UInt8			stateFlags;			//	various status fields	UInt8			stateFlags2;		//	various status fields	UInt8			stateFlags3;		//	various status fields	UInt8           socketType;         //  type of socket, tcp, udp, or tcp/udp listener	InetAddress     localAddress;       //  local address at bind time (ignored used call to get current)	InetAddress     remoteAddress;      //  remote address at connect (ignored used call to get current)	Boolean         UDPMoreFlag;        //  UDP more of datagram flag set    };typedef struct EPInfo EPInfo;struct ReadBuffer                       // Structure to contain read data.{	OTLink			fNext;				//	link into an OT FIFO 	UInt32          readBufferSize;	UInt32			readBufferOriginalSize;  	char *          readBufferData;	char *          readBufferPtr;      //Sliding pointer used to partial read buffer.    InetAddress     UDPAddress;         //UDP address	Boolean         UDPMoreFlag;        //UDP more of datagram flag set};typedef struct ReadBuffer ReadBuffer;struct TKeepAliveOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpKeepAliveOn;	UInt32		tcpKeepAliveTimer;};typedef struct TKeepAliveOpt TKeepAliveOpt;struct TLingerOpt                    {	UInt32		len;	OTXTILevel	level;	OTXTIName	name;	UInt32		status;	UInt32		tcpLingerOn;	UInt32		tcpLingerTimer;};typedef struct TLingerOpt TLingerOpt;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;EPInfo*				gDNSResolver;               //Our resolverSInt32				gDNSResolverStatus 			= RESOLVER_UNINITIALIZED;SInt32				gDNSResolverError			= noErr;SInt32			    gDNSResolverSemaIndex;      //This gets changed at startup time.InetHostInfo		gDNSHostInfo;InetDomainName 		gDNSAddrStr;                //Length of domain names? Old code was 512, but specs say 256.InetHost			gDNSAddr;SInt32              gDNSLookupType;OTConfigurationRef	gCfgMastertcp				= NULL;OTConfigurationRef	gCfgMasterudp				= NULL;OTConfigurationRef	gCfgMasterListener			= NULL;OTLIFO				gFreeReadBuffersLIFO;    	//  Buffers that are free to read intoOTLIFO*				gFreeReadBuffers			= &gFreeReadBuffersLIFO;SInt32				gFreeReadBuffersCounter		= 0;SInt32				gSocketsAllocated			= 0;UInt32				gmtuSize 					= 1024; //This gets changed at startup time.SInt32				gthisNetSession 			= 0;    //This gets changed at startup time.SInt32				gMaxConnections				= 0;    //This gets changed at startup time.UInt32				gOTVersion;                         //Gets set to OT version, to help us with special cases.SInt32				gProgramState				= 0;    //This gets changed at startup time.OTLIFO				gIdleEPLIFO[3];OTLIFO*				gIdleEPs[3];SInt32              gIdleEPCounter[3];OTLIFO				gBrokenEPLIFO;OTLIFO*				gBrokenEPs					= &gBrokenEPLIFO;OTLIFO				gAllEPLIFO;OTLIFO*				gAllEPs					    = &gAllEPLIFO;OTNotifyUPP DNSNotifierUPP,NotifierSocketUPP,NotifierSocketUDPUPP,NotifierSocketListenerUPP;/*** Private TCP Socket Functions ***//*** Private Resolver Functions ***/static void 		ResolverInitialize();static void		    ResolverTerminate(void);static void 		ResolverStart ();/*** Other Private Functions ***/void               CFMTerminate (void);static Boolean	   DestroyAllOpenSockets(void);static Boolean	   SocketValid(SocketPtr s);static Boolean     PortNumberValid(InetPort port) ;static SInt32      unmapStatus(EPInfo *);static void        Recycle();static void        makeEPIdle(EPInfo *epi);static void        purgeReadBuffers(EPInfo *epi);static void        makeEPBrokenThenIdle(EPInfo* epi,OTResult error);static void        makeEPBroken(EPInfo* epi,OTResult error);static EPInfo*     getOrMakeMeAnEP(UInt8 aSocketType,short counter);static Boolean     makeMeAnEP(UInt8 aSocketType);static void        attemptToCloseAndDeleteThisEP (EPInfo *epi);static void		   makeEPUnconnected(EPInfo* epi);static void        SetEPLastError(EPInfo* epi,OTResult error);static void        TapAllInterestedSemaphores(EPInfo *epi);int 				socketInit(void);int 				socketShutdown(void);static pascal void  DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie);static pascal void  NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie);static SInt32       internalSocketCreate(SocketPtr s, SInt32 netType, SInt32  socketType, SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint);static Boolean		EPOpen(EPInfo* epi);static Boolean 		EPClose(EPInfo*);static void         DoListenAccept(EPInfo* acceptor,EPInfo* theServer);static void         DoConnect(EPInfo* epi,InetHost addr, InetPort port);static void         DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint, OTQLen queueDepth );static UInt32       ReadData(EPInfo* epi, char* specialBuffer, UInt32 specialBufferSize);static OTResult     SendData(EPInfo* epi, char* buffer, UInt32 size);static OSStatus     doAbortConnection(EPInfo* epi);static void         NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo);static UInt32       readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize);static UInt32       readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int *moreFlag, char *buf,UInt32 adjustedBufSize);static SInt32	    lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result);static OTResult     SetFourByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetOneByteOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetKeepAliveOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);static OTResult     SetLingerOption(EPInfo* epi, Boolean trueIfGet, OTXTILevel level,  OTXTIName  name, UInt32 value, SInt32    *result);// Some diagnostic routinesvoid JMMLogMessage(Str255 input);void JMMLogMessageAndNumber(Str255 msg,long number);void JMMWriteLog();/*** Network Functions ***/int socketInit() {	//	//Don''t actually do any network work until we are newworked initialized	//This prevents kicking off internet dialup connections until needed	//	return true;}int socketShutdown() {	CFMTerminate();	return true;}int sqNetworkInit(int resolverSemaIndex) {	//	//  Initialize the network and return 0 if successful	//  Loads Open transport, allocates memory for read buffers and various other tasks	//		SInt32              i;	OSStatus            err = noErr;	InetInterfaceInfo   interfaceInformation;	UInt8               aSocketType;    ReadBuffer          *readBufferObject;    long				check68KorPPC;	    	if (gthisNetSession !!= 0) return 0;  /* noop if network is already initialized */		err = InitOpenTransport(); 	if (err) {		return -1;	}			err = Gestalt(gestaltOpenTptVersions, (long*) &gOTVersion);		if (err || (gOTVersion < kOTVersion112))	{		// Please install Open Transport 1.1.2 or later		// This might change to 1.3 since tech notes talked about 		// previous versions having problems with acksend logic.		//		return -111;	}		err = Gestalt(gestaltSysArchitecture, (long*) &check68KorPPC);	gProgramState = kProgramRunning;    //     //Setup the head of the idle queues    //    	for (i=0;i<3;i++) {	    gIdleEPs[i] = &gIdleEPLIFO[i];	    gIdleEPs[i]->fHead	   = NULL;	    gIdleEPCounter[i]      = 0;	}	gBrokenEPs->fHead 		= NULL;	gFreeReadBuffers->fHead = NULL;	gAllEPs->fHead          = NULL;			gMaxConnections			= 24; // Build 8 of each of listeners, tcp, udp.	    DNSNotifierUPP = NewOTNotifyUPP(DNSNotifier);    NotifierSocketUPP = NewOTNotifyUPP(NotifierSocket);    NotifierSocketUDPUPP = NewOTNotifyUPP(NotifierSocketUDP);    NotifierSocketListenerUPP = NewOTNotifyUPP(NotifierSocketListener);		gDNSResolver = (EPInfo*) OTAllocMem(sizeof(EPInfo));	if (gDNSResolver == NULL) return -1;			gDNSResolverSemaIndex = resolverSemaIndex;	ResolverInitialize();		/* Get MTU and default selected host address */		OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);    gmtuSize = interfaceInformation.fIfMTU;    		//	//	Open endpoints 	//	gCfgMastertcp = OTCreateConfiguration(kTCPName);	if (gCfgMastertcp == NULL) return -3;		gCfgMasterudp = OTCreateConfiguration(kUDPName);	if (gCfgMasterudp == NULL) return -4;		gCfgMasterListener = OTCreateConfiguration("tilisten, tcp"); //Note use of special tilisten logic	if (gCfgMasterListener == NULL) return -5;		//	//Build all our EPs, lots of work happens lower down asyncronously	//	aSocketType = TCPSocketType;	for (i = 0; i < gMaxConnections; i++)	{		makeMeAnEP(aSocketType);		aSocketType = ++aSocketType > 2 ? TCPSocketType : aSocketType;	} 	#ifdef OTSERVER	for (i = 0; i < 256; i++)	{		makeMeAnEP(TCPSocketType);	} #endif	//	//Build storage objects for read buffers	//How much memory to allocate still is a mystery	//    for (i=0;i<kReadBuffersToAllocate ;i++) {         readBufferObject = OTAllocMem(sizeof(ReadBuffer));        if (readBufferObject == nil) {       	    interpreterProxy->success(false);            return -25;        }                 OTMemzero(readBufferObject,sizeof(ReadBuffer));        if (gestalt68k == check68KorPPC)         	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*2 : 1024;        else        	readBufferObject->readBufferOriginalSize = (gmtuSize > 0) ? gmtuSize*4 : 1024;                readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(readBufferObject->readBufferOriginalSize);        if ( readBufferObject->readBufferData == nil) {       	    interpreterProxy->success(false);            return -25;        }        OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext);		gFreeReadBuffersCounter++;    }	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	gthisNetSession = clock() + time(NULL);	if (gthisNetSession == 0) gthisNetSession = 1;  /* don''t use 0 */		return 0;}void CFMTerminate (void)    /* termination either via a CFM or Squeak call*/{     sqNetworkShutdown();}void sqNetworkShutdown(void) {	/* shut down the network */    	if (gthisNetSession == 0) return;  /* noop if network is already shut down */	gthisNetSession = 0;	gProgramState = kProgramDone;	DestroyAllOpenSockets();	CloseOpenTransport(); }/*** Resolver Functions ***/static void	ResolverInitialize() {	OSStatus err;		//	//	Prepare to open internet services	//  to invoke DNR services	//		OTMemzero(gDNSResolver, sizeof(EPInfo));	    gDNSResolver->erf = OTOpenInternetServices(kDefaultInternetServicesPath, 0, &err);    gDNSResolver->semaIndex = gDNSResolverSemaIndex;		if (err !!= kOTNoError) {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;		return;	}	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError = kOTNoError;    err =  OTSetAsynchronous(gDNSResolver->erf);    err =  OTSetNonBlocking(gDNSResolver->erf);    err =  OTInstallNotifier(gDNSResolver->erf, DNSNotifierUPP, gDNSResolver);}static void ResolverStart () {	OSStatus err;	//	// Invoke DNR service Async, this meants the DNSNotifier will handle the actual 	// lookup and work, flags like the gDNSResolverStatus are used to indicate back	// to Squeak when the work is done	//	if (gDNSResolver->erf == NULL) //Sleep fix, other endpoints are more explicit about this issue. 	    ResolverInitialize();	    	gDNSResolverStatus  = RESOLVER_BUSY;	switch (gDNSLookupType) {		case RESOLVER_NAMETOADDR: {		    err = OTInetStringToAddress((InetSvcRef)gDNSResolver->erf, gDNSAddrStr, &gDNSHostInfo);			break;		}		case RESOLVER_ADDRTONAME: {			err = OTInetAddressToName((InetSvcRef)gDNSResolver->erf, gDNSAddr, gDNSAddrStr);			break;		}    }	if (err !!= kOTNoError)  {		gDNSResolverStatus = RESOLVER_ERROR;		gDNSResolverError = err;	}}void ResolverTerminate(void) {    //JMM if the resolver is opening what happens? 	gDNSResolverStatus = RESOLVER_UNINITIALIZED;   	if (gDNSResolver->erf == NULL) return;	EPClose(gDNSResolver);	OTMemzero(gDNSResolver, sizeof(EPInfo));}void sqResolverAbort(void) {	//	// Abort this running resolver request	//	if (gDNSResolverStatus == RESOLVER_BUSY) {		ResolverTerminate();		ResolverInitialize();	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	//	// copy the name found by the last address lookup into the given string 	//		OTMemcpy(nameForAddress, gDNSAddrStr, (UInt32) nameSize);	}int sqResolverAddrLookupResultSize(void) {	//	// return the length of the looked up name	//	return (long) strlen(gDNSAddrStr);}int sqResolverError(void) {	//	// Return OT error number	//	return gDNSResolverError; }int sqResolverLocalAddress(void) {    //    // Watch out for dynamic changing of this information, so don''t cache    //	InetInterfaceInfo interfaceInformation;	OTInetGetInterfaceInfo (&interfaceInformation,kDefaultInetInterface);	gDNSResolverStatus = RESOLVER_SUCCESS;	gDNSResolverError  = noErr;	return (long) interfaceInformation.fAddress;}int sqResolverNameLookupResult(void) {	//	// Return address from last lookup	//    	return (int) gDNSAddr;}void sqResolverStartAddrLookup(int address) {	//	// start process to lookup name from address	//    	if (gDNSResolverStatus == RESOLVER_BUSY) return;	gDNSAddr            = (InetHost) address;    gDNSLookupType      = RESOLVER_ADDRTONAME;	ResolverStart();}void sqResolverStartNameLookup(char *hostName, int nameSize) {	//	// start process to lookup address from name	//    	UInt32 len; 	if (gDNSResolverStatus == RESOLVER_BUSY) return;	len = (UInt32) ((nameSize <= kMaxHostNameLen) ? nameSize : kMaxHostNameLen);  //Old limit was 500  but that appeared to be wrong	OTMemcpy(gDNSAddrStr, hostName, len);	gDNSAddrStr[len]    = ''\0'';    gDNSLookupType      = RESOLVER_NAMETOADDR;	ResolverStart();	}int sqResolverStatus(void) {	//	// return resolver status, this is different from resolver error code	// status is the same among implementations, error is implementation dependent	//    	return gDNSResolverStatus;}//================================// Socket logic //void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {				//	//Old call from old image using new VM	//Just make new call	//	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  		 s,  netType,  socketType, recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex)	{     OSErr error;      netType; recvBufSize; sendBufSize;            //    //Create a socket given the supplied information    //We don''t bind the socket to a local port  until     //we do the connection. This of course could change?     //        error = internalSocketCreate( s, netType, socketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, (UInt8) socketType);    if (error !!= noErr) {		interpreterProxy->success(false);         return;       }}static SInt32 internalSocketCreate(  SocketPtr s, SInt32 netType, SInt32 socketType,  SInt32 recvBufSize, SInt32 sendBufSize, SInt32 semaIndex, SInt32 readSemaIndex, SInt32 writeSemaIndex, UInt8 aExtraSocketHint)	{  //  // Internal logic to open a socket for a connection or to listen  // Note how we ignore buffer sizes!!  //    EPInfo*     epi;    socketType; netType; recvBufSize; sendBufSize;        //    //Make the socket invalid and then get an idle EP    //Technically we only run out of EP when we run out of memory    //    	s->sessionID = 0;	if (gProgramState !!= kProgramRunning ) {			    interpreterProxy->success(false);        return -1;    }	epi = getOrMakeMeAnEP(aExtraSocketHint,0);	if (epi == NULL) {		interpreterProxy->success(false);		return -1;	}	epi->outstandingSends   = 0;	epi->bytesPendingToRead = 0;	epi->semaIndex          = semaIndex;	epi->readSemaIndex      = readSemaIndex;	epi->writeSemaIndex     = writeSemaIndex;	epi->stateFlags         = 0;	epi->stateFlags2        = 0;	epi->stateFlags3        = 0;	SetEPLastError(epi,noErr);	epi->socketType        = aExtraSocketHint;	OTInitInetAddress(&epi->remoteAddress, 0, 0);    OTInitInetAddress(&epi->localAddress, 0, 0);        if (aExtraSocketHint == UDPSocketType)        OTAtomicSetBit(&epi->stateFlags, kConnected); //udp is always connected     else        OTAtomicSetBit(&epi->stateFlags, kUnConnected);  	s->sessionID            = gthisNetSession;	s->socketType           = (aExtraSocketHint == UDPSocketType) ? UDPSocketType : TCPSocketType;	s->privateSocketPtr     = epi;	gSocketsAllocated++;	return 0;}void sqSocketListenOnPort(SocketPtr s, int port) {    //    //Listen on port for a connection, this is not the approved method    //sqSocketListenOnPortBacklogSize is the best way if you are a server    //However this works ok for UDP and kinda for onetime connections in TCP    //    EPInfo* epi;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,1);		if (epi->localAddress.fPort !!= port) {//We die if we don''t get the port we want            sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp		DoBind(epi,0,(InetPort) port,UDPListenerSocketType,1);	}}void	sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {    EPInfo* epi;	SInt32 sema,readSema,writeSema;	OSErr error;    //    //Listen on port for a connection, this is the best method if you are    //a server. Works in conjunction with accept. Shouldn''t drop connections    //OT''s special listener logic queues up the listen requestions    //	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	if (s->socketType == TCPSocketType) {		epi = (EPInfo *) s->privateSocketPtr;		sema = epi->semaIndex; readSema = epi->readSemaIndex; writeSema = epi->writeSemaIndex;	    makeEPIdle(epi); //Special case really need a listener EP, so put this EP back on the queue	    				 //This may seem odd but the epi is allocated before we know what type it is.	    				 //Would need to change Squeak to indicate type at creation!!		error = internalSocketCreate( s, 0, TCPSocketType, 0,  0, sema, readSema, writeSema, TCPListenerSocketType);		if (error !!= noErr) {            interpreterProxy->success(false);             return;   		}        epi = (EPInfo *) s->privateSocketPtr;		DoBind(epi,0,(InetPort) port,TCPListenerSocketType,(OTQLen) backlogSize);		if (epi->localAddress.fPort !!= port) {//The port we wanted must match, otherwise we die		    sqSocketDestroy(s);    	    interpreterProxy->success(false);		}	} else {//udp not allowed       	    interpreterProxy->success(false);	}}void	sqSocketAcceptFromRecvBytesSendBytesSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex){	//	//Old call from old image using new VM	//Just make new call	//	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			 s,  serverSocket,  recvBufSize,  sendBufSize,  semaIndex,  semaIndex,  semaIndex);		}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {	//	//Accept incoming request from a listener	//We take information from the listener, create a new socket	//and accept the incoming call	//	    EPInfo* epiSocket;    EPInfo* epiServerSocket;    Boolean	doLeave;    OSErr   error;    long	count=0;    	if (!!SocketValid(serverSocket)) return;	if (serverSocket->socketType == TCPSocketType) {            error = internalSocketCreate( s, 0, TCPSocketType, recvBufSize,  sendBufSize, semaIndex, readSemaIndex, writeSemaIndex, TCPSocketType);		    if (error !!= noErr) {        		interpreterProxy->success(false); 		        return;   		    }		    epiSocket = (EPInfo *) s->privateSocketPtr;    		DoBind(epiSocket,0,0,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE    		while (count++ < 100 && (OTAtomicTestBit(&epiSocket->stateFlags3, kWaitingForBind) == true)) {			    SystemTask(); OTIdle();            }		    OTAtomicSetBit(&epiSocket->stateFlags2, kPassconNeeded);		    epiServerSocket = (EPInfo *) serverSocket->privateSocketPtr;			OTAtomicSetBit(&epiServerSocket->stateFlags, kWaitingForConnection);			OTAtomicSetBit(&epiServerSocket->stateFlags, kUnConnected);            OTAtomicClearBit(&epiServerSocket->stateFlags, kConnected);    	    OTAtomicSetBit(&epiServerSocket->stateFlags2, kTapSemaphore);        	        	doLeave = OTEnterNotifier(epiServerSocket->erf);        	DoListenAccept(epiSocket,epiServerSocket);        	if (doLeave)        		OTLeaveNotifier(epiServerSocket->erf);	} else { //udp		interpreterProxy->success(false); 	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {    //    //Connect this socket to the given host addr and port    //    EPInfo* epi;	OTResult	epState;	if (!!SocketValid(s) || !!PortNumberValid((InetPort) port)) return;	epi = (EPInfo *) s->privateSocketPtr;	if (s->socketType == TCPSocketType) {    	DoBind(epi,(InetHost) addr,(InetPort) port,TCPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect	} else {//udp		epState = OTGetEndpointState(epi->erf);		if (epState == T_UNBND) {//Bind to remote, our side gets wildcarded    	    DoBind(epi,(InetHost) addr,(InetPort) port,UDPSocketType,0); // interrupt driven to  T_TBINDCOMPLETE which drives T_CONNECT/DoConnect    	} else {//Already bound to a port/interface on our side    	    OTInitInetAddress(&epi->remoteAddress, (InetPort) port, (InetHost) addr);    	}	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	//	// Send data really fast	// We create a copy of the data and give it to OT to play with	// We can get flow controlled lower down, if no flow control then we	// tap the semiphore since from squeaks viewpoint data is sent, otherwise when flow control is lifted the	// semaphore is tapped in the notification routine	//	OTResult res ;    EPInfo* epi;    Boolean doLeave;    char * buffer; 	UInt32 adjustedBufSize = bufSize > 65536 ? 65536 : (UInt32) bufSize; //? Not sure if we really need to do this limiting.   		if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;		// If send is blocked wait for unblocking	if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    return 0;	}    if (epi->socketType == UDPSocketType) {        //UDP adjust the buffer size again        adjustedBufSize = (adjustedBufSize > epi->UDPMaximumSize) ?   epi->UDPMaximumSize : adjustedBufSize;     }	buffer = OTAllocMem(adjustedBufSize);	if (buffer == nil) {		//Well maybe we back off and wait awhile? 		//If we run out of memory and stress the box, well death lurks.		adjustedBufSize = 256;		buffer = OTAllocMem(adjustedBufSize);		if (buffer == nil) {		    interpreterProxy->success(false); //Death did lurk	        SetEPLastError(epi, -1);	        return -1;	    } 	}			OTMemcpy(buffer,(void*) buf,adjustedBufSize);    	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_GODATA    res = SendData(epi,buffer,adjustedBufSize);  	  	if (doLeave)		OTLeaveNotifier(epi->erf);		  	if (res < 0 ){	    SetEPLastError(epi, res);		interpreterProxy->success(false); //JMM just for testing	    return 0;	}	return res;}////New primitive for sending UDP data to a particular host/port//Avoids race conditions between binding and send in Smalltalk//int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) { sqSocketConnectToPort(s, address, port); return sqSocketSendDataBufCount(s, buf, bufSize);}////Abort the socket//void sqSocketAbortConnection(SocketPtr s) {    EPInfo* epi;   OSStatus err; 	if (!!SocketValid(s)) return;    if (s->socketType == UDPSocketType) {		interpreterProxy->success(false);         return;    }	epi = (EPInfo *) s->privateSocketPtr;	err = doAbortConnection(epi);}////Acutal abort logic//We need to flush the queues//Then do a disconnect//static OSStatus doAbortConnection(EPInfo* epi) {   SInt32		count = 0;   OSStatus     err = kOTNoError; 	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 ) {		//Do flush and wait for it to happen		//Should make sync?		//		if (epi->outstandingSends !!= 0) {		    err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		    while (count++ < 100 && (epi->outstandingSends !!= 0 || OTAtomicTestBit(&epi->stateFlags, kUnConnected) == false)) {			    OTIdle();            }	    }        makeEPBroken(epi,0);	    err = OTSndDisconnect(epi->erf, NULL);	}	    	if (err !!= kOTNoError) 	    return err;	else        return epi->lastError;}////Socket close logic//void sqSocketCloseConnection(SocketPtr s) {    EPInfo* epi;    OSStatus err; 	OTResult	epState;	OTResult	lookResult;    	if (!!SocketValid(s)) return;	epi = (EPInfo *) s->privateSocketPtr;    if (s->socketType == UDPSocketType) {//Handle udp and return        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);		err = OTUnbind(epi->erf);		if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBroken(epi,err);		}	    TapAllInterestedSemaphores(epi);	    return;    }    OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);	// old code is sync and doesn''t trigger semaphore 		epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {        OTAtomicSetBit(&epi->stateFlags, kThisEndClosed);        OTAtomicClearBit(&epi->stateFlags, kConnected);        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed); 	    TapAllInterestedSemaphores(epi);	    return;	}	else	    err = OTSndOrderlyDisconnect(epi->erf);	    	if (err == kOTNoError) {        if (OTAtomicTestBit(&epi->stateFlags, kOtherEndClosed)) {	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }	} else {// Could get kOTLookErr with T_DISCONNECT pending 		lookResult = OTLook(epi->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT) {        	err = OTRcvDisconnect(epi->erf, NULL);	        OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);	        OTAtomicClearBit(&epi->stateFlags, kConnected);	        OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);	        OTAtomicSetBit(&epi->stateFlags, kUnConnected);	        if (epi->outstandingSends !!= 0)	            doAbortConnection(epi);			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) { //kOTLookErr with T_DATA, book says response is to zap EP.			    makeEPBroken(epi,err);			}    	    TapAllInterestedSemaphores(epi);        }        else {            SetEPLastError(epi,err);    		makeEPBroken(epi,err);            TapAllInterestedSemaphores(epi);       }	}}////Destroy the socket here we must ensure we cleanup and put the //socket back on the idle or broken EP queue//void sqSocketDestroy(SocketPtr s) {    OTResult err;    EPInfo* epi;	OTResult	epState;    JMMWriteLog(); //Diagnostics, turned off, must fiddle recompile to turn on.          if (!!SocketValid(s)) {    	return;     }	epi = (EPInfo *) s->privateSocketPtr;   OTAtomicSetBit(&epi->stateFlags2, kMakeEPIdle); 	epState = OTGetEndpointState(epi->erf);	if (epState == T_UNINIT || epState == T_UNBND ) {	    makeEPIdle(epi); //Unbound already so make him idle.	} else {	    if (s->socketType == UDPSocketType)			err = OTUnbind(epi->erf);	    else 		    err = doAbortConnection(epi);			if (err !!= kOTNoError) {//kOTLookErr with T_DATA, book says response is to zap EP.		    makeEPBrokenThenIdle(epi,err);		}	}	purgeReadBuffers(epi); //JMM Oct 4th 2000 (bug?)	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;	gSocketsAllocated--; }////Check to see if bytes are available//int sqSocketReceiveDataAvailable(SocketPtr s)							{    EPInfo* epi;    static lastTickCount=0;	if (!!SocketValid(s)) return 0;    epi = (EPInfo *) s->privateSocketPtr;    if (epi->bytesPendingToRead > 0)         return 1;       if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) // New case if data pending but flow controlled then go get it        return 1;        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreReadData); //Note how we imply there will be interest in semaphore    return 0;}////Read data into the buffer supplied//int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {    EPInfo* epi; 	UInt32  bytesRead = 0;    Boolean doLeave;    	if (!!SocketValid(s)) return -1; 		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead = readBytes(epi,(char *) buf,(UInt32) bufSize);    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {        if (bytesRead > 0)             ReadData(epi,NULL,0);         else            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize); //special case attempt read into squeak buffer    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}////New primitive to read UDP data and get data, host/port, and more flag//int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {    EPInfo* epi; 	UInt32 bytesRead = 0;    Boolean doLeave;    InetAddress fromAddress;        OTMemzero(&fromAddress,sizeof(InetAddress));    *address  = 0;    *port = 0;    *moreFlag = 0;    	if (!!SocketValid(s)) return -1;		epi = (EPInfo *) s->privateSocketPtr;         	doLeave = OTEnterNotifier(epi->erf);  //Avoid race condition for T_DATA    bytesRead   = readBytesUDP(epi,&fromAddress, moreFlag, (char *) buf,(UInt32) bufSize);    *address    = fromAddress.fHost;    *port       = fromAddress.fPort;    if (OTAtomicTestBit(&epi->stateFlags2, kReadFlowControl)) {         if (bytesRead > 0)             ReadData(epi,NULL,0);         else {            bytesRead = ReadData(epi,(char *) buf,(UInt32) bufSize);//special case attempt read into squeak buffer            *address    = epi->remoteAddress.fHost; //Also we happen to know the address just when into this area            *port       = epi->remoteAddress.fPort; //JMM more flag?            *moreFlag   = epi->UDPMoreFlag;        }    }  	if (doLeave)		OTLeaveNotifier(epi->erf);   	return (int) bytesRead;}int sqSocketLocalAddress(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    return (int) (epi->localAddress.fHost == 0) ? sqResolverLocalAddress() : epi->localAddress.fHost;}int sqSocketLocalPort(SocketPtr s) {    EPInfo* epi;    	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;		return epi->localAddress.fPort;}int sqSocketRemoteAddress(SocketPtr s) {    EPInfo*     epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return (int) epi->remoteAddress.fHost;    }        //It seems the only reliable way to get the address    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return (int) remoteAddr.fHost;}int sqSocketRemotePort(SocketPtr s) {    EPInfo* epi;    TBind       remoteBind;    InetAddress remoteAddr;    SInt32        counter=0;    OSStatus    err;	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;	if (OTAtomicTestBit(&epi->stateFlags, kUnConnected) && 	    !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)) return 0;	    if (epi->socketType == UDPSocketType) {        return epi->remoteAddress.fPort;    }        //It seems the only reliable way to get the port    //Is to make a call    //    OTMemzero(&remoteBind,sizeof(TBind));    OTMemzero(&remoteAddr,sizeof(InetAddress));    remoteBind.addr.buf = (UInt8 *) &remoteAddr;    remoteBind.addr.maxlen = sizeof(InetAddress);    err = OTGetProtAddress(epi->erf,0,&remoteBind);    while (counter++ < 10 && remoteAddr.fHost == 0) {        OTIdle();    }        if (err !!= kOTNoError)         return 0;    else        return remoteAddr.fPort;}int sqSocketSendDone(SocketPtr s) {    EPInfo* epi;	if (!!SocketValid(s)) return 1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kSendIsBlocked)) {	    OTAtomicSetBit(&epi->stateFlags2, kTapSemaphoreWriteData); //Note the implied intent to use the semaphore        return 0;    }    else {        return 1;    }}int sqSocketError(SocketPtr s) {    EPInfo* epi;     	if (!!SocketValid(s)) return -1;	epi = (EPInfo *) s->privateSocketPtr;    if (OTAtomicTestBit(&epi->stateFlags, kUnConnected)  &&         !!OTAtomicTestBit(&epi->stateFlags, kWaitingForConnection)         && epi->lastError == 0)	    return kENOTCONNErr; // old code would return unconnectederror if unconnected	else	    return (epi->lastError);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return InvalidSocket;	return unmapStatus((EPInfo *) s->privateSocketPtr);}static SInt32 unmapStatus(EPInfo *s) {    if (OTAtomicTestBit(&s->stateFlags3, kSleepKilledMe))         {return  InvalidSocket;        }    if (OTAtomicTestBit(&s->stateFlags, kThisEndClosed))         {return  ThisEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kOtherEndClosed))         {return  OtherEndClosed;        }    if (OTAtomicTestBit(&s->stateFlags, kConnected))         { return  Connected;        }    if (OTAtomicTestBit(&s->stateFlags, kWaitingForConnection))         {return  WaitingForConnection;        }    if (OTAtomicTestBit(&s->stateFlags, kUnConnected))         {return  Unconnected;        }   return 0;}static Boolean SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == gthisNetSession) && 		(s->socketType == TCPSocketType || s->socketType == UDPSocketType) &&		(!!OTAtomicTestBit(&(((EPInfo *)s->privateSocketPtr)->stateFlags3), kSleepKilledMe)) )		    return true;	interpreterProxy->success(false);	return false;}static Boolean PortNumberValid(InetPort port) {	if (port <= 65535) {		return true;	}	interpreterProxy->success(false);	return false;}//Used to signal all semaphores when we''ve closed the socket//I guess the read/write/disconnect threads really want to know//static void TapAllInterestedSemaphores(EPInfo *epi) {    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);     if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData)) 	    interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex); 				}static Boolean DestroyAllOpenSockets(void) {	EPInfo      *epi;	OTLink*		link;    ReadBuffer *aBuffer;	//	//	Start closing connector endpoints.	//	While we could be rude and just close the endpoints, 	//	we try to be polite and wait for all outstanding connections	//	to finish before closing the endpoints.   The is a bit easier	//	on the server which won''t end up keeping around control blocks	//	for dead connections which it doesn''t know are dead.  Alternately,	//	we could just send a disconnect, but this seems cleaner.	//	(void)OTLIFOStealList(gBrokenEPs);	(void)OTLIFOStealList(gIdleEPs[0]);	(void)OTLIFOStealList(gIdleEPs[1]);	(void)OTLIFOStealList(gIdleEPs[2]);	    link = OTLIFODequeue(gAllEPs);    while (link !!= NULL) {        epi = OTGetLinkObject(link, EPInfo, globalLink);     	attemptToCloseAndDeleteThisEP(epi);        link = OTLIFODequeue(gAllEPs);    }	//	//	If the lists are empty now, then all endpoints have been successfully closed,	//	so the client is stopped now.  (Actually we hope that is the case)	//	    //    //Free up all the other resources    //    link = OTLIFODequeue(gFreeReadBuffers);    while (link !!= NULL) {    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer);         link = OTLIFODequeue(gFreeReadBuffers);    }    ResolverTerminate();	OTFreeMem((char*)gDNSResolver);	gIdleEPs[0]->fHead		= NULL;	gIdleEPs[1]->fHead		= NULL;	gIdleEPs[2]->fHead		= NULL;	gBrokenEPs->fHead 		= NULL;	OTDestroyConfiguration(gCfgMastertcp);	OTDestroyConfiguration(gCfgMasterudp);	OTDestroyConfiguration(gCfgMasterListener);	DisposeOTNotifyUPP(DNSNotifierUPP);	DisposeOTNotifyUPP(NotifierSocketUPP);	DisposeOTNotifyUPP(NotifierSocketUDPUPP);	DisposeOTNotifyUPP(NotifierSocketListenerUPP);	return true;}////	DoBind////	This routine either binds to a wild card address and specfic port if //  we are doing a listen, otherwise we bind to a wild card address and //  wild card port if we are starting a connection to a remote host.//  J M M NOTE A more complex version could use port and addr//  Note we don''t bind to the local socket until here, we could when //  The socket is created, but that leads to odd issues.//static void DoBind(EPInfo* epi,InetHost addr, InetPort port,UInt8 aExtraSocketHint,OTQLen queueDepth ){	OSStatus 	err;	TBind 		bindReq, bindResult;	InetAddress	inAddr,bindAddr;		switch (aExtraSocketHint) {        case TCPSocketType: {            // for a connection        	//	Bind the endpoint to a wildcard address         	//	(assign us a port, we don''t care which one).        	//  NOTE A more complex version could use port and addr            OTInitInetAddress(&epi->remoteAddress, port, addr);            OTInitInetAddress(&epi->localAddress, 0, kOTAnyInetAddress);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case UDPSocketType: {             // for a connection        	//	Bind the endpoint to earlier supplied information            OTInitInetAddress(&epi->remoteAddress, port, addr);        	OTInitInetAddress(&inAddr, 0, 0);            break;        }        case TCPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }        case UDPListenerSocketType: {            // For a listen, bind wild card address, but supplied port.            // Note the passed in addr should be zero            // Note a more complex version could supply the address            OTInitInetAddress(&epi->remoteAddress, 0, kOTAnyInetAddress);            OTInitInetAddress(&epi->localAddress, port, addr);        	OTInitInetAddress(&inAddr,port, addr);            break;        }	} 	bindReq.addr.len    	= sizeof(InetAddress);	bindReq.addr.buf    	= (unsigned char*) &inAddr;	bindReq.qlen        	= queueDepth; //Note queue depth for listening 	bindResult.addr.maxlen	= sizeof(InetAddress); 	bindResult.addr.len   	= sizeof(InetAddress);	bindResult.addr.buf    	= (unsigned char*) &bindAddr;	epi->stateFlags     	= 0;	epi->stateFlags2   		= 0;	epi->stateFlags3    	= 0;	epi->bytesPendingToRead = 0;	SetEPLastError(epi,noErr);	if (aExtraSocketHint == TCPSocketType|| aExtraSocketHint == TCPListenerSocketType) {        OTAtomicSetBit(&epi->stateFlags, kUnConnected);        OTAtomicSetBit(&epi->stateFlags, kWaitingForConnection);        OTAtomicSetBit(&epi->stateFlags2, kTapSemaphore);    }		OTAtomicSetBit(&epi->stateFlags3, kWaitingForBind);	err = OTBind(epi->erf, &bindReq, &bindResult); // resume at T_BINDCOMPLETE		// for bindReq on listen what is queueDepth now? 	// bindReq.qlen could have changed	// But... No why to feed this back to the client!!		if (err !!= kOTNoError) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);    	return;	}		OTMemcpy(&epi->localAddress,bindResult.addr.buf,sizeof(InetAddress)); //Pickup local address	return;}////	DoConnect////	This routine attempts establish a new connection to the given//	address and port.  //  Called via the notifier at interrupt time.//static void DoConnect(EPInfo* epi,InetHost addr, InetPort port){	OSStatus err;	TCall sndCall;	InetAddress inAddr;		//	Don''t want new connections if already shutting down.	if (gProgramState !!= kProgramRunning ) return;			OTInitInetAddress(&inAddr, port, addr);	OTMemzero(&sndCall, sizeof(TCall));	sndCall.addr.len 	= sizeof(InetAddress);					sndCall.addr.buf	= (unsigned char*) &inAddr;		err = OTConnect(epi->erf, &sndCall, NULL); //resume at T_CONNECT	if (err !!= kOTNoDataErr) {    	SetEPLastError(epi,err);        makeEPUnconnected(epi);		return;	}}////	DoListenAccept////	The handling of a T_LISTEN is greatly simplified by use//	of the tilisten module, which serializes inbound connections.//	This means that when doing an OTAccept we won''t get a kOTLookErr//	because another inbound connection arrived and created a T_LISTEN.//	Without the tilisten module, we have to use the "8 step //	listen/accept/disconnect method", which is documented elsewhere.//static void DoListenAccept(EPInfo* acceptor,EPInfo* theServer){	TCall		call;	InetAddress	caddr;	OTResult	lookResult;	OSStatus	err;				OTMemzero(&call, sizeof(TCall));	call.addr.maxlen = sizeof(InetAddress);	call.addr.buf = (unsigned char*) &caddr;			err = OTListen(theServer->erf, &call);	if (err !!= kOTNoError) {		//		//	Only two errors are expected at this point.		//	One would be a kOTNoDataErr, indicating the inbound connection		//	was unavailable, temporarily hidden by a higher priority streams		//	message, etc.   The more likely error is a kOTLookErr, 		//	which indicates a T_DISCONNECT on the OTLook()		//	happens when the call we were going to process disconnected.		//	In that case, go away and wait for the next T_LISTEN event.		//		if (err == kOTNoDataErr) return;					lookResult = OTLook(theServer->erf); 		if (err == kOTLookErr && lookResult == T_DISCONNECT)        	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);				//JMM Sept28th,2000 ? ok accept it, if we don''t does this cause blockage?		acceptor->remoteAddress = caddr;		err = OTAccept(theServer->erf, acceptor->erf, &call);		return;		}		acceptor->remoteAddress = caddr;		err = OTAccept(theServer->erf, acceptor->erf, &call);	//	//	Note an kOTIndOutErr can occur if we are listening on the EP and handling 	//  off to the same EP. Sorry use the listento:backlogqueue: logic instead    //	if (err !!= kOTNoError) {		//		//	Again, we have to be able to handle the connection being disconnected		//	while we were trying to accept it.		//		lookResult = OTLook(theServer->erf);		if (err == kOTLookErr && lookResult == T_DISCONNECT)         	err = OTRcvDisconnect(theServer->erf, NULL);		else 		    SetEPLastError(theServer,lookResult);	}}////	EPOpen:////	A front end to OTAsyncOpenEndpoint.//	A status bit is set so we know there is an open in progress.//	It is cleared when the notifier gets a T_OPENCOMPLETE where the context//	pointer is this EPInfo.  Until that happens, this EPInfo can''t be cleaned//	up and released.//static Boolean EPOpen(EPInfo* epi){	OSStatus err;		OTAtomicSetBit(&epi->stateFlags, kOpenInProgressBit);	SetEPLastError(epi,kOTNoError);    epi->UDPMaximumSize = 0; //Remember to figure out the max UDP size.    	switch (epi->socketType) {	    case TCPSocketType: {		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMastertcp), 0, NULL, NotifierSocketUPP, epi); 	        break;	    }	    case UDPSocketType: {	        TEndpointInfo endPointInformation;		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterudp), 0, &endPointInformation, NotifierSocketUDPUPP, epi); 		    epi->UDPMaximumSize = (endPointInformation.tsdu == T_INFINITE) ? 64*1024 : endPointInformation.tsdu;	        break;	    }	    case TCPListenerSocketType: {		    err = OTAsyncOpenEndpoint(OTCloneConfiguration(gCfgMasterListener), 0, NULL, NotifierSocketListenerUPP, epi); 	        break;	    }	}	if (err !!= kOTNoError) {		SetEPLastError(epi,err);		OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);		return false;	}	return (epi->lastError == kOTNoError);}////	EPClose////	This routine is a front end to OTCloseProvider.   //	Centralizing closing of endpoints makes debugging and instrumentation easier.  //static Boolean EPClose(EPInfo* epi){	OSStatus err;		//	//	If an endpoint is still being opened, we can''t close it yet.	//	There is no way to cancel an OTAsyncOpenEndpoint, so we just	//	have to wait for the T_OPENCOMPLETE event at the notifier.	//	if ( OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) )		return false;		    	//	//	If the OTAsyncOpenEndpoint failed, the endpoint ref will be NULL,	//	and we don''t need to close it now. Also can be NULL or should be NULL if sleeping happened.	//	if (epi->erf == NULL || OTAtomicClearBit(&epi->stateFlags3, kSleepKilledMe)) {	    epi->erf = NULL;		return true;	}			if (epi->outstandingSends == 0) {    	err = OTCloseProvider(epi->erf);    	epi->erf = NULL;    	return true;    }    	    //	//	If we get to this point, the endpoint did an OTSnd() with AckSends,	//	and the T_MEMORYRELEASED event hasn''t been returned yet.  In order	//	to make sure we get the event, we flush the stream and then do an	//	OTDisconnect().   This should get the memory freed so we can close	//	the endpoint safely.   Note, we set a flag so we don''t do this 	//	more than once on an endpoint.	//  J M M I''m not sure we''ll ever get here since a flush should have been done higher up	//	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )	{		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);		if (err !!= kOTNoError)			{} 	}	return false;}////	Recycle:////	This routine shouldn''t be necessary, but it is helpful to work around both//	problems in OpenTransport and bugs in this program.   Basicly, whenever an//	unexpected error occurs which shouldn''t be fatal to the program, the EPInfo//	is queued on the BrokenEP queue.  When recycle is called,//  it will attempt to close the associated endpoint and open//	a new one to replace it using the same EPInfo structure.   This process of//	closing an errant endpoint and opening a replacement is probably the most//	reliable way to make sure that this program and OpenTransport can recover//	from unexpected happenings in a clean manner.////  Mind you it can be invoked to cleanup UDP sockets that aren''t closed //  properly due to pending traffice on a busy port.//  Solution mentioned in books is to close the EP.//static void Recycle(){	OTLink* 	list = OTLIFOStealList(gBrokenEPs);	OTLink*		link;	EPInfo*		epi;	while ( (link = list) !!= NULL ) {		list = link->fNext;		epi = OTGetLinkObject(link, EPInfo, link);		if (!!EPClose(epi)) {			OTLIFOEnqueue(gBrokenEPs, &epi->link);			continue;		}		if (gProgramState == kProgramRunning)		    EPOpen(epi);		 else		    makeEPIdle(epi);	}}//// Make the EP idle, it either goes on an idle queue or gets broken.//static void    makeEPIdle(EPInfo *epi) {    purgeReadBuffers(epi);        if (OTAtomicClearBit(&epi->stateFlags2, kEPIsBroken)) {        OTLIFOEnqueue(gBrokenEPs, &epi->link);     } else {	    OTLIFOEnqueue(gIdleEPs[epi->socketType], &epi->link);    	    OTAtomicAdd32(1, &gIdleEPCounter[epi->socketType]);    }}static void attemptToCloseAndDeleteThisEP (EPInfo *epi) {    purgeReadBuffers(epi); 	if (!!EPClose(epi)) {		//	Can''t close this endpoint yet, so skip it.	} else 	    OTFreeMem((char*)epi);}static EPInfo* getOrMakeMeAnEP(UInt8 aSocketType,short counter) {	EPInfo      *epi;    OTLink		*link;    SInt32      i;        Recycle();  //Ensure broken EP get fixed up        if (counter > 25)         return nil;  // End recursion John 2000/8/29    if (gIdleEPCounter[aSocketType] < 5)   //Magic Number ensure we have at least 5 EP available.        makeMeAnEP(aSocketType);            link = OTLIFODequeue(gIdleEPs[aSocketType]);	if (link == NULL) {		for(i=0;i<10;i++) {OTIdle();};		return getOrMakeMeAnEP(aSocketType,counter+1); //Watch for recursive failure	}	   	OTAtomicAdd32(-1, &gIdleEPCounter[aSocketType]);	epi = OTGetLinkObject(link, EPInfo, link);		if (OTAtomicTestBit(&epi->stateFlags3, kSleepKilledMe)) {	//	//A broken epi on the idle stack, now the only way we can 	//get here (I think) is to have gone to sleep which breaks	//all the end points. To clean up we must now fix them	//So make it idle, of course it''s broken	//Then recursive call to get another one	//This continues until we get a good one	//  	    makeEPIdle(epi);	    return getOrMakeMeAnEP(aSocketType,counter);  //Not a recursion issue. 	}    return epi;}////This is where EP are actually made and opened//EP opening is async//static Boolean makeMeAnEP (UInt8 aSocketType) {	EPInfo      *epi;		epi = (EPInfo*) OTAllocMem(sizeof(EPInfo));	if (epi == NULL) return false;   //Death lurks	OTMemzero(epi, sizeof(EPInfo));  //zero it out which makes all the pointers null    epi->socketType = aSocketType;    OTLIFOEnqueue(gAllEPs, &epi->globalLink);	return EPOpen(epi);}static void makeEPUnconnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicSetBit(&epi->stateFlags, kUnConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection on error        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPConnected(EPInfo *epi) {	OTAtomicClearBit(&epi->stateFlags, kWaitingForConnection);	OTAtomicClearBit(&epi->stateFlags, kUnConnected);    OTAtomicSetBit(&epi->stateFlags, kConnected);    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphore)) //tap to clear waitforconnection        interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);}static void makeEPBrokenThenIdle(EPInfo* epi,OTResult error) {    makeEPBroken(epi,error);    makeEPIdle(epi);}static void makeEPBroken(EPInfo* epi,OTResult error) {    SetEPLastError(epi,error);    OTAtomicSetBit(&epi->stateFlags2, kEPIsBroken);}static void SetEPLastError(EPInfo* epi,OTResult error) {    if (error < 0) {		JMMLogMessageAndNumber("\p NonZero Error For ",epi->semaIndex);		JMMLogMessageAndNumber("\p NonZero Error Is  ",error);    }    epi->lastError = error;}//	ReadData:////	This routine attempts to read all available data from an endpoint.//	it is not necessary for the program to handle//	getting back a T_DATA notification DURING an OTRcv() call, as would be//	the case if we read from outside the notifier.   We must read until we//	get a kOTNoDataErr in order to clear the T_DATA event so we will get//	another notification of T_DATA in the future.//  Note we use EnterNotifier to make this possible////	Note for the curious we attempted to use no-copy receives to get data.  This obligates//	the program to return the buffers to OT asap.  BUT we found we overran memory!!//  So we reverted to more expensive copies into buffers we have preallocated////  Perhaps a seperate routine for UDP would make sense?//  Note May 30/00 we added a special read when we exhaust the internal buffer pool//  But data is still pending we allow you to read into the squeak buffer directly//static UInt32 ReadData(EPInfo* epi,char *specialReadBuffer,UInt32 specialReadSize) {	OTResult  	res;	OTFlags	  	flags;	OTResult	epState,err;	OTLink		*link;    ReadBuffer 	*readBufferObject,simulatedReadBuffer;    InetAddress UDPdataFromAddress;	    if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreReadData)) //tap to clear waitfordata Data Data Data        interpreterProxy->signalSemaphoreWithIndex(epi->readSemaIndex);            if (specialReadSize > 0) { //Special case drop into squeak buffer, make a simulated buffer object        OTMemzero(&simulatedReadBuffer,sizeof(ReadBuffer));        simulatedReadBuffer.readBufferData = specialReadBuffer;        simulatedReadBuffer.readBufferSize = simulatedReadBuffer.readBufferOriginalSize = specialReadSize;        readBufferObject = &simulatedReadBuffer;    } else {       link = OTLIFODequeue(gFreeReadBuffers);                	if (link == NULL) {           	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);  //NO free buffers we are flow controled        	return;     	}		gFreeReadBuffersCounter--;    	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);        OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl);      }        OTMemzero(&UDPdataFromAddress,sizeof(InetAddress));    	while (true) {        		readBufferObject->readBufferPtr = readBufferObject->readBufferData;		   	    if (epi->socketType == UDPSocketType) {   	        TUnitData 	UDPDataInBound;   	        OTFlags     flagMeaningMore;            OSStatus    error;                	    UDPDataInBound.addr.maxlen = sizeof(InetAddress);    	    UDPDataInBound.addr.len    = sizeof(InetAddress);    	    UDPDataInBound.addr.buf    = (UInt8*) &readBufferObject->UDPAddress;    	    UDPDataInBound.opt.maxlen  = 0;    	    UDPDataInBound.opt.len     = 0;    	    UDPDataInBound.opt.buf     = NULL;    	    UDPDataInBound.udata.maxlen = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.len    = readBufferObject->readBufferOriginalSize;    	    UDPDataInBound.udata.buf    = (UInt8*)readBufferObject->readBufferData;	    	        error =  OTRcvUData(epi->erf, &UDPDataInBound, &flagMeaningMore);	        	        if (error !!= kOTNoError) {	            res = error;	        } else {	            if (UDPDataInBound.addr.len == 0) //Remember UDP address	                readBufferObject->UDPAddress = UDPdataFromAddress;	            else	                UDPdataFromAddress = readBufferObject->UDPAddress;	                	            epi->UDPMoreFlag = readBufferObject->UDPMoreFlag = (flagMeaningMore > 0) ? true: false;	            res = (SInt32) UDPDataInBound.udata.len; 	            OTMemcpy(&epi->remoteAddress,&readBufferObject->UDPAddress,sizeof(InetAddress));  	        }   	    } else {//A less complicated tcp read   	        res = OTRcv(epi->erf, readBufferObject->readBufferData, readBufferObject->readBufferOriginalSize, &flags);   	    }   	    		//		//	Note, check for 0 because can get a real 0 length receive		//	in some protocols (not in TCP), which is different from		//	getting back a kOTNoDataErr.		//		if (res >= 0) {            if (specialReadSize > 0)                 return (UInt32) res; //Note special case                            readBufferObject->readBufferSize = (UInt32) res;                        OTAddLast(&epi->readBuffers,&readBufferObject->fNext); //Put the buffer on the read queue        	OTAtomicAdd32(res, &epi->bytesPendingToRead);            link = OTLIFODequeue(gFreeReadBuffers);                            	if (link == NULL) {               	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl); //Our read flow control, OT will block lower down            	return;         	}			gFreeReadBuffersCounter--;        	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);   			continue; //Loop around and get more bytes if available		}		else {            if (specialReadSize == 0) {                OTLIFOEnqueue(gFreeReadBuffers, &readBufferObject->fNext); //Read above didn''t work so put it back on free queue				gFreeReadBuffersCounter++;			}		}				if (res == kOTNoDataErr) {			//			//	Since ReadData is only called from inside the notifier			//	we don''t have to worry about having missed a T_DATA 			//	during the OTRcv.			//  Note use of EnterNotifier logic			//			if (specialReadSize > 0)			    OTAtomicClearBit(&epi->stateFlags2, kReadFlowControl); 			return 0;		}		if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_DISCONNECT) {				//	If we got the T_ORDREL, we won''t get any more inbound data.				//	We return and wait for the notifier to get the T_ORDREL notification.				//	Upon getting it, we will notice we still need to send data and do so.				//	The T_ORDREL has to be cleared before we can send. 				//				if (specialReadSize > 0 && res == T_DISCONNECT) {					//Special case? need to get disconnect 					err = OTRcvDisconnect(epi->erf, NULL);					makeEPUnconnected(epi);				}				return 0 ;			}			if (res == T_GODATA) {			    if (specialReadSize == 0) {    			    link = OTLIFODequeue(gFreeReadBuffers);                    	if (link == NULL) {                       	OTAtomicSetBit(&epi->stateFlags2, kReadFlowControl);                    	return 0 ;                 	}					gFreeReadBuffersCounter--;                	readBufferObject = OTGetLinkObject(link, ReadBuffer, fNext);            	} else {            	    return 0;            	}			    continue; //OT Flow control lifted keep reading. JMM			}		} else {			epState = OTGetEndpointState(epi->erf);			if (res == kOTOutStateErr && epState == T_INREL) {				//				//	Occasionally this problem will happen due to what appears				//	to be an OpenTransport notifier reentrancy problem.   				//	What has occured is that a T_ORDREL event happened and 				//	was processed during ReadData().   This is proven by being				//	in the T_INREL state without having done a call to				//	OTRcvOrderlyDisconnect() here.   It appears to be a benign 				//	situation, so the way to handle it is to understand that no				//	more data is going to arrive and go ahead and being our response				//	to the client.				//				break;			}			if (res == kOTOutStateErr && (epState == T_UNBND || epState == T_IDLE ) && specialReadSize > 0) {				  interpreterProxy->success(false); //JMM Oct 4th 2000 special case fail if read on unbound				  return 0;			}		break; //Ok error so break out of loop		}	}    return 0;	}//// NOT USED HISTORICAL REASONS// /*static void NoCopyReceiveWalkingBufferChain(EPInfo *epi,OTBufferInfo *bufferInfo){   OSStatus     err;   OTBuffer     *thisBuffer;   UInt32       count;   ReadBuffer   *readBufferObject;           thisBuffer = bufferInfo->fBuffer;    err = noErr;    while (err == noErr && thisBuffer !!= nil) {        count = thisBuffer->fLen;    	OTAtomicAdd32(count, &epi->bytesPendingToRead);		readBufferObject = OTAllocMem(sizeof(ReadBuffer));        if (readBufferObject == nil) {			SysBeep(5);            err = -1;            break;        }         OTMemzero(readBufferObject,sizeof(ReadBuffer));        readBufferObject->readBufferData = readBufferObject->readBufferPtr = OTAllocMem(count);        if ( readBufferObject->readBufferData == nil) {			SysBeep(5);             err = -1;            break;        }         readBufferObject->readBufferOriginalSize = readBufferObject->readBufferSize = count;        OTMemcpy(readBufferObject->readBufferData,thisBuffer->fData,count);        OTAddLast(&epi->readBuffers,&readBufferObject->fNext);        thisBuffer = thisBuffer->fNext;    }   // Clean up.  We MUST release the OTBuffer chain to Open Transport    // so that it crelease the OTBuffer chain to Open Transport    // so that it can reuse it., OTReleaseBuffer does not tolerate   // the parameter being nil, so we check for that case first.    if (bufferInfo->fBuffer !!= nil) {      OTReleaseBuffer(bufferInfo->fBuffer);   }}*///// Read Bytes from the buffers// Called by Squeak to get the data//static UInt32  readBytes(EPInfo* epi,char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // use recursion to fill buf to adjustedBufSize or     // til we have no buffers left    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32 		increment,bytesRead = 0;    ReadBuffer *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);		gFreeReadBuffersCounter++;        increment = readBytes(epi,buf+bytesRead,adjustedBufSize-bytesRead);        bytesRead += increment;        return bytesRead;   }}static UInt32  readBytesUDP(EPInfo* epi,InetAddress *fromAddress, int * moreFlag, char *buf,UInt32 adjustedBufSize){    //    // Read bytes from buffers    // For UDP we just drop in the read buffer and address    // Don''t fill the entire buffer no recursion.    // By using enterNotifier higher up we avoid race on the readBuffers list    //        UInt32      bytesRead = 0;    ReadBuffer  *aBuffer;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    if (aBuffer == nil) return 0;        if (aBuffer->readBufferSize > adjustedBufSize) {        bytesRead = adjustedBufSize;    	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy((char *) buf,aBuffer->readBufferPtr,bytesRead);        aBuffer->readBufferPtr += bytesRead;        aBuffer->readBufferSize -= bytesRead;        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTAddFirst(&epi->readBuffers,&aBuffer->fNext);        return bytesRead;    }    else {        bytesRead = aBuffer->readBufferSize;       	OTAtomicAdd32(-bytesRead, &epi->bytesPendingToRead);        OTMemcpy(buf,aBuffer->readBufferPtr,bytesRead);        OTMemcpy(fromAddress,&aBuffer->UDPAddress,sizeof(InetAddress));        *moreFlag = aBuffer->UDPMoreFlag;        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);		gFreeReadBuffersCounter++;        return bytesRead;   }}//Cleanup logic//static void purgeReadBuffers(EPInfo *epi) {    ReadBuffer *aBuffer;            //    //Put buffers for this epi back on the free queue    //    aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);        while (aBuffer !!= NULL) {        OTLIFOEnqueue(gFreeReadBuffers, &aBuffer->fNext);		gFreeReadBuffersCounter++;        aBuffer = (ReadBuffer *) OTRemoveFirst(&epi->readBuffers);    }    epi->bytesPendingToRead = 0;}////	Send the Bytes (Really fast, we hope)//static SInt32 SendData(EPInfo* epi,char* buffer, UInt32 size){	OTResult res;	struct OTData *dataPtr;  	//	//	Make sure we record that we are starting a send so we don''t try to close	//	the endpoint before a T_MEMORYRELEASED event is returned.	//	OTAtomicAdd32(1, &epi->outstandingSends);		if (epi->socketType == UDPSocketType) {		TUnitData UDPDataOutBound;	    UDPDataOutBound.addr.maxlen  = sizeof(InetAddress);	    UDPDataOutBound.addr.len     = sizeof(InetAddress);	    UDPDataOutBound.addr.buf     = (UInt8*) &epi->remoteAddress;	    UDPDataOutBound.opt.maxlen   = 0;	    UDPDataOutBound.opt.len      = 0;	    UDPDataOutBound.opt.buf      = NULL;	    UDPDataOutBound.udata.maxlen = size;	    UDPDataOutBound.udata.len    = size;	    UDPDataOutBound.udata.buf    = (UInt8*)buffer;	            res =  OTSndUData(epi->erf,&UDPDataOutBound);         if (res == kOTNoError ) return (SInt32) size;                // Other Errors could be kOTFlowErr or kOTBadDataErr	}	else { //TCP Send    	//    	//	In OT 1.1.2 and previous versions, there is a bug with AckSends    	//	which occurs when the same buffer is sent more than once.   In an attempt    	//	to go fast and not allocate memory, TCP may write an IP and TCP header    	//	into the data buffer which is sent.   If the buffer is sent more than once    	//	without being refreshed, the data may be corrupted.   To work around this,    	//	send the data via an OTData structure, using the gather-write mechanism.    	//	The problem does not occur in this code path, and this will not hinder performance.    	//	The problem will be fixed in the next Open Transport release following 1.1.2.    	//    	//  Note the MAC OS 8.1 docs alude to a bug before 1.3 where acksends    	//  cause problems if a disconnect flows just right. Unsure if this    	//  will be an issue    	//    	    	if (gOTVersion < kOTVersion113) {    		dataPtr = OTAllocMem(sizeof(OTData));    		if (dataPtr == NULL) { //Death lurks I''m sure    		    OTAtomicAdd32(-1, &epi->outstandingSends);                OTFreeMem(buffer);                return 0;            }    		dataPtr->fNext = NULL;    		dataPtr->fData = buffer;    		dataPtr->fLen  = size;    		res = OTSnd(epi->erf, dataPtr, kNetbufDataIsOTData, 0);    		    		//Note in the notification routine we cleanup the allocated dataPtr AND buffer.    	}    	else    	{    		res = OTSnd(epi->erf, buffer, size, 0);    		    		//JMM how to handle kENOMEMErr no memory right now error    		//Book says to back off and wait but must do a timer or something    		//Right now we''ll fail the primitive higher up since the error code is bad    	}    }	if (res == size) return (SInt32) size;	if (res >= 0) {		//		//	Implied kOTFlowErr since not all data was accepted.		//  But maybe we aren''t blocked yet so keep sending		//		return res;	} else	{	// res < 0	 		OTAtomicAdd32(-1, &epi->outstandingSends);        OTFreeMem(buffer);        	    if ((epi->socketType !!= UDPSocketType) && (gOTVersion < kOTVersion113) )	       	OTFreeMem(dataPtr); 	   		if (res == kOTFlowErr) {		    //		    // Flow control back off and wait for T_GODATA		    //        	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);			return 0;		}				if (res == kOTLookErr) {			res = OTLook(epi->erf);			if (res == T_ORDREL || res == T_GODATA || res == T_DISCONNECT)			{				//	Wait to get the T_ORDREL at the notifier and handle it there.				//	Then we will resume sending.				//  Same applies for other events				//                //JMM test?                	OTAtomicSetBit(&epi->stateFlags, kSendIsBlocked);				return 0;			} else 			    	return res; 		} else 		    return res;		}}////Set the options//int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80],optionValue[80];    SInt32      anInteger;    	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);	optionName[optionNameSize] = 0x00;	    OTMemcpy(optionValue,(char *) optionValueT,optionValueSize);    optionValue[optionValueSize] = 0x00;    CopyCStringToPascal(optionValue,(unsigned char *) optionValue);    StringToNum((ConstStr255Param) optionValue,&anInteger);       	   error = lookupOptionName(epi, false, (char *) &optionName, anInteger,(long *) result);   return error;}////Get the options//int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{    EPInfo*     epi;    OTResult    error;    char        optionName[80];   	*result = 0;	if (!!SocketValid(s)) return -1;    epi = (EPInfo *) s->privateSocketPtr;	OTMemcpy(optionName,(char *) optionNameT,optionNameSize);  //NEED to fiddle with error number JMM to say readonly notvalid etc.	optionName[optionNameSize] = 0x00;	     	   error = lookupOptionName(epi, true, (char *) &optionName, NULL,(long *)  result);   return error;}// A Number of routines to set/get options, first figureout the flags, then call the routine// To set or get the options. static SInt32	lookupOptionName(EPInfo *epi, Boolean trueIfGet, char *aString, UInt32 value, SInt32 *result) {	if (strcmp("TCP_MAXSEG",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_MAXSEG,value,result);};	if (strcmp("TCP_NODELAY",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NODELAY,value,result);};	if (strcmp("TCP_ABORT_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_NOTIFY_THRESHOLD",aString)==0) {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_CONN_ABORT_THRESHOLD",aString)==0) 	{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_CONN_ABORT_THRESHOLD,value,result);};	if (strcmp("TCP_NOTIFY_THRESHOLD",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_NOTIFY_THRESHOLD,value,result);};	if (strcmp("TCP_URGENT_PTR_TYPE",aString)==0) 		{return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_URGENT_PTR_TYPE,value,result);};	if (strcmp("UDP_CHECKSUM",aString)==0) 				{return SetFourByteOption(epi,trueIfGet,INET_UDP,UDP_CHECKSUM,value,result);};	if (strcmp("SO_DEBUG",aString)==0) 			    	{return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_DEBUG,value,result);};	if (strcmp("SO_REUSEADDR",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);;};	if (strcmp("SO_REUSEPORT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_REUSEADDR,value,result);};	if (strcmp("SO_DONTROUTE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_DONTROUTE,value,result);};	if (strcmp("SO_BROADCAST",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST,value,result);};	if (strcmp("SO_SNDBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDBUF,value,result);};	if (strcmp("SO_RCVBUF",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVBUF,value,result);};	if (strcmp("SO_KEEPALIVE",aString)==0) 			   {return SetKeepAliveOption(epi,trueIfGet,INET_TCP,TCP_KEEPALIVE,value,result);};	if (strcmp("SO_OOBINLINE",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_TCP,TCP_OOBINLINE,value,result);};	if (strcmp("SO_PRIORITY",aString)==0) 			     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TOS,value,result);};	if (strcmp("SO_LINGER",aString)==0) 			      {return SetLingerOption(epi,trueIfGet,XTI_GENERIC,XTI_LINGER,value,result);};	if (strcmp("SO_RCVLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_RCVLOWAT,value,result);};	if (strcmp("SO_SNDLOWAT",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,XTI_GENERIC,XTI_SNDLOWAT,value,result);};			if (strcmp("IP_OPTIONS",aString)==0) 			    { }; //JMM What to do here?		if (strcmp("IP_TTL",aString)==0) 			         {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_TTL,value,result);};		if (strcmp("IP_HDRINCL",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_HDRINCL,value,result);}; //NOT SUPPORT FOR IP		if (strcmp("IP_RCVOPTS",aString)==0) 			    {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVOPTS,value,result);};		if (strcmp("IP_RCVDSTADDR",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVDSTADDR,value,result);};		if (strcmp("IP_MULTICAST_IF",aString)==0) 			{return SetFourByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_IF,value,result);};		if (strcmp("IP_MULTICAST_TTL",aString)==0) 			 {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_TTL,value,result);};		if (strcmp("IP_MULTICAST_LOOP",aString)==0) 	     {return SetOneByteOption(epi,trueIfGet,INET_IP,IP_MULTICAST_LOOP,value,result);};	/*	if (strcmp("IP_ADD_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_ADD_MEMBERSHIP,value,result);};		if (strcmp("IP_DROP_MEMBERSHIP",aString)==0) 	    { return SetJMMByteOption(epi,trueIfGet,INET_IP,IP_DROP_MEMBERSHIP,value,result);};		if (strcmp("IP_BROADCAST_IF",aString)==0) 	        {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_BROADCAST_IF,value,result);};		if (strcmp("IP_RCVIFADDR",aString)==0) 	            {return SetFourByteOption(epi,trueIfGet,INET_IP,IP_RCVIFADDR,value,result);};	*/    *result = 0;    return -1;}static OTResult SetFourByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTFourByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   option->value[0] = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(optBuffer);   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);      if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}								    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = option->value[0];   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }                return (err);}static OTResult SetOneByteOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   UInt8    optBuffer[kOTFourByteOptionSize];   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;      /* Set up the option buffer to specify the option and value to set. */   option->len  = kOTOneByteOptionSize;   option->level= level;   option->name = name;   option->status = 0;   *(unsigned char *)option->value = value;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= kOTOneByteOptionSize;   request.opt.maxlen=sizeof(optBuffer);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(optBuffer);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = (UInt32) (*(unsigned char *)option->value);   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}static OTResult SetKeepAliveOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TKeepAliveOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpKeepAliveOn = T_NO;   else        optBuffer.tcpKeepAliveOn = T_YES;           optBuffer.tcpKeepAliveTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpKeepAliveTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}		    static OTResult SetLingerOption(EPInfo* epi,Boolean trueIfGet, OTXTILevel level, OTXTIName  name, UInt32   value, SInt32    *returnValue) {   OTResult err;   TLingerOpt  optBuffer;   TOption  *option = (TOption *) &optBuffer;   TOptMgmt request;   TOptMgmt result;   Boolean isAsync=false;         if (value == 0)       optBuffer.tcpLingerOn = T_NO;   else        optBuffer.tcpLingerOn = T_YES;           optBuffer.tcpLingerTimer = value;				   /* Set up the option buffer to specify the option and value to set. */   option->len  = sizeof(TKeepAliveOpt);   option->level= level;   option->name = name;   option->status = 0;   /* Set up request parameter for OTOptionManagement */   request.opt.buf= (UInt8 *) option;   request.opt.len= sizeof(TKeepAliveOpt);   request.opt.maxlen=sizeof(TKeepAliveOpt);   request.flags  = trueIfGet ? T_CURRENT : T_NEGOTIATE;   /* Set up reply parameter for OTOptionManagement. */   result.opt.buf  = (UInt8 *) option;   result.opt.maxlen  = sizeof(TKeepAliveOpt);       if (OTIsSynchronous(epi->erf) == false)	{	// check whether ep sync or not		isAsync = true;			                // set flag if async		OTSetSynchronous(epi->erf);			        // set endpoint to sync		}				    err = OTOptionManagement(epi->erf, &request, &result);		if (isAsync)				        // restore ep state 		OTSetAsynchronous(epi->erf);    	*returnValue = optBuffer.tcpLingerTimer;   if (err == noErr) {      if (option->status !!= T_SUCCESS)          err = option->status;   }               return (err);}////	Notifier:////	Most of the interesting networking code in this program for the resolver resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	Note: The only events which are expected from the DNR are T_DNRSTRINGTOADDRCOMPLETE,//	T_DNRADDRTONAMECOMPLETE, and of close sleep/reconfigure notifications.////static pascal void DNSNotifier(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);		//	//	Once the program is shutting down, most events would be uninteresting.	//	if (gProgramState !!= kProgramRunning)			return;			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	T_DNRSTRINGTOADDRCOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the server''s name into an IP address we can use to connect to.		//		case T_DNRSTRINGTOADDRCOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSAddr = gDNSHostInfo.addrs[0];			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}				//		//	T_DNRADDRTONAMECOMPLETE:		//		//	This event occurs when the DNR has finished an attempt to translate		//	the  an IP address into a server name.		//		case T_DNRADDRTONAMECOMPLETE:		{			gDNSResolverError = result;			if (result !!= kOTNoError) {				gDNSResolverStatus = RESOLVER_ERROR;    			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);				return;			}			gDNSResolverStatus = RESOLVER_SUCCESS;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			return;		}									//		//	kOTProviderWillClose:		//		//	This event occurs when the user changes TCP/IP in the control panel		//		case kOTProviderWillClose:		case kOTProviderIsClosed:		{			gDNSResolverError = kOTProviderWillClose;			interpreterProxy->signalSemaphoreWithIndex(epi->semaIndex);			ResolverTerminate(); 			gDNSResolverStatus = RESOLVER_SUCCESS; //Cheat!! Keep Squeak happy later we fix the resolver EP.			return;		}				//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.  In the production version of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for socket: Please note we have another notifier for sockets that do multiple listens//  And a different notifier for UDP sockets, however the intesting thing is that we can call/// This routine from othe other as a simple form of inheritence.////	Most of the interesting networking code in this program for socket support resides inside //	this notifier.   In order to run asynchronously and as fast as possible,//	things are done inside the notifier whenever possible.  Since almost//	everything is done inside the notifier, there was little need for specical//	synchronization code.////	IMPORTANT NOTE:  Normal events defined by XTI (T_LISTEN, T_CONNECT, etc)//	and OT completion events (T_OPENCOMPLETE, T_BINDCOMPLETE, etc.) are not//	reentrant.  That is, whenever our notifier is invoked with such an event,//	the notifier will not be called again by OT for another normal or completion//	event until we have returned out of the notifier - even if we make OT calls//	from inside the notifier.   This is a useful synchronization tool.//	However, there are two kinds of events which will cause the notifier to //	be reentered.   One is T_MEMORYRELEASED, which always happens instantly.//	The other are state change events like kOTProviderWillClose.//static pascal void NotifierSocket(void* context, OTEventCode event, OTResult result, void* cookie){	OSStatus err;	OTResult epState;	EPInfo* epi = (EPInfo*) context;		JMMLogMessageAndNumber("\p Event  ",event);	JMMLogMessageAndNumber("\p Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	//	//	Once the program is shutting down, most events would be uninteresting.	//	However, we still need T_OPENCOMPLETE and T_MEMORYRELEASED events since	//	we can''t call CloseOpenTransport until all OTAsyncOpenEndpoints and	//	OTSends with AckSends have completed.   So those specific events	//	are still accepted.	//	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			//	//	Within the notifier, all action is based on the event code.	//	In this notifier, fatal errors all break out of the switch to the bottom.	//	As long as everything goes as expected, the case returns rather than breaks.	//	switch (event)	{		//		//	kStreamIoctlEvent:		//		//	This event is returned when an I_FLUSH ioctl has completed.		//	The flush was done in an attempt to get back all T_MEMORYRELEASED events		//	for outstanding OTSnd() calls with Ack Sends.   For good measure, we		//	send a disconnect now.   Errors are ignored at this point since it is		//	possible that the connection will already be gone, etc.		//		case kStreamIoctlEvent:		{			if (OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit) !!= 0) {			    OTAtomicClearBit(&epi->stateFlags2, kFlushDisconnectInProgressBit);				(void) OTSndDisconnect(epi->erf, NULL);			}			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only when we open a port with a listen.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);        		return;            }            makeEPConnected(epi);			return;		}		//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound to a wildcard addr.		//  Bind happens when we open a connection to a remote location.		//	No errors are expected.   		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			OTAtomicClearBit(&epi->stateFlags3, kWaitingForBind);			if (result !!= kOTNoError) {            	makeEPUnconnected(epi);				return;			}			if (epi->remoteAddress.fHost !!= 0) 			    DoConnect(epi,epi->remoteAddress.fHost, epi->remoteAddress.fPort);			return;		}				//		//	T_CONNECT:		//		//	This event is returned when a connection is established to the server.		//	The program must call OTRcvConnect() to get the conenction information		//	and clear the T_CONNECT event from the stream.  Since OTRcvConnect()		//	returns immediately (rather than via a completion event to the notifier)		//	we can use local stack structures for parameters.		//		case T_CONNECT:		{			TCall call;						            SetEPLastError(epi,result);			if (result !!= kOTNoError) {				makeEPUnconnected(epi);  				return;			}						// Address of endpoint that has connection			// This could be different from original request			// Due to hand off to different EP say you connect to 			// port 80, but you end up on 49160						call.addr.maxlen = sizeof(InetAddress);			call.addr.buf = (unsigned char*) &epi->remoteAddress;  			call.opt.maxlen = 0;			call.opt.buf = NULL;			call.udata.maxlen = 0;			call.udata.buf = NULL;						err = OTRcvConnect(epi->erf, &call);			SetEPLastError(epi,err);			if (err !!= kOTNoError) {			    if (err == kOTLookErr) {			        OSStatus	lookStatus;			        lookStatus = OTLook(epi->erf);			        if (lookStatus == T_DISCONNECT) {               			err = OTRcvDisconnect(epi->erf, NULL);        	    		if (err !!= kOTNoError) {        		    		if (err == kOTNoDisconnectErr) {                    			err = OTRcvConnect(epi->erf, &call);                    			SetEPLastError(epi,err);                       			makeEPUnconnected(epi);       		    		        return;       		    		    }			            } else {                			err = OTRcvConnect(epi->erf, &call);                			SetEPLastError(epi,err);                   			makeEPUnconnected(epi);   		    		        return;			            }			        }			        if (lookStatus == T_GODATA) { // HUH            			err = OTRcvConnect(epi->erf, &call);            			SetEPLastError(epi,err);               			makeEPConnected(epi);	    		        return;			        }			    }                //JMM book says may return kOTNoDataErr (no connecton yet) or a kOTLookErr with T_DISCONNECT                // BUT we had got T_GODATA WHY?                 				makeEPUnconnected(epi);				return;			}						makeEPConnected(epi);			return;				// Wait for a T_DATA...		}				//		//	T_LISTEN:		//		case T_LISTEN:		{			DoListenAccept(epi,epi);			return;		}		//		//	T_DATA:		//		//	The main rule for processing T_DATA''s is to remember that once you have		//	a T_DATA, you won''t get another one until you have read to a kOTNoDataErr.		//	The advanced rule is to remember that you could get another T_DATA		//	during an OTRcv() which will eventually return kOTNoDataErr, presenting		//	the application with a synchronization issue to be most careful about.		//			//	In this application, since an OTRcv() calls are made from inside the notifier,		//	this particular synchronization issue doesn''t become a problem.		//		case T_DATA:		{			if (!!OTAtomicTestBit(&epi->stateFlags2, kPassconNeeded)) {			    ReadData(epi,NULL,0);			    return;			 }			 else {    			//    			//	Here we work around a small OpenTransport bug.    			//	It turns out, since this program does almost everything from inside the notifier,    			//	that during a T_UNBINDCOMPLETE we can put an EPInfo back into the idle list.    			//	If that notification is interrupted by a T_LISTEN at the notifier, we could    			//	end up starting a new connection on the endpoint before OT unwinds the stack    			//	out of the code which delivered the T_UNBINDCOMPLETE.   OT has some specific    			//	code to protect against a T_DATA arriving before the T_PASSCON, but in this    			//	case it gets confused and the events arrive out of order.   If we try to    			//	do an OTRcv() at this point we will get a kOTStateChangeErr because the endpoint    			//	is still locked by the earlier OTAccept call until the T_PASSCON is delivered    			//	to us.   This is fairly benign and can be worked around easily.  What we do    			//	is note that the T_PASSCON hasn''t arrived yet and defer the call to ReadData()    			//	until it does.    			//    			if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 )    			{    			    ReadData(epi,NULL,0);    			    return;    			}    		}		}							//		//	T_PASSCON:		//		//	This event happens on the accepting endpoint, not the listening endpoint.		//	At this point the connection is fully established and we can begin the		//	process of downloading data.  Note that due to a problem in OT it is 		//	possible for a T_DATA to beat a T_PASSCON to the notifier.  When this		//	happens we note it in the T_DATA case and then start processing the 		//	data here.  		//		case T_PASSCON:		{            SetEPLastError(epi,result);			if (result !!= kOTNoError) {               	OTAtomicSetBit(&epi->stateFlags, kPassconBit);   				makeEPUnconnected(epi);				return;			}			   			makeEPConnected(epi);                		    if ( OTAtomicSetBit(&epi->stateFlags, kPassconBit) !!= 0 ){				//				//	A T_DATA previously beat the T_PASSCON to our notifier.				//	Here we help OT out by having deferred data processing until now.				//			    ReadData(epi,NULL,0);			}			return;		}		//		// T_MEMORYRELEASED		// lower level has finished with buffer						case T_MEMORYRELEASED:		{		    if (cookie == nil) return;			OTAtomicAdd32(-1, &epi->outstandingSends);				    	if (epi->socketType == UDPSocketType) {		        OTFreeMem(cookie);	    	} else {//tcp		    	if (gOTVersion < kOTVersion113) {		    		struct OTData *data=cookie;		    		OTFreeMem(data->fData);		    		OTFreeMem(data);		    	} else {		        	OTFreeMem(cookie);		        }	        }	        			    return;		}					//		//	T_DISCONNECT:		//		//	An inbound T_DISCONNECT event usually indicates that the other side of the		//	connection did an abortive disconnect (as opposed to an orderly release).		//	It also can be generated by the transport provider on the system (e.g. tcp)		//	when it decides that a connection is no longer in existance.		//		//	We receive the disconnect, but this program ignores the associated reason (NULL param).		//	It is possible to get back a kOTNoDisconnectErr from the OTRcvDisconnect call.		//	This can happen when either (1) the disconnect on the stream is hidden by a 		//	higher priority message, or (2) something has flushed or reset the disconnect		//	event in the meantime.   This is not fatal, and the appropriate thing to do is		//	to pretend the T_DISCONNECT event never happened.   Any other error is unexpected		//	and needs to be reported so we can fix it.  Next, unbind the endpoint so we can		//	reuse it for a new inbound connection.		//			//	It is possible to get an error on the unbind due to a bug in OT 1.1.1 and earlier.		//	The best thing to do for that is close the endpoint and open a new one to replace it.		//	We do this back in the main thread so we don''t have to deal with synchronization problems.		//		case T_DISCONNECT:		{			epState = OTGetEndpointState(epi->erf);			err = OTRcvDisconnect(epi->erf, NULL);						if (epState == T_OUTCON) { //01Aug2000 fix for bad port, will get disconnect on outgoing connection                makeEPUnconnected(epi);			}			if (err !!= kOTNoError) {				if (err == kOTNoDisconnectErr) return;			    makeEPBroken(epi,err);				return;			}			                ///                //Both sides now have closed                 //                        OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);						err = OTUnbind(epi->erf);    	    TapAllInterestedSemaphores(epi);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			return;		}				//		//	T_GODATA:		//		//	This event is received when flow control is lifted.   We are under flow control		//	whenever OTSnd() returns a kOTFlowErr or accepted less bytes than we attempted		//	to send.  		//		//	Note, it is also possible to get a T_GODATA without having invoke flow control.		//	Be safe and prepare for this. 		//		case T_GODATA:		{            if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) { 	           if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))  	              interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_OPENCOMPLETE:		//		//	This event occurs when an OTAsyncOpenEndpoint() completes.   Note that this event,		//	just like any other async call made from outside the notifier, can occur during		//	the call to OTAsyncOpenEndpoint().  That is, in the main thread the program did		//	the OTAsyncOpenEndpoint(), and the notifier is invoked before control is returned		//	to the line of code following the call to OTAsyncOpenEndpoint().   This is one		//	event we need to keep track of even if we are shutting down the program since there		//	is no way to cancel outstanding OTAsyncOpenEndpoint() calls.		//		case T_OPENCOMPLETE:		{			TOptMgmt 			optReq;			TOption             opt;			OTAtomicClearBit(&epi->stateFlags, kOpenInProgressBit);			if (result == kOTNoError)				epi->erf = (EndpointRef) cookie;			else {				makeEPBrokenThenIdle(epi,result);				return;			}			if (gProgramState !!= kProgramRunning) return;										//			//	Set to blocking mode so we don''t have to deal with kEAGAIN errors.			//	Async/blocking is the best mode to write an OpenTransport application in.			//			err = OTSetBlocking(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Set to AckSends so OT doesn''t slow down to copy data sent out.			//	However, this requires special care when closing endpoints, so don''t use			//	AckSends unless you are prepared for this.   Never, ever, close an endpoint			//	when a send has been done but the T_MEMORYRELEASED event hasn''t been returned yet.			//			err = OTAckSends(epi->erf);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);				return;			}						//			//	Option Management			//			//	Turn on ip_reuseaddr so we don''t have port conflicts in general.			//	We use local stack structures here since the memory for the 			//	option request structure is free upon return.   If we were to request			//	the option return value, we would have to use static memory for it.			//			optReq.flags			= T_NEGOTIATE;			optReq.opt.len			= kOTFourByteOptionSize;			optReq.opt.buf			= (unsigned char *) &opt;						opt.len					= sizeof(TOption);			opt.level				= INET_IP;			opt.name				= IP_REUSEADDR;			opt.status				= 0;			opt.value[0]			= 1;			            if (epi->socketType == TCPSocketType)                 OTAtomicSetBit(&epi->stateFlags3, kKeepAliveOptionNeeded);                			err = OTOptionManagement(epi->erf, &optReq, NULL);			if (err !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,err);			}						//			//	Code path resumes at T_OPTMGMTCOMPLETE			//						return;		}				//		//	T_OPTMGMTCOMPLETE:		//		//	An OTOptionManagement() call has completed.  These are used on all		//	endpoints to set IP_REUSEADDR.   It is also used for all endpoints		//	other than the listener to set TCP_KEEPALIVE which helps recover		//	server resources if the other side crashes or is unreachable.		//		case T_OPTMGMTCOMPLETE:		{			TOptMgmt 			optReq;			if (result !!= kOTNoError) {			    makeEPBrokenThenIdle(epi,result);				return;			}			            if (OTAtomicClearBit(&epi->stateFlags3, kKeepAliveOptionNeeded)) {                                TKeepAliveOpt		opt;				//				//	Turn on TCP_KEEPALIVE so we can recover from connections which have				//	gone away which we don''t know about.  				//				optReq.flags			= T_NEGOTIATE;				optReq.opt.len			= sizeof(TKeepAliveOpt);				optReq.opt.buf			= (unsigned char *) &opt;								opt.len					= sizeof(TKeepAliveOpt);				opt.level				= INET_TCP;				opt.name				= TCP_KEEPALIVE;				opt.status				= 0;				opt.tcpKeepAliveOn		= 1;				opt.tcpKeepAliveTimer	= kTCPKeepAliveInMinutes;									err = OTOptionManagement(epi->erf, &optReq, NULL);				if (err !!= kOTNoError) {    			    makeEPBrokenThenIdle(epi,result);                }                return;            }						            makeEPIdle(epi);  //This is where more EP enter the queue of available EPs.            			return;			// now wait 		}		//		//	T_ORDREL:		//		//	This event occurs when an orderly release has been received on the stream.		//		case T_ORDREL:		{			err = OTRcvOrderlyDisconnect(epi->erf);						if (err !!= kOTNoError) {				//				//	It is possible for several reasons for the T_ORDREL to have disappeared,				//	or be temporarily hidden, when we attempt the OTRcvOrderlyDisconnect().				//	The best thing to do when this happens is pretend that the event never				//	occured.   We will get another notification of T_ORDREL if the event				//	becomes unhidden later.  Any other form of error is unexpected and 				//	is reported back so we can correct it.				//				if (err == kOTNoReleaseErr)					return;				//Can get OTLookErr with T_DISCONNECT    		   makeEPBroken(epi,err);			}				if (OTAtomicTestBit(&epi->stateFlags, kThisEndClosed)) {                                ///                //Both sides now have closed                //                                OTAtomicSetBit(&epi->stateFlags, kUnConnected);			    	        OTAtomicClearBit(&epi->stateFlags, kConnected);                OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			                OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);											epState = OTGetEndpointState(epi->erf);				if (epState !!= T_IDLE) {            	    TapAllInterestedSemaphores(epi);				    return;				}				err = OTUnbind(epi->erf);        	    TapAllInterestedSemaphores(epi);				if (err !!= kOTNoError) {				    makeEPBroken(epi,err);				}				    		    return;            } else {    			OTAtomicSetBit(&epi->stateFlags, kOtherEndClosed);			}						//			//	Sometimes our data sends get stopped with a kOTLookErr			//	because of a T_ORDREL from the other side (which doesn''t close			//	the connection, it just means they are done sending data).			//	If so, we still end up in the notifier with the T_ORDREL event,			//	but we won''t resume sending data unless we explictly check			//	here whether or not we need to do so.			//             //JMM Test this?             if (OTAtomicClearBit(&epi->stateFlags, kSendIsBlocked)) {  		    	if (OTAtomicClearBit(&epi->stateFlags2, kTapSemaphoreWriteData))                	interpreterProxy->signalSemaphoreWithIndex(epi->writeSemaIndex);            };			return;		}				//		//	T_UNBINDCOMPLETE:		//		//	This event occurs on completion of an OTUnbind().		//	The endpoint is ready for reuse on a new inbound connection.		//	Note that the OTLIFO structure has atomic queue and dequeue,		//	which can be helpful for synchronization protection.  		//		case T_UNBINDCOMPLETE:		{			if (result !!= kOTNoError) {				//				//	Unbind errors can occur as a result of a bug in OT 1.1.1 and earlier				//	versions.   The best recovery is to put the endpoint in the broken				//	list for recycling with a clean, new endpoint.				//  Since we only support 1.1.2 we don''t expect to run this code.				//			    makeEPBroken(epi,result);				return;			}			return;		}						//		//	T_DISCONNECTCOMPLETE:		//		//	This event occurs on completion of an OTSndDisconnect().		//	Called when we abort a socket		//		case T_DISCONNECTCOMPLETE: {			err = OTUnbind(epi->erf);			if (err !!= kOTNoError) {			    makeEPBroken(epi,err);			}			purgeReadBuffers(epi);		            TapAllInterestedSemaphores(epi); 			if (OTAtomicTestBit(&epi->stateFlags2, kMakeEPIdle)) { //Make EP idle if marked as such only happens via destroy. 			    makeEPIdle(epi);			}			epi->stateFlags = 0;			epi->stateFlags2 = 0;			epi->stateFlags3 = 0;            SetEPLastError(epi,result);        	OTAtomicSetBit(&epi->stateFlags, kUnConnected);			return;		}				//		//Sleep sleep sleep all end points get trashed.		//		case kOTProviderWillClose: // reconfig stack disconnect and close		{		    makeEPBroken(epi,-12345678);            if(OTAtomicTestBit(&epi->stateFlags, kOpenInProgressBit)) return;            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTSndDisconnect(epi->erf, NULL);            OTUnbind(epi->erf);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 		    return;		}		case kOTProviderIsClosed: //Sleep lurks		{		    makeEPBroken(epi,-12345678);            OTSetSynchronous(epi->erf);			        // set endpoint to sync	        	if ( OTAtomicSetBit(&epi->stateFlags2, kFlushDisconnectInProgressBit) == 0 )        		err = OTIoctl(epi->erf, I_FLUSH, (void *)FLUSHRW);            OTCloseProvider(epi->erf);            OTAtomicSetBit(&epi->stateFlags, kUnConnected);				        OTAtomicClearBit(&epi->stateFlags, kConnected);            OTAtomicClearBit(&epi->stateFlags, kThisEndClosed);			            OTAtomicClearBit(&epi->stateFlags, kOtherEndClosed);			            OTAtomicSetBit(&epi->stateFlags3, kSleepKilledMe);            TapAllInterestedSemaphores(epi); 			return;		}		//		//	default:		//		//	There are events which we don''t handle, but we don''t expect to see		//	any of them.   When running in debugging mode while developing a program,		//	we exit with an informational alert.   Later, in the production version		//	of the program, we ignore the event and try to keep running.		//		default:		{			return;		}	}}////	Notifier for listen socket://static pascal void NotifierSocketListener(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	if (gProgramState !!= kProgramRunning)	{		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED))		{			return;		}	}	JMMLogMessageAndNumber("\p Listener Event  ",event);	JMMLogMessageAndNumber("\p Listener Result ",result);	JMMLogMessageAndNumber("\p Listener Id ",epi->semaIndex);		switch (event)	{		//		//	T_BINDCOMPLETE:		//		//	We only bind the listener endpoint, and bind failure is a fatal error.  		//	Acceptor endpoints are bound within the OTAccept() call when they get a connection.		//		case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			OTAtomicClearBit(&epi->stateFlags3, kWaitingForBind);			if (result !!= kOTNoError)   				makeEPUnconnected(epi);      			return;		}						//		//	T_LISTEN:		//		case T_LISTEN:		{            SetEPLastError(epi,result);   			makeEPConnected(epi);			return;		}		//		//	T_ACCEPTCOMPLETE:		//		//	This event is received by the listener endpoint only.   		//	The acceptor endpoint will get a T_PASSCON event instead.		//		case T_ACCEPTCOMPLETE:		{            SetEPLastError(epi,result);			return;		}				//		//	default:		//		//	There are events which we don''t handle, pass them onwards		//		default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}	}}////	Notifier for UDP listen socket://static pascal void NotifierSocketUDP(void* context, OTEventCode event, OTResult result, void* cookie){	EPInfo* epi = (EPInfo*) context;	OSStatus err;	JMMLogMessageAndNumber("\p DNS Event  ",event);	JMMLogMessageAndNumber("\p DNS Result ",result);	JMMLogMessageAndNumber("\p Id ",epi->semaIndex);	if (gProgramState !!= kProgramRunning) {		if ((event !!= T_OPENCOMPLETE) && (event !!= T_MEMORYRELEASED)) {			return;		}	}			switch (event)	{		//Some sort of UDP send error, too late to tell anyone?		//		case T_UDERR: {      		TUDErr 		uderr;		    InetAddress errorAddress;                        uderr.addr.maxlen   = sizeof(InetAddress);            uderr.addr.len      = sizeof(InetAddress);            uderr.addr.buf      = (UInt8 *) &errorAddress;            uderr.opt.maxlen    = 0;            uderr.opt.len       = 0;            uderr.opt.buf       = NULL;   		    err =  OTRcvUDErr(epi->erf, &uderr);            if (err !!= kOTNoError)   				makeEPBroken(epi,err);			            SetEPLastError(epi,uderr.error);		    return;		}				//		//	T_DATA:		//		//  Got milk?		//				case T_DATA: {			ReadData(epi,NULL,0);		    return;		}				//		//	T_BINDCOMPLETE:		//		//	This event is returned when an endpoint has been bound.		//	No errors are expected.   		//				case T_BINDCOMPLETE:		{            SetEPLastError(epi,result);			OTAtomicClearBit(&epi->stateFlags3, kWaitingForBind);			if (result !!= kOTNoError) {   				makeEPUnconnected(epi);				return;			}   			makeEPConnected(epi);			return;		}		//		//	default:		//		//	There are events which we don''t handle, pass them onwards to the regular notifier		//				default:		{            NotifierSocket(context,  event,  result, cookie);			return;		}    }}short	        gJMMFile=0;OTTimeStamp 	JMMStartTimeStamp;OTLIFO			JMMLogBufferLIFO;    	//  Buffers that are free to read intoOTLIFO*			JMMLogBufferBuffers			= &JMMLogBufferLIFO; void JMMWriteLog() {	OSErr			error;	OTLink* 	    list = OTReverseList(OTLIFOStealList(JMMLogBufferBuffers));	OTLink*		    link;	ReadBuffer      *aBuffer;	long           dummySize;	char			CH=0x0D;	if (true) return;		error = HCreate(0,0,"\pJMMFOOBAR.txt",''TEXT'',''TEXT'');	error = HOpenDF(0,0,"\pJMMFOOBAR.txt",fsRdWrPerm,&gJMMFile);	error = SetFPos(gJMMFile,fsFromLEOF,0);	while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);    	error = FSWrite(gJMMFile,(long *)&aBuffer->readBufferSize,aBuffer->readBufferData);    	dummySize = 1;    	error = FSWrite(gJMMFile,&dummySize,&CH);	}	error = FSClose(gJMMFile);		while ( (link = list) !!= NULL ) {		list = link->fNext;    	aBuffer = OTGetLinkObject(link, ReadBuffer, fNext);        OTFreeMem(aBuffer->readBufferData);        OTFreeMem(aBuffer); 	}	}void JMMLogMessage(Str255 input) {	Str255 			timeString;	long 			timeStringLength,inputLength;	UInt32			duration;	ReadBuffer      *readBufferObject;		if (true) return;		if (gJMMFile == 0) {		gJMMFile = 1;		OTGetTimeStamp(&JMMStartTimeStamp);		JMMLogBufferBuffers->fHead 		= NULL;	}		duration = OTElapsedMilliseconds(&JMMStartTimeStamp);	NumToString(duration,timeString);	timeStringLength = (unsigned char) timeString[0];	inputLength = (unsigned char) input[0];		readBufferObject = OTAllocMem(sizeof(ReadBuffer));	if (readBufferObject == NULL) return;	OTMemzero(readBufferObject,sizeof(ReadBuffer));		readBufferObject->readBufferData = OTAllocMem(60);	if (readBufferObject->readBufferData == NULL) {	    OTFreeMem(readBufferObject);	    return;	}		OTMemcpy(readBufferObject->readBufferData,timeString+1,timeStringLength);	OTMemcpy(readBufferObject->readBufferData+timeStringLength,input+1,inputLength);	readBufferObject->readBufferSize= timeStringLength+inputLength;    OTLIFOEnqueue(JMMLogBufferBuffers, &readBufferObject->fNext);	}void JMMLogMessageAndNumber(Str255 msg,long number) {	Str255 buffer,numberString;	long msgLength,numberLength;		if (true) return;		NumToString(number,numberString);	numberLength = (unsigned char) numberString[0];	msgLength = (unsigned char) msg[0];		OTMemcpy(buffer+1,msg+1,msgLength);	OTMemcpy(buffer+1+msgLength,numberString+1,numberLength);	buffer[0] = (unsigned char) msgLength+numberLength;	JMMLogMessage(buffer);}/*The Open Transport TCP/IP software modules provide a RawIP interface to the IP protocolhostname of '''' lookup fails This is OK? Same on linux and old mac versionJMM look at tlook page, not sure if we have completely understood itJMM is it legal to send a zero byte buffer need case for this?/* According to the XTI spec ("Section 4.6 Events and TLOOK Error indication"), the SndOrderlyDisconnect and RcvOrderlyDisconnect calls can fail because of a pending T_DISCONNECT event. This is XTI trying to tell you that the a connection on that endpoint broke. This can happen in this asynchronous wacky world of networks and your program will have to call a RcvDisconnect to acknowledge that your endpoint dropped.You might want to check out the OTI spec, which, although it is not always written in the most lucid fashion, does contain valuable information for those involved in OpenTransport programming.Further Information:Title: X/OPEN TRANSPORT INTERFACE (XTI) VER 2 [ 1.0 ed]Author: X/OPEN ISBN #: 0133534596A Prior to Open Transport 1.3, there was no supported way of calling Open Transport from CFM-68K code. With the introduction of Open Transport 1.3, it is now possible to call the Open Transport client interface from CFM-68K code. The Open Transport 1.3 SDK includes stub libraries and a document, "Open Tpt CFM68K Dev. Note", which explains Open Transport''s support for CFM-68K. which is supporte for syste 7.x but you can''t install!! No standalone installer exists. Coping the OT files kinda works*/#else/* Adjustments for pluginized VM * * Note: The Mac support files have not yet been fully converted to * pluginization. For the time being, it is assumed that they are linked * with the VM. When conversion is complete, they will no longer import * "sq.h" and they will access all VM functions and variables through * the interpreterProxy mechanism. */#include "sq.h"#include "SocketPlugin.h"/* initialize/shutdown */int socketInit() { return true; }int socketShutdown() { sqNetworkShutdown(); }/* End of adjustments for pluginized VM */#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"/*** Socket Type Constants ***/#define TCPSocketType 		0#define UDPSocketType 		1#define ListenerQueueType	2/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	(8 * 1024)#define RecvBufferSize	(8 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of open sockets */	int			semaIndex;	int			connectStatus;	void *		nextInListenerQueue; /* next socket in a ListenderQueue waiting socket list */	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 8TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;typedef struct {	int			localAddress;	int			localPort;	int			closed;				/* set true by close or abort */	int			semaIndex;			/* semaphore of the server socket */	int			desiredQueueLength;	TCPSockPtr	waitingSockets;} ListenerQueueRec, *ListenerQueuePtr;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of open sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/extern struct VirtualMachine *interpreterProxy;short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private ListenerQueue Socket Functions ***/void		FillListenerQueue(ListenerQueuePtr listener);TCPSockPtr	FindConnectedSocket(ListenerQueuePtr listener);TCPSockPtr	FindZombieSocket(ListenerQueuePtr listener);void		RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener);ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize);void		ListenerQueueDestroy(ListenerQueuePtr listener);int			ListenerQueueStatus(ListenerQueuePtr listener);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSockettoHostportSendDataBufCount(SocketPtr s, int address, int port, int buf, int bufSize) {  interpreterProxy->success(false);}int sqSocketGetOptionsoptionNameStartoptionNameSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int *result)	{  interpreterProxy->success(false);}void	sqSocketAcceptFromRecvBytesSendBytesSemaIDReadSemaIDWriteSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex, int readSemaIndex, int writeSemaIndex) {  interpreterProxy->success(false);}int sqSocketReceiveUDPDataBufCountaddressportmoreFlag(SocketPtr s, int buf, int bufSize,  int *address,  int *port, int *moreFlag) {  interpreterProxy->success(false);}int sqSocketSetOptionsoptionNameStartoptionNameSizeoptionValueStartoptionValueSizereturnedValue(SocketPtr s,int optionNameT, int optionNameSize, int optionValueT, int optionValueSize, int *result)	{  interpreterProxy->success(false);}int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* open network driver */	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		return -1;	}	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		ResolverTerminate();		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;	} else {		mtuSize = 1024;  /* guess */		ResolverTerminate();		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* Success!! Create a session ID that is unlikely to be	   repeated. Zero is never used for a valid session number.	*/	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);		return;	}	if (s->socketType == ListenerQueueType) {		((ListenerQueuePtr) s->privateSocketPtr)->closed = true; /* set closed flag */		return;	}	success(false);}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}	if (s->socketType == ListenerQueueType) {		return ListenerQueueStatus((ListenerQueuePtr) s->privateSocketPtr);	}	success(false);}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);		return;	}	success(false);}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}		return;	}	if (s->socketType == UDPSocketType) {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}		return;	}	success(false);}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		ListenerQueueDestroy((ListenerQueuePtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}	if (s->socketType == ListenerQueueType) {		return 0;  /* ListenerQueue''s themselves never get an error */	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);		return;	}	if (s->socketType == UDPSocketType) {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);		return;	}	success(false);}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localAddress;	}	success(false);}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}	if (s->socketType == ListenerQueueType) {		return ((ListenerQueuePtr) s->privateSocketPtr)->localPort;	}	success(false);}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}	success(false);}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	}	if (s->socketType == UDPSocketType) {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}	success(false);}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	if (s->socketType == UDPSocketType) {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}	success(false);}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	}	if (s->socketType == UDPSocketType) {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}	success(false);}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	} else {		resolver.status = RESOLVER_SUCCESS;		resolver.error = noErr;	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	if (resolver.status == RESOLVER_BUSY) return;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	resolver.error = noErr;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* real error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;	resolver.error = OpenResolver(nil);	if (resolver.error !!= noErr) {		resolver.status = RESOLVER_ERROR;		return resolver.error;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	if ((r == null) || (r->status !!= RESOLVER_BUSY)) return;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Squeak TCP Socket Listen/Accept Functions ***/ListenerQueuePtr ListenerQueueCreate(TCPSockPtr tcpSocket, int port, int backlogSize) {	ListenerQueuePtr listener;	/* allocate a new ListenerQueue */	listener = (ListenerQueuePtr) malloc(sizeof(ListenerQueueRec));	if (listener == nil) return nil;	/* initialize it */	listener->localAddress = TCPSockLocalAddress(tcpSocket);	listener->localPort = port;	listener->closed = false;	listener->semaIndex = tcpSocket->semaIndex;	listener->desiredQueueLength = (backlogSize < 1) ? 1 : backlogSize;	listener->waitingSockets = nil;	/* add the given socket to the new ListenerQueue */	tcpSocket->nextInListenerQueue = listener->waitingSockets;	listener->waitingSockets = tcpSocket;	TCPSockListenOn(tcpSocket, listener->localPort);	/* create additional waiting sockets in necessary to fill the ListenerQueue */	FillListenerQueue(listener);	return listener;}void ListenerQueueDestroy(ListenerQueuePtr listener) {	TCPSockPtr thisSock, nextSock;	/* destroy all sockets in this ListenerQueue''s waiting socket list */	thisSock = listener->waitingSockets;	while (thisSock !!= nil) {		nextSock = thisSock->nextInListenerQueue;		TCPSockDestroy(thisSock);		thisSock = nextSock;	}	/* clear a few fields, just in case of a dangling reference */	listener->closed = true;	listener->semaIndex = 0;	listener->waitingSockets = nil;	/* free the ListenerQueue */	free(listener);}int ListenerQueueStatus(ListenerQueuePtr listener) {	TCPSockPtr sock;	if (listener == nil) {		success(false);		return Unconnected;	}	if (listener->closed) return Unconnected;	/* check for zombie sockets; if there is one, clean up the queue */	if (FindZombieSocket(listener) !!= nil) {		FillListenerQueue(listener);  /* removes zombies and refills queue */	}	/* scan queue for a connected socket */	sock = FindConnectedSocket(listener);	return (sock == nil) ? WaitingForConnection : Connected;}void FillListenerQueue(ListenerQueuePtr listener) {	TCPSockPtr sock, newSock;	int count, socksToAdd;	/* remove from the queue and destroy any zombie sockets */	while ((sock = FindZombieSocket(listener)) !!= nil) {		RemoveSocketFromListenerQueue(sock, listener);		TCPSockDestroy(sock);	}	/* count the number of remaining sockets */	count = 0;	sock = listener->waitingSockets;	while (sock !!= nil) {		count++;		sock = sock->nextInListenerQueue;	}	/* create enough new sockets up to fill ListenerQueue to desired size */	socksToAdd = listener->desiredQueueLength - count;	while (socksToAdd > 0) {		newSock = TCPSockCreate();		if (newSock!!= nil) {			/* set semaphore of the new socket*/			newSock->semaIndex = listener->semaIndex;			/* record new socket in openTCPSockets */			newSock->next = openTCPSockets;			openTCPSockets = newSock;			/* add new socket to the listener queue and start it listening */			newSock->nextInListenerQueue = listener->waitingSockets;			listener->waitingSockets = newSock;			TCPSockListenOn(newSock, listener->localPort);		}		socksToAdd--;	}}TCPSockPtr FindConnectedSocket(ListenerQueuePtr listener) {  /* Return the first connected socket in the given ListenerQueue,     or nil if there isn''t one. */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if (sock->connectStatus == Connected) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}TCPSockPtr FindZombieSocket(ListenerQueuePtr listener) {  /* Return the first socket in the given ListenerQueue that is not connected or     waiting for a connection (we call this a zombie), or nil if there isn''t one.     Zombies are created when a connection is made but broken again before an     accept has been done. Since a zombie are no longer waiting for a connection,     it takes the place of listening socket. If the queue became filled with zombies     no connections could get through. Thus, zombies must be eliminated. As the     saying goes: "the only good zombie is a dead zombie." */	TCPSockPtr sock;	sock = listener->waitingSockets;	while (sock !!= nil) {		if ((sock->connectStatus !!= WaitingForConnection) &&			(sock->connectStatus !!= Connected)) return sock;		sock = sock->nextInListenerQueue;	}	return nil;}void sqSocketAcceptFromRecvBytesSendBytesSemaID(  SocketPtr s, SocketPtr serverSocket,  int recvBufSize, int sendBufSize, int semaIndex) {  /* Accept a connection for the given server socket. The server socket must     have been turned into a listener queue via sqSocketListenOnPortBacklogSize().     If successful, s is initialized to newly connected socket using the     given paramenters, and a new listening socket will be created and added     to the ListenerQueue to maintain the desired queue length. Note that MacTCP     allows multiple sockets to be listening on the same port number and, indeed,     this is the only way to support the Unix socket notion of a socket backlog. */	ListenerQueuePtr listener;	TCPSockPtr connectedSock;	/* server socket must be a valid ListenerQueue */	if ((serverSocket == nil) ||		(serverSocket->sessionID !!= thisNetSession) ||		(serverSocket->socketType !!= ListenerQueueType) ||		(serverSocket->privateSocketPtr == nil)) {			success(false);			return;	}	/* result socket must be a new, unintialized socket */	if ((s == nil) ||		(s->sessionID !!= 0) ||		(s->socketType !!= 0) ||		(s->privateSocketPtr !!= nil)) {			success(false);			return;	}	/* look for a connected socket */	listener = (ListenerQueuePtr) serverSocket->privateSocketPtr;	connectedSock = FindConnectedSocket(listener);	if (connectedSock == nil) {		success(false);	} else {		/* remove connected socket from the listener queue */		RemoveSocketFromListenerQueue(connectedSock, listener);		/* fill in the result socket handle */		connectedSock->semaIndex = semaIndex;		s->sessionID = thisNetSession;		s->socketType = TCPSocketType;		s->privateSocketPtr = connectedSock;	}	/* ensure that the queue has the desired number of listenening sockets */	FillListenerQueue(listener);}void RemoveSocketFromListenerQueue(TCPSockPtr sockToRemove, ListenerQueuePtr listener) {	TCPSockPtr lastSock, thisSock;	if (sockToRemove == nil) return;	if (listener->waitingSockets == sockToRemove) {		listener->waitingSockets = sockToRemove->nextInListenerQueue;		sockToRemove->nextInListenerQueue = nil;		return;	}	lastSock = listener->waitingSockets;	thisSock = lastSock->nextInListenerQueue;	while (thisSock !!= nil) {		if (thisSock == sockToRemove) {			lastSock->nextInListenerQueue = sockToRemove->nextInListenerQueue;			sockToRemove->nextInListenerQueue = nil;			return;		}		lastSock = thisSock;		thisSock = lastSock->nextInListenerQueue;	}}void sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize) {	TCPSockPtr tcpSocket;	ListenerQueuePtr listener;	/* s must be an TCP socket that is initialized but unconnected */	if ((!!SocketValid(s)) || (s->socketType !!= TCPSocketType)) {		success(false);		return;	}	tcpSocket = (TCPSockPtr) s->privateSocketPtr;	if (tcpSocket->connectStatus !!= Unconnected) {		success(false);		return;	}	/* make sure the port number is in range */	if (!!PortNumberValid(port)) {;		success(false);		return;	}	/* create a new listener on the given with the given backlog size */	listener = ListenerQueueCreate((TCPSockPtr) s->privateSocketPtr, port, backlogSize);	if (listener == nil) {		success(false);		return;	}	/* mutate s into a listener socket: replace the original TCP socket in s with	   the new listener, and change the type of s to ListenerQueueType */	s->socketType = ListenerQueueType;	s->privateSocketPtr = listener;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;	s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	if (s->lastError !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->connectStatus = Unconnected;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	s->lastError = noErr;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	s->lastError = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	int sendCount;	if ((s->connectStatus == Unconnected) || (s->connectStatus == WaitingForConnection)) {		success(false);		return 0;  /* fail if not connected */	}	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	s->lastError = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (s->lastError !!= noErr) {		s->sendInProgress = false;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	if (thisNetSession == 0) return;  /* noop if network is already shut down */	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	ResolverTerminate();	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}			return true;	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;	if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;	s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions (not yet implemented) ***/void * UDPSockCreate(void) {	return nil;}void UDPSockDestroy(UDPSockPtr s) {	s;}int UDPSockLocalAddress(UDPSockPtr s) {	s;}int UDPSockLocalPort(UDPSockPtr s) {	s;}int UDPSockRemoteAddress(UDPSockPtr s) {	s;}int UDPSockRemotePort(UDPSockPtr s) {	s;}void UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	s; addr; port;}void UDPSockListenOn(UDPSockPtr s, int port) {	s; port;}int UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}int UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	s; buf; bufSize;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 12/1/2000 22:27'!macWindowFile	^ '#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include <sound.h>#include <Math64.h>#include <cstddef>#include <processes.h>#include <OpenTransport.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape or IE Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE//#define IHAVENOHEAD//Aug 7th 2000,JMM Added logic for interrupt driven dispatching//Sept 1st 2000, JMM fix problem with modifier information being passed back incorrectly.//Sept 1st 2000, JMM use floating point for time versus 64bit math (faster!!)//Sept 1st 2000, JMM watch mouse movement foreground only, ignore when squeak in background.//Sept 18th 2000, JMM fix to cmpSize //Sept 19th 2000, JMM Sept 1st fix to keyboard modifier info broke cmd shift//Sept 27 2000, JMM fix to documentPath//Nov 13 2000, JMM logic to read/write image from VM. //Nov 22 2000, JMM Bob Arning found a bug with the duplicate mouse event logic (we were altering the event then recording the altered value)//Nov 30 2000, JMM Use Open Transport clock versus upTime, solves some issues for jitter and it''s faster#if TARGET_API_MAC_CARBON    #define EnableMenuItemCarbon(m1,v1)  EnableMenuItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableMenuItem(m1,v1);#else    #ifndef NewAEEventHandlerUPP    	#define NewAEEventHandlerUPP NewAEEventHandlerProc     #endif    #define EnableMenuItemCarbon(m1,v1)  EnableItem(m1,v1);    #define DisableMenuItemCarbon(m1,v1)  DisableItem(m1,v1);        inline Rect *GetPortBounds(CGrafPtr w,Rect *r) { *r = w->portRect; return &w->portRect;}          inline BitMap *GetQDGlobalsScreenBits(BitMap *bm){*bm = qd.screenBits; return &qd.screenBits; }        inline BitMap * GetPortBitMapForCopyBits (CGrafPtr w) { return &((GrafPtr)w)->portBits;}        inline pascal long InvalWindowRect(WindowRef  window,  const Rect * bounds) {InvalRect (bounds);}#endif/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/* The following prototype is missing from the CW11 header files: */pascal void ExitToShell(void);/*** Variables -- Imported from Browser Plugin Module ***/#ifdef PLUGINextern int pluginArgCount;extern char *pluginArgName[100];extern char *pluginArgValue[100];#endif/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image file */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document file */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;OTTimeStamp     timeStart;/*** Variables -- Event Recording ***/#define MAX_EVENT_BUFFER 1024int inputSemaphoreIndex = 0;/* if non-zero the event semaphore index */sqInputEvent eventBuffer[MAX_EVENT_BUFFER];int eventBufferGet = 0;int eventBufferPut = 0;/* declaration of the event message hook */typedef int (*eventMessageHook)(EventRecord* event);eventMessageHook messageHook = NULL;eventMessageHook postMessageHook = NULL;#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */int cachedButtonState = 0;	/* buffered mouse button and modifier state for							   last mouse click even if button has since gone up;							   this cache is kept until the next time ioGetButtonState()							   is called to avoid missing short clicks */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath);void MenuBarHide(void);void MenuBarRestore(void);int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID);int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short VolumeNumber,long directoryID);void SqueakTerminate();void ExitCleanup();int calculateStartLocationForImage();/* event capture */sqInputEvent *nextEventPut(void);int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);int recordMouseEvent(EventRecord *theEvent, int theButtonState);int recordKeyboardEvent(EventRecord *theEvent, int keyType);int MouseModifierState(EventRecord *theEvent);WindowPtr getSTWindow(void);int setMessageHook(eventMessageHook theHook);int setPostMessageHook(eventMessageHook theHook);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon);static pascal OSErr HandleOpenDocEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon);static pascal OSErr HandlePrintDocEvent(const AEDescList *aevt, AEDescList *reply, UInt32 refCon);static pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerUPP(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerUPP(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */    int                 checkValueForEmbeddedImage;    OSErr               err;	FSSpec		        fileSpec;	ProcessSerialNumber processID;	ProcessInfoRec      processInformation;	Str32                name; 		/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE,0,0);	checkValueForEmbeddedImage = calculateStartLocationForImage();	if (checkValueForEmbeddedImage == 0) {	    /* use default image name in same directory as the VM */	    strcpy(shortImageName, "squeak.image");	    return noErr;	}    GetCurrentProcess(&processID);     processInformation.processInfoLength = sizeof(ProcessInfoRec);    processInformation.processAppSpec = nil;    processInformation.processName = (StringPtr) &name;	err = GetProcessInformation(&processID,&processInformation);		if (err !!= noErr) {		strcpy(shortImageName, "squeak.image");	    return noErr;	}		CopyPascalStringToC(name,shortImageName);	StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,0,0);    return noErr;}pascal OSErr HandleOpenDocEvent(const AEDescList *aevt, AEDescList *reply, UInt32 refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	FInfo		finderInformation;	char 		tempShortName[SHORTIMAGE_NAME_SIZE + 1];			reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	PathToWorkingDir(vmPath, VMPATH_SIZE,0,0);		/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) return errAEEventNotHandled;;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;		if (shortImageName[0] !!= 0) {#ifdef IHAVENOHEAD		/* get image name */		err = AEGetNthPtr(&fileList, 1, typeFSS,						  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);		if (err) goto done;				err = FSpGetFInfo(&fileSpec,&finderInformation);		if (err) goto done;					CopyPascalStringToC(fileSpec.name,tempShortName);		if (finderInformation.fdType == ''SOBJ'') {			StoreFullPathForLocalNameInto(tempShortName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		}#endif		goto done;	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;		err = FSpGetFInfo(&fileSpec,&finderInformation);	if (err) goto done;			CopyPascalStringToC(fileSpec.name,shortImageName);	if (!!(IsImageName(shortImageName) || finderInformation.fdType == ''STim'') || finderInformation.fdType == ''STch'') {		/* record the document name, but run the default image in VM directory */		if (finderInformation.fdType == ''SOBJ'')			StoreFullPathForLocalNameInto(shortImageName, documentName, DOCUMENT_NAME_SIZE,fileSpec.vRefNum,fileSpec.parID);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,0,0);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(const AEDescList *aevt,  AEDescList *reply, UInt32 refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowRef		wp;	int				isDeskAccessory;	wp = FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = GetWindowKind(wp) < 0;	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableMenuItemCarbon(editMenu, 1);		EnableMenuItemCarbon(editMenu, 3);		EnableMenuItemCarbon(editMenu, 4);		EnableMenuItemCarbon(editMenu, 5);		EnableMenuItemCarbon(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableMenuItemCarbon(editMenu, 1);		DisableMenuItemCarbon(editMenu, 3);		DisableMenuItemCarbon(editMenu, 4);		DisableMenuItemCarbon(editMenu, 5);		DisableMenuItemCarbon(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	static EventRecord oldEvent;	int				ok;	Rect    bounds;	ok = WaitNextEvent(everyEvent, &theEvent,0,null);	if((messageHook) && (messageHook(&theEvent))) {        return ok;    }	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case mouseUp:				if(inputSemaphoreIndex) {					recordMouseEvent(&theEvent,MouseModifierState(&theEvent));    				if(postMessageHook) postMessageHook(&theEvent);					return false;				}				recordModifierButtons(&theEvent);				if(postMessageHook) postMessageHook(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyDown);					break;				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;						case keyUp:				if(inputSemaphoreIndex) {					recordKeyboardEvent(&theEvent,EventKeyUp);				}			break;#ifndef IHAVENOHEAD			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				GetPortBounds(GetWindowPort(stWindow),&bounds);				InvalWindowRect(stWindow,&bounds);			break;#endif			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;						case osEvt: 				if (((theEvent.message>>24)& 0xFF) == suspendResumeMessage) {									//JMM July 4th 2000					//Fix for menu bar tabbing, thanks to Javier Diaz-Reinoso for pointing this out					//					if (fullScreenFlag) {						if ((theEvent.message & resumeFlag) == 0) {							MenuBarRestore();						}						else {							MenuBarHide();						}					}				}				break;		}	}	else {		if(inputSemaphoreIndex && windowActive && 		    !!((oldEvent.what == theEvent.what) &&  		    (oldEvent.message == theEvent.message) && 		    ((oldEvent.where.v == theEvent.where.v) && (oldEvent.where.h == theEvent.where.h)) && 		    (oldEvent.modifiers == theEvent.modifiers))) {    		oldEvent = theEvent; //JMM Nov 11th 2000 bug fix 			recordMouseEvent(&theEvent,MouseModifierState(&theEvent)); 		} 		else		 oldEvent = theEvent;	}	if(postMessageHook) postMessageHook(&theEvent); 	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);#if !!TARGET_API_MAC_CARBON			OpenDeskAcc(name);#endif 			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:#if !!TARGET_API_MAC_CARBON			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}#endif		break;	}}void HandleMouseDown(EventRecord *theEvent) {    BitMap      bmap;	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:#if !!TARGET_API_MAC_CARBON			SystemClick(theEvent, theWindow);#endif		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;#ifndef IHAVENOHEAD		case inDrag:			GetQDGlobalsScreenBits(&bmap);			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &bmap.bounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				if(inputSemaphoreIndex) {					recordMouseEvent(theEvent,MouseModifierState(theEvent));					break;				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;#endif	}}#if TARGET_API_MAC_CARBONvoid InitMacintosh(void) {	FlushEvents(everyEvent, 0);	InitCursor();}void MenuBarHide(void) { 	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */    menuBarRegion = (RgnHandle) 1;    HideMenuBar();}void MenuBarRestore(void) {	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */    ShowMenuBar();    menuBarRegion = nil;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {}void FreeClipboard(void) {}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;       	clipSize = clipboardSize(); 	charsToMove = (count < clipSize) ? count : clipSize;    err = GetScrapFlavorData(scrap,kScrapFlavorTypeText,(long *) &charsToMove,(char *) byteArrayIndex + startIndex);    if (err !!= noErr) {         FreeClipboard();        return 0;           }	return charsToMove;}int clipboardSize(void) {	long count;	ScrapRef scrap;	OSStatus err;    err = GetCurrentScrap (&scrap);    if (err !!= noErr) return 0;           err = GetScrapFlavorSize (scrap, kScrapFlavorTypeText, &count); 	if (err !!= noErr) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ScrapRef scrap;	OSErr err;	err = ClearCurrentScrap();    err = GetCurrentScrap (&scrap);	err = PutScrapFlavor ( scrap, kScrapFlavorTypeText, kScrapFlavorMaskNone , count,  (const void *) (byteArrayIndex + startIndex));}#else void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */  	WindowPtr win; 		if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(GetGrayRgn(), menuBarRegion, GetGrayRgn());	LMSetMBarHeight(menuBarHeight);		win = FrontWindow();	if (win) {		CalcVis(win);		CalcVisBehind(win,menuBarRegion);	}	HiliteMenu(0);	DisposeRgn(menuBarRegion);		menuBarRegion = nil;	DrawMenuBar();}/*** Clipboard Support (text only for now) ***/Handle			clipboardBuffer = nil;void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;    //JMM locking    HLock(clipboardBuffer); 	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}    HUnlock(clipboardBuffer); 	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}#endifvoid SetUpMenus(void) {	long decideOnQuitMenu;		InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();#if TARGET_API_MAC_CARBON    Gestalt( gestaltMenuMgrAttr, &decideOnQuitMenu);    if (!!(decideOnQuitMenu & gestaltMenuMgrAquaLayoutMask))	        AppendMenu(fileMenu, "\pQuit");#else	AppendResMenu(appleMenu, ''DRVR'');    AppendMenu(fileMenu, "\pQuit");#endif 	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};#ifndef IHAVENOHEAD	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, false, 0);#endif}void SetWindowTitle(char *title) {    Str255 tempTitle;	CopyCStringToPascal(title,tempTitle);#ifndef IHAVENOHEAD	SetWTitle(stWindow, tempTitle);#endif}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int asciiChar, modifierBits, keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = modifierMap[(theEvent->modifiers >> 8) & 0x1F];	if ((modifierBits & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	keystate = (modifierBits << 8) | asciiChar;	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState = MouseModifierState(theEvent);	cachedButtonState = cachedButtonState | buttonState;}int MouseModifierState(EventRecord *theEvent) {	int stButtons;	stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {  /* is false if button is down */		stButtons = 4;		/* red button by default */		if ((theEvent->modifiers & optionKey) !!= 0) {			stButtons = 2;	/* yellow button if option down */		}		if ((theEvent->modifiers & cmdKey) !!= 0) {			stButtons = 1;	/* blue button if command down */		}	} 	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	return ((modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7));}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if ((theEvent->modifiers & btnState) == false) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordMouseEvent(EventRecord *theEvent, int theButtonState) {	sqMouseEvent *evt;		evt = (sqMouseEvent*) nextEventPut();	/* first the basics */	evt->type = EventTypeMouse;	evt->timeStamp = ioMSecs(); 	GlobalToLocal((Point *) &theEvent->where);	evt->x = theEvent->where.h;	evt->y = theEvent->where.v;	/* then the buttons */	evt->buttons = theButtonState & 0x07;	/* then the modifiers */	evt->modifiers = theButtonState >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}int recordKeyboardEvent(EventRecord *theEvent, int keyType) {	int stButtons = 0;	int asciiChar, modifierBits;	sqKeyboardEvent *evt, *extra;	evt = (sqKeyboardEvent*) nextEventPut();	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	asciiChar = theEvent->message & charCodeMask;	modifierBits = MouseModifierState(theEvent); //Capture mouse/option states	if (((modifierBits >> 3) & 0x9) == 0x9) {  /* command and shift */		if ((asciiChar >= 97) && (asciiChar <= 122)) {			/* convert ascii code of command-shift-letter to upper case */			asciiChar = asciiChar - 32;		}	}	/* first the basics */	evt->type = EventTypeKeyboard;	evt->timeStamp = ioMSecs();	/* now the key code */	/* press code must differentiate */	evt->charCode = (theEvent->message & keyCodeMask) >> 8;	evt->pressCode = keyType;	evt->modifiers = modifierBits >> 3;	/* clean up reserved */	evt->reserved1 = 0;	evt->reserved2 = 0;	/* generate extra character event */	if (keyType == EventKeyDown) {		extra = (sqKeyboardEvent*)nextEventPut();		*extra = *evt;		extra->charCode = asciiChar;		extra->pressCode = EventKeyChar;	}//	signalSemaphoreWithIndex(inputSemaphoreIndex);	return 1;}static sqInputEvent *nextEventPut(void) {	sqInputEvent *evt;	evt = eventBuffer + eventBufferPut;	eventBufferPut = (eventBufferPut + 1) % MAX_EVENT_BUFFER;	if (eventBufferGet == eventBufferPut) {		/* buffer overflow; drop the last event */		eventBufferGet = (eventBufferGet + 1) % MAX_EVENT_BUFFER;	}	return evt;}int ioSetInputSemaphore(int semaIndex) {	inputSemaphoreIndex = semaIndex;	return 1;}int ioGetNextEvent(sqInputEvent *evt) {	if (eventBufferGet == eventBufferPut) {		ioProcessEvents();	}	if (eventBufferGet == eventBufferPut) 		return false;	*evt = eventBuffer[eventBufferGet];	eventBufferGet = (eventBufferGet+1) % MAX_EVENT_BUFFER;	return true;}/*** Mac Specific External Primitive Support ***//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName) {	char pluginDirPath[1000];	CFragConnectionID libHandle;	Ptr mainAddr;	Str255 errorMsg,tempPluginName;	OSErr err;        	/* first, look in the "<Squeak VM directory>Plugins" directory for the library */	strcpy(pluginDirPath, vmPath);	#ifdef PLUGIN	strcat(pluginDirPath, ":Plugins");#else	strcat(pluginDirPath, "Plugins");#endif 	        libHandle = LoadLibViaPath(pluginName, pluginDirPath);	if (libHandle !!= nil) return (int) libHandle;#ifndef PLUGIN	/* second, look directly in Squeak VM directory for the library */	libHandle = LoadLibViaPath(pluginName, vmPath);	if (libHandle !!= nil) return (int) libHandle;        /* Lastly look for it as a shared import library */        CopyCStringToPascal(pluginName,tempPluginName);    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kLoadCFrag, &libHandle, &mainAddr, errorMsg);	if (err == noErr) 	    err = GetSharedLibrary(tempPluginName, kAnyCFragArch, kFindCFrag, &libHandle, &mainAddr, errorMsg);	if (libHandle !!= nil) return (int) libHandle;#endif    	return nil;}/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle) {	CFragSymbolClass ignored;	Ptr functionPtr = 0;	OSErr err;    Str255 tempLookupName;    	if (!!moduleHandle) return 0;	/* get the address of the desired primitive function */	CopyCStringToPascal(lookupName,tempLookupName);	err = FindSymbol(		(CFragConnectionID) moduleHandle, (unsigned char *) tempLookupName,		&functionPtr, &ignored);	if (err) return 0;	return (int) functionPtr;}/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle) {	CFragConnectionID libHandle;	OSErr err;	if (!!moduleHandle) return 0;	libHandle = (CFragConnectionID) moduleHandle;	err = CloseConnection(&libHandle);	return 0;}CFragConnectionID LoadLibViaPath(char *libName, char *pluginDirPath) {	short 				vRefNum;	long				ignore;	CInfoPBRec 			pb;	FSSpec				fileSpec;	Str255				problemLibName,fileSpecName,tempPlugindirPath;    Ptr					junk;	CFragConnectionID	libHandle = 0;	OSErr				err = noErr;	/* get the default volume */	HGetVol( nil, &vRefNum, &ignore);	/* get the directory ID for the given path */	CopyCStringToPascal(pluginDirPath,tempPlugindirPath);	pb.hFileInfo.ioNamePtr = tempPlugindirPath;	pb.hFileInfo.ioVRefNum = 0;  /* use the default volume */	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	err = PBGetCatInfoSync(&pb);	if (err) return nil; /* bad plugin directory path */	/* make a file spec for the given file name in the plugin directory */	CopyCStringToPascal(libName,fileSpecName);	FSMakeFSSpec(vRefNum,pb.hFileInfo.ioDirID,fileSpecName,&fileSpec);	err = GetDiskFragment(		&fileSpec, 0, kCFragGoesToEOF, nil, kLoadCFrag, &libHandle, &junk, problemLibName);	if (err) return nil;	return libHandle;}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}#ifndef PLUGINint ioExit(void) {	ioShutdownAllModules();	MenuBarRestore();	ExitToShell();}#endifint ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	if ((cachedButtonState & 0x7) !!= 0) {		int result = cachedButtonState;		cachedButtonState = 0;  /* clear cached button state */		return result;	}	cachedButtonState = 0;  /* clear cached button state */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioHasDisplayDepth(int depth) {	/* Return true if this platform supports the given color display depth. */	switch (depth) {	case 1:	case 2:	case 4:	case 8:	case 16:	case 32:		return true;	}	return false;}int ioMicroMSecsExpensive(void);int ioMicroMSecsExpensive(void) {	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}#if TARGET_CPU_PPC || GENERATINGPOWERPCint ioMicroMSecs(void) {	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. */		register long check;		if((Ptr)OTElapsedMilliseconds!!=(Ptr)kUnresolvedCFragSymbolAddress){    	check = OTElapsedMilliseconds(&timeStart);    	if (check !!= -1)     	    return check;    	OTGetTimeStamp(&timeStart);	    return ioMicroMSecs();	}else {	    return ioMicroMSecsExpensive();	}}#elseint ioMicroMSecs(void) {    return ioMicroMSecsExpensive();}#endifint ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	return ioMicroMSecs();}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	const int nextPollOffsetCheck = (CLOCKS_PER_SEC/30);	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + nextPollOffsetCheck;	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * ioProcessEvents(), which gives other applications a chance to run.	 */    microSeconds;    	ioProcessEvents();  /* process all pending events */}#ifndef PLUGINint ioScreenSize(void) {	int w = 10, h = 10;    Rect portRect;    #ifndef IHAVENOHEAD	if (stWindow !!= nil) {        GetPortBounds(GetWindowPort(stWindow),&portRect);		w =  portRect.right -  portRect.left;		h =  portRect.bottom - portRect.top;	}#endif	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}#endifint ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag) {	/* Set the window to the given width, height, and color depth. Put the window	   into the full screen mode specified by fullscreenFlag. */	/* Note: Changing display depth is not yet, and may never be, implemented	   on the Macintosh, where (a) it is considered inappropriate and (b) it may	   not even be a well-defined operation if the Squeak window spans several	   displays (which display''s depth should be changed?). */	depth;#ifndef IHAVENOHEAD	ioSetFullScreen(fullscreenFlag);	if (!!fullscreenFlag) {		SizeWindow(stWindow, width, height, true);	}#endif}#ifndef PLUGINint ioSetFullScreen(int fullScreen) {	Rect screen,portRect;	BitMap bmap;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;				GetQDGlobalsScreenBits(&bmap);    screen = bmap.bounds;    	if (fullScreen) {		MenuBarHide();		GetPortBounds(GetWindowPort(stWindow),&portRect);		oldWidth =  portRect.right -  portRect.left;		oldHeight =  portRect.bottom -  portRect.top;		width  = screen.right - screen.left; 		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}#endifint ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;    if (depth<=8) { /*Duane Maxwell <dmaxwell@exobox.com> fix cmpSize Sept 18,2000 */    	(*stPixMap)->cmpSize = depth;    	(*stPixMap)->cmpCount = 1;    } else if (depth==16) {    	(*stPixMap)->cmpSize = 5;    	(*stPixMap)->cmpCount = 3;    } else if (depth==32) {    	(*stPixMap)->cmpSize = 8;    	(*stPixMap)->cmpCount = 3;    }	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPortWindowPort(stWindow);	CopyBits((BitMap *) *stPixMap, GetPortBitMapForCopyBits(GetWindowPort(stWindow)), &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length, short volumeNumber,long directoryID) {	int offset, sz, i;	offset = PathToWorkingDir(fullName, length, volumeNumber, directoryID);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Initializing the path to Working Dir ***/int PathToWorkingDir(char *pathName, int pathNameMax, short volumeNumber,long directoryID) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	Str255 thisName;	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy((char *) thisName, ":");	CopyCStringToPascal((const char *)thisName,thisName);	pb.hFileInfo.ioNamePtr = thisName;	pb.hFileInfo.ioVRefNum = volumeNumber;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = directoryID;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}    	CopyPascalStringToC((unsigned char *)thisName,(char *) thisName);		pathLen = PrefixPathWith(pathName, pathLen, pathNameMax,(char *) thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}int PrefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		return pathNameSize;	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = '':'';  /* insert delimitor */	return pathNameSize + offset;}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	fullImagePath;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	/* clear all path and file names */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	SetUpClipboard();	SetUpPixmap();}int plugInShutdown(void) {	ioShutdownAllModules();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}#ifndef PLUGINint plugInAllowAccessToFilePath(char *pathString, int pathStringLength) {  /* Grant permission to all files. */	pathString; pathStringLength;	return true;}#endif/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	/* Note: 1.3x images will try to read the image as a document because they	   expect attribute #1 to be the document name. A 1.3x image can be patched	   using a VM of 2.6 or earlier. */	if (id == 1) return imageName;	if (id == 2) return documentName;#ifdef PLUGIN	/* When running in browser, return the EMBED tag info */	if ((id > 2) && (id <= (2 + (2 * pluginArgCount)))) {		int i = id - 3;		if ((i & 1) == 0) {  /* i is even */			return pluginArgName[i/2];		} else {			return pluginArgValue[i/2];		}	}#endif	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	Str255 tempPascalFileName;     FInfo fileInfo;	CopyCStringToPascal(fileName,tempPascalFileName);	if (strchr(mode, ''w'') !!= null) 	    err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);	 else	    err = HOpenDF(0,0,tempPascalFileName,fsRdPerm, &fRefNum);	    	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = HCreate(0,0,tempPascalFileName,  ''FAST'', ''STim'');		if (err2 == 0) {			err = HOpenDF(0,0,tempPascalFileName,fsRdWrPerm, &fRefNum);		}	}	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {        err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);        if (err !!= noErr) return 0; //This should not happen                //On the mac we start at location 0 if this isn''t an VM            	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')){    		/* truncate non-VM file if opening in write mode */    		err = SetEOF(fRefNum, 0);    		if (err !!= 0) {    			FSClose(fRefNum);    			return null;    		}	    }	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}int calculateStartLocationForImage() { 	Handle cfrgResource;  	long	memberCount,i;	CFragResourceMember *target;	Str255 tempPascalFileName;	OSErr   err;    int     resFileRef;		cfrgResource = GetResource(kCFragResourceType,0); 	if (cfrgResource == nil || ResError() !!= noErr) { return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {        ReleaseResource(cfrgResource);	    return 0; //Need FAT to get counters right	}		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {					    ReleaseResource(cfrgResource);		    return target->offset;		}		target = NextCFragResourceMemberPtr(target); 	}    ReleaseResource(cfrgResource);	return 0;}int sqImageFileStartLocation(int fileRef, char *filename, int imageSize){    FInfo fileInfo;	Str255 tempPascalFileName;	OSErr   err;     int     resFileRef;	Handle  cfrgResource,newcfrgResource;  	UInt32	maxOffset=0,maxOffsetLength,targetOffset;	long    memberCount,i;	CFragResourceMember *target;      	CopyCStringToPascal(filename,tempPascalFileName);    err = HGetFInfo(0,0,tempPascalFileName,&fileInfo);    if (err !!= noErr) return 0; //This should not happen        //On the mac we start at location 0 if this isn''t an VM    	if (!!(fileInfo.fdType == ''APPL'' && fileInfo.fdCreator == ''FAST'')) return 0;        //Ok we have an application file, open the resource part and attempt to find the crfg        resFileRef = HOpenResFile(0,0,tempPascalFileName,fsWrPerm);    if (resFileRef == -1) return 0;    	cfrgResource = GetResource(kCFragResourceType,0);	if (cfrgResource == nil || ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  		memberCount = ((CFragResource *)(*cfrgResource))->memberCount;	if (memberCount <= 1) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};  //Need FAT to get counters right		target = &((CFragResource *)(*cfrgResource))->firstMember;	for(i=0;i<memberCount;i++) {		if (target->architecture == ''FAST'') {		    targetOffset = target->offset;		    target->length = imageSize;		    ChangedResource(cfrgResource);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		    UpdateResFile(resFileRef);        	if (ResError() !!= noErr) {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;};             ReleaseResource(cfrgResource); 		    CloseResFile(resFileRef);			return targetOffset;		}		if (target->offset > maxOffset) {			maxOffset = target->offset;			maxOffsetLength = target->length;		}		target = NextCFragResourceMemberPtr(target);	}		//Ok at this point we need to alter the crfg to add the new tag for the image part		newcfrgResource = cfrgResource;	err = HandToHand(&newcfrgResource);	if (err !!= noErr || MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 	SetHandleSize(newcfrgResource,GetHandleSize(cfrgResource)+AlignToFour(kBaseCFragResourceMemberSize + 1));	if (MemError() !!= noErr)  {ReleaseResource(cfrgResource); CloseResFile(resFileRef); return 0;}; 		target = &((CFragResource *)(*newcfrgResource))->firstMember; 	for(i=0;i<memberCount;i++) {		target = NextCFragResourceMemberPtr(target); 	}    target->architecture = ''FAST'';    target->reservedA = 0;                  /* !! Must be zero!!*/    target->reservedB = 0;                  /* !! Must be zero!!*/    target->updateLevel = 0;    target->currentVersion = 0;    target->oldDefVersion = 0;    target->uUsage1.appStackSize = 0;    target->uUsage2.appSubdirID = 0;    target->uUsage2.libFlags = 0;    target->usage = kApplicationCFrag;    target->where = kDataForkCFragLocator;    target->offset = maxOffset + maxOffsetLength;    targetOffset = target->offset;    target->length = imageSize;    target->uWhere1.spaceID = 0;    target->uWhere1.forkKind = 0;    target->uWhere2.forkInstance = 0;    target->extensionCount = 0;             /* The number of extensions beyond the name.*/    target->memberSize = AlignToFour(kBaseCFragResourceMemberSize + 1);   /* Size in bytes, includes all extensions.*/    target->name[0] = 0x00;	((CFragResource *)(*newcfrgResource))->memberCount = memberCount+1;	RemoveResource(cfrgResource);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};  	AddResource(newcfrgResource,kCFragResourceType,0,nil);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     UpdateResFile(resFileRef);	if (ResError() !!= noErr) {CloseResFile(resFileRef); return 0;};     CloseResFile(resFileRef);    	return targetOffset;}#ifndef PLUGINvoid * sqAllocateMemory(int minHeapSize, int desiredHeapSize) {	/* Application allocates Squeak object heap memory from its own heap. */	minHeapSize;	MaxBlock();	return NewPtr(desiredHeapSize);}#endif/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	SetEventMask(everyEvent); // also get key up events	#if TARGET_CPU_PPC || GENERATINGPOWERPC	if((Ptr)OTGetTimeStamp!!=(Ptr)kUnresolvedCFragSymbolAddress) 	    OTGetTimeStamp(&timeStart);#endif	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE,0,0);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 500000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 50K to that.)	    	    JMM Note changed to 500 for Open Transport support on 68K machines	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSizeStartingAt(f, availableMemory, calculateStartLocationForImage());	sqImageFileClose(f);#ifndef IHAVENOHEAD	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);#endif	/* run Squeak */	interpret();}#endifvoid SqueakTerminate() {#ifdef PLUGIN	ExitCleanup();#else	ioShutdownAllModules();#endif}WindowPtr getSTWindow(void) {    return stWindow;}int setMessageHook(eventMessageHook theHook) {    messageHook = theHook;}int setPostMessageHook(eventMessageHook theHook) {    postMessageHook = theHook;}#if !!TARGET_API_MAC_CARBON////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src !!= NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = ''\0'';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string''s length is set to zero//void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar !!= ''\0'' ) 		{			unsigned char	nextChar;						// use nextChar so we don''t overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src !!= NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can''t do the K&R C thing of while (*s++ = *t++) because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) !!= 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 12/1/2000 22:44'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built using the following source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqVirtualMachine.h	-- support for dynamic primitives	sqADPCMPrims.c		-- ADCPM sound compression primitives	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystickAndTablet.c -- Mac support for Wacom tablets and GravisMouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqNamedPrims.c		-- support for named primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backwardcompatibility	sqVirtualMachine.c	-- support for dynamic primitives	interp.c				-- automatically generated code for the virtualmachineIn addition to these files, a number of .h and .c files are generated when Squeakgenerates a new interpreter. The exact set of files depends on which sets ofprimitives are included. In general, all the files created by this process shouldbe visible to the CW project and all the generated .c files should be added tothe CW project. Don''t worry--the linker will tell you if you forget something.The platform specific files are sqMacXXX.c, totaling about 2000 lines of codewhen this document was originally written. All other code is written to standardANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubsout all non-essential support functions and, together with sqFilePrims.c, allowsone to build a functioning virtual machine that only lacks non-essential I/Ofunctions (including support for file directory enumeration, which is not reallyessential!!). The small size of this file demonstrates how little code is reallyneeded to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the majorSqueak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8bytes; these assumptions are checked at start up time. Float objects in the imageare stored in the IEEE standard byte ordering for double-precision floats on allplatforms; macros in sq.h can be defined to swap bytes into and out of theplatform native float format if necessary. (To ensure proper word alignment, onetypically has to copy a Squeak Float object into a C "double" variable beforeoperating on it; byte swapping can be done while doing this copy for little or noadditional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generatedautomatically, so changes to these files will be lost when they are nextgenerated. It is fine to make ephemeral changes to these file for the purpose ofdebugging or statistics gathering. To generate the interpreter, see the"translation" category in Interpreter class. To generate sqSoundPrims.c, see theclass method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrior 11. Earlier, I usedSemantec Think C 6.0, but discovered a few bugs in their libraries having to dowith 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler byHans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need tocreate an empty "MacHeaders.h" file. You may get some harmless compiler warningsand, for peak performance, the method that patches the dispatch loop must also bechanged. Hans-Martin says: "The whole VM seems to be marginally slower than thedelivered VM, but it is significantly smaller."Note that Jitter 3 (Squeak V3.x) has migrated to Gnu GCC, and MPW. As of late fall 2000there is no 68K version, but the macintosh specific source is the same as for CW.The virtual machine uses the following libraries:	Libraries for 68K Project:		dnr.c		InterfaceLib		MathLibCFM68K (4i/8d).Lib		MSL C.CFM68K Far(4i/8d).Lib		MWCFM68KRuntime.Lib		Profiler68kCFM.lib		QuickTimeLib				//Optional only to build OT version of 68K do not include in regularbuild		OpenTpt68kATalkLib		OpenTpt68kClientLib		OpenTpt68kInetLib		OpenTpt68kUtilLib	Libraries for PowerPC Project:		InterfaceLib		MathLib		MSL C.PPC.Lib		MWCRuntime.Lib		profilerPPC.lib		QuickTimeLib		OpenTptInetPPC.o		OpenTptInternetLib		OpenTransportExtnPPC.o		OpenTransportLibThe 68K Mac networking code also requires three files from Apple''s MacTCPdeveloper''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.The shipping 68K version of Squeak uses the older MacTCP interface. You can alterthe sqMacNetwork.c file and compile your own 68K verion of Squeak that uses thenew Open Transport version, but the availability of the 68K version of OpenTransport V1.3 is limited to 68040 machines that run system 8.1. You can run thisconfiguration on a 68030 using system 7.5.x but Apple does not support thatconfiguration.To build a fat binary, build the 68K version first, and make sure that the file"Squeak VM 68K" is included in the PowerPC project. Then build the PowerPCversion. CodeWarrior will include the 68K interpreter in the resource fork of theoutput file, resulting in an interpreter that runs on either 68K or PowerPC Macs.(JMM) Note I had some problems building the FAT application with CW11 I had tocopy the SqueakApp.rsrc items over to the application after it was built, theseresources aren''t copied from the 68K application like the documentation says theyshould.To get an additional speedup, the object code for the bytecode dispatch loop ofthe PPC version can be patched using the method "patchInterp:" in Interpreterclass.Note: In order to support dynamically loaded primitives, we have switched tousing Code Fragement Manager model for the 68K VM. This has severalramifications:  1. You now need to use the CFM versions of the library files. The 68K projectfile has been updated accordingly.  2. You cannot run the 68K VM under the emulator on the PowerPC (Apple doesn''tsupport CFM apps under the 68K emulator).  3. You need to be sure that version 4.0 or later of "CFM-68K Runtime Enabler"is in the Extensions folder of the system folder on your 68K Mac. *** Warning:Older versions of "CFM-68K Runtime Enabler" had bugs that will probably preventSqueak from even starting!! ***.CarbonWe do not include a Carbon ready project at this time. Much of the work to make aCarbon application is done, however we are still missing versions of the soundplugin and the serialMidi plugin which are Carbon compliant. Building Named Primitive PluginsI''ve included a pair of sample projects for building Squeak primitive plugins. Asusual, you must build the 68K version first, then the FAT one. If you don''t needa FAT version, you can remove the 68K project from the PPC one.Pluginized VMSqueak 2.8 introduces the "pluginized VM". In the interest of getting a Macversion of the 2.8 out as quickly and with as little chance of introducing bugsas possible, I''ve made the bare minimal changes to the Mac support files. Forthis reason, all the Mac primitives that were previously linked into the VM muststill be built into the VM as "internal" primitives. That is because many of themstill access a few VM functions and variables directly, rather than callingthrough the interpreter proxy, which they must in order to run in an externalplugin. One can still override these builtin primitives with an external pluginand, of course, newly built plugins can be created as external or internalplugins. When the dust settles, it will be easy to make the final few changesrequired.Building Squeak as a Browser PluginI''ve included an archive containing a CW project file and various supportingfiles for building the Squeak VM as plugin for Netscape or Internet Explorer onthe Mac. The plugin works with versions 4.0 or later of either browser. However,the primitives that can be used to ask the browser to fetch a URL do not work inversions of IE earlier than 5.0. There are also two resource files the containthe strings needed to tell the browser about the plugin--its name, version, andthe mime and file extensions it recognizes.To build this, you will need a copy of the Netscape Plugin SDK, available forfree at their web site. The required support files are:	jri.h	jritypes.h	jri_md.h	npapi.h	npmac.cpp	npupp.hThe installation and use of Squeak as a browser plugin is somewhat beyond thescope of this readme file. The basic idea is that the Squeak image started by thebrowser lives in a pre-defined directory ("SystemFolder:Preferences:Squeak:Internet" by default) with predefined name (e.g.,"squeak.image"). The browser plugin can only read and write files within theInternet directory and directories contained within it. This is called Squeakfile system "sand box". The browser captures most of the command key combination,so you have to use the menus rather than your favorite Squeak command keyshortcuts. {Note that using the full screen option allows you to again use thecommand key combinations and has better performance characteristics.} The browseralso captures cmd-., so the interrupt key when running under the browser iscontrol-C. The most flexible way to invoke Squeak is through the HTML "EMBED"command. This allows arbitrary arguments to be made available to Squeak. The"memory" EMBED tag can be used to tell Squeak how much memory is required by agiven Squeaklet.To build a browser plugin VM, do the following:  1. translate a browser plugin version of the interpreter (usingInterpreter>translateForBrowserPlugin:).  2. edit the file sqMacWindow.c and uncomment the #define of "PLUGIN"  3. edit the file platform.exports and uncomment the #define of "PLUGIN"  4. build the plugin using the supplied browser plugin projectIf you build your own project file, note that IE requires that the main entrypoint be "main" rather than CW''s usual "__start". (Netscape doesn''t care, so ittook me a long time to figure out why it wasn''t working under IE!!) The suppliedproject produces a PPC-only plugin.	-- John Maloney, May 25, 2000,	-- Changes John M McIntosh Aug 2, 2000, Dec 1,2000'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 12/1/2000 22:24'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#include "sqVirtualMachine.h"#define true 1#define false 0#define null 0  /* using "null" because nil is predefined in Think C *//* pluggable primitives macros *//* Note: All pluggable primitives are defined as	EXPORT(int) somePrimitive(void)   If the platform requires special declaration modifiers   the EXPORT macro can be redefined*/#define EXPORT(returnType) returnType/* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqImageFileStartLocation(fileRef, fileName, size)  0#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* platform-dependent memory size adjustment macro *//* Note: This macro can be redefined to allows platforms with a   fixed application memory partition (notably, the Macintosh)   to reserve extra C heap memory for special applications that need   it (e.g., for a 3D graphics library). Since most platforms can   extend their application memory partition at run time if needed,   this macro is defined as a noop here and redefined if necessary   in sqPlatformSpecific.h.*/#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) origHeapSize/* platform-dependent millisecond clock macros *//* Note: The Squeak VM uses three different clocks functions for   timing. The primary one, ioMSecs(), is used to implement Delay   and Time millisecondClockValue. The resolution of this clock   determines the resolution of these basic timing functions. For   doing real-time control of music and MIDI, a clock with resolution   down to one millisecond is preferred, but a coarser clock (say,   1/60th second) can be used in a pinch. The VM calls a different   clock function, ioLowResMSecs(), in order to detect long-running   primitives. This function must be inexpensive to call because when   a Delay is active it is polled twice per primitive call. On several   platforms (Mac, Win32), the high-resolution system clock used in   ioMSecs() would incur enough overhead in this case to slow down the   the VM significantly. Thus, a cheaper clock with low resolution is   used to implement ioLowResMSecs() on these platforms. Finally, the   function ioMicroMSecs() is used only to collect timing statistics   for the garbage collector and other VM facilities. (The function   name is meant to suggest that the function is based on a clock   with microsecond accuracy, even though the times it returns are   in units of milliseconds.) This clock must have enough precision to   provide accurate timings, and normally isn''t called frequently   enough to slow down the VM. Thus, it can use a more expensive clock   that ioMSecs(). By default, all three clock functions are defined   here as macros based on the standard C library function clock().   Any of these macros can be overridden in sqPlatformSpecific.h.*/int ioMSecs(void);int ioLowResMSecs(void);int ioMicroMSecs(void);#define ioMSecs()		((1000 * clock()) / CLOCKS_PER_SEC)#define ioLowResMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)#define ioMicroMSecs()	((1000 * clock()) / CLOCKS_PER_SEC)/* filename copy/transform macro. An opportunity to transform the filenames for   platforms with strange needs, anda simple encapsulation for everyone else*/#define sqFilenameFromString(dst, src, num) \if (1) { \	int i; \	for (i = 0; i < num; i++) { \		dst[i] = *((char *) (src + i)); \	} \	dst[num] = 0;\}/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);int ioHasDisplayDepth(int depth);int ioSetDisplayMode(int width, int height, int depth, int fullscreenFlag);/* User input recording I:   In general, either set of input function can be supported,   depending on the platform. This (first) set is state based   and should be supported even on platforms that make use   of the newer event driven API to support older images    without event support.*/int ioGetButtonState(void);int ioGetKeystroke(void);int ioMousePoint(void);int ioPeekKeystroke(void);/* Note: In an event driven architecture, ioProcessEvents is obsolete.   It can be implemented as a no-op since the image will check for   events in regular intervals. */int ioProcessEvents(void);/* User input recording II:   The following functions and definition can be used on   platform supporting events directly.*//* types of events */#define EventTypeNone 0#define EventTypeMouse 1#define EventTypeKeyboard 2/* keypress state for keyboard events */#define EventKeyChar 0#define EventKeyDown 1#define EventKeyUp 2/* button definitions */#define RedButtonBit 4#define BlueButtonBit 2#define YellowButtonBit 1/* modifier definitions */#define ShiftKeyBit 1#define CtrlKeyBit 2#define OptionKeyBit 4#define CommandKeyBit 8/* generic input event definition */typedef struct sqInputEvent {	int type; /* type of event; either one of EventTypeXXX */	unsigned int timeStamp; /* time stamp */     /* the interpretation of the following fields depend on the type of the event */	int unused1;	int unused2;	int unused3;	int unused4;	int unused5;	int unused6;} sqInputEvent;/* mouse input event definition */typedef struct sqMouseEvent {	int type; /* EventTypeMouse */	unsigned int timeStamp; /* time stamp */	int x; /* mouse position x */	int y; /* mouse position y */	int buttons; /* combination of xxxButtonBit */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */} sqMouseEvent;/* keyboard input event definition */typedef struct sqKeyboardEvent {	int type; /* EventTypeKeyboard */	unsigned int timeStamp; /* time stamp */	int charCode; /* character code in Mac Roman encoding */	int pressCode; /* press code; any of EventKeyXXX */	int modifiers; /* combination of xxxKeyBit */	int reserved1; /* reserved for future use */	int reserved2; /* reserved for future use */	int reserved3; /* reserved for future use */} sqKeyboardEvent;/* set an asynchronous input semaphore index for events */int ioSetInputSemaphore(int semaIndex);/* retrieve the next input event from the OS */int ioGetNextEvent(sqInputEvent *evt);/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore *//* Read the image from the given file starting at the given image offset */int readImageFromFileHeapSizeStartingAt(sqImageFile f, int desiredHeapSize, int imageOffset);/* NOTE: The following is obsolete - it is only provided for compatibility */#define readImageFromFileHeapSize(f, s) readImageFromFileHeapSizeStartingAt(f,s,0)/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* browser plug-in support */int plugInAllowAccessToFilePath(char *pathString, int pathStringLength);void plugInForceTimeToReturn(void);int plugInInit(char *imageName);int plugInNotifyUser(char *msg);void plugInSetStartTime(void);int plugInShutdown(void);int plugInTimeToReturn(void);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* ar 5/13/2000:	The following set of miscellaneous and sound primitives should	at some point go into named primitives. Right now there are a few	problems with that (related to how the distinct set of methods can	be defined as residing in one plugin).*//* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringfindSubstringinstartingAtmatchTable(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int oldprimSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/*** sound compression primitives ***/int primADPCMCodecprivateDecodeMono(void);int primADPCMCodecprivateDecodeStereo(void);int primADPCMCodecprivateEncodeMono(void);int primADPCMCodecprivateEncodeStereo(void);/*** pluggable primitive support ***//* NOTE: The following functions are those implemented by sqNamedPrims.c */int ioLoadExternalFunctionOfLengthFromModuleOfLength(  int functionNameIndex, int functionNameLength,  int moduleNameIndex, int moduleNameLength);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadFunctionFrom(char *functionName, char *pluginName);int ioShutdownAllModules(void);int ioUnloadModule(char *);int ioUnloadModuleOfLength(int moduleNameIndex, int moduleNameLength);char *ioListBuiltinModule(int moduleIndex);char *ioListLoadedModule(int moduleIndex);/* The next two are FFI entries!! (implemented in sqNamedPrims.c as well) */int ioLoadModuleOfLength(int moduleNameIndex, int moduleNameLength);int ioLoadSymbolOfLengthFromModule(int functionNameIndex, int functionNameLength, int moduleHandle);/* The next three functions must be implemented by sqXYZExternalPrims.c *//* ioLoadModule:	Load a module from disk.	WARNING: this always loads a *new* module. Don''t even attempt to find a loaded one.	WARNING: never primitiveFail() within, just return 0*/int ioLoadModule(char *pluginName);/* ioFindExternalFunctionIn:	Find the function with the given name in the moduleHandle.	WARNING: never primitiveFail() within, just return 0.*/int ioFindExternalFunctionIn(char *lookupName, int moduleHandle);/* ioFreeModule:	Free the module with the associated handle.	WARNING: never primitiveFail() within, just return 0.*/int ioFreeModule(int moduleHandle);/* The Squeak version this interpreter was generated from */extern const char *interpreterVersion;'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'JMM 12/1/2000 22:25'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*/#ifdef UNIX/* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs#undef ioLowResMSecs#endif /* UNIX */#ifdef macintosh/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#undef sqImageFileStartLocation#undef sqAllocateMemorytypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);int         sqImageFileStartLocation(int fileRef, char *filename, int imageSize);void *						sqAllocateMemory(int minHeapSize, int desiredHeapSize);/* override reserveExtraCHeapBytes() macro to reduce Squeak object heap size on Mac */#undef reserveExtraCHeapBytes#define reserveExtraCHeapBytes(origHeapSize, bytesToReserve) (origHeapSize - bytesToReserve)/* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioMicroMSecs/* macro to return from interpret() loop in browser plugin VM */#define ReturnFromInterpret() return/* prototypes missing from CW11 headers */#include <textutils.h>void CopyPascalStringToC(ConstStr255Param src, char* dst);void CopyCStringToPascal(const char* src, Str255 dst);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num)/* string copying macro to compensate for bug in Acorn library code */#define copyNCharsFromTo(num, src, dst)\if(1) {int sqfni;\	char cc;\	for (sqfni = 0; sqfni < num; sqfni++) {\		dst[sqfni] = cc = *((char *) (src + sqfni));\		if ( cc == 0) break;\	}\	dst[num] = 0;\}/* undefine clock macros that are implemented as functions */#undef ioMicroMSecs#undef ioMSecs#define ioMSecs() (10* (int)os_read_monotonic_time())#undef ioLowResMSecs#define ioLowResMSecs() (ioMSecs())#endif /* ACORN */#ifdef WIN32/* Override necessary definitions */#undef putchar#include "sqWin32Alloc.h"#ifdef WIN32_FILE_SUPPORT#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWrite#define sqImageFile unsigned longint sqImageFileClose(sqImageFile h);sqImageFile sqImageFileOpen(char *fileName, char *mode);int sqImageFilePosition(sqImageFile h);int sqImageFileRead(void *ptr, int sz, int count, sqImageFile h);int sqImageFileSeek(sqImageFile h, int pos);int sqImageFileWrite(void *ptr, int sz, int count, sqImageFile h);#endif /* WIN32_FILE_SUPPORT *//* pluggable primitive support */#if defined(_MSC_VER) || defined(__MINGW32__)#  undef EXPORT#  define EXPORT(returnType) __declspec( dllexport ) returnType#endif /* undefine clock macros that are implemented as functions */#undef ioMSecs#undef ioLowResMSecs#undef ioMicroMSecs/* Declare GetTickCount() in case <windows.h> is not included */#if !!defined(_WINDOWS_) && !!defined(_WIN32_WCE) && !!defined(_WINDOWS_H)__declspec(dllimport) unsigned long __stdcall GetTickCount(void);#endif#define ioLowResMSecs() GetTickCount()#endif /* WIN32 */'! !