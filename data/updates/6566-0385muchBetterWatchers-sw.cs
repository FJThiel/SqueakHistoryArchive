'From Squeakland 3.8.5976 of 25 August 2004 [latest update: #384] on 6 January 2005 at 6:17:15 pm'!"Change Set:		muchBetterWatchers-swDate:			6 January 2005Author:			Scott WallaceEnhancements to etoy watchers:* Readouts for all watchers are now type-appropriate.  Up until now, all readouts had been textual; now for a color type you'll get a watcher showing a color swatch, and so forth down through all the available types.*  So-called 'fancy watchers' are now allowed on variables of any type, not just numbers, and, as for the simple watchers, the readout supplied is type-appropriate.*  The *name* of a watcher now reveals its provenance.  Formerly, it was extremely difficult to figure out what a simple watcher was watching.  And the watcher is dynamically updated to track the name of the object it is watching.*  When you drop a slot-retriever phrase (such as car's x) on the desktop, if the new preference #dropProducesWatcher is true, a watcher will be produced.  Try it, you may like it!!*  A watcher can be dropped into a type-compatible tile pad in a script.*  Some adjustments made to which data-types can be ascribed to user-defined variables."!!BooleanType commentStamp: 'sw 1/5/2005 22:15' prior: 0!A data type representing Boolean values, i.e., true or false.!!ColorType commentStamp: 'sw 1/5/2005 22:15' prior: 0!A data type representing a Color value.!!MenuType commentStamp: 'sw 1/6/2005 03:45' prior: 0!A type associated with menu-item values.  An imperfect thing thus far, only usable in the doMenuItem etoy scripting phrase.!!SymbolListType commentStamp: 'sw 1/6/2005 17:52' prior: 0!A type whose values range across a finite set of symbols, which are held in the "symbols" instance variable.!!ThumbnailMorph commentStamp: 'sw 1/6/2005 03:47' prior: 0!A Morph that views another morph, its objectToView.!AlignmentMorph subclass: #WatcherWrapper	instanceVariableNames: 'player variableName'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting Support'!!WatcherWrapper commentStamp: 'sw 1/6/2005 00:06' prior: 0!A wrapper around either kind of watcher.  My primary raison d'etre is so that I can automatically change names when my player changes names.!!DataType methodsFor: 'tiles' stamp: 'sw 1/6/2005 04:29'!addWatcherItemsToMenu: aMenu forGetter: aGetter	"Add watcher items to the menu if appropriate, provided the getter is not an odd-ball one for which a watcher makes no sense"	(Vocabulary gettersForbiddenFromWatchers includes: aGetter) ifFalse:		[aMenu add: 'unlabeled watcher' translated selector: #tearOffUnlabeledWatcherFor: argument: aGetter.		aMenu add: 'labeled watcher' translated selector: #tearOffFancyWatcherFor: argument: aGetter.		aMenu addLine]! !!ColorType methodsFor: 'tiles' stamp: 'sw 1/5/2005 19:57'!wantsArrowsOnTiles	"Answer whether this data type wants up/down arrows on tiles representing its values"	^ false! !!MenuType methodsFor: 'tiles' stamp: 'sw 1/5/2005 22:27'!representsAType	"Answer whether this vocabulary represents an end-user-sensible data type"	^false! !!Morph methodsFor: 'latter day support' stamp: 'sw 1/6/2005 01:26'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ false! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'sw 1/6/2005 04:34'!morphToDropInPasteUp: aPasteUp	"Answer the morph to drop in aPasteUp, given that the receiver is the putative droppee"	| actualObject itsSelector aScriptor pos aWatcher op |	((actualObject _ self actualObject) isNil or: [actualObject costume isInWorld not]) ifTrue: [^ self].	self isCommand ifFalse:  "Can't expand to a scriptor, but maybe launch a watcher..."		[^ (Preferences dropProducesWatcher and: [(#(unknown command) includes: self resultType) not] and:			[(op _ self operatorTile operatorOrExpression) notNil] and: [op numArgs = 0] and: [(Vocabulary gettersForbiddenFromWatchers includes: op) not])			ifTrue:				[aWatcher _ self associatedPlayer fancyWatcherFor: op.				aWatcher position: self position]			ifFalse:				[self]].	self justGrabbedFromViewer ifFalse: [^ self].	actualObject assureUniClass.	itsSelector _ self userScriptSelector.	pos _ self position.	aScriptor _ itsSelector isEmptyOrNil		ifFalse:			[actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			actualObject newScriptorAround: self].	aScriptor ifNil:[^self].	(self hasOwner: aScriptor) ifTrue:[		aScriptor fullBounds. "force layout"		aScriptor position: pos - self position.	] ifFalse:[		aScriptor position: self position.	].	^ aScriptor! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/2005 01:32'!allPossibleWatchersFromWorld	"Answer a list of all UpdatingStringMorphs, PlayerReferenceReadouts, ThumbnailMorphs, and  UpdatingReferenceMorphs in the Active world and its hidden book pages, etc., which have me or any of my siblings as targets"	| a |	a _ IdentitySet new: 400.	ActiveWorld allMorphsAndBookPagesInto: a.	^ a select: [:e | e isEtoyReadout and: [e target class == self class]]! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/2005 16:53'!fancyWatcherFor: aGetter	"Anser a labeled readout for viewing a value textuallyi"	| aWatcher aColor aLine itsName aSelector aLabel |	aWatcher _ self unlabeledWatcherFor: aGetter.	aColor _ (Color r: 0.742 g: 0.839 b: 1.0).	aLine _ WatcherWrapper newRow.	aLine player: self variableName: (aSelector _ Utilities inherentSelectorForGetter: aGetter).	itsName _ aWatcher externalName.	aWatcher setNameTo: 'readout'.	aLine addMorphFront: (self tileReferringToSelf				borderWidth: 0; layoutInset: 4@0;				typeColor: aColor; 				color: aColor; bePossessive).	aLabel _ StringMorph contents: aSelector, ' = ' font: ScriptingSystem fontForTiles.	aLabel setProperty: #watcherLabel toValue: true.	aLine addMorphBack: aLabel.	aLine addMorphBack: aWatcher.	aLine setNameTo: itsName.	^ aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/2005 02:02'!tearOffFancyWatcherFor: aGetter	"Hand the user a labeled readout for viewing a numeric value"	(self fancyWatcherFor: aGetter) openInHand! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/2005 18:16'!tearOffUnlabeledWatcherFor: aGetter	"Hand the user anUnlabeled readout for viewing a numeric value"	| readout aWrapper |	readout _ self unlabeledWatcherFor: aGetter.	aWrapper _ WatcherWrapper new.	aWrapper player: self variableName: (Utilities inherentSelectorForGetter: aGetter).	aWrapper addMorphBack: readout.	readout setNameTo: 'readout'.  "The wrapper bears the name for the user"	aWrapper openInHand! !!Player methodsFor: 'slots-user' stamp: 'sw 1/5/2005 22:17'!unlabeledWatcherFor: aGetter	"Answer an unnlabeled readout for viewing a numeric-valued slot of mine"	| aWatcher info anInterface watcherWording itsType vocab aSetter |	info _ self slotInfoForGetter: aGetter.	info ifNotNil:			[itsType _ info type.			watcherWording _ Utilities inherentSelectorForGetter: aGetter.			aSetter _ Utilities setterSelectorFor: watcherWording]		ifNil:			[anInterface _Vocabulary eToyVocabulary methodInterfaceAt: aGetter ifAbsent: [nil].			anInterface				ifNotNil:					[itsType _ anInterface resultType.					aSetter _ anInterface companionSetterSelector]				ifNil:					[itsType _ #Unknown.					aSetter _ nil].			watcherWording _ anInterface ifNotNil: [anInterface wording] ifNil: ['*']].	vocab _ Vocabulary vocabularyForType: itsType.	aWatcher _ vocab updatingTileForTarget: self partName: watcherWording getter: aGetter setter: aSetter.	aWatcher setNameTo: (self externalName, '''s ', watcherWording).	aWatcher minHeight: (vocab wantsArrowsOnTiles ifTrue: [22] ifFalse: [14]).	^ aWatcher! !!Player methodsFor: 'translation' stamp: 'sw 1/6/2005 16:34'!renameSlotInWatchersOld: oldName new: newName	"A variable has been renamed; get all relevant extant watchers updated.  All this assumed to be happening in the ActiveWorld"	| wasStepping oldGetter |	oldGetter _ Utilities getterSelectorFor: oldName.	self allPossibleWatchersFromWorld do: [:aWatcher |		(aWatcher getSelector = oldGetter) ifTrue:			[(wasStepping _ aWatcher isStepping) ifTrue: [aWatcher stopStepping].			aWatcher getSelector: (Utilities getterSelectorFor: newName).			aWatcher putSelector ifNotNil:				[aWatcher putSelector: (Utilities setterSelectorFor: newName)].			((aWatcher isKindOf: UpdatingStringMorph) and: [aWatcher hasStructureOfComplexWatcher]) ifTrue:  "Old style fancy watcher"				[aWatcher owner owner traverseRowTranslateSlotOld: oldName to: newName.				(aWatcher target labelFromWatcher: aWatcher) contents: newName, ' = '].			(aWatcher ownerThatIsA: WatcherWrapper) ifNotNilDo:				[:wrapper | wrapper player: self variableName: newName].			wasStepping ifTrue: [aWatcher startStepping]]]! !!SymbolListType methodsFor: 'tiles' stamp: 'sw 1/6/2005 17:24'!representsAType	"Answer whether this vocabulary represents an end-user-sensible data type"	^ #(BorderStyle ButtonPhase TrailStyle) includes: vocabularyName! !!ThumbnailMorph methodsFor: 'scripting' stamp: 'sw 1/6/2005 01:29'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!ThumbnailMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:46'!getSelector	"Answer the selector I send to my target to retrieve my value"	^ viewSelector! !!ThumbnailMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 17:03'!getSelector: aSelector	"Set the selector used to obtain my value"	self objectToView: objectToView viewSelector: aSelector! !!ThumbnailMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 17:06'!putSelector	"Answer the selector used  for the receiver to send a fresh value back to its target"	^ nil! !!ThumbnailMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:39'!target	"Answer the object on which I act"	^ objectToView! !!PlayerReferenceReadout methodsFor: 'initialization' stamp: 'sw 1/6/2005 17:12'!putSelector	"Answer the putSelector"	^ putSelector! !!PlayerReferenceReadout methodsFor: 'initialization' stamp: 'sw 1/6/2005 17:13'!putSelector: aSel	"Reset the putSelector"	self objectToView: objectToView viewSelector: viewSelector putSelector: aSel! !!PlayerReferenceReadout methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:24'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!PlayerReferenceReadout methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:38'!target	"Answer the object on which I act"	^ objectToView! !!TilePadMorph methodsFor: 'layout' stamp: 'sw 1/6/2005 03:25'!acceptDroppingMorph: aMorph event: evt 	"Accept the given morph within my bowels"	| editor wasPossessive morphToUse |	wasPossessive := submorphs notEmpty and: [submorphs first isPossessive].	morphToUse _ self morphToDropFrom: aMorph.	self prepareToUndoDropOf: morphToUse.	self removeAllMorphs.	morphToUse position: self position.	self addMorph: morphToUse.	wasPossessive ifTrue: [morphToUse bePossessive].	morphToUse lastTile addRetractArrow.	"if can"	(editor := self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 1/6/2005 03:27'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	(aMorph isKindOf: WatcherWrapper) ifFalse: [^ aMorph].	^ aMorph getterTilesForDrop! !!TilePadMorph methodsFor: 'mouse' stamp: 'sw 1/6/2005 02:41'!canAccept: aMorph	"Answer whether this pad can accept the given morph"	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isKindOf: TileMorph orOf: WatcherWrapper]) 		ifTrue:			[^ (aMorph resultType capitalized = self type capitalized "for bkwd compat") "or:				[(aMorph resultType == #unknown) and: [type == #Player]]"].	^ false! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 16:31'!getSelector	"Answer the getSelector"	^ getSelector! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:28'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 1/6/2005 01:27'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!Vocabulary class methodsFor: 'eToy vocabularies' stamp: 'sw 1/6/2005 04:28'!gettersForbiddenFromWatchers	"Answer getters that should not have watchers launched to them"	^ #(colorSees copy isOverColor: seesColor: newClone getNewClone color:sees: touchesA: overlaps: overlapsAny:)! !!WatcherWrapper methodsFor: 'initialization' stamp: 'sw 1/6/2005 00:11'!player: aPlayer variableName: aVariableName	"Set up my initial state"	| aColor |	aColor _ (Color r: 0.742 g: 0.839 b: 1.0).	player _ aPlayer.	variableName _ aVariableName.	self		listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap; 		color: aColor;		layoutInset: -1;		borderWidth: 1;		borderColor: aColor darker;		listCentering: #center.	self reconstituteName! !!WatcherWrapper methodsFor: 'updating' stamp: 'sw 1/6/2005 00:11'!bringUpToDate	"Given that my player may have been renamed, reformulate my external name"	self reconstituteName	! !!WatcherWrapper methodsFor: 'updating' stamp: 'sw 1/6/2005 16:55'!reconstituteName	"Reconstitute the external name of the receiver"	variableName ifNotNil:		[self setNameTo: player externalName, '''s ', variableName.		(self submorphWithProperty: #watcherLabel) ifNotNilDo:			[:aLabel | aLabel contents: variableName asString, ' = ']]! !!WatcherWrapper methodsFor: 'identification' stamp: 'sw 1/6/2005 03:44'!isTileScriptingElement	"Answer whether the receiver is a tile-scripting element"	^ true! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 04:18'!getterTilesForDrop	"Answer getter tiles to use if there is an attempt to drop me onto a tile pad"	| aCategoryViewer |	aCategoryViewer _ CategoryViewer new initializeFor: player categoryChoice: #basic.	^ aCategoryViewer getterTilesFor: (Utilities getterSelectorFor: variableName)  type: self resultType! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 03:49'!isTileLike	"Answer whether the receiver can participate tile-like"	^ true! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 04:00'!justGrabbedFrom: formerOwner	"An attempt to make these guys easier to involve in tile scripting.  But in the end too strange, so for the moment the active ingredients commented out""	self center: ActiveHand position.	self left: ActiveHand position x."	super justGrabbedFrom: formerOwner! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 02:47'!readoutMorph	"Answer the submorph of mine that serves as my readout"	^ self allMorphs detect:		[:m | m isEtoyReadout] ifNone: [nil]! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 03:13'!resultType	"Answer the result type the receiver would produce."	^ player typeForSlotWithGetter: (Utilities getterSelectorFor: variableName)! !NumberType removeSelector: #addWatcherItemsToMenu:forGetter:!"Postscript:"Preferences addPreference: #dropProducesWatcher category: #scripting default: true balloonHelp: 'When this preference is set, a drop of value-viewing tiles, such as "car''s heading", will result in the creation of a watcher for the given variable.'!