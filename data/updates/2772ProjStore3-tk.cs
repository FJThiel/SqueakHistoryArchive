'From Squeak2.9alpha of 16 June 2000 [latest update: #2803] on 4 October 2000 at 4:13:52 pm'!"Change Set:		ProjStore3-tkDate:			4 October 2000Author:			Ted KaehlerFixes bugs in Controllable ImageSegment Storage (CISS):	CompiledMethods can now be read from the disk in DataStreams.  Defines a new type for DataStream to do it.	Stop doing the double write of Scripts stored in class instance variables.  Was actually causing a bug in some cases, and taking lots of space.	Fixes a bug in the way that Active Essays show the dates of their old versions."!!SmartRefStream commentStamp: '<historical>' prior: 0!Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.  A class may be stored inside an ImageSegment that is stored by me.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).There is a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self, does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.Some metaclasses are put into the structures table.  This is for when a block has a receiver that is a class.  See checkFatalReshape:.ImageSegments:	A ReferenceStream is used to enumerate objects to put inside an ImageSegment.  If an instance of a UniClass is seen, the class is put in also.	A SmartRefStream is used to store the ImageSegment.  Roots are nil, and the segment is a wordArray.  We are encoding the outPointers.  Structures contains all classes from both places.  Must filter out UniClasses for some things, and do include them for putting source code at end of file.  Do not write any class inst vars in file.Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tell how to make conversion work when some files have already been written.!!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 10/4/2000 10:30'!readDataFrom: aDataStream size: varsOnDisk	"Fill in my fields.  My header and number of literals are already installed.  Must read both objects for the literals and bytes for the bytecodes."	| lits |	aDataStream beginReference: self.	aDataStream next.	"read the header again to get past it"	lits _ self numLiterals + 1.	"counting header"	2 to: lits do:		[:ii | self objectAt: ii put: aDataStream next].	lits*4+1 to: self basicSize do:		[:ii | self basicAt: ii put: aDataStream byteStream next].			"Get raw bytes directly from the file"	^ self! !!DataStream methodsFor: 'write and read' stamp: 'tk 10/4/2000 10:33'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger	"<-4"			readStringOld readSymbol readByteArray		"<-7"			readArray readInstance readReference readBitmap	"<-11"			readClass readUser readFloat readRectangle readShortInst 	"<-16"			readString readWordArray readWordArrayForSegment 	"<-19"			readWordLike readMethod "<-21") at: type.	selector == 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"			byteStream close. 			self error: 'file is more recent than this system'. ^ nil].	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject _ anObject comeFullyUpOnReload: self.	^ self maybeBeginReference: internalObject! !!DataStream methodsFor: 'write and read' stamp: 'tk 10/4/2000 10:35'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectForDataStream: self.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "<-16 short inst" 		writeString: writeBitmap: writeBitmap: writeWordLike: 		writeInstance: "CompiledMethod") at: typeID.	self perform: selector with: objectToStore.	^ anObject"NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectForDataStream:) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 writeReference: -> errorWriteReference:."! !!DataStream methodsFor: 'write and read' stamp: 'tk 10/4/2000 10:30'!readMethod	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next.	newClass _ Smalltalk at: className asSymbol.	xxHeader _ self next.		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."		"largeBit _ (xxHeader >> 17) bitAnd: 1."	nLits _ (xxHeader >> 9) bitAnd: 16rFF.		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * 4).	newMethod _ newClass 		newMethod: byteCodeSizePlusTrailer		header: xxHeader.	self setCurrentReference: refPosn.  "before readDataFrom:size:"	newMethod _ newMethod readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ newMethod! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'tk 10/4/2000 10:09'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 80. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"bitmap-like"	t at: SoundBuffer put: 20.  refTypes add: 1.		"And all other word arrays"	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"	"t at:  put: 22.  refTypes add: 0."	ReferenceStream refTypes: refTypes.		"save it"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/4/2000 15:45'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures _ Dictionary new.	superclasses _ Dictionary new.	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"			refs keysDo: [:each | 				cls _ each class.				"cls isObsolete ifTrue: [self error: 'Trying to write ', cls name]."				(cls class ~~ Metaclass) & (cls isObsolete not) ifTrue: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures at: #Point put: false.	"writeRectangle: does not put out class pointer"	structures at: #Rectangle put: false.	structures keysDo: [:nm | 		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	(refs includesKey: #AnImageSegment) 		ifTrue: [classInstVars _ #()]		ifFalse: [self saveClassInstVars].	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/4/2000 15:40'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls list |	"Do not record Player class inst vars.  They are in the segement."	refs keysDo: [:each | 		cls _ each class.		cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].		cls class == Metaclass 			ifFalse: [structures at: cls name put: false.				(each isKindOf: ImageSegment) ifTrue: [					each outPointers do: [:out | "Why necessary??"						(out isKindOf: Class) ifTrue: [							structures at: out theNonMetaClass name put: false]].					each arrayOfRoots do: [:rr | (rr isKindOf: Class) ifTrue: [							structures at: rr theNonMetaClass name put: false]]]]		].	list _ refs at: #BlockReceiverClasses ifAbsent: [^ self].	list do: [:meta | structures at: meta name put: false].		"Just the metaclasses whose instances are block receivers.  Otherwise metaclasses are not allowed."! !!Time class methodsFor: 'general inquiries' stamp: 'tk 10/3/2000 13:53'!namesForTimes: arrayOfSeconds	| simpleEnglish prev final prevPair myPair |	"Return English descriptions of the times in the array.  They are each seconds since 1901.  If two names are the same, append the date and time to distinguish them."	simpleEnglish _ arrayOfSeconds collect: [:secsAgo |		self humanWordsForSecondsAgo: self totalSeconds - secsAgo].	prev _ ''.	final _ simpleEnglish copy.	simpleEnglish withIndexDo: [:eng :ind | 		eng = prev ifFalse: [eng]			ifTrue: ["both say 'a month ago'"				prevPair _ self dateAndTimeFromSeconds: 						(arrayOfSeconds at: ind-1).				myPair _ self dateAndTimeFromSeconds: 						(arrayOfSeconds at: ind).				(final at: ind-1) = prev ifTrue: ["only has 'a month ago'"					final at: ind-1 put: 							(final at: ind-1), ', ', prevPair first mmddyyyy].				final at: ind put: 							(final at: ind), ', ', myPair first mmddyyyy.				prevPair first = myPair first 					ifTrue: [						(final at: ind-1) last == $m ifFalse: ["date but no time"							final at: ind-1 put: 								(final at: ind-1), ', ', prevPair second printMinutes].						final at: ind put: 							(final at: ind), ', ', myPair second printMinutes]].		prev _ eng].	^ final! !DataStream initialize!