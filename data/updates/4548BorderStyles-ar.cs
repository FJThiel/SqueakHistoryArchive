'From Squeak3.2alpha of 2 October 2001 [latest update: #4547] on 26 November 2001 at 3:52:41 pm'!"Change Set:		BorderStyles-arDate:			26 November 2001Author:			Andreas RaabThis change set introduces explicit border styles in Morphic. At this point they are hacked into BorderedMorph to allow the dual existance of the borderWidth/borderColor pair with the new border styles (e.g., storing a value into borderWidth/borderColor will be reflected in the borderStyle when it is used).Six new complex border styles have been added - besides 'rounded' versions of inset and raised borders (as well as their inverse variants) framed borders are supported. The new border styles are available from the object properties dialog (e.g., when you click on the 'change color' halo - which really should be renamed).In addition, each border style can either track the color from its associated morph, or it can have a fixed color. It is therefore now possible to have a morph with a gradient fill and a manually selected color with a raised (or inset, or framed) border style, thus greatly improving the results for any fancy fill styles."!Object subclass: #BorderStyle	instanceVariableNames: ''	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Morphic-Borders'!BorderStyle subclass: #SimpleBorder	instanceVariableNames: 'baseColor color width '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Borders'!SimpleBorder subclass: #ComplexBorder	instanceVariableNames: 'style colors lineStyles '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Borders'!!ComplexBorder commentStamp: '<historical>' prior: 0!poly _ polygon250 baseColor _ Color blue twiceLighter.border _ (ComplexBorder framed: 10) baseColor: poly color.border frameRectangle: ((100@100 extent: 200@200) insetBy: -5) on: Display getCanvas.baseColor _ Color red twiceLighter.border _ (ComplexBorder framed: 10) baseColor: baseColor.border drawPolygon: {100@100. 300@100. 300@300. 100@300} on: Display getCanvas.border drawPolyPatchFrom: 100@200 via: 100@100 via: 200@100 to: 200@200 on: Display getCanvas.border drawPolyPatchFrom: 100@100 via: 200@100 via: 200@200 to: 100@200 on: Display getCanvas.border drawPolyPatchFrom: 200@100 via: 200@200 via: 100@200 to: 100@100 on: Display getCanvas.border drawPolyPatchFrom: 200@200 via: 100@200 via: 100@100 to: 200@100 on: Display getCanvas.border _ (ComplexBorder raised: 10) baseColor: poly color.border drawPolygon: poly getVertices on: Display getCanvas360 / 16.0 22.5points _ (0 to: 15) collect:[:i| (Point r: 100 degrees: i*22.5) + 200].Display getCanvas fillOval: (100@100 extent: 200@200) color: baseColor.border drawPolygon: points on: Display getCanvas.-1 to: points size + 1 do:[:i|	border drawPolyPatchFrom: (points atWrap: i) via: (points atWrap: i+1) via: (points atWrap: i+2) to: (points atWrap: i+3) on: Display getCanvas.].Display getCanvas fillOval: (100@100 extent: 200@200) color: baseColor.0 to: 36 do:[:i|	border drawLineFrom: (Point r: 100 degrees: i*10) + 200 to: (Point r: 100 degrees: i+1*10) + 200		on: Display getCanvas.].drawPolygon:Point r: 1.0 degrees: 10MessageTally spyOn:[Display deferUpdates: true.t1 _ [1 to: 1000 do:[:i|	border drawLineFrom: (100@100) to: (300@100) on: Display getCanvas.	border drawLineFrom: (300@100) to: (300@300) on: Display getCanvas.	border drawLineFrom: (300@300) to: (100@300) on: Display getCanvas.	border drawLineFrom: (100@300) to: (100@100) on: Display getCanvas]] timeToRun.Display deferUpdates: false.].MessageTally spyOn:[Display deferUpdates: true.t2 _ [1 to: 1000 do:[:i|	border drawLine2From: (100@100) to: (300@100) on: Display getCanvas.	border drawLine2From: (300@100) to: (300@300) on: Display getCanvas.	border drawLine2From: (300@300) to: (100@300) on: Display getCanvas.	border drawLine2From: (100@300) to: (100@100) on: Display getCanvas]] timeToRun.Display deferUpdates: false.].!SimpleBorder subclass: #InsetBorder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Borders'!SimpleBorder subclass: #RaisedBorder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Borders'!!Array methodsFor: 'accessing' stamp: 'ar 8/26/2001 22:02'!atWrap: index 	"Optimized to go through the primitive if possible"	<primitive: 60>	^ self at: index - 1 \\ self size + 1! !!Array methodsFor: 'accessing' stamp: 'ar 8/26/2001 22:03'!atWrap: index put: anObject	"Optimized to go through the primitive if possible"	<primitive: 61>	^ self at: index - 1 \\ self size + 1 put: anObject! !!BorderStyle methodsFor: 'initialize' stamp: 'ar 8/25/2001 16:06'!releaseCachedState	"Release any associated cached state"! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:15'!baseColor	^Color transparent! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:15'!baseColor: aColor	"Ignored"! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!color	^Color transparent! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!color: aColor	"Ignored"! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:22'!colorsAtCorners	^Array new: 4 withAll: self color! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!dotOfSize: diameter forDirection: aDirection	| form |	form _ Form extent: diameter@diameter depth: Display depth.	form getCanvas fillOval: form boundingBox color: self color.	^form! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:51'!style	^#none! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!width	^0! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!width: aNumber	"Ignored"! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:08'!widthForRounding	^self width! !!BorderStyle methodsFor: 'testing' stamp: 'ar 8/25/2001 16:08'!isBorderStyle	^true! !!BorderStyle methodsFor: 'testing' stamp: 'ar 8/26/2001 19:30'!isComplex	^false! !!BorderStyle methodsFor: 'comparing' stamp: 'ar 8/25/2001 18:38'!= aBorderStyle	^self species = aBorderStyle species		and:[self style == aBorderStyle style		and:[self width = aBorderStyle width		and:[self color = aBorderStyle color]]].! !!BorderStyle methodsFor: 'comparing' stamp: 'ar 8/25/2001 16:08'!hash	"hash is implemented because #= is implemented"	^self species hash bitXor: (self width hash bitXor: self color hash)! !!BorderStyle methodsFor: 'drawing' stamp: 'ar 8/25/2001 17:01'!drawLineFrom: startPoint to: stopPoint on: aCanvas	^aCanvas line: startPoint to: stopPoint width: self width color: self color! !!BorderStyle methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:24'!frameOval: aRectangle on: aCanvas	"Frame the given rectangle on aCanvas"	aCanvas frameOval: aRectangle width: self width color: self color! !!BorderStyle methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:57'!framePolygon: vertices on: aCanvas	"Frame the given rectangle on aCanvas"	self framePolyline: vertices on: aCanvas.	self drawLineFrom: vertices last to: vertices first on: aCanvas.! !!BorderStyle methodsFor: 'drawing' stamp: 'ar 8/25/2001 17:05'!framePolyline: vertices on: aCanvas	"Frame the given rectangle on aCanvas"	| prev next |	prev _ vertices at: 1.	2 to: vertices size do:[:i|		next _ vertices at: i.		self drawLineFrom: prev to: next on: aCanvas.		prev _ next].! !!BorderStyle methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:24'!frameRectangle: aRectangle on: aCanvas	"Frame the given rectangle on aCanvas"	aCanvas frameRectangle: aRectangle width: self width color: self color! !!BorderStyle methodsFor: 'color tracking' stamp: 'ar 8/25/2001 17:29'!trackColorFrom: aMorph	"If necessary, update our color to reflect a change in aMorphs color"! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 23:52'!color: aColor width: aNumber	^self width: aNumber color: aColor! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 15:01'!complexAltFramed	^ComplexBorder style: #complexAltFramed! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 15:01'!complexAltInset	^ComplexBorder style: #complexAltInset! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 15:00'!complexAltRaised	^ComplexBorder style: #complexAltRaised! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 15:00'!complexFramed	^ComplexBorder style: #complexFramed! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 15:00'!complexInset	^ComplexBorder style: #complexInset! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 15:00'!complexRaised	^ComplexBorder style: #complexRaised! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 17:26'!default	^Default ifNil:[Default _ self new]! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 14:59'!inset	^InsetBorder new! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 11/26/2001 14:59'!raised	^RaisedBorder new! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 16:19'!width: aNumber	^self width: aNumber color: Color black! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 16:19'!width: aNumber color: aColor	^SimpleBorder new color: aColor; width: aNumber; yourself! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 8/25/2001 17:27'!fillRectangle: aRectangle fillStyle: aFillStyle borderStyle: aBorderStyle	"Fill the given rectangle."	self fillRectangle: (aRectangle insetBy: aBorderStyle width) fillStyle: aFillStyle.	aBorderStyle frameRectangle: aRectangle on: self! !!BalloonCanvas methodsFor: 'drawing-polygons' stamp: 'ar 8/26/2001 22:14'!drawPolygon: vertices fillStyle: aFillStyle	"Fill the given polygon."	self drawPolygon: vertices fillStyle: aFillStyle borderWidth: 0 borderColor: nil! !!CornerRounder methodsFor: 'all' stamp: 'ar 11/26/2001 15:23'!tweakCornersOf: aMorph on: aCanvas borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits fourColors mask outBits shadowColor |	shadowColor _ aCanvas shadowColor.	aCanvas shadowColor: nil. "for tweaking it's essential"	w > 0 ifTrue:[			fourColors _ shadowColor 				ifNil:[aMorph borderStyle colorsAtCorners]				ifNotNil:[Array new: 4 withAll: shadowColor]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	1 to: 4 do:[:i | 		(cornerList includes: i) ifTrue:			[corner _ aMorph bounds corners at: i.			saveBits _ underBits at: i.			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:				["Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]].	aCanvas shadowColor: shadowColor. "restore shadow color"! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 8/26/2001 20:54'!transformDirection: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x _ (aPoint x * self a11) + (aPoint y * self a12).	y _ (aPoint x * self a21) + (aPoint y * self a22).	^x @ y! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:28'!borderColor	^self borderStyle color! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:28'!borderColor: aColor	| style |	(style _ self borderStyle) baseColor = aColor ifFalse:[		style baseColor: aColor.		self changed].! !!Morph methodsFor: 'accessing' stamp: 'ar 11/26/2001 14:53'!borderStyle	^(self valueOfProperty: #borderStyle ifAbsent:[BorderStyle default]) trackColorFrom: self! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:30'!borderStyle: newStyle	newStyle = self borderStyle ifFalse:[		self setProperty: #borderStyle toValue: newStyle.		self changed].! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:28'!borderWidth	^self borderStyle width! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:29'!borderWidth: aNumber	| style |	(style _ self borderStyle) width = aNumber ifFalse:[		style width: aNumber.		self changed.	].! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:55'!insetColor	owner ifNil:[^self color].	^owner colorForInsets! !!Morph methodsFor: 'drawing' stamp: 'ar 8/25/2001 17:31'!drawOn: aCanvas	aCanvas fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyle.! !!Morph methodsFor: 'caching' stamp: 'ar 11/26/2001 15:25'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'."	self wonderlandTexture: nil. "We can recreate it if needed"	self borderStyle releaseCachedState.! !!Morph methodsFor: 'testing' stamp: 'ar 8/25/2001 19:14'!canDrawBorder: aBorderStyle	"Return true if the receiver can be drawn with the given border style."	^true! !!BorderedMorph methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:04'!borderStyle	"Work around the borderWidth/borderColor pair"	| style |	borderColor ifNil:[^BorderStyle default].	borderWidth isZero ifTrue:[^BorderStyle default].	style _ self valueOfProperty: #borderStyle ifAbsent:[BorderStyle default].	(borderWidth = style width and:[		"Hah!! Try understanding this..."		borderColor == style style "#raised/#inset etc" or:[			#simple == style style and:[borderColor = style color]]]) ifFalse:[		borderColor isColor			ifTrue:[style _ BorderStyle width: borderWidth color: borderColor]			ifFalse:[style _ (BorderStyle perform: borderColor "argh.") width: borderWidth].		self setProperty: #borderStyle toValue: style.	].	^style trackColorFrom: self! !!BorderedMorph methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:08'!borderStyle: aBorderStyle	"Work around the borderWidth/borderColor pair"	aBorderStyle = self borderStyle ifTrue:[^self].	aBorderStyle width = self borderStyle width ifFalse:[self changed].	(aBorderStyle == nil or:[aBorderStyle == BorderStyle default]) ifTrue:[		self removeProperty: #borderStyle.		borderWidth _ 0.		^self changed].	self setProperty: #borderStyle toValue: aBorderStyle.	borderWidth _ aBorderStyle width.	aBorderStyle style == #simple 		ifTrue:[borderColor _ aBorderStyle color]		ifFalse:[borderColor _ aBorderStyle style].	self changed.! !!BalloonRectangleMorph methodsFor: 'accessing' stamp: 'ar 8/25/2001 19:08'!canDrawBorder: aBorderStyle	^aBorderStyle style == #simple! !!EllipseMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/25/2001 19:08'!canDrawBorder: aBorderStyle	^aBorderStyle style == #simple! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/25/2001 18:30'!targetBorderColor	^myTarget borderStyle baseColor! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/26/2001 15:29'!targetBorderColor: aColor	"Need to replace the borderStyle or BorderedMorph will not 'feel' the change"	myTarget borderStyle: (myTarget borderStyle copy baseColor: aColor).! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'ar 8/25/2001 19:12'!borderPrototype: aBorderStyle help: helpString	| selector proto |	selector _ BorderedMorph new.	selector borderWidth: 0.	selector color: Color transparent.	proto _ Morph new extent: 16@16.	proto color:  Color transparent.	proto borderStyle: aBorderStyle.	selector extent: proto extent + 4.	selector addMorphCentered: proto.	(myTarget canDrawBorder: aBorderStyle) ifTrue:[		selector setBalloonText: helpString.		selector on: #mouseDown send: #toggleBorderStyle:with:from: to: self withValue: proto.		(myTarget borderStyle species == aBorderStyle species and:[			myTarget borderStyle style == aBorderStyle style]) ifTrue:[selector borderWidth: 1].	] ifFalse:[		selector setBalloonText: 'This border style cannot be used here'.		selector on: #mouseDown send: #beep to: self.		selector addMorphCentered: ((Morph new) color: (Color black alpha: 0.5); extent: selector extent).	].	^selector! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'ar 8/25/2001 18:27'!paneForBorderColorPicker	^self 		inAColumn: {			self 				colorPickerFor: self				getter: #targetBorderColor				setter: #targetBorderColor:.			self lockedString: 'Border Color'.			(self paneForBorderStyle) hResizing: #shrinkWrap; layoutInset: 5.			self lockedString: 'Border style'.			self paneForBorderWidth.		} 		named: #pickerForBorderColor.! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'ar 11/26/2001 15:02'!paneForBorderStyle	^self inARow: {		self borderPrototype: (BorderStyle width: 4 color: Color black)			help:'Click to select a simple colored border'.		self borderPrototype: (BorderStyle raised width: 4)			help:'Click to select a simple raised border'.		self borderPrototype: (BorderStyle inset width: 4)			help:'Click to select a simple inset border'.		self borderPrototype: (BorderStyle complexFramed width: 4)			help:'Click to select a complex framed border'.		self borderPrototype: (BorderStyle complexRaised width: 4)			help:'Click to select a complex raised border'.		self borderPrototype: (BorderStyle complexInset width: 4)			help:'Click to select a complex inset border'.		self borderPrototype: (BorderStyle complexAltFramed width: 4)			help:'Click to select a complex framed border'.		self borderPrototype: (BorderStyle complexAltRaised width: 4)			help:'Click to select a complex raised border'.		self borderPrototype: (BorderStyle complexAltInset width: 4)			help:'Click to select a complex inset border'.	}! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'ar 8/25/2001 18:35'!toggleBorderStyle: provider with: arg1 from: arg2	| oldStyle newStyle |	oldStyle _ myTarget borderStyle.	newStyle _ provider borderStyle copy.	oldStyle width = 0 		ifTrue:[newStyle width: 2]		ifFalse:[newStyle width: oldStyle width].	newStyle baseColor: oldStyle baseColor.	myTarget borderStyle: newStyle.	provider owner owner submorphsDo:[:m| m borderWidth: 0].	provider owner borderWidth: 1.! !!OrientedFillStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:03'!direction	^direction ifNil:[direction _ normal y @ normal x negated]! !!GradientFillStyle methodsFor: 'converting' stamp: 'ar 8/25/2001 21:02'!asColor	"Guess..."	^colorRamp first value mixed: 0.5 with: colorRamp last value! !!GradientFillStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 17:03'!colors: colorArray	"Create a gradient fill style from an array of equally spaced colors"	^self ramp: (colorArray withIndexCollect:		[:color :index| (index-1 asFloat / (colorArray size - 1)) -> color]).! !!Player methodsFor: 'slot getters/setters' stamp: 'ar 11/26/2001 15:32'!getBorderColor	"Answer the border color of my costume"	^costume renderedMorph borderStyle color! !!Player methodsFor: 'slot getters/setters' stamp: 'ar 11/26/2001 15:33'!setBorderColor: aColor	"Set the border color as requested"	costume renderedMorph borderStyle:		(costume renderedMorph borderStyle copy baseColor: aColor).! !!Point methodsFor: 'point functions' stamp: 'ar 8/26/2001 22:15'!normalized	"Optimized for speed -- ar 8/26/2001"	| r |	r _ ((x*x) + (y * y)) sqrt.	^(x / r) @ (y / r)! !!Point methodsFor: 'transforming' stamp: 'ar 8/26/2001 22:14'!negated	"Answer a point whose x and y coordinates are the negatives of those of the receiver.  6/6/96 sw"	"Optimized for speed -- ar 8/26/2001"	^ (0 - x) @ (0 - y)! !!PolygonMorph methodsFor: 'drawing' stamp: 'ar 11/26/2001 14:53'!drawBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas."	"NOTE: Much of this code is also copied in drawDashedBorderOn:  	(should be factored)"	| bigClipRect p1i p2i style |	borderDashSpec		ifNotNil: [^ self drawDashedBorderOn: aCanvas usingEnds: anArray].	style _ self borderStyle.	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	self lineSegmentsDo: [:p1 :p2 | 		p1i _ p1 asIntegerPoint.		p2i _ p2 asIntegerPoint.		(arrows ~= #none and: [closed not])			ifTrue: ["Shorten line ends so as not to interfere with tip of arrow."					((arrows == #back								or: [arrows == #both])							and: [p1 = vertices first])						ifTrue: [p1i _ anArray first asIntegerPoint].					((arrows == #forward								or: [arrows == #both])							and: [p2 = vertices last])						ifTrue: [p2i _ anArray last asIntegerPoint]].		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"			((p1i min: p2i) max: bigClipRect origin)				<= ((p1i max: p2i) min: bigClipRect corner)])				ifTrue: [style drawLineFrom: p1i to: p2i on: aCanvas]]! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:19'!baseColor	^baseColor ifNil:[Color transparent]! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:23'!baseColor: aColor	| cc |	cc _ aColor isTransparent ifTrue:[nil] ifFalse:[aColor].	baseColor = cc ifTrue:[^self].	baseColor _ cc.	self releaseCachedState.	self color: cc.! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:09'!bottomRightColor	^color! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:19'!color	^color ifNil:[Color transparent]! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:10'!color: aColor	color = aColor ifTrue:[^self].	color _ aColor.	self releaseCachedState.! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:52'!style	^#simple! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:09'!topLeftColor	^color! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:35'!width	^width! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:10'!width: aNumber	width = aNumber ifTrue:[^self].	width _ aNumber truncated max: (width isPoint ifTrue:[0@0] ifFalse:[0]).	self releaseCachedState.! !!SimpleBorder methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:59'!drawLineFrom: startPoint to: stopPoint on: aCanvas	| lineColor |	(stopPoint truncated quadrantOf: startPoint truncated) > 2		ifTrue: [lineColor _ self topLeftColor]		ifFalse: [lineColor _ self bottomRightColor].	aCanvas line: startPoint to: stopPoint width: self width color: lineColor.! !!SimpleBorder methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:27'!frameRectangle: aRectangle on: aCanvas	aCanvas frameAndFillRectangle: aRectangle		fillColor: Color transparent		borderWidth: self width		topLeftColor: self topLeftColor		bottomRightColor: self bottomRightColor.! !!ComplexBorder methodsFor: 'initialize' stamp: 'ar 11/26/2001 14:43'!releaseCachedState	colors _ nil.	lineStyles _ nil.! !!ComplexBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:13'!colors	^colors ifNil:[colors _ self computeColors].! !!ComplexBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:22'!style	^style! !!ComplexBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:22'!style: newStyle	style == newStyle ifTrue:[^self].	style _ newStyle.	self releaseCachedState.! !!ComplexBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:14'!widthForRounding	^0! !!ComplexBorder methodsFor: 'testing' stamp: 'ar 8/26/2001 19:30'!isComplex	^true! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 8/26/2001 19:31'!drawLineFrom: startPoint to: stopPoint on: aCanvas	"Here we're using the balloon engine since this is much faster than BitBlt w/ brushes."	| delta length dir cos sin tfm w h w1 w2 h1 h2 fill |	width isPoint ifTrue:[w _ width x. h _ width y] ifFalse:[w _ h _ width].	w1 _ w // 2.	w2 _ w - w1.	h1 _ h // 2. 	h2 _ h - h1.	"Compute the rotational transform from (0@0) -> (1@0) to startPoint -> stopPoint"	delta _ stopPoint - startPoint.	length _ delta r.	length > 1.0e-10 ifTrue:[dir _ delta / length] ifFalse:[dir _ 1@0].	cos _ dir dotProduct: (1@0).		sin _ dir crossProduct: (1@0).	tfm _ (MatrixTransform2x3 new) a11: cos; a12: sin; a21: sin negated; a22: cos.	"Install the start point offset"	tfm offset: startPoint.	"Now get the fill style appropriate for the given direction"	fill _ self fillStyleForDirection: dir.	"And draw..."	aCanvas asBalloonCanvas transformBy: tfm during:[:cc|		cc drawPolygon: { 			(0-w1) @ (0-h1). "top left"			(length + w2) @ (0-h1). "top right"			(length + w2) @ (h2). "bottom right"			(0-w1) @ (h2). "bottom left"		} fillStyle: fill.	].! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 11/26/2001 15:10'!drawPolyPatchFrom: startPoint to: stopPoint on: aCanvas usingEnds: endsArray	| cos sin tfm fill dir fsOrigin fsDirection points x y |	dir _ (stopPoint - startPoint) normalized.	"Compute the rotational transform from (0@0) -> (1@0) to startPoint -> stopPoint"	cos _ dir dotProduct: (1@0).	sin _ dir crossProduct: (1@0).	"Now get the fill style appropriate for the given direction"	fill _ self fillStyleForDirection: dir.false ifTrue:[	"Transform the fill appropriately"	fill _ fill clone.	"Note: Code below is inlined from tfm transformPoint:/transformDirection:"	x _ fill origin x. y _ fill origin y.	fsOrigin _ ((x * cos) + (y * sin) + startPoint x) @					((y * cos) - (x * sin) + startPoint y).	x _ fill direction x. y _ fill direction y.	fsDirection _ ((x * cos) + (y * sin)) @ ((y * cos) - (x * sin)).	fill origin: fsOrigin; 		direction: fsDirection rounded; "NOTE: This is a bug in the balloon engine!!!!!!"		normal: nil.	aCanvas asBalloonCanvas drawPolygon: endsArray fillStyle: fill.] ifFalse:[	"Transform the points rather than the fills"	tfm _ (MatrixTransform2x3 new) a11: cos; a12: sin; a21: sin negated; a22: cos.	"Install the start point offset"	tfm offset: startPoint.	points _ endsArray collect:[:pt| tfm invertPoint: pt].	aCanvas asBalloonCanvas transformBy: tfm during:[:cc|		cc drawPolygon: points fillStyle: fill.	].].! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 9/4/2001 19:51'!framePolygon2: vertices on: aCanvas	| dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 	 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends |	balloon _ aCanvas asBalloonCanvas.	balloon == aCanvas ifFalse:[balloon deferred: true].	ends _ Array new: 4.	w _ width * 0.5.	pointA _ nil.	1 to: vertices size do:[:i|		p1 _ vertices atWrap: i.		p2 _ vertices atWrap: i+1.		p3 _ vertices atWrap: i+2.		p4 _ vertices atWrap: i+3.		dir1 _ p2 - p1.		dir2 _ p3 - p2.		dir3 _ p4 - p3.		i = 1 ifTrue:[			"Compute the merge points of p1->p2 with p2->p3"			cross1 _ dir2 crossProduct: dir1.			nrm1 _ dir1 normalized. nrm1 _ (nrm1 y * w) @ (0 - nrm1 x * w).			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm1 _ nrm1 negated. nrm2 _ nrm2 negated].			point1 _ (p1 x + nrm1 x) @ (p1 y + nrm1 y).			point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).			pointA _ self intersectFrom: point1 with: dir1 to: point2 with: dir2.			point1 _ (p1 x - nrm1 x) @ (p1 y - nrm1 y).			point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).			pointB _ self intersectFrom: point1 with: dir1 to: point2 with: dir2.			pointB ifNotNil:[				(pointB x - p2 x) abs + (pointB y - p2 y) abs > (4*w) ifTrue:[pointA _ pointB _ nil].			].		].		"Compute the merge points of p2->p3 with p3->p4"		cross2 _ dir3 crossProduct: dir2.		nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).		nrm3 _ dir3 normalized. nrm3 _ (nrm3 y * w) @ (0 - nrm3 x * w).		cross2 < 0 ifTrue:[nrm2 _ nrm2 negated. nrm3 _ nrm3 negated].		point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).		point3 _ (p3 x + nrm3 x) @ (p3 y + nrm3 y).		pointC _ self intersectFrom: point2 with: dir2 to: point3 with: dir3.		point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).		point3 _ (p3 x - nrm3 x) @ (p3 y - nrm3 y).		pointD _ self intersectFrom: point2 with: dir2 to: point3 with: dir3.		pointD ifNotNil:[			(pointD x - p3 x) abs + (pointD y - p3 y) abs > (4*w) ifTrue:[pointC _ pointD _ nil].		].		cross1 * cross2 < 0.0 ifTrue:[			point1 _ pointA.			pointA _ pointB.			pointB _ point1.			cross1 _ 0.0 - cross1].		ends at: 1 put: pointA; at: 2 put: pointB; at: 3 put: pointD; at: 4 put: pointC.		pointA ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).			ends at: 1 put: point2].		pointB ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).			ends at: 2 put: point2].		pointC ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross2 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p3 x + nrm2 x) @ (p3 y + nrm2 y).			ends at: 4 put: point2].		pointD ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross2 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p3 x - nrm2 x) @ (p3 y - nrm2 y).			ends at: 3 put: point2].		self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.		pointA _ pointC.		pointB _ pointD.		cross1 _ cross2.	].	balloon == aCanvas ifFalse:[balloon flush].! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 9/4/2001 19:50'!framePolygon: vertices on: aCanvas	| dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 	 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends pointE pointF |	balloon _ aCanvas asBalloonCanvas.	balloon == aCanvas ifFalse:[balloon deferred: true].	ends _ Array new: 6.	w _ width * 0.5.	pointA _ nil.	1 to: vertices size do:[:i|		p1 _ vertices atWrap: i.		p2 _ vertices atWrap: i+1.		p3 _ vertices atWrap: i+2.		p4 _ vertices atWrap: i+3.		dir1 _ p2 - p1.		dir2 _ p3 - p2.		dir3 _ p4 - p3.		(i = 1 | true) ifTrue:[			"Compute the merge points of p1->p2 with p2->p3"			cross1 _ dir2 crossProduct: dir1.			nrm1 _ dir1 normalized. nrm1 _ (nrm1 y * w) @ (0 - nrm1 x * w).			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm1 _ nrm1 negated. nrm2 _ nrm2 negated].			point1 _ (p1 x + nrm1 x) @ (p1 y + nrm1 y).			point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).			pointA _ self intersectFrom: point1 with: dir1 to: point2 with: dir2.			point1 _ (p1 x - nrm1 x) @ (p1 y - nrm1 y).			point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).			pointB _ point1 + dir1 + point2 * 0.5.			pointB _ p2 + ((pointB - p2) normalized * w).			pointC _ point2.		].		"Compute the merge points of p2->p3 with p3->p4"		cross2 _ dir3 crossProduct: dir2.		nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).		nrm3 _ dir3 normalized. nrm3 _ (nrm3 y * w) @ (0 - nrm3 x * w).		cross2 < 0 ifTrue:[nrm2 _ nrm2 negated. nrm3 _ nrm3 negated].		point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).		point3 _ (p3 x + nrm3 x) @ (p3 y + nrm3 y).		pointD _ self intersectFrom: point2 with: dir2 to: point3 with: dir3.		point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).		point3 _ (p3 x - nrm3 x) @ (p3 y - nrm3 y).		pointF _ point2 + dir2.		pointE _ pointF + point3 * 0.5.		pointE _ p3 + ((pointE - p3) normalized * w).		cross1 * cross2 < 0.0 ifTrue:[			ends				at: 1 put: pointA;				at: 2 put: pointB;				at: 3 put: pointC;				at: 4 put: pointD;				at: 5 put: pointE;				at: 6 put: pointF.		] ifFalse:[			ends 				at: 1 put: pointA; 				at: 2 put: pointB;				at: 3 put: pointC; 				at: 4 put: pointF; 				at: 5 put: pointE;				at: 6 put: pointD.		].		self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.		pointA _ pointD.		pointB _ pointE.		pointC _ pointF.		cross1 _ cross2.	].	balloon == aCanvas ifFalse:[balloon flush].! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 8/26/2001 19:01'!frameRectangle: aRectangle on: aCanvas	"Note: This uses BitBlt since it's roughly a factor of two faster for rectangles"	| w h r |	self colors ifNil:[^super frameRectangle: aRectangle on: aCanvas].	w _ self width.	w isPoint ifTrue:[h _ w y. w _ w x] ifFalse:[h _ w].	1 to: h do:[:i| "top/bottom"		r _ (aRectangle topLeft + (i-1)) extent: (aRectangle width - (i-1*2))@1. "top"		aCanvas fillRectangle: r color: (colors at: i).		r _ (aRectangle bottomLeft + (i @ (0-i))) extent: (aRectangle width - (i-1*2) - 1)@1. "bottom"		aCanvas fillRectangle: r color: (colors at: colors size - i + 1).	].	1 to: w do:[:i| "left/right"		r _ (aRectangle topLeft + (i-1)) extent: 1@(aRectangle height - (i-1*2)). "left"		aCanvas fillRectangle: r color: (colors at: i).		r _ aRectangle topRight + ((0-i)@i) extent: 1@(aRectangle height - (i-1*2) - 1). "right"		aCanvas fillRectangle: r color: (colors at: colors size - i + 1).	].! !!ComplexBorder methodsFor: 'color tracking' stamp: 'ar 8/25/2001 18:17'!trackColorFrom: aMorph	baseColor ifNil:[self color: aMorph raisedColor].! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:15'!colorsForDirection: direction	"Return an array of colors describing the receiver in the given direction"	| colorArray dT cc |	cc _ self colors.	(direction x * direction y) <= 0 ifTrue:[		"within up->right or down->left transition; no color blend needed"		(direction x > 0 or:[direction y < 0]) ifTrue:["up->right"			colorArray _ cc copyFrom: 1 to: width.		] ifFalse:["down->left"			"colors are stored in reverse direction when following a line"			colorArray _ (cc copyFrom: width+1 to: cc size) reversed.		].	] ifFalse:[		"right->down or left->up transition; need color blend"		colorArray _ Array new: width.		dT _ direction x asFloat / (direction x + direction y).		(direction x > 0 or:[direction y >= 0]) ifTrue:["top-right"			1 to: width do:[:i|				colorArray at: i put: 					((cc at: i) mixed: dT with: (cc at: cc size - i + 1))]		] ifFalse:["bottom-left"			1 to: width do:[:i|				colorArray at: i put: 					((cc at: cc size - i + 1) mixed: dT with: (cc at: i))]		].	].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:16'!computeAltFramedColors	| base light dark w hw colorArray param |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	w = 1 ifTrue:[^{base mixed: 0.5 with: light. base mixed: 0.5 with: dark}].	colorArray _ Array new: w.	hw _ w // 2.	"brighten"	0 to: hw-1 do:[:i|		param _ 0.5 + (i asFloat / hw * 0.5).		colorArray at: i+1 put: (base mixed: param with: dark). "brighten"		colorArray at: w-i put: (base mixed: param with: light). "darken"	].	w odd ifTrue:[colorArray at: hw+1 put: base].	^colorArray, colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:16'!computeAltInsetColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		false			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: dark). "darken"		colorArray at: colorArray size - i put: (base mixed: param with: light). "brighten"	].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:16'!computeAltRaisedColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		false 			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: colorArray size - i put: (base mixed: param with: dark). "darken"	].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 11/26/2001 15:00'!computeColors	width = 0 ifTrue:[^colors _ #()].	style == #complexFramed ifTrue:[^self computeFramedColors].	style == #complexAltFramed ifTrue:[^self computeAltFramedColors].	style == #complexRaised ifTrue:[^self computeRaisedColors].	style == #complexAltRaised ifTrue:[^self computeAltRaisedColors].	style == #complexInset ifTrue:[^self computeInsetColors].	style == #complexAltInset ifTrue:[^self computeAltInsetColors].	self error:'Unknown border style: ', style printString.! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:35'!computeFramedColors	| base light dark w hw colorArray param |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	w = 1 ifTrue:[^{base mixed: 0.5 with: light. base mixed: 0.5 with: dark}].	colorArray _ Array new: w.	hw _ w // 2.	"brighten"	0 to: hw-1 do:[:i|		param _ 0.5 + (i asFloat / hw * 0.5).		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: w-i put: (base mixed: param with: dark). "darken"	].	w odd ifTrue:[colorArray at: hw+1 put: base].	^colorArray, colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:16'!computeInsetColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		true			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: dark). "darken"		colorArray at: colorArray size - i put: (base mixed: param with: light). "brighten"	].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:16'!computeRaisedColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		true 			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: colorArray size - i put: (base mixed: param with: dark). "darken"	].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'ar 9/4/2001 19:51'!fillStyleForDirection: direction	"Fill the given form describing the receiver's look at a particular direction"	| index fill dir |	index _ direction degrees truncated // 10 + 1.	lineStyles ifNotNil:[		fill _ lineStyles at: index.		fill ifNotNil:[^fill].	].	dir _ Point r: 1.0 degrees: index - 1 * 10 + 5.	fill _ GradientFillStyle colors: (self colorsForDirection: dir).	fill direction: 0 @ width asPoint y; radial: false.	fill origin: ((width asPoint x // 2) @ (width asPoint y // 2)) negated.	fill pixelRamp: (fill computePixelRampOfSize: 16).	fill isTranslucent. "precompute"	lineStyles ifNil:[lineStyles _ Array new: 37].	lineStyles at: index put: fill.	^fill! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/26/2001 23:39'!intersectFrom: startPt with: startDir to: endPt with: endDir	"Compute the intersection of two lines. Return nil if either		* the intersection does not exist, or		* the intersection is 'before' startPt, or		* the intersection is 'after' endPt	"	| det deltaPt alpha beta |	det _ (startDir x * endDir y) - (startDir y * endDir x).	det = 0.0 ifTrue:[^nil]. "There's no solution for it"	deltaPt _ endPt - startPt.	alpha _ (deltaPt x * endDir y) - (deltaPt y * endDir x).	beta _ (deltaPt x * startDir y) - (deltaPt y * startDir x).	alpha _ alpha / det.	beta _ beta / det.	alpha < 0 ifTrue:[^nil].	beta > 1.0 ifTrue:[^nil].	"And compute intersection"	^(startPt x + (alpha * startDir x)) @ (startPt y + (alpha * startDir y))! !!ComplexBorder class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 16:22'!style: aSymbol	^self new style: aSymbol! !!InsetBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:11'!bottomRightColor	^width = 1 		ifTrue: [color twiceLighter]		ifFalse: [color lighter]! !!InsetBorder methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:23'!colorsAtCorners	| c c14 c23 |	c _ self color.	c14 _ c lighter. c23 _ c darker.	^Array with: c23 with: c14 with: c14 with: c23.! !!InsetBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:51'!style	^#inset! !!InsetBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:11'!topLeftColor	^width = 1 		ifTrue: [color twiceDarker]		ifFalse: [color darker]! !!InsetBorder methodsFor: 'color tracking' stamp: 'ar 8/25/2001 18:17'!trackColorFrom: aMorph	baseColor ifNil:[self color: aMorph insetColor].! !!RaisedBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:34'!bottomRightColor	^width = 1 		ifTrue: [color twiceDarker]		ifFalse: [color darker]! !!RaisedBorder methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:23'!colorsAtCorners	| c c14 c23 |	c _ self color.	c14 _ c lighter. c23 _ c darker.	^Array with: c14 with: c23 with: c23 with: c14! !!RaisedBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:51'!style	^#raised! !!RaisedBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:34'!topLeftColor	^width = 1 		ifTrue: [color twiceLighter]		ifFalse: [color lighter]! !!RaisedBorder methodsFor: 'color tracking' stamp: 'ar 8/25/2001 18:17'!trackColorFrom: aMorph	baseColor ifNil:[self color: aMorph raisedColor].! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 8/25/2001 19:09'!canDrawBorder: aBorderStyle	^aBorderStyle style == #simple! !ObjectPropertiesMorph removeSelector: #paneForBorderToggles!ObjectPropertiesMorph removeSelector: #targerBorderIsInset!ObjectPropertiesMorph removeSelector: #targerBorderIsRaised!ObjectPropertiesMorph removeSelector: #toggleTargetBorderInset!ObjectPropertiesMorph removeSelector: #toggleTargetBorderRaised!BorderedMorph removeSelector: #drawOn:!Morph removeSelector: #colorsAtCorners!