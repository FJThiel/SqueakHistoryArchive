'From Squeak 2.2 of Sept 23, 1998 on 11 October 1998 at 3:49:30 am'!"Change Set:		PluggablePrims-Examples-arDate:			11 October 1998Author:			Andreas RaabThe change set includes two examples for pluggable primitives.FloatArrays - Arrays storing 32bit IEEE floating point numberfor numerically heavy computations.FFT - Using FloatArrays to speed up the FFT computation byabout a factor of 150 (yes, really!!). The FFTPlugin is also anexample how entire plugins can be simulated from Smalltalkcode and how to deal with instance specific data in a primitive.Finally, the translation methods of Interpreter DynamicInterpreterhave been modified to translate the two plugins in the source code."!InterpreterPlugin subclass: #FFTPlugin	instanceVariableNames: 'nu fftSize sinTable sinTableSize permTable permTableSize realData realDataSize imagData imagDataSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!InterpreterPlugin subclass: #FloatArrayPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!ArrayedCollection variableWordSubclass: #FloatArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!ArrayedCollection variableWordSubclass: #IntegerArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!ArrayedCollection variableWordSubclass: #WordArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!DynamicInterpreter class methodsFor: 'translation' stamp: 'ar 10/11/1998 00:32'!translate: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: false.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: false.		Smalltalk beep]"	self	translate: fileName		doInlining: inlineFlag		doAssertions: assertionFlag		fromClasses: (OrderedCollection new				add: BitBltSimulation;				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;				add: FFTPlugin;				add: FloatArrayPlugin;			yourself)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginPrepareData	"The FFT plugin requires data to be represented in WordArrays or FloatArrays"	sinTable _ sinTable asFloatArray.	permTable _ permTable asWordArray.	realData _ realData asFloatArray.	imagData _ imagData asFloatArray.! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginTest  "Display restoreAfter: [(FFT new nu: 12) pluginTest]."	"Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self pluginPrepareData.	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: true]); endEntry.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: false]); endEntry.	self plot: realData in: (100@260 extent: 256@60)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/11/1998 02:52'!pluginTransformData: forward	"Plugin testing -- if the primitive is not implemented 	or cannot be found run the simulation. See also: FFTPlugin"	<primitive: 'primitiveFFTTransformData'>	^FFTPlugin doPrimitive: 'primitiveFFTTransformData'.! !!FFTPlugin commentStamp: '<historical>' prior: 0!FFTPlugin is an example  of how plugins are written. It shows the use of FloatArray for heavy numerical stuff as well as the simulation of plugins from Squeak.See also:		FFT pluginTransformData:!]style[(173 24 1)f1,f1LFFT pluginTransformData:;,f1!!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTPermuteData	| rcvr |	self export: true.	rcvr _ interpreterProxy stackObjectValue: 0.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self permuteData.	interpreterProxy failed ifTrue:[		"permuteData went wrong. Do the permutation again -- this will restore the original order"		self permuteData].! !!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTScaleData	| rcvr |	self export: true.	rcvr _ interpreterProxy stackObjectValue: 0.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self scaleData.! !!FFTPlugin methodsFor: 'primitives' stamp: 'ar 10/11/1998 01:59'!primitiveFFTTransformData	| rcvr forward |	self export: true.	forward _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	rcvr _ interpreterProxy stackObjectValue: 1.	(self loadFFTFrom: rcvr) ifFalse:[^nil].	self transformData: forward.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 00:25'!permuteData	| i end a b tmp |	self var: #tmp declareC: 'float tmp'.	i _ 0.	end _ permTableSize.	[i < end] whileTrue:		[a _ (permTable at: i) - 1.		b _ (permTable at: i+1) - 1.		(a < realDataSize and:[b < realDataSize]) ifFalse:[^interpreterProxy success: false].		tmp _ realData at: a.		realData at: a put: (realData at: b).		realData at: b put: tmp.		tmp _ imagData at: a.		imagData at: a put: (imagData at: b).		imagData at: b put: tmp.		i _ i + 2]! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 10/3/1998 18:10'!scaleData	"Scale all elements by 1/n when doing inverse"	| realN |	self var: #realN declareC: 'float realN'.	fftSize <= 1 ifTrue:[^nil].	realN _ self cCoerce: (1.0 / (self cCoerce: fftSize to: 'double')) to: 'float'.	0 to: fftSize-1 do:		[:i |		realData at: i put: (realData at: i) * realN.		imagData at: i put: (imagData at: i) * realN]! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 20:21'!transformData: forward	self permuteData.	interpreterProxy failed ifTrue:[		"permuteData went wrong. Do the permutation again -- this will restore the original order"		self permuteData.		^nil].	self transformForward: forward.	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FFTPlugin methodsFor: 'transforming' stamp: 'ar 9/16/1998 21:28'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i fftSize2 fftSize4 fftScale ii |	self var: #realU declareC:'float realU'.	self var: #realT declareC:'float realT'.	self var: #imagU declareC:'float imagU'.	self var: #imagT declareC:'float imagT'.	fftSize2 _ fftSize // 2.	fftSize4 _ fftSize // 4.	1 to: nu do:		[:level |		lev _ 1 bitShift: level.		lev1 _ lev // 2.		fftScale _ fftSize // lev.		1 to: lev1 do:			[:j |			theta _ j-1 * fftScale.   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < fftSize4  "Compute U, the complex multiplier for each level"				ifTrue:					[realU _ sinTable at: sinTableSize - theta - 1.					imagU _ sinTable at: theta]				ifFalse:					[realU _ 0.0 - (sinTable at: theta - fftSize4).					imagU _ sinTable at: fftSize2 - theta].			forward ifFalse: [imagU _ 0.0 - imagU]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i _ j.			[i <= fftSize] whileTrue:				[ip _ i + lev1 - 1.				ii _ i-1.				realT _ ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT _ ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: ii) - realT.				imagData at: ip put: (imagData at: ii) - imagT.				realData at: ii put: (realData at: ii) + realT.				imagData at: ii put: (imagData at: ii) + imagT.				i _ i + lev]]].! !!FFTPlugin methodsFor: 'private' stamp: 'ar 9/16/1998 21:40'!checkedFloatPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'float *'.	interpreterProxy success: (interpreterProxy isWords: oop).	interpreterProxy failed ifTrue:[^0].	^self cCoerce: (interpreterProxy firstIndexableField: oop) to:'float *'! !!FFTPlugin methodsFor: 'private' stamp: 'ar 9/16/1998 21:40'!checkedWordPtrOf: oop	"Return the first indexable word of oop which is assumed to be variableWordSubclass"	self returnTypeC:'unsigned int *'.	interpreterProxy success: (interpreterProxy isWords: oop).	^self cCoerce: (interpreterProxy firstIndexableField: oop) to: 'unsigned int *'! !!FFTPlugin methodsFor: 'private' stamp: 'ar 10/10/1998 21:43'!loadFFTFrom: fftOop	| oop |	interpreterProxy success: (interpreterProxy slotSizeOf: fftOop) >= 6.	interpreterProxy failed ifTrue:[^false].	nu _ interpreterProxy fetchInteger: 0 ofObject: fftOop.	fftSize _ interpreterProxy fetchInteger: 1 ofObject: fftOop.	oop _ interpreterProxy fetchPointer: 2 ofObject: fftOop.	sinTableSize _ interpreterProxy stSizeOf: oop.	sinTable _ self checkedFloatPtrOf: oop.	oop _ interpreterProxy fetchPointer: 3 ofObject: fftOop.	permTableSize _ interpreterProxy stSizeOf: oop.	permTable _ self checkedWordPtrOf: oop.	oop _ interpreterProxy fetchPointer: 4 ofObject: fftOop.	realDataSize _ interpreterProxy stSizeOf: oop.	realData _ self checkedFloatPtrOf: oop.	oop _ interpreterProxy fetchPointer: 5 ofObject: fftOop.	imagDataSize _ interpreterProxy stSizeOf: oop.	imagData _ self checkedFloatPtrOf: oop.	"Check assumptions about sizes"	interpreterProxy success:		(1 << nu = fftSize) & 		(fftSize // 4 + 1 = sinTableSize) & 		(fftSize = realDataSize) & 		(fftSize = imagDataSize) &		(realDataSize = imagDataSize).	^interpreterProxy failed == false! !!FFTPlugin class methodsFor: 'accessing' stamp: 'ar 9/14/1998 23:51'!moduleName	^'sqFFT'! !!FFTPlugin class methodsFor: 'translation to C' stamp: 'ar 9/15/1998 00:27'!declareCVarsIn: cg	cg var: 'sinTable' declareC:'float *sinTable'.	cg var: 'realData' declareC: 'float *realData'.	cg var: 'imagData' declareC:'float *imagData'.	cg var: 'permTable' declareC:'unsigned int *permTable'.! !!FloatArray class methodsFor: 'primitive generation' stamp: 'ar 10/11/1998 03:06'!cCodeString	"FloatArray cCodeString"	^PluggableCodeGenerator new codeStringForPrimitives:#(		(FloatArray primAddArray:withArray:from:to:)		(FloatArray primSubArray:withArray:from:to:)		(FloatArray primMulArray:withArray:from:to:)	)! !!FloatArrayPlugin commentStamp: '<historical>' prior: 0!FloatArrayPlugin defines the basic access messages for FloatArray (e.g., floatAt: and floatAt:put:).!!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:46'!primitiveFloatArrayAt	| index rcvr floatValue floatPtr |	self export: true.	self var: #floatValue declareC:'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	index _ interpreterProxy stackIntegerValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatValue _ (floatPtr at: index-1) asFloat.	interpreterProxy pop: 2.	interpreterProxy pushFloat: floatValue.! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:46'!primitiveFloatArrayAtPut	| value floatValue index rcvr floatPtr |	self export: true.	self var: #floatValue declareC: 'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	value _ interpreterProxy stackObjectValue: 0.	floatValue _ interpreterProxy floatValueOf: value.	index _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatPtr at: index-1 put: (self cCoerce: floatValue to:'float').	interpreterProxy failed ifFalse:[interpreterProxy pop: 3 thenPush: value].! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:29'!primitiveFloatArrayEqual	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 2.	length _ interpreterProxy stSizeOf: arg.	length = (interpreterProxy stSizeOf: rcvr) ifFalse:[^interpreterProxy pushBool: false].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		(rcvrPtr at: i) = (argPtr at: i) ifFalse:[^interpreterProxy pushBool: false].	].	^interpreterProxy pushBool: true! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 10/11/1998 01:29'!primitiveFloatArrayHash	| rcvr rcvrPtr length result |	self export: true.	self var: #rcvrPtr declareC:'int *rcvrPtr'.	rcvr _ interpreterProxy stackObjectValue: 0.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'int *'.	result _ 0.	0 to: length-1 do:[:i|		result _ result + (rcvrPtr at: i).		rcvrPtr _ rcvrPtr + 4.	].	interpreterProxy pop: 1.	^interpreterProxy pushInteger: (result bitAnd: 16r1FFFFFFF)! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayAddFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayAddScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayDivFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	"Check if any of the argument's values is zero"	0 to: length-1 do:[:i|		(interpreterProxy longAt: (argPtr + i)) = 0 ifTrue:[^interpreterProxy primitiveFail]].	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) / (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 00:59'!primitiveFloatArrayDivScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value inverse length |	self export: true.	self var: #value declareC:'double value'.	self var: #inverse declareC:'double inverse'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	value = 0.0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	inverse _ 1.0 / value.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * inverse.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArrayMulFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArrayMulScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArraySubFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 10/11/1998 01:00'!primitiveFloatArraySubScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin class methodsFor: 'accessing' stamp: 'ar 9/11/1998 18:02'!moduleName	^'SqFloatArray'! !!FloatArrayPlugin class methodsFor: 'translation to C' stamp: 'ar 9/15/1998 00:30'!declareCVarsIn: cg	"Nothing to declare..."! !!Interpreter class methodsFor: 'translation' stamp: 'ar 10/11/1998 00:26'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	{FFTPlugin. FloatArrayPlugin} do:[:plugin|		plugin initialize.		cg addClass:plugin.		plugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray _ FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray _ IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray _ WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!FloatArray commentStamp: '<historical>' prior: 0!FloatArrays store 32bit IEEE floating point numbers.!!FloatArray reorganize!('accessing' at: at:put:)('arithmetic' * *= + += - -= / /=)('comparing' = hash)('primitives-plugin' primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:)('primitives-translated' primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:)('converting' asFloatArray)('private' basicFloatAt: basicFloatAt:put: replaceFrom:to:with:startingAt:)!!FloatArray methodsFor: 'accessing' stamp: 'ar 10/11/1998 02:45'!at: index	<primitive: 'primitiveFloatArrayAt'>	^self basicFloatAt: index! !!FloatArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 21:54'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	^self basicFloatAt: index put: value asFloat! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!* anObject	^self clone *= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!*= anObject	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!+ anObject	^self clone += anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:48'!+= anObject	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!- anObject	^self clone -= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!-= anObject	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:34'!/ anObject	^self clone /= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 10/7/1998 19:58'!/= anObject	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!= aFloatArray	| length |	<primitive:'primitiveFloatArrayEqual'>	length _ self size.	(length = aFloatArray size) ifFalse:[^false].	1 to: self size do:[:i| (self at: i) = (aFloatArray at: i) ifFalse:[^false]].	^true! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/11/1998 03:10'!primAddArray: floatArray	<primitive: 'primitiveFloatArrayAddFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primAddScalar: scalarValue	<primitive: 'primitiveFloatArrayAddScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primDivArray: floatArray	<primitive: 'primitiveFloatArrayDivFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primDivScalar: scalarValue	<primitive: 'primitiveFloatArrayDivScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primMulArray: floatArray	<primitive: 'primitiveFloatArrayMulFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primMulScalar: scalarValue	<primitive: 'primitiveFloatArrayMulScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:01'!primSubArray: floatArray	<primitive: 'primitiveFloatArraySubFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primSubScalar: scalarValue	<primitive: 'primitiveFloatArraySubScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/11/1998 03:06'!primAddArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArrayAddFloatArrayFromTo' module: 'sqPlugin'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) + (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/9/1998 11:26'!primMulArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArrayMulFloatArrayFromTo'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) * (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'primitives-translated' stamp: 'ar 10/9/1998 11:26'!primSubArray: floatArray1 withArray: floatArray2 from: firstIndex to: lastIndex	| length stop start srcIndex |	<primitive: 'primitiveFloatArraySubFloatArrayFromTo'>	self var: #floatArray1 declareC:'float *floatArray1'.	self var: #floatArray2 declareC:'float *floatArray2'.	length _ floatArray1 size.	start _ firstIndex.	stop _ length min: lastIndex.	length _ floatArray2 size.	(stop - start + 1) > length ifTrue:[stop _ start + length - 1].	srcIndex _ 1.	start to: stop do:[:dstIndex|		floatArray1 at: dstIndex put: (floatArray1 at: dstIndex) - (floatArray2 at: srcIndex).		srcIndex _ srcIndex+1].! !!FloatArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asFloatArray	^self! !!FloatArray methodsFor: 'private' stamp: 'ar 10/10/1998 17:40'!basicFloatAt: index	"Note: Relies on IEEE floats!!"	| word sign mantissa exponent newFloat |	word _ self basicAt: index.	word = 0 ifTrue:[^0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^Float nan].		sign = 0 			ifTrue:[^Float infinity]			ifFalse:[^Float infinity negated]].	"Create new float"	newFloat _ Float new: 2.	newFloat basicAt: 1 put: sign + (1023 + exponent bitShift: 20) + (mantissa bitShift: -3).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!FloatArray methodsFor: 'private' stamp: 'ar 10/10/1998 17:40'!basicFloatAt: index put: value	"Note: Relies on IEEE floats!!"	| word1 word2 sign mantissa exponent destWord |	value = 0.0 ifTrue:[^self basicAt: index put: 0].	word1 _ value basicAt: 1.	word2 _ value basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^self basicAt: index put: 0].	exponent > 254 ifTrue:[		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ sign + (exponent bitShift: 23) + mantissa.	self basicAt: index put: destWord.! !!FloatArray methodsFor: 'private' stamp: 'ar 10/9/1998 11:27'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!IntegerArray commentStamp: '<historical>' prior: 0!IntegerArrays store 32bit signed Integer values.Negative values are stored as 2's complement.!!IntegerArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 20:37'!at: index	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 10/10/1998 20:37'!at: index put: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger - 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'converting' stamp: 'ar 10/10/1998 16:18'!asIntegerArray	^self! !!WordArray commentStamp: '<historical>' prior: 0!IntegerArrays store 32bit unsigned Integer values.!!WordArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asWordArray	^self! !