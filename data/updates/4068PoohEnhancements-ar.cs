'From Squeak3.1alpha of 28 February 2001 [latest update: #4064] on 24 May 2001 at 1:55:03 pm'!"Change Set:		PoohEnhancements-arDate:			24 May 2001Author:			Andreas RaabThe CS makes Pooh more robust and allows for self-intersecting outlines as well."!SubdivisionHalfEdge subclass: #PoohHalfEdge	instanceVariableNames: 'leftFace rightFace fanVertices '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Pooh'!SubdivisionQuadEdge subclass: #PoohQuadEdge	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Pooh'!Subdivision subclass: #PoohSubdivision	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Pooh'!BorderedMorph subclass: #PoohTestMorph	instanceVariableNames: 'points subdivision lastPoint firstPoly time '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Pooh'!!PoohTestMorph commentStamp: '<historical>' prior: 0!PoohTestMorph new openInWorld.!Object subclass: #PoohTriangle	instanceVariableNames: 'flags e1 e2 e3 next '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon3D-Pooh'!!PoohTriangle commentStamp: '<historical>' prior: 0!| faces points |points _ (0 to: 35) collect:[:i| 	(B3DRotation angle: i*5 axis: 0@0@1) asMatrix4x4 localPointToGlobal: (20@0@0)].points _ points collect:[:v3| v3 x @ v3 y].points _ {300@196. 299@205. 297@210. 296@212}.faces _ PoohTriangle basicNew elevateFan: points to: 246@158@74 steps: 8.faces _ B3DSimpleMesh withAll: faces.(B3DSceneExplorerMorph new openInWorld) scene withGeometry: faces asIndexedMesh.!!B3DIndexedMesh methodsFor: 'modifying' stamp: 'ar 5/20/2001 01:37'!transformBy: aMatrix	"Modify the mesh by transforming it using a matrix; this allows us to change the insertion point of the mesh"	| transformer primVtx |	transformer _ B3DPrimitiveTransformer new.	primVtx _ B3DPrimitiveVertex new.	vertices do:[:vtx|		primVtx position: vtx.		transformer privateTransformPrimitiveVertex: primVtx byModelView: aMatrix.		vtx loadFrom: primVtx position].	vtxNormals ifNotNil:[		vtxNormals do:[:nrm|			primVtx normal: nrm.			transformer privateTransformPrimitiveNormal: primVtx byMatrix: aMatrix rescale: true.			nrm loadFrom: primVtx normal]].	bBox ifNotNil: [bBox _ self computeBoundingBox].	vtxNormals ifNil:[self computeVertexNormals].! !!B3DIndexedTriangle methodsFor: 'testing' stamp: 'ar 5/22/2001 22:54'!isDegenerate	(self at: 1) = (self at: 2) ifTrue:[^true].	(self at: 2) = (self at: 3) ifTrue:[^true].	(self at: 3) = (self at: 1) ifTrue:[^true].	^false! !!B3DMatrix4x4 class methodsFor: 'instance creation' stamp: 'ar 5/20/2001 00:12'!withScale: amount	^self identity setScale: amount! !!B3DSimpleMesh methodsFor: 'converting' stamp: 'ar 5/22/2001 22:55'!asIndexedTriangleMesh	"Convert the receiver into (the more compact) indexed triangle representation"	| map faces face vtx nrm tex col mesh |	map _ Dictionary new: (self size * 4). "Need some space for the vertices"	faces _ WriteStream on: (B3DIndexedTriangleArray new: self size).	self trianglesDo:[:tri|		tri assureVertexNormals.		face _ B3DIndexedTriangle					with: (map at: tri first ifAbsentPut:[map size + 1])					with: (map at: tri second ifAbsentPut:[map size + 1])					with: (map at: tri third ifAbsentPut:[map size + 1]).		face isDegenerate ifFalse:[faces nextPut: face]].	faces _ faces contents.	vtx _ B3DVector3Array new: map size.	nrm _ B3DVector3Array new: map size.	self hasTextureCoords ifTrue:[tex _ B3DTexture2Array new: map size].	self hasVertexColors ifTrue:[col _ B3DColor4Array new: map size].	map keysAndValuesDo:[:vertex :idx|		vtx at: idx put: vertex position.		nrm at: idx put: vertex normal.		tex == nil ifFalse:[tex at: idx put: vertex texCoord].		col == nil ifFalse:[col at: idx put: vertex color].	].	mesh _ B3DIndexedTriangleMesh new.	mesh faces: faces.	mesh vertices: vtx.	mesh texCoords: tex.	mesh vertexColors: col.	mesh vertexNormals: nrm.	^mesh! !!B3DSimpleMesh methodsFor: 'rendering' stamp: 'ar 5/20/2001 00:08'!renderOn: aRenderer	1 to: self size do:[:i|		(self at: i) renderOn: aRenderer.	].! !!B3DSimpleMeshFace methodsFor: 'testing' stamp: 'ar 5/23/2001 01:14'!isDegenerate	self size = 3 ifFalse:[^false].	(self at: 1) position = (self at: 2) position ifTrue:[^true].	(self at: 2) position = (self at: 3) position ifTrue:[^true].	(self at: 1) position = (self at: 3) position ifTrue:[^true].	^false! !!B3DSimpleMeshFace methodsFor: 'enumerating' stamp: 'ar 5/23/2001 01:13'!trianglesDo: aBlock	"Evaluate aBlock with triangular faces"	| face |	self size = 3		ifTrue:[^aBlock value: self].	3 to: self size do:[:i|		face _ self class with: (self at: 1) with: (self at: i-1) with: (self at: i).		face isDegenerate ifFalse:[aBlock value: face].	].! !!B3DSimpleMeshVertex methodsFor: 'rendering' stamp: 'ar 5/20/2001 00:07'!renderOn: aRenderer	color == nil ifFalse:[aRenderer color: color].	texCoord == nil ifFalse:[aRenderer texCoords: texCoord].	normal == nil ifFalse:[aRenderer normal: normal].	aRenderer vertex: position.! !!B3DVector3 methodsFor: 'converting' stamp: 'ar 5/23/2001 00:24'!asPoint	^self x @ self y! !!B3DVector3 methodsFor: 'enumerating' stamp: 'ar 5/20/2001 00:05'!vertexPositionsDo: aBlock	aBlock value: self! !!Number methodsFor: 'converting' stamp: 'ar 5/20/2001 01:40'!asB3DVector3	^self@self@self! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 22:57'!elevationHeight	| height center |	height _ self length * 0.5.	fanVertices ifNotNil:[		center _ self center.		fanVertices do:[:v| height _ height + (v dist: center)].		height _ height / (fanVertices size + 1) asFloat].	^height! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 20:46'!fanVertices	^fanVertices! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 20:46'!fanVertices: pointList	fanVertices _ pointList! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:37'!leftFace	^leftFace! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:09'!leftFace: aFace	self assert:[leftFace == nil].	leftFace _ aFace! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:37'!rightFace	^rightFace! !!PoohHalfEdge methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:09'!rightFace: aFace	self assert:[rightFace == nil].	rightFace _ aFace! !!PoohHalfEdge methodsFor: 'testing' stamp: 'ar 5/19/2001 19:26'!hasAllInsideCircle: aCollection 	"Tests if all Points in aCollection are inside the circle which has this  	edge as a diameter"	| start end |	start _ self origin.	end _ self destination.	aCollection do: [:aPoint | (start - aPoint dotProduct: end - aPoint)			> 0 ifTrue: [^ false]].	^ true! !!PoohHalfEdge methodsFor: 'private' stamp: 'ar 5/19/2001 17:08'!quadEdgeClass	^PoohQuadEdge! !!PoohQuadEdge methodsFor: 'private' stamp: 'ar 5/19/2001 22:51'!edgeClass	^PoohHalfEdge! !!PoohSubdivision methodsFor: 'private' stamp: 'ar 5/24/2001 12:54'!build3DObject	"Return the full triangulation of the receiver"	| firstPoly poly faces mesh half scale vtx nrm |	self markExteriorEdges.	firstPoly _ self triangulate.	faces _ WriteStream on: #().	poly _ firstPoly.	[poly == nil] whileFalse:[		faces nextPutAll: (poly elevateSpine: 4).		poly _ poly next].	faces _ faces contents.	faces isEmpty ifTrue:[^nil].	half _ B3DSimpleMesh withAll: faces contents.	scale _ 0.5 / area extent.	half do:[:face| face do:[:v|		v texCoord: (v position x @ v position y) - area origin * scale]].	half _ half asIndexedMesh.	half vertexNormals: (half computeVertexNormals collect:[:v| v negated]).	vtx _ half vertices.	nrm _ half vertexNormals.	1 to: vtx size do:[:i|		(vtx at: i) z = 0.0 ifTrue:[nrm at: i put: ((nrm at: i) z: 0.0)]].	mesh _ self mirror: half.	^mesh! !!PoohSubdivision methodsFor: 'private' stamp: 'ar 5/19/2001 20:37'!createPolygons	| poly firstPoly |	firstPoly _ nil.	self innerTriangleEdgesDo:[:e1 :e2 :e3|		poly _ PoohTriangle new.		poly e1: e1 e2: e2 e3: e3.		poly recomputeType.		poly next: firstPoly.		firstPoly _ poly.	].	^firstPoly! !!PoohSubdivision methodsFor: 'private' stamp: 'ar 5/22/2001 18:41'!mirror: half	"Mirror one half-mesh and return a full mesh"	| vtx nrm tex faces faceOffset vtxOffset mesh |	vtx _ B3DVector3Array new: half vertices size * 2.	nrm _ B3DVector3Array new: half vertexNormals size * 2.	tex _ B3DVector2Array new: half texCoords size * 2.	faces _ B3DIndexedTriangleArray new: (half faces size * 2).	"Fill in first half"	vtx 		privateReplaceFrom: 1 		to: half vertices basicSize 		with: half vertices 		startingAt: 1.	nrm 		privateReplaceFrom: 1 		to: half vertexNormals basicSize 		with: half vertexNormals 		startingAt: 1.	tex 		privateReplaceFrom: 1 		to: half texCoords basicSize 		with: half texCoords 		startingAt: 1.	faces 		privateReplaceFrom: 1 		to: half faces basicSize 		with: half faces 		startingAt: 1.	"fill in second half"	half transformBy: (B3DMatrix4x4 withScale: 1@1@-1).	half texCoords do:[:tx| tx v: (1.0 - tx v)].	vtx 		privateReplaceFrom: half vertices basicSize + 1 		to: vtx basicSize 		with: half vertices 		startingAt: 1.	nrm 		privateReplaceFrom: half vertexNormals basicSize + 1 		to: nrm basicSize 		with: half vertexNormals 		startingAt: 1.	tex 		privateReplaceFrom: half texCoords basicSize + 1 		to: tex basicSize 		with: half texCoords 		startingAt: 1.	faceOffset _ half faces basicSize.	vtxOffset _ half vertices size.	1 to: half faces size do:[:i|		faces 			basicAt: (faceOffset _ faceOffset + 1) 			put: (half faces basicAt: (i-1) * 3 + 3) + vtxOffset.		faces 			basicAt: (faceOffset _ faceOffset + 1) 			put: (half faces basicAt: (i-1) * 3 + 2) + vtxOffset.		faces 			basicAt: (faceOffset _ faceOffset + 1) 			put: (half faces basicAt: (i-1) * 3 + 1) + vtxOffset.	].	mesh _ B3DIndexedTriangleMesh new.	mesh vertices: vtx.	mesh vertexNormals: nrm.	mesh faces: faces.	mesh texCoords: tex.	^mesh! !!PoohSubdivision methodsFor: 'private' stamp: 'ar 5/19/2001 17:08'!quadEdgeClass	^PoohQuadEdge! !!PoohSubdivision methodsFor: 'private' stamp: 'ar 5/22/2001 13:29'!triangulate	"Return the full triangulation of the receiver"	| firstPoly poly |	"Create the triangle list"	firstPoly _ self createPolygons.	poly _ firstPoly.	[poly == nil] whileFalse:[		poly buildTerminalFan.		poly _ poly next].	^firstPoly! !!PoohTestMorph methodsFor: 'initialize' stamp: 'ar 5/18/2001 21:17'!initialize	super initialize.	self color: Color white.	self extent: 400@400.! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/19/2001 00:58'!handlesMouseDown: evt	^true! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/23/2001 22:58'!mouseDown: evt	lastPoint _ nil.	points _ subdivision _ firstPoly _ nil.	self mouseMove: evt.! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/19/2001 14:21'!mouseMove: evt	(lastPoint notNil and:[(lastPoint dist: evt position) < 5])  ifTrue:[^self].	lastPoint _ evt position.	points ifNil:[points _ WriteStream on: (Array new: 100)].	points nextPut: (evt position - bounds origin).	self changed.! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/19/2001 15:40'!mouseUp: evt	lastPoint _ nil.	self mouseMove: evt.	points _ points contents asArray.	self subdivide.	self changed.	"triangulation _ POTriangulation on: points."! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/23/2001 22:55'!regularize: pointCollection	"Make the pointList non-intersecting, e.g., insert points at intersections and have the outline include those points"	| pointList segments last intersections map pts |	pointList _ pointCollection collect:[:pt| pt asIntegerPoint].	segments _ WriteStream on: (Array new: pointList size).	last _ pointList last.	pointList do:[:next|		segments nextPut: (LineSegment from: last to: next).		last _ next.	].	segments _ segments contents.	intersections _ LineIntersections of: segments.	map _ IdentityDictionary new: segments size.	intersections do:[:is|		(map at: is second ifAbsentPut:[WriteStream on: (Array new: 2)]) nextPut: is first.		(map at: is third ifAbsentPut:[WriteStream on: (Array new: 2)]) nextPut: is first.	].	pts _ WriteStream on: (Array new: pointList size).	segments do:[:seg|		intersections _ (map at: seg) contents.		intersections _ intersections sort:			[:p1 :p2|  (p1 squaredDistanceTo: seg start) <= (p2 squaredDistanceTo: seg start)].		last _ intersections at: 1.		pts nextPut: last.		intersections do:[:next|			(next = last and:[next = seg end]) ifFalse:[				pts nextPut: next.				last _ next]].	].	^pts contents collect:[:pt| pt asFloatPoint]! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/19/2001 15:41'!simplify: pointList	| pts |	pts _ StrokeSimplifier new.	points do:[:aPoint| pts add: aPoint].	pts closeStroke.	^pts finalStroke.! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/19/2001 15:52'!smoothen: pointList length: unitLength	| prevPt curPt nextPt out prevMid nextMid segment length steps deltaT |	out _ WriteStream on: (Array new: pointList size).	prevPt _ pointList at: pointList size-1.	curPt _ pointList last.	prevMid _ (curPt + prevPt) * 0.5.	1 to: pointList size do:[:i|		nextPt _ pointList at: i.		nextMid _ (nextPt + curPt) * 0.5.		segment _ Bezier2Segment from: prevMid to: nextMid via: curPt.		length _ segment length.		steps _ (length / unitLength) asInteger.		steps < 1 ifTrue:[steps _ 1].		deltaT _ 1.0 / steps.		1 to: steps-1 do:[:k|			out nextPut: (segment valueAt: deltaT * k)].		out nextPut: nextMid.		prevPt _ curPt.		curPt _ nextPt.		prevMid _ nextMid.	].	^out contents! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/23/2001 22:54'!subdivide	time _ [		points _ self simplify: points.		points _ self smoothen: points length: 10.		points _ self regularize: points.		self triangulate.	] timeToRun.	self changed.! !!PoohTestMorph methodsFor: 'event handling' stamp: 'ar 5/19/2001 21:49'!triangulate	subdivision _ PoohSubdivision constraintOutline: points.	subdivision markExteriorEdges.	firstPoly _ subdivision triangulate.! !!PoohTestMorph methodsFor: 'drawing' stamp: 'ar 5/23/2001 22:59'!drawOn: aCanvas	| ptList last |	super drawOn: aCanvas.	aCanvas translateBy: bounds origin clippingTo: self innerBounds during:[:cc|		points ifNotNil:[			points class == Array 				ifTrue:[ptList _ points]				ifFalse:[ptList _ points contents].			last _ ptList last.				ptList do:[:next|					cc line: last to: next width: 5 color: (Color gray: 0.9).					last _ next]].		self drawSubdivisionTrianglesOn: cc.		self drawSubdivisionEdgesOn: cc.		self drawSubdivisionSpineOn: cc.	].	time ifNotNil:[		aCanvas text: time printString,' msecs' bounds: self innerBounds font: nil color: Color black.	].! !!PoohTestMorph methodsFor: 'drawing' stamp: 'ar 5/22/2001 12:44'!drawSubdivisionEdgesOn: cc	subdivision ifNil:[^self].	subdivision edgesDo:[:e|		cc line: e origin to: e destination width: 1 color: e classificationColor].! !!PoohTestMorph methodsFor: 'drawing' stamp: 'ar 5/19/2001 22:23'!drawSubdivisionSpineOn: cc	| p1 p2 p3 center colors |	firstPoly ifNil:[^self].false ifTrue:[	colors _ #(red green blue yellow magenta cyan) collect:[:s| Color perform: s].] ifFalse:[	colors _ {Color green}.].	firstPoly validFacesDo:[:poly|true ifTrue:[		p1 _ p2 _ p3 _ nil.true ifTrue:[		poly e1 fanVertices			ifNil:[cc line: poly e1 origin to: poly e1 destination width: 1 color: poly e1 classificationColor].		poly e2 fanVertices			ifNil:[cc line: poly e2 origin to: poly e2 destination width: 1 color: poly e2 classificationColor].		poly e3 fanVertices			ifNil:[cc line: poly e3 origin to: poly e3 destination width: 1 color: poly e3 classificationColor].].		poly e1 leftFace ifNotNil:[p1 _ poly e1 center].		poly e2 leftFace ifNotNil:[p2 _ poly e2 center].		poly e3 leftFace ifNotNil:[p3 _ poly e3 center].		(p1 notNil and:[p2 notNil and:[p3 notNil]]) ifTrue:[			center _ poly center.			poly e1 fanVertices 				ifNil:[cc line: center to: p1 width: 1 color: Color red].			poly e2 fanVertices				ifNil:[cc line: center to: p2 width: 1 color: Color red].			poly e3 fanVertices				ifNil:[cc line: center to: p3 width: 1 color: Color red].		] ifFalse:[			(p1 notNil and:[p2 notNil])				ifTrue:[cc line: p1 to: p2 width: 1 color: Color red].			(p2 notNil and:[p3 notNil])				ifTrue:[cc line: p2 to: p3 width: 1 color: Color red].			(p3 notNil and:[p1 notNil])				ifTrue:[cc line: p3 to: p1 width: 1 color: Color red].		].].true ifTrue:[		poly e1 fanVertices ifNotNil:[			center _ poly isJunction ifTrue:[poly center] ifFalse:[poly e1 center].			poly e1 fanVertices doWithIndex:[:pt :idx|				cc line: center to: pt width: 1 color: (colors atWrap: idx)]].		poly e2 fanVertices ifNotNil:[			center _ poly isJunction ifTrue:[poly center] ifFalse:[poly e2 center].			poly e2 fanVertices doWithIndex:[:pt :idx|				cc line: center to: pt width: 1 color: (colors atWrap: idx)]].		poly e3 fanVertices ifNotNil:[			center _ poly isJunction ifTrue:[poly center] ifFalse:[poly e3 center].			poly e3 fanVertices doWithIndex:[:pt :idx|				cc line: center to: pt width: 1 color: (colors atWrap: idx)]].].	].! !!PoohTestMorph methodsFor: 'drawing' stamp: 'ar 5/19/2001 17:51'!drawSubdivisionTrianglesOn: cc	| colors |true ifTrue:[^self].	subdivision ifNil:[^self].	colors _ #(red green blue yellow magenta cyan) collect:[:s| Color perform: s].	subdivision innerTriangles doWithIndex:[:f :idx|		cc drawPolygon: f 			color: (colors atWrap: idx) 			borderWidth: 0 borderColor: Color transparent].! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 18:07'!center	| pt1 pt2 pt3 l1 l2 l3 sum |	pt1 _ e1 center.	pt2 _ e2 center.	pt3 _ e3 center.	l1 _ e1 length.	l2 _ e2 length.	l3 _ e3 length.	sum _ l1 + l2 + l3.	^((pt1 * l1) + (pt2 * l2) + (pt3 * l3)) / sum	"^(p1 + p2 + p3) / 3.0"! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:45'!e1	^e1! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 22:08'!e1: edge1 e2: edge2 e3: edge3	flags _ 0.	e1 _ edge1.	e2 _ edge2.	e3 _ edge3.	e1 rightFace: self. e1 symmetric leftFace: self.	e2 rightFace: self. e2 symmetric leftFace: self.	e3 rightFace: self. e3 symmetric leftFace: self.! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:45'!e2	^e2! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:45'!e3	^e3! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 18:25'!flags	^flags! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 18:25'!flags: aNumber	flags _ aNumber! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:27'!next	^next! !!PoohTriangle methodsFor: 'accessing' stamp: 'ar 5/19/2001 17:28'!next: aTriangle	next _ aTriangle.! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:06'!isJunction	^flags anyMask: 2! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:06'!isJunction: aBool	flags _ aBool ifTrue:[flags bitOr: 2] ifFalse:[flags bitClear: 2].! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:05'!isSleeve	^flags anyMask: 4! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:05'!isSleeve: aBool	flags _ aBool ifTrue:[flags bitOr: 4] ifFalse:[flags bitClear: 4].! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:05'!isTerminal	^flags anyMask: 8! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:05'!isTerminal: aBool	flags _ aBool ifTrue:[flags bitOr: 8] ifFalse:[flags bitClear: 8].! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:14'!isValid	^(flags bitAnd: 1) = 0! !!PoohTriangle methodsFor: 'testing' stamp: 'ar 5/19/2001 22:14'!isValid: aBool	flags _ aBool ifFalse:[flags bitOr: 1] ifTrue:[flags bitClear: 1].! !!PoohTriangle methodsFor: 'spine' stamp: 'ar 5/24/2001 12:52'!buildTerminalFan	| firstEdge pt points lastEdge nextEdge inside |	self isTerminal ifFalse:[^self].	e1 isBorderEdge ifFalse:[firstEdge _ e1. pt _ e3 origin].	e2 isBorderEdge ifFalse:[firstEdge _ e2. pt _ e1 origin].	e3 isBorderEdge ifFalse:[firstEdge _ e3. pt _ e2 origin].	firstEdge ifNil:[^self].	points _ OrderedCollection new.	lastEdge _ firstEdge.	points add: lastEdge destination; add: pt; add: lastEdge origin.	nextEdge _  lastEdge leftFace oppositeSpineEdgeOf: lastEdge symmetric.	[lastEdge rightFace isValid: false.	nextEdge notNil and:[nextEdge fanVertices isNil]] whileTrue:[		nextEdge origin = points first ifTrue:[			points addLast: nextEdge destination		] ifFalse:[nextEdge origin = points last ifTrue:[			points addFirst: nextEdge destination.		] ifFalse:[nextEdge destination = points first ifTrue:[			points addLast: nextEdge origin.		] ifFalse:[nextEdge destination = points last ifTrue:[			points addFirst: nextEdge origin.		] ifFalse:[self error:'I am confused']]]].		inside _ nextEdge hasAllInsideCircle: points.		lastEdge _ nextEdge.		inside			ifTrue:[nextEdge _ lastEdge leftFace oppositeSpineEdgeOf: lastEdge symmetric]			ifFalse:[nextEdge _ nil].	].	lastEdge symmetric fanVertices: points.! !!PoohTriangle methodsFor: 'spine' stamp: 'ar 5/19/2001 21:58'!oppositeSpineEdgeOf: someEdge	self isSleeve ifFalse:[^nil].	someEdge == e1 ifTrue:[		(e2 leftFace notNil and:[e3 leftFace isNil]) ifTrue:[^e2].		(e3 leftFace notNil and:[e2 leftFace isNil]) ifTrue:[^e3].		^nil].	someEdge == e2 ifTrue:[		(e1 leftFace notNil and:[e3 leftFace isNil]) ifTrue:[^e1].		(e3 leftFace notNil and:[e1 leftFace isNil]) ifTrue:[^e3].		^nil].	someEdge == e3 ifTrue:[		(e1 leftFace notNil and:[e2 leftFace isNil]) ifTrue:[^e1].		(e2 leftFace notNil and:[e1 leftFace isNil]) ifTrue:[^e2].		^nil].	self error:'Edge not in receiver'! !!PoohTriangle methodsFor: 'spine' stamp: 'ar 5/19/2001 22:03'!recomputeType	| count |	count _ 0.	e1 isBorderEdge ifTrue:[count _ count + 1].	e2 isBorderEdge ifTrue:[count _ count + 1].	e3 isBorderEdge ifTrue:[count _ count + 1].	self isJunction: (count = 0).	self isSleeve: (count = 1).	self isTerminal: (count = 2).! !!PoohTriangle methodsFor: 'enumeration' stamp: 'ar 5/19/2001 17:29'!do: aBlock	| tmp |	tmp _ self.	[tmp == nil] whileFalse:[		aBlock value: tmp.		tmp _ tmp next].! !!PoohTriangle methodsFor: 'enumeration' stamp: 'ar 5/19/2001 22:13'!validFacesDo: aBlock	| tmp |	tmp _ self.	[tmp == nil] whileFalse:[		tmp isValid ifTrue:[aBlock value: tmp].		tmp _ tmp next].! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/19/2001 23:45'!elevateConnect: vtxList1 with: vtxList2 into: aStream	1 to: vtxList1 size-1 do:[:i|		aStream nextPut: (B3DSimpleMeshFace			with: (vtxList1 at: i)			with: (vtxList1 at: i+1)			with: (vtxList2 at: i+1)			with: (vtxList2 at: i))].! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 14:10'!elevateFan: vertices to: elevationVertex steps: nSteps	"Elevate the given edge of a junction"	| lastVtx nextVtx faces |	faces _ WriteStream on: #().	lastVtx _ nextVtx _ nil.	vertices reverseDo:[:pt|		nextVtx _ self elevateFrom: (pt@0) to: elevationVertex steps: nSteps.		lastVtx ifNotNil:[self elevateConnect: lastVtx with: nextVtx into: faces].		lastVtx _ nextVtx.	].	^faces contents! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 19:20'!elevateFrom: baseVertex to: elevationVertex steps: nSteps	| centerVertex nrm rot vtxList vtx vertex zScale dirVtx |	centerVertex _ elevationVertex x @ elevationVertex y @ 0.	dirVtx _ baseVertex - centerVertex.	zScale _ elevationVertex z / dirVtx length.	zScale _ B3DMatrix4x4 withScale: 1@1@zScale.	nrm _ dirVtx y @ dirVtx x negated @ 0.	vtxList _ Array new: nSteps+1.	0 to: nSteps do:[:i|		i = 0 ifTrue:[			vtx _ baseVertex.		] ifFalse:[i = nSteps ifTrue:[			vtx _ elevationVertex.		] ifFalse:[			rot _ (B3DRotation angle: 90.0 * i / nSteps axis: nrm) asMatrix4x4					composedWithGlobal: zScale.			vtx _ rot localPointToGlobal: dirVtx.			vtx _ vtx + centerVertex.		]].		vertex _ B3DSimpleMeshVertex new.		vertex position: vtx.		vertex normal: B3DVector3 new.		"vertex normal: (vtx - centerVertex) normalized."		vtxList at: i+1 put: vertex].	^vtxList! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 14:06'!elevateJunction: nSteps	| height faces |	self isJunction ifFalse:[^#()].	height _ self elevationHeight.	faces _ WriteStream on: #().	faces nextPutAll: (self elevateJunctionEdge: e1 height: height steps: nSteps).	faces nextPutAll: (self elevateJunctionEdge: e2 height: height steps: nSteps).	faces nextPutAll: (self elevateJunctionEdge: e3 height: height steps: nSteps).	^faces contents! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 14:07'!elevateJunctionEdge: anEdge height: height steps: nSteps	"Elevate the given edge of a junction"	| faceVertex faces edgeVertex vtxList1 vtxList2 |	faceVertex _ self center @ height.	anEdge fanVertices ifNotNil:[		"Connect the fan vertices with self center"		^self elevateFan: anEdge fanVertices to: faceVertex steps: nSteps].	"Connect 		(anEdge origin, anEdge center, self center)		(self center, anEdge center, anEdge destination)"	faces _ WriteStream on: #().	edgeVertex _ anEdge center @ anEdge elevationHeight.	vtxList1 _ self elevateFrom: anEdge origin @ 0 to: edgeVertex steps: nSteps.	vtxList2 _ self elevateFrom: anEdge origin @ 0 to: faceVertex steps: nSteps.	self elevateConnect: vtxList1 with: vtxList2 into: faces.	vtxList1 _ self elevateFrom: anEdge destination @ 0 to: faceVertex steps: nSteps.	vtxList2 _ self elevateFrom: anEdge destination @ 0 to: edgeVertex steps: nSteps.	self elevateConnect: vtxList1 with: vtxList2 into: faces.	^faces contents! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 14:06'!elevateSleeve: nSteps	| lastEdge nextEdge faces lastEdgeVertex nextEdgeVertex vtxList1 vtxList2 |	self isSleeve ifFalse:[^#()].	faces _ WriteStream on: #().	e1 isBorderEdge ifTrue:[lastEdge _ e2. nextEdge _ e3].	e2 isBorderEdge ifTrue:[lastEdge _ e3. nextEdge _ e1].	e3 isBorderEdge ifTrue:[lastEdge _ e1. nextEdge _ e2].	lastEdgeVertex _ lastEdge center @ lastEdge elevationHeight.	nextEdgeVertex _ nextEdge center @ nextEdge elevationHeight.	"Elevate fan vertices, if any"	lastEdge fanVertices ifNotNil:[		faces nextPutAll: (self elevateFan: lastEdge fanVertices to: lastEdgeVertex steps: nSteps)].	nextEdge fanVertices ifNotNil:[		faces nextPutAll: (self elevateFan: nextEdge fanVertices to: nextEdgeVertex steps: nSteps)].	"Connect edges"	vtxList1 _ self elevateFrom: lastEdge origin @ 0 to: lastEdgeVertex steps: nSteps.	vtxList2 _ self elevateFrom: nextEdge destination @ 0to: nextEdgeVertex steps: nSteps.	self elevateConnect: vtxList1 with: vtxList2 into: faces.	vtxList1 _ self elevateFrom: nextEdge origin @ 0 to: nextEdgeVertex steps: nSteps.	vtxList2 _ self elevateFrom: lastEdge destination @ 0 to: lastEdgeVertex steps: nSteps.	self elevateConnect: vtxList1 with: vtxList2 into: faces.	^faces contents! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 14:05'!elevateSpine: nSteps	"Elevate the receiver's spine"	self isValid ifFalse:[^#()].	self isJunction 		ifTrue:[^self elevateJunction: nSteps].	self isTerminal		ifTrue:[^self elevateTerminal: nSteps].	self isSleeve		ifTrue:[^self elevateSleeve: nSteps].	^#()! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/22/2001 14:06'!elevateTerminal: nSteps	self error:'All terminal triangles should have been removed'.! !!PoohTriangle methodsFor: 'elevation' stamp: 'ar 5/20/2001 01:06'!elevationHeight	"Compute the elevation height of the receiver"	| center sum count |	center _ self center.	sum _ (center dist: e1 origin) + (center dist: e2 origin) + (center dist: e3 origin).	count _ 3.true ifTrue:[^sum / count].	e1 fanVertices ifNotNilDo:[:vtx|		vtx do:[:v| sum _ sum + (v dist: center)].		count _ count + vtx size].	e2 fanVertices ifNotNilDo:[:vtx|		vtx do:[:v| sum _ sum + (v dist: center)].		count _ count + vtx size].	e3 fanVertices ifNotNilDo:[:vtx|		vtx do:[:v| sum _ sum + (v dist: center)].		count _ count + vtx size].	^sum / count asFloat! !!WonderlandActor methodsFor: 'accessing' stamp: 'ar 5/23/2001 23:26'!getBoundingBox	"Returns the actor's bounding box"	| size x y z nOrigin nCorner childBBox cOrigin cCorner meshBBox mOrigin mCorner |	(myMesh notNil)		ifTrue: [ meshBBox _ myMesh boundingBox.true ifTrue:[				cOrigin _ scaleMatrix localPointToGlobal: meshBBox origin.				cCorner _ scaleMatrix localPointToGlobal: meshBBox corner.				nOrigin _ cOrigin min: cCorner.				nCorner _ cOrigin max: cCorner.] ifFalse:[				 size _ self getSizeVector.				 mOrigin _ meshBBox origin.				 mCorner _ meshBBox corner.				 x _ (mOrigin x) * (size x).				 y _ (mOrigin y) * (size y).				 z _ (mOrigin z) * (size z).				 nOrigin _ B3DVector3 x: x y: y z: z.				 x _ (mCorner x) * (size x).				 y _ (mCorner y) * (size y).				 z _ (mCorner z) * (size z).				 nCorner _ B3DVector3 x: x y: y z: z.].				]		ifFalse: [ nOrigin _ (B3DVector3 x:0 y:0 z:0).				  nCorner _ (B3DVector3 x:0 y:0 z:0) ].	myChildren do: [:child | 			(child isPart) ifTrue: [									childBBox _ child getBoundingBox: self.				 					cOrigin _ childBBox origin.				 					cCorner _ childBBox corner.									nOrigin _ nOrigin min: cOrigin.									nCorner _ nCorner max: cCorner.								 ].					].	^ Rectangle origin: nOrigin corner: nCorner.! !!WonderlandActor methodsFor: 'private' stamp: 'ar 5/23/2001 00:10'!getScaleMatrix	^scaleMatrix! !!WonderlandActor methodsFor: 'private' stamp: 'ar 5/23/2001 23:28'!scaleByVector: aVector	"Scale the object by the given vector."	| aMatrix |	aMatrix _ B3DMatrix4x4 identity.	"Scale my matrix"	aMatrix scalingX: (aVector x) y: (aVector y) z: (aVector z).	scaleMatrix _ aMatrix composeWith: scaleMatrix.	"Now scale my parts"	myChildren do: [:child | (child isPart) ifTrue: [								child setPositionVector: (child getPositionVector) * aVector.								child scaleByVector: aVector												].					].! !!WonderlandCameraMorph methodsFor: 'accessing' stamp: 'ar 5/22/2001 13:20'!outline	^ outline ifNil:[outline _ ReadWriteStream on: #()]! !!WonderlandCameraMorph methodsFor: 'accessing' stamp: 'ar 5/22/2001 13:20'!outline: pointList	outline _ pointList! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/22/2001 20:50'!drawAcceleratedOn: aCanvas	| myRect |	myRect _ (self bounds: bounds in: nil) intersect: (0@0 extent: DisplayScreen actualScreenSize).	(myRenderer notNil and:[myRenderer isAccelerated]) ifFalse:[		myRenderer ifNotNil:[myRenderer destroy].		myRenderer _ nil.	].	myRenderer ifNotNil:[		myRenderer _ myRenderer bufferRect: myRect.	].	myRenderer ifNil:[		myRenderer _ B3DHardwareEngine newIn: myRect.		myRenderer ifNil:[^self drawSimulatedOn: aCanvas].	] ifNotNil:[		myRenderer reset.	].	myRenderer viewportOffset: aCanvas origin.	myRenderer clipRect: aCanvas clipRect.	myCamera drawSceneBackground ifFalse:[		myRenderer restoreMorphicBackground: myRect under: self.	].	self renderOn: myRenderer.	outline ifNotNil:[		self drawAcceleratedOutlineOn: myRenderer.	].	myRenderer restoreMorphicForeground: myRect above: self.	Display addExtraRegion: myRect for: self.! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/22/2001 23:30'!drawAcceleratedOutlineOn: aRenderer	"Draw a pooh outline on an accelerated renderer."	| vtxList scale out pt vtx offset z |	"NOTE: The test below captures two distinct cases.		#1: The software renderer (which does not support lines)		#2: The D3D renderer (which does not support line attributes)."	myRenderer hasFrameBufferAccess ifTrue:[		^myRenderer provideOverlayCanvasDuring:[:cc| self sketchOn: cc].	].	z _ 0.5.	vtxList _ self outline contents.	vtxList size < 2 ifTrue:[^self].	out _ WriteStream on: (B3DVector3Array new: vtxList size * 2).	out nextPut: vtxList first @ z.	2 to: vtxList size-1 do:[:i|		pt _ vtxList at: i.		vtx _ B3DVector3 x: pt x y: pt y z: z.		out nextPut: vtx; nextPut: vtx].	out nextPut: vtxList last @ z.	out _ out contents.	offset _ bounds origin + bounds corner * 0.5 @ 0.	scale _ (2.0 / bounds extent x) @ (-2.0 / bounds extent y) @ 1.	myRenderer reset. "get rid of everything"	myRenderer material: (B3DMaterial new emission: Color red).	myRenderer scaleBy: scale.	myRenderer translateBy: offset negated.	myRenderer lineWidth: 5.	myRenderer drawLines: out normals: nil colors: nil texCoords: nil.! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/22/2001 13:21'!drawSimulatedOn: aCanvas	"Draw the receiver using the builtin software renderer"	(myRenderer notNil and:[myRenderer isOverlayRenderer]) ifTrue:[		"Dump it. We may just being dragged around by the hand."		myRenderer destroy.		myRenderer _ nil].	aCanvas asBalloonCanvas render: self.	outline ifNotNil:[self sketchOn: aCanvas].! !!WonderlandCameraMorph methodsFor: 'drawing' stamp: 'ar 5/22/2001 13:23'!sketchOn: aCanvas	| vtx prev next |	vtx _ self outline.	vtx reset.	vtx atEnd ifTrue:[^self].	prev _ vtx next.	[vtx atEnd] whileFalse: [		next _ vtx next.		aCanvas line: prev to: next width: 5 color: Color red.		prev _ next]! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 5/24/2001 13:50'!mouseDown: evt 	"When the user clicks in a camera window, determine which actor the    	         user clicked on and have that actor respond to the event"	| newEvent reactions |	mode == #stroke ifTrue:[^self recordStroke: evt cursorPoint].	firstPersonControls == true ifTrue:[		myControls setCenter: evt position.		myControls mouseDown: evt.		evt hand needsToBeDrawn ifFalse:[Cursor crossHair show].		^self	].	newEvent _ self convertEvent: evt.	newEvent ifNil:[^self].	mode == #paint ifTrue:[		newEvent getVertex ifNil:[^self].		evt commandKeyPressed ifTrue:[^self].		self prepareAction: newEvent.		^self perform: palette action with: newEvent].	newEvent getActor hasActiveTexture		ifTrue: [^ newEvent getActor morphicMouseDown: newEvent].	evt redButtonPressed ifTrue:[		reactions _ newEvent getActor getReactionsTo: leftMouseDown.		mouseUpButton _ leftMouseUp.	] ifFalse: [evt yellowButtonPressed ifTrue:[ 		reactions _ newEvent getActor getReactionsTo: rightMouseDown.		mouseUpButton _ rightMouseUp.	] ifFalse: [reactions _ nil]].	reactions ifNotNil: [reactions do: [:aReaction | aReaction reactTo: newEvent]].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 5/24/2001 13:50'!mouseMove: evt 	"When the user clicks in a camera window, determine which actor the    	    user clicked on and have that actor respond to the event"	| newEvent reactions |	mode == #stroke ifTrue: [^self recordStroke: evt cursorPoint].	firstPersonControls == true ifTrue:[^self].	newEvent _ self convertEvent: evt.	newEvent ifNil:[^self].	mode = #paint ifTrue:[		newEvent getVertex ifNil:[^self].		evt commandKeyPressed ifTrue:[^self].		newEvent getActor = currentActor ifFalse:[^self].		self prepareAction: newEvent.		^self perform: palette action with: newEvent].	newEvent getActor hasActiveTexture		ifTrue: [^ newEvent getActor morphicMouseMove: newEvent].	reactions _ newEvent getActor getReactionsTo: mouseMove.	reactions ifNotNil: [reactions do: [:aReaction | aReaction reactTo: newEvent]].! !!WonderlandCameraMorph methodsFor: 'event handling' stamp: 'ar 5/24/2001 13:50'!mouseUp: evt 	"When the user clicks in a camera window, determine which actor the    	user clicked on and have that actor respond to the event"	| newEvent reactions |	self mode == #stroke ifTrue: [^self createPoohActor].	firstPersonControls == true ifTrue:[		myControls mouseUp: evt.		myControls setCenter: nil.		evt hand needsToBeDrawn ifFalse:[Cursor normal show].		^self	].	newEvent _ self convertEvent: evt.	newEvent ifNil: [^ self].	mode == #paint ifTrue:[		newEvent getVertex ifNil:[^self].		self prepareAction: newEvent.		^ self perform: palette action with: newEvent].	newEvent getActor hasActiveTexture 		ifTrue: [^ newEvent getActor morphicMouseUp: newEvent].	reactions _ newEvent getActor getReactionsTo: mouseUpButton.	reactions ifNotNil: [reactions do: [:aReaction | aReaction reactTo: newEvent]]! !!WonderlandCameraMorph methodsFor: 'initialization' stamp: 'ar 5/22/2001 13:22'!initialize	super initialize.	lastCursorPoint _ 0 @ 0.	CurrentProjectRefactoring currentAddGuard: self.	"Teddy"	self mode: #view.	self outline: nil.! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/22/2001 13:21'!clearStroke	self outline: nil! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/24/2001 12:54'!createPoohActor	| actor pointList box scale center subdivision mesh |	pointList _ self outline.	pointList reset.	pointList _ pointList contents.	pointList size < 2 ifTrue:[		self clearStroke.		^errorSound play].	pointList _ self simplify: pointList.	pointList _ self smoothen: pointList length: 10.	pointList _ self regularize: pointList.	box _ Rectangle encompassing: pointList.	scale _ bounds extent y * 0.5.	scale _ 1.0 / (scale @ scale negated).	center _ box origin + box corner * 0.5.	pointList _ pointList collect:[:each|  each - center * scale].	subdivision _ PoohSubdivision constraintOutline: pointList.	mesh _ subdivision build3DObject.	mesh ifNil:[		errorSound play.	] ifNotNil:[		actor _ self getWonderland makeActorNamed: 'pooh'.		actor setProperty: #handmade toValue: true;			setBackfaceCulling: #ccw;			setMesh: mesh;			setColor: gray;			setTexturePointer: ((Form extent: 256@128 depth: Display depth) fillColor: Color white) asTexture.		actor setComposite: (myCamera getMatrixFromRoot composedWithLocal: (B3DMatrix4x4 withOffset: 0@0@2)).		actor scaleByMatrix: (B3DRotation axis: 0@1@0 angle: 90) asMatrix4x4.		actor rotateByMatrix: (B3DRotation axis: 0@1@0 angle:-90) asMatrix4x4.	].	self clearStroke.	self mode: nil.	Cursor normal show.! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/22/2001 18:25'!paintActor: anActor	self mode: #paint.	backup _ anActor getTexturePointer deepCopy.	palette _ self world paintBox.	palette position: self position + (self extent x @ 0); focusMorph: self.! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/22/2001 13:21'!recordStroke: p	self outline nextPut: p! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/23/2001 21:35'!regularize: pointCollection	"Make the pointList non-intersecting, e.g., insert points at intersections and have the outline include those points"	| pointList segments last intersections map pts |	pointList _ pointCollection collect:[:pt| pt asIntegerPoint].	segments _ WriteStream on: (Array new: pointList size).	last _ pointList last.	pointList do:[:next|		segments nextPut: (LineSegment from: last to: next).		last _ next.	].	segments _ segments contents.	intersections _ LineIntersections of: segments.	map _ IdentityDictionary new: segments size.	intersections do:[:is|		(map at: is second ifAbsentPut:[WriteStream on: (Array new: 2)]) nextPut: is first.		(map at: is third ifAbsentPut:[WriteStream on: (Array new: 2)]) nextPut: is first.	].	pts _ WriteStream on: (Array new: pointList size).	segments do:[:seg|		intersections _ (map at: seg) contents.		intersections _ intersections sort:			[:p1 :p2|  (p1 squaredDistanceTo: seg start) <= (p2 squaredDistanceTo: seg start)].		last _ intersections at: 1.		pts nextPut: last.		intersections do:[:next|			(next = last and:[next = seg end]) ifFalse:[				pts nextPut: next.				last _ next]].	].	^pts contents! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/22/2001 13:31'!simplify: pointList	| pts |	pts _ StrokeSimplifier new.	pointList do:[:aPoint| pts add: aPoint].	pts closeStroke.	^pts finalStroke.! !!WonderlandCameraMorph methodsFor: 'pooh' stamp: 'ar 5/22/2001 13:32'!smoothen: pointList length: unitLength	| prevPt curPt nextPt out prevMid nextMid segment length steps deltaT |	out _ WriteStream on: (Array new: pointList size).	prevPt _ pointList at: pointList size-1.	curPt _ pointList last.	prevMid _ (curPt + prevPt) * 0.5.	1 to: pointList size do:[:i|		nextPt _ pointList at: i.		nextMid _ (nextPt + curPt) * 0.5.		segment _ Bezier2Segment from: prevMid to: nextMid via: curPt.		length _ segment length.		steps _ (length / unitLength) asInteger.		steps < 1 ifTrue:[steps _ 1].		deltaT _ 1.0 / steps.		1 to: steps-1 do:[:k|			out nextPut: (segment valueAt: deltaT * k)].		out nextPut: nextMid.		prevPt _ curPt.		curPt _ nextPt.		prevMid _ nextMid.	].	^out contents! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 5/22/2001 18:24'!addHandlesTo: aHaloMorph box: box	| dismissHandle s |	s _ aHaloMorph handleSize.	myActor getTexturePointer == nil ifFalse:[		aHaloMorph addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #extractTexture: to: aHaloMorph target].	aHaloMorph addHandleAt: box topLeft color: Color red icon: 'Halo-Menu'		on: #mouseDown send: #doMenu:with: to: aHaloMorph.	aHaloMorph addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown icon: 'Halo-Tile'		on: #mouseDown send: #yourself "#tearOffTile" to: self.	dismissHandle _ aHaloMorph addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color red muchLighter icon: 'Halo-Dismiss'		on: #mouseDown send: #mouseDownInDimissHandle:with: to: aHaloMorph.	dismissHandle on: #mouseUp send: #maybeDismiss:with: to: aHaloMorph.	dismissHandle on: #mouseDown send: #setDismissColor:with: to: aHaloMorph.	dismissHandle on: #mouseMove send: #setDismissColor:with: to: aHaloMorph.	aHaloMorph addHandleAt: box leftCenter color: Color cyan icon: 'Halo-View'		on: #mouseDown send: #openViewerForArgument to: self.	aHaloMorph addHandleAt: box topCenter color: Color black icon: 'Halo-Grab'		on: #mouseDown send: #grabFromHalo:with: to: self.	(aHaloMorph addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown icon: 'Halo-Drag'		on: #mouseDown send: #dragStartFromHalo:with: to: self)		on: #mouseMove send: #dragMoveFromHalo:with: to: self;		on: #mouseUp send: #dragEndFromHalo:with: to: self.	(aHaloMorph addHandleAt: box topRight color: Color green icon: 'Halo-Dup'		on: #mouseDown send: #dupStartFromHalo:with: to: self)		on: #mouseMove send: #dupMoveFromHalo:with: to: self;		on: #mouseUp send: #dupEndFromHalo:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[aHaloMorph addHandleAt: ((box topRight + box rightCenter) // 2)			color: Color blue veryMuchLighter icon: 'Halo-Debug'			on: #mouseDown send: #doDebug:with: to: aHaloMorph].	(aHaloMorph addHandleAt: box bottomLeft color: Color blue icon: 'Halo-Rotate'		on: #mouseDown send: #rotateStartFromHalo:with: to: self)		on: #mouseMove send: #rotateMoveFromHalo:with: to: self;		on: #mouseUp send: #rotateEndFromHalo:with: to: self.	(aHaloMorph addHandleAt: box bottomRight color: Color yellow icon: 'Halo-Scale'		on: #mouseDown send: #growStartFromHalo:with: to: self)		on: #mouseMove send: #growMoveFromHalo:with: to: self;		on: #mouseUp send: #growEndFromHalo:with: to: self.	myActor isHandmade		ifTrue: [			(aHaloMorph addHandleAt: box center color: Color white icon: 'Halo-Paint'				on: #mouseUp send: #paintTexture to: self)]! !!WonderlandWrapperMorph methodsFor: 'handles' stamp: 'ar 5/22/2001 18:24'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(rotateStartFromHalo:with:				'Rotate')		(growStartFromHalo:with:				'Change size') 		(dupStartFromHalo:with:					'Duplicate')		(grabFromHalo:with:						'Pick up')		(dragStartFromHalo:with:				'Move')		(extractTexture:							'Extract texture')		(paintTexture							'Paint on surface')	) do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^super balloonHelpTextForHandle: aHandle! !!WonderlandWrapperMorph methodsFor: 'menu' stamp: 'ar 5/22/2001 18:24'!paintTexture	self getCameraMorph paintActor: myActor.! !WonderlandCameraMorph removeSelector: #paintMode!WonderlandCameraMorph removeSelector: #paintModeFor:!PoohTestMorph removeSelector: #markedOutline:!PoohTestMorph removeSelector: #normalize:to:!PoohTestMorph removeSelector: #outline:!PoohTestMorph removeSelector: #points:!"Postscript:Dump any stuff in old wonderlands"WonderlandCameraMorph allSubInstancesDo:[:m| m outline: nil].!