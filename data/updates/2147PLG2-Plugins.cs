'From Squeak2.8alpha of 6 February 2000 [latest update: #2098] on 13 May 2000 at 5:56:55 pm'!"Change Set:		PLG2-PluginsDate:			13 May 2000Author:			Tim Rowledge & Andreas RaabPluginisation pass 2: Defines a zillion of new plugins and fixes some of the older ones to use appropriated names (that is names beginning with 'primitive')."!TestInterpreterPlugin subclass: #AsynchFilePlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!AsynchFilePlugin commentStamp: '<historical>' prior: 0!Implements the asynchronous file primtives!InterpreterPlugin subclass: #BalloonEngineBase	instanceVariableNames: 'workBuffer objBuffer getBuffer aetBuffer spanBuffer engine formArray engineStopped geProfileTime dispatchedValue dispatchReturnValue objUsed doProfileStats loadBBFn copyBitsFn '	classVariableNames: 'EdgeInitTable EdgeStepTable FillTable WideLineFillTable WideLineWidthTable '	poolDictionaries: 'BalloonEngineConstants '	category: 'VMConstruction-Plugins'!InterpreterPlugin subclass: #BitBltSimulation	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight sourceBits sourcePitch sourcePixSize destBits destPitch destPixSize pixPerWord bitCount skew mask1 mask2 preload nWords destMask hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH srcWidth srcHeight destWidth destHeight halftoneHeight noSource noHalftone halftoneBase colorMap sourceAlpha cmBitsPerColor srcBitShift dstBitShift scanStart scanStop scanString scanRightX scanStopArray scanDisplayFlag scanXTable stopCode bitBltOop affectedL affectedR affectedT affectedB opTable maskTable ditherMatrix4x4 ditherThresholds16 ditherValues16 hasSurfaceLock warpSrcShift warpSrcMask warpAlignShift warpAlignMask warpBitShiftTable cmDeltaBits cmRedMask cmBlueMask cmGreenMask cmRedShift cmBlueShift cmGreenShift '	classVariableNames: 'AllOnes BBClipHeightIndex BBClipWidthIndex BBClipXIndex BBClipYIndex BBColorMapIndex BBDestFormIndex BBDestXIndex BBDestYIndex BBHalftoneFormIndex BBHeightIndex BBLastIndex BBRuleIndex BBSourceFormIndex BBSourceXIndex BBSourceYIndex BBWarpBase BBWidthIndex BBXTableIndex BinaryPoint CrossedX EndOfRun FixedPt1 FormBitsIndex FormDepthIndex FormHeightIndex FormWidthIndex OpTable OpTableSize '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!InterpreterPlugin subclass: #FilePlugin	instanceVariableNames: ''	classVariableNames: 'DirBadPath DirEntryFound DirNoMoreEntries '	poolDictionaries: ''	category: 'Squeak-Plugins'!FilePlugin subclass: #FilePluginSimulator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!TestInterpreterPlugin subclass: #JoystickTabletPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!JoystickTabletPlugin commentStamp: '<historical>' prior: 0!This plugin implements the interface to the joystick and tablet input devices, if you have one.!TestInterpreterPlugin subclass: #MIDIPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!TestInterpreterPlugin subclass: #SerialPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!SerialPlugin commentStamp: '<historical>' prior: 0!Implement the serial port primitives.!TestInterpreterPlugin subclass: #SocketPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!SocketPlugin commentStamp: '<historical>' prior: 0!Implement the socket and resolver primitives.I really think it wouldbe worth a minor rewrite to avoid the sq{plat}Socket.c files refering directly back t the VM -- TPR !TestInterpreterPlugin subclass: #SoundPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Plugins'!!SoundPlugin commentStamp: '<historical>' prior: 0!Implements the main sound related primiives. NB: I really think it would be a good cleanup to mildly rewrite the sq{plat}Sound.c files to NOT refer directly back to the VM -- TPR.!!AsynchFilePlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:52'!initialiseModule	"Initialise the module"	self export: true.	^self cCode: 'asyncFileInit()' inSmalltalk:[true]! !!AsynchFilePlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:54'!shutdownModule	"Initialise the module"	self export: true.	^self cCode: 'asyncFileShutdown()' inSmalltalk:[true]! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'TPR 2/7/2000 13:01'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	interpreterProxy success:		((interpreterProxy isIntegerObject: oop) not and:		 [(interpreterProxy isBytes: oop) and:		 [(interpreterProxy slotSizeOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	interpreterProxy failed ifTrue: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 17:08'!primitiveAsyncFileClose: fh 	| f |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileClose'		parameters: #(Oop ).	f _ self asyncFileValueOf: fh.	self asyncFileClose: f! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 17:10'!primitiveAsyncFileOpen: fileName forWrite: writeFlag semaIndex: semaIndex 	| fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileOpen'		parameters: #(String Boolean SmallInteger ).	fileNameSize _ interpreterProxy slotSizeOf: (fileName asOop: String).	fOop _ interpreterProxy instantiateClass: interpreterProxy classByteArray indexableSize: (self cCode: 'sizeof(AsyncFile)').	f _ self asyncFileValueOf: fOop.	interpreterProxy failed ifFalse: [self cCode: 'asyncFileOpen(f, (int)fileName, fileNameSize, writeFlag, semaIndex)'].	^ fOop! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 17:19'!primitiveAsyncFileReadResult: fhandle intoBuffer: buffer at: start count: num 	| bufferSize bufferPtr r f count startIndex |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileReadResult'		parameters: #(Oop Oop SmallInteger SmallInteger ).	f _ self asyncFileValueOf: fhandle.	count _ num.	startIndex _ start.	bufferSize _ interpreterProxy slotSizeOf: buffer. "in bytes or words"	(interpreterProxy isBytes: buffer)		ifTrue: ["covert word counts to byte counts"			count _ count * 4.			startIndex _ startIndex - 1 * 4 + 1.			bufferSize _ bufferSize * 4].	interpreterProxy success: (startIndex >= 1 and: [startIndex + count - 1 <= bufferSize]).	bufferPtr _ (self cCoerce: (interpreterProxy firstIndexableField: buffer)				to: 'int')				+ startIndex - 1. 	"adjust for zero-origin indexing"	interpreterProxy failed ifFalse: [r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	^ r asOop: SmallInteger! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'ar 5/13/2000 16:00'!primitiveAsyncFileReadStart: fHandle fPosition: fPosition count: count	| f |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileReadStart'		parameters: #(Oop SmallInteger SmallInteger).	f _ self asyncFileValueOf: fHandle.	self cCode: 'asyncFileReadStart(f, fPosition, count)'! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'TPR 2/7/2000 16:09'!primitiveAsyncFileWriteResult: fHandle	| f r |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileWriteResult'		parameters:#(Oop).	f _ self asyncFileValueOf: fHandle.	r _ self cCode:' asyncFileWriteResult(f)'.	^r asOop: SmallInteger! !!AsynchFilePlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 17:22'!primitiveAsyncFileWriteStart: fHandle fPosition: fPosition fromBuffer: buffer at: start count: num 	| f bufferSize bufferPtr count startIndex |	self var: #f declareC: 'AsyncFile *f'.	self primitive: 'primitiveAsyncFileWriteStart'		parameters: #(Oop SmallInteger Oop SmallInteger SmallInteger ).	f _ self asyncFileValueOf: fHandle.	interpreterProxy failed ifTrue: [^ nil].	count _ num.	startIndex _ start.	bufferSize _ interpreterProxy slotSizeOf: buffer.	"in bytes or words"	(interpreterProxy isBytes: buffer)		ifTrue: ["covert word counts to byte counts"			count _ count * 4.			startIndex _ startIndex - 1 * 4 + 1.			bufferSize _ bufferSize * 4].	interpreterProxy success: (startIndex >= 1 and: [startIndex + count - 1 <= bufferSize]).	bufferPtr _ (self cCoerce: (interpreterProxy firstIndexableField: buffer)				to: 'int')				+ startIndex - 1.	"adjust for zero-origin indexing"	interpreterProxy failed ifFalse: [self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)']! !!AsynchFilePlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:21'!headerFile^'/* Header file for AsynchFile plugin *//* module initialization/shutdown */int asyncFileInit(void);int asyncFileShutdown(void);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);'! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'ar 5/13/2000 02:02'!translateB3D	"B3DEnginePlugin translateB3D"	"Translate all the basic plugins into one support module 	and write the C sources for the rasterizer."	| cg |	cg _ PluggableCodeGenerator new initialize.	cg var: #moduleName declareC:'const char *moduleName = "', self moduleName,'"'.	{InterpreterPlugin. B3DEnginePlugin. B3DTransformerPlugin. B3DVertexBufferPlugin. B3DShaderPlugin. B3DClipperPlugin. B3DPickerPlugin. B3DRasterizerPlugin} do: 		[:theClass | 		theClass initialize.		cg addClass: theClass.		theClass declareCVarsIn: cg].	cg storeCodeOnFile: self moduleName , '.c' doInlining: true.	"	cg storeCodeOnFile: '/tmp/Ballon3D.c' doInlining: true."	B3DRasterizerPlugin writeSupportCode: true! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:08'!primitiveGetAALevel	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self aaLevelGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:10'!primitiveGetClipRect	| rectOop pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMinXGet yValue: self clipMinYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 0 ofObject: rectOop withValue: pointOop.	interpreterProxy pushRemappableOop: rectOop.	pointOop _ interpreterProxy makePointwithxValue: self clipMaxXGet yValue: self clipMaxYGet.	rectOop _ interpreterProxy popRemappableOop.	interpreterProxy storePointer: 1 ofObject: rectOop withValue: pointOop.	interpreterProxy pop: 2.	interpreterProxy push: rectOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:13'!primitiveGetCounts	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWCountInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWCountFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWCountNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWCountAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWCountNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWCountMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWCountDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWCountNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWCountChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:14'!primitiveGetDepth	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self currentZGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:10'!primitiveGetFailureReason	"Return the reason why the last operation failed."	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	"Note -- don't call loadEngineFrom here because this will override the stopReason with Zero"	(interpreterProxy isIntegerObject: engine) ifTrue:[^false].	(interpreterProxy isPointers: engine) ifFalse:[^false].	(interpreterProxy slotSizeOf: engine) < BEBalloonEngineSize ifTrue:[^false].	(self loadWorkBufferFrom: 		(interpreterProxy fetchPointer: BEWorkBufferIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.	interpreterProxy pushInteger: self stopReasonGet.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:11'!primitiveGetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy makePointwithxValue: self destOffsetXGet yValue: self destOffsetYGet.	interpreterProxy pop: 1.	interpreterProxy push: pointOop.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:07'!primitiveGetTimes	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 9		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWTimeInitializing).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWTimeFinishTest).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWTimeNextGETEntry).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWTimeAddAETEntry).	stats at: 4 put: (stats at: 4) + (workBuffer at: GWTimeNextFillEntry).	stats at: 5 put: (stats at: 5) + (workBuffer at: GWTimeMergeFill).	stats at: 6 put: (stats at: 6) + (workBuffer at: GWTimeDisplaySpan).	stats at: 7 put: (stats at: 7) + (workBuffer at: GWTimeNextAETEntry).	stats at: 8 put: (stats at: 8) + (workBuffer at: GWTimeChangeAETEntry).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:12'!primitiveNeedsFlush	| needFlush |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	needFlush _ self needsFlush.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: needFlush.! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:14'!primitiveNeedsFlushPut	| needFlush |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	needFlush _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	needFlush _ interpreterProxy booleanValueOf: needFlush.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	needFlush == true 		ifTrue:[self needsFlushPut: 1]		ifFalse:[self needsFlushPut: 0].	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:12'!primitiveSetAALevel	| level |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	level _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self setAALevel: level.	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leace rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:05'!primitiveSetClipRect	| rectOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	rectOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: rectOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: rectOop) < 2		ifTrue:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: (interpreterProxy fetchPointer: 0 ofObject: rectOop).	self loadPoint: self point2Get from: (interpreterProxy fetchPointer: 1 ofObject: rectOop).	interpreterProxy failed ifFalse:[		self clipMinXPut: (self point1Get at: 0).		self clipMinYPut: (self point1Get at: 1).		self clipMaxXPut: (self point2Get at: 0).		self clipMaxYPut: (self point2Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:11'!primitiveSetColorTransform	| transformOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	transformOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadColorTransformFrom: transformOop.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:06'!primitiveSetDepth	| depth |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	depth _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self currentZPut: depth.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:14'!primitiveSetEdgeTransform	| transformOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	transformOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadEdgeTransformFrom: transformOop.	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-access' stamp: 'ar 5/11/2000 23:13'!primitiveSetOffset	| pointOop |	self export: true.		self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	pointOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy fetchClassOf: pointOop) = interpreterProxy classPoint		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: pointOop.	interpreterProxy failed ifFalse:[		self destOffsetXPut: (self point1Get at: 0).		self destOffsetYPut: (self point1Get at: 1).		self storeEngineStateInto: engine.		interpreterProxy pop: 1. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:58'!primitiveAddActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForEdge)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self needAvailableSpace: 1) 		ifFalse:[^interpreterProxy primitiveFail].	(self edgeNumLinesOf: edge) > 0 ifTrue:[		self insertEdgeIntoAET: edge.	].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Back to adding edges from GET"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountAddAETEntry by: 1.		self incrementStat: GWTimeAddAETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:59'!primitiveChangedActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingChange)		ifFalse:[^interpreterProxy primitiveFail].	edge _ self loadEdgeStateFrom: edgeOop.	interpreterProxy failed ifTrue:[^nil].	(self edgeNumLinesOf: edge) = 0 		ifTrue:[	self removeFirstAETEntry]		ifFalse:[	self resortFirstAETEntry.				self aetStartPut: self aetStartGet + 1].	self statePut: GEStateUpdateEdges. "Back to updating edges"	self storeEngineStateInto: engine.	interpreterProxy pop: 1. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountChangeAETEntry by: 1.		self incrementStat: GWTimeChangeAETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:59'!primitiveDisplaySpanBuffer	"Note: Must load bitBlt and spanBuffer"	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateBlitBuffer)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[		self displaySpanBufferAt: self currentYGet.		self postDisplayAction.	].	self finishedProcessing ifFalse:[		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		self statePut: GEStateUpdateEdges].	self storeEngineStateInto: engine.	doProfileStats ifTrue:[		self incrementStat: GWCountDisplaySpan by: 1.		self incrementStat: GWTimeDisplaySpan by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:59'!primitiveInitializeProcessing	"Note: No need to load bitBlt but must load spanBuffer"	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked) 		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for clear operation"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	self initializeGETProcessing.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	self statePut: GEStateAddingFromGET. "Initialized"	interpreterProxy failed ifFalse:[self storeEngineStateInto: engine].	doProfileStats ifTrue:[		self incrementStat: GWCountInitializing by: 1.		self incrementStat: GWTimeInitializing by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:59'!primitiveMergeFillFrom	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop bitsOop value |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	bitsOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateWaitingForFill)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for merging the fill"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check bitmap"	(interpreterProxy fetchClassOf: bitsOop) = interpreterProxy classBitmap		ifFalse:[^interpreterProxy primitiveFail].	"Check fillOop"	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize		ifTrue:[^interpreterProxy primitiveFail].	"Check if this was the fill we have exported"	value _ interpreterProxy fetchInteger: FTIndexIndex ofObject: fillOop.	(self objectIndexOf: self lastExportedFillGet) = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMinXIndex ofObject: fillOop.	self lastExportedLeftXGet = value		ifFalse:[^interpreterProxy primitiveFail].	value _ interpreterProxy fetchInteger: FTMaxXIndex ofObject: fillOop.	self lastExportedRightXGet = value		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: bitsOop) < (self lastExportedRightXGet - self lastExportedLeftXGet)		ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	self fillBitmapSpan: (interpreterProxy firstIndexableField: bitsOop)		from: self lastExportedLeftXGet		to: self lastExportedRightXGet.	self statePut: GEStateScanningAET. "Back to scanning AET"	self storeEngineStateInto: engine.	interpreterProxy pop: 2. "Leave rcvr on stack"	doProfileStats ifTrue:[		self incrementStat: GWCountMergeFill by: 1.		self incrementStat: GWTimeMergeFill by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:59'!primitiveNextActiveEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUpdateEdges or: GEStateCompleted)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ false.	self stateGet = GEStateCompleted ifFalse:[		hasEdge _ self findNextExternalUpdateFromAET.		hasEdge ifTrue:[			edge _ aetBuffer at: self aetStartGet.			self storeEdgeStateFrom: edge into: edgeOop.			"Do not advance to the next aet entry yet"			"self aetStartPut: self aetStartGet + 1."			self statePut: GEStateWaitingChange. "Wait for changed edge"		] ifFalse:[self statePut: GEStateAddingFromGET]. "Start over"	].	interpreterProxy failed ifTrue:[^nil].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	doProfileStats ifTrue:[		self incrementStat: GWCountNextAETEntry by: 1.		self incrementStat: GWTimeNextAETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 14:59'!primitiveNextFillEntry	"Note: No need to load bitBlt but must load spanBuffer"	| fillOop hasFill |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateScanningAET)		ifFalse:[^interpreterProxy primitiveFail].	"Load span buffer for internal handling of fills"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^interpreterProxy primitiveFail].	"Check if we have to clear the span buffer before proceeding"	(self clearSpanBufferGet = 0) ifFalse:[		(self currentYGet bitAnd: self aaScanMaskGet) = 0			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0].	hasFill _ self findNextExternalFillFromAET.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	hasFill ifTrue:[self storeFillStateInto: fillOop].	interpreterProxy failed ifFalse:[		hasFill			ifTrue:[	self statePut: GEStateWaitingForFill]			ifFalse:[	self wbStackClear.					self spanEndAAPut: 0.					self statePut: GEStateBlitBuffer].		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushBool: hasFill not.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].	].! !!BalloonEngineBase methodsFor: 'primitives-incremental' stamp: 'ar 5/13/2000 15:00'!primitiveNextGlobalEdgeEntry	"Note: No need to load either bitBlt or spanBuffer"	| edgeOop hasEdge edge |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	edgeOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateAddingFromGET)		ifFalse:[^interpreterProxy primitiveFail].	hasEdge _ self findNextExternalEntryFromGET.	hasEdge ifTrue:[		edge _ getBuffer at: self getStartGet.		self storeEdgeStateFrom: edge into: edgeOop.		self getStartPut: self getStartGet + 1].	interpreterProxy failed ifTrue:[^nil].	hasEdge		ifTrue:[	self statePut: GEStateWaitingForEdge] "Wait for adding edges"		ifFalse:[ "Start scanning the AET"				self statePut: GEStateScanningAET.				self clearSpanBufferPut: 1. "Clear span buffer at next entry"				self aetStartPut: 0.				self wbStackClear].	self storeEngineStateInto: engine.	interpreterProxy pop: 2.	interpreterProxy pushBool: hasEdge not.	doProfileStats ifTrue:[		self incrementStat: GWCountNextGETEntry by: 1.		self incrementStat: GWTimeNextGETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 5/12/2000 16:40'!loadRenderingState	"Load the entire state from the interpreter for the rendering primitives"	| edgeOop fillOop state |	self inline: false.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	fillOop _ interpreterProxy stackObjectValue: 0.	edgeOop _ interpreterProxy stackObjectValue: 1.	engine _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^false].	(self quickLoadEngineFrom: engine)		ifFalse:[^false].	"Load span buffer and bitBlt"	(self loadSpanBufferFrom:		(interpreterProxy fetchPointer: BESpanIndex ofObject: engine))			ifFalse:[^false].	(self loadBitBltFrom: 		(interpreterProxy fetchPointer: BEBitBltIndex ofObject: engine))			ifFalse:[^false].	(self loadFormsFrom:		(interpreterProxy fetchPointer: BEFormsIndex ofObject: engine))			ifFalse:[^false].	"Check edgeOop and fillOop"	(interpreterProxy slotSizeOf: edgeOop) < ETBalloonEdgeDataSize 		ifTrue:[^false].	(interpreterProxy slotSizeOf: fillOop) < FTBalloonFillDataSize 		ifTrue:[^false].	"Note: Rendering can only take place if we're not in one of the intermediate	(e.g., external) states."	state _ self stateGet.	(state = GEStateWaitingForEdge or:[		state = GEStateWaitingForFill or:[			state = GEStateWaitingChange]]) ifTrue:[^false].	^true! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 5/11/2000 23:08'!primitiveRenderImage	"Start/Proceed rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish this scan line"	engineStopped ifTrue:[^self storeRenderingState].	self proceedRenderingImage. "And go on as usual"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 5/11/2000 23:07'!primitiveRenderScanline	"Start rendering the entire image"	self export: true.	self inline: false.	self loadRenderingState ifFalse:[^interpreterProxy primitiveFail].	self proceedRenderingScanline. "Finish the current scan line"	self storeRenderingState.! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 5/13/2000 15:00'!proceedRenderingImage	"This is the main rendering entry"	| external |	self inline: false.	[self finishedProcessing] whileFalse:[		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		external _ self findNextExternalEntryFromGET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextGETEntry by: 1.			self incrementStat: GWTimeNextGETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		self wbStackClear.		self spanEndAAPut: 0.		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		doProfileStats ifTrue:[			self incrementStat: GWCountDisplaySpan by: 1.			self incrementStat: GWTimeDisplaySpan by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		external _ self findNextExternalUpdateFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextAETEntry by: 1.			self incrementStat: GWTimeNextAETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].	].! !!BalloonEngineBase methodsFor: 'primitives-rendering' stamp: 'ar 5/13/2000 15:00'!proceedRenderingScanline	"Proceed rendering the current scan line.	This method may be called after some Smalltalk code has been executed inbetween."	"This is the main rendering entry"	| external state |	self inline: false.	state _ self stateGet.	state = GEStateUnlocked ifTrue:[		self initializeGETProcessing.		engineStopped ifTrue:[^0].		state _ GEStateAddingFromGET.	]. 	state = GEStateAddingFromGET ifTrue:[		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		external _ self findNextExternalEntryFromGET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextGETEntry by: 1.			self incrementStat: GWTimeNextGETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateAddingFromGET].		external ifTrue:[			self statePut: GEStateWaitingForEdge.			^self stopBecauseOf: GErrorGETEntry.		]. 		self aetStartPut: 0.		self wbStackClear.		self clearSpanBufferPut: 1.		state _ GEStateScanningAET.	].	state = GEStateScanningAET ifTrue:[		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		(self clearSpanBufferGet ~= 0 and:[(self currentYGet bitAnd: self aaScanMaskGet) = 0])			ifTrue:[self clearSpanBuffer].		self clearSpanBufferPut: 0.		external _ self findNextExternalFillFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextFillEntry by: 1.			self incrementStat: GWTimeNextFillEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateScanningAET].		external ifTrue:[			self statePut: GEStateWaitingForFill.			^self stopBecauseOf: GErrorFillEntry.		].		state _ GEStateBlitBuffer.		self wbStackClear.		self spanEndAAPut: 0.	].	state = GEStateBlitBuffer ifTrue:[		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		(self currentYGet bitAnd: self aaScanMaskGet) = self aaScanMaskGet ifTrue:[			self displaySpanBufferAt: self currentYGet.			self postDisplayAction.		].		doProfileStats ifTrue:[			self incrementStat: GWCountDisplaySpan by: 1.			self incrementStat: GWTimeDisplaySpan by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateBlitBuffer].		self finishedProcessing ifTrue:[^0].		state _ GEStateUpdateEdges.		self aetStartPut: 0.		self currentYPut: self currentYGet + 1.	].	state = GEStateUpdateEdges ifTrue:[		doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].		external _ self findNextExternalUpdateFromAET.		doProfileStats ifTrue:[			self incrementStat: GWCountNextAETEntry by: 1.			self incrementStat: GWTimeNextAETEntry by: (interpreterProxy ioMicroMSecs - geProfileTime)].		engineStopped ifTrue:[^self statePut: GEStateUpdateEdges].		external ifTrue:[			self statePut: GEStateWaitingChange.			^self stopBecauseOf: GErrorAETEntry.		].		self statePut: GEStateAddingFromGET.	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/11/2000 23:06'!primitiveAbortProcessing	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	self statePut: GEStateCompleted.	self storeEngineStateInto: engine.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/11/2000 23:12'!primitiveCopyBuffer	| buf1 buf2 diff src dst |	self export: true.	self inline: false.	self var: #src declareC:'int * src'.	self var: #dst declareC:'int * dst'.	interpreterProxy methodArgumentCount = 2		ifFalse:[^interpreterProxy primitiveFail].	buf2 _ interpreterProxy stackObjectValue: 0.	buf1 _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	"Make sure the old buffer is properly initialized"	(self loadWorkBufferFrom: buf1) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the buffers are of the same type"	(interpreterProxy fetchClassOf: buf1) = (interpreterProxy fetchClassOf: buf2)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure buf2 is at least of the size of buf1"	diff _ (interpreterProxy slotSizeOf: buf2) - (interpreterProxy slotSizeOf: buf1).	diff < 0 ifTrue:[^interpreterProxy primitiveFail].	"Okay - ready for copying. First of all just copy the contents up to wbTop"	src _ workBuffer.	dst _ interpreterProxy firstIndexableField: buf2.	0 to: self wbTopGet-1 do:[:i|		dst at: i put: (src at: i).	].	"Adjust wbSize and wbTop in the new buffer"	dst at: GWBufferTop put: self wbTopGet + diff.	dst at: GWSize put: self wbSizeGet + diff.	"Now copy the entries from wbTop to wbSize"	src _ src + self wbTopGet.	dst _ dst + self wbTopGet + diff.	0 to: (self wbSizeGet - self wbTopGet - 1) do:[:i|		dst at: i put: (src at: i).	].	"Okay, done. Check the new buffer by loading the state from it"	(self loadWorkBufferFrom: buf2) 		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 2. "Leave rcvr on stack"! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/11/2000 23:05'!primitiveDoProfileStats	"Turn on/off profiling. Return the old value of the flag."	| oldValue newValue |	self inline: false.	self export: true.	oldValue _ doProfileStats.	newValue _ interpreterProxy stackObjectValue: 0.	newValue _ interpreterProxy booleanValueOf: newValue.	interpreterProxy failed ifFalse:[		doProfileStats _ newValue.		interpreterProxy pop: 2. "Pop rcvr, arg"		interpreterProxy pushBool: oldValue.	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/13/2000 14:59'!primitiveFinishedProcessing	| finished |	self export: true.	self inline: false.	doProfileStats ifTrue:[geProfileTime _ interpreterProxy ioMicroMSecs].	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	engine _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	finished _ self finishedProcessing.	self storeEngineStateInto: engine.	interpreterProxy pop: 1.	interpreterProxy pushBool: finished.	doProfileStats ifTrue:[		self incrementStat: GWCountFinishTest by: 1.		self incrementStat: GWTimeFinishTest by: (interpreterProxy ioMicroMSecs - geProfileTime)].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/11/2000 23:09'!primitiveInitializeBuffer	| wbOop size |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	wbOop _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy isWords: wbOop) 		ifFalse:[^interpreterProxy primitiveFail].	(size _ interpreterProxy slotSizeOf: wbOop) < GWMinimalSize		ifTrue:[^interpreterProxy primitiveFail].	workBuffer _ interpreterProxy firstIndexableField: wbOop.	objBuffer _ workBuffer + GWHeaderSize.	self magicNumberPut: GWMagicNumber.	self wbSizePut: size.	self wbTopPut: size.	self statePut: GEStateUnlocked.	self objStartPut: GWHeaderSize.	self objUsedPut: 4.	"Dummy fill object"	self objectTypeOf: 0 put: GEPrimitiveFill.	self objectLengthOf: 0 put: 4.	self objectIndexOf: 0 put: 0.	self getStartPut: 0.	self getUsedPut: 0.	self aetStartPut: 0.	self aetUsedPut: 0.	self stopReasonPut: 0.	self needsFlushPut: 0.	self clipMinXPut: 0.	self clipMaxXPut: 0.	self clipMinYPut: 0.	self clipMaxYPut: 0.	self currentZPut: 0.	self resetGraphicsEngineStats.	self initEdgeTransform.	self initColorTransform.	interpreterProxy pop: 2.	interpreterProxy push: wbOop.! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/11/2000 23:08'!primitiveRegisterExternalEdge	| rightFillIndex leftFillIndex initialZ initialY initialX index  edge |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	rightFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	initialZ _ interpreterProxy stackIntegerValue: 2.	initialY _ interpreterProxy stackIntegerValue: 3.	initialX _ interpreterProxy stackIntegerValue: 4.	index _ interpreterProxy stackIntegerValue: 5.	engine _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	(self allocateObjEntry: GEBaseEdgeSize) 		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	(self isFillOkay: leftFillIndex)		ifFalse:[^interpreterProxy primitiveFail].	(self isFillOkay: rightFillIndex)		ifFalse:[^interpreterProxy primitiveFail].	edge _ objUsed.	objUsed _ edge + GEBaseEdgeSize.	"Install type and length"	self objectTypeOf: edge put: GEPrimitiveEdge.	self objectLengthOf: edge put: GEBaseEdgeSize.	self objectIndexOf: edge put: index.	"Install remaining stuff"	self edgeXValueOf: edge put: initialX.	self edgeYValueOf: edge put: initialY.	self edgeZValueOf: edge put: initialZ.	self edgeLeftFillOf: edge put: (self transformColor: leftFillIndex).	self edgeRightFillOf: edge put: (self transformColor: rightFillIndex).	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6. "Leave rcvr on stack"	].! !!BalloonEngineBase methodsFor: 'primitives-other' stamp: 'ar 5/11/2000 23:14'!primitiveRegisterExternalFill	| index  fill |	self export: true.	self inline: false.	interpreterProxy methodArgumentCount = 1 		ifFalse:[^interpreterProxy primitiveFail].	index _ interpreterProxy stackIntegerValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Note: We *must* not allocate any fill with index 0"	fill _ 0.	[fill = 0] whileTrue:[		(self allocateObjEntry: GEBaseEdgeSize) 			ifFalse:[^interpreterProxy primitiveFail].		fill _ objUsed.		objUsed _ fill + GEBaseFillSize.		"Install type and length"		self objectTypeOf: fill put: GEPrimitiveFill.		self objectLengthOf: fill put: GEBaseFillSize.		self objectIndexOf: fill put: index.	].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 2.		interpreterProxy pushInteger: fill.	].! !!BalloonEngineBase methodsFor: 'displaying' stamp: 'ar 5/12/2000 16:42'!displaySpanBufferAt: y	"Display the span buffer at the current scan line."	| targetX0 targetX1 targetY |	self inline: false.	"self aaLevelGet > 1 ifTrue:[self adjustAALevel]."	targetX0 _ self spanStartGet >> self aaShiftGet.	targetX0 < self clipMinXGet ifTrue:[targetX0 _ self clipMinXGet].	targetX1 _ (self spanEndGet + self aaLevelGet - 1) >> self aaShiftGet.	targetX1 > self clipMaxXGet ifTrue:[targetX1 _ self clipMaxXGet].	targetY _ y >> self aaShiftGet.	(targetY < self clipMinYGet or:[targetY >= self clipMaxYGet or:[		targetX1 < self clipMinXGet or:[targetX0 >= self clipMaxXGet]]]) ifTrue:[^0].	self copyBitsFrom: targetX0 to: targetX1 at: targetY.! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 5/12/2000 16:42'!copyBitsFrom: x0 to: x1 at: yValue	^self cCode:' ((int (*) (int, int, int)) copyBitsFn)(x0, x1, yValue)'! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 5/13/2000 14:55'!errorWrongIndex	"Ignore dispatch errors when translating to C	(since we have no entry point for #error in the VM proxy)"	self cCode:'' inSmalltalk:[self error:'BalloonEngine: Fatal dispatch error']! !!BalloonEngineBase methodsFor: 'private' stamp: 'ar 5/12/2000 16:41'!loadBitBltFrom: bbObj	^self cCode: '((int (*) (int))loadBBFn)(bbObj)'! !!BalloonEngineBase methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:40'!initialiseModule	self export: true.	loadBBFn _ interpreterProxy ioLoadFunction: 'loadBitBltFrom' From:'BitBltPlugin'.	copyBitsFn _ interpreterProxy ioLoadFunction: 'copyBitsFromtoat' From: 'BitBltPlugin'.	^(loadBBFn ~= 0 and:[copyBitsFn ~= 0])! !!BalloonEngineBase class methodsFor: 'accessing' stamp: 'ar 5/11/2000 23:48'!moduleName	^'B2DPlugin'! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:07'!primitiveAddBezier	| leftFill rightFill viaOop endOop startOop nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	rightFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	viaOop _ interpreterProxy stackObjectValue: 2.	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFill) and:[self isFillOkay: rightFill])			ifFalse:[^interpreterProxy primitiveFail].	"Do a quick check if the fillIndices are equal - if so, just ignore it"	leftFill = rightFill & false ifTrue:[		^interpreterProxy pop: 6. "Leave rcvr on stack"	].	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: viaOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self transformPoints: 3.	nSegments _ self loadAndSubdivideBezierFrom: self point1Get 						via: self point2Get 						to: self point3Get 						isWide: false.	self needAvailableSpace: nSegments * GBBaseSize.	engineStopped ifFalse:[		leftFill _ self transformColor: leftFill.		rightFill _ self transformColor: rightFill].	engineStopped ifFalse:[		self loadWideBezier: 0 lineFill: 0 leftFill: leftFill rightFill: rightFill n: nSegments.	].	engineStopped ifTrue:[		"Make sure the stack is okay"		self wbStackClear.		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:08'!primitiveAddBezierShape	| points lineFill lineWidth fillIndex length isArray segSize nSegments |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	lineWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	nSegments _ interpreterProxy stackIntegerValue: 3.	points _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = (nSegments * 3) or:[length = (nSegments * 6)])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = (nSegments * 3)			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Transform colors"	lineFill _ self transformColor: lineFill.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 5].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[		lineWidth _ self transformWidth: lineWidth.		lineWidth < 1 ifTrue:[lineWidth _ 1]].	"And load the actual shape"	isArray ifTrue:[		self loadArrayShape: points nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill.	] ifFalse:[		self loadShape: (interpreterProxy firstIndexableField: points) nSegments: nSegments			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nSegments * 3 = length)].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:10'!primitiveAddBitmapFill	| nrmOop dirOop originOop tileFlag fill xIndex cmOop formOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 7 		ifFalse:[^interpreterProxy primitiveFail].	xIndex _ interpreterProxy stackIntegerValue: 0.	xIndex <= 0 ifTrue:[^interpreterProxy primitiveFail].	nrmOop _ interpreterProxy stackObjectValue: 1.	dirOop _ interpreterProxy stackObjectValue: 2.	originOop _ interpreterProxy stackObjectValue: 3.	tileFlag _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 4).	tileFlag ifTrue:[tileFlag _ 1] ifFalse:[tileFlag _ 0].	cmOop _ interpreterProxy stackObjectValue: 5.	formOop _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 7) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadBitmapFill: formOop 				colormap: cmOop				tile: tileFlag				from: self point1Get 				along: self point2Get 				normal: self point3Get 				xIndex: xIndex-1.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 8.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:06'!primitiveAddCompressedShape	| fillIndexList lineFills lineWidths rightFills leftFills nSegments points pointsShort |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 7 		ifFalse:[^interpreterProxy primitiveFail].	fillIndexList _ interpreterProxy stackObjectValue: 0.	lineFills _ interpreterProxy stackObjectValue: 1.	lineWidths _ interpreterProxy stackObjectValue: 2.	rightFills _ interpreterProxy stackObjectValue: 3.	leftFills _ interpreterProxy stackObjectValue: 4.	nSegments _ interpreterProxy stackIntegerValue: 5.	points _ interpreterProxy stackObjectValue: 6.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 7) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the compressed shape is okay"	(self checkCompressedShape: points 			segments: nSegments 			leftFills: leftFills 			rightFills: rightFills 			lineWidths: lineWidths 			lineFills: lineFills 			fillIndexList: fillIndexList) ifFalse:[^interpreterProxy primitiveFail].	"Now check that we have some hope to have enough free space.	Do this by assuming nSegments boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(self needAvailableSpace: (GBBaseSize max: GLBaseSize) * nSegments)		ifFalse:[^interpreterProxy primitiveFail].	"Check if the points are short"	pointsShort _ (interpreterProxy slotSizeOf: points) = (nSegments * 3).	"Then actually load the compressed shape"	self loadCompressedShape: (interpreterProxy firstIndexableField: points)			segments: nSegments 			leftFills: (interpreterProxy firstIndexableField: leftFills)			rightFills: (interpreterProxy firstIndexableField: rightFills)			lineWidths: (interpreterProxy firstIndexableField: lineWidths)			lineFills: (interpreterProxy firstIndexableField: lineFills)			fillIndexList: (interpreterProxy firstIndexableField: fillIndexList)			pointShort: pointsShort.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 7. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:13'!primitiveAddGradientFill	| isRadial nrmOop dirOop originOop rampOop fill |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	isRadial _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	nrmOop _ interpreterProxy stackValue: 1.	dirOop _ interpreterProxy stackValue: 2.	originOop _ interpreterProxy stackValue: 3.	rampOop _ interpreterProxy stackValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	self loadPoint: self point1Get from: originOop.	self loadPoint: self point2Get from: dirOop.	self loadPoint: self point3Get from: nrmOop.	interpreterProxy failed ifTrue:[^0].	fill _ self loadGradientFill: rampOop 				from: self point1Get 				along: self point2Get 				normal: self point3Get 				isRadial: isRadial.	engineStopped ifTrue:[		"Make sure the stack is okay"		^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 6.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: fill).	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:08'!primitiveAddLine	| leftFill rightFill endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 4 		ifFalse:[^interpreterProxy primitiveFail].	rightFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	leftFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 1).	endOop _ interpreterProxy stackObjectValue: 2.	startOop _ interpreterProxy stackObjectValue: 3.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 4) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: leftFill) and:[self isFillOkay: rightFill])			ifFalse:[^interpreterProxy primitiveFail].	"Load the points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	"Transform points"	self transformPoints: 2.	"Transform colors"	leftFill _ self transformColor: leftFill.	rightFill _ self transformColor: rightFill.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Load line"	self loadWideLine: 0 from: self point1Get to: self point2Get 		lineFill: 0 leftFill: leftFill rightFill: rightFill.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self storeEngineStateInto: engine.		interpreterProxy pop: 4. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:12'!primitiveAddOval	| fillIndex borderWidth borderIndex endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	borderWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Transform colors"	fillIndex _ self transformColor: fillIndex.	borderIndex _ self transformColor: borderIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth <= 0]]) ifTrue:[		^interpreterProxy pop: 5. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (16 * GBBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth]		ifFalse:[borderWidth _ 0].	"Load the rectangle points"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point2Get from: endOop.	interpreterProxy failed ifTrue:[^0].	self loadOval: borderWidth lineFill: borderIndex 		leftFill: 0 rightFill: fillIndex.	engineStopped ifTrue:[		self wbStackClear.		^interpreterProxy primitiveFail.	].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:11'!primitiveAddPolygon	| points lineFill lineWidth fillIndex nPoints length isArray segSize |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	lineFill _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	lineWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	nPoints _ interpreterProxy stackIntegerValue: 3.	points _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"First, do a check if the points look okay"	length _ interpreterProxy slotSizeOf: points.	(interpreterProxy isWords: points) ifTrue:[		isArray _ false.		"Either PointArray or ShortPointArray"		(length = nPoints or:[nPoints * 2 = length])			ifFalse:[^interpreterProxy primitiveFail].	] ifFalse:["Must be Array of points"		(interpreterProxy fetchClassOf: points) = interpreterProxy classArray			ifFalse:[^interpreterProxy primitiveFail].		length = nPoints			ifFalse:[^interpreterProxy primitiveFail].		isArray _ true.	].	"Now check that we have some hope to have enough free space.	Do this by assuming nPoints boundaries of maximum size,	hoping that most of the fills will be colors and many boundaries	will be line segments"	(lineWidth = 0 or:[lineFill = 0])		ifTrue:[segSize _ GLBaseSize]		ifFalse:[segSize _ GLWideSize].	(self needAvailableSpace: segSize * nPoints)		ifFalse:[^interpreterProxy primitiveFail].	"Check the fills"	((self isFillOkay: lineFill) and:[self isFillOkay: fillIndex])		ifFalse:[^interpreterProxy primitiveFail]. 	"Transform colors"	lineFill _ self transformColor: lineFill.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if have anything at all to do"	((lineFill = 0 or:[lineWidth = 0]) and:[fillIndex = 0])		ifTrue:[^interpreterProxy pop: 6].	"Transform the lineWidth"	lineWidth = 0 ifFalse:[lineWidth _ self transformWidth: lineWidth].	"And load the actual polygon"	isArray ifTrue:[		self loadArrayPolygon: points nPoints: nPoints			fill: fillIndex lineWidth: lineWidth lineFill: lineFill	] ifFalse:[		self loadPolygon: (interpreterProxy firstIndexableField: points) nPoints: nPoints 			fill: fillIndex lineWidth: lineWidth lineFill: lineFill 			pointsShort: (nPoints = length)].	engineStopped ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:09'!primitiveAddRect	| fillIndex borderWidth borderIndex endOop startOop |	self export: true.	self inline: false.	"Fail if we have the wrong number of arguments"	interpreterProxy methodArgumentCount = 5 		ifFalse:[^interpreterProxy primitiveFail].	borderIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	borderWidth _ interpreterProxy stackIntegerValue: 1.	fillIndex _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 2).	endOop _ interpreterProxy stackObjectValue: 3.	startOop _ interpreterProxy stackObjectValue: 4.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: (interpreterProxy stackObjectValue: 5) requiredState: GEStateUnlocked)		ifFalse:[^interpreterProxy primitiveFail].	"Make sure the fills are okay"	((self isFillOkay: borderIndex) and:[self isFillOkay: fillIndex])			ifFalse:[^interpreterProxy primitiveFail].	"Transform colors"	borderIndex _ self transformColor: borderIndex.	fillIndex _ self transformColor: fillIndex.	engineStopped ifTrue:[^interpreterProxy primitiveFail].	"Check if we have anything at all to do"	(fillIndex = 0 and:[borderIndex = 0 or:[borderWidth = 0]]) ifTrue:[		^interpreterProxy pop: 5. "Leave rcvr on stack"	].	"Make sure we have some space"	(self needAvailableSpace: (4 * GLBaseSize)) 		ifFalse:[^interpreterProxy primitiveFail].	"Check if we need a border"	(borderWidth > 0 and:[borderIndex ~= 0]) 		ifTrue:[borderWidth _ self transformWidth: borderWidth]		ifFalse:[borderWidth _ 0].	"Load the rectangle"	self loadPoint: self point1Get from: startOop.	self loadPoint: self point3Get from: endOop.	interpreterProxy failed ifTrue:[^nil].	self point2Get at: 0 put: (self point3Get at: 0).	self point2Get at: 1 put: (self point1Get at: 1).	self point4Get at: 0 put: (self point1Get at: 0).	self point4Get at: 1 put: (self point3Get at: 1).	"Transform the points"	self transformPoints: 4.	self loadRectangle: borderWidth lineFill: borderIndex leftFill: 0 rightFill: fillIndex.	interpreterProxy failed ifFalse:[		self needsFlushPut: 1.		self storeEngineStateInto: engine.		interpreterProxy pop: 5. "Leave rcvr on stack"	].! !!BalloonEnginePlugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:06'!primitiveGetBezierStats	| statOop stats |	self export: true.	self inline: false.	self var: #stats declareC:'int *stats'.	interpreterProxy methodArgumentCount = 1		ifFalse:[^interpreterProxy primitiveFail].	statOop _ interpreterProxy stackObjectValue: 0.	engine _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	(self quickLoadEngineFrom: engine)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: statOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: statOop) < 4		ifTrue:[^interpreterProxy primitiveFail].	stats _ interpreterProxy firstIndexableField: statOop.	stats at: 0 put: (stats at: 0) + (workBuffer at: GWBezierMonotonSubdivisions).	stats at: 1 put: (stats at: 1) + (workBuffer at: GWBezierHeightSubdivisions).	stats at: 2 put: (stats at: 2) + (workBuffer at: GWBezierOverflowSubdivisions).	stats at: 3 put: (stats at: 3) + (workBuffer at: GWBezierLineConversions).	interpreterProxy pop: 1. "Leave rcvr on stack"! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 21:27'!drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt>>drawLoopX:Y:"	| dx1 dy1 px py P affL affR affT affB |	xDelta > 0		ifTrue: [dx1 _ 1]		ifFalse: [xDelta = 0				ifTrue: [dx1 _ 0]				ifFalse: [dx1 _ -1]].	yDelta > 0		ifTrue: [dy1 _ 1]		ifFalse: [yDelta = 0				ifTrue: [dy1 _ 0]				ifFalse: [dy1 _ -1]].	px _ yDelta abs.	py _ xDelta abs.	affL _ affT _ 9999.  "init null rectangle"	affR _ affB _ -9999.	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx1.				(P _ P - px) < 0 ifTrue: 					[destY _ destY + dy1.					P _ P + py].				i < py ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							self showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy1.				(P _ P - py) < 0 ifTrue: 					[destX _ destX + dx1.					P _ P + px].				i < px ifTrue:					[self copyBits.					interpreterProxy failed ifTrue:						[^ nil "bail out now on failure -- avoid storing x,y"].					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							self showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]].	"Remaining affected rect"	affectedL _ affL.  affectedR _ affR.	affectedT _ affT.  affectedB _ affB.	"store destX, Y back"		interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 21:23'!fetchIntOrFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	| fieldOop floatValue |	self var: #floatValue declareC:'double floatValue'.	fieldOop _ interpreterProxy fetchPointer: fieldIndex ofObject: objectPointer.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	floatValue _ interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 <= floatValue and:[floatValue <= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 20:51'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	| fieldOop floatValue |	self var: #floatValue declareC:'double floatValue'.	fieldOop _ interpreterProxy fetchPointer: fieldIndex ofObject: objectPointer.	(interpreterProxy isIntegerObject: fieldOop)		ifTrue:[^interpreterProxy integerValueOf: fieldOop].	floatValue _ interpreterProxy floatValueOf: fieldOop.	(-2147483648.0 <= floatValue and:[floatValue <= 2147483647.0])		ifFalse:[interpreterProxy primitiveFail. ^0].	^floatValue asInteger! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/20/2000 19:42'!loadBitBltFrom: bbObj	"Load BitBlt from the oop.	This function is exported for the Balloon engine."	self export: true.	^self loadBitBltFrom: bbObj warping: false.! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 5/11/2000 20:39'!loadBitBltFrom: bbObj warping: aBool	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| ok |	self inline: false.	bitBltOop _ bbObj.	colorMap _ nil. "Assume no color map"	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > (OpTableSize - 2)]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bbObj.	((interpreterProxy isPointers: destForm) and: [(interpreterProxy slotSizeOf: destForm) >= 4])		ifFalse: [^ false].	ok _ self loadBitBltDestForm.	ok ifFalse:[^false].	destX _ self fetchIntOrFloat: BBDestXIndex ofObject: bitBltOop.	destY _ self fetchIntOrFloat: BBDestYIndex ofObject: bitBltOop.	width _ self fetchIntOrFloat: BBWidthIndex ofObject: bitBltOop.	height _ self fetchIntOrFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy slotSizeOf: sourceForm) >= 4])			ifFalse: [^ false].		ok _ self loadBitBltSourceForm.		ok ifFalse:[^false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		ok _ self loadColorMap: aBool.		ok ifFalse:[^false].		self setupColorMasks.		sourceX _ self fetchIntOrFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ self fetchIntOrFloat: BBSourceYIndex ofObject: bitBltOop].	ok _ self loadHalftoneForm.	ok ifFalse:[^false].	clipX _ self fetchIntOrFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ self fetchIntOrFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ self fetchIntOrFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ self fetchIntOrFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 21:24'!loadBitBltSourceForm	"Load the source form for BitBlt. Return false if anything is wrong, true otherwise."	| sourcePixPerWord sourceBitsSize |	self inline: true.	sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.	srcWidth _ self fetchIntOrFloat: FormWidthIndex ofObject: sourceForm.	srcHeight _ self fetchIntOrFloat: FormHeightIndex ofObject: sourceForm.	(srcWidth >= 0 and: [srcHeight >= 0])		ifFalse: [^ false].	sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.	"Ignore an integer bits handle for Display in which case 	the appropriate values will be obtained by calling ioLockSurfaceBits()."	(interpreterProxy isIntegerObject: sourceBits) ifTrue:[		"Query for actual surface dimensions"		(self querySourceSurface: (interpreterProxy integerValueOf: sourceBits))			ifFalse:[^false].		sourcePixPerWord _ 32 // sourcePixSize.		sourceBits _ sourcePitch _ 0.	] ifFalse:[		sourcePixPerWord _ 32 // sourcePixSize.		sourcePitch _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord * 4.		sourceBitsSize _ interpreterProxy byteSizeOf: sourceBits.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourcePitch * srcHeight)])			ifFalse: [^ false].		"Skip header since external bits don't have one"		sourceBits _ self cCoerce: (interpreterProxy firstIndexableField: sourceBits) to:'int'.	].	^true! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 21:24'!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	self inline: false.	"Load arguments and Scanner state"	scanStart _ start.	scanStop _ stop.	scanString _ string.	scanRightX _ rightX.	scanStopArray _ stopArray.	scanDisplayFlag _ displayFlag.	interpreterProxy success: (		(interpreterProxy isPointers: scanStopArray)			and: [(interpreterProxy slotSizeOf: scanStopArray) >= 1]).	scanXTable _ interpreterProxy fetchPointer: BBXTableIndex ofObject: bbObj.	interpreterProxy success: (		(interpreterProxy isPointers: scanXTable)			and: [(interpreterProxy slotSizeOf: scanXTable) >= 1]).	"width and sourceX may not be set..."	interpreterProxy storeInteger: BBWidthIndex ofObject: bbObj withValue: 0.	interpreterProxy storeInteger: BBSourceXIndex ofObject: bbObj withValue: 0.	"Now load BitBlt state if displaying"	scanDisplayFlag		ifTrue: [interpreterProxy success: (self loadBitBltFrom: bbObj)]		ifFalse: [bitBltOop _ bbObj.				destX _ self fetchIntOrFloat: BBDestXIndex ofObject: bbObj].	^interpreterProxy failed not! !!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'ar 2/19/2000 20:46'!showDisplayBits	interpreterProxy 		showDisplayBits: destForm		Left: affectedL		Top: affectedT		Right: affectedR		Bottom: affectedB! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 2/20/2000 19:43'!copyBits	"This function is exported for the Balloon engine"	self export: true.	self inline: true.	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	"Lock the surfaces"	self lockSurfaces ifFalse:[^interpreterProxy primitiveFail].	self copyBitsLockedAndClipped.	self unlockSurfaces.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 2/20/2000 19:42'!copyBitsFrom: startX to: stopX at: yValue	"Support for the balloon engine."	self export: true.	destX _ startX.	destY _ yValue.	sourceX _ startX.	width _ (stopX - startX).	self copyBits.	self showDisplayBits.! !!BitBltSimulation methodsFor: 'setup' stamp: 'ar 2/19/2000 20:58'!copyBitsLockedAndClipped	"Perform the actual copyBits operation.	Assume: Surfaces have been locked and clipping was performed."	| done |	self inline: true.	"Try a shortcut for stuff that should be run as quickly as possible" 	done _ self tryCopyingBitsQuickly.	done ifTrue:[^nil].	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy methodArgumentCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	bitCount _ 0.	"Choose and perform the actual copy loop."	self performCopyLoop.	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 2/19/2000 21:24'!warpLoop	"ar 12/7/1999: This version is unused but kept as reference implemenation"	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	self inline: false. 	(interpreterProxy slotSizeOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ self fetchIntOrFloat: BBWarpBase ofObject: bitBltOop.	t _ self fetchIntOrFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ self fetchIntOrFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ self fetchIntOrFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ self fetchIntOrFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ self fetchIntOrFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ self fetchIntOrFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ self fetchIntOrFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy methodArgumentCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy slotSizeOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((self dstLongAt: destIndex) bitAnd: destMask).			self dstLongAt: destIndex put: (destMask bitAnd: mergeWord)				mask: destMask bitInvert32.			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'ar 2/19/2000 21:24'!xWarpLoop	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation."	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy pBx pBy	  xDelta yDelta smoothingCount sourceMapOop 	  nSteps nPix words destWord endBits mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler" 	(interpreterProxy slotSizeOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ self fetchIntOrFloat: BBWarpBase ofObject: bitBltOop.	words _ self fetchIntOrFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: words nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ words - (nSteps*deltaP12x)].	pAy _ self fetchIntOrFloat: BBWarpBase+1 ofObject: bitBltOop.	words _ self fetchIntOrFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: words nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ words - (nSteps*deltaP12y)].	pBx _ self fetchIntOrFloat: BBWarpBase+9 ofObject: bitBltOop.	words _ self fetchIntOrFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: words nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ words - (nSteps*deltaP43x)].	pBy _ self fetchIntOrFloat: BBWarpBase+10 ofObject: bitBltOop.	words _ self fetchIntOrFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: words nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ words - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy methodArgumentCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy slotSizeOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail].					sourceMapOop _ self cCoerce: (interpreterProxy firstIndexableField: sourceMapOop) to:'int']]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1. 	bbW < startBits ifTrue:[startBits _ bbW].	destY < clipY ifTrue:[		"Advance increments if there was clipping in y"		pAx _ pAx + (clipY - destY * deltaP12x).		pAy _ pAy + (clipY - destY * deltaP12y).		pBx _ pBx + (clipY - destY * deltaP43x).		pBy _ pBy + (clipY - destY * deltaP43y)].	"Setup values for faster pixel fetching.	Note: this should really go into a separate method	since it only sets up globals so there is no need to	have it in this method."		"warpSrcShift = log2(sourcePixSize)"		warpSrcShift _ 0.		words _ sourcePixSize. "recycle temp"		[words = 1] whileFalse:[			warpSrcShift _ warpSrcShift + 1.			words _ words >> 1].		"warpSrcMask = mask for extracting one pixel from source word"		warpSrcMask _ maskTable at: sourcePixSize.		"warpAlignShift: Shift for aligning x position to word boundary"		warpAlignShift _ 5 - warpSrcShift.		"warpAlignMask: Mask for extracting the pixel position from an x position"		warpAlignMask _ 1 << warpAlignShift - 1.		"Setup the lookup table for source bit shifts"		"warpBitShiftTable: given an sub-word x value what's the bit shift?"		0 to: warpAlignMask do:[:i|			warpBitShiftTable at: i put: 32 - ( i + 1 << warpSrcShift )].	1 to: bbH do:		[ :i | "here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		dstBitShift _ 32 - ((dx bitAnd: pixPerWord - 1) + 1 * destPixSize).		(destX < clipX) ifTrue:[			"Advance increments if there was clipping in x"			sx _ sx + (clipX - destX * xDelta).			sy _ sy + (clipX - destX * yDelta).		].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ self halftoneAt: dy+i-1].		destMask _ mask1.		nPix _ startBits.		"Here is the inner loop..."		words _ nWords.			["pick up word"			smoothingCount = 1 ifTrue:["Faster if not smoothing"				skewWord _ self warpPickSourcePixels: nPix								xDeltah: xDelta yDeltah: yDelta								xDeltav: deltaP12x yDeltav: deltaP12y.			] ifFalse:["more difficult with smoothing"				skewWord _ self warpPickSmoothPixels: nPix						xDeltah: xDelta yDeltah: yDelta						xDeltav: deltaP12x yDeltav: deltaP12y						sourceMap: sourceMapOop						smoothing: smoothingCount.			].			destMask = AllOnes ifTrue:["avoid read-modify-write"				mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)								with: (self dstLongAt: destIndex).				self dstLongAt: destIndex put: (destMask bitAnd: mergeWord).			] ifFalse:[ "General version using dest masking"				destWord _ self dstLongAt: destIndex.				mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)								with: (destWord bitAnd: destMask).				destWord _ (destMask bitAnd: mergeWord) bitOr:								(destWord bitAnd: destMask bitInvert32).				self dstLongAt: destIndex put: destWord.			].			destIndex _ destIndex + 4.			words = 2 "e.g., is the next word the last word?"				ifTrue:["set mask for last word in this row"						destMask _ mask2.						nPix _ endBits]				ifFalse:["use fullword mask for inner loop"						destMask _ AllOnes.						nPix _ pixPerWord].			(words _ words - 1) = 0] whileFalse.		"--- end of inner loop ---"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'initialize-release' stamp: 'ar 5/11/2000 20:39'!initialiseModule	self export: true.	self initBBOpTable.	^true! !!BitBltSimulation methodsFor: 'primitives' stamp: 'ar 2/19/2000 20:40'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	self export: true.	rcvr _ interpreterProxy stackValue: interpreterProxy methodArgumentCount.	(self loadBitBltFrom: rcvr) 		ifFalse:[^interpreterProxy primitiveFail].	self copyBits.	self showDisplayBits.! !!BitBltSimulation methodsFor: 'primitives' stamp: 'ar 2/19/2000 20:42'!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	self export: true.	rcvr _ interpreterProxy stackValue: 2.	xDelta _ interpreterProxy stackIntegerValue: 1.	yDelta _ interpreterProxy stackIntegerValue: 0.	(self loadBitBltFrom: rcvr) 		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		self drawLoopX: xDelta Y: yDelta.		self showDisplayBits].	interpreterProxy failed ifFalse:[interpreterProxy pop: 2].! !!BitBltSimulation methodsFor: 'primitives' stamp: 'ar 2/19/2000 20:44'!primitiveScanCharacters	"Invoke the scanCharacters primitive."	| rcvr start stop string rightX stopArray displayFlag |	self export: true.	rcvr _ interpreterProxy stackValue: 6.	start _ interpreterProxy stackIntegerValue: 5.	stop _ interpreterProxy stackIntegerValue: 4.	string _ interpreterProxy stackValue: 3.	rightX _ interpreterProxy stackIntegerValue: 2.	stopArray _ interpreterProxy stackValue: 1.	displayFlag _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	interpreterProxy failed ifTrue: [^ nil].	(self loadScannerFrom: rcvr			start: start stop: stop string: string rightX: rightX			stopArray: stopArray displayFlag: displayFlag)		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed		ifFalse: [self scanCharacters].	interpreterProxy failed		ifFalse: [			displayFlag ifTrue: [self showDisplayBits].			interpreterProxy pop: 7.			interpreterProxy push: self stopReason].! !!BitBltSimulation methodsFor: 'primitives' stamp: 'ar 2/19/2000 20:47'!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	self export: true.	rcvr _ interpreterProxy stackValue: interpreterProxy methodArgumentCount.	(self loadWarpBltFrom: rcvr) 		ifFalse:[^interpreterProxy primitiveFail].	self warpBits.	self showDisplayBits.! !!BitBltSimulation class methodsFor: 'translation' stamp: 'ar 5/12/2000 01:11'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'.	aCCodeGenerator var: 'maskTable'		declareC:'int maskTable[33] = {0, 1, 3, 0, 15, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 65535,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}'.	aCCodeGenerator var: 'ditherMatrix4x4'		declareC:'const int ditherMatrix4x4[16] = {0,	8,	2,	10,12,	4,	14,	6,3,	11,	1,	9,15,	7,	13,	5}'.	aCCodeGenerator var: 'ditherThresholds16'		declareC:'const int ditherThresholds16[8] = { 0, 2, 4, 6, 8, 12, 14, 16 }'.	aCCodeGenerator var: 'ditherValues16'		declareC:'const int ditherValues16[32] = {0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}'.	aCCodeGenerator var: 'warpBitShiftTable'		declareC:'int warpBitShiftTable[32]'.! !!BitBltSimulation class methodsFor: 'translation' stamp: 'ar 2/19/2000 20:55'!moduleName	^'BitBltPlugin'! !!BitBltSimulator class methodsFor: 'instance creation' stamp: 'ar 5/11/2000 22:06'!new	^super new! !!FFIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:21'!primitiveForceLoad	"Primitive. Force loading the receiver (an instance of ExternalLibrary)."	| rcvr theClass moduleHandlePtr moduleHandle ffiModuleName moduleLength ptr |	self export: true.	self inline: false.	self var: #ptr declareC:'int *ptr'.	self ffiSetLastError: FFIErrorGenericError. "educated guess if we fail silently"	interpreterProxy methodArgumentCount = 0		ifFalse:[^interpreterProxy primitiveFail].	rcvr _ interpreterProxy stackValue: 0.	theClass _ interpreterProxy fetchClassOf: rcvr.	(interpreterProxy includesBehavior: theClass 			ThatOf: interpreterProxy classExternalLibrary) 				ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].	moduleHandlePtr _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	moduleHandle _ self ffiContentsOfHandle: moduleHandlePtr errCode: FFIErrorBadExternalLibrary.	interpreterProxy failed ifTrue:[^0].	ffiModuleName _ interpreterProxy fetchPointer: 1 ofObject: rcvr.	(interpreterProxy isBytes: ffiModuleName) 		ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].	moduleLength _ interpreterProxy byteSizeOf: ffiModuleName.	moduleHandle _ interpreterProxy ioLoadModule: (self cCoerce: (interpreterProxy firstIndexableField: ffiModuleName) to:'int') OfLength: moduleLength.	interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorModuleNotFound]. "failed"	"and store back"	ptr _ interpreterProxy firstIndexableField: moduleHandlePtr.	ptr at: 0 put: moduleHandle.	^0 "done"! !!FFIPlugin methodsFor: 'symbol loading' stamp: 'ar 5/12/2000 17:22'!ffiLoadCalloutModule: module	"Load the given module and return its handle"	| moduleHandlePtr moduleHandle ffiModuleName moduleLength rcvr theClass ptr |	self var: #ptr declareC:'int *ptr'.	(interpreterProxy isBytes: module) ifTrue:[		"plain module name"		ffiModuleName _ module.		moduleLength _ interpreterProxy byteSizeOf: ffiModuleName.		moduleHandle _ interpreterProxy ioLoadModule: (self cCoerce: (interpreterProxy firstIndexableField: ffiModuleName) to:'int') OfLength: moduleLength.		interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorModuleNotFound]. "failed"		^moduleHandle].	"Check if the external method is defined in an external library"	rcvr _ interpreterProxy stackValue: interpreterProxy methodArgumentCount.	theClass _ interpreterProxy fetchClassOf: rcvr.	(interpreterProxy includesBehavior: theClass 			ThatOf: interpreterProxy classExternalLibrary) ifFalse:[^0].	"external library"	moduleHandlePtr _ interpreterProxy fetchPointer: 0 ofObject: rcvr.	moduleHandle _ self ffiContentsOfHandle: moduleHandlePtr errCode: FFIErrorBadExternalLibrary.	interpreterProxy failed ifTrue:[^0].	moduleHandle = 0 ifTrue:["need to reload module"		ffiModuleName _ interpreterProxy fetchPointer: 1 ofObject: rcvr.		(interpreterProxy isBytes: ffiModuleName) ifFalse:[^self ffiFail: FFIErrorBadExternalLibrary].		moduleLength _ interpreterProxy byteSizeOf: ffiModuleName.		moduleHandle _ interpreterProxy ioLoadModule: (self cCoerce: (interpreterProxy firstIndexableField: ffiModuleName) to:'int') OfLength: moduleLength.		interpreterProxy failed ifTrue:[^self ffiFail: FFIErrorModuleNotFound]. "failed"		"and store back"		ptr _ interpreterProxy firstIndexableField: moduleHandlePtr.		ptr at: 0 put: moduleHandle].	^moduleHandle! !!FilePlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:53'!initialiseModule	self export: true.	^self cCode: 'sqFileInit()' inSmalltalk:[true]! !!FilePlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:54'!shutdownModule	self export: true.	^self cCode: 'sqFileShutdown()' inSmalltalk:[true]! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/12/2000 01:24'!fileRecordSize	"Return the size of a Smalltalk file record in bytes."	self static: false.	^ self cCode: 'sizeof(SQFile)'.! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/12/2000 01:24'!fileValueOf: objectPointer	"Return a pointer to the first byte of of the file record within the given Smalltalk object, or nil if objectPointer is not a file record."	self returnTypeC: 'SQFile *'.	self static: false.	(((interpreterProxy isBytes: objectPointer) and:		 [(interpreterProxy byteSizeOf: objectPointer) = self fileRecordSize]))			ifFalse:[interpreterProxy primitiveFail. ^nil].	^interpreterProxy firstIndexableField: objectPointer! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:17'!primitiveFileAtEnd	| file atEnd |	self export: true.	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (interpreterProxy stackValue: 0).	interpreterProxy failed ifFalse:[atEnd _ self sqFileAtEnd: file ].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 2.  "rcvr, file"		interpreterProxy pushBool: atEnd.	].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:17'!primitiveFileClose	| file |	self export: true.	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (interpreterProxy stackValue: 0).	interpreterProxy failed ifFalse: [ self sqFileClose: file ].	interpreterProxy failed ifFalse: [ interpreterProxy pop: 1  "pop file; leave rcvr on stack" ].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:32'!primitiveFileDelete	| namePointer nameIndex nameSize |	self var: 'nameIndex' type: 'char *'.	self export: true.	namePointer _ interpreterProxy stackValue: 0.	(interpreterProxy isBytes: namePointer) 		ifFalse:[^interpreterProxy primitiveFail].	nameIndex _ interpreterProxy firstIndexableField: namePointer.	nameSize _ interpreterProxy byteSizeOf: namePointer.	self sqFileDeleteName: (self cCoerce: nameIndex to: 'int') Size: nameSize.	interpreterProxy failed 		ifFalse:[interpreterProxy pop: 1. "pop name, leave rcvr on stack" ].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:17'!primitiveFileGetPosition	| file position |	self var: 'file' declareC: 'SQFile *file'.	self export: true.	file _ self fileValueOf: (interpreterProxy stackValue: 0).	interpreterProxy failed ifFalse: [position _ self sqFileGetPosition: file].	interpreterProxy failed ifFalse: [		interpreterProxy pop: 2.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: position)].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:33'!primitiveFileOpen	| writeFlag namePointer filePointer file nameIndex nameSize |	self var: 'file' declareC: 'SQFile *file'.	self var: 'nameIndex' type:'char *'.	self export: true.	writeFlag _ interpreterProxy booleanValueOf: (interpreterProxy stackValue: 0).	namePointer _ interpreterProxy stackValue: 1.	(interpreterProxy isBytes: namePointer) 		ifFalse:[^interpreterProxy primitiveFail].	filePointer _ interpreterProxy 					instantiateClass: (interpreterProxy classByteArray)					indexableSize: self fileRecordSize.	file _ self fileValueOf: filePointer.	nameIndex _ interpreterProxy firstIndexableField: namePointer.	nameSize _ interpreterProxy byteSizeOf: namePointer.	interpreterProxy failed ifFalse:[		self cCode: 'sqFileOpen(file, (int)nameIndex, nameSize, writeFlag)'.	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.  "rcvr, name, writeFlag"		interpreterProxy push: filePointer.	].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:33'!primitiveFileRead	| count startIndex array file byteSize arrayIndex bytesRead |	self var: 'file' declareC: 'SQFile *file'.	self var: 'arrayIndex' type:'char *'.	self export: true.	count		_ interpreterProxy stackIntegerValue: 0.	startIndex	_ interpreterProxy stackIntegerValue: 1.	array		_ interpreterProxy stackValue: 2.	file			_ self fileValueOf: (interpreterProxy stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	(interpreterProxy isWordsOrBytes: array) 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	((startIndex >= 1) and:		[(startIndex + count - 1) <= (interpreterProxy slotSizeOf: array)])			ifFalse:[^interpreterProxy primitiveFail].	arrayIndex _ interpreterProxy firstIndexableField: array.	"Note: adjust startIndex for zero-origin indexing"	bytesRead _ self sqFile: file Read: (count * byteSize)					 Into: (self cCoerce: arrayIndex to: 'int')					   At: ((startIndex - 1) * byteSize).	interpreterProxy failed ifFalse:[		interpreterProxy pop: 5.  "pop rcvr, file, array, startIndex, count"		interpreterProxy pushInteger: bytesRead // byteSize.  "push # of elements read"	].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:34'!primitiveFileRename	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |	self var: 'oldNameIndex' type: 'char *'.	self var: 'newNameIndex' type: 'char *'.	self export: true.	newNamePointer _ interpreterProxy stackValue: 0.	oldNamePointer _ interpreterProxy stackValue: 1.	((interpreterProxy isBytes: newNamePointer) and:[		(interpreterProxy isBytes: oldNamePointer)])			ifFalse:[^interpreterProxy primitiveFail].	newNameIndex _ interpreterProxy firstIndexableField: newNamePointer.	newNameSize _ interpreterProxy byteSizeOf: newNamePointer.	oldNameIndex _ interpreterProxy firstIndexableField: oldNamePointer.	oldNameSize _ interpreterProxy byteSizeOf: oldNamePointer.	self sqFileRenameOld: (self cCoerce: oldNameIndex to: 'int') Size: oldNameSize New: (self cCoerce: newNameIndex to: 'int') Size: newNameSize.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 2.  "pop new and old names, leave rcvr on stack"	].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:17'!primitiveFileSetPosition	| newPosition file |	self var: 'file' declareC: 'SQFile *file'.	self export: true.	newPosition _ interpreterProxy positive32BitValueOf: (interpreterProxy stackValue: 0).	file _ self fileValueOf: (interpreterProxy stackValue: 1).	interpreterProxy failed ifFalse:[		self sqFile: file SetPosition: newPosition ].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 2 "pop position, file; leave rcvr on stack" ].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:17'!primitiveFileSize	| file size |	self var: 'file' declareC: 'SQFile *file'.	self export: true.	file _ self fileValueOf: (interpreterProxy stackValue: 0).	interpreterProxy failed ifFalse:[size _ self sqFileSize: file].	interpreterProxy failed ifFalse: [		interpreterProxy pop: 2.		interpreterProxy push: (interpreterProxy positive32BitIntegerFor: size)].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/11/2000 22:34'!primitiveFileWrite	| count startIndex array file byteSize arrayIndex bytesWritten |	self var: 'file' declareC: 'SQFile *file'.	self var: 'arrayIndex' type: 'char *'.	self export: true.	count		_ interpreterProxy stackIntegerValue: 0.	startIndex	_ interpreterProxy stackIntegerValue: 1.	array		_ interpreterProxy stackValue: 2.	file			_ self fileValueOf: (interpreterProxy stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	(interpreterProxy isWordsOrBytes: array) 		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	((startIndex >= 1) and:		[(startIndex + count - 1) <= (interpreterProxy slotSizeOf: array)])			ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifFalse:[		arrayIndex _ interpreterProxy firstIndexableField: array.		"Note: adjust startIndex for zero-origin indexing"		bytesWritten _			self sqFile: file				Write: (count * byteSize)				From: (self cCoerce: arrayIndex to: 'int')				At: ((startIndex - 1) * byteSize).	].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 5.  "pop rcvr, file, array, startIndex, count"		interpreterProxy pushInteger: bytesWritten // byteSize.  "push # of elements written"	].! !!FilePlugin methodsFor: 'file primitives' stamp: 'ar 5/13/2000 14:51'!setMacFile: fileName Type: typeString AndCreator: creatorString	"Exported entry point for the VM. Needed for image saving only and no-op on anything but Macs."	self export: true. "Must be exported for image file write"	self var: #fileName type: 'char *'.	self var: #typeString type: 'char *'.	self var: #creatorString type: 'char *'.	^self cCode: 'dir_SetMacFileTypeAndCreator(fileName, strlen(fileName), typeString, creatorString)'.! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/11/2000 21:31'!asciiDirectoryDelimiter	^ self cCode: 'dir_Delimitor()' inSmalltalk: [FileDirectory pathNameDelimiter asciiValue]! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/11/2000 22:11'!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	| modDateOop createDateOop nameString results stringPtr |	self var: 'entryName' declareC: 'char *entryName'.	self var: 'stringPtr' declareC:'char *stringPtr'.	"allocate storage for results, remapping newly allocated	 oops in case GC happens during allocation"	interpreterProxy pushRemappableOop:		(interpreterProxy instantiateClass: (interpreterProxy classArray) indexableSize: 5).	interpreterProxy pushRemappableOop:		(interpreterProxy instantiateClass: (interpreterProxy classString) indexableSize: entryNameSize)..	interpreterProxy pushRemappableOop: 		(interpreterProxy positive32BitIntegerFor: createDate).	interpreterProxy pushRemappableOop: 		(interpreterProxy positive32BitIntegerFor: modifiedDate).	modDateOop   _ interpreterProxy popRemappableOop.	createDateOop _ interpreterProxy popRemappableOop.	nameString    _ interpreterProxy popRemappableOop.	results         _ interpreterProxy popRemappableOop.	"copy name into Smalltalk string"	stringPtr _ interpreterProxy firstIndexableField: nameString.	0 to: entryNameSize - 1 do: [ :i |		stringPtr at: i put: (entryName at: i).	].	interpreterProxy storePointer: 0 ofObject: results withValue: nameString.	interpreterProxy storePointer: 1 ofObject: results withValue: createDateOop.	interpreterProxy storePointer: 2 ofObject: results withValue: modDateOop.	dirFlag		ifTrue: [ interpreterProxy storePointer: 3 ofObject: results withValue: interpreterProxy trueObject ]		ifFalse: [ interpreterProxy storePointer: 3 ofObject: results withValue: interpreterProxy falseObject ].	interpreterProxy storePointer: 4 ofObject: results		withValue: (interpreterProxy integerObjectOf: fileSize).	^ results! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/13/2000 14:42'!primitiveDirectoryCreate	| dirName dirNameIndex dirNameSize |	self var: #dirNameIndex type: 'char *'.	self export: true.	dirName _ interpreterProxy stackValue: 0.	(interpreterProxy isBytes: dirName) ifFalse:[^interpreterProxy primitiveFail].	dirNameIndex _ interpreterProxy firstIndexableField: dirName.	dirNameSize _ interpreterProxy byteSizeOf: dirName.	(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)'		inSmalltalk:[false])		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.  "pop dirName; leave rcvr on stack"! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/13/2000 14:42'!primitiveDirectoryDelete	| dirName dirNameIndex dirNameSize |	self var: #dirNameIndex type: 'char *'.	self export: true.	dirName _ interpreterProxy stackValue: 0.	(interpreterProxy isBytes: dirName) ifFalse:[^interpreterProxy primitiveFail].	dirNameIndex _ interpreterProxy firstIndexableField: dirName.	dirNameSize _ interpreterProxy byteSizeOf: dirName.	(self cCode: 'dir_Delete((char *) dirNameIndex, dirNameSize)'		inSmalltalk:[false])		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.  "pop dirName; leave rcvr on stack"! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/11/2000 22:18'!primitiveDirectoryDelimitor	| ascii |	self export: true.	ascii _ self asciiDirectoryDelimiter.	((ascii >= 0) and: [ascii <= 255])		ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 1.  "pop rcvr"	interpreterProxy push: (interpreterProxy fetchPointer: ascii ofObject: (interpreterProxy characterTable)).! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/11/2000 22:18'!primitiveDirectoryLookup	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |	self var: 'entryName' declareC: 'char entryName[256]'.	self var: 'pathNameIndex' type: 'char *'.	self export: true.	index _ interpreterProxy stackIntegerValue: 0.	pathName _ interpreterProxy stackValue: 1.	(interpreterProxy isBytes: pathName) ifFalse:[^interpreterProxy primitiveFail].	pathNameIndex _ interpreterProxy firstIndexableField: pathName.	pathNameSize _ interpreterProxy byteSizeOf: pathName.	status _ self cCode:			'dir_Lookup(				(char *) pathNameIndex, pathNameSize, index,				entryName, &entryNameSize, &createDate, &modifiedDate,				&dirFlag, &fileSize)'.	interpreterProxy failed ifTrue:[^nil].	status = DirNoMoreEntries ifTrue: [		"no more entries; return nil"		interpreterProxy pop: 3.  "pop pathName, index, rcvr"		interpreterProxy push: interpreterProxy nilObject.		^ nil	].	status = DirBadPath ifTrue: [ ^ interpreterProxy primitiveFail ].  "bad path"	interpreterProxy pop: 3.  "pop pathName, index, rcvr"	interpreterProxy push:			(self makeDirEntryName: entryName size: entryNameSize				createDate: createDate modDate: modifiedDate				isDir: dirFlag fileSize: fileSize).! !!FilePlugin methodsFor: 'directory primitives' stamp: 'ar 5/11/2000 22:18'!primitiveDirectorySetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	self var: 'creatorStringIndex' type: 'char *'.	self var: 'typeStringIndex' type: 'char *'.	self var: 'fileNameIndex' type: 'char *'.	self export: true.	creatorString _ interpreterProxy stackValue: 0.	typeString _ interpreterProxy stackValue: 1.	fileName _ interpreterProxy stackValue: 2.	((interpreterProxy isBytes: creatorString) and: [(interpreterProxy byteSizeOf: creatorString) = 4]) ifFalse:[^interpreterProxy primitiveFail].	((interpreterProxy isBytes: typeString) and: [(interpreterProxy byteSizeOf: typeString) = 4]) ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isBytes: fileName) ifFalse:[^interpreterProxy primitiveFail].	creatorStringIndex _ interpreterProxy firstIndexableField: creatorString.	typeStringIndex _ interpreterProxy firstIndexableField: typeString.	fileNameIndex _ interpreterProxy firstIndexableField: fileName.	fileNameSize _ interpreterProxy byteSizeOf: fileName.	(self cCode: 'dir_SetMacFileTypeAndCreator(			(char *) fileNameIndex, fileNameSize,			(char *) typeStringIndex, (char *) creatorStringIndex)'		inSmalltalk:[true]) ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy pop: 3.  "pop filename, type, creator; leave rcvr on stack"! !!FilePlugin class methodsFor: 'class initialization' stamp: 'ar 5/12/2000 16:04'!initialize	"FilePlugin initialize"	DirEntryFound _ 0.	DirNoMoreEntries _ 1.	DirBadPath _ 2.! !!FilePlugin class methodsFor: 'instance creation' stamp: 'ar 5/11/2000 22:13'!simulatorClass	^FilePluginSimulator! !!FilePlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:28'!headerFile^'/* File support definitions *//* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileShutdown(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delete(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);'.! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:10'!fileValueOf: objectPointer	^interpreterProxy fileValueOf: objectPointer! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:11'!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	^interpreterProxy		makeDirEntryName: entryName size: entryNameSize		createDate: createDate modDate: modifiedDate		isDir: dirFlag fileSize: fileSize! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:11'!primitiveDirectoryLookup	^interpreterProxy primitiveDirectoryLookup! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:12'!primitiveFileDelete 	^interpreterProxy primitiveFileDelete ! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:12'!primitiveFileOpen	^interpreterProxy primitiveFileOpen! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:12'!primitiveFileRename	^interpreterProxy primitiveFileRename! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:09'!sqFile: file Read: count Into: byteArrayIndex At: startIndex	^interpreterProxy sqFile: file Read: count Into: byteArrayIndex At: startIndex! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:09'!sqFile: file SetPosition: newPosition	^interpreterProxy sqFile: file SetPosition: newPosition! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:09'!sqFile: file Write: count From: byteArrayIndex At: startIndex	^interpreterProxy sqFile: file Write: count From: byteArrayIndex At: startIndex! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:09'!sqFileAtEnd: file	^interpreterProxy sqFileAtEnd: file! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:09'!sqFileClose: file	^interpreterProxy sqFileClose: file! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:10'!sqFileGetPosition: file	^interpreterProxy sqFileGetPosition: file! !!FilePluginSimulator methodsFor: 'as yet unclassified' stamp: 'ar 5/11/2000 22:10'!sqFileSize: file	^interpreterProxy sqFileSize: file! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 5/11/2000 23:14'!primitiveAt	| index rcvr floatValue floatPtr |	self export: true.	self var: #floatValue declareC:'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	index _ interpreterProxy stackIntegerValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatValue _ (floatPtr at: index-1) asFloat.	interpreterProxy pop: 2.	interpreterProxy pushFloat: floatValue.! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 5/11/2000 23:16'!primitiveAtPut	| value floatValue index rcvr floatPtr |	self export: true.	self var: #floatValue declareC: 'double floatValue'.	self var: #floatPtr declareC:'float *floatPtr'.	value _ interpreterProxy stackValue: 0.	(interpreterProxy isIntegerObject: value)		ifTrue:[floatValue _ (interpreterProxy integerValueOf: value) asFloat]		ifFalse:[floatValue _ interpreterProxy floatValueOf: value].	index _ interpreterProxy stackIntegerValue: 1.	rcvr _ interpreterProxy stackObjectValue: 2.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy success: (index > 0 and:[index <= (interpreterProxy slotSizeOf: rcvr)]).	interpreterProxy failed ifTrue:[^nil].	floatPtr _ interpreterProxy firstIndexableField: rcvr.	floatPtr at: index-1 put: (self cCoerce: floatValue to:'float').	interpreterProxy failed ifFalse:[interpreterProxy pop: 3 thenPush: value].! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 5/11/2000 23:17'!primitiveEqual	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 2.	length _ interpreterProxy stSizeOf: arg.	length = (interpreterProxy stSizeOf: rcvr) ifFalse:[^interpreterProxy pushBool: false].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		(rcvrPtr at: i) = (argPtr at: i) ifFalse:[^interpreterProxy pushBool: false].	].	^interpreterProxy pushBool: true! !!FloatArrayPlugin methodsFor: 'access primitives' stamp: 'ar 5/11/2000 23:16'!primitiveHash	| rcvr rcvrPtr length result |	self export: true.	self var: #rcvrPtr declareC:'int *rcvrPtr'.	rcvr _ interpreterProxy stackObjectValue: 0.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'int *'.	result _ 0.	0 to: length-1 do:[:i|		result _ result + (rcvrPtr at: i).		rcvrPtr _ rcvrPtr + 4.	].	interpreterProxy pop: 1.	^interpreterProxy pushInteger: (result bitAnd: 16r1FFFFFFF)! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:17'!primitiveAddFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:15'!primitiveAddScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) + value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:15'!primitiveDivFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	"Check if any of the argument's values is zero"	0 to: length-1 do:[:i|		(interpreterProxy longAt: (argPtr + i)) = 0 ifTrue:[^interpreterProxy primitiveFail]].	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) / (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:16'!primitiveDivScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value inverse length |	self export: true.	self var: #value declareC:'double value'.	self var: #inverse declareC:'double inverse'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	value = 0.0 ifTrue:[^interpreterProxy primitiveFail].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	inverse _ 1.0 / value.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * inverse.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:18'!primitiveDotProduct	"Primitive. Compute the dot product of the receiver and the argument.	The dot product is defined as the sum of the products of the individual elements."	| rcvr arg rcvrPtr argPtr length result |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	self var: #result declareC:'double result'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	result _ 0.0.	0 to: length-1 do:[:i|		result _ result + ((rcvrPtr at: i) * (argPtr at: i)).	].	interpreterProxy pop: 2. "Pop args + rcvr"	interpreterProxy pushFloat: result. "Return result"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:15'!primitiveMulFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:17'!primitiveMulScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) * value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:17'!primitiveSubFloatArray	"Primitive. Add the receiver and the argument, both FloatArrays and store the result into the receiver."	| rcvr arg rcvrPtr argPtr length |	self export: true.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	self var: #argPtr declareC:'float *argPtr'.	arg _ interpreterProxy stackObjectValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: arg).	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: arg.	interpreterProxy success: (length = (interpreterProxy stSizeOf: rcvr)).	interpreterProxy failed ifTrue:[^nil].	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	argPtr _ self cCoerce: (interpreterProxy firstIndexableField: arg) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - (argPtr at: i).	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!FloatArrayPlugin methodsFor: 'arithmetic primitives' stamp: 'ar 5/11/2000 23:17'!primitiveSubScalar	"Primitive. Add the argument, a scalar value to the receiver, a FloatArray"	| rcvr rcvrPtr value length |	self export: true.	self var: #value declareC:'double value'.	self var: #rcvrPtr declareC:'float *rcvrPtr'.	value _ interpreterProxy stackFloatValue: 0.	rcvr _ interpreterProxy stackObjectValue: 1.	interpreterProxy failed ifTrue:[^nil].	interpreterProxy success: (interpreterProxy isWords: rcvr).	interpreterProxy failed ifTrue:[^nil].	length _ interpreterProxy stSizeOf: rcvr.	rcvrPtr _ self cCoerce: (interpreterProxy firstIndexableField: rcvr) to: 'float *'.	0 to: length-1 do:[:i|		rcvrPtr at: i put: (rcvrPtr at: i) - value.	].	interpreterProxy pop: 1. "Leave rcvr on stack"! !!InflatePlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 23:58'!moduleName	^'ZipPlugin'! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 2/20/2000 22:05'!displayBitsOf: aForm Left: l Top: t Right: r Bottom: b	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h dispBitsIndex d left right top bottom surfaceHandle |	displayObj _ self splObj: TheDisplay.	aForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	l < 0 ifTrue:[left _ 0] ifFalse:[left _ l].	r > w ifTrue:[right _ w] ifFalse:[right _ r].	t < 0 ifTrue:[top _ 0] ifFalse:[top _ t].	b > h ifTrue:[bottom _ h] ifFalse:[bottom _ b].	((left <= right) and: [top <= bottom]) ifFalse:[^nil].	successFlag ifTrue: [		(self isIntegerObject: dispBits) ifTrue:[			surfaceHandle _ self integerValueOf: dispBits.			"For now just fail"			"self cCode:'ioShowSurface(surfaceHandle, left, right, top, bottom)'."			self success: false.		] ifFalse:[			dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"			self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom)'.		].	].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 2/20/2000 22:06'!primitiveShowDisplayRect	"Force the given rectangular section of the Display to be copied to the screen."	| bottom top right left |	bottom	_ self stackIntegerValue: 0.	top		_ self stackIntegerValue: 1.	right	_ self stackIntegerValue: 2.	left		_ self stackIntegerValue: 3.	self displayBitsOf: (self splObj: TheDisplay) Left: left Top: top Right: right Bottom: bottom.	successFlag ifTrue: [		self ioForceDisplayUpdate.		self pop: 4].  "pop left, right, top, bottom; leave rcvr on stack"! !!Interpreter methodsFor: 'I/O primitives' stamp: 'ar 2/20/2000 22:06'!showDisplayBits: aForm Left: l Top: t Right: r Bottom: b	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	deferDisplayUpdates ifTrue: [^ nil].	self displayBitsOf: aForm Left: l Top: t Right: r Bottom: b! !!Interpreter methodsFor: 'bitblt support' stamp: 'ar 5/12/2000 15:34'!copyBits	"This entry point needs to be implemented for the interpreter proxy.	Since BitBlt is now a plugin we need to look up BitBltPlugin_copyBits	and call it. This entire mechanism should eventually go away and be	replaced with a dynamic lookup from BitBltPlugin itself but for backward	compatibility this stub is provided"	| fn |	fn _ self ioLoadFunction: 'copyBits' From: 'BitBltPlugin'.	fn = 0 ifTrue:[^self primitiveFail].	^self cCode:' ((int (*) (void)) fn)()'! !!Interpreter methodsFor: 'bitblt support' stamp: 'ar 5/12/2000 15:35'!copyBitsFrom: x0 to: x1 at: y	"This entry point needs to be implemented for the interpreter proxy.	Since BitBlt is now a plugin we need to look up BitBltPlugin_copyBitsFrom:to:at:	and call it. This entire mechanism should eventually go away and be	replaced with a dynamic lookup from BitBltPlugin itself but for backward	compatibility this stub is provided"	| fn |	fn _ self ioLoadFunction: 'copyBitsFromtoat' From: 'BitBltPlugin'.	fn = 0 ifTrue:[^self primitiveFail].	^self cCode:' ((int (*) (int, int, int)) fn)(x0, x1, y)'! !!Interpreter methodsFor: 'bitblt support' stamp: 'ar 5/12/2000 15:34'!loadBitBltFrom: bb	"This entry point needs to be implemented for the interpreter proxy.	Since BitBlt is now a plugin we need to look up BitBltPlugin_loadBitBltFrom	and call it. This entire mechanism should eventually go away and be	replaced with a dynamic lookup from BitBltPlugin itself but for backward	compatibility this stub is provided"	| fn |	fn _ self ioLoadFunction: 'loadBitBltFrom' From: 'BitBltPlugin'.	fn = 0 ifTrue:[^self primitiveFail].	^self cCode:' ((int (*) (int)) fn)(bb)'! !!JoystickTabletPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:53'!initialiseModule	self export: true.	^self cCode: 'joystickInit()' inSmalltalk:[true]! !!JoystickTabletPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:55'!shutdownModule	self export: true.	^self cCode: 'joystickShutdown()' inSmalltalk:[true]! !!JoystickTabletPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 18:54'!primitiveGetTabletParameters: cursorIndex	"Get information on the pen tablet attached to this machine. Fail if there is no tablet. If successful, the result is an array of integers; see the Smalltalk call on this primitive for its interpretation."	| resultSize result resultPtr |	self var: #resultPtr declareC: 'int * resultPtr'.	self primitive: 'primitiveGetTabletParameters'		parameters: #(SmallInteger).	resultSize _ self tabletResultSize.	result _ interpreterProxy instantiateClass: interpreterProxy classBitmap indexableSize: resultSize.	resultPtr _ result asIntPtr.	interpreterProxy success: (self cCode: 'tabletGetParameters(cursorIndex, resultPtr)').	^result! !!JoystickTabletPlugin methodsFor: 'primitives' stamp: 'TPR 3/24/2000 18:33'!primitiveReadJoystick: index	"Read an input word from the joystick with the given index."	self primitive: 'primitiveReadJoystick'		parameters: #(SmallInteger).	^(self joystickRead: index) asPositiveIntegerObj! !!JoystickTabletPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 18:56'!primitiveReadTablet: cursorIndex	"Get the current state of the cursor of the pen tablet specified by my argument. Fail if there is no tablet. If successful, the result is an array of integers; see the Smalltalk call on this primitive for its interpretation."	| resultSize result resultPtr|	self var: #resultPtr declareC: 'int * resultPtr'.	self primitive: 'primitiveReadTablet'		parameters: #(SmallInteger).	resultSize _ self tabletResultSize.	result _ interpreterProxy instantiateClass: interpreterProxy classBitmap indexableSize: resultSize.	resultPtr _ result asIntPtr.	interpreterProxy success: (self cCode: 'tabletRead(cursorIndex, resultPtr)').	^result! !!JoystickTabletPlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:20'!headerFile^'/* joystick support *//* module initialization/shutdown */int joystickInit(void);int joystickShutdown(void);int joystickRead(int stickIndex);/*** tablet support ***/int tabletGetParameters(int cursorIndex, int result[]);int tabletRead(int cursorIndex, int result[]);int tabletResultSize(void);'! !!MIDIPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:53'!initialiseModule	self export: true.	^self cCode: 'midiInit()' inSmalltalk:[true]! !!MIDIPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:55'!shutdownModule	self export: true.	^self cCode: 'midiShutdown()' inSmalltalk:[true]! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:14'!primitiveMIDIClosePort: portNum	self primitive: 'primitiveMIDIClosePort'		parameters: #(SmallInteger).	self sqMIDIClosePort: portNum! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:14'!primitiveMIDIGetClock	"Return the value of the MIDI clock as a SmallInteger. The range is limited to SmallInteger maxVal / 2 to allow scheduling MIDI events into the future without overflowing a SmallInteger. The sqMIDIGetClock function is assumed to wrap at or before 16r20000000."	| clockValue |	self primitive: 'primitiveMIDIGetClock'.	clockValue _ self sqMIDIGetClock bitAnd: 16r1FFFFFFF.	^clockValue asSmallIntegerObj! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:14'!primitiveMIDIGetPortCount	| n |	self primitive: 'primitiveMIDIGetPortCount'.	n _ self sqMIDIGetPortCount.	^n asSmallIntegerObj! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:14'!primitiveMIDIGetPortDirectionality: portNum	|  dir |	self primitive: 'primitiveMIDIGetPortDirectionality'		parameters: #(SmallInteger).	dir _ self sqMIDIGetPortDirectionality: portNum.	^dir asSmallIntegerObj! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:14'!primitiveMIDIGetPortName: portNum	| portName sz nameObj namePtr |	self var: #portName declareC: 'char portName[256]'.	self var: #namePtr declareC: 'char * namePtr'.	self primitive: 'primitiveMIDIGetPortName'		parameters: #(SmallInteger).	sz _ self cCode: 'sqMIDIGetPortName(portNum, (int) &portName, 255)'.	nameObj _ interpreterProxy instantiateClass: interpreterProxy classString indexableSize: sz.	interpreterProxy failed ifTrue:[^nil].	namePtr _ nameObj asValue: String .	self cCode: 'memcpy(namePtr, portName, sz)'.	^nameObj! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:15'!primitiveMIDIOpenPort: portNum sema: semaIndex speed: clockRate	self primitive: 'primitiveMIDIOpenPort'		parameters: #(SmallInteger SmallInteger SmallInteger).	self cCode: 'sqMIDIOpenPort(portNum, semaIndex, clockRate)'! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:15'!primitiveMIDIParameterGet: whichParameter	|  currentValue |	"read parameter"	self primitive: 'primitiveMIDIParameterGet'		parameters: #(SmallInteger).	currentValue _ self cCode: 'sqMIDIParameterGet(whichParameter)'.	^currentValue asSmallIntegerObj! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:15'!primitiveMIDIParameterGetOrSet	"Backward compatibility"	self export: true.	interpreterProxy methodArgumentCount = 1		ifTrue:[^self primitiveMIDIParameterGet]		ifFalse:[^self primitiveMIDIParameterSet]! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:15'!primitiveMIDIParameterSet: whichParameter value: newValue	"write parameter"	self primitive:'primitiveMIDIParameterSet'		parameters:#(SmallInteger SmallInteger).	self cCode: 'sqMIDIParameterSet(whichParameter, newValue)'! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:15'!primitiveMIDIRead: portNum into: array	| arrayLength bytesRead |	self primitive: 'primitiveMIDIRead'		parameters: #(SmallInteger ByteArray).	arrayLength _ interpreterProxy byteSizeOf: array cPtrAsOop.	bytesRead _ self sqMIDIPort: portNum			Read: arrayLength			Into: array asInteger.	^bytesRead asSmallIntegerObj! !!MIDIPlugin methodsFor: 'primitives' stamp: 'ar 5/12/2000 17:15'!primitiveMIDIWrite: portNum from: array at: time	| arrayLength bytesWritten |	self primitive: 'primitiveMIDIWrite'		parameters: #(SmallInteger ByteArray SmallInteger).	arrayLength _ interpreterProxy byteSizeOf: array cPtrAsOop.	bytesWritten _ self sqMIDIPort: portNum			Write: arrayLength			From: array asInteger			At: time.	^bytesWritten asSmallIntegerObj! !!MIDIPlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:21'!headerFile^'/* MIDI primitives *//* module initialization/shutdown */int midiInit(void);int midiShutdown(void);int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameterSet(int whichParameter, int newValue);int sqMIDIParameterGet(int whichParameter);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);'! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:19'!primitiveComposeMatrix	| m1 m2 m3 result |	self export: true.	self inline: false.	self var: #m1 declareC:'float *m1'.	self var: #m2 declareC:'float *m2'.	self var: #m3 declareC:'float *m3'.	m3 _ self loadArgumentMatrix: (result _ interpreterProxy stackObjectValue: 0).	m2 _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	m1 _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3ComposeMatrix: m1 with: m2 into: m3.	interpreterProxy pop: 3.	interpreterProxy push: result.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:19'!primitiveInvertPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3InvertPoint: matrix.	interpreterProxy failed ifFalse:[self roundAndStoreResultPoint: 2].! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:18'!primitiveInvertRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3InvertPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	interpreterProxy failed ifFalse:[		dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY].	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:19'!primitiveIsIdentity	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 0).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 1.	interpreterProxy pushBool:(		((matrix at: 0) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 1) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 2) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 3) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 4) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 5) = (self cCoerce: 0.0 to: 'float'))).! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:19'!primitiveIsPureTranslation	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 0).	interpreterProxy failed ifTrue:[^nil].	interpreterProxy pop: 1.	interpreterProxy pushBool:(		((matrix at: 0) = (self cCoerce: 1.0 to: 'float')) &		((matrix at: 1) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 3) = (self cCoerce: 0.0 to: 'float')) &		((matrix at: 4) = (self cCoerce: 1.0 to: 'float'))).! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:18'!primitiveTransformPoint	| matrix |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self loadArgumentPoint: (interpreterProxy stackObjectValue: 0).	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 1).	interpreterProxy failed ifTrue:[^nil].	self matrix2x3TransformPoint: matrix.	self roundAndStoreResultPoint: 2.! !!Matrix2x3Plugin methodsFor: 'primitives' stamp: 'ar 5/11/2000 23:19'!primitiveTransformRectInto	| matrix srcOop dstOop originX originY cornerX cornerY minX maxX minY maxY |	self export: true.	self inline: false.	self var: #matrix declareC:'float *matrix'.	self var: #originX declareC:'double originX'.	self var: #originY declareC:'double originY'.	self var: #cornerX declareC:'double cornerX'.	self var: #cornerY declareC:'double cornerY'.	self var: #minX declareC:'double minX'.	self var: #maxX declareC:'double maxX'.	self var: #minY declareC:'double minY'.	self var: #maxY declareC:'double maxY'.	dstOop _ interpreterProxy stackObjectValue: 0.	srcOop _ interpreterProxy stackObjectValue: 1.	matrix _ self loadArgumentMatrix: (interpreterProxy stackObjectValue: 2).	interpreterProxy failed ifTrue:[^nil].	(interpreterProxy fetchClassOf: srcOop) = (interpreterProxy fetchClassOf: dstOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy isPointers: srcOop)		ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: srcOop) = 2		ifFalse:[^interpreterProxy primitiveFail].	"Load top-left point"	self loadArgumentPoint: (interpreterProxy fetchPointer: 0 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	originX _ m23ArgX.	originY _ m23ArgY.	self matrix2x3TransformPoint: matrix.	minX _ maxX _ m23ResultX.	minY _ maxY _ m23ResultY.	"Load bottom-right point"	self loadArgumentPoint:(interpreterProxy fetchPointer: 1 ofObject: srcOop).	interpreterProxy failed ifTrue:[^nil].	cornerX _ m23ArgX.	cornerY _ m23ArgY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load top-right point"	m23ArgX _ cornerX.	m23ArgY _ originY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	"Load bottom-left point"	m23ArgX _ originX.	m23ArgY _ cornerY.	self matrix2x3TransformPoint: matrix.	minX _ minX min: m23ResultX.	maxX _ maxX max: m23ResultX.	minY _ minY min: m23ResultY.	maxY _ maxY max: m23ResultY.	dstOop _ self roundAndStoreResultRect: dstOop x0: minX y0: minY x1: maxX y1: maxY.	interpreterProxy failed ifFalse:[		interpreterProxy pop: 3.		interpreterProxy push: dstOop.	].! !!SerialPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:53'!initialiseModule	self export: true.	^self cCode: 'serialPortInit()' inSmalltalk:[true]! !!SerialPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:55'!shutdownModule	self export: true.	^self cCode: 'serialPortShutdown()' inSmalltalk:[true]! !!SerialPlugin methodsFor: 'primitives' stamp: 'TPR 2/17/2000 18:16'!primitiveSerialPortClose: portNum	self primitive: 'primitiveSerialPortClose'		parameters: #(SmallInteger).	self serialPortClose: portNum! !!SerialPlugin methodsFor: 'primitives' stamp: 'TPR 2/11/2000 16:08'!primitiveSerialPortOpen: portNum baudRate: baudRate stopBitsType: stopBitsType parityType: parityType dataBits: dataBits inFlowControlType: inFlowControl outFlowControlType: outFlowControl xOnByte: xOnChar xOffByte: xOffChar	self primitive: 'primitiveSerialPortOpen'		parameters: #(SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger ).	self cCode: 'serialPortOpen(			portNum, baudRate, stopBitsType, parityType, dataBits,			inFlowControl, outFlowControl, xOnChar, xOffChar)'! !!SerialPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 17:00'!primitiveSerialPortRead: portNum into: array startingAt: startIndex count: count 	| bytesRead arrayPtr |	self primitive: 'primitiveSerialPortRead'		parameters: #(SmallInteger ByteArray SmallInteger SmallInteger ).	interpreterProxy success: (startIndex >= 1 and: [startIndex + count - 1 <= (interpreterProxy byteSizeOf: array cPtrAsOop)]).	arrayPtr _ array asInteger + startIndex - 1.	bytesRead _ self cCode: 'serialPortReadInto( portNum, count, arrayPtr)'.	"adjust for zero-origin indexing"	^ bytesRead asSmallIntegerObj! !!SerialPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 17:00'!primitiveSerialPortWrite: portNum from: array startingAt: startIndex count: count 	| bytesWritten arrayPtr |	self primitive: 'primitiveSerialPortWrite'		parameters: #(SmallInteger ByteArray SmallInteger SmallInteger ).	interpreterProxy success: (startIndex >= 1 and: [startIndex + count - 1 <= (interpreterProxy byteSizeOf: array cPtrAsOop)]).	interpreterProxy failed		ifFalse: [arrayPtr _ array asInteger + startIndex - 1.			bytesWritten _ self						serialPort: portNum						Write: count						From: arrayPtr].	^ bytesWritten asSmallIntegerObj! !!SerialPlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:22'!headerFile^'/* serial port primitives *//* module initialization/shutdown */int serialPortInit(void);int serialPortShutdown(void);int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);'! !!SocketPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:53'!initialiseModule	self export: true.	^self cCode: 'socketInit()' inSmalltalk:[true]! !!SocketPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:55'!shutdownModule	self export: true.	^self cCode: 'socketShutdown()' inSmalltalk:[true]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 4/25/2000 14:21'!intToNetAddress: addr	"Convert the given 32-bit integer into an internet network address represented as a four-byte ByteArray."	| netAddressOop naPtr|	self var: #naPtr declareC: 'char * naPtr'.	netAddressOop _		interpreterProxy instantiateClass: interpreterProxy classByteArray			indexableSize: 4.	naPtr _ netAddressOop asCharPtr.	naPtr at: 0 put: (self cCoerce: ((addr >> 24) bitAnd: 16rFF) to: 'char').	naPtr at: 1 put: (self cCoerce: ((addr >> 16) bitAnd: 16rFF) to: 'char').	naPtr at: 2 put: (self cCoerce: ((addr >> 8) bitAnd: 16rFF) to: 'char').	naPtr at: 3 put: (self cCoerce: (addr bitAnd: 16rFF) to: 'char').	^ netAddressOop! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 4/24/2000 17:18'!netAddressToInt: ptrToByteArray	"Convert the given internet network address (represented as a four-byte ByteArray) into a 32-bit integer. Fail if the given ptrToByteArray does not appear to point to a four-byte ByteArray."	| sz |	self var: #ptrToByteArray declareC: 'unsigned char * ptrToByteArray'.	sz _ interpreterProxy byteSizeOf: ptrToByteArray cPtrAsOop.	sz = 4 ifFalse: [^ interpreterProxy primitiveFail].	^ (ptrToByteArray at: 3	) +		((ptrToByteArray at: 2) <<8) +		((ptrToByteArray at: 1) <<16) +		((ptrToByteArray at: 0) <<24)! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:39'!primitiveInitializeNetwork: resolverSemaIndex	| err |	self primitive: 'primitiveInitializeNetwork'		parameters: #(SmallInteger).	err _ self sqNetworkInit: resolverSemaIndex.	interpreterProxy success: err = 0! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 11:47'!primitiveResolverAbortLookup	self primitive: 'primitiveResolverAbortLookup'.	self sqResolverAbort! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:47'!primitiveResolverAddressLookupResult	| sz s |	self primitive: 'primitiveResolverAddressLookupResult'.	sz _ self sqResolverAddrLookupResultSize.	interpreterProxy failed		ifFalse: [s _ interpreterProxy instantiateClass: interpreterProxy classString indexableSize: sz.			self sqResolverAddrLookup: s asCharPtr Result: sz].	^ s! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:10'!primitiveResolverError	self primitive: 'primitiveResolverError'.	^ self sqResolverError asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:10'!primitiveResolverLocalAddress	| addr |	self primitive: 'primitiveResolverLocalAddress'.	addr _ self sqResolverLocalAddress.	^self intToNetAddress: addr! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:11'!primitiveResolverNameLookupResult	| addr |	self primitive: 'primitiveResolverNameLookupResult'.	addr _ self sqResolverNameLookupResult.	^self intToNetAddress: addr! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 4/25/2000 14:42'!primitiveResolverStartAddressLookup: address	| addr |	self primitive: 'primitiveResolverStartAddressLookup'		parameters: #(ByteArray).	addr _ self netAddressToInt: (self cCoerce: address to: 'unsigned char *').	interpreterProxy failed ifFalse: [		self sqResolverStartAddrLookup: addr]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:19'!primitiveResolverStartNameLookup: name	| sz |	self primitive: 'primitiveResolverStartNameLookup'		parameters: #(String).	interpreterProxy failed ifFalse:  [		sz _ interpreterProxy byteSizeOf: name cPtrAsOop.		self sqResolverStartName: name Lookup: sz]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:20'!primitiveResolverStatus	| status |	self primitive: 'primitiveResolverStatus'.	status _ self sqResolverStatus.	^status asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 4/25/2000 14:42'!primitiveSocket: socket connectTo: address port: port	| addr s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketConnectToPort'		parameters: #(Oop ByteArray SmallInteger).	addr _ self netAddressToInt: (self cCoerce: address to: 'unsigned char *').	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		self sqSocket: s ConnectTo: addr Port: port]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:34'!primitiveSocket: socket listenOnPort: port"one part of the wierdass dual prim primitiveSocketListenOnPort which was warped by some demented evil person determined to twist the very nature of reality"	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketListenOnPort'		parameters: #(Oop SmallInteger).	s _ self socketValueOf: socket.	self sqSocket: s ListenOnPort: port.! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:35'!primitiveSocket: socket listenOnPort: port backlogSize: backlog"second part of the wierdass dual prim primitiveSocketListenOnPort which was warped by some demented evil person determined to twist the very nature of reality"	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketListenOnPortBacklog'		parameters: #(Oop SmallInteger SmallInteger).	s _ self socketValueOf: socket.	self sqSocket: s ListenOnPort: port BacklogSize: backlog.! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:53'!primitiveSocket: socket receiveDataBuf: array start: startIndex count: count 	| s byteSize arrayBase bufStart bytesReceived |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketReceiveDataBufCount'		parameters: #(Oop Oop SmallInteger SmallInteger ).	s _ self socketValueOf: socket.	"buffer can be any indexable words or bytes object"	interpreterProxy success: (interpreterProxy isWordsOrBytes: array).	(interpreterProxy isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	interpreterProxy success: (startIndex >= 1			and: [count >= 0 and: [startIndex + count - 1 <= (interpreterProxy slotSizeOf: array)]]).	interpreterProxy failed		ifFalse: ["Note: adjust bufStart for zero-origin indexing"			arrayBase _ self cCoerce: (interpreterProxy firstIndexableField: array)						to: 'int'.			bufStart _ arrayBase + (startIndex - 1 * byteSize).			bytesReceived _ self						sqSocket: s						ReceiveDataBuf: bufStart						Count: count * byteSize].	^ (bytesReceived // byteSize) asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:54'!primitiveSocket: socket sendData: array start: startIndex count: count 	| s byteSize arrayBase bufStart bytesSent |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketSendDataBufCount'		parameters: #(Oop Oop SmallInteger SmallInteger ).	s _ self socketValueOf: socket.	"buffer can be any indexable words or bytes object except CompiledMethod "	interpreterProxy success: (interpreterProxy isWordsOrBytes: array).	(interpreterProxy isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	interpreterProxy success: (startIndex >= 1			and: [count >= 0 and: [startIndex + count - 1 <= (interpreterProxy slotSizeOf: array)]]).	interpreterProxy failed		ifFalse: ["Note: adjust bufStart for zero-origin indexing"			arrayBase _ self cCoerce: (interpreterProxy firstIndexableField: array)						to: 'int'.			bufStart _ arrayBase + (startIndex - 1 * byteSize).			bytesSent _ self						sqSocket: s						SendDataBuf: bufStart						Count: count * byteSize].	^ (bytesSent // byteSize) asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:21'!primitiveSocketAbortConnection: socket	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketAbortConnection'		parameters: #(Oop).	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		self sqSocketAbortConnection: s]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:54'!primitiveSocketAcceptFrom: sockHandle rcvBufferSize: recvBufSize sndBufSize: sendBufSize semaIndex: semaIndex 	| socketOop s serverSocket |	self var: #s declareC: 'SocketPtr s'.	self var: #serverSocket declareC: 'SocketPtr serverSocket'.	self primitive: 'primitiveSocketAccept'		parameters: #(Oop SmallInteger SmallInteger SmallInteger ).	serverSocket _ self socketValueOf: sockHandle.	interpreterProxy failed		ifFalse: [socketOop _ interpreterProxy instantiateClass: interpreterProxy classByteArray indexableSize: self socketRecordSize.			s _ self socketValueOf: socketOop.			self				sqSocket: s				AcceptFrom: serverSocket				RecvBytes: recvBufSize				SendBytes: sendBufSize				SemaID: semaIndex].	^ socketOop! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:24'!primitiveSocketCloseConnection: socket	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketCloseConnection'		parameters: #(Oop).	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		self sqSocketCloseConnection: s]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 10:30'!primitiveSocketConnectionStatus: socket	| s status |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketConnectionStatus'		parameters: #(Oop).	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		status _ self sqSocketConnectionStatus: s].	^ status asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:55'!primitiveSocketCreateNetwork: netType type: socketType receiveBufferSize: recvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	| socketOop s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketCreate'		parameters: #(SmallInteger SmallInteger SmallInteger SmallInteger SmallInteger).	socketOop _ interpreterProxy instantiateClass: interpreterProxy classByteArray					indexableSize: self socketRecordSize.	s _ self socketValueOf: socketOop.	self sqSocket: s CreateNetType: netType SocketType: socketType		RecvBytes: recvBufSize SendBytes: sendBufSize SemaID: semaIndex.	^socketOop! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 12:09'!primitiveSocketDestroy: socket	| s |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketDestroy'		parameters: #(Oop).	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		self sqSocketDestroy: s]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/18/2000 12:11'!primitiveSocketError: socket	| s err |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketError'		parameters: #(Oop).	s _ self socketValueOf: socket.	interpreterProxy failed ifFalse: [		err _ self sqSocketError: s].	^err asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:37'!primitiveSocketLocalAddress: socket	| s addr |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketLocalAddress'		parameters: #(Oop).	s _ self socketValueOf: socket.	addr _ self sqSocketLocalAddress: s.	^self intToNetAddress: addr! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:39'!primitiveSocketLocalPort: socket	| s port |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketLocalPort'		parameters: #(Oop).	s _ self socketValueOf: socket.	port _ self sqSocketLocalPort: s.	^port asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:42'!primitiveSocketReceiveDataAvailable: socket	| s dataIsAvailable |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketReceiveDataAvailable'		parameters: #(Oop).	s _ self socketValueOf: socket.	dataIsAvailable _ self sqSocketReceiveDataAvailable: s.	^dataIsAvailable asBooleanObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:52'!primitiveSocketRemoteAddress: socket	| s addr |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketRemoteAddress'		parameters: #(Oop).	s _ self socketValueOf: socket.	addr _ self sqSocketRemoteAddress: s.	^self intToNetAddress: addr! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 11:54'!primitiveSocketRemotePort: socket	| s port |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketRemotePort'		parameters: #(Oop).	s _ self socketValueOf: socket.	port _ self sqSocketRemotePort: s.	^port asSmallIntegerObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 17:20'!primitiveSocketSendDone: socket	| s done |	self var: #s declareC: 'SocketPtr s'.	self primitive: 'primitiveSocketSendDone'		parameters: #(Oop).	s _ self socketValueOf: socket.	done _ self sqSocketSendDone: s.	^done asBooleanObj! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 2/22/2000 17:26'!socketRecordSize	"Return the size of a Smalltalk socket record in bytes."	^ self cCode: 'sizeof(SQSocket)' inSmalltalk: [12]! !!SocketPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:55'!socketValueOf: socketOop 	"Return a pointer to the first byte of of the socket record within the  	given Smalltalk object, or nil if socketOop is not a socket record."	| socketIndex |	self returnTypeC: 'SQSocket *'.	interpreterProxy success: ((interpreterProxy isBytes: socketOop)			and: [(interpreterProxy byteSizeOf: socketOop)					= self socketRecordSize]).	interpreterProxy failed		ifTrue: [^ nil]		ifFalse: [socketIndex _ self cCoerce: (interpreterProxy firstIndexableField: socketOop)						to: 'int'.			^ self cCode: '(SQSocket *) socketIndex']! !!SocketPlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:22'!headerFile^'/* squeak socket record; see sqMacNetwork.c for details *//* module initialization/shutdown */int socketInit(void);int socketShutdown(void);typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* 	ar 7/16/1999: New primitives for accept().	Note: If accept() calls are not supported simply make the calls fail	and the old connection style will be used */void	sqSocketListenOnPortBacklogSize(SocketPtr s, int port, int backlogSize);void	sqSocketAcceptFromRecvBytesSendBytesSemaID(			SocketPtr s, SocketPtr serverSocket,			int recvBufSize, int sendBufSize, int semaIndex);'! !!SoundPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:54'!initialiseModule	self export: true.	^self cCode: 'soundInit()' inSmalltalk:[true]! !!SoundPlugin methodsFor: 'initialize-release' stamp: 'ar 5/12/2000 16:55'!shutdownModule	self export: true.	^self cCode: 'soundShutdown()' inSmalltalk:[true]! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 3/24/2000 18:30'!primitiveSoundAvailableSpace	"Returns the number of sample frames of available sound output buffer space."	| frames |	self primitive: 'primitiveSoundAvailableSpace'.	frames _ self cCode: 'snd_AvailableSpace()'.  "-1 if sound output not started"	interpreterProxy success: frames >= 0.	^frames asPositiveIntegerObj! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 2/24/2000 18:18'!primitiveSoundGetRecordingSampleRate	"Return a float representing the actual sampling rate during recording. Fail if not currently recording."	| rate |	self var: #rate declareC: 'double rate'.	self primitive: 'primitiveSoundGetRecordingSampleRate'.	rate _ self cCode: 'snd_GetRecordingSampleRate()'.  "fail if not recording"	^rate asFloatObj! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 3/24/2000 18:30'!primitiveSoundInsertSamples: frameCount from: buf leadTime: leadTime 	"Insert a buffer's worth of sound samples into the currently playing  	buffer. Used to make a sound start playing as quickly as possible. The  	new sound is mixed with the previously buffered sampled."	"Details: Unlike primitiveSoundPlaySamples, this primitive always starts  	with the first sample the given sample buffer. Its third argument  	specifies the number of samples past the estimated sound output buffer  	position the inserted sound should start. If successful, it returns the  	number of samples inserted."	| framesPlayed |	self primitive: 'primitiveSoundInsertSamples'		parameters: #(SmallInteger WordArray SmallInteger ).	interpreterProxy success: frameCount <= (interpreterProxy slotSizeOf: buf cPtrAsOop).	interpreterProxy failed		ifFalse: [framesPlayed _ self cCode: 'snd_InsertSamplesFromLeadTime(frameCount, (int)buf, leadTime)'.			interpreterProxy success: framesPlayed >= 0].	^ framesPlayed asPositiveIntegerObj! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 3/24/2000 18:31'!primitiveSoundPlaySamples: frameCount from: buf startingAt: startIndex 	"Output a buffer's worth of sound samples."	| framesPlayed |	self primitive: 'primitiveSoundPlaySamples'		parameters: #(SmallInteger WordArray SmallInteger ).	interpreterProxy success: (startIndex >= 1 and: [startIndex + frameCount - 1 <= (interpreterProxy slotSizeOf: buf cPtrAsOop)]).	interpreterProxy failed		ifFalse: [framesPlayed _ self cCode: 'snd_PlaySamplesFromAtLength(frameCount, (int)buf, startIndex - 1)'.			interpreterProxy success: framesPlayed >= 0].	^ framesPlayed asPositiveIntegerObj! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 3/24/2000 18:31'!primitiveSoundPlaySilence	"Output a buffer's worth of silence. Returns the number of sample frames played."	| framesPlayed |	self primitive: 'primitiveSoundPlaySilence'.	framesPlayed _ self cCode: 'snd_PlaySilence()'.  "-1 if sound output not started"	interpreterProxy success: framesPlayed >= 0.	^framesPlayed asPositiveIntegerObj! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 3/24/2000 18:31'!primitiveSoundRecordSamplesInto: buf startingAt: startWordIndex 	"Record a buffer's worth of 16-bit sound samples."	| bufSizeInBytes samplesRecorded |	self primitive: 'primitiveSoundRecordSamples'		parameters: #(WordArray SmallInteger ).	interpreterProxy failed		ifFalse: [bufSizeInBytes _ (interpreterProxy slotSizeOf: buf cPtrAsOop) * 4.			interpreterProxy success: (startWordIndex >= 1 and: [startWordIndex - 1 * 2 < bufSizeInBytes])].	interpreterProxy failed ifFalse: [samplesRecorded _ self cCode: 'snd_RecordSamplesIntoAtLength((int)buf, startWordIndex - 1, bufSizeInBytes)'].	^ samplesRecorded asPositiveIntegerObj! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 3/21/2000 16:39'!primitiveSoundSetRecordLevel: level 	"Set the sound input recording level."	self primitive: 'primitiveSoundSetRecordLevel'		parameters: #(SmallInteger ).	interpreterProxy failed ifFalse: [self cCode: 'snd_SetRecordLevel(level)']! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 2/25/2000 14:58'!primitiveSoundStartBufferSize: bufFrames rate: samplesPerSec stereo: stereoFlag	"Start the double-buffered sound output with the given buffer size, sample rate, and stereo flag."	self primitive: 'primitiveSoundStart'		parameters: #(SmallInteger SmallInteger Boolean).	interpreterProxy success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag, 0)')! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 2/25/2000 12:57'!primitiveSoundStartBufferSize: bufFrames rate: samplesPerSec stereo: stereoFlag semaIndex: semaIndex	"Start the double-buffered sound output with the given buffer size, sample rate, stereo flag, and semaphore index."	self primitive: 'primitiveSoundStartWithSemaphore'		parameters: #(SmallInteger SmallInteger Boolean SmallInteger).	interpreterProxy success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag, semaIndex)')! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 2/25/2000 12:55'!primitiveSoundStartRecordingDesiredSampleRate: desiredSamplesPerSec stereo: stereoFlag semaIndex: semaIndex	"Start recording sound with the given parameters."	self primitive: 'primitiveSoundStartRecording'		parameters: #(SmallInteger Boolean SmallInteger).	self cCode: 'snd_StartRecording(desiredSamplesPerSec, stereoFlag, semaIndex)'! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 2/25/2000 12:58'!primitiveSoundStop	"Stop double-buffered sound output."	self primitive: 'primitiveSoundStop'.	self cCode: 'snd_Stop()'.  "leave rcvr on stack"! !!SoundPlugin methodsFor: 'primitives' stamp: 'TPR 2/25/2000 12:58'!primitiveSoundStopRecording	"Stop recording sound."	self primitive: 'primitiveSoundStopRecording'.	self cCode: 'snd_StopRecording()'.  "leave rcvr on stack"! !!SoundPlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:23'!headerFile^'/* SoundPlugin.h - header for Sound Plugins :-) tim@sumeru.stanford.edu *//* module initialization/shutdown */int soundInit(void);int soundShutdown(void);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);'! !Matrix2x3Plugin removeSelector: #m23PrimitiveComposeMatrix!Matrix2x3Plugin removeSelector: #m23PrimitiveInvertPoint!Matrix2x3Plugin removeSelector: #m23PrimitiveInvertRectInto!Matrix2x3Plugin removeSelector: #m23PrimitiveIsIdentity!Matrix2x3Plugin removeSelector: #m23PrimitiveIsPureTranslation!Matrix2x3Plugin removeSelector: #m23PrimitiveTransformPoint!Matrix2x3Plugin removeSelector: #m23PrimitiveTransformRectInto!InterpreterSimulator removeSelector: #initBBOpTable!Interpreter removeSelector: #showDisplayBits!FloatArrayPlugin class removeSelector: #moduleName!FloatArrayPlugin removeSelector: #primitiveFloatArrayAddFloatArray!FloatArrayPlugin removeSelector: #primitiveFloatArrayAddScalar!FloatArrayPlugin removeSelector: #primitiveFloatArrayAt!FloatArrayPlugin removeSelector: #primitiveFloatArrayAtPut!FloatArrayPlugin removeSelector: #primitiveFloatArrayDivFloatArray!FloatArrayPlugin removeSelector: #primitiveFloatArrayDivScalar!FloatArrayPlugin removeSelector: #primitiveFloatArrayDotProduct!FloatArrayPlugin removeSelector: #primitiveFloatArrayEqual!FloatArrayPlugin removeSelector: #primitiveFloatArrayHash!FloatArrayPlugin removeSelector: #primitiveFloatArrayMulFloatArray!FloatArrayPlugin removeSelector: #primitiveFloatArrayMulScalar!FloatArrayPlugin removeSelector: #primitiveFloatArraySubFloatArray!FloatArrayPlugin removeSelector: #primitiveFloatArraySubScalar!FilePlugin initialize!!FilePlugin reorganize!('initialize-release' initialiseModule shutdownModule)('file primitives' fileRecordSize fileValueOf: primitiveFileAtEnd primitiveFileClose primitiveFileDelete primitiveFileGetPosition primitiveFileOpen primitiveFileRead primitiveFileRename primitiveFileSetPosition primitiveFileSize primitiveFileWrite setMacFile:Type:AndCreator:)('directory primitives' asciiDirectoryDelimiter makeDirEntryName:size:createDate:modDate:isDir:fileSize: primitiveDirectoryCreate primitiveDirectoryDelete primitiveDirectoryDelimitor primitiveDirectoryLookup primitiveDirectorySetMacTypeAndCreator)!FFTPlugin class removeSelector: #moduleName!BitBltSimulation removeSelector: #setInterpreter:!BitBltSimulation removeSelector: #targetForm!InterpreterPlugin subclass: #BitBltSimulation	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight sourceBits sourcePitch sourcePixSize destBits destPitch destPixSize pixPerWord bitCount skew mask1 mask2 preload nWords destMask hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH srcWidth srcHeight destWidth destHeight halftoneHeight noSource noHalftone halftoneBase colorMap sourceAlpha cmBitsPerColor srcBitShift dstBitShift scanStart scanStop scanString scanRightX scanStopArray scanDisplayFlag scanXTable stopCode bitBltOop affectedL affectedR affectedT affectedB opTable maskTable ditherMatrix4x4 ditherThresholds16 ditherValues16 hasSurfaceLock warpSrcShift warpSrcMask warpAlignShift warpAlignMask warpBitShiftTable cmDeltaBits cmRedMask cmBlueMask cmGreenMask cmRedShift cmBlueShift cmGreenShift '	classVariableNames: 'AllOnes BBClipHeightIndex BBClipWidthIndex BBClipXIndex BBClipYIndex BBColorMapIndex BBDestFormIndex BBDestXIndex BBDestYIndex BBHalftoneFormIndex BBHeightIndex BBLastIndex BBRuleIndex BBSourceFormIndex BBSourceXIndex BBSourceYIndex BBWarpBase BBWidthIndex BBXTableIndex BinaryPoint CrossedX EndOfRun FixedPt1 FormBitsIndex FormDepthIndex FormHeightIndex FormWidthIndex OpTable OpTableSize '	poolDictionaries: ''	category: 'VMConstruction-Interpreter'!BalloonEnginePlugin removeSelector: #gePrimitiveAddBezier!BalloonEnginePlugin removeSelector: #gePrimitiveAddBezierShape!BalloonEnginePlugin removeSelector: #gePrimitiveAddBitmapFill!BalloonEnginePlugin removeSelector: #gePrimitiveAddCompressedShape!BalloonEnginePlugin removeSelector: #gePrimitiveAddGradientFill!BalloonEnginePlugin removeSelector: #gePrimitiveAddLine!BalloonEnginePlugin removeSelector: #gePrimitiveAddOval!BalloonEnginePlugin removeSelector: #gePrimitiveAddPolygon!BalloonEnginePlugin removeSelector: #gePrimitiveAddRect!BalloonEnginePlugin removeSelector: #gePrimitiveGetBezierStats!BalloonEngineBase removeSelector: #gePrimitiveAbortProcessing!BalloonEngineBase removeSelector: #gePrimitiveAddActiveEdgeEntry!BalloonEngineBase removeSelector: #gePrimitiveChangedActiveEdgeEntry!BalloonEngineBase removeSelector: #gePrimitiveCopyBuffer!BalloonEngineBase removeSelector: #gePrimitiveDisplaySpanBuffer!BalloonEngineBase removeSelector: #gePrimitiveDoProfileStats!BalloonEngineBase removeSelector: #gePrimitiveFinishedProcessing!BalloonEngineBase removeSelector: #gePrimitiveGetAALevel!BalloonEngineBase removeSelector: #gePrimitiveGetClipRect!BalloonEngineBase removeSelector: #gePrimitiveGetCounts!BalloonEngineBase removeSelector: #gePrimitiveGetDepth!BalloonEngineBase removeSelector: #gePrimitiveGetFailureReason!BalloonEngineBase removeSelector: #gePrimitiveGetOffset!BalloonEngineBase removeSelector: #gePrimitiveGetTimes!BalloonEngineBase removeSelector: #gePrimitiveInitializeBuffer!BalloonEngineBase removeSelector: #gePrimitiveInitializeProcessing!BalloonEngineBase removeSelector: #gePrimitiveMergeFillFrom!BalloonEngineBase removeSelector: #gePrimitiveNeedsFlush!BalloonEngineBase removeSelector: #gePrimitiveNeedsFlushPut!BalloonEngineBase removeSelector: #gePrimitiveNextActiveEdgeEntry!BalloonEngineBase removeSelector: #gePrimitiveNextFillEntry!BalloonEngineBase removeSelector: #gePrimitiveNextGlobalEdgeEntry!BalloonEngineBase removeSelector: #gePrimitiveRegisterExternalEdge!BalloonEngineBase removeSelector: #gePrimitiveRegisterExternalFill!BalloonEngineBase removeSelector: #gePrimitiveRenderImage!BalloonEngineBase removeSelector: #gePrimitiveRenderScanline!BalloonEngineBase removeSelector: #gePrimitiveSetAALevel!BalloonEngineBase removeSelector: #gePrimitiveSetClipRect!BalloonEngineBase removeSelector: #gePrimitiveSetColorTransform!BalloonEngineBase removeSelector: #gePrimitiveSetDepth!BalloonEngineBase removeSelector: #gePrimitiveSetEdgeTransform!BalloonEngineBase removeSelector: #gePrimitiveSetOffset!InterpreterPlugin subclass: #BalloonEngineBase	instanceVariableNames: 'workBuffer objBuffer getBuffer aetBuffer spanBuffer engine formArray engineStopped geProfileTime dispatchedValue dispatchReturnValue objUsed doProfileStats copyBitsFn loadBBFn '	classVariableNames: 'EdgeInitTable EdgeStepTable FillTable WideLineFillTable WideLineWidthTable '	poolDictionaries: 'BalloonEngineConstants '	category: 'VMConstruction-Plugins'!