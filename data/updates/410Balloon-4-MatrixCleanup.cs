'From Squeak 2.2 of Sept 23, 1998 on 16 November 1998 at 3:04:18 am'!!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/15/1998 23:42'!addMorphFront: aMorph fromWorldPosition: wp	self addMorphFront: aMorph.	aMorph position: (self transformFromWorld globalPointToLocal: wp)! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44'!boundsInWorld	owner ifNil: [^ bounds].	^ (owner transformFrom: self world) localBoundsToGlobal: bounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44'!fullBoundsInWorld	owner ifNil: [^ self fullBounds].	^ (owner transformFrom: self world) localBoundsToGlobal: self fullBounds.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42'!pointFromWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) globalPointToLocal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:43'!pointInWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) localPointToGlobal: aPoint.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 11/15/1998 23:41'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		newOwner _ self dropTargetFor: m event: evt.		newOwner ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		morphToDrop _ newOwner morphToDropFrom: m. 		morphToDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm globalPointToLocal: self position.		morphToDrop position: localPt + (morphToDrop position - self position).		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!MorphicEvent methodsFor: 'mouse' stamp: 'ar 11/15/1998 23:42'!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform globalPointToLocal: cursorPoint)! !!MovieMorph methodsFor: 'menu' stamp: 'ar 11/15/1998 23:42'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!PluggableListMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:45'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) localBoundsToGlobal: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableListMorphOfMany methodsFor: 'all' stamp: 'ar 11/15/1998 23:45'!drawOn: aCanvas	| onMorph |	super drawOn: aCanvas.	1 to: list size do:  "NOTE: should be optimized to only visible morphs"		[:index |		(model listSelectionAt: index) ifTrue:			[onMorph _ scroller submorphs at: index.			aCanvas fillRectangle:				(((scroller transformFrom: self) localBoundsToGlobal: onMorph bounds)						intersect: scroller bounds)				color: color darker]]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'ar 11/15/1998 23:45'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!SketchMorph methodsFor: 'menu' stamp: 'ar 11/15/1998 23:42'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld globalPointToLocal: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!TextMorph methodsFor: 'anchors' stamp: 'ar 11/15/1998 23:42'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	| i |	self addMorphFront: aMorph.	i _ (self paragraph characterBlockAtPoint: (self transformFromWorld globalPointToLocal: wp))		stringIndex.	self paragraph replaceFrom: i to: i-1		with: (Text string: '*' attribute: (TextAnchor new anchoredMorph: aMorph))		displaying: false.	self fit! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue: [^ mList].	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:44'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds, and to translate, rotate and scale as appropriate."	| sourceQuad warp innerRect patchRect subCanvas offsetCanvas start |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	transform isPureTranslation ifTrue:		[^ super fullDrawOn: aCanvas].	self drawOn: aCanvas.	self hasSubmorphs ifFalse: [^ self].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ self innerBounds.	patchRect _ transform globalBoundsToLocal:					(aCanvas clipRect intersect: innerRect).	sourceQuad _ (transform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.	warp cellSize: smoothing.  "installs a colormap if smoothing > 1"	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (aCanvas depth = 1 and: [aCanvas shadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		i=1	ifTrue: [subCanvas setShadowDrawing; stipple: Color black.					warp combinationRule: Form erase]			ifFalse: [aCanvas shadowDrawing ifTrue:					[subCanvas setShadowDrawing; stipple: aCanvas stipple].					warp combinationRule: Form paint].		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		submorphs reverseDo: [:m | m fullDrawOn: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!TransformMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:44'!fullDrawOn: aCanvas without: stopMorph andStopThere: stopThere	"Like fullDrawOn:, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns true if it has hit stopMorph, and should stop."	| clippingCanvas sourceQuad warp innerRect patchRect subCanvas offsetCanvas stopped patchForm |	(aCanvas isVisible: self bounds) ifFalse: [^ false].	self drawOn: aCanvas.	transform isPureTranslation	ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo:			[:m | m == stopMorph				ifTrue: [stopThere ifTrue: [^ true]]				ifFalse: [(m fullDrawOn: clippingCanvas								without: stopMorph								andStopThere: stopThere)							ifTrue: [^ true]]].		^ false]	ifFalse:		[innerRect _ self innerBounds.		"Render the submorphs visible in the clipping rectangle, as patchForm"		patchRect _ 			(transform globalBoundsToLocal: (aCanvas clipRect intersect: innerRect))			intersect:			(Rectangle merging: (self submorphs collect: [:m | m fullBounds])).		subCanvas _ FormCanvas extent: patchRect extent depth: aCanvas depth.		offsetCanvas _ subCanvas copyOffset: patchRect topLeft negated.		stopped _ false.		submorphs reverseDo:			[:m | stopped ifFalse:				["If we have not hit stopMorph..."				(m == stopMorph  "and this submorph is not stopMorph"					or: ["Then display it"						m fullDrawOn: offsetCanvas							without: stopMorph							andStopThere: stopThere])					ifTrue: ["We hit stopMorph here or below, so..."							stopped _ stopThere]]].		patchForm _ subCanvas form.		"Now do a warping blt of the patchForm onto the incoming canvas"		sourceQuad _ (transform sourceQuadFor: innerRect)						collect: [:p | p - patchRect topLeft].		warp _ aCanvas warpFrom: sourceQuad toRect: innerRect.		warp cellSize: smoothing;  "installs a colormap if smoothing > 1"			sourceForm: patchForm;			warpBits.		^ stopped]! !!TransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42'!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullBounds containsPoint: (transform globalPointToLocal: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !!TransformMorph methodsFor: 'change reporting' stamp: 'ar 11/15/1998 23:45'!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNil: [^ self].	^ owner invalidRect: ((transform localBoundsToGlobal: damageRect) intersect: bounds)! !!TransformationMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 23:43'!referencePosition	^ transform localPointToGlobal: self renderedMorph referencePosition! !!TransformationMorph methodsFor: 'change reporting' stamp: 'ar 11/15/1998 23:45'!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ (transform localBoundsToGlobal:					(Rectangle merging:						(self submorphs collect: [:m | m fullBounds])))				expandBy: 1].	super layoutChanged! !