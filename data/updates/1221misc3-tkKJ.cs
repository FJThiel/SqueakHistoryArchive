'From Squeak 2.4c of May 10, 1999 on 27 May 1999 at 4:27:10 pm'!!MethodFinder methodsFor: 'initialize' stamp: 'tk 5/27/1999 16:03'!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) "| |"Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"adding"  growSize"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asIRCLowercase asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf fromPacked:	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet" valueOfHtmlEntity:"accessing" byteAt: endsWithDigit findAnySubStr:startingAt: findBetweenSubStrs: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: includesSubString: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: skipAnySubStr:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: crc16 endsWith: endsWithAnyOf: match: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padded:to:with:"converting" asByteArray asDate asDisplayText asFileName asHtml asLegalSelector asPacked asParagraph asText asTime asUnHtml asUrl asUrlRelativeTo: capitalized compressWithTable: contractTo: correctAgainst: encodeForHTTP initialInteger integerAtBeginning keywords quoted sansPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes truncateWithElipsisTo: withBlanksTrimmed withFirstCharacterDownshifted withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits withoutTrailingBlanks"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable replaceHtmlCharRefs unescapePercents withInternetLineEndings withSqueakLineEndings withoutQuoting"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: translateToLowercase) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "system primitives" isInfix isKeyword isPvtSelector) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" evalStrings "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce addLast:times: repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print: printHtml:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo:		) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" key nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: dist: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: fromRgbTriplet: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other" colorNames indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses _ #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls _ Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1 ) (at:modify: 2 ) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 ) (ifKindOf:thenDo: 2 ) (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (contains: 1 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sortBy: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (scopeHas:ifTrue: 2 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (bindWithTemp: 1 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray]."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 5/18/1999 14:49'!load: dataWithAnswers	"Find a function that takes the data and gives the answers.  Odd list entries are data for it, even ones are the answers. ""  (MethodFinder new) load: #( (4 3) 7  (-10 5) -5  (-3 11) 8);		findMessage  "| fixed |data _ Array new: dataWithAnswers size // 2.1 to: data size do: [:ii | data at: ii put: (dataWithAnswers at: ii*2-1)].answers _ Array new: data size.1 to: answers size do: [:ii | answers at: ii put: (dataWithAnswers at: ii*2)].fixed _ false.data do: [:list | 	(list isKindOf: SequenceableCollection) ifFalse: [		^ self inform: 'first and third items are not Arrays'].	list withIndexDo: [:arg :ind | 			arg == #true ifTrue: [list at: ind put: true.  fixed _ true].			arg == #false ifTrue: [list at: ind put: false.  fixed _ true].			]].answers withIndexDo: [:arg :ind | 			arg == #true ifTrue: [answers at: ind put: true.  fixed _ true].			arg == #false ifTrue: [answers at: ind put: false.  fixed _ true].			].fixed ifTrue: [self inform: '#(true false) are Symbols, not Booleans.  Next time use { true. false }'].argMap _ (1 to: data first size) asArray.data do: [:list | list size = argMap size ifFalse: [		self inform: 'data arrays must all be the same size']].argMap size > 4 ifTrue: [self inform: 'No more than a receiver and three arguments allowed'].	"Really only test receiver and three args." thisData _ data copy.mapStage _ mapList _ nil.! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 5/27/1999 16:09'!verify	"Test a bunch of examples"	"	MethodFinder new verify    "Approved ifNil: [self initialize].	"Sets of allowed selectors"(MethodFinder new load: #( (0) 0  (30) 0.5  (45) 0.707106  (90) 1)	) searchForOne = '(data1 degreeSin) ' ifFalse: [self error: 'should have found it'].(MethodFinder new load:  { { true. [3]. [4]}. 3.  { false. [0]. [6]}. 6}	) searchForOne = '(data1 ifTrue: data2 ifFalse: data3) ' ifFalse: [		self error: 'should have found it'].(MethodFinder new load: #((1) true (2) false (5) true (10) false)	) searchForOne = '(data1 odd) ' ifFalse: [self error: 'should have found it'].		"will correct the date type of #true, and complain"(MethodFinder new load: #((4 2) '2r100'   (255 16) '16rFF'    (14 8) '8r16')	) searchForOne = 		'(data1 radix: data2) (data1 printStringBase: data2) (data1 storeStringBase: data2) '			  ifFalse: [self error: 'should have found it'].	(MethodFinder new load: {{Point x: 3 y: 4}. 4.  {Point x: 1 y: 5}. 5}	) searchForOne = '(data1 y) ' ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #(('abcd') $a  ('TedK') $T)	) searchForOne = '(data1 first) (data1 anyOne) ' ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #(('abcd' 1) $a  ('Ted ' 3) $d )	) searchForOne = '(data1 at: data2) (data1 atPin: data2) (data1 atWrap: data2) ' 		ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #(((12 4 8)) 24  ((1 3 6)) 10 )	) searchForOne = '(data1 sum) '   ifFalse: [self error: 'should have found it'].			"note extra () needed for an Array object as an argument"(MethodFinder new load: #((14 3) 11  (-10 5) -15  (4 -3) 7)	) searchForOne = '(data1 - data2) ' ifFalse: [self error: 'should have found it'].(MethodFinder new load: #((4) 4  (-10) 10 (-3) 3 (2) 2 (-6) 6 (612) 612)	) searchForOne = '(data1 abs) ' ifFalse: [self error: 'should have found it'].(MethodFinder new load: {#(4 3). true.  #(-7 3). false.  #(5 1). true.  #(5 5). false}	) searchForOne = '(data1 > data2) ' ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((5) 0.2   (2) 0.5)	) searchForOne = '(data1 reciprocal) ' ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((12 4 8) 2  (1 3 6) 2  (5 2 16) 8)	) searchForOne = ''     " '(data3 / data2) ' See ExpressionFinder for leaving out args"  		ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((0.0) 0.0  (1.5) 0.997495  (0.75) 0.681639)	) searchForOne = '(data1 sin) '   ifFalse: [self error: 'should have found it'].	(MethodFinder new load: #((7 5) 2   (4 5) 4   (-9 4) 3)	) searchForOne = '(data1 \\ data2) '   ifFalse: [self error: 'should have found it'].	! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 5/18/1999 14:46'!makeAllMaps 	"Make a giant list of all permutations of the args.  To find the function, we will try these permutations of the input data.  receiver, args."	| ii |	mapList _ Array new: argMap size factorial.	ii _ 1.	argMap permutationsDo: [:perm |		mapList at: ii put: perm copy.		ii _ ii + 1].	mapStage _ 1.	"about to be bumped"! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 5/24/1999 16:31'!permuteArgs 	"Run through ALL the permutations.  First one was as presented."	data first size <= 1 ifTrue: [^ false].	"no other way"	mapList ifNil: [self makeAllMaps].	mapStage _ mapStage + 1.	mapStage > mapList size ifTrue: [^ false].	argMap _ mapList at: mapStage.	self mapData.	^ true	! !!MethodFinder methodsFor: 'search' stamp: 'tk 5/27/1999 16:15'!exceptions	"Handle some very slippery selectors.	asSymbol -- want to be able to produce it, but do not want to make every string submitted into a Symbol!!" 	| aSel |	answers first class == Symbol ifFalse: [^ self].	thisData first first class == String ifFalse: [^ self].	aSel _ #asSymbol.	(self testPerfect: aSel) ifTrue: [		selector add: aSel.		expressions nextPut: $(.		expressions nextPutAll: 'data', argMap first printString.		aSel keywords doWithIndex: [:key :ind |			expressions nextPutAll: ' ',key.			(key last == $:) | (key first isLetter not)				ifTrue: [expressions nextPutAll: ' data', 					(argMap at: ind+1) printString]].		expressions nextPut: $); space].! !!MethodFinder methodsFor: 'search' stamp: 'tk 5/27/1999 15:20'!findMessage	"Control the search."	| selFinder |	data do: [:alist | 		(alist isKindOf: SequenceableCollection) ifFalse: [			^ 'first and third items are not Arrays']].	Approved ifNil: [self initialize].	"Sets of allowed selectors"	expressions _ WriteStream on: (String new: 400).	self search: true.	"multi"	Smalltalk isMorphic ifTrue: [		((selFinder _ World submorphs first model) isKindOf: SelectorBrowser) ifTrue: [			selFinder selectorList: selector asSortedArray]].	selector isEmpty ifTrue: [^ 'no single method does that function'].	^ expressions contents			! !!MethodFinder methodsFor: 'search' stamp: 'tk 5/18/1999 14:56'!searchForOne	"Look for and return just one answer"	expressions _ WriteStream on: (String new: 400).	self search: false.	"non-multi"	^ expressions contents			! !!MethodFinder methodsFor: 'search' stamp: 'tk 5/27/1999 16:16'!simpleSearch	"Run through first arg's class' selectors, looking for one that works."| class supers listOfLists |self exceptions.class _ thisData first first class."Cache the selectors for the receiver class"(class == cachedClass and: [cachedArgNum = ((argMap size) - 1)]) 	ifTrue: [listOfLists _ cachedSelectorLists]	ifFalse: [supers _ class withAllSuperclasses.		listOfLists _ OrderedCollection new.		supers do: [:cls |			listOfLists add: (cls selectorsWithArgs: (argMap size) - 1)].		cachedClass _ class.		cachedArgNum _ (argMap size) - 1.		cachedSelectorLists _ listOfLists].listOfLists do: [:selectorList |	selectorList do: [:aSel |		(selector includes: aSel) ifFalse: [			((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [				(self testPerfect: aSel) ifTrue: [					selector add: aSel.					expressions nextPut: $(.					expressions nextPutAll: 'data', argMap first printString.					aSel keywords doWithIndex: [:key :ind |						expressions nextPutAll: ' ',key.						(key last == $:) | (key first isLetter not)							ifTrue: [expressions nextPutAll: ' data', 								(argMap at: ind+1) printString]].					expressions nextPut: $); space.					]]]]].! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 5/26/1999 14:14'!byExample	^ 'Type a fragment of a selector in the top pane.  Accept it.	Or, use an example to find a method in the system.  Type receiver, args, and answer in the top pane witht periods between the items.  3. 4. 7Or, in this pane, use examples to find a method in the system.  Select the line of code and choose "print it".  	MethodFinder methodFor: #( (4 3) 7  (0 5) 5  (5 5) 10).This will discover (data1 + data2)You supply inputs and answers and the system will find the method.  Each inner array is a list of inputs.  It contains the receiver and zero or more arguments.  For Booleans and any computed arguments, use brace notation.	MethodFinder methodFor: { {1. 3}. true.  {20. 10}. false}.This will discover the expression (data1 < data2)	MethodFinder methodFor: { {''29 Apr 1999'' asDate}. ''Thursday''.  		{''30 Apr 1999'' asDate}. ''Friday'' }.Will discover the expression (data1 weekday)Receiver and arguments do not have to be in the right order.  See MethodFinder.verify for more examples.'! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 5/26/1999 14:07'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens |	contents _ aString.	classList _ #().  classListIndex _ 0.	selectorIndex _ 0.	tokens _ contents asString findTokens: ' '.	selectorList _ Cursor wait showWhile: [		tokens size = 1 			ifTrue: [(Symbol selectorsContaining: contents asString) asSortedArray]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'tk 5/27/1999 14:52'!quickList	"Compute the selectors for the single example of receiver and args, in the very top pane"	| data array ccc where |	ccc _ data _ contents asString.	"delete trailing period"	data last isSeparator ifTrue: [data _ data allButLast].	data last isSeparator ifTrue: [data _ data allButLast].	data last = $. ifTrue: [data _ data allButLast].	"enclose args in one more level"	where _ 0.	data size to: 1 by: -1 do: [:ii |		(data at: ii) = $. ifTrue: [			(data at: ii+1) isDigit ifFalse: [				where = 0 ifTrue: [where _ ii]]]].	where = 0 ifTrue: [^ self inform: 'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment' withCRs].	data _ data copyReplaceFrom: where to: where-1 with: '}'.		"enclose args in { }"	array _ Compiler evaluate: '{{', data, '}'.		"eval"	MethodFinder methodFor: array.	contents _ ccc.	"restore top pane, since MethodFinder clears it"	^ selectorList! !!SmallInteger methodsFor: 'system primitives' stamp: 'tk 5/14/1999 20:54'!nextInstance	"SmallIntegers can't be enumerated this way.  There are a finite number of them from from (SmallInteger minVal) to (SmallInteger maxVal), but you'll have to enumerate them yourself with:	(SmallInteger minVal) to: (SmallInteger maxVal) do: [:integer | <your code here>].	"	self shouldNotImplement ! !"Postscript:Force reinitialization of Approved and other lists of selectors."MethodFinder classPool at: #Approved put: nil.!