'From Squeak2.8alpha of 6 February 2000 [latest update: #2098] on 13 May 2000 at 5:56:50 pm'!"Change Set:		PLG1-CodeGenDate:			13 May 2000Author:			Tim Rowledge & Andreas RaabPluginisation part 1: Changes a lot of stuff in the CCodeGenerator and fixes a bunch of translation related methods." !Object subclass: #CCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations methods variablesSetCache headerFiles isCPP postProcesses pluginPrefix extraDefs '	classVariableNames: 'UseRightShiftForDivide '	poolDictionaries: ''	category: 'VMConstruction-Translation to C'!Object subclass: #TMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete export static '	classVariableNames: 'CaseStatements '	poolDictionaries: ''	category: 'VMConstruction-Translation to C'!!Object methodsFor: 'translation support' stamp: 'ar 2/21/2000 00:42'!static: aBoolean	"For translation only; noop when running in Smalltalk."! !!CCodeGenerator methodsFor: 'public' stamp: 'TPR 3/2/2000 11:22'!addAllClassVarsFor: aClass	"Add the class variables for the given class (and its superclasses) to the code base as constants."	| allClasses |	allClasses _ aClass withAllSuperclasses.	allClasses do: [:c | self addClassVarsFor: c].! !!CCodeGenerator methodsFor: 'public' stamp: 'TPR 3/2/2000 11:26'!addClass: aClass 	"Add the variables and methods of the given class to the code base."	| source |	self checkClassForNameConflicts: aClass.	self addClassVarsFor: aClass.	"ikp..."	self addPoolVarsFor: aClass.	variables addAll: aClass instVarNames.	'Adding Class ' , aClass name , '...'		displayProgressAt: Sensor cursorPoint		from: 0		to: aClass selectors size		during: [:bar | aClass selectors				doWithIndex: 					[:sel :i | 					bar value: i.					source _ aClass sourceCodeAt: sel.					self addMethod: ((Compiler new							parse: source							in: aClass							notifying: nil)							asTranslationMethodOfClass: self translationMethodClass)]]! !!CCodeGenerator methodsFor: 'public' stamp: 'TPR 3/2/2000 11:26'!addClassVarsFor: aClass	"Add the class variables for the given class to the code base as constants."	aClass classPool associationsDo:		[:assoc | constants at: assoc key put: (TConstantNode new setValue: assoc value)]! !!CCodeGenerator methodsFor: 'public' stamp: 'TPR 3/2/2000 11:25'!addPoolVarsFor: aClass 	"Add the pool variables for the given class to the code base as constants."	aClass sharedPools do: [:pool | pool associationsDo: [:assoc | constants at: assoc key put: (TConstantNode new setValue: assoc value)]]! !!CCodeGenerator methodsFor: 'public' stamp: 'ar 5/9/2000 11:56'!codeStringForPrimitives: classAndSelectorList 	| sel aClass source s verbose meth methodList |	self initialize.	classAndSelectorList do: 		[:classAndSelector | 		aClass _ Smalltalk at: (classAndSelector at: 1).		self addAllClassVarsFor: aClass."TPR - should pool vars also be added here?"		"find the method in either the class or the metaclass"		sel _ classAndSelector at: 2.		(aClass includesSelector: sel)			ifTrue: [source _ aClass sourceCodeAt: sel]			ifFalse: [source _ aClass class sourceCodeAt: sel].		"compile the method source and convert to a suitable translation 		method "		meth _ (Compiler new					parse: source					in: aClass					notifying: nil)					asTranslationMethodOfClass: self translationMethodClass.		"if this method is supposed to be a primitive (rather than a helper 		routine), add assorted prolog and epilog items"		meth primitive > 0 ifTrue: [meth preparePrimitiveInClass: aClass].		"for old-style array accessing: 		meth covertToZeroBasedArrayReferences."		meth replaceSizeMessages.		self addMethod: meth].	"method preparation"	verbose _ false.	self prepareMethods.	verbose		ifTrue: 			[self printUnboundCallWarnings.			self printUnboundVariableReferenceWarnings.			Transcript cr].	"code generation"	self doInlining: true.	s _ ReadWriteStream on: (String new: 1000).	methodList _ methods asSortedCollection: [:m1 :m2 | m1 selector < m2 selector].	self emitCHeaderForPrimitivesOn: s.	self emitCVariablesOn: s.	self emitCFunctionPrototypes: methodList on: s.	methodList do: [:m | m emitCCodeOn: s generator: self].	^ s contents! !!CCodeGenerator methodsFor: 'public' stamp: 'ar 5/9/2000 12:24'!exportedPrimitiveNames	"Return an array of all exported primitives"	^methods select:[:m| m export] thenCollect:[:m| m selector copyWithout: $:].! !!CCodeGenerator methodsFor: 'public' stamp: 'ar 2/21/2000 14:58'!isTranslatingLocally	"Return true if the CG has been setup to translate a plugin locally."	^pluginPrefix notNil! !!CCodeGenerator methodsFor: 'public' stamp: 'ar 2/21/2000 14:58'!pluginPrefix	"Return the plugin prefix when generating local plugins.	Local plugins are plugins compiled with the main interpreter	source but are not included (nor inlined into) interp.c"	^pluginPrefix! !!CCodeGenerator methodsFor: 'public' stamp: 'ar 2/21/2000 14:58'!pluginPrefix: aString	"Set the plugin prefix when generating local plugins.	Local plugins are plugins compiled with the main interpreter	source but are not included (nor inlined into) interp.c"	pluginPrefix _ aString.! !!CCodeGenerator methodsFor: 'public' stamp: 'ar 5/9/2000 14:53'!storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Store C code for this code base on the given file."	| stream realName |	"(self isTranslatingLocally and:[(fileName beginsWith: 'sq') not])		ifTrue:[realName _ 'sq', fileName]		ifFalse:[realName _ fileName]."	stream _ CrLfFileStream newFileNamed: fileName.	stream ifNil: [Error signal: 'Could not open C code file: ', realName].	self emitCCodeOn: stream doInlining: inlineFlag doAssertions: assertionFlag.	stream close! !!CCodeGenerator methodsFor: 'inlining' stamp: 'ar 5/10/2000 15:40'!pruneUnreachableMethods	"Remove any methods that are not reachable. Retain methods needed by the BitBlt operation table, primitives, plug-ins, or interpreter support code." 	| retain |	"Build a set of selectors for methods that should be output even though they have no apparent callers. Some of these are stored in tables for indirect lookup, some are called by the C support code or by primitives."	retain _ BitBltSimulation opTable asSet.	#(checkedLongAt: fullDisplayUpdate interpret nullCompilerHook printCallStack readImageFromFile:HeapSize:StartingAt: setCompilerInitialized: success:		"Windows needs the following two for startup and debug"		readableFormat: getCurrentBytecode		"Acorn needs this for display setup"		splObj:)		do: [:sel | retain add: sel].	InterpreterProxy organization categories do: [:cat |		((cat ~= 'initialize') and: [cat ~= 'private']) ifTrue: [			retain addAll: (InterpreterProxy organization listAtCategoryNamed: cat)]].	"Remove all the unreachable methods that aren't retained for the reasons above."	self unreachableMethods do: [:sel |		(retain includes: sel) ifFalse: [			methods removeKey: sel ifAbsent: []]].! !!CCodeGenerator methodsFor: 'utilities' stamp: 'TPR 3/2/2000 11:45'!translationMethodClass	"return the class used to produce C translation methods from MethodNodes"	^TMethod! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ar 2/21/2000 14:58'!cFunctionNameFor: aSelector	"Create a C function name from the given selector by omitting colons	and prefixing with the plugin name if the method is exported."	| meth |	pluginPrefix == nil ifTrue:[^aSelector copyWithout: $:].	meth _ methods at: aSelector ifAbsent:[nil].	(meth notNil and:[meth export])		ifTrue:[^pluginPrefix,'_', (aSelector copyWithout: $:)]		ifFalse:[^aSelector copyWithout: $:].! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ar 2/21/2000 19:53'!emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose methodList |	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	assertionFlag ifFalse: [ self removeAssertions ].	self doInlining: inlineFlag.	"code generation"	methodList _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderOn: aStream.	self emitCVariablesOn: aStream.	self emitCFunctionPrototypes: methodList on: aStream.'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |	methodList doWithIndex: [ :m :i | bar value: i.		m emitCCodeOn: aStream generator: self.]].! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ar 5/9/2000 11:58'!emitCFunctionPrototypes: methodList on: aStream 	"Store prototype declarations for all non-inlined methods on the given stream."	| exporting |	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	isCPP ifTrue: [aStream nextPutAll: 'extern "C" {'; cr].	exporting _ false.	methodList do: [:m | 		m export			ifTrue: [exporting					ifFalse: 						[aStream nextPutAll: '#pragma export on'; cr.						exporting _ true]]			ifFalse: [exporting					ifTrue: 						[aStream nextPutAll: '#pragma export off'; cr.						exporting _ false]].		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr].	exporting ifTrue: [aStream nextPutAll: '#pragma export off'; cr].	isCPP ifTrue: [aStream nextPutAll: '}'; cr]! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'TPR 4/10/2000 10:56'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int stackIntegerValue(int);extern int successFlag;/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ar 5/9/2000 14:50'!emitCVariablesOn: aStream	"Store the global variable declarations on the given stream."	| varString |	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection do: [ :var |		(self isGeneratingPluginCode and:[self isTranslatingLocally])			ifTrue:[aStream nextPutAll:'static '].		varString _ var asString.		(variableDeclarations includesKey: varString) ifTrue: [			aStream nextPutAll: (variableDeclarations at: varString), ';'; cr.		] ifFalse: [			"default variable declaration"			aStream nextPutAll: 'int ', varString, ';'; cr.		].	].	aStream cr.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'TPR 2/29/2000 18:55'!translate: fileName all: classes doInlining: inlineFlag	"Time millisecondsToRun: [		InterpreterPlugin translate:'all.c' all:{FloatArrayPlugin. FFTPlugin} doInlining: true.		Smalltalk beep]"	| cg theClass |	cg _ self codeGeneratorClass new initialize.	classes do:[:cls|		theClass _ cls.		theClass initialize.		[theClass == InterpreterPlugin] whileFalse:[			cg addClass: theClass.			theClass declareCVarsIn: cg.			theClass _ theClass superclass]].	(classes includes: InterpreterPlugin) ifFalse:[		cg addClass: InterpreterPlugin.		InterpreterPlugin declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 5/11/2000 22:30'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	^self translate: fileName doInlining: inlineFlag locally: false.! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 5/12/2000 00:35'!translate: fileName doInlining: inlineFlag locally: localFlag	"Time millisecondsToRun: [		FloatArrayPlugin translate: 'SqFloatArray.c' doInlining: true.		Smalltalk beep]"	| cg theClass fullName fd |	fullName _ self baseDirectoryName.	fd _ FileDirectory on: fullName.	localFlag ifFalse:[		(fd directoryExists: self moduleName) 			ifFalse:[fd createDirectory: self moduleName].		fd _ fd on: (fd fullNameFor: self moduleName)].	fullName _ fd fullNameFor: fileName.	self initialize.	self headerFile ifNotNil:[		(CrLfFileStream newFileNamed: (fd fullNameFor: self moduleName,'.h'))			nextPutAll: self headerFile;			close].	cg _ self codeGeneratorClass new initialize.	localFlag ifTrue:[cg pluginPrefix: self moduleName].	"Add an extra declaration for module name"	cg var: #moduleName declareC:'const char *moduleName = "', self moduleName,'"'.	theClass _ self.	[theClass == Object] whileFalse:[		cg addClass: theClass.		theClass declareCVarsIn: cg.		theClass _ theClass superclass].	cg storeCodeOnFile: fullName doInlining: inlineFlag.	^cg! !!InterpreterPlugin class methodsFor: 'translation' stamp: 'ar 2/20/2000 23:28'!translateLocally	^self translate: (self moduleName,'.c') doInlining: true locally: true! !!InterpreterPlugin class methodsFor: 'private' stamp: 'TPR 2/29/2000 18:54'!codeGeneratorClass	"return the appropriate class of code generator for this kind ofplugin"	^PluggableCodeGenerator! !!B3DEnginePlugin class methodsFor: 'translation' stamp: 'ar 5/13/2000 02:02'!translateB3D	"B3DEnginePlugin translateB3D"	"Translate all the basic plugins into one support module 	and write the C sources for the rasterizer."	| cg |	cg _ PluggableCodeGenerator new initialize.	cg var: #moduleName declareC:'const char *moduleName = "', self moduleName,'"'.	{InterpreterPlugin. B3DEnginePlugin. B3DTransformerPlugin. B3DVertexBufferPlugin. B3DShaderPlugin. B3DClipperPlugin. B3DPickerPlugin. B3DRasterizerPlugin} do: 		[:theClass | 		theClass initialize.		cg addClass: theClass.		theClass declareCVarsIn: cg].	cg storeCodeOnFile: self moduleName , '.c' doInlining: true.	"	cg storeCodeOnFile: '/tmp/Ballon3D.c' doInlining: true."	B3DRasterizerPlugin writeSupportCode: true! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'di 11/15/1998 16:22'!cCodeForMiscPrimitives	"Return the contents of the miscellaneous primitives file, which is generated via automatic translation to C."	^ CCodeGenerator new codeStringForPrimitives: #(		(Bitmap compress:toByteArray:)		(Bitmap decompress:fromByteArray:at:)		(Bitmap encodeBytesOf:in:at:)		(Bitmap encodeInt:in:at:)		(String compare:with:collated:)		(String translate:from:to:table:)			(String findFirstInString:inSet:startingAt:)		(String indexOfAscii:inString:startingAt:)		(String findSubstring:in:startingAt:matchTable:)		(SampledSound convert8bitSignedFrom:to16Bit:))! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'ar 5/13/2000 15:04'!writeSupportFiles	"Store into this image's folder the C sources files required to support the interpreter on all platforms. This method also generates the code for the sound synthesis and other primitives translated from Smalltalk to C. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeSupportFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakVirtualMachineHeaderFile	onFileNamed: 'sqVirtualMachine.h'.	self storeString: self squeakVirtualMachineFile	onFileNamed: 'sqVirtualMachine.c'.	self storeString: self squeakNamedPrimsFile onFileNamed:'sqNamedPrims.c'.	self storeString: self squeakADPCMCodecPrimsFile	 onFileNamed: 'sqADPCMPrims.c'.	self storeString: self squeakFilePrimsFile	onFileNamed:  'sqFilePrims.c'.	self storeString: self squeakGSMCodecPluginFile	onFileNamed: 'sqGSMCodecPlugin.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives		onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.! !!MethodNode methodsFor: 'C translation' stamp: 'TPR 2/29/2000 18:12'!asTranslationMethodOfClass: aClass 	^ aClass new		setSelector: selectorOrFalse		args: arguments		locals: encoder tempsAndBlockArgs		block: block		primitive: primitive! !!PluggableCodeGenerator methodsFor: 'C code generator' stamp: 'TPR 3/7/2000 18:55'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/* Default EXPORT macro that does nothing (see comment in sq.h): */#define EXPORT(returnType) returnType/* Do not include the entire sq.h file but just those parts needed. *//*  The virtual machine proxy definition */#include "sqVirtualMachine.h"/* Configuration options */#include "sqConfig.h"/* Platform specific definitions */#include "sqPlatformSpecific.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C */'; cr; cr.	"Additional header files"	headerFiles do:[:hdr|		aStream nextPutAll:'#include '; nextPutAll: hdr; cr].	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Proxy Functions ***/#define stackValue(i) (interpreterProxy->stackValue(i))#define stackIntegerValue(i) (interpreterProxy->stackIntegerValue(i))#define successFlag (!!interpreterProxy->failed())#define success(bool) (interpreterProxy->success(bool))#define arrayValueOf(oop) (interpreterProxy->arrayValueOf(oop))#define checkedIntegerValueOf(oop) (interpreterProxy->checkedIntegerValueOf(oop))#define fetchArrayofObject(idx,oop) (interpreterProxy->fetchArrayofObject(idx,oop))#define fetchFloatofObject(idx,oop) (interpreterProxy->fetchFloatofObject(idx,oop))#define fetchIntegerofObject(idx,oop) (interpreterProxy->fetchIntegerofObject(idx,oop))#define floatValueOf(oop) (interpreterProxy->floatValueOf(oop))#define pop(n) (interpreterProxy->pop(n))#define pushInteger(n) (interpreterProxy->pushInteger(n))#define sizeOfSTArrayFromCPrimitive(cPtr) (interpreterProxy->sizeOfSTArrayFromCPrimitive(cPtr))#define storeIntegerofObjectwithValue(idx,oop,value) (interpreterProxy->storeIntegerofObjectwithValue(idx,oop,value))/*** Proxy Variables ***/struct VirtualMachine *interpreterProxy;'.	aStream cr.! !!PluggableCodeGenerator methodsFor: 'public' stamp: 'TPR 2/29/2000 19:32'!codeStringForPrimitives: classAndSelectorList	"add the code for the setInterpreter() to the list"	^super codeStringForPrimitives: (classAndSelectorList copyWith: #(InterpreterPlugin setInterpreter:))! !!TMethod methodsFor: 'initialization' stamp: 'ar 5/9/2000 12:22'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	export _ self extractExportDirective.	static _ self extractStaticDirective.	self removeFinalSelfReturn.	self recordDeclarations.! !!TMethod methodsFor: 'accessing' stamp: 'ar 5/9/2000 12:13'!isStatic	^static ifNil:[false].! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:12'!argConversionExprFor: varName stackIndex: stackIndex 	"Return the parse tree for an expression that fetches and converts the 	primitive argument at the given stack offset."	| exprList decl stmtList |	exprList _ OrderedCollection new.	(declarations includesKey: varName)		ifTrue: 			[decl _ declarations at: varName.			(decl includes: $*)				ifTrue: 					["array"					exprList add: varName , ' _ ', self vmNameString, ' arrayValueOf: (', self vmNameString, ' stackValue: (' , stackIndex printString , '))'.					exprList add: varName , ' _ ' , varName , ' - 1']				ifFalse: 					["must be a double"					(decl findString: 'double' startingAt: 1)						= 0 ifTrue: [self error: 'unsupported type declaration in a primitive method'].					exprList add: varName , ' _ ', self vmNameString, ' stackFloatValue: ' , stackIndex printString]]		ifFalse: ["undeclared variables are taken to be integer"			exprList add: varName , ' _ ', self vmNameString, ' stackIntegerValue: ' , stackIndex printString].	stmtList _ OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:12'!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr _ 'rcvr _ ', self vmNameString, ' stackValue: (', args size printString, ')'.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:19'!fixUpReturns: argCount postlog: postlog	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	| newStmts |	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			newStmts _ OrderedCollection new: 100.			node statements do: [:stmt |				stmt isReturn					ifTrue: [						(stmt expression isSend and:						 ['primitiveFail' = stmt expression selector])							ifTrue: [  "failure return"								newStmts addLast: stmt expression.								newStmts addLast: (TReturnNode new									setExpression: (TVariableNode new setName: 'null'))]							ifFalse: [  "normal return"								newStmts addAll: postlog.								newStmts addAll: (self popArgsExpr: argCount + 1).								newStmts addLast: (TSendNode new									setSelector: #pushInteger:									receiver: (TVariableNode new setName: self vmNameString)									arguments: (Array with: stmt expression)).								newStmts addLast: (TReturnNode new									setExpression: (TVariableNode new setName: 'null'))]]					ifFalse: [						newStmts addLast: stmt]].			node setStatements: newStmts asArray]].! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:12'!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| exprList decl stmtList |	exprList _ OrderedCollection new.	(declarations includesKey: varName) ifTrue: [		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [  "array"			exprList add:				(varName, ' _ ', self vmNameString, ' fetchArray: ', instIndex printString, ' ofObject: rcvr').			exprList add: (varName, ' _ ', varName, ' - 1').		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add:				(varName, ' _ ', self vmNameString, ' fetchFloat: ', instIndex printString, ' ofObject: rcvr').		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add:			(varName, ' _ ', self vmNameString, ' fetchInteger: ', instIndex printString, ' ofObject: rcvr').	].	stmtList _ OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:13'!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr _ '', self vmNameString, ' storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.	^ self statementsFor: expr varName: varName! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:13'!popArgsExpr: argCount	"Return the parse tree for an expression that pops the given number of arguments from the stack."	| expr |	expr _ '', self vmNameString, ' pop: ', argCount printString.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/3/2000 10:12'!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	"ar 10/7/1998 -- 	Add the export directive for translated primitives.				--	Use the name of the primitive if it's called by name."	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	primArgCount _ args size.	"add receiver fetch and arg conversions to prolog"	prolog addAll: self fetchRcvrExpr.	1 to: args size do: [:argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add success check to postlog"	postlog addAll: self checkSuccessExpr.	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	prolog addAll: self checkSuccessExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [self error: 'local name conflicts with instance variable name'].	endsWithReturn _ self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	"Check for pluggable primitive"	primitive = 117 		ifTrue:[selector _ ((aClass includesSelector: selector)					ifTrue: [aClass compiledMethodAt: selector]					ifFalse: [aClass class compiledMethodAt: selector]) literals first at: 2.				export _ true]		ifFalse:[selector _ 'prim', aClass name, selector].	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [			postlog addAll: (self popArgsExpr: primArgCount).			parseTree setStatements: prolog, parseTree statements, postlog].! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 19:08'!replaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	| argExpr |	parseTree nodesDo: [:n |		(n isSend and: [n selector = #size]) ifTrue: [			argExpr _ TSendNode new				setSelector: #+				receiver: n receiver				arguments: (Array with: (TConstantNode new setValue: 1)).			n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TVariableNode new setName: self vmNameString)				arguments: (Array with: argExpr)]].! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 2/29/2000 18:47'!statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s _ WriteStream on: ''.	s nextPutAll: 'temp'; cr; cr; tab.	self printTempsAndVar: varName on: s.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil)			asTranslationMethodOfClass: self class) statements! !!TMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:08'!vmNameString	"return the string to use as the vm name in code generated for this method"	^'self'! !!TMethod methodsFor: 'transformations' stamp: 'ar 2/20/2000 23:33'!extractStaticDirective	"Scan the top-level statements for an inlining directive of the form:		self static: <boolean>	 and remove the directive from the method body. Return the argument of the directive or true if there is no static directive."	| result newStatements |	result _ true.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #static:]) ifTrue: [			result _ stmt args first name ~= 'false'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TMethod methodsFor: 'C code generation' stamp: 'ar 5/9/2000 12:13'!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	export 		ifTrue:[aStream nextPutAll:'EXPORT('; nextPutAll: returnType; nextPutAll:') ']		ifFalse:[(aCodeGen isGeneratingPluginCode and:[self isStatic]) 					ifTrue:[aStream nextPutAll:'static '].				aStream nextPutAll: returnType; space].	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TMethod methodsFor: 'printing' stamp: 'TPR 3/2/2000 18:36'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' (', selector, ')'.! !!TMethod methodsFor: 'private' stamp: 'TPR 2/29/2000 18:45'!printTempsAndVar: varName on: aStream 	"add the required temps and the varname to the stream"	aStream nextPutAll: '| rcvr stackPointer successFlag ' , varName , ' |';	 cr! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'TPR 2/25/2000 16:21'!generateAsIfVar: aNode on: aStream indent: anInteger	| cName fName class index |	cName _ String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	fName _ aNode args second value.	index _ class allInstVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	aStream 		nextPutAll: 'interpreterProxy->fetchPointerofObject(';		nextPutAll: (index - 1) asString;		nextPutAll: ','.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'TPR 2/25/2000 16:41'!generateAsIfVarAsValue: aNode on: aStream indent: anInteger	| cName fName class index fetchNode |	cName _ String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	fName _ aNode args second value.	index _ class allInstVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	fetchNode _ TSendNode new		setSelector: #fetchPointer:ofObject:		receiver: (TVariableNode new setName: 'interpreterProxy')		arguments: (Array			with: (TConstantNode new setValue: index - 1)			with: aNode receiver).	cName _ aNode args third nameOrValue.	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'third arg must identify class'].	class ccg: self generateCoerceToValueFrom: fetchNode on: aStream! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'TPR 2/25/2000 16:41'!generateAsIfVarPut: aNode on: aStream indent: anInteger	| cName fName class index |	cName _ String streamContents: 		[:scStr | self emitCExpression: aNode args first on: scStr].	class _ Smalltalk 		at: (cName asSymbol) 		ifAbsent: [nil].	(class isNil not and: [class isBehavior]) ifFalse: 		[^self error: 'first arg must identify class'].	fName _ aNode args second value.	index _ class allInstVarNames		indexOf: fName		ifAbsent: [^self error: 'second arg must be instVar'].	aStream 		nextPutAll: 'interpreterProxy->storePointerofObjectwithValue(';		nextPutAll: (index - 1) asString;		nextPutAll: ','.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ','.	self emitCExpression: aNode args third on: aStream.	aStream nextPutAll: ')'.! !!TestCodeGenerator methodsFor: 'translating builtins' stamp: 'TPR 4/24/2000 18:33'!generateCPtrAsOop: aNode on: aStream indent: anInteger	aStream nextPutAll: '((int) ('.	self emitCExpression: aNode receiver on: aStream.	aStream nextPutAll: ') -4)'.! !!TestCodeGenerator methodsFor: 'as yet unclassified' stamp: 'TPR 2/29/2000 18:14'!translationMethodClass	"return the class used to produce C translation methods from MethodNodes"	^TestTMethod! !!TestInterpreterPlugin class methodsFor: 'private' stamp: 'TPR 2/29/2000 18:54'!codeGeneratorClass	"return the appropriate class of code generator for this kind ofplugin"	^TestCodeGenerator! !!TestTMethod methodsFor: 'initializing' stamp: 'ar 5/9/2000 12:22'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	export _ self extractExportDirective.	static _ self extractStaticDirective.	isPrimitive _ false.  "set to true only if you find a primtive direction."	suppressingFailureGuards _ self extractSuppressFailureGuardDirective.	self recordDeclarations.	self extractPrimitiveDirectives.! !!TestTMethod methodsFor: 'transforming' stamp: 'TPR 3/1/2000 20:21'!fixUpReturnOneStmt: stmt on: sStream	stmt isReturn ifFalse: [^sStream nextPut: stmt].	(stmt expression isSend and: ['primitiveFail' = stmt expression selector]) ifTrue: 		["failure return"		 sStream nextPut: stmt expression.		 sStream nextPut: self nullReturnExpr.		 ^nil].	(stmt expression isVariable and: ['nil' = stmt expression name]) ifTrue: 		["^ nil -- this is never right unless automatically generated"		 sStream nextPut: stmt.		 ^nil].	(stmt expression isVariable and: ['self' = stmt expression name]) ifTrue: 		["^ self"		 self generateFailureGuardOn: sStream.		 fullArgs isEmpty ifFalse:[ sStream nextPut: (self popExpr: fullArgs size)].		 sStream nextPut: self nullReturnExpr.		 ^nil].	(stmt expression isVariable | stmt expression isConstant | suppressingFailureGuards) ifTrue:		["^ variable or ^ constant or ^ expr without guardchecking"		 self generateFailureGuardOn: sStream.		 sStream nextPut: (self pop: fullArgs size + 1 thenReturnExpr: stmt expression).		 sStream nextPut: self nullReturnExpr.		 ^nil].	"^ expr with guardchecking"	sStream nextPut: (self assign: (self oopVariable: '_return_value') expression: stmt expression).	self generateFailureGuardOn: sStream.	sStream nextPut: (self pop: fullArgs size + 1 thenReturnExpr: (self oopVariable: '_return_value')).	sStream nextPut: self nullReturnExpr! !!TestTMethod methodsFor: 'transforming' stamp: 'TPR 3/2/2000 19:07'!replaceArraySizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive. Specialised version for generating primitives outside a plugin"	super replaceSizeMessages! !!TestTMethod methodsFor: 'transforming' stamp: 'acg 9/20/1999 14:04'!replaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	parseTree nodesDo: [:n |		(n isSend and: [n selector = #size]) ifTrue: [			n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TVariableNode new setName: 'interpreterProxy')				arguments: (Array with: n receiver)]].! !!TestTMethod methodsFor: 'specifying primitives' stamp: 'acg 12/15/1999 06:13'!extractPrimitiveDirectives	"Save selector in fullSelector and args in fullArgs.  Scan top-level statements for a directive of the form:		self				primitive: 	<string>or		self			primitive:	<string>			parameters: <list of class names>or		self			primitive:	<string>			parameters: <list of class names>			receiver: <class name>or an assignment of that expression to a local, and manipulate the state and parse tree accordingly."	parseTree setStatements: (Array streamContents:		[:sStream |			parseTree statements do:				[:stmt |				 (self primitiveDirectiveWasHandled: stmt on: sStream)					ifFalse: [sStream nextPut: stmt]]]).	isPrimitive 		ifTrue:			[export _ true.			 parseTree 				setStatements: self namedPrimitiveProlog, 								parseTree statements.			 self fixUpReturns.			 self replaceSizeMessages.			 ^true]		ifFalse: [self removeFinalSelfReturn].	^false! !!TestTMethod methodsFor: 'specifying primitives' stamp: 'TPR 3/1/2000 20:14'!handlePrimitiveDirective: aStmt on: sStream	isPrimitive _ true.	fullArgs _ args.	locals addAll: args.	args _ OrderedCollection new.	fullArgs with: parmSpecs do:		[:argName :spec |			declarations				at: argName				put: (spec ccgDeclareCForVar: argName)].	aStmt isAssignment ifTrue:		[declarations			at: aStmt variable name			put: (rcvrSpec ccgDeclareCForVar: aStmt variable name).		 sStream nextPutAll: (self			statementsFor:				(rcvrSpec					ccg:		TestCodeGenerator new					prolog:  [:expr | aStmt variable name, ' _ ', expr]					expr: 	aStmt variable name					index: 	(fullArgs size))			varName: '')].	"only add the failure guard if there are args or it is an assignment"	(fullArgs isEmpty not or:[aStmt isAssignment]) ifTrue:[self generateFailureGuardOn: sStream].	^true.! !!TestTMethod methodsFor: 'specifying primitives' stamp: 'TPR 2/10/2000 17:43'!isPrimitiveDirectiveSend: stmt		stmt isSend ifTrue:		[stmt selector = #primitive: ifTrue:			[^self primitive: 	stmt args first value				   parameters:	(Array new: args size withAll: #Oop)				   receiver:		#Oop].		 stmt selector = #primitive:parameters: ifTrue:			[^self primitive: 	stmt args first value				   parameters: 	stmt args second value				   receiver:		#Oop].		 stmt selector = #primitive:parameters:receiver: ifTrue:			[^self primitive:		stmt args first value				   parameters:	stmt args second value				   receiver:		stmt args third value].		^false].	^false.! !!TestTMethod methodsFor: 'private' stamp: 'TPR 3/2/2000 12:39'!printTempsAndVar: varName on: aStream 	"add the required temps and the varname to the stream"	aStream nextPutAll: '| '.	(#('rcvr' 'stackPointer' 'successFlag' 'interpreterProxy' ) reject: [:each | locals includes: each])		do: [:each | aStream nextPutAll: each;			 space].	(locals reject: [:each | each first = $_])		do: [:each | aStream nextPutAll: each;			 space]."don't add varName twice. Probably a deeper reason for this, but WTH. TPR"	(locals includes: varName) ifFalse:[aStream nextPutAll: varName].	aStream nextPutAll: '|';	 cr! !!TestTMethod methodsFor: 'primitive compilation' stamp: 'TPR 3/2/2000 16:07'!vmNameString	"return the string to use as the vm name in code generated for this method"	^'interpreterProxy'! !TestTMethod removeSelector: #statementsFor:varName:!TestInterpreterPlugin class removeSelector: #translate:all:doInlining:!TestInterpreterPlugin class removeSelector: #translate:doInlining:!TestCodeGenerator removeSelector: #addClass:!TestCodeGenerator removeSelector: #codeStringForPrimitives:!TMethod removeSelector: #pushIntegerResultExpr:!MethodNode removeSelector: #asTMethodFromClass:!MethodNode removeSelector: #asTestTMethodFromClass:!BitBltSimulator class removeSelector: #translate:doInlining:!BalloonEngineBase class removeSelector: #localTranslate:doInlining:!CCodeGenerator removeSelector: #emitCFunctionPrototypesOn:!Object subclass: #CCodeGenerator	instanceVariableNames: 'translationDict inlineList constants variables variableDeclarations methods variablesSetCache headerFiles pluginPrefix extraDefs postProcesses isCPP '	classVariableNames: 'UseRightShiftForDivide '	poolDictionaries: ''	category: 'VMConstruction-Translation to C'!