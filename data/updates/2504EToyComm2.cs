'From Squeak2.9alpha of 17 July 2000 [latest update: #2498] on 17 August 2000 at 4:05:53 pm'!"Change Set:		EToyComm2Date:			2 August 2000Author:			Bob ArningFeaturing audio chat based on i-Scream by Brian Payne and Jonathan Greene- added 'A' audio chat button to sender badge- added 'S' see another world button to sender badge- 'Share' button to ProjectNavigatorMoph to start sharing of this world via Nebraska- also: many of the requisite morphs can be obtained from the World/new morph/experimental menu- added user name and picture to remote hands in Nebraska- fixed scaling of ColorForms (as in the sender badge)- fixed filing out of #add-ed classes in ChangeSorter to file out current def rather than fat. Otherwise it was difficult to delete variables from #add-ed classes and make the deletion stick.- audio chat option 'transmit while recording' added- audio chat option 'hands-free talking' added- moved SoundRecorder class>>canRecordWhilePlaying to Preferences to allow better use of this option on platforms that support it.- modified Debugger to send 'Project resumeProcess: interruptedProcess' only if the interrupted process was the ui process. This corrrects an old problem where walkbacks in non-ui code would, if resumed, lead to there being no ui process. - reduced sampling rate on continuous speech in audio chat in order to reduce network traffic. Also dropped very quiet saounds for the same reason.- added backlog indicator to audio chat to show user if network is unable to keep up with continuous speech.- when talking in hands-free mode, the talk button flashes to remind user he is broadcasting.- some Nebraska improvements:--- improved caching of common forms on remote side--- changed painting background to solid white for speed--- added override to keep control while drawing (no interCyclePause)- changed stepping of embedded worlds to use #step rather than #allLowerWorldsDo:- modified SketchEditorMorph and PaintBoxMorph to support multiple hands painting at once.- on systems where sound is disabled, morphs or chats arriving will be signalled by a beep.- multi-user chat added- acceptOnCR toggle (default) added to chat window- added button disabling to Kim's general file loader------actual code below-----"EToyListenerMorph stopListening.!StringHolder subclass: #ChatNotes	instanceVariableNames: 'name notesIndex names notes recorder player sound isPlaying isRecording isSaving nameTextMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Audio-Chat'!ChatNotes class	instanceVariableNames: ''!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC sourceMap tempNames savedCursor isolationHead failedProject errorWasInUIProcess '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tools-Debugger'!Object subclass: #EToyIncomingMessage	instanceVariableNames: ''	classVariableNames: 'MessageHandlers '	poolDictionaries: ''	category: 'Morphic-Experimental'!Object subclass: #EToyPeerToPeer	instanceVariableNames: 'socket dataToSend communicatorMorph process ipAddress connectionQueue leftOverData remoteSocketAddress dataQueue '	classVariableNames: 'DEBUG PREVTICK '	poolDictionaries: ''	category: 'Network-EToy Communications'!FileList subclass: #FileList2	instanceVariableNames: 'showDirsInFileList currentDirectorySelected fileSelectionBlock optionalButtonSpecs modalView directoryChangeBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!EllipseMorph subclass: #AlertMorph	instanceVariableNames: 'onColor offColor myObjSock socketOwner '	classVariableNames: ''	poolDictionaries: ''	category: 'Audio-Chat'!SimpleButtonMorph subclass: #ChatButtonMorph	instanceVariableNames: 'actionDownSelector actionUpSelector labelDown labelUp '	classVariableNames: ''	poolDictionaries: ''	category: 'Audio-Chat'!ChatButtonMorph class	instanceVariableNames: ''!EToyCommunicatorMorph subclass: #AudioChatGUI	instanceVariableNames: 'mycodec myrecorder mytargetip myalert playOnArrival theConnectButton soundBlockNumber soundMessageID queueForMultipleSends transmitWhileRecording theTalkButton handsFreeTalking handsFreeTalkingFlashTime '	classVariableNames: 'DebugLog LiveMessages NewAudioMessages PlayOnArrival '	poolDictionaries: ''	category: 'Morphic-Experimental'!EToyChatOrBadgeMorph subclass: #EToyChatMorph	instanceVariableNames: 'listener receivingPane myForm recipientForm sendingPane acceptOnCR '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!AudioChatGUI class	instanceVariableNames: ''!EToyChatMorph subclass: #EToyMultiChatMorph	instanceVariableNames: 'targetIPAddresses '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!EToyChatOrBadgeMorph subclass: #EToySenderMorph	instanceVariableNames: 'userPicture '	classVariableNames: 'DEBUG '	poolDictionaries: ''	category: 'Morphic-Experimental'!Object subclass: #NebraskaDebug	instanceVariableNames: ''	classVariableNames: 'DEBUG Details '	poolDictionaries: ''	category: 'Morphic-Remote'!!NebraskaDebug commentStamp: '<historical>' prior: 0!BufferedCanvas enabled: false.BufferedCanvas enabled: true.CanvasEncoder beginCachingCanvasEncoder stopCachingNebraskaDebug beginStatsNebraskaDebug showStatsNebraskaDebug stopAndShowAllNebraskaDebug killStatsStringSocket showRatesSeenStringSocket clearRatesSeenNebraskaDebug showAndClearStats: #allStatsCanvasEncoder beginStatsCanvasEncoder showStatsCanvasEncoder killStatsNebraskaDebug showStats: #peerBytesSentNebraskaDebug showStats: #soundReductionTimeNebraskaDebug showStats: #FormEncodeTimesNebraskaDebug showStats: #SendReceiveStatsNebraskaDebug showStats: #sendDeltasNebraskaDebug showStats: #bigImageNebraskaDebug showStats: #sketchNebraskaDebug showStats: #addToOutBuf:----buffered off, painting 125kb/s, dragging 400kb/sbuffered on, painting 100kb/s, dragging 170kb/s!]style[(61 53 142 14 45 73 415)f1cblue;,f1cred;,f1cblack;,f1,f1cblack;,f1cblue;,f1cblack;!Model subclass: #NebraskaServer	instanceVariableNames: 'worldDepth world clients listenQueue '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!EmbeddedWorldBorderMorph subclass: #NetworkTerminalBorderMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!Morph subclass: #NetworkTerminalMorph	instanceVariableNames: 'connection decoder eventEncoder backgroundForm enteringHand '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Remote'!ImageMorph subclass: #OLDPaintBoxMorph	instanceVariableNames: 'action tool currentCursor thumbnail currentColor currentBrush colorMemory colorPatch stampHolder rotationTabForm scaleTabForm colorMemoryThin brushes focusMorph weakDependents '	classVariableNames: 'AllOffImage AllOnImage AllPressedImage OriginalBounds Prototype '	poolDictionaries: ''	category: 'Morphic-Support'!Morph subclass: #OLDSketchEditorMorph	instanceVariableNames: 'hostView stampForm palette ticksToDwell rotationCenter registrationPoint newPicBlock emptyPicBlock action paintingForm dimForm buff brush paintingFormPen formCanvas picToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton cumRot cumMag undoBuffer lastEvent currentNib enclosingPasteUpMorph forEachHand oldIVars '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!ImageMorph subclass: #PaintBoxMorph	instanceVariableNames: 'action tool currentCursor thumbnail currentColor currentBrush colorMemory colorPatch stampHolder rotationTabForm scaleTabForm colorMemoryThin brushes focusMorph weakDependents '	classVariableNames: 'AllOffImage AllOnImage AllPressedImage OriginalBounds Prototype '	poolDictionaries: ''	category: 'Morphic-Support'!Morph subclass: #SketchEditorMorph	instanceVariableNames: 'hostView stampForm canvasRectangle palette currentColor ticksToDwell rotationCenter registrationPoint newPicBlock emptyPicBlock action paintingForm dimForm buff brush paintingFormPen formCanvas picToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton strokeOrigin cumRot cumMag undoBuffer lastEvent currentNib enclosingPasteUpMorph forEachHand '	classVariableNames: 'SketchTimes '	poolDictionaries: ''	category: 'Morphic-Support'!SoundRecorder subclass: #ChatRecorder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Audio-Chat'!ChatRecorder class	instanceVariableNames: ''!Form subclass: #StaticForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!StaticForm commentStamp: '<historical>' prior: 0!An optimization for Nebraska - a StaticForm does not change once created so it may be cached on the remote end.!ObjectSocket subclass: #StringSocket	instanceVariableNames: 'numStringsInNextArray stringsForNextArray nextStringSize files startTime stringCounter socketWriterProcess outputQueue slowNetworkTime slowNetworkCount '	classVariableNames: 'MaxRatesSeen RecentSendHistory RunningSendCount '	poolDictionaries: ''	category: 'Network-ObjectSocket'!UpdatingThreePhaseButtonMorph subclass: #EtoyUpdatingThreePhaseButtonMorph	instanceVariableNames: ''	classVariableNames: 'CheckedForm MouseDownForm UncheckedForm '	poolDictionaries: ''	category: 'Morphic-Widgets'!Object subclass: #WorldState	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime lastCycleTime '	classVariableNames: 'CanSurrenderToOS DeferredUIMessages DisableDeferredUpdates LastCycleTime MinCycleLapse '	poolDictionaries: ''	category: 'Morphic-Worlds'!!AbstractSound methodsFor: 'volume' stamp: 'RAA 8/11/2000 11:51'!adjustVolumeTo: vol overMSecs: mSecs	"Adjust the volume of this sound to the given volume, a number in the range [0.0..1.0], over the given number of milliseconds. The volume will be changed a little bit on each sample until the desired volume is reached."	| newScaledVol |	self flag: #bob.		"I removed the upper limit to allow making sounds louder. hmm..."	newScaledVol _ (32768.0 * vol) truncated.	newScaledVol = scaledVol ifTrue: [^ self].	scaledVolLimit _ newScaledVol.	"scaledVolLimit > ScaleFactor ifTrue: [scaledVolLimit _ ScaleFactor]."	scaledVolLimit < 0 ifTrue: [scaledVolLimit _ 0].	mSecs = 0		ifTrue: [  "change immediately"			scaledVol _ scaledVolLimit.			scaledVolIncr _ 0]		ifFalse: [			scaledVolIncr _				((scaledVolLimit - scaledVol) * 1000) // (self samplingRate * mSecs)].! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'RAA 8/14/2000 14:22'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw the rectangle using the given attributes.	Note: This is a *very* simple implementation"	| bw pt |	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: bottomRightColor.	bottomRightColor = topLeftColor ifFalse: [		bw _ borderWidth asPoint.		pt _ r topLeft + (bw // 2).		self line: pt to: pt + ((r extent x - bw x)@0) width: borderWidth color: topLeftColor.		self line: pt to: pt + (0@(r extent y - bw y)) width: borderWidth color: topLeftColor.	].! !!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'RAA 8/15/2000 10:59'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| patchRect subCanvas |	self flag: #bob.		"added to Canvas in hopes it will work for Nebraska"	(aDisplayTransform isPureTranslation) ifTrue: [		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to aClipRect"	patchRect _ (aDisplayTransform globalBoundsToLocal: aClipRect) rounded.	patchRect area = 0 ifTrue: [^self]. 	"oh, well!!"	"Render the submorphs visible in the clipping rectangle, as patchForm"	subCanvas _ FormCanvas extent: patchRect extent depth: self depth.	self isShadowDrawing ifTrue: [		subCanvas shadowColor: self shadowColor	].	subCanvas 		translateBy: patchRect topLeft negated truncated		during: [ :offsetCanvas | aBlock value: offsetCanvas].	subCanvas form 		displayInterpolatedIn: (aClipRect translateBy: self origin) truncated		on: self form.! !!CanvasDecoder methodsFor: 'decoding' stamp: 'RAA 8/14/2000 13:41'!drawImage: command	| image point sourceRect rule cacheID cacheNew previousImage |	image := self class decodeImage: (command at: 2).	point := self class decodePoint: (command at: 3).	sourceRect := self class decodeRectangle: (command at: 4).	rule := self class decodeInteger: (command at: 5).	command size >= 7 ifTrue: [		cacheID _ self class decodeInteger: (command at: 6).		cacheNew _ (self class decodeInteger: (command at: 7)) = 1.		cacheID > 0 ifTrue: [			CachedForms ifNil: [CachedForms _ Array new: 100].			cacheNew ifTrue: [				CachedForms at: cacheID put: image			] ifFalse: [				previousImage _ CachedForms at: cacheID.				image ifNil: [					image _ previousImage				] ifNotNil: [					previousImage ifNotNil: [						image _ previousImage addDeltasFrom: image.					].					CachedForms at: cacheID put: image				].			].		].	].	self drawCommand: [ :c |		c image: image  at: point  sourceRect: sourceRect rule: rule	]! !!CanvasDecoder class methodsFor: 'decoding' stamp: 'RAA 8/14/2000 10:21'!decodeImage: string	| bitsStart depth width height bits rs numColors colorArray |	bitsStart _ string indexOf: $|.	bitsStart = 0 ifTrue: [^nil].	rs := ReadStream on: (string copyFrom: 1 to: bitsStart-1).	rs peek == $C ifTrue: [		rs next.		numColors _ Integer readFromString: (rs upTo: $,).		colorArray _ Array new: numColors.		1 to: numColors do: [ :i |			colorArray at: i put: (self decodeColor: (rs next: 12))		].	].	depth := Integer readFromString: (rs upTo: $,).	width :=  Integer readFromString: (rs upTo: $,).	height :=  Integer readFromString: (rs upToEnd).	bits _ Bitmap newFromStream: (		RWBinaryOrTextStream with: (string copyFrom: bitsStart+1 to: string size)	) binary reset.	colorArray ifNil: [		^Form extent: width@height depth: depth bits: bits	].	^(ColorForm extent: width@height depth: depth bits: bits)		colors: colorArray! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/14/2000 13:48'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	| cacheID cacheNew cacheReply formToSend cacheEntry t destRect visRect aFormArea |	"first if we are only going to be able to draw a small part of the form,	it may be faster just to send the part of the form that will actually show up"	aFormArea _ aForm boundingBox area.	aFormArea > 20000 ifTrue: [		destRect _ aPoint extent: sourceRect extent.		(destRect intersects: lastClipRect) ifFalse: [			^NebraskaDebug at: #bigImageSkipped add: {lastClipRect. aPoint. sourceRect extent}.		].		visRect _ destRect intersect: lastClipRect.		visRect area < (aFormArea // 20) ifTrue: [			"NebraskaDebug 				at: #bigImageReduced 				add: {lastClipRect. aPoint. sourceRect extent. lastTransform}."			formToSend _ aForm copy: (visRect translateBy: sourceRect origin - aPoint).			^self 				image: formToSend 				at: visRect origin 				sourceRect: formToSend boundingBox				rule: rule		].	].t _ Time millisecondsToRun: [	cacheID _ 0.	cacheNew _ 0.	formToSend _ aForm.	aFormArea > 1000 ifTrue: [		CachedObjects ifNotNil: [			(cacheReply _ self testCache: aForm) ifNotNil: [				cacheID _ cacheReply first.				cacheEntry _ cacheReply third.				cacheReply second ifTrue: [					cacheNew _ 1.				] ifFalse: [					cacheNew _ 0.					formToSend _ aForm isStatic 						ifTrue: [nil] 						ifFalse: [aForm deltaFrom: cacheEntry fourth].				].				cacheEntry at: 4 put: (aForm isStatic ifTrue: [aForm] ifFalse: [aForm deepCopy]).			].		].	].	self sendCommand: {		String with: CanvasEncoder codeImage.		self class encodeImage: formToSend.		self class encodePoint: aPoint.		self class encodeRectangle: sourceRect.		self class encodeInteger: rule.		self class encodeInteger: cacheID.		self class encodeInteger: cacheNew.	}.].	aFormArea > 100 ifTrue: [		NebraskaDebug at: #bigImage add: {lastClipRect. aPoint. sourceRect extent. t. cacheID. cacheNew}.	].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'RAA 8/14/2000 14:27'!line: pt1  to: pt2  width: w  color: c"Smalltalk at: #Q3 put: thisContext longStack."	self sendCommand: {		String with: CanvasEncoder codeLine.		self class encodePoint: pt1.		self class encodePoint: pt2.		self class encodeInteger: w.		self class encodeColor: c	}! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 8/14/2000 10:20'!encodeImage: form		| t answer |	form ifNil: [^''].	t _ Time millisecondsToRun: [answer _ form encodeForRemoteCanvas].	form boundingBox area > 5000 ifTrue: [		NebraskaDebug at: #FormEncodeTimes add: {t. form extent. answer size}	].			"answer size > 50000 ifTrue: [Smalltalk at: #Q2 put: thisContext longStack]."	^answer	"HandMorph>>restoreSavedPatchOn: is one culprit here"! !!CanvasEncoder class methodsFor: 'encoding' stamp: 'RAA 8/9/2000 16:11'!encodeRectangle: rectangle	| x y encoded cornerX cornerY |	x _ rectangle origin x asInteger.	y _ rectangle origin y asInteger.	cornerX _ rectangle corner x asInteger.	cornerY _ rectangle corner y asInteger.	CanvasEncoder at: 2 count:  1.	encoded := String new: 16.	encoded putInteger32: x at: 1.	encoded putInteger32: y at: 5.	encoded putInteger32: cornerX at: 9.	encoded putInteger32: cornerY at: 13.	^encoded! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 18:53'!cachingString	^CachedObjects ifNil: ['c'] ifNotNil: ['C']! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 14:18'!nameForCode: aStringOrChar	| ch |	ch _ (aStringOrChar isKindOf: String) ifTrue: [aStringOrChar first] ifFalse: [aStringOrChar].	ch == self codeBalloonRect ifTrue: [^'balloon rectangle'].	ch == self codeClip ifTrue: [^'clip'].	ch == self codeExtentDepth ifTrue: [^'codeExtentDepth'].	ch == self codeFont ifTrue: [^'codeFont'].	ch == self codeForce ifTrue: [^'codeForce'].	ch == self codeImage ifTrue: [^'codeImage'].	ch == self codeLine ifTrue: [^'codeLine'].	ch == self codeOval ifTrue: [^'codeOval'].	ch == self codePoly ifTrue: [^'codePoly'].	ch == self codeRect ifTrue: [^'codeRect'].	ch == self codeReleaseCache ifTrue: [^'codeReleaseCache'].	ch == self codeStencil ifTrue: [^'codeStencil'].	ch == self codeText ifTrue: [^'codeText'].	ch == self codeTransform ifTrue: [^'codeTransform'].	^'????'! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 14:18'!showStats"CanvasEncoder showStats"	| answer bucket |	SentTypesAndSizes ifNil: [^1 beep].	answer _ WriteStream on: String new.	SentTypesAndSizes keys asSortedCollection do: [ :each |		bucket _ SentTypesAndSizes at: each.		answer nextPutAll: each printString,' ',				bucket first printString,'  ',				bucket second asStringWithCommas,' ',				(self nameForCode: each); cr.	].	StringHolder new contents: answer contents; openLabel: 'send/receive stats'.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 17:22'!stopCaching	CachedObjects _ (1 to: 100) collect: [ :x | {WeakArray new: 1. nil. nil. nil}].! !!ChangeSet methodsFor: 'private' stamp: 'RAA 8/6/2000 11:49'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3'		].	].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass].! !!ChatNotes methodsFor: 'accessing' stamp: 'RAA 8/1/2000 17:59'!name	^name ifNil: [name _ '']! !!ChatNotes methodsFor: 'accessing' stamp: 'TBP 2/23/2000 21:07'!name: aString	name _ aString.	self changed: #name.! !!ChatNotes methodsFor: 'accessing' stamp: 'RAA 8/1/2000 18:01'!notesList		self flag: #why.	^names copy asArray! !!ChatNotes methodsFor: 'accessing' stamp: 'RAA 8/1/2000 18:02'!notesListIndex	^notesIndex ifNil: [notesIndex _ 0]! !!ChatNotes methodsFor: 'accessing' stamp: 'RAA 8/1/2000 18:02'!notesListIndex: index		notesIndex _ index = notesIndex ifTrue: [0] ifFalse: [index].	self name: (self notesList at: notesIndex ifAbsent: ['']).	self changed: #notesListIndex.! !!ChatNotes methodsFor: 'accessing' stamp: 'TBP 2/23/2000 21:07'!recorder	^recorder! !!ChatNotes methodsFor: 'button commands' stamp: 'RAA 8/1/2000 19:05'!record	self isRecording: true.	notesIndex = 0 ifFalse: [self notesListIndex: 0].	sound _ nil.	recorder clearRecordedSound.	recorder resumeRecording.! !!ChatNotes methodsFor: 'button commands' stamp: 'RAA 8/1/2000 18:03'!save	self isSaving: true.	notesIndex = 0		ifTrue: [self saveSound]		ifFalse: [self saveName].	self isSaving: false.! !!ChatNotes methodsFor: 'button commands' stamp: 'TBP 2/23/2000 21:07'!stop	recorder pause.	self isRecording: false! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:03'!isPlaying	^isPlaying ifNil: [isPlaying _ false]! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:04'!isPlaying: aBoolean	isPlaying = aBoolean ifTrue: [^self].	isPlaying _ aBoolean.	self changed: #isPlaying	! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:04'!isRecording	^isRecording ifNil: [isRecording _ false]! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:05'!isRecording: aBoolean		isRecording = aBoolean ifTrue: [^self].	isRecording _ aBoolean.	self changed: #isRecording	! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:05'!isSaving	^isSaving ifNil: [isSaving _ false]! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:05'!isSaving: aBoolean	isSaving = aBoolean ifTrue: [^self].	isSaving _ aBoolean.	self changed: #isSaving! !!ChatNotes methodsFor: 'testing' stamp: 'RAA 8/1/2000 18:05'!isStopped	^false! !!ChatNotes methodsFor: 'initialization' stamp: 'RAA 8/1/2000 18:05'!initialize	self loadNotes.	notesIndex _ 0.	recorder _ ChatRecorder new.	recorder initialize.! !!ChatNotes methodsFor: 'initialization' stamp: 'RAA 8/1/2000 18:09'!loadNotes	"Load notes from the files"	| dir |	names _ OrderedCollection new.	notes _ OrderedCollection new.	(FileDirectory default directoryExists: 'audio')		ifFalse: [FileDirectory default createDirectory: 'audio'].	dir _ self audioDirectory.	dir fileNames do: [:fname |		(fname endsWith: '.name') ifTrue: [			names add: ((dir fileNamed: fname) contentsOfEntireFile).			notes add: (fname copyFrom: 1 to: (fname size - 4))]].! !!ChatNotes methodsFor: 'initialization' stamp: 'RAA 8/2/2000 01:15'!openAsMorph	| window aColor recordButton stopButton playButton saveButton |	window _ (SystemWindow labelled: 'Audio Notes') model: self.	window addMorph: (		(PluggableListMorph 			on: self 			list: #notesList 			selected: #notesListIndex 			changeSelected: #notesListIndex: 			menu: #notesMenu:		) autoDeselect: false) frame: (0@0 corner: 0.5@1.0).	nameTextMorph _ PluggableTextMorph on: self text: #name accept: nil.	nameTextMorph askBeforeDiscardingEdits: false.	window addMorph: nameTextMorph frame: (0.5@0 corner: 1.0@0.4).	aColor _ Color colorFrom: self defaultBackgroundColor.	(recordButton _ PluggableButtonMorph on: self getState: #isRecording action: #record)		label: 'record';		askBeforeChanging: true;		color: aColor;		onColor: aColor darker offColor: aColor.	window addMorph: recordButton frame: (0.5@0.4 corner: 0.75@0.7).	(stopButton _ PluggableButtonMorph on: self getState: #isStopped action: #stop)		label: 'stop';		askBeforeChanging: true;		color: aColor;		onColor: aColor darker offColor: aColor.	window addMorph: stopButton frame: (0.75@0.4 corner: 1.0@0.7).	(playButton _ PluggableButtonMorph on: self getState: #isPlaying action: #play)		label: 'play';		askBeforeChanging: true;		color: aColor;		onColor: aColor darker offColor: aColor.	window addMorph: playButton frame: (0.5@0.7 corner: 0.75@1.0).	(saveButton _ PluggableButtonMorph on: self getState: #isSaving action: #save)		label: 'save';		askBeforeChanging: true;		color: aColor;		onColor: aColor darker offColor: aColor.	window addMorph: saveButton frame: (0.75@0.7 corner: 1.0@1.0).	window openInWorld.! !!ChatNotes methodsFor: 'morphic' stamp: 'TBP 2/23/2000 21:07'!defaultBackgroundColor	"In a better design, this would be handled by preferences."	^Color r: 1.0 g: 0.7 b: 0.8! !!ChatNotes methodsFor: 'morphic' stamp: 'TBP 2/23/2000 21:07'!initialExtent	"Nice and small--that was the idea.	It shouldn't take up much screen real estate."	^200@100! !!ChatNotes methodsFor: 'morphic' stamp: 'TBP 2/23/2000 21:07'!notesMenu: aMenu	"Simple menu to delete notes"	^(notesIndex = 0)		ifTrue: [aMenu labels: 'update notes' lines: #() selections: #(updateNotes)]		ifFalse: [aMenu labels: ('delete', String cr, 'update notes') lines: #() selections: #(deleteSelection updateNotes)]! !!ChatNotes methodsFor: 'morphic' stamp: 'RAA 8/2/2000 01:11'!textMorphString	^nameTextMorph text string! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/1/2000 18:08'!audioDirectory	^FileDirectory default directoryNamed: 'audio'! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/1/2000 18:08'!deleteSelection	"Delete the selection in the list"	| dir |	notesIndex <= 0 ifTrue: [^self].	dir _ self audioDirectory.	dir deleteFileNamed: ((notes at: notesIndex), 'name') ifAbsent: [].	dir deleteFileNamed: ((notes at: notesIndex), 'aiff') ifAbsent: [].	names removeAt: notesIndex.	notes removeAt: notesIndex.	self notesListIndex: 0.	self changed: #notesList.	self changed: #name.! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/1/2000 18:09'!getNextName	"Return the next name available.	All names are of the form '#.name' and '#.aiff'."	| dir num |	dir _ self audioDirectory.	num _ 1.	[dir fileExists: (num asString, '.name')] whileTrue: [num _ num + 1].	^(num asString, '.')! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/1/2000 19:05'!play	| separator |	self isPlaying: true.	notesIndex = 0 ifTrue: [		recorder pause.		recorder playback.		self isPlaying: false.		^self	].	separator _ FileDirectory pathNameDelimiter asString.	sound _ (AIFFFileReader new readFromFile: (		FileDirectory default pathName, 		separator, 'audio', separator, (notes at: notesIndex), 'aiff')) sound.	[		sound playAndWaitUntilDone.		self isPlaying: false	] fork! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/2/2000 01:09'!saveName	"Save the name to the '.name' file."	| dir file |	self name: self textMorphString.	dir _ self audioDirectory.	file _ (notes at: notesIndex), 'name'.	(dir fileExists: file) ifTrue: [dir deleteFileNamed: file].	file _ dir newFileNamed: file.	file nextPutAll: name.	file close.	names at: notesIndex put: name.	self changed: #notesList.! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/2/2000 01:09'!saveSound	"Move the sound from the recorder to the files."	| fname file |		recorder recordedSound ifNil: [^self].	self isSaving: true.	fname _ self getNextName.	"Create .name file"	file _ self audioDirectory newFileNamed: (fname, 'name').	file nextPutAll: self textMorphString.	file close.	"Create .aiff file"	file _ (self audioDirectory newFileNamed: (fname, 'aiff')) binary.	self storeAIFFOnFile: file.	file close.	"Add to names and notes"	names add: self textMorphString.	notes add: fname.	self changed: #notesList.	self notesListIndex: (notes size).	"Clear Recorder"	recorder _ SoundRecorder new.	"Stop Button"	self isSaving: false! !!ChatNotes methodsFor: 'file i/o' stamp: 'RAA 8/1/2000 18:12'!storeAIFFOnFile: file	"In a better design, this would be handled by SequentialSound,	but I figure you will need a new primitive anyway, so it can	be implemented at that time."	| sampleCount s |	sampleCount _ recorder recordedSound sounds inject: 0 into: [ :sum :rsound |		sum + rsound samples monoSampleCount	].	file nextPutAll: 'FORM' asByteArray.	file nextInt32Put: (2 * sampleCount) + 46.	file nextPutAll: 'AIFF' asByteArray.	file nextPutAll: 'COMM' asByteArray.	file nextInt32Put: 18.	file nextNumber: 2 put: 1. "channels"	file nextInt32Put: sampleCount.	file nextNumber: 2 put: 16. "bits/sample"	(AbstractSound new) storeExtendedFloat: (recorder samplingRate) on: file.	file nextPutAll: 'SSND' asByteArray.	file nextInt32Put: (2 * sampleCount) + 8.	file nextInt32Put: 0.	file nextInt32Put: 0.	(recorder recordedSound sounds) do: [:rsound |		1 to: (rsound samples monoSampleCount) do: [:i |			s _ rsound samples at: i.			file nextPut: ((s bitShift: -8) bitAnd: 16rFF).			file nextPut: (s bitAnd: 16rFF)]].! !!ChatNotes methodsFor: 'file i/o' stamp: 'TBP 2/23/2000 21:07'!updateNotes	"Probably not necessary unless several audio notes are	open at the same time"	"Clear Notes"	self loadNotes.	self changed: #notesList.	self notesListIndex: 0.	self name: ''.! !!ChatNotes class methodsFor: 'instance creation' stamp: 'RAA 8/2/2000 01:06'!openAsMorph	^self new openAsMorph! !!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 19:30'!withEToySound: aByteArray	self flag: #bob.		"no longer needed"	self halt.! !!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 19:25'!withEToySound: aByteArray samplingRate: anInteger	soundClassName _ #SampledSound.	channels _ {aByteArray}.	codecName _ #GSMCodec.	loopEnd _ nil.	"???"	loopLength _  nil.	perceivedPitch _ 100.0.	samplingRate  _ anInteger.	gain  _ 1.0.	"???"	firstSample _ 1.	cachedSound  _ nil.	"???"! !!Debugger methodsFor: 'initialize' stamp: 'RAA 8/8/2000 10:44'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| topView |	Smalltalk isMorphic ifTrue: [		self openFullMorphicLabel: aString.		errorWasInUIProcess _ CurrentProjectRefactoring newProcessIfUI: interruptedProcess.		^self	].	topView _ self buildMVCDebuggerViewLabel: aString minSize: 300@200.	topView controller openNoTerminate.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'RAA 8/8/2000 10:45'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	msg _ msgString.	(label beginsWith: 'Space is low') ifTrue: [msg _ self lowSpaceChoices, msgString].	isolationHead ifNotNil:		["We have already revoked the isolation layer -- now jump to the parent project."		msg _ self isolationRecoveryAdvice, msgString.		failedProject _ Project current.		isolationHead parent enterForEmergencyRecovery].	Smalltalk isMorphic ifTrue: [		self buildMorphicNotifierLabelled: label message: msg.		errorWasInUIProcess _ CurrentProjectRefactoring newProcessIfUI: interruptedProcess.		^self	].	Display fullScreen.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16 + self optionalButtonHeight).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'private' stamp: 'RAA 8/8/2000 10:48'!resumeProcess: aTopView 	Smalltalk isMorphic		ifFalse: [aTopView erase].	savedCursor		ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead		ifNotNil: [failedProject enterForEmergencyRecovery.			isolationHead invoke.			isolationHead _ nil].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate)		ifFalse: [contextStackIndex > 1				ifTrue: [interruptedProcess popTo: self selectedContext]				ifFalse: [interruptedProcess install: self selectedContext].			Smalltalk isMorphic				ifTrue: [errorWasInUIProcess						ifTrue: [Project resumeProcess: interruptedProcess]						ifFalse: [interruptedProcess resume]]				ifFalse: [ScheduledControllers activeControllerNoTerminate: interruptedController andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil.	"Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete.			Display repaintMorphicDisplayNow]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.	"restart low space handler"	errorWasInUIProcess == false		ifFalse: [Processor terminateActive]! !!EToyHierarchicalTextGizmo class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 14:28'!example"EToyHierarchicalTextGizmo example"	(EToyHierarchicalTextGizmo new 		topNode: EToyTextNode newNode;		notInAWindow) openInWorld! !!EToyIncomingMessage methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:22'!incomingMessgage: dataStream fromIPAddress: ipAddress	| nullChar messageType senderName  selectorAndReceiver |	nullChar _ 0 asCharacter.	messageType _ dataStream upTo: nullChar.	senderName _ dataStream upTo: nullChar.	(EToyGateKeeperMorph acceptRequest: messageType from: senderName at: ipAddress) ifFalse: [		^self	].	selectorAndReceiver _ self class messageHandlers at: messageType ifAbsent: [^self].	^selectorAndReceiver second 		perform: selectorAndReceiver first 		withArguments: {dataStream. senderName. ipAddress}! !!EToyIncomingMessage class methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:19'!allTypes	^{		self typeKeyboardChat.		self typeMorph.		self typeFridge.		self typeStatusRequest.		self typeStatusReply.		self typeSeeDesktop.		self typeAudioChat.		self typeAudioChatContinuous.		self typeMultiChat.	}! !!EToyIncomingMessage class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 13:21'!forType: aMessageType send: aSymbol to: anObject	self messageHandlers at: aMessageType put: {aSymbol. anObject}! !!EToyIncomingMessage class methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 07:52'!initializeMessageHandlers	self		forType: self typeMorph 		send: #handleNewMorphFrom:sentBy:ipAddress: 		to: self;		forType: self typeFridge 		send: #handleNewFridgeMorphFrom:sentBy:ipAddress: 		to: self;		forType: self typeKeyboardChat 		send: #handleNewChatFrom:sentBy:ipAddress: 		to: self;		forType: self typeMultiChat 		send: #handleNewMultiChatFrom:sentBy:ipAddress: 		to: self;		forType: self typeStatusRequest 		send: #handleNewStatusRequestFrom:sentBy:ipAddress: 		to: self;		forType: self typeStatusReply 		send: #handleNewStatusReplyFrom:sentBy:ipAddress: 		to: self;		forType: self typeSeeDesktop 		send: #handleNewSeeDesktopFrom:sentBy:ipAddress: 		to: self.! !!EToyIncomingMessage class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 13:35'!messageHandlers	^MessageHandlers ifNil: [MessageHandlers _ Dictionary new].! !!EToyIncomingMessage class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 13:36'!newObjectFromStream: dataStream	| newObject |	[newObject _ SmartRefStream objectFromStreamedRepresentation: dataStream upToEnd.]		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				"self flashIndicator: #working."			].		].	"self resetIndicator: #working."	^newObject! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/4/2000 13:32'!handleNewChatFrom: dataStream sentBy: senderName ipAddress: ipAddressString	^ EToyChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: (self newObjectFromStream: dataStream).	! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/4/2000 13:33'!handleNewFridgeMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject |	newObject _ self newObjectFromStream: dataStream.	newObject		setProperty: #fridgeSender toValue: senderName;		setProperty: #fridgeIPAddress toValue: ipAddressString;		setProperty: #fridgeDate toValue: Time dateAndTimeNow.	WorldState addDeferredUIMessage: [EToyFridgeMorph newItem: newObject] fixTemps.	! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/16/2000 12:26'!handleNewMorphFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| newObject thumbForm targetWorld |	newObject _ self newObjectFromStream: dataStream.	EToyCommunicatorMorph playArrivalSound.	targetWorld _ self currentWorld.	(EToyMorphsWelcomeMorph morphsWelcomeInWorld: targetWorld) ifTrue: [		newObject position: (			newObject 				valueOfProperty: #positionInOriginatingWorld 				ifAbsent: [(targetWorld randomBoundsFor: newObject) topLeft]		).		WorldState addDeferredUIMessage: [			newObject openInWorld: targetWorld.		] fixTemps.		^self	].	thumbForm _ newObject imageForm scaledToSize: 50@50.	EToyListenerMorph addToGlobalIncomingQueue: {		thumbForm. newObject. senderName. ipAddressString	}.	WorldState addDeferredUIMessage: [		EToyListenerMorph ensureListenerInCurrentWorld	] fixTemps.! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/17/2000 09:22'!handleNewMultiChatFrom: dataStream sentBy: senderName ipAddress: ipAddressString	^ EToyMultiChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: (self newObjectFromStream: dataStream).	! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/4/2000 13:34'!handleNewSeeDesktopFrom: dataStream sentBy: senderName ipAddress: ipAddressString	"more later"	^ EToyChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: ipAddressString,' would like to see your desktop'.	! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/4/2000 13:34'!handleNewStatusReplyFrom: dataStream sentBy: senderName ipAddress: ipAddressString	(EToyGateKeeperMorph entryForIPAddress: ipAddressString) statusReplyReceived: (		self newObjectFromStream: dataStream	)! !!EToyIncomingMessage class methodsFor: 'handlers' stamp: 'RAA 8/4/2000 13:34'!handleNewStatusRequestFrom: dataStream sentBy: senderName ipAddress: ipAddressString	"more later"	^ EToyChatMorph 		chatFrom: ipAddressString 		name: senderName 		text: ipAddressString,' would like to know if you are available'.	! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 13:20'!typeAudioChat	^'audiochat'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/5/2000 19:21'!typeAudioChatContinuous	^'audiochat2'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 11:49'!typeFridge	^'fridge'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 11:46'!typeKeyboardChat	^'chat'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 11:59'!typeMorph	^'morph'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/17/2000 07:41'!typeMultiChat	^'multichat'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 11:56'!typeSeeDesktop	^'seedesktop'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 11:53'!typeStatusReply	^'statusreply'! !!EToyIncomingMessage class methodsFor: 'message types' stamp: 'RAA 8/4/2000 11:51'!typeStatusRequest	^'statusrequest'! !!EToyPeerToPeer methodsFor: 'sending' stamp: 'RAA 8/6/2000 09:29'!doConnectForSend	| addr |	addr _ NetNameResolver addressForName: ipAddress.	addr ifNil: [		communicatorMorph commResult: {#message -> ('could not find ',ipAddress)}.		^false	].	socket connectTo: addr port: self class eToyCommunicationsPort.	(socket waitForConnectionUntil: (Socket deadlineSecs: 15)) ifFalse: [		communicatorMorph commResult: {#message -> ('no connection to ',ipAddress,' (',				(NetNameResolver stringFromAddress: addr),')')}.		^false	].	^true! !!EToyPeerToPeer methodsFor: 'sending' stamp: 'RAA 8/12/2000 14:28'!doSendData	| totalLength myData allTheData |	myData _ dataQueue next ifNil: [socket sendData: '0 '. ^false].	totalLength _ (myData collect: [ :x | x size]) sum.	socket sendData: totalLength printString,' '.	allTheData _ WriteStream on: (String new: totalLength).	myData do: [ :chunk | allTheData nextPutAll: chunk asString].	NebraskaDebug at: #peerBytesSent add: {totalLength}.	self sendDataCautiously: allTheData contents.	^true! !!EToyPeerToPeer methodsFor: 'sending' stamp: 'RAA 8/9/2000 16:30'!sendDataCautiously: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent. Try not to send too much at once since this seemed to cause problems talking to a port on the same machine"	| bytesSent bytesToSend count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		count _ socket 			sendSomeData: aStringOrByteArray 			startIndex: bytesSent + 1  			count: (bytesToSend - bytesSent min: 4000).		bytesSent _ bytesSent + count.		communicatorMorph commResult: {#commFlash -> true}.		(Delay forMilliseconds: 10) wait.	].	^ bytesSent! !!EToyPeerToPeer methodsFor: 'sending' stamp: 'RAA 8/6/2000 09:34'!sendSomeData: arrayOfByteObjects to: anIPAddress for: aCommunicatorMorph	dataQueue _ self 		sendSomeData: arrayOfByteObjects 		to: anIPAddress 		for: aCommunicatorMorph 		multiple: false.	dataQueue nextPut: nil.		"only this message to send"! !!EToyPeerToPeer methodsFor: 'sending' stamp: 'RAA 8/6/2000 09:34'!sendSomeData: arrayOfByteObjects to: anIPAddress for: aCommunicatorMorph multiple: aBoolean	Socket initializeNetwork.	socket _ Socket newTCP.	dataQueue _ SharedQueue new.	dataQueue nextPut: arrayOfByteObjects.	communicatorMorph _ aCommunicatorMorph.	ipAddress _ anIPAddress.	process _ [		self doConnectForSend ifTrue: [			[self doSendData] whileTrue.			communicatorMorph commResult: {#message -> 'OK'}.			socket closeAndDestroy.		].	] newProcess.	process priority: Processor highIOPriority.	process resume.	^dataQueue! !!EToyPeerToPeer methodsFor: 'receiving' stamp: 'RAA 8/6/2000 10:45'!doReceiveData	| answer |	[answer _ self doReceiveOneMessage] 		on: Error		do: [ :ex | 			communicatorMorph commResult: {#message -> (ex description,' ',socket printString)}.			^false		].	communicatorMorph commResult: {		#message -> 'OK'. 		#data -> answer .		#ipAddress -> remoteSocketAddress.	}.	^answer size > 0! !!EToyPeerToPeer methodsFor: 'receiving' stamp: 'RAA 8/6/2000 14:29'!doReceiveOneMessage	| awaitingLength i length answer |	awaitingLength _ true.	answer _ WriteStream on: String new.	[awaitingLength] whileTrue: [		leftOverData _ leftOverData,socket getData.		(i _ leftOverData indexOf: $ ) > 0 ifTrue: [			awaitingLength _ false.			length _ (leftOverData first: i - 1) asNumber.			answer nextPutAll: (leftOverData allButFirst: i).		].	].	leftOverData _ ''.	[answer size < length] whileTrue: [		answer nextPutAll: socket getData.		communicatorMorph commResult: {#commFlash -> true}.	].	answer _ answer contents.	answer size > length ifTrue: [		leftOverData _ answer allButFirst: length.		answer _ answer first: length	].	^answer! !!EToyPeerToPeer methodsFor: 'receiving' stamp: 'RAA 8/6/2000 14:26'!receiveDataOn: aSocket for: aCommunicatorMorph	socket _ aSocket.	remoteSocketAddress _ socket remoteAddress.	communicatorMorph _ aCommunicatorMorph.	process _ [		leftOverData _ ''.		[self doReceiveData] whileTrue.		socket closeAndDestroy.	] newProcess.	process priority: Processor highIOPriority.	process resume.! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 13:59'!directory	^directory! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 13:26'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory _ dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode _ #date].	volList _ Array with: '[]'.	directory ifNotNil: [		volList _ volList, directory pathParts.  "Nesting suggestion from RvL"	].	volList _ volList withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern.	directoryChangeBlock ifNotNil: [directoryChangeBlock value: directory].! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 13:22'!directoryChangeBlock: aBlockOrNil	directoryChangeBlock _ aBlockOrNil.! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 8/17/2000 13:53'!enableTypeButtons: typeButtons info: fileTypeInfo forDir: aDirectory	| foundSuffixes fileSuffixes firstEnabled enableIt |	firstEnabled _ nil.	foundSuffixes _ aDirectory fileNames collect: [ :each | (each findTokens: '.') last asLowercase].	foundSuffixes _ foundSuffixes asSet.	fileTypeInfo with: typeButtons do: [ :info :button |		fileSuffixes _ info second.		enableIt _ fileSuffixes anySatisfy: [ :patt | foundSuffixes includes: patt].		button 			setProperty: #enabled 			toValue: enableIt.		enableIt ifTrue: [firstEnabled ifNil: [firstEnabled _ button]].	].	firstEnabled ifNotNil: [^firstEnabled mouseUp: nil].	typeButtons do: [ :each | each color: Color gray].! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 8/17/2000 14:07'!morphicViewGeneralLoaderInWorld: aWorld"FileList2 morphicViewGeneralLoaderInWorld: self currentWorld"	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b fileTypeInfo fileTypeButtons fileTypeRow actionRow |	fileTypeInfo _ self endingSpecs.	window _ AlignmentMorphBob1 newColumn.	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	aFileList _ self new directory: FileDirectory default.	aFileList 		fileSelectionBlock: self projectOnlySelectionBlock;		modalView: window.	window		setProperty: #FileList toValue: aFileList;		centering: #center;		borderWidth: 4;		borderColor: (Color r: 0.355 g: 0.516 b: 1.0);		useRoundedCorners.	fileTypeButtons _ fileTypeInfo collect: [ :each |		(self blueButtonText: each first textColor: Color gray inWindow: window)			setProperty: #enabled toValue: true;			hResizing: #shrinkWrap	].	buttons _ #('OK' 'Cancel') collect: [ :each |		self blueButtonText: each textColor: textColor1 inWindow: window	].	treePane _ aFileList morphicDirectoryTreePane 		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane _ aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window addARow: {window fancyText: 'Find...' ofSize: 21 color: textColor1}.	fileTypeRow _ window addARowCentered: fileTypeButtons.	actionRow _ window addARowCentered: {		buttons first. 		(Morph new extent: 30@5) color: Color transparent. 		buttons second	}.	window		addARow: {			(window inAColumn: {(pane2a _ window inARow: {window inAColumn: {treePane}}) 				useRoundedCorners; inset: 6}) inset: 10.			(window inAColumn: {(pane2b _ window inARow: {window inAColumn: {fileListPane}}) 				useRoundedCorners; inset: 6}) inset: 10.		}.	window fullBounds.	window fillWithRamp: self blueRamp1 oriented: 0.65.	pane2a fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	pane2b fillWithRamp: self blueRamp3 oriented: (0.7 @ 0.35).	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	fileTypeButtons do: [ :each | 		each 			on: #mouseUp 			send: #value:value: 			to: [ :evt :morph | 				self update: actionRow in: window fileTypeRow: fileTypeRow morphUp: morph.			] fixTemps	].	buttons first on: #mouseUp send: #okHit to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	aFileList directoryChangeBlock: [ :newDir |		self enableTypeButtons: fileTypeButtons info: fileTypeInfo forDir: newDir	] fixTemps.	aFileList directory: aFileList directory.	^ window openInWorld: aWorld.! !!FileList2 class methodsFor: 'morphic ui' stamp: 'RAA 8/17/2000 14:10'!update: actionRow in: window fileTypeRow: fileTypeRow morphUp: morph	| fileTypeInfo info2 buttons textColor1 fileSuffixes fileActions aFileList fileTypeString |	(morph valueOfProperty: #enabled) ifFalse: [^self].	fileTypeRow submorphsDo: [ :sub |		sub color: (			sub == morph 				ifTrue: [Color white] 				ifFalse: [(sub valueOfProperty: #enabled) 							ifTrue: [Color transparent] ifFalse: [Color gray]]		).	].	fileTypeString _ morph firstSubmorph firstSubmorph contents asString.	aFileList _ window valueOfProperty: #FileList.	textColor1 _ Color r: 0.742 g: 0.839 b: 1.0.	actionRow removeAllMorphs.	fileTypeInfo _ self endingSpecs.	info2 _ fileTypeInfo detect: [ :each | each first = fileTypeString] ifNone: [self halt].	fileSuffixes _ info2 second.	fileActions _ info2 third.	buttons _ fileActions, #(('Cancel this search' cancelHit 'Cancel')) collect: [ :each |		(self blueButtonText: each third textColor: textColor1 inWindow: window)			setBalloonText: each first;			on: #mouseUp send: each second to: aFileList.	].	buttons do: [ :each | actionRow addMorphBack: each].	window fullBounds.	buttons do: [ :each |		each fillWithRamp: self blueRamp2 oriented: (0.75 @ 0).	].	aFileList fileSelectionBlock: (		self selectionBlockForSuffixes: (fileSuffixes collect: [ :each | '*.',each])	).	aFileList updateFileList.! !!Form methodsFor: 'fileIn/Out' stamp: 'RAA 8/13/2000 15:32'!encodeForRemoteCanvas	| header binaryForm |	"encode into a bitstream for use with RemoteCanvas.  The format does not require invoking the Compiler"	header := String streamContents: [ :str |	str "nextPutAll: 'F|';"		nextPutAll: self depth printString;		nextPut: $,;		nextPutAll: self width printString;		nextPut: $,;		nextPutAll: self height printString;		nextPut: $|. ].	binaryForm := ByteArray streamContents: [ :str |		self unhibernate.		bits writeOn: str. ].	^header, binaryForm asString! !!Form methodsFor: 'other' stamp: 'RAA 8/14/2000 10:13'!asCursorForm	^ self as: StaticForm! !!Form methodsFor: 'testing' stamp: 'RAA 8/14/2000 10:00'!isStatic	^false! !!ColorForm methodsFor: 'copying' stamp: 'RAA 8/14/2000 10:45'!asCursorForm	^ (self asFormOfDepth: 32) offset: offset; as: StaticForm! !!ColorForm methodsFor: 'scaling, rotation' stamp: 'RAA 8/5/2000 18:12'!scaledToSize: newExtent	"super method did not seem to work so well on ColorForms"	^(self asFormOfDepth: 16) scaledToSize: newExtent! !!Cursor methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:14'!asCursorForm	| form |	form _ StaticForm extent: self extent depth: 8.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 10:14'!asCursorForm	| form |	form _ StaticForm extent: self extent depth: 8.	form fillShape: maskForm fillColor: Color white.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!FormCanvas methodsFor: 'drawing-support' stamp: 'RAA 8/15/2000 10:53'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	^super 		transform2By: aDisplayTransform 		clippingTo: aClipRect 		during: aBlock 		smoothing: cellSize! !!InputSensor methodsFor: 'mouse' stamp: 'RAA 8/14/2000 18:44'!escapeIfQuickClick: quickClickBlock ifMoved: movedBlock	| pt |	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	self flag: #bob.		"probably obsolete - moved to HandMorph"	pt _ self cursorPoint.	(Delay forMilliseconds: 80) wait.	self anyButtonPressed ifFalse: [^ quickClickBlock value].	((self cursorPoint - pt) abs < (3@3)) ifFalse: [^ movedBlock value]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'RAA 8/14/2000 16:55'!allLowerWorldsDo: aBlock	self flag: #bob.		"this proved to be a fair time-waster. phasing out"	self allMorphsDo: [ :each | 		each == self ifFalse: [ each isWorldMorph ifTrue: [aBlock value: each]]	].! !!Morph methodsFor: 'WiW support' stamp: 'RAA 8/14/2000 12:09'!shouldGetStepsFrom: aWorld	self world == aWorld ifTrue: [^true].	(self ownerThatIsA: HandMorph) ifNotNil: [^true].	^false! !!AlertMorph methodsFor: 'as yet unclassified' stamp: 'TBP 3/5/2000 13:47'!canHaveFillStyles	^false! !!AlertMorph methodsFor: 'as yet unclassified' stamp: 'TBP 3/5/2000 13:47'!color: aColor	super color: aColor.	onColor _ aColor.! !!AlertMorph methodsFor: 'as yet unclassified' stamp: 'TBP 3/5/2000 13:47'!initialize	super initialize.	self color: Color red.	self extent: 25@25.	self borderWidth: 2.! !!AlertMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/2/2000 10:39'!socketOwner: aChatGUI	socketOwner _ aChatGUI.! !!AlertMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/7/2000 08:22'!step	super step.	offColor ifNil: [offColor _ onColor mixed: 0.5 with: Color black].	socketOwner objectsInQueue = 0 ifTrue: [		color = offColor ifFalse: [super color: offColor].	] ifFalse: [		super color: (color = onColor ifTrue: [offColor] ifFalse: [onColor]).	].! !!AlertMorph methodsFor: 'as yet unclassified' stamp: 'TBP 3/5/2000 13:47'!stepTime	"Answer the desired time between steps in milliseconds."	^ 500! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 11:57'!layoutChanged	| myGuy |	"use the version from Morph"	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue: [		(myGuy _ self firstSubmorph) isWorldMorph ifFalse: [			worldBoundsToShow = myGuy bounds ifFalse: [				self changeWorldBoundsToShow: (worldBoundsToShow _ myGuy bounds).			].		].		"submorphs do: [:m | m ownerChanged]"		"<< I don't see any reason for this"	].! !!ChatButtonMorph methodsFor: 'initialization' stamp: 'Tbp 4/11/2000 16:13'!setDefaultLabel	self label: 'Flash'.! !!ChatButtonMorph methodsFor: 'accessing' stamp: 'Tbp 4/11/2000 16:25'!actionDownSelector: aSymbolOrString	(nil = aSymbolOrString or:	['nil' = aSymbolOrString or:	[aSymbolOrString isEmpty]])		ifTrue: [^actionDownSelector _ nil].	actionDownSelector _ aSymbolOrString asSymbol.! !!ChatButtonMorph methodsFor: 'accessing' stamp: 'Tbp 4/11/2000 16:27'!actionUpSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionUpSelector _ nil].	actionUpSelector _ aSymbolOrString asSymbol.! !!ChatButtonMorph methodsFor: 'accessing' stamp: 'Tbp 4/11/2000 16:31'!labelDown: aString	labelDown _ aString.! !!ChatButtonMorph methodsFor: 'accessing' stamp: 'Tbp 4/11/2000 16:32'!labelUp: aString	labelUp _ aString! !!ChatButtonMorph methodsFor: 'events' stamp: 'Tbp 4/11/2000 16:19'!doButtonDownAction	(target ~~ nil and: [actionDownSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionDownSelector]].! !!ChatButtonMorph methodsFor: 'events' stamp: 'Tbp 4/11/2000 16:20'!doButtonUpAction	(target ~~ nil and: [actionUpSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionUpSelector]].! !!ChatButtonMorph methodsFor: 'events' stamp: 'RAA 8/6/2000 18:30'!mouseDown: evt	oldColor _ color.	self label: labelDown.	self doButtonDownAction.! !!ChatButtonMorph methodsFor: 'events' stamp: 'RAA 8/6/2000 18:37'!mouseUp: evt	"if oldColor nil, it signals that mouse had not gone DOWN inside me, e.g. because of a cmd-drag; in this case we want to avoid triggering the action!!"	oldColor ifNil: [^self].	self color: oldColor.	(self containsPoint: evt cursorPoint) ifTrue: [		self label: labelUp.		self doButtonUpAction.	].! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 13:52'!addGateKeeperMorphs	| list currentTime choices age row |	self setProperty: #gateKeeperCounterValue toValue: EToyGateKeeperMorph updateCounter.	choices _ #(		(60 'm' 'in the last minute')		(3600 'h' 'in the last hour')		(86400 'd' 'in the last day')	).	currentTime _ Time totalSeconds.	list _ EToyGateKeeperMorph knownIPAddresses.	list do: [ :each |		age _ each timeBetweenLastAccessAnd: currentTime.		age _ choices			detect: [ :x | age <= x first]			ifNone: [{0. '-'. (age // 86400) printString,'days ago'}].		row _ self addARow:		(EToyIncomingMessage allTypes collect: [ :type |				self toggleButtonFor: each attribute: type]		),		{			(self inAColumn: {				(StringMorph contents: age second) lock.			}) inset: 2; hResizing: #shrinkWrap; setBalloonText: 'Last attempt was ',age third.			(self inAColumn: {				(StringMorph contents: each ipAddress) lock.			}) inset: 2; hResizing: #shrinkWrap.			(self inAColumn: {				(StringMorph contents: each latestUserName) lock.			}) inset: 2.		}.		row			color: (Color r: 0.6 g: 0.8 b: 1.0);			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			"on: #mouseUp send: #mouseUp:in: to: self;"			setBalloonText: each fullInfoString	].! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/2/2000 12:51'!simpleToggleButtonFor: target attribute: attribute help: helpText	^(EtoyUpdatingThreePhaseButtonMorph checkBox)		target: target;		actionSelector: #toggleChoice:;		arguments: {attribute};		getSelector: #getChoice:;		setBalloonText: helpText;		step! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/2/2000 12:42'!toggleButtonFor: entry attribute: attribute	^(self inAColumn: {		self			simpleToggleButtonFor: entry 			attribute: attribute 			help: 'Whether you want "',attribute,'" messages'	}) hResizing: #shrinkWrap! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/7/2000 06:51'!changeTalkButtonLabel	| bText |	self transmitWhileRecording.	handsFreeTalking ifTrue: [		theTalkButton			labelUp: 'Talk';			labelDown: 'Release';			label: 'Talk'.		bText _ 'Click once to begin a message. Click again to end the message.'	] ifFalse: [		theTalkButton			labelUp: 'Talk';			labelDown: (transmitWhileRecording ifTrue: ['TALKING'] ifFalse: ['RECORDING']);			label: 'Talk'.		bText _ 'Press and hold to record a message.'	].	transmitWhileRecording ifTrue: [		bText _ bText , ' The message will be sent while you are speaking.'	] ifFalse: [		bText _ bText , ' The message will be sent when you are finished.'	].	theTalkButton setBalloonText: bText.! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/4/2000 13:25'!connect	mytargetip _ FillInTheBlank 		request: 'Connect to?' 		initialAnswer: (mytargetip ifNil: ['']).	mytargetip _ NetNameResolver stringFromAddress: (		(NetNameResolver addressFromString: mytargetip) ifNil: [^mytargetip _ '']	)! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/4/2000 13:09'!currentConnectionStateString	^'?'! !!AudioChatGUI methodsFor: 'stuff' stamp: 'TBP 3/5/2000 16:22'!defaultBackgroundColor	"In a better design, this would be handled by preferences."	^Color yellow."r: 1.0 g: 0.7 b: 0.8"! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/6/2000 18:27'!getChoice: aSymbol	aSymbol == #playOnArrival ifTrue: [^self class playOnArrival].	aSymbol == #transmitWhileRecording ifTrue: [^self transmitWhileRecording].	aSymbol == #handsFreeTalking ifTrue: [^self handsFreeTalking].! !!AudioChatGUI methodsFor: 'stuff' stamp: 'TBP 3/5/2000 16:02'!initialExtent	"Nice and small--that was the idea.	It shouldn't take up much screen real estate."	^200@100! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/4/2000 13:01'!objectsInQueue	^self class numberOfNewMessages! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/4/2000 12:26'!playNextMessage	self class playNextAudioMessage.! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/4/2000 14:59'!removeConnectButton	theConnectButton ifNotNil: [		theConnectButton delete.		theConnectButton _ nil.	].! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/12/2000 18:11'!step	| now |	super step.	self transmitWhileRecording ifTrue: [self sendAnyCompletedSounds].	self handsFreeTalking & myrecorder isRecording ifTrue: [		now _ Time millisecondClockValue.		((handsFreeTalkingFlashTime ifNil: [0]) - now) abs > 200 ifTrue: [			theTalkButton color: (				theTalkButton color = self buttonColor 						ifTrue: [Color white] 						ifFalse: [self buttonColor]			).			handsFreeTalkingFlashTime _ now.		].	].	self class playOnArrival ifTrue: [self playNextMessage].	"myrecorder ifNotNil: [		myrecorder recorder samplingRate printString ,'   ',		SoundPlayer samplingRate printString,'    '		displayAt: 0@0	]."! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/12/2000 18:09'!stepTime	myrecorder ifNil: [^200].	myrecorder isRecording ifFalse: [^200].	^20! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/2/2000 07:47'!stepTimeIn: aSystemWindow	^self stepTime! !!AudioChatGUI methodsFor: 'stuff' stamp: 'Tbp 4/11/2000 16:49'!stop	myrecorder stop.	self send.! !!AudioChatGUI methodsFor: 'stuff' stamp: 'RAA 8/7/2000 06:52'!toggleChoice: aSymbol	aSymbol == #playOnArrival ifTrue: [		^PlayOnArrival _ self class playOnArrival not	].	aSymbol == #transmitWhileRecording ifTrue: [		transmitWhileRecording _ self transmitWhileRecording not.		self changeTalkButtonLabel.		^transmitWhileRecording	].	aSymbol == #handsFreeTalking ifTrue: [		handsFreeTalking _ self handsFreeTalking not.		self changeTalkButtonLabel.		^handsFreeTalking	].! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/2/2000 16:33'!buttonColor 	^Color lightBrown! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/2/2000 16:36'!connectButton		^SimpleButtonMorph new		label: 'Connect';		color: self buttonColor;		target: self;		actWhen: #buttonUp;		actionSelector: #connect;		setBalloonText: 'Press to connect to another audio chat user.'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/7/2000 06:51'!initialize	super initialize.	transmitWhileRecording _ false.	handsFreeTalking _ false.		mycodec _ GSMCodec new.	myrecorder _ ChatNotes new.	mytargetip _ ''.	color _ Color yellow.	borderWidth _ 4.	borderColor _ Color black.	self start2.	self changeTalkButtonLabel.	! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/4/2000 14:26'!ipAddress: aString	mytargetip _ aString! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/12/2000 16:22'!messageWaitingAlertIndicator	| messageCounter |	myalert _ AlertMorph new socketOwner: self.	messageCounter _ UpdatingStringMorph on: self selector: #objectsInQueue.	myalert addMorph: messageCounter.	messageCounter contents: '0'; color: Color white.	messageCounter align: messageCounter center with: myalert center.	myalert setBalloonText: 'New messages indicator. This will flash and show the number of messages when there are messages that you haven''t listened to. You can click here to play the next message.'.	myalert on: #mouseUp send: #playNextMessage to: self.	^myalert! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/2/2000 16:34'!playButton	^SimpleButtonMorph new		label: 'Play';		color: self buttonColor;		target: self;		actWhen: #buttonUp;		actionSelector: #playNextMessage;		setBalloonText: 'Play the next new message.'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/2/2000 16:37'!recordAndStopButton	^ChatButtonMorph new		labelUp: 'Record';		labelDown: 'RECORDING';		label: 'Record';		color: self buttonColor;		target: self;		actionUpSelector: #stop;		actionDownSelector: #record;		setBalloonText: 'Press and hold to record a message. It will be sent when you release the mouse.'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/4/2000 14:05'!start	| myUpdatingText playButton myOpenConnectionButton myStopButton window  |"--- old system window version ---"	Socket initializeNetwork.	myrecorder initialize.	window _ (SystemWindow labelled: 'iSCREAM') model: self.	myalert _ AlertMorph new.	myalert socketOwner: self.	window addMorph: myalert frame: (0.35@0.4 corner: 0.5@0.7).	(playButton _ self playButton) center: 200@300.	window addMorph: playButton frame: (0.5@0.4 corner: 1.0@0.7).	(myOpenConnectionButton _ self connectButton) center: 250@300.	window addMorph: myOpenConnectionButton frame: (0.5@0 corner: 1.0@0.4).	(myStopButton _ self recordAndStopButton) center: 300@300.	window addMorph: myStopButton frame: (0.5@0.7 corner: 1.0@1.0).	myUpdatingText _ UpdatingStringMorph on: self selector: #objectsInQueue.	window addMorph: myUpdatingText frame: (0.41@0.75 corner: 0.45@0.95).	"myUserList init."! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/12/2000 16:25'!start2	Socket initializeNetwork.	myrecorder initialize.	self addARow: {		self inAColumn: {			(				self inARow: {					self inAColumn: {self toggleForSendWhileTalking}.					self inAColumn: {self toggleForHandsFreeTalking}.					self inAColumn: {self toggleForPlayOnArrival}.				}			) hResizing: #shrinkWrap.			self inARow: {				self talkBacklogIndicator.				self messageWaitingAlertIndicator.			}.		}.		self inAColumn: {			theConnectButton _ self connectButton.			self playButton.			theTalkButton _ self talkButton.		}.	}.! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/12/2000 16:24'!talkBacklogIndicator	^(UpdatingStringMorph on: self selector: #talkBacklog)		setBalloonText: 'Approximate number of seconds of delay in your messages getting to the other end.'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/7/2000 06:52'!talkButton	^ChatButtonMorph new		labelUp: 'xxx';		labelDown: 'xxx';		label: 'xxx';		color: self buttonColor;		target: self;		actionUpSelector: #talkButtonUp;		actionDownSelector: #talkButtonDown;		setBalloonText: 'xxx'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/12/2000 16:14'!toggleForHandsFreeTalking	^self		simpleToggleButtonFor: self 		attribute: #handsFreeTalking 		help: 'Whether you want to talk without holding the mouse down.'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/12/2000 16:15'!toggleForPlayOnArrival	^self		simpleToggleButtonFor: self 		attribute: #playOnArrival 		help: 'Whether you want to play messages automatically on arrival.'! !!AudioChatGUI methodsFor: 'initialization' stamp: 'RAA 8/12/2000 16:14'!toggleForSendWhileTalking	^self		simpleToggleButtonFor: self 		attribute: #transmitWhileRecording 		help: 'Whether you want to send messages while recording.'! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/6/2000 18:25'!handsFreeTalking	^handsFreeTalking ifNil: [handsFreeTalking _ false].! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/6/2000 09:47'!record	queueForMultipleSends _ nil.	myrecorder record.! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/12/2000 15:01'!samplingRateForTransmission	^11025		"try to cut down on amount of data sent for live chats"! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/13/2000 11:44'!send	| null rawSound aSampledSound |	mytargetip isEmpty ifTrue: [		^self inform: 'You must connect with someone first.'.	].	rawSound _ myrecorder recorder recordedSound ifNil: [^self].	aSampledSound _ rawSound asSampledSound."Smalltalk at: #Q3 put: {rawSound. rawSound asSampledSound. aCompressedSound}."	self transmitWhileRecording ifTrue: [		self sendOneOfMany: rawSound asSampledSound.		queueForMultipleSends ifNotNil: [queueForMultipleSends nextPut: nil].		queueForMultipleSends _ nil.		^self	].	null _ String with: 0 asCharacter.	EToyPeerToPeer new 		sendSomeData: {			EToyIncomingMessage typeAudioChat,null. 			Preferences defaultAuthorName,null.			aSampledSound originalSamplingRate asInteger printString,null.			(mycodec compressSound: aSampledSound) channels first.		}		to: mytargetip		for: self.! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/12/2000 14:34'!sendAnyCompletedSounds	| soundsSoFar firstCompleteSound |	myrecorder isRecording ifFalse: [^self].	mytargetip isEmpty ifTrue: [^self].	soundsSoFar _ myrecorder recorder recordedSound ifNil: [^self].	firstCompleteSound _ soundsSoFar removeFirstCompleteSoundOrNil ifNil: [^self].	self sendOneOfMany: firstCompleteSound.! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/12/2000 18:22'!sendOneOfMany: aSampledSound	| null message aCompressedSound ratio resultBuf oldSamples newCount t fromIndex val maxVal |	self samplingRateForTransmission = aSampledSound originalSamplingRate ifTrue: [		aCompressedSound _ mycodec compressSound: aSampledSound.	] ifFalse: [		t _ [			ratio _ aSampledSound originalSamplingRate // self samplingRateForTransmission.			oldSamples _ aSampledSound samples.			newCount _ oldSamples monoSampleCount // ratio.			resultBuf _ SoundBuffer newMonoSampleCount: newCount.			fromIndex _ 1.			maxVal _ 0.			1 to: newCount do: [ :i |				maxVal _ maxVal max: (val _ oldSamples at: fromIndex).				resultBuf at: i put: val.				fromIndex _ fromIndex + ratio.			].		] timeToRun.		NebraskaDebug at: #soundReductionTime add: {t. maxVal}.		maxVal < 400 ifTrue: [			NebraskaDebug at: #soundReductionTime add: {'---dropped---'}.			^self		].		"awfully quiet"		aCompressedSound _ mycodec compressSound: (			SampledSound new 				setSamples: resultBuf 				samplingRate: aSampledSound originalSamplingRate // ratio		).	].	null _ String with: 0 asCharacter.	message _ {		EToyIncomingMessage typeAudioChatContinuous,null. 		Preferences defaultAuthorName,null.		aCompressedSound samplingRate asInteger printString,null.		aCompressedSound channels first.	}.	queueForMultipleSends ifNil: [		queueForMultipleSends _ EToyPeerToPeer new 			sendSomeData: message			to: mytargetip			for: self			multiple: true.	] ifNotNil: [		queueForMultipleSends nextPut: message	].! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/12/2000 16:18'!talkBacklog	^(queueForMultipleSends ifNil: [^0]) size // 2! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/9/2000 18:05'!talkButtonDown	EToyListenerMorph confirmListening.	self handsFreeTalking ifFalse: [^self record].	theTalkButton label: 'Release'.! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/9/2000 18:13'!talkButtonUp	theTalkButton recolor: self buttonColor.	self handsFreeTalking ifFalse: [^self stop].	myrecorder isRecording ifTrue: [		theTalkButton label: 'Talk'.		^self stop.	].	self record.	theTalkButton label: 'TALKING'.! !!AudioChatGUI methodsFor: 'sending' stamp: 'RAA 8/6/2000 13:08'!transmitWhileRecording	^transmitWhileRecording ifNil: [transmitWhileRecording _ false]! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/2000 12:26'!chatFrom: ipAddress name: senderName text: text	| initialText attrib |	recipientForm ifNil: [		initialText _ senderName asText allBold.	] ifNotNil: [		attrib _ TextAnchor new anchoredMorph: recipientForm "asMorph".		initialText _ '*' asText.		initialText addAttribute: attrib from: 1 to: 1.	].	self appendMessage: initialText,' - ',text,String cr.	EToyCommunicatorMorph playArrivalSound.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 10:37'!getChoice: aSymbol		aSymbol == #acceptOnCR ifTrue: [^acceptOnCR ifNil: [true]].	^false.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 10:34'!initialize	super initialize.	acceptOnCR _ true.	orientation _ #vertical.	color _ Color paleYellow.	inset _ 0.	borderColor _ self standardBorderColor.	borderWidth _ 8.	hResizing _ vResizing _ #rigid.	minWidth _ minHeight _ 200.	bounds _ 400@100 extent:  200@150.	self rebuild.! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 10:41'!rebuild	| r1 r2 |	r1 _ self addARow: {		self simpleToggleButtonFor: self attribute: #acceptOnCR help: 'Send with Return?'.		self inAColumn: {StringMorph new contents: 'Your message to:'; lock}.		self textEntryFieldNamed: #ipAddress with: ''					help: 'IP address for chat partner'.	}.	recipientForm ifNotNil: [		r1 addMorphBack: recipientForm asMorph lock	].	self		addMorphBack: (			sendingPane _ PluggableTextMorph				on: self				text: nil				accept: #acceptTo:forMorph:		).	r2 _ self addARow: {self inAColumn: {StringMorph new contents: 'Replies'; lock}}.	self		addMorphBack: (			receivingPane _ PluggableTextMorph				on: self				text: nil				accept: nil		).	{r1. r2} do: [ :each |		each			vResizing: #spaceFill;			color: Color veryLightGray.	].	heights _ #(18 0.25 18 9999999).	sendingPane acceptOnCR: (acceptOnCR ifNil: [acceptOnCR _ true])! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 08:04'!standardBorderColor	^Color darkGray! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 10:41'!toggleChoice: aSymbol		aSymbol == #acceptOnCR ifTrue: [		acceptOnCR _ (acceptOnCR ifNil: [true]) not.		sendingPane ifNotNil: [sendingPane acceptOnCR: acceptOnCR].		^self	].! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 11:58'!transmittedObjectCategory	^EToyIncomingMessage typeKeyboardChat! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/2000 12:27'!playArrivalSound	Preferences soundsEnabled ifTrue: [		SampledSound playSoundNamed: 'chirp'.	] ifFalse: [		1 beep	].! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 16:12'!debugLog: x"AudioChatGUI debugLog: nilAudioChatGUI debugLog: OrderedCollection newDebugLog LiveMessages NewAudioMessages PlayOnArrival "	DebugLog _ x.! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/11/2000 11:54'!handleNewAudioChat2From: dataStream sentBy: senderName ipAddress: ipAddressString	| newSound seqSound compressed |	compressed _ self newCompressedSoundFrom: dataStream.	newSound _ compressed asSound."-------an experiment to trynewSound adjustVolumeTo: 7.0 overMSecs: 10--------"DebugLog ifNotNil: [	DebugLog add: {compressed. newSound}.].	LiveMessages ifNil: [LiveMessages _ Dictionary new].	seqSound _ LiveMessages at: ipAddressString ifAbsentPut: [SequentialSound new].	seqSound isPlaying ifTrue: [		seqSound			add: newSound;			pruneFinishedSounds.	] ifFalse: [		seqSound			initialize;			add: newSound.	].	seqSound isPlaying ifFalse: [seqSound play].! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 19:28'!handleNewAudioChatFrom: dataStream sentBy: senderName ipAddress: ipAddressString	| compressed |	compressed _ self newCompressedSoundFrom: dataStream.DebugLog ifNotNil: [	DebugLog add: {compressed}.].	self newAudioMessages nextPut: compressed.	self playOnArrival ifTrue: [self playNextAudioMessage].	! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/5/2000 19:22'!initialize	EToyIncomingMessage		forType: EToyIncomingMessage typeAudioChat 		send: #handleNewAudioChatFrom:sentBy:ipAddress: 		to: self.	EToyIncomingMessage		forType: EToyIncomingMessage typeAudioChatContinuous		send: #handleNewAudioChat2From:sentBy:ipAddress: 		to: self.! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 12:16'!newAudioMessages	^NewAudioMessages ifNil: [NewAudioMessages _ SharedQueue new].! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 19:28'!newCompressedSoundFrom: dataStream	| samplingRate |	samplingRate _ (dataStream upTo: 0 asCharacter) asNumber.	^CompressedSoundData new 		withEToySound: dataStream upToEnd		samplingRate: samplingRate.! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 13:01'!numberOfNewMessages	^self newAudioMessages size! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 14:06'!openAsMorph	AudioChatGUI new openInWorld.	"old syswindow version in #start"! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/6/2000 14:23'!playNextAudioMessage	(self newAudioMessages nextOrNil ifNil: [^self]) asSound play.! !!AudioChatGUI class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 13:14'!playOnArrival	^PlayOnArrival ifNil: [PlayOnArrival _ false]! !!EToyChatMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/16/2000 12:26'!chatWindowForIP: ipAddress name: senderName picture: aForm inWorld: aWorld	| makeANewOne aSenderBadge existing |	existing _ self instanceForIP: ipAddress inWorld: aWorld.	existing ifNotNil: [^existing].	makeANewOne _ [		self new			recipientForm: aForm; 			open; 			setIPAddress: ipAddress	].	EToyCommunicatorMorph playArrivalSound.	self doChatsInternalToBadge ifTrue: [		aSenderBadge _ EToySenderMorph instanceForIP: ipAddress inWorld: aWorld.		aSenderBadge ifNotNil: [			aSenderBadge startChat: false.			^aSenderBadge 				findDeepSubmorphThat: [ :x | x isKindOf: EToyChatMorph] 				ifAbsent: makeANewOne		].		aSenderBadge _ EToySenderMorph instanceForIP: ipAddress.		aSenderBadge ifNotNil: [			aSenderBadge _ aSenderBadge veryDeepCopy.			aSenderBadge 				killExistingChat;				openInWorld: aWorld;				startChat: false.			^aSenderBadge 				findDeepSubmorphThat: [ :x | x isKindOf: EToyChatMorph] 				ifAbsent: makeANewOne		].		(aSenderBadge _ EToySenderMorph new)			userName: senderName 			userPicture: aForm			userEmail: 'unknown' 			userIPAddress: ipAddress;			position: 200@200;			openInWorld: aWorld;			startChat: false.		^aSenderBadge 			findDeepSubmorphThat: [ :x | x isKindOf: EToyChatMorph] 			ifAbsent: makeANewOne	].	^makeANewOne value.! !!EToyFridgeMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 11:50'!transmittedObjectCategory	^EToyIncomingMessage typeFridge! !!EToyGateKeeperEntry methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 11:49'!initialize	self flag: #bob.		"need to decide better initial types"	super initialize.	ipAddress _ '???'.	accessAttempts _ attempsDenied _ 0.	lastRequests _ OrderedCollection new.	acceptableTypes _ Set withAll: EToyIncomingMessage allTypes. ! !!EToyGateKeeperMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 09:43'!initialize	super initialize.	orientation _ #vertical.	color _ Color lightGray.	inset _ 4.	borderColor _ #raised "Color brown".	borderWidth _ 4.	hResizing _ vResizing _ #spaceFill.	self useRoundedCorners.	self rebuild.	! !!EToyGateKeeperMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 11:06'!acceptRequest: requestType from: senderName at: ipAddressString	| entry |	UpdateCounter _ self updateCounter + 1.	entry _ self entryForIPAddress: ipAddressString.	senderName isEmpty ifFalse: [entry latestUserName: senderName].	^entry requestAccessOfType: requestType! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 14:27'!initialize	super initialize.	color _ Color white.	self useRoundedCorners.! !!EToyHierarchicalTextMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 14:34'!new	| listMorph model |	model _ EToyHierarchicalTextGizmo new 		topNode: EToyTextNode newNode.	(listMorph _ EToyHierarchicalTextMorph 		on: model		list: #getList		selected: #getCurrentSelection		changeSelected: #noteNewSelection:		menu: #genericMenu:		keystroke: nil).	listMorph autoDeselect: false.     ^ listMorph! !!EToyHierarchicalTextMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 14:32'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self basicNew initialize		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 18:05'!confirmListening	self isListening ifFalse: [		(self confirm: 'You currently are not listening and will not hear a reply.Shall I start listening for you?') ifTrue: [			self startListening		].	].! !!EToyListenerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/9/2000 17:56'!isListening	^GlobalListener notNil! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:05'!acceptDroppingMorph: morphToDrop event: evt	(morphToDrop isKindOf: EToySenderMorph) ifFalse: [		^evt hand rejectDropMorph: morphToDrop event: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we don't really want it"	self updateIPAddressField: targetIPAddresses,{morphToDrop ipAddress}.! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 08:08'!acceptTo: someText forMorph: aMorph	| streamedMessage |	streamedMessage _ {targetIPAddresses. someText} eToyStreamedRepresentationNotifying: self.	targetIPAddresses do: [ :each |		self 			transmitStreamedObject: streamedMessage			to: each.	].	aMorph setText: '' asText.	self appendMessage: 		self startOfMessageFromMe,		' - ',		someText,		String cr.	^true! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:01'!chatFrom: ipAddress name: senderName text: textPackage	super chatFrom: ipAddress name: senderName text: textPackage second.	self updateIPAddressField: (		targetIPAddresses,textPackage first,{ipAddress} 			copyWithout: NetNameResolver localAddressString	).! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:01'!editEvent: anEvent for: aMorph	| answer initialText aFillInTheBlankMorph |	(aMorph bounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	initialText _ String streamContents: [ :strm |		targetIPAddresses do: [ :each | strm nextPutAll: each; cr].	].	aFillInTheBlankMorph _ FillInTheBlankMorph new		setQuery: 'Who are you chatting with?'		initialAnswer: initialText		answerHeight: 250		acceptOnCR: false.	aFillInTheBlankMorph responseUponCancel: nil.	self world addMorph: aFillInTheBlankMorph centeredNear: anEvent cursorPoint.	answer _ aFillInTheBlankMorph getUserResponse.	answer ifNil: [^self].	self updateIPAddressField: (answer findTokens: ' ',String cr).! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 08:57'!initialize	targetIPAddresses _ OrderedCollection new.	super initialize.	bounds _ 0@0 extent: 350@350.! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 13:16'!rebuild	| r1 r2 |	r1 _ self addARow: {		self simpleToggleButtonFor: self attribute: #acceptOnCR help: 'Send with Return?'.		self inAColumn: {StringMorph new contents: 'Multi chat with:'; lock}.		self textEntryFieldNamed: #ipAddress with: ''					help: 'Click to edit participant list'.	}.	self		addMorphBack: (			PluggableTextMorph				on: self				text: nil				accept: #acceptTo:forMorph:		).	r2 _ self addARow: {self inAColumn: {StringMorph new contents: 'Replies'; lock}}.	self		addMorphBack: (			receivingPane _ PluggableTextMorph				on: self				text: nil				accept: nil		).	{r1. r2} do: [ :each |		each			vResizing: #spaceFill;			color: Color veryLightGray.	].	heights _ #(18 0.25 18 9999999).	self updateIPAddressField: targetIPAddresses.! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 08:53'!standardBorderColor	^Color veryLightGray! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 07:44'!transmittedObjectCategory	^EToyIncomingMessage typeMultiChat! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:01'!updateIPAddressField: newAddresses		targetIPAddresses _ (		newAddresses copyWithout: NetNameResolver localAddressString	) 		asSet 		asSortedCollection 		asArray.	(fields at: #ipAddress) contents: targetIPAddresses size printString,' people'.! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 09:04'!wantsDroppedMorph: aMorph event: evt	(aMorph isKindOf: EToySenderMorph) ifFalse: [^false].	(bounds containsPoint: evt cursorPoint) ifFalse: [^false].	^true.! !!EToyMultiChatMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 08:53'!chatWindowForIP: ipAddress name: senderName picture: aForm inWorld: aWorld	^self allInstances 		detect: [ :x | x world == aWorld] 		ifNone: [			EToyCommunicatorMorph playArrivalSound.			self new open		].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/10/2000 12:25'!currentBadgeVersion	"enables on-the-fly updating of older morphs"	^10! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/10/2000 12:25'!initialize	Preferences defaultAuthorName.		"seems like a good place to insure we have a name"	super initialize.	orientation _ #vertical.	color _ Color lightMagenta.	inset _ 4.	borderColor _ Color magenta.	borderWidth _ 4.	self setProperty: #normalBorderColor toValue: borderColor.	self setProperty: #flashingColors toValue: {Color red. Color yellow}.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 14:35'!killExistingChat	| oldOne |	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	(oldOne _ self valueOfProperty: #embeddedChatHolder) ifNotNil: [		oldOne delete.		self removeProperty: #embeddedChatHolder	].	(oldOne _ self valueOfProperty: #embeddedAudioChatHolder) ifNotNil: [		oldOne delete.		self removeProperty: #embeddedAudioChatHolder	].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 11:52'!sendStatusCheck	| null |	null _ String with: 0 asCharacter.	EToyPeerToPeer new 		sendSomeData: {			EToyIncomingMessage typeStatusRequest,null. 			Preferences defaultAuthorName,null.		}		to: self ipAddress		for: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 11:53'!sendStatusReply	| null |	null _ String with: 0 asCharacter.	EToyPeerToPeer new 		sendSomeData: {			EToyIncomingMessage typeStatusReply,null. 			Preferences defaultAuthorName,null.			((EToyGateKeeperMorph acceptableTypesFor: self ipAddress) 				eToyStreamedRepresentationNotifying: self).		}		to: self ipAddress		for: self.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 14:22'!startAudioChat	self startAudioChat: true! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/11/2000 12:32'!startAudioChat: toggleMode	| chat r |	(self valueOfProperty: #embeddedAudioChatHolder) ifNotNil: [		toggleMode ifFalse: [^self].		^self killExistingChat	].	(self ownerThatIsA: EToyFridgeMorph) isNil ifTrue: [		chat _ AudioChatGUI new ipAddress: self ipAddress.		chat			removeConnectButton;		"we already know the connectee"			vResizing: #shrinkWrap;			hResizing: #shrinkWrap;			borderWidth: 2.		r _ (self addARow: {chat}) vResizing: #shrinkWrap.		self world startSteppingSubmorphsOf: chat.		self setProperty: #embeddedAudioChatHolder toValue: r.		self hResizing: #spaceFill; vResizing: #spaceFill.	] ifFalse: [		chat _ AudioChatGUI new ipAddress: self ipAddress.		chat openInWorld: self world.	]! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 14:39'!startChat: toggleMode	| chat r |	(self valueOfProperty: #embeddedChatHolder) ifNotNil: [		toggleMode ifFalse: [^self].		^self killExistingChat	].	(EToyChatMorph doChatsInternalToBadge and: 				[(self ownerThatIsA: EToyFridgeMorph) isNil]) ifTrue: [		chat _ EToyChatMorph basicNew			recipientForm: userPicture; 			initialize;			setIPAddress: self ipAddress.		chat			vResizing: #spaceFill;			hResizing: #spaceFill;			borderWidth: 2;			insetTheScrollbars.		r _ (self addARow: {chat}) vResizing: #spaceFill.		self world startSteppingSubmorphsOf: chat.		self setProperty: #embeddedChatHolder toValue: r.		self hResizing: #spaceFill; vResizing: #spaceFill.	] ifFalse: [		chat _ EToyChatMorph 			chatWindowForIP: self ipAddress			name: self userName 			picture: userPicture 			inWorld: self world.		chat owner addMorphFront: chat.	]! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 12:11'!startNebraskaClient	| newMorph |	[		[			newMorph _ NetworkTerminalMorph connectTo: self ipAddress.			WorldState addDeferredUIMessage: [newMorph openInStyle: #scaled] fixTemps.		]			on: Error			do: [ :ex |				WorldState addDeferredUIMessage: [					self inform: 'No connection to: '. self ipAddress,' (',ex printString,')'				] fixTemps			].	] fork! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/10/2000 12:24'!step	(self valueOfProperty: #currentBadgeVersion) = self currentBadgeVersion ifFalse: [		self setProperty: #currentBadgeVersion toValue: self currentBadgeVersion.		self fixOldVersion.		Preferences defaultAuthorName.		"seems like a good place to insure we have a name"	].	super step.! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 12:00'!transmittedObjectCategory	^EToyIncomingMessage typeMorph! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 15:04'!userName: aString userPicture: aFormOrNil userEmail: emailString userIPAddress: ipString	| dropZoneRow |	self setProperty: #currentBadgeVersion toValue: self currentBadgeVersion.	userPicture _ aFormOrNil ifNil: [		(TextStyle default fontOfSize: 26) emphasized: 1; characterFormAt: $?	].	userPicture _ userPicture scaledToSize: 61@53.	self killExistingChat.	self removeAllMorphs.	self useRoundedCorners.	self 		addARow: {			self inAColumn: {(StringMorph contents: aString) lock}		}.	dropZoneRow _ self		addARow: {			self inAColumn: {userPicture asMorph lock}		}.	self establishDropZone: dropZoneRow.	self		addARow: {			self textEntryFieldNamed: #emailAddress with: emailString					help: 'Email address for this person'		};		addARow: {			self textEntryFieldNamed: #ipAddress with: ipString					help: 'IP address for this person'		};		addARow: {			self indicatorFieldNamed: #working color: Color blue help: 'working'.			self indicatorFieldNamed: #communicating color: Color green help: 'sending'.			self buttonNamed: 'C' action: #startChat color: Color paleBlue 								help: 'Open a written chat with this person'.			self buttonNamed: 'T' action: #startTelemorphic color: Color paleYellow 								help: 'Start telemorphic with this person'.			self buttonNamed: '!!' action: #tellAFriend color: Color paleGreen 								help: 'Tell this person about the current project'.			self buttonNamed: '?' action: #checkOnAFriend color: Color lightBrown 								help: 'See if this person is available'.			self buttonNamed: 'A' action: #startAudioChat color: Color yellow 								help: 'Open an audio chat with this person'.			self buttonNamed: 'S' action: #startNebraskaClient color: Color white 								help: 'See this person''s world (if he allows that)'.		}.	! !!EToySenderMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 15:42'!nameForIPAddress: ipString	| senderMorphs |	senderMorphs _ EToySenderMorph allInstances select: [ :x | 		x userName notNil and: [x ipAddress = ipString]	].	senderMorphs isEmpty ifTrue: [^nil].	^senderMorphs first userName! !!EToyTextNode class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 14:36'!includeInNewMorphMenu	^ false! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 8/14/2000 18:43'!escapeIfQuickClick: quickClickBlock ifMoved: movedBlock	| pt |	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	pt _ Sensor cursorPoint.	(Delay forMilliseconds: 80) wait.	Sensor anyButtonPressed ifFalse: [^ quickClickBlock value].	((Sensor cursorPoint - pt) abs < (3@3)) ifFalse: [^ movedBlock value]! !!HandMorph methodsFor: 'event handling' stamp: 'RAA 8/14/2000 18:36'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: Sensor cursorPoint]				ifFalse: [evt])."Transcript show: m printString; cr."	m ifNotNil:		[aHalo _ m world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [m world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown					ifTrue: [clickClient click: firstClickEvent]					ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab					ifNotNil:						[self grabMorph: rootForGrab]					ifNil:						[self newMouseFocus: m   "trigger automatic viewing, for example"]].		mouseOverTimes removeKey: m ifAbsent: []]! !!IndentingListParagraphMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 14:36'!includeInNewMorphMenu	^ false! !!NebraskaClient methodsFor: 'initialization' stamp: 'RAA 8/4/2000 16:01'!initialize: aConnection	| remoteAddress userPicture |	connection := aConnection.	hand := RemoteControlledHandMorph on: (MorphicEventDecoder on: aConnection).	remoteAddress _ connection remoteAddress.	remoteAddress ifNotNil: [remoteAddress _ NetNameResolver stringFromAddress: remoteAddress].	userPicture _ EToySenderMorph pictureForIPAddress: remoteAddress.	hand		userInitials: ((EToySenderMorph nameForIPAddress: remoteAddress) ifNil: ['???'])		andPicture: (userPicture ifNotNil: [userPicture scaledToSize: 16@20]).	encoder := CanvasEncoder on: aConnection.	canvas := BufferedCanvas		"could return us a RemoteCanvas" 		connection: encoder		clipRect: (0@0 extent: 5000@5000)		transform: MorphicTransform identity! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 13:41'!at: queueName add: anArray	| now |	DEBUG ifNil: [		queueName == #sketchZZZ ifFalse: [^self].		"Details _ OrderedCollection new."		self beginStats.	].	(Details notNil and: [Details size < 20]) ifTrue: [		Details add: thisContext longStack	].	now _ Time millisecondClockValue.	DEBUG add: {now},anArray,{queueName}.! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 10:33'!beginStats	DEBUG _ OrderedCollection new! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/17/2000 15:06'!fixups	"Some patching up necessitated by this change set"	NebraskaServerMorph killOldServers.	EToyIncomingMessage initializeMessageHandlers.	AudioChatGUI initialize.	Preferences absorbAdditions.	CanvasEncoder beginCaching.	BufferedCanvas enabled: false.	PaintBoxMorph allInstances do: [ :each | each fixupButtons].! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 19:22'!killStats	DEBUG _ nil.! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 10:34'!showAndClearStats: queueName	DEBUG ifNil: [^1 beep].	self 		showStats: queueName 		from: DEBUG.	DEBUG _ nil.! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 10:35'!showStats: queueName	DEBUG ifNil: [^1 beep].	self 		showStats: queueName 		from: DEBUG.! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 10:44'!showStats: queueName from: aCollection	| xx answer prevTime currTime |	prevTime _ nil.	answer _ String streamContents: [ :s | 		s nextPutAll: (aCollection last first - aCollection first first) asStringWithCommas,' ms';cr;cr.		aCollection withIndexDo: [ :each :index | 			(queueName == #allStats or: [queueName == each last]) ifTrue: [				currTime _ each first.				xx _ currTime printString.				prevTime ifNil: [prevTime _ currTime].				s nextPutAll: index printString,'.  ',					(xx allButLast: 3),'.',(xx last: 3),' ',(currTime - prevTime) printString,' '.				s nextPutAll: each allButFirst printString; cr.				prevTime _ currTime.			].		]	].	StringHolder new 		contents: answer;		openLabel: queueName! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 10:36'!stopAndShowAll	| prev |self halt.	"not updated to new format"	prev _ DEBUG.	DEBUG _ nil.	prev ifNil: [^1 beep].	prev keysAndValuesDo: [ :k :v |		self showStats: k from: v	].! !!NebraskaServerMorph methodsFor: 'structure' stamp: 'RAA 8/15/2000 14:44'!delete	server removeDependent: self.	server stopListening.	super delete.! !!NebraskaServerMorph methodsFor: 'drawing' stamp: 'RAA 8/13/2000 18:53'!drawOn: aCanvas	| str |	str _ 'server with ', server numClients printString, ' clients  ',					(previousBacklog _ server backlog) printString,' ',					BufferedCanvas enabledString,CanvasEncoder cachingString.	aCanvas clipBy: self bounds during: [ :c |		c fillColor: self color.		c			text: str			at: self position + (5@5)			font: nil			color: Color black.		c frameRectangle: self bounds color: Color black.	].! !!NebraskaServerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 14:49'!killOldServers	NebraskaServerMorph allInstances do: [ :each |		each delete.	].	NebraskaServer allInstances do: [ :each |		each stopListening.		DependentsFields removeKey: each ifAbsent: [].	].! !!NebraskaServerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 14:50'!serveWorld: aWorld	NebraskaServerMorph killOldServers.	"a bit of a hack until we get a better way"	^self serveWorld: aWorld onPort: NebraskaServer defaultPort! !!NetworkTerminalBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 12:21'!boxesAndColorsAndSelectors	^#()! !!NetworkTerminalBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 12:22'!initialize	super initialize.	self setBalloonText: 'I am a view on another Squeak'! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 12:06'!connection: aConnection	connection := aConnection.	decoder := CanvasDecoder connection: aConnection.	eventEncoder := MorphicEventEncoder on: aConnection.! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 12:24'!initialize	super initialize.	backgroundForm _ (		(StringMorph contents: '......' font: (TextStyle default fontOfSize: 24))			color: Color white	) imageForm.	bounds _ backgroundForm boundingBox.! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 10:45'!openInStyle: aSymbol	aSymbol == #naked ifTrue: [		self openInWorld.	].	aSymbol == #scaled ifTrue: [		self openScaled.	].	aSymbol == #bordered ifTrue: [		AlignmentMorph newColumn			hResizing: 	#shrinkWrap;			vResizing: 	#shrinkWrap;			borderWidth: 8;			borderColor: Color blue;			addMorph: self;			openInWorld.	].	[		[self world isNil] whileFalse: [(Delay forSeconds: 2) wait].		self disconnect.	] fork.! !!NetworkTerminalMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 12:22'!openScaled	| window tm |	window _ NetworkTerminalBorderMorph new		minWidth: 100;		minHeight: 100;		borderWidth: 8;		borderColor: Color orange;		bounds: (0@0 extent: Display extent * 3 // 4).	tm _ BOBTransformationMorph new.	window addMorph: tm.	tm addMorph: self.	window openInWorld."==	tm changeWorldBoundsToShow: bounds.	self arrangeToStartSteppingIn: enclosingWorld.=="! !!NetworkTerminalMorph methodsFor: 'drawing' stamp: 'RAA 8/15/2000 12:17'!updateBackgroundForm	"make sure that our background form matches what the server has most recently requested"	| drawingForm |	drawingForm _ decoder drawingForm.	(drawingForm extent = backgroundForm extent and: [		drawingForm depth = backgroundForm depth ]) ifTrue: [			"they match just fine"			^self ].	backgroundForm _ drawingForm deepCopy.	self extent: backgroundForm extent.! !!NetworkTerminalMorph methodsFor: 'stepping and presenter' stamp: 'RAA 8/15/2000 11:46'!step	decoder ifNil: [ ^self ].	decoder processIOOnForce: [ :rectangle |		self forceToFront: rectangle ].	enteringHand ifNotNil: [		self sendEvent: (			MorphicEvent new				setType: #mouseMove				cursorPoint: (self globalPointToLocal: Sensor cursorPoint)				buttons: Sensor primMouseButtons 				keyValue: 0		)	].! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 8/4/2000 15:45'!mouseDown: evt	self sendEvent: evt! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 8/15/2000 11:47'!mouseMove: evt	self sendEventAsIs: evt! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 8/15/2000 11:34'!sendEvent: evt	self sendEventAsIs: (evt translatedBy: bounds topLeft negated).! !!NetworkTerminalMorph methodsFor: 'event handling' stamp: 'RAA 8/15/2000 11:33'!sendEventAsIs: evt	eventEncoder ifNil: [ ^self ].	eventEncoder sendEvent: evt.! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'RAA 8/4/2000 15:13'!connectTo: serverHost	^self connectTo: serverHost port: NebraskaServer defaultPort! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'RAA 8/4/2000 15:12'!connectTo: serverHost port: serverPort	| stringSock |	stringSock _ self socketConnectedTo: serverHost port: serverPort.	^self new connection: stringSock! !!NetworkTerminalMorph class methodsFor: 'instance creation' stamp: 'RAA 8/15/2000 10:09'!openAndConnectTo: serverHost port: serverPort	| stringSock me |	stringSock _ self socketConnectedTo: serverHost port: serverPort.	me _ self new connection: stringSock.	^me openInStyle: #naked! !!OLDSketchEditorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 19:54'!brushAlphaFromGray	"Get currentNib again, (a gray-scale Form) and transform it into an alpha brush.  3/15/97 tk"	| d alphaMap this alpha colorMaker newBox smallNib |	self flag: #bob.		"may be unused and needs currentColor update"	self flag: #unsent.		"???"	currentNib _ palette getNib.	newBox _ currentNib rectangleEnclosingPixelsNotOfColor: Color transparent.	"minimum size"	smallNib _ Form extent: newBox extent depth: currentNib depth.	smallNib copyBits: newBox from: currentNib at: 0@0 		clippingBox: smallNib boundingBox rule: Form over fillColor: nil."smallNib display.  newBox printString displayAt: 0@50."	d _ currentNib depth.	"usually 8"	alphaMap _ (Color cachedColormapFrom: d to: 32) copy.	"force a map to be there"	1 to: alphaMap size do: [:pixVal |		this _ Color colorFromPixelValue: pixVal-1 depth: d.		alpha _ 1.0 - this brightness.	"based on brightness"		"alpha _ alpha * 0.14 - 0.01."	"Adjust sensitivity for buffer depth"		"alpha _ alpha raisedTo: 2.0."	"Adjust sensitivity for buffer depth"		alphaMap at: pixVal 				put: (((self oldIVar: #currentColor) alpha: alpha) pixelWordForDepth: 32)].		brush _ Form extent: smallNib extent depth: 32.	"brush offset: smallNib offset."	colorMaker _ BitBlt current toForm: brush.	colorMaker sourceForm: smallNib; colorMap: alphaMap.	colorMaker sourceOrigin: 0@0; destOrigin: 0@0; combinationRule: Form over;		width: brush width; height: brush height; copyBits.	^ brush	! !!OLDSketchEditorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 19:55'!save: aForm	"Save these bits.  Not to be confused with the Save command.  "	self flag: #bob.	self flag: #unsent.		"??"	stampForm _ aForm! !!OLDSketchEditorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 19:55'!transBrush: evt	"Paint with a semi-transparent brush.  Call this each stroke.  , di"	|  prevP p buffSize theta brushRect buffRect delta newBuffRect updateRect scale half |	self flag: #bob.	self flag: #unsent.		"???"	scale _ buffToPic cellSize.	"2"	buffSize _ (buff width - brush width) // scale.	"100"	half _ brush extent // 2.	"center"	"buffRect now relative to pictureForm"	buffRect _ (evt cursorPoint - bounds origin) - (buff extent // scale // 2) 		extent: buff extent // scale.	picToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.	prevP _ ((evt cursorPoint - bounds origin) - buffRect origin) * scale - half.	[Sensor redButtonPressed] whileTrue:		[p _ ((evt cursorPoint - bounds origin) - buffRect origin) * scale - half.				"p, prevP are rel to buff origin"		p ~= prevP ifTrue: [		(p dist: prevP) > buffSize ifTrue:			["Stroke too long to fit in buffer -- clip to buffer,				and next time through will do more of it"			theta _ (p-prevP) theta.			p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].		brushRect _ p extent: brush extent.		((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:			["Brush is out of buffer region.  Scroll the buffer,				and fill new areas from the display"			delta _ (brushRect amountToTranslateWithin: 				(buff boundingBox insetBy: scale)) // scale.			buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.			newBuffRect _ buffRect translateBy: delta negated.			p _ p translateBy: delta*scale.			prevP _ prevP translateBy: delta*scale.			(newBuffRect areasOutside: buffRect) do:				[:r | picToBuff copyQuad: r innerCorners 						toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].			buffRect _ newBuffRect].		"Interpolate from prevP to p..."		brushToBuff drawFrom: prevP to: p withFirstPoint: false.		"Update only the altered pixels of the destination"		updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.		updateRect _ updateRect origin // scale * scale				corner: updateRect corner + scale // scale * scale.		"And finally store into the painting""buff displayAt: 0@0."		buffToPic copyQuad: updateRect innerCorners					toRect: (updateRect origin // scale + buffRect origin								extent: updateRect extent // scale).		prevP _ p.		self render: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale)]].! !!OLDSketchEditorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 19:55'!transBrushPrep	"Prepare to paint with a transparent brush at twice the resolution.  Do the work in 32-bits.  See BitBlt.alphaBlendDemo8 for details.  "	| buffSize scale cm1 cm2 |	self flag: #bob.		"may be unused and needs currentColor update"	self flag: #unsent.		"???"	(self oldIVar: #currentColor) class == Bitmap ifTrue: [		self oldIVar: #currentColor put: palette getColor]. "do not force white"	brush _ self brushAlphaFromGray.	"Get currentNib again, 		(a gray-scale Form) and transform it into an alpha brush"	scale _ 3.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	buffSize _ 100.	buff _ Form extent: (buffSize * scale) asPoint + brush extent depth: 32.  "Travelling 32-bit buffer"	picToBuff _ (WarpBlt current toForm: buff)  "from Picture to buff - magnify by 2"		sourceForm: paintingForm;		combinationRule: Form over.	cm1 _ (Color cachedColormapFrom: paintingForm depth to: 32) copy.	cm1 ifNotNil: [		"map off-the-edge pixels to the background color, so blend will look right at edge"		cm1 at: 1 put: (self world color pixelValueForDepth: 32)].	picToBuff colorMap: cm1.	brushToBuff _ (BitBlt current toForm: buff)  "from brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	"use buffToPic instead of paintingFormPen"	buffToPic _ (WarpBlt current toForm: paintingForm)  "from buff to Picture - shrink by 2"		sourceForm: buff;		cellSize: scale;    "...and use smoothing"		combinationRule: Form over.	cm2 _ (Color cachedColormapFrom: 32 to: paintingForm depth) copy.	cm2 ifNotNil: [		"remap background color to transparent"		cm2 at: (self world color indexInMap: cm2) put: 0].	buffToPic colorMap: cm2.	buffToBuff _ BitBlt current toForm: buff.  "for slewing the buffer"! !!ObjectSocket methodsFor: 'as yet unclassified' stamp: 'RAA 8/2/2000 12:01'!destroy	socket destroy.	socket _ nil.! !!ObjectSocket methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 15:38'!remoteAddress	self isConnected ifFalse: [^nil].	^socket remoteAddress! !!PaintBoxColorPicker methodsFor: 'initialization' stamp: 'RAA 8/15/2000 14:57'!beStatic	"an aid for Nebraska: make the color chart a static image to reduce traffic"	image isStatic ifFalse: [		image _ image as: StaticForm	].! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'RAA 8/15/2000 16:37'!selectColor: evt	"Update the receiver from the given event. Constrain locOfCurrent's center to lie within the color selection area. If it is partially in the transparent area, snap it entirely into it vertically."	| r |	locOfCurrent _ evt cursorPoint - self topLeft.	r _ Rectangle center: locOfCurrent extent: 9@9.	locOfCurrent _ locOfCurrent + (r amountToTranslateWithin: (5@11 corner: 140@136)).	locOfCurrent x > 128 ifTrue: [locOfCurrent _ 135@locOfCurrent y].  "snap into grayscale"	locOfCurrent y < 17		ifTrue: [			locOfCurrent _ locOfCurrent x@11.  "snap into transparent"			currentColor _ Color transparent]		ifFalse: [			currentColor _ image colorAt: locOfCurrent].	(owner isKindOf: PaintBoxMorph) ifTrue: [owner takeColorEvt: evt from: self].	self changed.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 16:47'!addWeakDependent: anObject	weakDependents ifNil: [^weakDependents _ WeakArray with: anObject].	weakDependents _ weakDependents,{anObject} reject: [ :each | each isNil].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 14:59'!beStatic	colorMemory ifNotNil: [colorMemory beStatic].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'RAA 8/16/2000 01:11'!createButtons	"Create buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button nib |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: pickup: "pickup: pickup: pickup:" stamp: "stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		button actionSelector: #tool:action:cursor:evt:; arguments: (Array with: button with: sel with: nil).		button actWhen: #buttonUp; target: self.		]].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		nib _ Form dotOfSize: (#(1 2 3 6 11 26) at: ind).		button actionSelector: #brush:action:nib:evt:; 				arguments: (Array with: button with: sel with: nib).		button actWhen: #buttonUp; target: self.		]]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'RAA 8/16/2000 01:36'!fixupButtons	| changes answer newSelector |	changes _ Dictionary new.	changes		at: #brush:action:nib: put: #brush:action:nib:evt:;		at: #tool:action:cursor: put: #tool:action:cursor:evt:;		at: #pickup:action:cursor: put: #pickup:action:cursor:evt:;		at: #keep:with: put: #keep:with:evt:;		at: #undo:with: put: #undo:with:evt:;		at: #scrollStamps:action: put: #scrollStamps:action:evt:;		at: #toss:with: put: #toss:with:evt:;		at: #eyedropper:action:cursor: put: #eyedropper:action:cursor:evt:;		at: #clear:with: put: #clear:with:evt:;		yourself.	answer _ WriteStream on: String new.	self allMorphsDo: [ :each |		(each isKindOf: ThreePhaseButtonMorph) ifTrue: [			answer nextPutAll: each actionSelector.			(changes includesKey: each actionSelector) ifTrue: [				each actionSelector: (newSelector _ changes at: each actionSelector).				answer nextPutAll: ' <-- ',newSelector.			].			answer cr.		].	].	^answer contents	"StringHolder new		contents: answer contents;		openLabel: 'button fixups'"! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'RAA 8/16/2000 11:12'!notifyWeakDependentsWith: arguments	weakDependents ifNil: [^self].	weakDependents do: [ :each |		each ifNotNil: [			each paintBoxChanged: arguments.			each paintBoxChanged: {#changed. arguments second. true}.		].	].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 13:35'!actionCursor	"Return the cursor to use with this painting action/tool. Offset of the form must be set."	^self		cursorFor: action		oldCursor: currentCursor		currentNib: self getNib		color: currentColor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:16'!brush: brushButton action: aSelector nib: aMask evt: evt	"Set the current tool and action for the paintBox.  "	currentBrush ifNotNil: [		currentBrush == brushButton ifFalse: [currentBrush state: #off]].	currentBrush _ brushButton.		"A ThreePhaseButtonMorph"	"currentBrush state: #on.	already done"	"aSelector is like brush3:.  Don't save it.  Can always say (currentBrush arguments at: 2)	aMask is the brush shape.  Don't save it.  Can always say (currentBrush arguments at: 3)"	self notifyWeakDependentsWith: {#currentNib. evt. currentBrush arguments at: 3}.	self brushable ifFalse: [self setAction: #paint: evt: evt].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:34'!clear: clearButton with: clearSelector evt: evt	| ss |	(ss _ self focusMorph) 		ifNotNil: [ss clearPainting: self]		ifNil: [self notCurrentlyPainting].	clearButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 09:22'!currentColor: aColor evt: evt	"Accept a color from the outside.  (my colorMemoryMorph must call takeColorEvt: evt from: colorPicker instead)"	currentColor _ aColor.	colorMemory currentColor: aColor.	self showColor.	self colorable ifFalse: [self setAction: #paint: evt: evt].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 13:37'!cursorFor: anAction oldCursor: oldCursor currentNib: aNibForm color: aColor 	"Return the cursor to use with this painting action/tool. Offset of the 	form must be set."	| ff width co larger c box |	anAction == #paint:		ifTrue: ["Make a cursor from the brush and the color"			width _ aNibForm width.			c _ self ringColorFor: aColor.			co _ oldCursor offset - (width // 4 @ 34 - (width // 6)) min: 0 @ 0.			larger _ width negated + 10 @ 0 extent: oldCursor extent + (width @ width).			ff _ oldCursor copy: larger.			ff colors at: 1 put: Color transparent.			ff colors at: 2 put: Color transparent.			ff offset: co - (width @ width // 2).			ff getCanvas				fillOval: (Rectangle center: ff offset negated extent: width @ width)				color: Color transparent				borderWidth: 1				borderColor: c.			^ ff].	anAction == #erase:		ifTrue: ["Make a cursor from the cursor and the color"			width _ aNibForm width.			co _ oldCursor offset + (width // 2 @ 4) min: 0 @ 0.			larger _ 0 @ 0 extent: oldCursor extent + (width @ width).			ff _ oldCursor copy: larger.			ff offset: co - (width @ width // 2).			ff				fill: (box _ co negated extent: width @ width)				fillColor: (Color r: 0.5 g: 0.5 b: 1.0).			ff				fill: (box insetBy: 1 @ 1)				fillColor: Color transparent.			^ ff].	^ oldCursor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 09:26'!deleteCurrentStamp: evt	"The trash is telling us to delete the currently selected stamp"	(tool arguments at: 2) == #stamp: ifTrue: [		stampHolder remove: tool.		self setAction: #paint: evt: evt].	"no use stamping with a blank stamp"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 09:24'!eyedropper: aButton action: aSelector cursor: aCursor evt: evt 	"Take total control and pick up a color!!!!"	| pt feedbackColor |	aButton state: #on.	tool		ifNotNil: [tool state: #off].	currentCursor _ aCursor.	evt hand showTemporaryCursor: currentCursor hotSpotOffset: 6 negated @ 4 negated.	"<<<< the form was changed a bit??"	feedbackColor _ Display colorAt: Sensor cursorPoint.	self addMorphFront: colorMemory.	"Full color picker"	[Sensor anyButtonPressed]		whileFalse: [pt _ Sensor cursorPoint.			"deal with the fact that 32 bit displays may have garbage in the 			alpha bits"			feedbackColor _ Display depth = 32						ifTrue: [Color								colorFromPixelValue: ((Display pixelValueAt: pt)										bitOr: 4278190080)								depth: 32]						ifFalse: [Display colorAt: pt].			"the hand needs to be drawn"			evt hand position: pt.			self world displayWorldSafely].	Sensor waitNoButton.	evt hand showTemporaryCursor: nil hotSpotOffset: 0 @ 0.	self currentColor: feedbackColor evt: evt.	colorMemory delete.	tool		ifNotNil: [tool state: #on.			currentCursor _ tool arguments at: 3].	aButton state: #off! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:48'!keep: keepButton with: keepSelector evt: evt	"Showing of the corrent palette (viewer or noPalette) is done by the block submitted to the SketchMorphEditor, see (EToyHand makeNewDrawing) and (SketchMorph editDrawingInWorld:forBackground:)."	| ss |	owner ifNil: [^ self].	keepButton ifNotNil: [keepButton state: #off].	(ss _ self focusMorph) 		ifNotNil: [ss savePainting: self evt: evt]		ifNil:		[keepSelector == #silent ifTrue: [^ self].		self notCurrentlyPainting].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:43'!pickup: actionButton action: aSelector cursor: aCursor evt: evt	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor evt: evt.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3) evt: evt].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3) evt: evt]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // -2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self focusMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [self notCurrentlyPainting.				self setAction: #paint: evt: evt]].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/17/2000 14:59'!pickupForm: stampForm evt: evt	"Install the new picture in this stamp"	| stampButton |	stampHolder stampForm: stampForm for: tool.	stampButton _ action == #pickup: 		ifTrue: [stampHolder otherButtonFor: tool]		ifFalse: [tool].	"was a nil stampForm"	stampButton state: #on.	stampButton doButtonAction: evt.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 13:40'!plainCursor	"Return the cursor to use with this painting action/tool. Offset of the form must be set."	^currentCursor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 13:30'!ringColor	"Choose a color that contrasts with my current color. If that color isn't redish, return red. Otherwise, return green"	^self ringColorFor: currentColor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 13:29'!ringColorFor: aColor	"Choose a color that contrasts with my current color. If that color isn't redish, return red. Otherwise, return green"	aColor isTransparent ifTrue: [^ Color red].	aColor red < 0.5 ifTrue: [^ Color red].	aColor red > (aColor green + (aColor blue * 0.5))		ifTrue: [^ Color green]		ifFalse: [^ Color red].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:44'!scrollStamps: actionButton action: aSelector evt: evt	"Move the stamps over"	aSelector == #prevStamp:		ifTrue: [stampHolder scroll: -1]		ifFalse: [stampHolder scroll: 1].	actionButton state: #off.	action == #stamp: ifTrue: ["reselect the stamp and compute the cursor"		self stampForm 			ifNil: [self setAction: #paint: evt: evt]			ifNotNil: [tool doButtonAction: evt]].		! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:16'!setAction: aSelector evt: evt	"Find this button and turn it on.  Does not work for stamps or pickups"	| button |	button _ self findButton: aSelector. 	button ifNotNil: [		button state: #on.		button doButtonAction: evt].	"select it!!"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:19'!takeColorEvt: evt from: colorPicker	"Accept a new color from the colorMemory.  Programs use currentColor: instead.  Do not do this before the picker has a chance to set its own color!!"	currentColor _ colorPicker currentColor.	self notifyWeakDependentsWith: {#currentColor. evt. currentColor}.	self showColor.	self colorable ifFalse: [self setAction: #paint: evt: evt].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 12:38'!tool: actionButton action: aSelector cursor: aCursor evt: evt	"Set the current tool and action for the paintBox.  "	tool ifNotNil: [		tool == actionButton ifFalse: [			tool state: #off.			action == #stamp: ifTrue: [self stampDeEmphasize]]].	tool _ actionButton.		"A ThreePhaseButtonMorph"	"tool state: #on.	already done"	action _ aSelector.		"paint:"	currentCursor _ aCursor.	self notifyWeakDependentsWith: {#action. evt. action}.	self notifyWeakDependentsWith: {#currentCursor. evt. currentCursor}.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:45'!toss: cancelButton with: cancelSelector evt: evt	"Reject the painting.  Showing noPalette is done by the block submitted to the SketchEditorMorph"	| focus |	owner ifNil: ["it happens"  ^ self].	(focus _ self focusMorph) 		ifNotNil: [focus cancelPainting: self evt: evt]		ifNil:			[self delete].	cancelButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 11:15'!undo: undoButton with: undoSelector evt: evt	| ss |	(ss _ self focusMorph) 		ifNotNil: [ss undoPainting: self evt: evt]		ifNil: [self notCurrentlyPainting].	undoButton state: #off.! !!PasteUpMorph methodsFor: 'misc' stamp: 'RAA 8/14/2000 12:10'!shouldGetStepsFrom: aWorld	(self isWorldMorph and: [owner notNil]) ifTrue: [		^self outermostWorldMorph == aWorld	].	^super shouldGetStepsFrom: aWorld! !!PasteUpMorph methodsFor: 'misc' stamp: 'RAA 8/14/2000 11:50'!step	(self isWorldMorph and: [owner notNil]) ifTrue: [		^self runLocalStepMethods	].	super step! !!PasteUpMorph methodsFor: 'misc' stamp: 'RAA 8/14/2000 11:50'!stepTime	(self isWorldMorph and: [owner notNil]) ifTrue: [		^1	].	^super stepTime! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 8/14/2000 11:48'!installAsActiveSubprojectIn: enclosingWorld at: newBounds titled: aString	| window howToOpen tm boundsForWorld |	howToOpen _ self embeddedProjectDisplayMode.					"#scaled may be the only one that works at the moment"	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	boundsForWorld _ howToOpen == #naked ifTrue: [newBounds] ifFalse: [bounds].	worldState canvas: nil.	worldState viewBox: boundsForWorld.	self bounds: boundsForWorld.	"self viewBox: Display boundingBox."	"worldState handsDo: [:h | h initForEvents]."	self installFlaps.	"SystemWindow noteTopWindowIn: self."	"self displayWorldSafely."	howToOpen == #naked ifTrue: [		enclosingWorld addMorphFront: self.	].	howToOpen == #window ifTrue: [		window _ (NewWorldWindow labelled: aString) model: self.		window addMorph: self frame: (0@0 extent: 1.0@1.0).		window openInWorld: enclosingWorld.	].	howToOpen == #frame ifTrue: [		window _ AlignmentMorphBob1 new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			heights: #(999999);			bounds: newBounds.		window addMorph: self.		window openInWorld: enclosingWorld.	].	howToOpen == #scaled ifTrue: [		self position: 0@0.		window _ EmbeddedWorldBorderMorph new			minWidth: 100;			minHeight: 100;			borderWidth: 8;			borderColor: Color green;			bounds: newBounds.		tm _ BOBTransformationMorph new.		window addMorph: tm.		tm addMorph: self.		window openInWorld: enclosingWorld.		tm changeWorldBoundsToShow: bounds.		self arrangeToStartSteppingIn: enclosingWorld.		"tm scale: (tm width / self width min: tm height / self height) asFloat."	].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 8/14/2000 18:44'!mouseDown: evt	"Handle a mouse down event."	self isWorldMorph		ifTrue:			[evt hand newKeyboardFocus: self.			evt hand escapeIfQuickClick: [^ self quickClickOnDesktop: evt]				ifMoved: [^ self dragThroughOnDesktop: evt].			evt hand invokeMetaMenu: evt]		ifFalse:			[^ super mouseDown: evt]! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 8/7/2000 12:09'!repairEmbeddedWorlds	| transform eWorld toDoList |	toDoList _ OrderedCollection new.	self allMorphsDo: [ :each |		(each isKindOf: EmbeddedWorldBorderMorph) ifTrue: [			transform _ each submorphs at: 1 ifAbsent: [nil].			transform ifNotNil: [				eWorld _ transform submorphs at: 1 ifAbsent: [nil].				eWorld ifNotNil: [					toDoList add: {transform. eWorld}.				].			].			"Smalltalk at: #Q put: {self. each. transform. eWorld}."		].	].	toDoList do: [ :each |		each first addMorph: each second.	].! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 8/13/2000 18:56'!extent	self apply: [ :c | ^c extent ].! !!PluggableCanvas methodsFor: 'canvas methods' stamp: 'RAA 8/13/2000 18:57'!origin	self apply: [ :c | ^c origin ].! !!BufferedCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 12:33'!sendDeltas"NebraskaDebug showStats: #sendDeltas"	| t current deltas dirtyFraction |	previousVersion ifNil: [		previousVersion _ Display deepCopy.		remote 			image: previousVersion 			at: 0@0 			sourceRect: previousVersion boundingBox 			rule: Form paint.		^remote forceToScreen: previousVersion boundingBox.	].	dirtyRect ifNil: [^self].	t _ Time millisecondClockValue.	dirtyFraction _ dirtyRect area / previousVersion boundingBox area roundTo: 0.0001.	dirtyFraction > 0.75 ifTrue: [		"may be faster to do the whole thing"		dirtyRect _ previousVersion boundingBox.		current _ Display deepCopy.		deltas _ current deltaFrom: previousVersion.		previousVersion _ current.	] ifFalse: [		current _ Display copy: dirtyRect.		deltas _ previousVersion deltaFrom: current at: dirtyRect origin.		previousVersion copy: dirtyRect from: 0@0 in: current rule: Form over.	].	remote 		image: deltas at: dirtyRect origin sourceRect: deltas boundingBox rule: Form reverse;		forceToScreen: dirtyRect.	t _ Time millisecondClockValue - t.	NebraskaDebug at: #sendDeltas add: {t. dirtyFraction. deltas boundingBox}.	dirtyRect _ nil.! !!BufferedCanvas class methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 18:50'!enabledString	^self enabled ifTrue: ['B'] ifFalse: ['b']! !!MultiCanvas methodsFor: 'private' stamp: 'RAA 8/14/2000 10:27'!contentsOfArea: aRectangle into: aForm	self apply: [ :c |		(c isKindOf: FormCanvas) ifTrue: [			c contentsOfArea: aRectangle into: aForm.			^aForm		].	].	self apply: [ :c |		c contentsOfArea: aRectangle into: aForm.		^aForm.	].	^aForm! !!Preferences class methodsFor: 'help' stamp: 'RAA 8/7/2000 19:24'!helpMsgsRecordWhilePlaying	^ #((canRecordWhilePlaying	'If true, recording and playing sounds concurrently are permitted (platform dependent).'))! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 8/7/2000 19:21'!canRecordWhilePlaying	^ self valueOfFlag: #canRecordWhilePlaying! !!Preferences class methodsFor: 'initial values' stamp: 'RAA 8/7/2000 19:15'!initialValuesRecordWhilePlaying	^ #((canRecordWhilePlaying false (media ) ) )! !!Project methodsFor: 'menu messages' stamp: 'RAA 8/7/2000 11:13'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject makeThumbnail.			returningFlag == #specialReturn ifTrue: [				ProjectHistory forget: CurrentProject.		"this guy is irrelevant"			] ifFalse: [				ProjectHistory remember: CurrentProject.			].		].	(revertFlag | saveForRevert | forceRevert) ifFalse: [		(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [			self storeToMakeRoom]].	Smalltalk isMorphic ifTrue: [Display bestGuessOfCurrentWorld triggerClosingScripts].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ Display pauseMorphicEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[Display changeMorphicWorldTo: world.  "Signifies Morphic"			world install.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[Display changeMorphicWorldTo: nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 8/8/2000 10:42'!spawnNewProcessIfThisIsUI: suspendedProcess	self uiProcess == suspendedProcess ifTrue: [		self spawnNewProcess.		^true	].	^false		"no new process was created"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 15:26'!addButtons	self 		addButton: '< Prev' balloonText: 'Previous project' for: #previousProject;		addButton: 'Next >' balloonText: 'Next project' for: #nextProject;		addButton: '^ Publish' balloonText: 'Publish this project. Save it where it came from (server, hard disk, etc.) ' for: #publishProject;		addButton: 'Newer?' balloonText: 'Is there a newer version of this project ?' for: #getNewerVersionIfAvailable;		addButton: 'Tell!!' balloonText: 'Tell a friend about this project' for: #tellAFriend;		addButton: 'Find...' balloonText: 'Find a project' for: #findAProject.	self inFullScreenMode ifTrue: [		self addButton: 'Browser Reentry' balloonText: 'Re-enter the browser' for: #fullScreenOff	] ifFalse: [		self addButton: 'Escape Browser' balloonText: 'Use the full screen' for: #fullScreenOn	].	self inFlapsSuppressedMode ifTrue: [		self addButton: 'Show tabs' balloonText: 'Show tabs' for: #toggleFlapsSuppressed	] ifFalse: [		self addButton: 'Hide tabs' balloonText: 'Hide tabs' for: #toggleFlapsSuppressed	].	self 		addButton: 'Share' 		balloonText: 'Share this project so that others can explore it with you.' 		for: #shareThisWorld! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 15:26'!currentNavigatorVersion	^9		"since these guys get saved, we fix them up if they are older versions"! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 14:26'!positionVertically	| wb |	wb _ self worldBounds.	mouseInside == true ifTrue: [		(self top - wb top) abs < (self bottom - wb bottom) abs ifTrue: [			self top: wb top		] ifFalse: [			self bottom: wb bottom		].	] ifFalse: [		(self top - wb top) abs < (self bottom - wb bottom) abs ifTrue: [			self bottom: wb top + 8		] ifFalse: [			self top: wb bottom - 8		].	].! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/4/2000 15:24'!shareThisWorld	NebraskaServerMorph serveWorld: self world! !!RemoteCanvas methodsFor: 'drawing-support' stamp: 'RAA 8/14/2000 13:19'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	self flag: #bob.	"we are not getting here"	^super transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize! !!RemoteControlledHandMorph methodsFor: 'events' stamp: 'RAA 8/14/2000 18:39'!queueEvent: anEvent	"add an event to be handled"	anEvent setSourceHand: self.	self handleEvent: anEvent! !!RemoteControlledHandMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 18:44'!escapeIfQuickClick: quickClickBlock ifMoved: movedBlock	"The mouse just went down.  Pause briefly and then check to see whether it is still down and whether it has moved a significant amount; evaluate quickClickBlock or movedBlock as appropriate."	self flag: #bob.		"Don't know how to do this for remote hands yet"! !!SampledSound methodsFor: 'playing' stamp: 'RAA 8/12/2000 15:11'!setScaledIncrement: aNumber	scaledIncrement _ (aNumber * IncrementScaleFactor) rounded.! !!SequentialSound methodsFor: 'composition' stamp: 'RAA 8/9/2000 16:27'!removeFirstCompleteSoundOrNil	"Remove the first sound if it has been completely recorded."	| firstSound |	sounds size > 0 ifFalse: [^ nil].	firstSound _ sounds first.	sounds _ sounds copyFrom: 2 to: sounds size.	^firstSound! !!SharedQueue methodsFor: 'accessing' stamp: 'RAA 8/4/2000 12:20'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	| value |	accessProtect critical: [		readPosition = writePosition ifTrue: [			value _ nil		] ifFalse: [			value _ contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition _ readPosition + 1		]	].	^value! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'RAA 8/16/2000 00:58'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	"NB: if aPosition is nil, then it's assumed that the paintbox is obtained from a flap or some such, so do nothing special regarding a palette in this case.  The palette needs already to be in the world for this to work."	| w  |	(w _ aPasteUpMorph world) addMorphFront: self.	enclosingPasteUpMorph _ aPasteUpMorph.	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	palette _ w paintBox focusMorph: self.	palette beStatic.		"give Nebraska whatever help we can"	palette fixupButtons.	palette addWeakDependent: self.	aPosition ifNotNil:		[w addMorphFront: palette.  "bring to front"		palette position: aPosition].	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'RAA 8/16/2000 11:21'!mouseDown: evt	"Start a new stroke.  Check if any palette setting have changed.  6/11/97 20:30 tk"	| cur pfPen myAction |	"verify that we are in a good state"	self verifyState: evt.		"includes prepareToPaint and #scalingOrRotate"	pfPen _ self get: #paintingFormPen for: evt.	undoBuffer _ paintingForm deepCopy.	"know we will draw something"	pfPen place: (evt cursorPoint - bounds origin).	myAction _ self getActionFor: evt.	self set: #strokeOrigin for: evt to: evt cursorPoint.		"origin point for pickup: rect: ellispe: polygon: line: star:.  Always take it."	myAction == #pickup: ifTrue: [		cur _ Cursor corner clone.		cur offset: 0@0  "cur offset abs".		evt hand showTemporaryCursor: cur].	myAction == #polygon: ifTrue: [self polyNew: evt].	"a mode lets you drag vertices"! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'RAA 8/16/2000 12:39'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| poly top cColor |	super mouseEnter: evt.	top _ evt hand recipientForMouseDown: evt.	top == self ifFalse: [^self].		"one of my buttons in the way"	evt hand showTemporaryCursor: (self getCursorFor: evt).	palette getSpecial == #polygon: ifFalse: [^self].	(poly _ self valueOfProperty: #polygon) ifNil: [^ self].	cColor _ self getColorFor: evt.	poly color: cColor; borderWidth: 1.	poly changed.! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'RAA 8/16/2000 11:56'!mouseMove: evt	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt priorEvt |	WorldState canSurrenderToOS: false.		"we want maximum responsiveness"	pt _ evt cursorPoint.	priorEvt _ self get: #lastEvent for: evt.	(priorEvt ~~ nil and: [pt = priorEvt cursorPoint]) ifTrue: [^ self].	self perform: (self getActionFor: evt) with: evt.		"Each action must do invalidRect:"	self set: #lastEvent for: evt to: evt.	false ifTrue: ["So senders will find the things performed here"		self paint: nil; fill: nil; areaFill: nil; erase: nil; pickup: nil; stamp: nil.		self rect: nil; ellipse: nil; polygon: nil; line: nil; star: nil].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'RAA 8/16/2000 11:52'!mouseUp: evt	| myAction |	"Do nothing except those that work on mouseUp."	myAction _ self getActionFor: evt.	myAction == #fill: ifTrue: [		self perform: myAction with: evt.		"Each action must do invalidRect:"		].	myAction == #areaFill: ifTrue: ["old, remove it"		self perform: myAction with: evt.		"Each action must do invalidRect:"		].	myAction == #pickup: ifTrue: [		self pickupMouseUp: evt].	self set: #lastEvent for: evt to: nil.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/15/2000 20:00'!addRotationScaleHandles	"Rotation and scaling handles"	rotationButton _ SketchMorph withForm: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep: to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph withForm: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs."REMOVED:	fwdButton _ PolygonMorph new.	pt _ bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.		fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	"	self setProperty: #rotationStyle toValue: hostView rotationStyle."	self forward: hostView setupAngle direction: fwdButton.	"	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 01:46'!cancel: evt	"Palette is telling us that the use wants to end the painting session.  "	Cursor blank show.	self deliverPainting: #cancel evt: evt.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 11:14'!deliverPainting: result evt: evt	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm |	(self getActionFor: evt) == #areaFill: ifTrue: [palette setCurrentBrush: palette brush3a].	palette ifNotNil: "nil happens" [palette setAction: #paint: evt: evt].	"Get out of odd modes"	"rot _ palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [^ self cancelOutOfPainting].	"for Morphic"	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox _ paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.	registrationPoint ifNotNil:		[registrationPoint _ registrationPoint - newBox origin]. "relative to newForm origin"	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	self delete.	"so won't find me again"	dimForm delete.	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 11:28'!prepareToPaint: evt	"Figure out what the current brush, fill, etc is.  Return an action to take every mouseMove.  Set up instance variable and pens.  Prep for normal painting is inlined here.  tk 6/14/97 21:11"	| specialMode pfPen cColor cNib myBrush |	"Install the brush, color, (replace mode), and cursor."	specialMode _ self getActionFor: evt. 	cColor  _ self getColorFor: evt.	cNib _ self getNibFor: evt.	self set: #brush for: evt to: (myBrush _ cNib).	self set: #paintingFormPen for: evt to: (pfPen _ Pen newOnForm: paintingForm).	self set: #stampForm for: evt to: nil.	"let go of stamp"	formCanvas _ paintingForm getCanvas.	"remember to change when undo"	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	specialMode == #paint: ifTrue: [		"get it to one bit depth.  For speed, instead of going through a colorMap every time ."		self set: #brush for: evt to: (myBrush _ Form extent: myBrush extent depth: 1).		myBrush offset: (0@0) - (myBrush extent // 2).		cNib displayOn: myBrush at: (0@0 - cNib offset).		pfPen sourceForm: myBrush.		pfPen combinationRule: Form paint.		pfPen color: cColor.		cColor isTransparent ifTrue: [			pfPen combinationRule: Form erase1bitShape.			pfPen color: Color black].		^ #paint:].	specialMode == #erase: ifTrue: [		self erasePrep: evt.		^ #erase:].	specialMode == #stamp: ifTrue: [		self set: #stampForm for: evt to: palette stampForm.	"keep it"		^ #stamp:].	(self respondsTo: specialMode) 		ifTrue: [^ specialMode]	"fill: areaFill: pickup: (in mouseUp:) 				rect: ellipse: line: polygon: star:"		ifFalse: ["Don't recognise the command"			palette setAction: #paint: evt: evt.	"set it to Paint"			^ self prepareToPaint: evt].! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 11:14'!save: evt	"Palette is telling us that the use wants to end the painting session.  "	Cursor blank show.	(self getActionFor: evt) == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"	^ self deliverPainting: #okay evt: evt.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 11:18'!undo: evt	"revert to a previous state.  "	| temp poly |	self flag: #bob.		"what is undo in multihand environment?"	undoBuffer ifNil: [^ self beep].	"nothing to go back to"	(poly _ self valueOfProperty: #polygon) ifNotNil:		[poly delete.		self setProperty: #polygon toValue: nil.		^ self].	temp _ paintingForm.	paintingForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had by undoing again"	(self get: #paintingFormPen for: evt) setDestForm: paintingForm.	formCanvas _ paintingForm getCanvas.	"used for lines, ovals, etc."	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	self render: bounds.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 12:30'!verifyState: evt	| myAction |	"We are sure we will make a mark now.  Make sure the palette has not changed state while we were away.  If so, end this action and start another one.  6/11/97 19:52 tk  action, currentColor, brush"	"Install the brush, color, (replace mode), and cursor."	palette isInWorld ifFalse:		[self world addMorphFront: palette].  "It happens.  might want to position it also"	myAction _ self getActionFor: evt.	(self get: #changed for: evt) == false ifFalse: [		self set: #changed for: evt to: false.		self invalidRect: rotationButton bounds.	"snap these back"		rotationButton position: bounds topCenter - (6@0).		"later adjust by button width?"		self invalidRect: rotationButton bounds.		self invalidRect: scaleButton bounds.		scaleButton position: bounds rightCenter - ((scaleButton width)@6).		self invalidRect: scaleButton bounds.		myAction == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"		^ self set: #action for: evt to: (self prepareToPaint: evt)].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:47'!areaFill: evt 	"Find the area that is the same color as where you clicked. Fill it with 	the current paint color."	evt isMouseUp		ifFalse: [^ self].	"Only fill upon mouseUp"	Cursor execute		showWhile: [paintingForm				shapeFill: (self getColorFor: evt)				interiorPoint: evt cursorPoint - bounds origin.			"would like to only invalidate the area changed, but can't find 			out what it is."			self render: bounds]! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:55'!ellipse: evt	"Draw an ellipse from the center. "	| rect oldRect ww ext oldExt cColor sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	cColor _ self getColorFor: evt.	ext _ (sOrigin - evt cursorPoint) abs * 2.	evt shiftPressed ifTrue: [ext _ ext r].	rect _ Rectangle center: sOrigin extent: ext.	ww _ (self getNibFor: evt) width.	(priorEvt _ self get: #lastEvent for: evt) ifNotNil: [		oldExt _ (sOrigin - priorEvt cursorPoint) abs + ww * 2.		priorEvt shiftPressed ifTrue: [oldExt _ oldExt r].		(oldExt < ext) ifFalse: ["Last draw sticks out, must erase the area"			oldRect _ Rectangle center: sOrigin extent: oldExt.			self restoreRect: oldRect]].	cColor == Color transparent	ifFalse:[	formCanvas fillOval: rect color: cColor 		borderWidth: 0 borderColor: Color transparent.]	ifTrue:[	formCanvas fillOval: rect color: cColor 		borderWidth: ww borderColor: Color black].	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:30'!erasePrep: evt	"Transparent paint, square brush.  Be careful not to let this be undone by asking palette for brush and color."	| size pfPen myBrush |	pfPen _ self get: #paintingFormPen for: evt.	size _ (self getNibFor: evt) width.	self set: #brush for: evt to: (myBrush _ Form extent: size@size depth: 1).	myBrush offset: (0@0) - (myBrush extent // 2).	myBrush fillWithColor: Color black.	pfPen sourceForm: myBrush.	"transparent"	pfPen combinationRule: Form erase1bitShape.	pfPen color: Color black.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:46'!fill: evt 	"Find the area that is the same color as where you clicked. Fill it with 	the current paint color."	evt isMouseUp		ifFalse: [^ self].	"Only fill upon mouseUp"	"would like to only invalidate the area changed, but can't find out what it is."	Cursor execute		showWhile: [paintingForm				shapeFill: (self getColorFor: evt)				interiorPoint: evt cursorPoint - bounds origin.			self render: bounds]! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:06'!flipHoriz: evt 	"Flip the image"	| temp myBuff |	myBuff _ self get: #buff for: evt.	temp _ myBuff deepCopy flipBy: #horizontal centerAt: myBuff center.	temp offset: 0 @ 0.	paintingForm fillWithColor: Color transparent.	temp displayOn: paintingForm at: paintingForm center - myBuff center + myBuff offset.	rotationButton position: evt cursorPoint x - 6 @ rotationButton position y.	self render: bounds! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:06'!flipVert: evt 	"Flip the image"	| temp myBuff |	myBuff _ self get: #buff for: evt.	temp _ myBuff deepCopy flipBy: #vertical centerAt: myBuff center.	temp offset: 0 @ 0.	paintingForm fillWithColor: Color transparent.	temp displayOn: paintingForm at: paintingForm center - myBuff center + myBuff offset.	rotationButton position: evt cursorPoint x - 6 @ rotationButton position y.	self render: bounds! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:54'!line: evt 	"Draw a line on the paintingForm using formCanvas aimed at it."	| rect oldRect ww now diff cor cColor sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	rect _ sOrigin rect: (now _ evt cursorPoint).	evt shiftPressed		ifTrue: [diff _ evt cursorPoint - sOrigin.			now _ sOrigin						+ (Point r: diff r degrees: diff degrees + 22.5 // 45 * 45).			rect _ sOrigin rect: now].	ww _ (self getNibFor: evt) width.	(priorEvt _ self get: #lastEvent for: evt)		ifNotNil: [oldRect _ sOrigin rect: priorEvt cursorPoint.			priorEvt shiftPressed				ifTrue: [diff _ priorEvt cursorPoint - sOrigin.					cor _ sOrigin								+ (Point r: diff r degrees: diff degrees + 22.5 // 45 * 45).					oldRect _ sOrigin rect: cor].			oldRect _ oldRect expandBy: ww @ ww.			"Last draw will always stick out, must erase the area"			self restoreRect: oldRect].	cColor _ self getColorFor: evt.	formCanvas		line: sOrigin		to: now		width: ww		color: cColor.	self invalidRect: rect! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:22'!paint: evt	"While the mouse is down, lay down paint, but only within window bounds.	 11/28/96 sw: no longer stop painting when pen strays out of window; once it comes back in, resume painting rather than waiting for a mouse up"	|  mousePoint startRect endRect startToEnd pfPen myBrush |	pfPen _ self get: #paintingFormPen for: evt.	myBrush _ self getBrushFor: evt.	mousePoint _ evt cursorPoint.	startRect _ pfPen location + myBrush offset extent: myBrush extent.	pfPen goto: mousePoint - bounds origin.	endRect _ pfPen location + myBrush offset extent: myBrush extent.	"self render: (startRect merge: endRect).	Show the user what happened"	startToEnd _ startRect merge: endRect.	self invalidRect: (startToEnd translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:57'!pickup: evt	"Grab a part of the picture (or screen) and store it in a known place.  Note where we started.  Use a rubberband rectangle to show what is being selected."	| rect oldRect sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	rect _ sOrigin rect: evt cursorPoint + (14@14).	(priorEvt _ self get: #lastEvent for: evt) == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ sOrigin rect: priorEvt cursorPoint + (14@14).			self restoreRect: (oldRect insetBy: -2)].	formCanvas frameAndFillRectangle: (rect insetBy: -2) fillColor: Color transparent		borderWidth: 2 borderColor: Color gray.	self invalidRect: (rect insetBy: -2).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/17/2000 15:00'!pickupMouseUp: evt	"Grab a part of the picture (or screen) and store it in a known place. Like Copy on the Mac menu. Then switch to the stamp tool."	| rr pForm ii oldRect sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	(priorEvt _ self get: #lastEvent for: evt) == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ sOrigin rect: priorEvt cursorPoint + (14@14).			self restoreRect: (oldRect insetBy: -2)].	self primaryHand showTemporaryCursor: nil.	"later get rid of this"		rr _ sOrigin rect: evt cursorPoint + (14@14).	ii _ rr translateBy: (0@0) - bounds origin.	(rr intersects: bounds) ifTrue: [		pForm _ paintingForm copy: ii.		pForm isAllWhite "means transparent" 			ifFalse: []	"normal case.  Can be transparent in parts"			ifTrue: [pForm _ nil.			"Get an un-dimmed picture of other objects on the playfield"			"don't know how yet"]].	pForm ifNil: [pForm _ Form fromDisplay: rr].		"Anywhere on the screen"	palette pickupForm: pForm evt: evt.	evt hand showTemporaryCursor: (self getCursorFor: evt).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 16:54'!polyNew: evt	"Create a new polygon.  Add it to the sketch, and let the user dragits vertices around!!  Freeze it into the painting when the user choosesanother tool."	| poly cColor |	cColor _ self getColorFor: evt.	self polyFreeze.		"any old one we were working on"	poly _ PolygonMorph new addHandles. 	cColor == Color transparent	ifFalse:[	poly color: cColor; borderWidth: 0;	borderColor: Color transparent]	ifTrue:[	poly color: cColor; borderWidth: 1;     "still some problems with brushsize !!!!"	borderColor: Color black].	poly position: evt cursorPoint.	self addMorph: poly.	poly changed.	self setProperty: #polygon toValue: poly.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:57'!rect: evt 	"While moving corner, just write on the canvas. When done, write 	on the paintingForm"	| rect within oldRect now diff cor cColor sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	rect _ sOrigin rect: (now _ evt cursorPoint).	cColor _ self getColorFor: evt.	evt shiftPressed		ifTrue: [diff _ evt cursorPoint - sOrigin.			now _ sOrigin						+ (Point r: (diff x abs min: diff y abs)									* 2 degrees: diff degrees // 90 * 90 + 45).			rect _ sOrigin rect: now].	(priorEvt _ self get: #lastEvent for: evt) == nil		ifFalse: [oldRect _ sOrigin rect: priorEvt cursorPoint.			priorEvt shiftPressed				ifTrue: [diff _ priorEvt cursorPoint - sOrigin.					cor _ sOrigin								+ (Point r: (diff x abs min: diff y abs)											* 2 degrees: diff degrees // 90 * 90 + 45).					oldRect _ sOrigin rect: cor].			within _ rect containsRect: oldRect.			within & cColor isTransparent not				ifFalse: ["Last draw will stick out, must erase the area"					self restoreRect: oldRect]].	cColor == Color transparent		ifTrue: [formCanvas				frameAndFillRectangle: rect				fillColor: cColor				borderWidth: (self getNibFor: evt) width				borderColor: Color black]		ifFalse: [formCanvas				frameAndFillRectangle: rect				fillColor: cColor				borderWidth: 0				borderColor: Color transparent].	self invalidRect: rect! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 17:13'!render: damageRect	"Compose the damaged area again and store on the display.  damageRect is relative to paintingForm origin.  3/19/97 tk"	self invalidRect: damageRect.	"Now in same coords as self bounds"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:07'!rotateBy: evt 	"Left-right is rotation. 3/26/97 tk Slider at top of window. 4/3/97 tk"	| pt temp amt smooth myBuff |	myBuff _ self get: #buff for: evt.	evt cursorPoint x - self left < 20		ifTrue: [^ self flipHoriz: evt].	"at left end flip horizontal"	evt cursorPoint x - self right > -20		ifTrue: [^ self flipVert: evt].	"at right end flip vertical"	pt _ evt cursorPoint - bounds center.	smooth _ 2.	"paintingForm depth > 8 ifTrue: [2] ifFalse: [1]."	"Could go back to 1 for speed"	amt _ pt x abs < 12				ifTrue: ["detent"					0]				ifFalse: [pt x - (12 * pt x abs // pt x)].	amt _ amt * 1.8.	temp _ myBuff				rotateBy: amt				magnify: cumMag				smoothing: smooth.	temp displayOn: paintingForm at: paintingForm center - temp center + myBuff offset.	rotationButton position: evt cursorPoint x - 6 @ rotationButton position y.	self render: bounds.	cumRot _ amt! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:23'!rotateScalePrep: evt	"Make a source that is the paintingForm.  Work from that.  3/26/97 tk"	| newBox myBuff |	(self getActionFor: evt) == #scaleOrRotate ifTrue: [^ self].	"Already doing it"	paintingForm width > 120 		ifTrue: [newBox _ paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.			"minimum size"			newBox _ newBox insetBy: 				((18 - newBox width max: 0)//2) @ ((18 - newBox height max: 0)//2) * -1]		ifFalse: [newBox _ paintingForm boundingBox].	newBox _ newBox expandBy: 1.	self set: #buff for: evt to: (myBuff _ Form extent: newBox extent depth: paintingForm depth).	myBuff offset: newBox center - paintingForm center.	myBuff copyBits: newBox from: paintingForm at: 0@0 		clippingBox: myBuff boundingBox rule: Form over fillColor: nil.	"Could just run up owner chain asking colorUsed, but may not be embedded"	cumRot _ 0.0.  cumMag _ 1.0.	"start over"	self set: #action for: evt to: #scaleOrRotate.		"Only changed by mouseDown with tool in paint area"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:06'!scaleBy: evt 	"up-down is scale. 3/26/97 tk Now a slider on the right."	| pt temp cy oldRect amt myBuff |	myBuff _ self get: #buff for: evt.	pt _ evt cursorPoint - bounds center.	cy _ bounds height * 0.5.	oldRect _ myBuff boundingBox expandBy: myBuff extent * cumMag / 2.	amt _ pt y abs < 12				ifTrue: ["detent"					1.0]				ifFalse: [pt y - (12 * pt y abs // pt x)].	amt _ amt asFloat / cy + 1.0.	temp _ myBuff				rotateBy: cumRot				magnify: amt				smoothing: 2.	cumMag > amt		ifTrue: ["shrinking"			oldRect _ oldRect translateBy: paintingForm center - oldRect center + myBuff offset.			paintingForm				fill: (oldRect expandBy: 1 @ 1)				rule: Form over				fillColor: Color transparent].	temp displayOn: paintingForm at: paintingForm center - temp center + myBuff offset.	scaleButton position: scaleButton position x @ (evt cursorPoint y - 6).	self render: bounds.	cumMag _ amt! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 17:43'!stamp: evt	"plop one copy of the user's chosen Form down."	"Check depths"	| pt sForm |	sForm _ self get: #stampForm for: evt.	pt _ evt cursorPoint - (sForm extent // 2).	sForm displayOn: paintingForm 		at: pt - bounds origin		clippingBox: paintingForm boundingBox		rule: Form paint		fillColor: nil.	self render: (pt extent: sForm extent).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:55'!star: evt 	"Draw an star from the center."	| poly ext ww rect oldExt oldRect oldR verts pt cColor sOrigin priorEvt |	sOrigin _ self get: #strokeOrigin for: evt.	cColor _ self getColorFor: evt.	ww _ (self getNibFor: evt) width.	ext _ (pt _ sOrigin - evt cursorPoint) r + ww * 2.	rect _ Rectangle center: sOrigin extent: ext.	(priorEvt _ self get: #lastEvent for: evt)		ifNotNil: [oldExt _ (sOrigin - priorEvt cursorPoint) r + ww * 2.			"Last draw sticks out, must erase the area"			oldRect _ Rectangle center: sOrigin extent: oldExt.			self restoreRect: oldRect].	ext _ pt r.	oldR _ ext.	verts _ (0 to: 350 by: 36)				collect: [:angle | (Point r: (oldR _ oldR = ext									ifTrue: [ext * 5 // 12]									ifFalse: [ext]) degrees: angle + pt degrees)						+ sOrigin].	poly _ PolygonMorph new addHandles.	cColor == Color transparent		ifTrue: [poly color: cColor;				 borderWidth: 1;				 borderColor: Color black]		ifFalse: [poly color: cColor;				 borderWidth: 0;				 borderColor: Color transparent].	"can't handle thick brushes"	self invalidRect: rect.	"self addMorph: poly."	poly privateOwner: self.	poly		bounds: (sOrigin extent: ext).	poly setVertices: verts.	poly drawOn: formCanvas.	"poly delete."	self invalidRect: rect! !!SketchEditorMorph methodsFor: 'copying' stamp: 'RAA 8/16/2000 12:29'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."hostView _ hostView.		Weakly copied"	"stampForm _ stampForm veryDeepCopyWith: deepCopier."	"canvasRectangle _ canvasRectangle veryDeepCopyWith: deepCopier."palette _ palette veryDeepCopyWith: deepCopier.	"currentColor _ currentColor veryDeepCopyWith: deepCopier."ticksToDwell _ ticksToDwell veryDeepCopyWith: deepCopier.rotationCenter _ rotationCenter veryDeepCopyWith: deepCopier.registrationPoint _ registrationPoint veryDeepCopyWith: deepCopier.newPicBlock _ newPicBlock veryDeepCopyWith: deepCopier.emptyPicBlock _ emptyPicBlock veryDeepCopyWith: deepCopier.	"action _ action veryDeepCopyWith: deepCopier."paintingForm _ paintingForm veryDeepCopyWith: deepCopier.dimForm _ dimForm veryDeepCopyWith: deepCopier.	"buff _ buff veryDeepCopyWith: deepCopier."	"brush _ brush veryDeepCopyWith: deepCopier."	"paintingFormPen _ paintingFormPen veryDeepCopyWith: deepCopier."formCanvas _ formCanvas veryDeepCopyWith: deepCopier.	"picToBuff _ picToBuff veryDeepCopyWith: deepCopier."	"brushToBuff _ brushToBuff veryDeepCopyWith: deepCopier."	"buffToBuff _ buffToBuff veryDeepCopyWith: deepCopier."	"buffToPic _ buffToPic veryDeepCopyWith: deepCopier."rotationButton _ rotationButton veryDeepCopyWith: deepCopier.scaleButton _ scaleButton veryDeepCopyWith: deepCopier.	"strokeOrigin _ strokeOrigin veryDeepCopyWith: deepCopier."cumRot _ cumRot veryDeepCopyWith: deepCopier.cumMag _ cumMag veryDeepCopyWith: deepCopier.undoBuffer _ undoBuffer veryDeepCopyWith: deepCopier.	"lastEvent _ lastEvent veryDeepCopyWith: deepCopier."	"currentNib _ currentNib veryDeepCopyWith: deepCopier."enclosingPasteUpMorph _ enclosingPasteUpMorph.	"weakly copied"forEachHand _ nil.	"hmm..."                              ! !!SketchEditorMorph methodsFor: 'palette handling' stamp: 'RAA 8/16/2000 01:47'!cancelPainting: aPaintBoxMorph evt: evt	"Undo the operation after user issued #cancel in aPaintBoxMorph"	^self cancel: evt! !!SketchEditorMorph methodsFor: 'palette handling' stamp: 'RAA 8/14/2000 10:57'!dimTheWindow	| bgColor |	"Updated to use TranslucentColor by kfr 10/5 00"	"Do not call twice!! Installs a morph with an 'onion-skinned' copy of the pixels behind me." 	"create an 'onion-skinned' version of the stuff on the screen"	owner outermostMorphThat: [:morph | morph resumeAfterDrawError. false].	"an experiment for Nebraska to see if opaque background speeds things up"	bgColor _ false ifTrue: [TranslucentColor r:1.0 g:1.0 b:1.0 alpha:0.5] ifFalse: [Color white].	dimForm _ (RectangleMorph new color: bgColor; bounds: self bounds; borderWidth: 0).	dimForm position: self position.	owner		privateAddMorph: dimForm		atIndex: (owner submorphs indexOf: self) + 1.! !!SketchEditorMorph methodsFor: 'palette handling' stamp: 'RAA 8/15/2000 18:02'!paintBoxChanged: arguments	self set: arguments first for: arguments second to: arguments third.! !!SketchEditorMorph methodsFor: 'palette handling' stamp: 'RAA 8/16/2000 01:48'!savePainting: aPaintBoxMorph evt: evt	"Save the image after user issued #keep in aPaintBoxMorph"	^self save: evt! !!SketchEditorMorph methodsFor: 'palette handling' stamp: 'RAA 8/16/2000 11:17'!undoPainting: aPaintBoxMorph evt: evt	"Undo the operation after user issued #undo in aPaintBoxMorph"	^self undo: evt! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 15:13'!get: aSymbol for: anEventOrHand	| valuesForHand |	valuesForHand _ self valuesForHand: anEventOrHand.	^valuesForHand at: aSymbol ifAbsent: [nil].! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/16/2000 11:14'!getActionFor: anEventOrHand	^(self get: #action for: anEventOrHand) ifNil: [		self set: #action for: anEventOrHand to: palette action	].! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 17:56'!getBrushFor: anEventOrHand	^(self get: #brush for: anEventOrHand) ifNil: [		self set: #brush for: anEventOrHand to: palette getNib	].! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/16/2000 11:20'!getColorFor: anEventOrHand	^(self get: #currentColor for: anEventOrHand) ifNil: [		self set: #currentColor for: anEventOrHand to: palette getColor	].! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/16/2000 13:40'!getCursorFor: anEventOrHand	| plainCursor |	plainCursor _ (self get: #currentCursor for: anEventOrHand) ifNil: [		self set: #currentCursor for: anEventOrHand to: palette plainCursor	].	^palette		cursorFor: (self getActionFor: anEventOrHand) 		oldCursor: plainCursor 		currentNib: (self getNibFor: anEventOrHand) 		color: (self getColorFor: anEventOrHand)! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 17:16'!getNibFor: anEventOrHand	^(self get: #currentNib for: anEventOrHand) ifNil: [		self set: #currentNib for: anEventOrHand to: palette getNib	].! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 15:20'!set: aSymbol for: anEventOrHand to: anObject	| valuesForHand |	valuesForHand _ self valuesForHand: anEventOrHand.	valuesForHand at: aSymbol put: anObject.	^anObject! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 15:12'!valuesForHand: anEventOrHand	| hand valuesForHand |	forEachHand ifNil: [forEachHand _ IdentityDictionary new].	hand _ (anEventOrHand isKindOf: HandMorph) 				ifTrue: [anEventOrHand] ifFalse: [anEventOrHand hand].	valuesForHand _ forEachHand at: hand ifAbsentPut: [Dictionary new].	^valuesForHand! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 18:01'!valuesForHandIfPresent: anEventOrHand	| hand |	forEachHand ifNil: [forEachHand _ IdentityDictionary new].	hand _ (anEventOrHand isKindOf: HandMorph) 				ifTrue: [anEventOrHand] ifFalse: [anEventOrHand hand].	^forEachHand at: hand ifAbsent: [nil].! !!SoundPlayer class methodsFor: 'playing' stamp: 'RAA 8/7/2000 19:22'!canStartPlayer	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."	Preferences canRecordWhilePlaying ifTrue: [^ true].	SoundRecorder allSubInstancesDo: [:rec | rec isActive ifTrue: [^ false]].	^ true! !!SoundRecorder methodsFor: 'recording controls' stamp: 'RAA 8/13/2000 11:37'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused _ true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer.				self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying _ nil].	"Note: there can be problems if canRecordWhilePlaying is true. Recorders which only pause will inhibit other recorders from recording. I chose to make #stopPlaying unconditional in a subclass. The same might be appropriate here at the expense of making recorders resumable"	Preferences canRecordWhilePlaying ifFalse: [self stopRecording].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 10/17/97 14:53'!playback	"Playback the sound that has been recorded."	self pause.	soundPlaying _ self recordedSound.	soundPlaying play.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'RAA 8/13/2000 11:41'!resumeRecording	"Continue recording from the point at which it was last paused."	self flag: #bob.	"Note: If canRecordWhilePlaying is true, then recordings may never get started (at least by this method). One possibility, used in a subclass, is to make the #startPlaying unconditional. Another would be to use #startPlaying instead of #resumePlaying in appropriate cases"	Preferences canRecordWhilePlaying ifFalse: [self startRecording].	paused _ false.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'RAA 8/7/2000 19:22'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	Preferences canRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!ChatRecorder methodsFor: 'accessing' stamp: 'TBP 2/23/2000 20:54'!recordedSound: aSound	self clearRecordedSound.	recordedSound _ aSound.! !!ChatRecorder methodsFor: 'as yet unclassified' stamp: 'RAA 8/11/2000 09:47'!initialize		"setting a higher desired recording rate seemed to fix certain powerbook problems.	I'm still trying to understand it all, but there it is for now"	super initialize.	samplingRate _ 44100.! !!ChatRecorder methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 11:34'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused _ true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer.				self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying _ nil].	self stopRecording.	"Preferences canRecordWhilePlaying ifFalse: [self stopRecording]."! !!ChatRecorder methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 11:34'!playback	"Playback the sound that has been recorded."	self pause.	soundPlaying _ self recordedSound ifNil: [^self].	soundPlaying play.! !!ChatRecorder methodsFor: 'as yet unclassified' stamp: 'RAA 8/13/2000 11:38'!resumeRecording	"Continue recording from the point at which it was last paused."	self startRecording.	paused _ false.! !!SoundRecorder class methodsFor: 'class initialization' stamp: 'RAA 8/7/2000 19:23'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying _ #ignoredNowInPreferences.! !!SoundRecorder class methodsFor: 'accessing' stamp: 'RAA 8/7/2000 19:23'!canRecordWhilePlaying	"Return true if this platform supports simultaneous sound recording and playback."	^Preferences canRecordWhilePlaying.		"now in preferences"! !!StaticForm methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 09:59'!isStatic	^true! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 17:33'!drawOn: aCanvas| t |"Smalltalk at: #Q4 put: OrderedCollection new."	form ifNil: [form _ (Form extent: 32@32 depth: 8) fillColor: Color green].	(cache isNil or: [cache extent ~= bounds extent]) ifTrue: [		t _ [cache _ Form extent: bounds extent depth: aCanvas depth.		form displayInterpolatedIn: cache boundingBox on: cache] timeToRun.		"Q4 add: {t. form. cache}."	].	aCanvas paintImage: cache at: bounds origin.! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 8/14/2000 14:00'!processOutput	| arrayToWrite size bytesSent timeStartSending t itemsSent now timeSlot bucketAgeInMS bytesThisSlot |	outBufIndex _ 1.	itemsSent _ bytesSent _ 0.	timeStartSending _ Time millisecondClockValue.	[outObjects isEmpty not and: [self isConnected]] whileTrue: [		arrayToWrite _ outObjects removeFirst.		size _ self addToOutBuf: arrayToWrite.		bytesSent _ bytesSent + size.		itemsSent _ itemsSent + 1.		outBufIndex > 10000 ifTrue: [self queueOutBufContents].	].	outBufIndex > 1 ifTrue: [self queueOutBufContents].	bytesSent > 0 ifTrue: [		MaxRatesSeen ifNil: [MaxRatesSeen _ Dictionary new].		now _ Time millisecondClockValue.		t _ now - timeStartSending.		timeSlot _ now // 10000.	"ten second buckets"		bucketAgeInMS _ now \\ 10.		bytesThisSlot _ (MaxRatesSeen at: timeSlot ifAbsent: [0]) + bytesSent.		MaxRatesSeen 			at: timeSlot 			put: bytesThisSlot.		NebraskaDebug 			at: #SendReceiveStats 			add: {'put'. bytesSent. t. itemsSent. bytesThisSlot // (bucketAgeInMS max: 100)}.	].! !!StringSocket methodsFor: 'private-IO' stamp: 'RAA 8/13/2000 17:16'!sendDataCautiously: aStringOrByteArray bytesToSend: bytesToSend	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent. Try not to send too much at once since this seemed to cause problems talking to a port on the same machine"	| bytesSent count |	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		count _ socket 			sendSomeData: aStringOrByteArray 			startIndex: bytesSent + 1  			count: (bytesToSend - bytesSent min: 6000).		bytesSent _ bytesSent + count.		(Delay forMilliseconds: 1) wait.	].	^ bytesSent! !!StringSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 14:02'!clearRatesSeen"StringSocket clearRatesSeen"	MaxRatesSeen _ nil ! !!StringSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 14:04'!showRatesSeen"StringSocket showRatesSeen"	| answer |	MaxRatesSeen ifNil: [^1 beep].	answer _ WriteStream on: String new.	MaxRatesSeen keys asSortedCollection do: [ :key |		answer nextPutAll: key printString,'  ',((MaxRatesSeen at: key) // 10000) printString; cr	].	StringHolder new contents: answer contents; openLabel: 'send rates at 10 second intervals'.! !!ThreePhaseButtonMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 16:27'!doButtonAction: evt	| moreArgs |	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	target ifNil: [^self].	actionSelector ifNil: [^self].	Cursor normal showWhile: [		moreArgs _ actionSelector numArgs > arguments size ifTrue: [			arguments copyWith: evt		] ifFalse: [			arguments		].		target perform: actionSelector withArguments: moreArgs	]! !!ThreePhaseButtonMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/15/2000 16:29'!mouseUp: evt		"Allow on:send:to: to set the response to events other than actWhen"	actWhen == #buttonUp ifFalse: [^super mouseUp: evt].	(self containsPoint: evt cursorPoint) ifTrue: [		self state: #on.		self doButtonAction: evt	] ifFalse: [		self state: #off.		target ifNotNil: [target mouseUpBalk: evt]	]	"Allow owner to keep it selected for radio buttons"		! !!EtoyUpdatingThreePhaseButtonMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 13:34'!checkBox	"Answer a button pre-initialized with checkbox images."	"(Form extent: 12@12 depth: 32) morphEdit"	CheckedForm ifNil: [		self setForms	].	^self new		onImage: CheckedForm;		pressedImage: MouseDownForm;		offImage: UncheckedForm;		extent: CheckedForm extent;		yourself! !!EtoyUpdatingThreePhaseButtonMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 13:34'!setFormsCheckedForm _ (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 4278190081 2003331177 4278190081 4278190081 0 0 0 0 0 0 0 4278190081 2003331177 0 4278190081 4278190081 0 0 0 0 0 0 4278190081 2003331177 0 0 4278190081 4278190081 0 4278190081 0 0 0 4278190081 2003331177 0 0 0 4278190081 4278190081 0 2003331177 4278190081 0 4278190081 2003331177 0 0 0 0 4278190081 4278190081 0 0 2003331177 4278190081 2003331177 0 0 0 0 0 4278190081 4278190081 0 0 0 2003331177 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0).MouseDownForm _ UncheckedForm _ (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0)! !!TrashCanMorph methodsFor: 'event handling' stamp: 'RAA 8/16/2000 09:26'!mouseDown: evt	| paintBox palette |	self currentHand endDisplaySuppression.	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox _ self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp: evt.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"	palette _ self standardPalette.	((palette notNil and: [palette isInWorld]) and: [palette hasScrapsTab])		ifTrue:			[palette showScrapsTab]		ifFalse:			[self currentHand openScrapsBook]! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 8/14/2000 16:41'!interCyclePause: milliSecs	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	currentTime _ Time millisecondClockValue.	(lastCycleTime notNil and: [CanSurrenderToOS ~~ false]) ifTrue: [ 		wait _ lastCycleTime + milliSecs - currentTime.		wait > 0 ifTrue: [ 			wait < milliSecs  "big waits happen after a snapshot"				ifTrue: [DisplayScreen checkForNewScreenSize.						(Delay forMilliseconds: wait) wait ]. ]. ].	lastCycleTime _ currentTime.	CanSurrenderToOS _ true.! !!WorldState methodsFor: 'stepping' stamp: 'RAA 8/14/2000 12:09'!runLocalStepMethodsIn: aWorld	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		(morphToStep shouldGetStepsFrom: aWorld)			ifTrue:				[wakeupTime <= now					ifTrue:						[morphToStep stepAt: now.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new]. 				deletions addLast: morphToStep]]]	 ifError: [:err :rcvr |		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now! !!WorldState methodsFor: 'stepping' stamp: 'RAA 8/14/2000 12:03'!runStepMethodsIn: aWorld	| queue |	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	queue _ self class deferredUIMessages.	[queue isEmpty] whileFalse: [		queue next value	].	self runLocalStepMethodsIn: aWorld.	"we are using a normal #step for these now"	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."! !!WorldState class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 16:40'!canSurrenderToOS: aBoolean	CanSurrenderToOS _ aBoolean! !StringSocket class removeSelector: #showStats:!SoundRecorder initialize!!ChatRecorder reorganize!('accessing' recordedSound:)('as yet unclassified' initialize pause playback resumeRecording)!SketchEditorMorph removeSelector: #brushAlphaFromGray!SketchEditorMorph removeSelector: #cancel!SketchEditorMorph removeSelector: #cancelPainting:!SketchEditorMorph removeSelector: #currentColor!SketchEditorMorph removeSelector: #currentColor:!SketchEditorMorph removeSelector: #deliverPainting:!SketchEditorMorph removeSelector: #erasePrep!SketchEditorMorph removeSelector: #prepareToPaint!SketchEditorMorph removeSelector: #rotateScalePrep!SketchEditorMorph removeSelector: #save!SketchEditorMorph removeSelector: #savePainting:!SketchEditorMorph removeSelector: #transBrush:!SketchEditorMorph removeSelector: #transBrushPrep!SketchEditorMorph removeSelector: #undo!SketchEditorMorph removeSelector: #undoPainting:!SketchEditorMorph removeSelector: #verifyState!Morph subclass: #SketchEditorMorph	instanceVariableNames: 'hostView palette ticksToDwell rotationCenter registrationPoint newPicBlock emptyPicBlock paintingForm dimForm formCanvas rotationButton scaleButton cumRot cumMag undoBuffer enclosingPasteUpMorph forEachHand '	classVariableNames: 'SketchTimes '	poolDictionaries: ''	category: 'Morphic-Support'!PaintBoxMorph removeSelector: #brush:action:nib:!PaintBoxMorph removeSelector: #clear:with:!PaintBoxMorph removeSelector: #currentColor:!PaintBoxMorph removeSelector: #deleteCurrentStamp!PaintBoxMorph removeSelector: #eyedropper:action:cursor:!PaintBoxMorph removeSelector: #keep:with:!PaintBoxMorph removeSelector: #pickup:action:cursor:!PaintBoxMorph removeSelector: #scrollStamps:action:!PaintBoxMorph removeSelector: #setAction:!PaintBoxMorph removeSelector: #showColorPalette!PaintBoxMorph removeSelector: #takeColorFrom:!PaintBoxMorph removeSelector: #tool:action:cursor:!PaintBoxMorph removeSelector: #toss:with:!PaintBoxMorph removeSelector: #undo:with:!NetworkTerminalMorph removeSelector: #delete!NebraskaDebug class removeSelector: #statsAt:!EToyGateKeeperMorph class removeSelector: #messageTypes!AudioChatGUI initialize!EToyChatOrBadgeMorph subclass: #EToyChatMorph	instanceVariableNames: 'listener receivingPane myForm recipientForm acceptOnCR sendingPane '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Experimental'!!AudioChatGUI reorganize!('stuff' changeTalkButtonLabel connect currentConnectionStateString defaultBackgroundColor getChoice: initialExtent objectsInQueue playNextMessage removeConnectButton step stepTime stepTimeIn: stop toggleChoice:)('initialization' buttonColor connectButton initialize ipAddress: messageWaitingAlertIndicator playButton recordAndStopButton start start2 talkBacklogIndicator talkButton toggleForHandsFreeTalking toggleForPlayOnArrival toggleForSendWhileTalking)('sending' handsFreeTalking record samplingRateForTransmission send sendAnyCompletedSounds sendOneOfMany: talkBacklog talkButtonDown talkButtonUp transmitWhileRecording)!FileList2 class removeSelector: #enableTypeButtons:forDir:!FileList2 class removeSelector: #update:in:toReflect:!FileList2 class removeSelector: #update:in:toReflect:fileTypeRow:morph:!EToyPeerToPeer class removeSelector: #debug:!EToyPeerToPeer removeSelector: #debug:!Object subclass: #EToyPeerToPeer	instanceVariableNames: 'socket communicatorMorph process ipAddress connectionQueue dataQueue remoteSocketAddress leftOverData '	classVariableNames: 'DEBUG PREVTICK '	poolDictionaries: ''	category: 'Network-EToy Communications'!!EToyPeerToPeer reorganize!('as yet unclassified')('sending' doConnectForSend doSendData sendDataCautiously: sendSomeData:to:for: sendSomeData:to:for:multiple:)('receiving' awaitDataFor: doAwaitData doReceiveData doReceiveOneMessage receiveDataOn:for: stopListening)!!EToyIncomingMessage class reorganize!('as yet unclassified' allTypes forType:send:to: initializeMessageHandlers messageHandlers newObjectFromStream:)('handlers' handleNewChatFrom:sentBy:ipAddress: handleNewFridgeMorphFrom:sentBy:ipAddress: handleNewMorphFrom:sentBy:ipAddress: handleNewMultiChatFrom:sentBy:ipAddress: handleNewSeeDesktopFrom:sentBy:ipAddress: handleNewStatusReplyFrom:sentBy:ipAddress: handleNewStatusRequestFrom:sentBy:ipAddress:)('message types' typeAudioChat typeAudioChatContinuous typeFridge typeKeyboardChat typeMorph typeMultiChat typeSeeDesktop typeStatusReply typeStatusRequest)!EToyIncomingMessage removeSelector: #handleNewChatFrom:sentBy:ipAddress:!EToyIncomingMessage removeSelector: #handleNewFridgeMorphFrom:sentBy:ipAddress:!EToyIncomingMessage removeSelector: #handleNewMorphFrom:sentBy:ipAddress:!EToyIncomingMessage removeSelector: #handleNewSeeDesktopFrom:sentBy:ipAddress:!EToyIncomingMessage removeSelector: #handleNewStatusReplyFrom:sentBy:ipAddress:!EToyIncomingMessage removeSelector: #handleNewStatusRequestFrom:sentBy:ipAddress:!EToyIncomingMessage removeSelector: #methodForMessageType:!EToyIncomingMessage removeSelector: #newObjectFromStream:!!EToyIncomingMessage reorganize!('as yet unclassified' incomingMessgage:fromIPAddress:)('specific handlers')!"Postscript:"NebraskaDebug fixups.!