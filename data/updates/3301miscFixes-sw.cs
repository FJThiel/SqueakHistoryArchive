'From Squeak2.9alpha of 5 August 2000 [latest update: #3367] on 1 February 2001 at 11:26:21 pm'!"Change Set:		miscFixes-swDate:			1 February 2001Author:			Scott Wallace* Gives CompoundTileMorph the right layout properties.* When a sibling instance is created, it is added to the world, so that attempts to set its heading, for example, don't create errors.* Small adjustments to windows & flaps menu.* Fixes a bug in ScriptEditorMorph.hibernate for the case where the scripted player is nil."!!Morph methodsFor: 'copying' stamp: 'sw 2/1/2001 23:11'!usableSiblingInstance	"Return another similar morph whose Player is of the same class as mine"	|  aName usedNames newPlayer newMorph topRenderer |	self flag: #noteToTed.  "I think this may have deviated majorly from your mainstream veryDeepCopy work, so there will probably be some problems entailed"	(topRenderer _ self topRendererOrSelf) == self ifFalse: [^ topRenderer usableSiblingInstance].	self player assureUniClass.	newMorph _ self veryDeepCopyWithoutPlayer.	newPlayer _ self player class new costume: newMorph.	newPlayer copyAddedStateFrom: self player.	newPlayer resetCostumeList.	self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"	newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ (self world ifNil: [OrderedCollection new] ifNotNil: [self world allKnownNames]) copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self currentWorld addMorphBack: newMorph.	self presenter flushPlayerListCache.	^ newMorph! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'sw 2/1/2001 16:36'!initialize	| r |	super initialize.	self color: Color orange muchLighter.	self borderWidth: 1.	self layoutInset: 2.	self listDirection: #topToBottom.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	r _ AlignmentMorph newRow color: color; layoutInset: 0.	r setProperty: #demandsBoolean toValue: true.	r addMorphBack: (Morph new color: color; extent: 2@5).  "spacer"	r addMorphBack: (StringMorph new contents: 'Test').	r addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	r addMorphBack: (testPart _ BooleanScriptEditor new borderWidth: 0; layoutInset: 1).	testPart color: Color transparent.	self addMorphBack: r.	r _ AlignmentMorph newRow color: color; layoutInset: 0.	r addMorphBack: (Morph new color: color; extent: 30@5).  "spacer"	r addMorphBack: (StringMorph new contents: 'Yes').	r addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	r addMorphBack: (yesPart _ ScriptEditorMorph new borderWidth: 0; layoutInset: 2).	yesPart color: Color transparent.	self addMorphBack: r.	r _ AlignmentMorph newRow color: color; layoutInset: 0.	r addMorphBack: (Morph new color: color; extent: 35@5).  "spacer"	r addMorphBack: (StringMorph new contents: 'No').	r addMorphBack: (Morph new color: color; extent: 5@5).  "spacer"	r addMorphBack: (noPart _ ScriptEditorMorph new borderWidth: 0; layoutInset: 2).	noPart color: Color transparent.	self addMorphBack: r.	self extent: 5@5.  "will grow to fit"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/1/2001 23:02'!hibernate	"Possibly delete the tiles."	| ww |	(ww _ self world) 		ifNil: [(playerScripted == nil or: [playerScripted isUniversalTiles]) ifFalse: [^ self]]		ifNotNil:			[(ww valueOfProperty: #universalTiles ifAbsent: [false]) ifFalse: [^ self]].	submorphs size > 1 ifTrue: [submorphs second delete].! !!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'sw 2/1/2001 23:13'!windowsMenu        "Build the windows menu for the world."        ^ self fillIn: (self menu: 'windows & flaps...') from: {                  { 'find window' . { #myWorld . #findWindow: }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.                { 'find changed browsers...' . { #myWorld . #findDirtyBrowsers: }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                { 'find changed windows...' . { #myWorld . #findDirtyWindows: }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.			nil.                { 'find a transcript (t)' . { #myWorld . #findATranscript: }. 'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.			 nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.                nil.                { 'collapse all windows' . { #myWorld . #collapseAll }. 'Reduce all open windows to collapsed forms that only show titles.'}.                { 'expand all windows' . { #myWorld . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.                { 'close top window (w)' . { SystemWindow . #closeTopWindow }. 'Close the topmost window if possible.'}.                { 'send top window to back (\)' . { SystemWindow . #sendTopWindowToBack  }. 'Make the topmost window become the backmost one, and activate the window just beneath it.'}.			 { 'move windows onscreen' . { #myWorld . #bringWindowsFullOnscreen }. 'Make all windows fully visible on the screen'}.                nil.                { 'delete unchanged windows' . { #myWorld . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.                { 'delete non-windows' . { #myWorld . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.                { 'delete both of the above' . { self . #cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.                nil.            "    { #suppressFlapsString . { self . #toggleFlapSuppressionInProject }. 'Governs whether flaps should be shown in this project'}."                { #useGlobalFlapsString . { self. #toggleWhetherToUseGlobalFlaps }. 'Governs whether a universal set of "global" flaps should be sharable by all morphic projects.'}.			{ #whichGlobalFlapsString . { Utilities. #offerGlobalFlapsMenu }. 'Put up a menu that allows you to choose which global flaps to show in this project'. #globalFlapsEnabled}.                { #newGlobalFlapString  . { Utilities . #addGlobalFlap }. 'Create a new flap that will be shared by all morphic projects'.  #globalFlapsEnabled}.                nil.                { 'new project flap...'  . { Utilities . #addLocalFlap }. 'Create a new flap to be used only in this project.'}.                { 'add stack-tools flap'  . { Utilities . #addStackToolsFlap }. 'Add a flap in this project that offers tools for creating stacks and cards.'}.				nil.                { 'about flaps...' . { Utilities . #explainFlaps }. 'Gives a window full of details about how to use flaps.'}.        }! !