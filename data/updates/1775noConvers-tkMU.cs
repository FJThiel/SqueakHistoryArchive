'From Squeak2.7 of 5 January 2000 [latest update: #1769] on 11 January 2000 at 3:28:15 pm'!"Change Set:		noConvers-tkMUDate:			8 January 2000Author:			Ted KaehlerTry to get rid of the annoying dialog box that asks you to write a default conversion method when reading in a SmartRefStream and keep going.  Just build the method and go on.  Tell the user what methods will be built."!!ImageSegment methodsFor: 'compact classes' stamp: 'tk 1/11/2000 15:27'!remapCompactClasses: mapFakeClassesToReal refStrm: smartRefStream	| ccArray current fake info |	"See if our compact classes are compatible with this system.  Convert to what the system already has.  If we are adding a new class, it has already been filed in.  A compact class may not be a root."	(outPointers at: (outPointers size - 1)) = 1717 ifFalse: [^ true].	ccArray _ outPointers last.	current _ Smalltalk compactClassesArray.	1 to: ccArray size do: [:ind | 		(ccArray at: ind) ifNotNil: ["is compact in the segment"			fake _ mapFakeClassesToReal keyAtValue: (current at: ind) ifAbsent: [nil].			info _ self cc: ind new: (ccArray at: ind) current: (current at: ind) 					fake: fake refStrm: smartRefStream.			info ifFalse: [^ false]]].	^ true! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/11/2000 15:11'!verifyStructure	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "| sel newClass oldVer newList newVer oldList ans newShort oldShort sup converting newlyConverting |converting _ OrderedCollection new.newlyConverting _ OrderedCollection new.structures keysDo: [:nm "an old className (symbol)" |	"For missing classes, there needs to be a method in SmartRefStream like 		#rectangleoc2 that returns the new class."	newClass _ self mapClass: nm.		"does (renamed at: nm put: newClass name)"	newClass class == String ifTrue: [^ newClass].	"error, fileIn needed"	oldVer _ self versionSymbol: (structures at: nm).	newList _ (Array with: newClass classVersion), (newClass allInstVarNames).	newVer _ self versionSymbol: newList.	sel _ 'convert',oldVer,':',newVer, ':'.			"method name of conversion routine that is send after the object is created."	oldList _ structures at: nm.	superclasses ifNil: [newShort _ newList.  oldShort _ oldList]		ifNotNil: ["just compare inst vars for this class"			sup _ superclasses at: nm.			oldShort _ sup = 'nil' 				ifFalse: [oldList copyFrom: (structures at: sup) size + 1 to: oldList size]				ifTrue: [oldList copyFrom: 2 to: oldList size].			oldShort _ (Array with: (oldList at: 1)), oldShort.	"put version back".			newShort _ (Array with: newClass classVersion), (newClass instVarNames)].	newList = oldList 		ifTrue: [steady add: newClass]	"read it in as written"		ifFalse: [ans _ self verifyClass: newClass was: nm 					selector: sel newList: newShort oldList: oldShort.				ans == #exists ifTrue: [converting add: newClass name].				ans == #new ifTrue: [newlyConverting add: newClass name].				]].false & converting isEmpty not ifTrue: ["debug" 		self inform: 'These classes are being converted from existing methods:\' withCRs,			converting asArray printString].newlyConverting isEmpty not ifTrue: [		self inform: 'Making up new conversion methods for these changed classes\' withCRs,			newlyConverting asArray printString].! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 1/11/2000 12:38'!verifyClass: newClass was: nm selector: sel newList: newShort oldList: oldShort	"Compare the incoming inst var name lists with the existing class.  See if the proper conversion method is present.  Works for either comparing inst vars for THIS class, or for allInstVars of the superclasses.  "	Symbol hasInterned: sel ifTrue: [:symb | reshaped at: nm put: symb].	newShort = oldShort ifFalse: ["inst vars did change"		(reshaped includesKey: nm) ifFalse: ["No conversion method exists"				self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.				^ #new]].	(reshaped includesKey: nm) ifTrue: ["Symbol exists"		(newClass canUnderstand: sel asSymbol) ifFalse: ["But not in this class!!"			self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.			^ #new]].	"Existing conversion methods is here"	^ #exists! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 1/11/2000 12:17'!writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList	"No method sel was found in newClass.  Writing a default conversion method."	| code keywords newOthers oldOthers copied |	code _ WriteStream on: (String new: 500).	keywords _ sel keywords.	code nextPutAll: (keywords at: 1); nextPutAll: ' varDict '; 			nextPutAll: (keywords at: 2); nextPutAll: ' smartRefStrm'; cr; tab.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code nextPutAll: '"These variables are automatically stored into the new instance '.	code nextPutAll: copied asArray printString; nextPut: $. .	code cr; tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; cr; cr; tab.	(newOthers size = 0) & (oldOthers size = 0) 		ifTrue: [code nextPutAll: '"Instance variables are the same.  Only the order changed.  This method should work as written."'].	(newOthers size > 0) ifTrue: [code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withCRs].	(oldOthers size > 0) ifTrue: [code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in another variable?"'].	newClass compile: code contents classified: 'object fileIn'.	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !