'From Squeak2.8alpha of 13 January 2000 [latest update: #1817] on 7 February 2000 at 11:26:47 am'!!ChangeSorter methodsFor: 'message list' stamp: 'tk 2/7/2000 11:01'!selectedMessage	"Answer a copy of the source code for the selected message selector." 	^ contents ifNil: [''] ifNotNil: [contents copy]! !!FileList methodsFor: 'file list menu' stamp: 'tk 2/6/2000 15:09'!compressFile	"Compress the currently selected file"	| zipped buffer unzipped |	unzipped _ directory readOnlyFileNamed: self fullName.	unzipped binary.	zipped _ directory newFileNamed: (fileName, FileDirectory dot, 'gz').	zipped binary; setFileTypeToObject.		"Type and Creator not to be text, so can be enclosed in an email"	zipped _ GZipWriteStream on: zipped.	buffer _ ByteArray new: 50000.	'Compressing ', self fullName displayProgressAt: Sensor cursorPoint		from: 0 to: unzipped size		during:[:bar|			[unzipped atEnd] whileFalse:[				bar value: unzipped position.				zipped nextPutAll: (unzipped nextInto: buffer)].			zipped close.			unzipped close].	self updateFileList! !!FileList methodsFor: 'file list menu' stamp: 'tk 2/7/2000 11:20'!openProjectFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList window proj preStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	World ifNil: [^ self inform: 'Later, allow jumping from MVC to Morphic Projects.'].	preStream _ directory oldFileNamed: self fullName.	(preStream fullName asLowercase endsWith: '.gz')		ifTrue: [aFileStream _ (RWBinaryOrTextStream with:					(GZipReadStream on: preStream) upToEnd) reset.				preStream close.]		ifFalse: [aFileStream _ preStream].	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [			window _ (SystemWindow labelled: proj name) model: proj.			window				addMorph: (ProjectViewMorph on: proj)				frame: (0@0 corner: 1.0@1.0).			window openInWorld.			proj enter]].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'].	(window _ ProjectViewMorph newMorphicProjectOn: morphOrList) openInWorld.	window model enter! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 2/7/2000 11:20'!writeForExportWithSources: shortName	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	| fileStream temp fName classes |	state = #activeCopy ifFalse: [self error: 'wrong state'].	temp _ endMarker.	endMarker _ nil.	(shortName endsWith: '.extSeg')		ifTrue: [fName _ shortName]		ifFalse: [fName _ shortName , '.extSeg'].	fileStream _ FileStream newFileNamed: fName.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker _ temp.	"append sources"	classes _ arrayOfRoots select: [:cls | 		(cls isKindOf: Behavior) and: [cls theNonMetaClass isSystemDefined]].	classes size = 0 ifTrue: [^ self].	fileStream reopen; setToEnd.	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	classes do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream padToNextLongPut: $ .	fileStream close.! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 2/7/2000 11:26'!nextWordsInto: aBitmap 	| blt pos mainX mainY frontX frontY little source |	"Fill the word based buffer from my collection.  Stored on stream as Little Endian.  Optimized for speed."	(collection class isBytes) ifTrue:		["1 to: aBitmap size do: [:index | aBitmap at: index put: (self nextNumber: 4)]."		little _ Smalltalk endianness == #little.		collection basicSize \\ 4 = 0 			ifTrue: [source _ collection.  					pos _ self position.					self skip: aBitmap size * 4.]			ifFalse: [source _ self next: aBitmap size * 4.		"forced to copy it"					pos _ 0].		mainX _ pos \\ 4.   mainY _ pos // 4.	"two Blts required if not word aligned"		frontX _ 0.  frontY _ mainY + 1.		blt _ (BitBlt toForm: (Form new hackBits: aBitmap)) 					sourceForm: (Form new hackBits: source).		blt combinationRule: Form over.  "store"		blt sourceX: mainX; sourceY: mainY; height: aBitmap size; width: 4-mainX.		blt destX: 0; destY: 0.		little ifTrue: [blt sourceX: 0; destX: mainX].	"just happens to be this way!!"		blt copyBits.		mainX = 0 ifTrue: [^ aBitmap].		"second piece when not word aligned"		blt sourceX: frontX; sourceY: frontY; height: aBitmap size; width: mainX.		blt destX: 4-mainX; destY: 0.		little ifTrue: [blt sourceX: 4-mainX; destX: frontX].	"draw picture to understand this"		blt copyBits.		^ aBitmap].	^ self next: aBitmap size into: aBitmap startingAt: 1.! !!PositionableStream methodsFor: 'converting' stamp: 'tk 2/7/2000 11:08'!asBinaryOrTextStream	"Convert to a stream that can switch between bytes and characters"	^ (RWBinaryOrTextStream with: self contentsOfEntireFile) reset! !!FileStream methodsFor: 'converting' stamp: 'tk 2/4/2000 09:16'!asBinaryOrTextStream	"I can switch between binary and text data"	^ self! !!InflateStream methodsFor: 'accessing' stamp: 'tk 2/4/2000 10:26'!contents	^ self upToEnd! !!Project class methodsFor: 'utilities' stamp: 'tk 2/7/2000 11:08'!thumbnailFromUrl: urlString	"Load the project, and make a thumbnail to it in the current project.Project thumbnailFromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/SqueakEasy.extSeg'."	| aFileStream morphOrList proj thumbnail | 	aFileStream _ (urlString asLowercase endsWith: '.gz')		ifTrue: [(RWBinaryOrTextStream with:					(GZipReadStream on: (ServerFile new fullPath: urlString) asStream)						upToEnd) reset]		ifFalse: [(ServerFile new fullPath: urlString) asStream].	morphOrList _ aFileStream fileInObjectAndCode.	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots detect: [:mm | mm class == Project] 					ifNone: [nil].		"rename the project if it conflicts?"		proj ifNotNil: [			thumbnail _ (SystemWindow labelled: proj name) model: proj.			thumbnail addMorph: (ProjectViewMorph on: proj)				frame: (0@0 corner: 1.0@1.0).			thumbnail openInWorld.			proj enter]].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'].	(thumbnail _ ProjectViewMorph newMorphicProjectOn: morphOrList) openInWorld.	thumbnail model enter! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 2/4/2000 09:15'!asBinaryOrTextStream	^ self! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 2/4/2000 10:00'!asStream	"Return a RemoteFileStream (subclass of RWBinaryOrTextStream) on the contents of the remote file I represent.  For reading only."	^ self readOnlyFileNamed: self fileName! !