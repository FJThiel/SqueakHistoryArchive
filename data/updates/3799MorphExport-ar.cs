'From Squeak3.1alpha of 4 February 2001 [latest update: #3808] on 23 March 2001 at 3:04:42 pm'!"Change Set:		MorphExport-arDate:			23 March 2001Author:			Andreas RaabAdds 'export...' for exporting snapshots of morphs."!!Form methodsFor: 'fileIn/Out' stamp: 'ar 3/23/2001 15:02'!writeBMPfileNamed: fName  "Display writeBMPfileNamed: 'display'"	| fileName bhSize biSize biClrUsed f biSizeImage bfOffBits rowBytes rgb data colorValues |	self depth = 16 ifTrue:[^(self asFormOfDepth: 32) writeBMPfileNamed: fName].	self unhibernate.	(#(1 4 8 32) includes: depth) ifFalse: [self halt  "depth must be one of these"].	((fileName _ fName) asUppercase endsWith: '.BMP')		ifFalse: [fileName _ fName , '.BMP'].	bhSize _ 14.  "# bytes in file header"	biSize _ 40.  "info header size in bytes"	biClrUsed _ depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits _ biSize + bhSize + (4*biClrUsed).	rowBytes _ ((depth min: 24) * width + 31 // 32) * 4.	biSizeImage _ height * rowBytes. 	f _ (FileStream newFileNamed: fileName) binary.	"Write the file header"	f position: 0.	f nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	f nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	f nextLittleEndianNumber: 4 put: 0.  "bfReserved"	f nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	f position: bhSize.	f nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	f nextLittleEndianNumber: 4 put: width.  "biWidth"	f nextLittleEndianNumber: 4 put: height.  "biHeight"	f nextLittleEndianNumber: 2 put: 1.  "biPlanes"	f nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"	f nextLittleEndianNumber: 4 put: 0.  "biCompression"	f nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	f nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	f nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	f nextLittleEndianNumber: 4 put: biClrUsed.	f nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues _ self colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb _ colorValues at: i.			0 to: 24 by: 8 do: [:j | f nextPut: (rgb >> j bitAnd: 16rFF)]]].	'Writing image data' displayProgressAt: Sensor cursorPoint		from: 1 to: height during: [:bar |			1 to: height do:				[:i | bar value: i.				data _ (self copy: (0@(height-i) extent: width@1)) bits.				depth = 32				ifTrue: [1 to: data size do: [:j | f nextLittleEndianNumber: 3 put: (data at: j)].						1 to: (data size*3)+3//4*4-(data size*3) do: [:j | f nextPut: 0 "pad to 32-bits"]]				ifFalse: [1 to: data size do: [:j | f nextNumber: 4 put: (data at: j)]]]].	f position = (bfOffBits + biSizeImage) ifFalse: [self halt].	f close.! !!Morph methodsFor: 'menus' stamp: 'ar 3/23/2001 14:54'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables aPlayer |	aMenu addLine.	self maybeAddCollapseItemTo: aMenu.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu addLine.	aMenu add: 'copy Postscript' action: #clipPostscript.	aMenu add: 'print PS to file...' target: self selector: #printPSToFile.	(aPlayer _ self topRendererOrSelf player) ifNotNil:		[aMenu addLine.		aMenu add: 'make a sibling instance' target: self action: #makeNewPlayerInstance:.		aMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts'.		aMenu add: 'make multiple siblings...' target: self action: #makeMultipleSiblings:.		aMenu balloonTextForLastItem: 'Make any number of sibling instances all at once'.		(aPlayer belongsToUniClass and: [aPlayer class instanceCount > 1]) ifTrue:			[aMenu add: 'make all siblings look like me' target: self action: #makeSiblingsLookLikeMe:.			aMenu balloonTextForLastItem: 'make all my sibling instances look like me.'.			aMenu add: 'bring all siblings to my location' target: self action: #bringAllSiblingsToMe:.			aMenu balloonTextForLastItem: 'find all sibling instances and bring them to me'.			aMenu add: 'apply status to all siblngs' target: self action: #applyStatusToAllSiblings:.			aMenu balloonTextForLastItem: 'apply the current status of all of my scripts to the scripts of all my siblings']].	aMenu addLine.	aMenu add: 'open a property sheet' target: self action: #openAPropertySheet.	aMenu balloonTextForLastItem: 'Open a property sheet for me. Allows changing lots of stuff at once.'.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	self addExportMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().	aMenu addLine.	self potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' target: self action: #embedInto:].	aMenu defaultTarget: self.	aMenu addUpdating: #lockedString action: #lockUnlockMorph.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu		defaultTarget: self;		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction.	aMenu addLine.	(owner notNil and: [owner isStackBackground]) ifTrue:		[self isShared			ifFalse:				[aMenu add: 'put onto Background' target: self action: #putOnBackground]			ifTrue:				[aMenu add: 'remove from Background' target: self action: #putOnForeground.				self couldHoldSeparateDataForEachInstance ifTrue:					[self holdsSeparateDataForEachInstance						ifFalse:							[aMenu add: 'start holding separate data for each instance' target: self action: #makeHoldSeparateDataForEachInstance]						ifTrue:							[aMenu add: 'stop holding separate data for each instance' target: self action: #stopHoldingSeparateDataForEachInstance].							aMenu add: 'be default value on new card' target: self action: #setAsDefaultValueForNewCard.							(self hasProperty: #thumbnailImage)								ifTrue:									[aMenu add: 'stop using for reference thumbnail' target: self action: #stopUsingForReferenceThumbnail]								ifFalse:									[aMenu add: 'start using for reference thumbnail' target: self action: #startUsingForReferenceThumbnail]]].				aMenu addLine].	aMenu defaultTarget: self topRendererOrSelf.	aMenu add: 'draw new path' action: #definePath.	(self hasProperty: #pathPoints) ifTrue:		[aMenu add: 'follow path' action: #followPath.		aMenu add: 'delete path' action: #deletePath].	(owner == nil) ifFalse:		[aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'ar 3/23/2001 14:53'!addExportMenuItems: aMenu hand: aHandMorph	| menu |	menu _ MenuMorph new defaultTarget: self.	menu add:'BMP file' action: #exportAsBMP.	menu add:'GIF file' action: #exportAsGIF.	aMenu ifNotNil:[aMenu add: 'export...' subMenu: menu].	^menu! !!Morph methodsFor: 'menus' stamp: 'ar 3/23/2001 15:01'!exportAsBMP	| fName |	fName _ FillInTheBlank request:'Please enter the name' initialAnswer: self externalName,'.bmp'.	fName isEmpty ifTrue:[^self].	self imageForm writeBMPfileNamed: fName.! !!Morph methodsFor: 'menus' stamp: 'ar 3/23/2001 15:03'!exportAsGIF	| fName |	fName _ FillInTheBlank request:'Please enter the name' initialAnswer: self externalName,'.gif'.	fName isEmpty ifTrue:[^self].	GIFReadWriter putForm: self imageForm onFileNamed: fName.! !