'From Squeak3.9alpha of 4 July 2005 [latest update: #6719] on 6 February 2006 at 10:22:57 pm'!
Object subclass: #Pragma	instanceVariableNames: 'method keyword arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!
	!Pragma commentStamp: '<historical>' prior: 0!I represent a pragma instance found in a compiled method. I can provide information about the defining class, method, its selector, as well as the information about the pragma keyword and its arguments. See the two 'accessing' protocols for details. 'accessing-method' provides information about the method the pragma is found in, while 'accessing-pragma' is about the pragma itself.Instances are retreived using one of the pragma search methods of the 'finding' protocol on the class side.!!Pragma methodsFor: 'accessing-method' stamp: 'lr 1/20/2006 02:04'!method	"Answer the compiled-method containing the pragma."		^ method! !!Pragma methodsFor: 'accessing-method' stamp: 'lr 1/20/2006 02:08'!methodClass	"Answer the class of the method containing the pragma."		^ method methodClass! !!Pragma methodsFor: 'accessing-method' stamp: 'lr 2/6/2006 19:56'!selector	"Answer the selector of the method containing the pragma."		^ method who last.! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/20/2006 02:10'!argumentAt: anInteger	"Answer one of the arguments of the pragma."		^ self arguments at: anInteger.! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:54'!arguments	"Answer the arguments of the recieving pragma. For a pragma defined as <key1: val1 key2: val2> this will answer #(val1 val2)."		^ arguments! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:53'!keyword	"Answer the keyword of the recieving pragma. For a pragma defined as <key1: val1 key2: val2> this will answer #key1:key2."		^ keyword! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:55'!message	"Answer the message of the recieving pragma."		^ Message selector: self keyword arguments: self arguments. ! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/20/2006 02:10'!numArgs	"Answer the number of arguments in the pragma."	^ self arguments size.! !!Pragma methodsFor: 'initialization' stamp: 'lr 1/20/2006 00:53'!setArguments: anArray	arguments := anArray! !!Pragma methodsFor: 'initialization' stamp: 'lr 1/20/2006 00:53'!setKeyword: aSymbol	keyword := aSymbol! !!Pragma methodsFor: 'initialization' stamp: 'lr 1/19/2006 23:39'!setMethod: aCompiledMethod	method := aCompiledMethod! !!Pragma methodsFor: 'printing' stamp: 'lr 2/6/2006 19:56'!printOn: aStream	aStream nextPut: $<.	self keyword precedence = 1		ifTrue: [ aStream nextPutAll: self keyword ]		ifFalse: [			self keyword keywords with: self arguments do: [ :key :arg |				aStream nextPutAll: key; space; print: arg; space ].			aStream skip: -1 ].	aStream nextPut: $>.! !!Pragma methodsFor: 'testing' stamp: 'lr 2/6/2006 22:17'!hasLiteralSuchThat: aBlock	^ (aBlock value: self keyword)		or: [ self arguments hasLiteralSuchThat: aBlock ].! !!Pragma methodsFor: 'testing' stamp: 'lr 2/6/2006 22:16'!hasLiteral: aLiteral	^ self keyword == aLiteral 		or: [ self arguments hasLiteral: aLiteral ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pragma class	instanceVariableNames: ''!!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 08:54'!allNamed: aSymbol from: aSubClass to: aSuperClass	"Answer a collection of all pragmas found in methods of all classes between aSubClass and aSuperClass (inclusive) whose keyword is aSymbol."		^ Array streamContents: [ :stream |		aSubClass withAllSuperclassesDo: [ :class |			self withPragmasIn: class do:  [ :pragma |				pragma keyword = aSymbol					ifTrue: [ stream nextPut: pragma ] ].			aSuperClass = class				ifTrue: [ ^ stream contents ] ] ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 18:16'!allNamed: aSymbol from: aSubClass to: aSuperClass sortedByArgument: anInteger	"Answer a collection of all pragmas found in methods of all classes between aSubClass and aSuperClass (inclusive) whose keyword is aSymbol, sorted according to argument anInteger."	^ self allNamed: aSymbol from: aSubClass to: aSuperClass sortedUsing: [ :a :b | (a argumentAt: anInteger) < (b argumentAt: anInteger) ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/19/2006 20:12'!allNamed: aSymbol from: aSubClass to: aSuperClass sortedUsing: aSortBlock	"Answer a collection of all pragmas found in methods of all classes between aSubClass and aSuperClass (inclusive) whose keyword is aSymbol, sorted according to aSortBlock."		^ (self allNamed: aSymbol from: aSubClass to: aSuperClass) sort: aSortBlock.! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 08:55'!allNamed: aSymbol in: aClass	"Answer a collection of all pragmas found in methods of aClass whose keyword is aSymbol."		^ Array streamContents: [ :stream |		self withPragmasIn: aClass do: [ :pragma |			pragma keyword = aSymbol				ifTrue: [ stream nextPut: pragma ] ] ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/20/2006 18:16'!allNamed: aSymbol in: aClass sortedByArgument: anInteger	"Answer a collection of all pragmas found in methods of aClass whose keyword is aSymbol, sorted according to argument anInteger."	^ self allNamed: aSymbol in: aClass sortedUsing: [ :a :b | (a argumentAt: anInteger) < (b argumentAt: anInteger) ].! !!Pragma class methodsFor: 'finding' stamp: 'lr 1/19/2006 20:06'!allNamed: aSymbol in: aClass sortedUsing: aSortBlock	"Answer a collection of all pragmas found in methods of aClass whose keyword is aSymbol, sorted according to aSortBlock."		^ (self allNamed: aSymbol in: aClass) sort: aSortBlock.! !!Pragma class methodsFor: 'private' stamp: 'lr 1/20/2006 00:34'!keyword: aSymbol arguments: anArray	^ self new		setKeyword: aSymbol;		setArguments: anArray;		yourself.! !!Pragma class methodsFor: 'private' stamp: 'lr 1/20/2006 08:50'!withPragmasIn: aClass do: aBlock	aClass selectorsAndMethodsDo: [ :selector :method | method pragmas do: aBlock ].! !
	"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Object subclass: #MethodProperties	instanceVariableNames: 'properties pragmas'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!
	!MethodProperties commentStamp: 'lr 2/6/2006 19:31' prior: 0!I am class holding state for compiled methods. All my instance variables should be actually part of the CompiledMethod itself, but the current implementation of the VM doesn't allow this.I am a compact class and optimized for size and speed, since every CompiledMethod points onto an instance of myself. I am mostly polymorphic to the protocol of an identity-dictionary, so that key-value pairs can be easily stored and retreived without the need to add new variables. However keep in mind that instantiating a dictionary consumes much more memory than adding an instance-variable, so it might be clever to add a new variable if the property is going to be used by every compiled method.!!MethodProperties methodsFor: 'accessing' stamp: 'lr 2/6/2006 19:11'!pragmas	^ pragmas! !!MethodProperties methodsFor: 'initialization' stamp: 'lr 2/6/2006 19:12'!initialize	super initialize.	pragmas := #().! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:04'!at: aKey	"Answer the property value associated with aKey."		^ self at: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 20:47'!at: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self at: aKey ifAbsent: [ self at: aKey put: aBlock value ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:07'!at: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil ifTrue: [ ^ aBlock value ].	^ properties at: aKey ifAbsent: aBlock.! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:06'!at: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	properties ifNil: [ properties :=  IdentityDictionary new ].	^ properties at: aKey put: anObject.! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:11'!includesKey: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 20:48'!removeKey: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeKey: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:07'!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer.! !!MethodProperties methodsFor: 'private' stamp: 'lr 2/6/2006 20:36'!addPragma: aPragma	pragmas := pragmas copyWith: aPragma.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodProperties class	instanceVariableNames: ''!!MethodProperties class methodsFor: 'class initialization' stamp: 'lr 2/6/2006 22:06'!initialize	self becomeCompact.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

!CompiledMethod methodsFor: 'accessing' stamp: 'lr 2/6/2006 19:46'!pragmas	"Answer an array of the pragmas of the reciever."		^ self properties pragmas.! !

!CompiledMethod methodsFor: 'accessing' stamp: 'lr 2/6/2006 19:35'!properties	"Answer the method properties of the receiver."	^ self literalAt: self numLiterals - 1.! !
	
!CompiledMethod methodsFor: 'initialize-release' stamp: 'lr 2/6/2006 20:52'!properties: aMethodProperties	"Set the method-properties of the receiver to aMethodProperties."    ^ self literalAt: self numLiterals - 1 put: aMethodProperties.! !
	
!CompiledMethod methodsFor: 'literals' stamp: 'lr 2/6/2006 22:15'!hasLiteralSuchThat: aBlock	"Answer true if aBlock returns true for any literal in this method, even if imbedded in array structure or within its pragmas."		| literal |	self pragmas do: [ :pragma |		(pragma hasLiteralSuchThat: aBlock)			ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		(aBlock value: literal)			ifTrue: [ ^ true ].		(literal class == Array and: [ literal hasLiteralSuchThat: aBlock ])			ifTrue: [ ^ true ] ].	^ false.! !
	
!CompiledMethod methodsFor: 'literals' stamp: 'lr 2/6/2006 22:15'!hasLiteralThorough: aLiteral	"Answer true if any literal in this method is literal, even if embedded in array structure or within its pragmas."	| literal |	self pragmas do: [ :pragma |		(pragma hasLiteral: aLiteral)			ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		literal == aLiteral 			ifTrue: [ ^ true ].		(literal class == Array and: [ literal hasLiteral: aLiteral ]) 			ifTrue: [ ^ true ] ].	^ false.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

!DecompilerConstructor methodsFor: 'constructor' stamp: 'lr 2/6/2006 21:08'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| node methodTemps |	node _ self codeSelector: selector code: nil.	tempVars _ vars.	methodTemps _ tempVars select: [:t | t scope >= 0].	^MethodNode new		selector: node		arguments: (methodTemps copyFrom: 1 to: nArgs)		precedence: selector precedence		temporaries: (methodTemps copyFrom: nArgs + 1 to: methodTemps size)		block: block		encoder: (Encoder new initScopeAndLiteralTables					temps: tempVars					literals: literalValues					class: class)		primitive: primitive		properties: method properties.! !
		
"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

!MethodNode methodsFor: 'code generation' stamp: 'lr 2/6/2006 23:24'!properties	^ properties! !

!MethodNode methodsFor: 'printing' stamp: 'lr 2/6/2006 21:54'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '|'.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].				aStream nextPutAll: ' |'].	properties ifNotNil: [ 		properties pragmas do: [ :each |			"Don't decompile basic primitives that return self, i-vars, etc."			each keyword = #primitive:				ifFalse: [ aStream crtab: 1. each printOn: aStream ]				ifTrue: [					((each argumentAt: 1) between: 255 and: 519)						ifFalse: [ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ] ].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !
	
"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

!Parser methodsFor: 'pragmas' stamp: 'lr 2/6/2006 20:50'!addPragma: aPragma	self properties addPragma: aPragma.! !
	
!Parser methodsFor: 'pragmas' stamp: 'lr 2/6/2006 21:02'!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' or: [ Smalltalk hasClassNamed: here ] ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'.! !

!Parser methodsFor: 'pragmas' stamp: 'lr 2/6/2006 20:23'!pragmaPrimitives	| primitives |	primitives := self properties pragmas select: [ :each | 		#( primitive: primitive:module: ) 			includes: each keyword ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self.! !
	
!Parser methodsFor: 'pragmas' stamp: 'lr 2/6/2006 20:23'!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ].! !
			
!Parser methodsFor: 'pragmas' stamp: 'lr 2/6/2006 20:50'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| keyword arguments |	keyword := String new.	arguments := Array new.		"This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here."	(hereType == #keyword and: [ here = #apicall: or: [ here = #cdecl: ] ])		ifTrue: [ ^ self externalFunctionDeclaration ].		[ hereType == #word or: [ hereType == #keyword ] ] whileTrue: [		keyword := keyword , self advance.		keyword last = $:			ifTrue: [ arguments := arguments copyWith: self pragmaLiteral ] ].	keyword numArgs ~= arguments size		ifTrue: [ ^ self notify: keyword , ' is an invalid pragma' ].	self addPragma: (Pragma keyword: keyword asSymbol arguments: arguments).	^ true.! !
	
!Parser methodsFor: 'pragmas' stamp: 'lr 2/6/2006 20:39'!properties	^ properties ifNil: [ properties := MethodProperties new ].! !
	
!Parser methodsFor: 'primitives' stamp: 'lr 2/6/2006 20:50'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType _ descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == ')' asSymbol] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !
	
!Parser methodsFor: 'primitives' stamp: 'lr 2/6/2006 20:24'!primitive: anIntegerOrString	"Create indexed primitive."			^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ].! !!Parser methodsFor: 'primitives' stamp: 'lr 2/6/2006 20:24'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117.! !
	
!Parser methodsFor: 'expression types' stamp: 'lr 2/6/2006 20:40'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	encoder _ encoderToUse.	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporariesIn: (sap at: 1)..	messageComment _ currentComment.	currentComment _ nil.	doit ifFalse: [ self pragmaSequence ].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !
		
"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

!CompiledMethod methodsFor: 'initialize-release' stamp: 'lr 2/6/2006 20:52'!properties: aMethodProperties	"Set the method-properties of the receiver to aMethodProperties."	aMethodProperties pragmas do: [ :each | each setMethod: self ].	^ self literalAt: self numLiterals - 1 put: aMethodProperties.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

MethodNode removeSelector: #selector:arguments:precedence:temporaries:block:encoder:primitive:!

CompiledMethod removeSelector: #propertyAt:!
CompiledMethod removeSelector: #propertyAt:ifAbsent:!
CompiledMethod removeSelector: #propertyAt:put:!
CompiledMethod removeSelector: #propertyRemoveKey:!
CompiledMethod removeSelector: #removeProperty:!CompiledMethod removeSelector: #setProperty:toValue:!CompiledMethod removeSelector: #valueOfProperty:!CompiledMethod removeSelector: #valueOfProperty:ifAbsent:!

MethodProperties removeSelector: #propDict:!
MethodProperties removeSelector: #propertyAt:!
MethodProperties removeSelector: #propertyAt:ifAbsent:!
MethodProperties removeSelector: #propertyAt:put:!
MethodProperties removeSelector: #propertyRemoveKey:!

MethodProperties initialize!

Smalltalk allClassesDo: [ :each |
	each organization removeEmptyCategories; sortCategories.
	each class organization removeEmptyCategories; sortCategories ]!

Compiler recompileAll!