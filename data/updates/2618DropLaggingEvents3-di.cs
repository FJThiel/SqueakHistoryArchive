'From Squeak2.9alpha of 12 June 2000 [latest update: #2612] on 14 September 2000 at 12:19:06 pm'!"Change Set:		DropLaggingEvents3Date:			13 September 2000Author:			Dan IngallsThis changeSet causes the hand to drop mouse move events that are obsolete and insignificant -- ie there are newer ones already waiting in the queue, and no new button state is included.  Also breaks out of the loop in HandMorph>>processEvents when this occurs, in order to allow a display update to take place.The mechanism queries Morph>>wantsEveryMouseMove that defaults to ^ false, so that certain mouse clients can override this optimization to receive every mouse point recorded by the event system."!!EventSensor methodsFor: 'accessing' stamp: 'di 9/13/2000 13:00'!peekEvent	"Look ahead at the next event."	eventQueue == nil 		ifTrue:[^ nil]		ifFalse:[^ eventQueue peek]! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/2000 11:46'!wantsEveryMouseMove	"Unless overridden, this method allows processing to skip mouse move events	when processing is lagging.  No 'significant' event (down/up, etc) will be skipped."	^ false! !!HandMorph methodsFor: 'event handling' stamp: 'di 9/14/2000 12:13'!latestEventSimilarTo: currentBuf	"Current event, a mouse event buffer, is about to be processed.  If there are other similar mouse events queued up, then drop them from the queue, and report the latest one.  While this will lose resolution, it will not lose any events, and the morphic event cycle will stay current."	| latestBuf nextEvent |	lastEvent ifNil:		[^ currentBuf].  "First event is significant"	lastEvent anyButtonPressed ~= ((currentBuf at: 5) anyMask: 7) ifTrue:		[^ currentBuf].  "MouseDown state changed in the first event"	latestBuf _ currentBuf.	[(nextEvent _ Sensor peekEvent) ~~ nil]		whileTrue:		[(nextEvent at: 1) = (latestBuf at: 1) ifFalse:			[^ latestBuf  "different event type"].		(nextEvent at: 5) = (latestBuf at: 5) ifFalse:			[^ latestBuf  "buttons changed"].		(nextEvent at: 6) = (latestBuf at: 6) ifFalse:			[^ latestBuf  "modifiers changed"].		"nextEvent is similar.  Remove it from the queue, and check the next."		latestBuf _ Sensor nextEvent].	^ latestBuf! !!HandMorph methodsFor: 'event handling' stamp: 'di 9/14/2000 12:02'!processEvents	"Process user input events from the local input devices.	Note: Ugly as it is, several places in Morphic currently rely on sending at least one mouse event per cycle. There's no way around this so we're checking if the first event is a mouse event and if not, we synthesize one.	Another interesting problem. Morphic is always supposed to run in an event driven environment but for now it is possible that a Morphic window is run from MVC so that we have to synthesize events in the sensor. That's quite a bit of a problem because it means that we'll get endless mouse events. To compensate for this, EventSensor will always return keyboard events first if synthesized so if we're running into a mouse event AND Sensor doesn't have an event queue we can safely break out of the event processing loop. See also EventSensor>>nextEventSynthesized.	When event processing lags behind event gathering, as in drag operations, the loop in this method can cause the display never to get updated.  Also in this case, it is frequently a waste to process any but the most recent mouse move.  For this reason, lagging events will be skipped whenever possible, and the loop will be exited to allow a display update cycle."	| evt currentExtent evtBuf type hadMouse eventsLagging latestBuf |	hadMouse _ false. "see first note above"	eventsLagging _ false.	[evtBuf _ Sensor nextEvent.	worldUnderCursor _ nil.		"start over for each event"	eventsLagging		or: [evtBuf isNil and: [hadMouse]]]		whileFalse: [		evtBuf == nil ifTrue:[			"Make us a fake mouse event so hadMouse will be true"			evtBuf _ Array with: EventTypeMouse							with: Time millisecondClockValue							with: lastEvent cursorPoint x							with: lastEvent cursorPoint y							with: (lastEvent buttons bitAnd: 7)							with: (lastEvent buttons bitShift: 3)].		evt _ nil. "for unknown event types"		type _ evtBuf at: 1.		type = EventTypeMouse ifTrue:[			hadMouse _ true.			(mouseDownMorph notNil and: [mouseDownMorph wantsEveryMouseMove]) ifFalse:				["Unless forbidden, skip over any lagging events"				latestBuf _ self latestEventSimilarTo: evtBuf.				latestBuf == evtBuf ifFalse: [eventsLagging _ true.  evtBuf _ latestBuf]].			evt _ MorphicEvent new				setMousePoint: (evtBuf at: 3) @ (evtBuf at: 4)				buttons: (evtBuf at: 5)				modifiers: (evtBuf at: 6)				lastEvent: lastEvent				hand: self].		(type = EventTypeKeyboard) ifTrue:[			evt _ MorphicEvent new				setKeyValue: (evtBuf at: 3)				type: (evtBuf at: 4)				mousePoint: self position				modifiers: (evtBuf at: 5)				hand: self].		"All other events are ignored"		(evt notNil and:[remoteConnections size > 0]) ifTrue: [			"Transmit the event to interested listeners"			currentExtent _ self worldBounds extent.			lastWorldExtent ~= currentExtent ifTrue: [				self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).				lastWorldExtent _ currentExtent].			self transmitEvent: evt].		"Finally, handle it"		self handleEvent: evt.		"See the note on running a World in MVC in the method comment"		(hadMouse and:[Sensor eventQueue == nil]) ifTrue:[worldUnderCursor _ nil. ^self].	].! !