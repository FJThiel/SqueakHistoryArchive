'From Squeak3.7alpha of 11 September 2003 [latest update: #5741] on 3 March 2004 at 10:57:38 am'!!Model commentStamp: '<historical>' prior: 0!Provides a superclass for classes that function as models.  The only behavior provided is fast dependents maintenance, which bypasses the generic DependentsFields mechanism.  1/23/96 sw!!Object methodsFor: 'system primitives' stamp: 'zz 3/3/2004 23:53'!becomeForward: otherObject copyHash: copyHash	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)				copyHash: copyHash! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:44'!and: block1 and: block2	"Nonevaluating conjunction without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as false, then return false immediately,		without evaluating any further blocks.	If all return true, then return true."	self ifFalse: [^ false].	block1 value ifFalse: [^ false].	block2 value ifFalse: [^ false].	^ true! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:44'!and: block1 and: block2 and: block3	"Nonevaluating conjunction without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as false, then return false immediately,		without evaluating any further blocks.	If all return true, then return true."	self ifFalse: [^ false].	block1 value ifFalse: [^ false].	block2 value ifFalse: [^ false].	block3 value ifFalse: [^ false].	^ true! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:44'!and: block1 and: block2 and: block3 and: block4	"Nonevaluating conjunction without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as false, then return false immediately,		without evaluating any further blocks.	If all return true, then return true."	self ifFalse: [^ false].	block1 value ifFalse: [^ false].	block2 value ifFalse: [^ false].	block3 value ifFalse: [^ false].	block4 value ifFalse: [^ false].	^ true! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:45'!or: block1 or: block2	"Nonevaluating alternation without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as true, then return true immediately,		without evaluating any further blocks.	If all return false, then return false."	self ifTrue: [^ true].	block1 value ifTrue: [^ true].	block2 value ifTrue: [^ true].	^ false! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:45'!or: block1 or: block2 or: block3	"Nonevaluating alternation without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as true, then return true immediately,		without evaluating any further blocks.	If all return false, then return false."	self ifTrue: [^ true].	block1 value ifTrue: [^ true].	block2 value ifTrue: [^ true].	block3 value ifTrue: [^ true].	^ false! !!Boolean methodsFor: 'controlling' stamp: 'zz 3/2/2004 23:45'!or: block1 or: block2 or: block3 or: block4	"Nonevaluating alternation without deep nesting.	The receiver is evaluated, followed by the blocks in order.	If any of these evaluates as true, then return true immediately,		without evaluating any further blocks.	If all return false, then return false."	self ifTrue: [^ true].	block1 value ifTrue: [^ true].	block2 value ifTrue: [^ true].	block3 value ifTrue: [^ true].	block4 value ifTrue: [^ true].	^ false! !!Model methodsFor: 'menus' stamp: 'zz 3/2/2004 23:49'!step	"Default for morphic models is no-op"! !!Model methodsFor: 'keyboard' stamp: 'zz 3/2/2004 23:49'!arrowKey: aChar from: view	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany anEvent |	(#(1 4 11 12 30 31) includes: (keyEvent _ aChar asciiValue)) ifFalse:		[(Smalltalk isMorphic and: [false]) ifTrue:			[((anEvent _ view currentEvent) isKindOf: KeyboardEvent) ifTrue: [self currentWorld keystrokeInWorld: anEvent]].			self flag: #deferred.			"Would like to pass all command-keys that pass through the hands of the model via this protocol but are not in fact intercepted here on to the desktop, where they might be quite relevant.  But when we obtain the event this way we are not getting the keyboard event"			^ self].     oldSelection := view getCurrentSelectionIndex.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[self okToChange			ifTrue:				[view changeModelSelection: nextSelection.				"view controller moveMarker"]]			! !