'From Squeak3.4 of 1 March 2003 [latest update: #5170] on 22 May 2003 at 9:26:01 pm'!"Change Set:		MCP-CompleteDate:			22 May 2003Author:			Diego Gomez Deck, German Morales, Javier Musa, Jose Laiolo, Andres Otaduy and Ned KonzThis is the first set of changes produced by MCP-Project.To see details about the project and its future look at http://minnow.cc.gatech.edu/squeak/3005This 'official' acceptance for our work gives us a stop-and-go opportunity to define the next goals.List of changes (probably incomplete):- refactor of #initialize procedure, added/implemented #defaultBounds, #defaultBorderColor, #defaultBorderWidth and #defaultColor - methods categorization - remove of most direct assignation for color, bounds, borderColor and borderWidth variables - replaces all isKindOf: Morph by isMorph - deletion of #initialColor where corresponds - remove of methods with the same behaviour in superclass - remove of methods with only a super invocation - added Morph>>hasExtension - added Morph>>privateExtension: - refactor the former users of the extension variable in Morph hierarchy - added MorphExtension>>hasOtherProperties - added MorphExtension>>privateOtherProperties: - refactor the former users of the otherProperties variable in MorphExtension  - isSystemWindow added to Object and SystemWindow - replaces all isKindOf: SystemWindow by isSystemWindow - bug fixed in SoundLoopMorph>>defaultBounds - TetrisBoard>>defaultColor now use an equivalent named color - Remove of assignments at end of ifTrue:ifFalse: blocks - Remove same code on ifTrue:ifFalse: blocks - comparation with nil per #isNil/#notNil - comparation with #size per #isEmpty/#notEmpty - at:1 per first - ~~ nil changed to #notNil - at:2 changed to #second, at:3 to #third, etc - remove unused #yourself. - remove unused #= - remove 2 methods equivalent to the superclass one moves isMorphicModel from Morph up to Object - replaces almost every isKindOf: WhateverClass by isWhateverClass - Assignment to same variable and end of ifTrue:ifFalse: blocks only when convenient . - Replaces uses of ifTrue:/ifFalse: instead of min:/max:. - HandMorph needsToBeDrawn: need to check for visible submorphs, not just for submorphs. - SelectionMorph doDup:fromHalo:handle: doesn't duplicate morphs properly. - refactor of same statements at end of #ifTrue:ifFalse blocks"!!Object methodsFor: 'testing' stamp: 'gm 2/22/2003 12:56'!isMorphicModel	"Return true if the receiver is a morphic model"	^false! !!Object methodsFor: 'testing' stamp: 'jam 3/9/2003 15:10'!isSystemWindow"answer whatever the receiver is a SystemWindow"	^ false! !!BorderStyle methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:59'!framePolyline: vertices on: aCanvas 	"Frame the given rectangle on aCanvas"	| prev next |	prev := vertices first.	2 to: vertices size		do: 			[:i | 			next := vertices at: i.			self 				drawLineFrom: prev				to: next				on: aCanvas.			prev := next]! !!ButtonProperties methodsFor: 'accessing' stamp: 'gm 2/22/2003 14:53'!privateSetLook: aSymbol to: aFormOrMorph 	| f |	f := (aFormOrMorph isForm) 				ifTrue: [aFormOrMorph]				ifFalse: [aFormOrMorph imageForm].	self stateCostumes at: aSymbol put: f! !!ButtonProperties methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:52'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetOffset.	target := rootMorphs size > 1 		ifTrue: [rootMorphs second]		ifFalse: [nil]! !!CanvasCharacterScanner methodsFor: 'scanning' stamp: 'aoy 2/15/2003 21:24'!displayLine: textLine offset: offset leftInRun: leftInRun 	"largely copied from DisplayScanner's routine"	| nowLeftInRun done startLoc startIndex stopCondition |	line := textLine.	foregroundColor ifNil: [foregroundColor := Color black].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	rightMargin := line rightMargin + offset x.	lineY := line top + offset y.	lastIndex := textLine first.	nowLeftInRun := leftInRun <= 0 				ifTrue: 					[self setStopConditions.	"also sets the font"					text runLengthFor: lastIndex]				ifFalse: [leftInRun]. 	runX := destX := leftMargin.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	[done] whileFalse: 			["remember where this portion of the line starts"			startLoc := destX @ destY.			startIndex := lastIndex.			"find the end of this portion of the line"			stopCondition := self 						scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						kern: kern.	"displaying: false"			"display that portion of the line"			canvas 				drawString: text string				from: startIndex				to: lastIndex				at: startLoc				font: font				color: foregroundColor.			"handle the stop condition"			done := self perform: stopCondition].	^runStopIndex - lastIndex! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:42'!drawBalloonOval: command 	| aRectangle aFillStyle borderWidth borderColor |	aRectangle := self class decodeRectangle: command second.	aFillStyle := self class decodeFillStyle: command third.	borderWidth := self class decodeInteger: command fourth.	borderColor := self class decodeColor: (command fifth).	self drawCommand: 			[:c | 			c asBalloonCanvas 				fillOval: aRectangle				fillStyle: aFillStyle				borderWidth: borderWidth				borderColor: borderColor]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:42'!drawBalloonRect: command 	| aRectangle aFillStyle |	aRectangle := self class decodeRectangle: (command second).	aFillStyle := self class decodeFillStyle: command third.	self drawCommand: 			[:c | 			c asBalloonCanvas fillRectangle: aRectangle fillStyle: aFillStyle]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:43'!drawImage: command 	| image point sourceRect rule cacheID cacheNew previousImage |	image := self class decodeImage: command second.	point := self class decodePoint: command third.	sourceRect := self class decodeRectangle: command fourth.	rule := self class decodeInteger: command fifth.	command size >= 7 		ifTrue: 			[false ifTrue: [self showSpaceUsed].	"debugging"			cacheID := self class decodeInteger: (command sixth).			cacheNew := (self class decodeInteger: command seventh) = 1.			cacheID > 0 				ifTrue: 					[CachedForms ifNil: [CachedForms := Array new: 100].					cacheNew 						ifTrue: [CachedForms at: cacheID put: image]						ifFalse: 							[previousImage := CachedForms at: cacheID.							image ifNil: [image := previousImage]								ifNotNil: 									[(previousImage notNil and: [image depth > 8]) 										ifTrue: [image := previousImage addDeltasFrom: image].									CachedForms at: cacheID put: image]]]].	self drawCommand: 			[:c | 			c 				image: image				at: point				sourceRect: sourceRect				rule: rule]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:43'!drawInfiniteFill: command 	| aRectangle aFillStyle |	aRectangle := self class decodeRectangle: (command second).	aFillStyle := InfiniteForm with: (self class decodeImage: command third).	self drawCommand: 			[:c | 			c asBalloonCanvas fillRectangle: aRectangle fillStyle: aFillStyle]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 13:18'!drawLine: command 	| verb pt1Enc pt2Enc widthEnc colorEnc pt1 pt2 width color |	verb _ command first.	pt1Enc _ command second.	pt2Enc _ command third.	widthEnc _ command fourth.	colorEnc _ command fifth.""	pt1 _ self class decodePoint: pt1Enc.	pt2 _ self class decodePoint: pt2Enc.	width _ self class decodeInteger: widthEnc.	color _ self class decodeColor: colorEnc.""	self		drawCommand: [:c | c				line: pt1				to: pt2				width: width				color: color]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 13:19'!drawOval: command 	| verb rectEnc colorEnc borderWidthEnc borderColorEnc rect color borderWidth borderColor |	verb _ command first.	rectEnc _ command second.	colorEnc _ command third.	borderWidthEnc _ command fourth.	borderColorEnc _ command fifth.	""	rect _ self class decodeRectangle: rectEnc.	color _ self class decodeColor: colorEnc.	borderWidth _ self class decodeInteger: borderWidthEnc.	borderColor _ self class decodeColor: borderColorEnc.	""	self		drawCommand: [:c | c				fillOval: rect				color: color				borderWidth: borderWidth				borderColor: borderColor]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:43'!drawPoly: command 	| verticesEnc fillColorEnc borderWidthEnc borderColorEnc vertices fillColor borderWidth borderColor |	fillColorEnc := command second.	borderWidthEnc := command third.	borderColorEnc := command fourth.	verticesEnc := command copyFrom: 5 to: command size.	fillColor := self class decodeColor: fillColorEnc.	borderWidth := self class decodeInteger: borderWidthEnc.	borderColor := self class decodeColor: borderColorEnc.	vertices := verticesEnc collect: [:enc | self class decodePoint: enc].	self drawCommand: 			[:c | 			c 				drawPolygon: vertices				color: fillColor				borderWidth: borderWidth				borderColor: borderColor]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 13:19'!drawRect: command 	| verb rectEnc fillColorEnc borderWidthEnc borderColorEnc rect fillColor borderWidth borderColor |	verb _ command first.	rectEnc _ command second.	fillColorEnc _ command third.	borderWidthEnc _ command fourth.	borderColorEnc _ command fifth.	""	rect _ self class decodeRectangle: rectEnc.	fillColor _ self class decodeColor: fillColorEnc.	borderWidth _ self class decodeInteger: borderWidthEnc.	borderColor _ self class decodeColor: borderColorEnc.	""	self		drawCommand: [:c | c				frameAndFillRectangle: rect				fillColor: fillColor				borderWidth: borderWidth				borderColor: borderColor]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:44'!drawStencil: command 	| stencilFormEnc locationEnc sourceRectEnc colorEnc stencilForm location sourceRect color |	stencilFormEnc := command second.	locationEnc := command third.	sourceRectEnc := command fourth.	colorEnc := command fifth.	stencilForm := self class decodeImage: stencilFormEnc.	location := self class decodePoint: locationEnc.	sourceRect := self class decodeRectangle: sourceRectEnc.	color := self class decodeColor: colorEnc.	self drawCommand: 			[:executor | 			executor 				stencil: stencilForm				at: location				sourceRect: sourceRect				color: color]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:44'!drawText: command 	| boundsEnc colorEnc text bounds color fontIndexEnc fontIndex |	text := command second.	boundsEnc := command third.	fontIndexEnc := command fourth.	colorEnc := command fifth.	bounds := self class decodeRectangle: boundsEnc.	fontIndex := self class decodeInteger: fontIndexEnc.	color := self class decodeColor: colorEnc.	self drawCommand: 			[:c | 			c 				drawString: text				in: bounds				font: (fonts at: fontIndex)				color: color]! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:44'!extentDepth: command 	| depth extent |	extent := self class decodePoint: (command second).	depth := self class decodeInteger: (command third).	drawingCanvas := FormCanvas extent: extent depth: depth! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 13:20'!processCommand: command onForceDo: forceBlock 	| verb verbCode |	command isEmpty		ifTrue: [^ self].	verb _ command first.	verbCode _ verb first.""	verbCode = CanvasEncoder codeClip		ifTrue: [^ self setClip: command].	verbCode = CanvasEncoder codeTransform		ifTrue: [^ self setTransform: command].	verbCode = CanvasEncoder codeText		ifTrue: [^ self drawText: command].	verbCode = CanvasEncoder codeLine		ifTrue: [^ self drawLine: command].	verbCode = CanvasEncoder codeRect		ifTrue: [^ self drawRect: command].	verbCode = CanvasEncoder codeBalloonRect		ifTrue: [^ self drawBalloonRect: command].	verbCode = CanvasEncoder codeBalloonOval		ifTrue: [^ self drawBalloonOval: command].	verbCode = CanvasEncoder codeInfiniteFill		ifTrue: [^ self drawInfiniteFill: command].	verbCode = CanvasEncoder codeOval		ifTrue: [^ self drawOval: command].	verbCode = CanvasEncoder codeImage		ifTrue: [^ self drawImage: command].	verbCode = CanvasEncoder codeReleaseCache		ifTrue: [^ self releaseImage: command].	verbCode = CanvasEncoder codePoly		ifTrue: [^ self drawPoly: command].	verbCode = CanvasEncoder codeStencil		ifTrue: [^ self drawStencil: command].	verbCode = CanvasEncoder codeForce		ifTrue: [^ self forceToScreen: command withBlock: forceBlock].	verbCode = CanvasEncoder codeFont		ifTrue: [^ self addFontToCache: command].	verbCode = CanvasEncoder codeExtentDepth		ifTrue: [^ self extentDepth: command].	verbCode = CanvasEncoder codeShadowColor		ifTrue: [^ self shadowColor: command].""	self error: 'unknown command: ' , command first! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:44'!releaseImage: command 	| cacheID |	CachedForms ifNil: [^self].	cacheID := self class decodeInteger: (command second).	CachedForms at: cacheID put: nil! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:44'!setClip: command 	| clipRectEnc |	clipRectEnc := command second.	clipRect := self class decodeRectangle: clipRectEnc! !!CanvasDecoder methodsFor: 'decoding' stamp: 'dgd 2/22/2003 18:45'!setTransform: command 	| transformEnc |	transformEnc := command second.	transform := self class decodeTransform: transformEnc! !!CanvasEncoder methodsFor: 'drawing' stamp: 'dgd 2/22/2003 19:01'!testCache: anObject 	| firstFree cachedObject newEntry |	cachingEnabled 		ifFalse: 			[cachedObjects := nil.			^nil].	cachedObjects ifNil: 			[cachedObjects := (1 to: 100) collect: 							[:x | 							{ 								WeakArray new: 1.								nil.								nil.								nil}]].	self purgeCache.	firstFree := nil.	cachedObjects withIndexDo: 			[:each :index | 			cachedObject := each first first.			firstFree ifNil: [cachedObject ifNil: [firstFree := index]].			cachedObject == anObject 				ifTrue: 					[each at: 2 put: (each second) + 1.					^{ 						index.						false.						each}]].	firstFree ifNil: [^nil].	newEntry := { 				WeakArray with: anObject.				1.				Time millisecondClockValue.				nil}.	cachedObjects at: firstFree put: newEntry.	^{ 		firstFree.		true.		newEntry}! !!CanvasEncoder methodsFor: 'private' stamp: 'dgd 2/22/2003 14:41'!sendCommand: stringArray 	| bucket |	connection ifNil: [^self].	connection isConnected ifFalse: [^self].	connection nextPut: stringArray.	SentTypesAndSizes ifNil: [^self].	bucket := SentTypesAndSizes at: stringArray first				ifAbsentPut: 					[{ 						0.						0.						0}].	bucket at: 1 put: bucket first + 1.	bucket at: 2		put: (bucket second) 				+ (stringArray inject: 4 into: [:sum :array | sum + (array size + 4)])! !!ChangeSet methodsFor: 'accessing' stamp: 'gm 2/16/2003 20:39'!editPostscript	"edit the receiver's postscript, in a separate window.  "	| deps found |	self assurePostscriptExists.	deps := postscript dependents 				select: [:m | (m isSystemWindow) or: [m isKindOf: StandardSystemView]].	deps size > 0 		ifTrue: 			[Smalltalk isMorphic 				ifTrue: 					[found := deps 								detect: [:obj | obj isSystemWindow and: [obj world == self currentWorld]]								ifNone: [nil].					found ifNotNil: [^found activate]]				ifFalse: 					[found := deps detect: 									[:obj | 									(obj isKindOf: StandardSystemView) 										and: [ScheduledControllers scheduledControllers includes: obj controller]]								ifNone: [nil].					found 						ifNotNil: [^ScheduledControllers activateController: found controller]].			self 				inform: 'Caution -- there' , (deps size isOrAreStringWith: 'other window') 						, 'already open on this postscript elsewhere'].	postscript openLabel: 'Postscript for ChangeSet named ' , name! !!CommandHistory methodsFor: 'called by programmer' stamp: 'aoy 2/15/2003 21:14'!purgeAllCommandsSuchThat: cmdBlock 	"Remove a bunch of commands, as in [:cmd | cmd undoTarget == zort]"	Preferences useUndo ifFalse: [^self].	history := history reject: cmdBlock.	lastCommand := history isEmpty ifTrue: [nil] ifFalse: [history last] ! !!CommandHistory methodsFor: 'menu' stamp: 'dgd 2/22/2003 14:40'!redoMenuWording	"Answer the wording to be used in a menu offering the current Redo command"	| nextCommand |	((nextCommand := self nextCommand) isNil or: [Preferences useUndo not]) 		ifTrue: [^'can''t redo'].	^String streamContents: 			[:aStream | 			aStream nextPutAll: 'redo "'.			aStream nextPutAll: (nextCommand cmdWording truncateWithElipsisTo: 20).			aStream nextPut: $".			lastCommand phase == #done ifFalse: [aStream nextPutAll: ' (z)']]! !!CommandHistory methodsFor: 'menu' stamp: 'dgd 2/22/2003 14:40'!undoMenuWording	"Answer the wording to be used in an 'undo' menu item"	(((lastCommand isNil or: [Preferences useUndo not]) 		or: [Preferences infiniteUndo not and: [lastCommand phase == #undone]]) 			or: [self nextCommandToUndo isNil]) ifTrue: [^'can''t undo'].	^String streamContents: 			[:aStream | 			aStream nextPutAll: 'undo "'.			aStream 				nextPutAll: (self nextCommandToUndo cmdWording truncateWithElipsisTo: 20).			aStream nextPut: $".			lastCommand phase == #done ifTrue: [aStream nextPutAll: ' (z)']]! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'gm 2/22/2003 14:46'!addProgressDecoration: extraParam 	| f m |	targetMorph ifNil: [^self].	(extraParam isForm) 		ifTrue: 			[targetMorph 				submorphsDo: [:mm | (mm isKindOf: SketchMorph) ifTrue: [mm delete]].			f := Form extent: extraParam extent depth: extraParam depth.			extraParam displayOn: f.			m := SketchMorph withForm: f.			m align: m fullBounds leftCenter				with: targetMorph fullBounds leftCenter + (2 @ 0).			targetMorph addMorph: m.			^self].	(extraParam isMemberOf: String) 		ifTrue: 			[targetMorph 				submorphsDo: [:mm | (mm isKindOf: StringMorph) ifTrue: [mm delete]].			m := StringMorph contents: extraParam.			m align: m fullBounds bottomCenter + (0 @ 8)				with: targetMorph bounds bottomCenter.			targetMorph addMorph: m.			^self]! !!DamageRecorder methodsFor: 'testing' stamp: 'dgd 2/22/2003 14:43'!updateIsNeeded	"Return true if the display needs to be updated."	^totalRepaint or: [invalidRects notEmpty]! !!EventHandler methodsFor: 'printing' stamp: 'dgd 2/22/2003 18:40'!printOn: aStream 	| aVal recipients |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'doubleClickSelector' 'keyStrokeSelector') 		do: 			[:aName | 			(aVal := self instVarNamed: aName) notNil 				ifTrue: [aStream nextPutAll: '; ' , aName , '=' , aVal]].	(recipients := self allRecipients) notEmpty 		ifTrue: 			[aStream nextPutAll: ' recipients: '.			recipients printOn: aStream]! !!FreeTranslation class methodsFor: 'translation' stamp: 'gm 2/22/2003 18:57'!translatePanel: buttonPlayer fromTo: normalDirection	| ow fromTM toTM fromLang toLang tt doc answer width |	"Gather up all the info I need from the morphs in the button's owner and do the translation.  Insert the results in a TextMorph.  Use www.freeTranslation.com Refresh the banner ad.	TextMorph with 'from' in the title is starting text.	PopUpChoiceMorph  with 'from' in the title is the starting language.	TextMorph with 'from' in the title is place to put the answer.	PopUpChoiceMorph  with 'from' in the title is the target language.		If normalDirection is false, translate the other direction."	ow _ buttonPlayer costume ownerThatIsA: PasteUpMorph.	ow allMorphs do: [:mm |		(mm isTextMorph) ifTrue: [ 			(mm knownName asString includesSubString: 'from') ifTrue: [				 fromTM _ mm].			(mm knownName asString includesSubString: 'to') ifTrue: [				 toTM _ mm]].		(mm isKindOf: PopUpChoiceMorph) ifTrue: [ 			(mm knownName asString includesSubString: 'from') ifTrue: [				 fromLang _ mm contents asString].			(mm owner knownName asString includesSubString: 'from') ifTrue: [				 fromLang _ mm contents asString].			(mm knownName asString includesSubString: 'to') ifTrue: [				 toLang _ mm contents asString].			(mm owner knownName asString includesSubString: 'to') ifTrue: [				 toLang _ mm contents asString]]].	normalDirection ifFalse: ["switch"		tt _ fromTM.  fromTM _ toTM.  toTM _ tt.		tt _ fromLang.  fromLang _ toLang.  toLang _ tt].	Cursor wait showWhile: [		doc _ self translate: fromTM contents asString from: fromLang to: toLang.		answer _ self extract: doc].	"pull out the translated text"		width _ toTM width.	toTM contents: answer wrappedTo: width.	toTM changed.! !!GrafPort methodsFor: 'copying' stamp: 'dgd 2/21/2003 22:38'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31]) 		ifTrue: 			[alpha isNil 				ifTrue: [self copyBitsTranslucent: 255]				ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !!ImageSegment methodsFor: 'testing' stamp: 'gm 2/15/2003 14:56'!findRogueRootsAllMorphs: rootArray 	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) assemble all objects should be in seg:  morph tree, presenter, scripts, player classes, metaclasses.  Put in a Set.2) Remove the roots from this list.  Ask for senders of each.  Of the senders, forget the ones that are in the segment already.  Keep others.  The list is now all the 'incorrect' pointers into the segment."	| inSeg testRoots scriptEditors pointIn wld xRoots |	Smalltalk garbageCollect.	inSeg := IdentitySet new: 200.	arrayOfRoots := rootArray.	(testRoots := self rootsIncludingPlayers) ifNil: [testRoots := rootArray].	testRoots do: 			[:obj | 			(obj isKindOf: Project) 				ifTrue: 					[inSeg add: obj.					wld := obj world.					inSeg add: wld presenter].			(obj isKindOf: Presenter) ifTrue: [inSeg add: obj]].	xRoots := wld ifNil: [testRoots] ifNotNil: [testRoots , (Array with: wld)].	xRoots do: 			[:obj | 			"root is a project"			obj isMorph 				ifTrue: 					[obj allMorphs do: 							[:mm | 							inSeg add: mm.							mm player ifNotNil: [inSeg add: mm player]].					obj isWorldMorph ifTrue: [inSeg add: obj presenter]]].	inSeg do: 			[:obj | 			(obj isKindOf: Player) 				ifTrue: 					[scriptEditors := obj class tileScriptNames 								collect: [:nn | obj scriptEditorFor: nn].					scriptEditors do: [:se | inSeg addAll: se allMorphs]]].	testRoots do: [:each | inSeg remove: each ifAbsent: []].	"want them to be pointed at from outside"	pointIn := IdentitySet new: 400.	inSeg do: [:ob | pointIn addAll: (Smalltalk pointersTo: ob except: inSeg)].	testRoots do: [:each | pointIn remove: each ifAbsent: []].	pointIn remove: inSeg array ifAbsent: [].	pointIn remove: pointIn array ifAbsent: [].	inSeg do: 			[:obj | 			(obj isMorph) 				ifTrue: 					[pointIn remove: (obj instVarAt: 3)						ifAbsent: 							["submorphs"							].					"associations in extension"					pointIn remove: obj extension ifAbsent: [].					obj extension ifNotNil: 							[obj extension otherProperties ifNotNil: 									[obj extension otherProperties 										associationsDo: [:ass | pointIn remove: ass ifAbsent: []]									"*** and extension actorState"									"*** and ActorState instantiatedUserScriptsDictionary ScriptInstantiations"]]].			(obj isKindOf: Player) 				ifTrue: [obj class scripts values do: [:us | pointIn remove: us ifAbsent: []]]].	"*** presenter playerlist"	self halt: 'Examine local variables pointIn and inSeg'.	^pointIn! !!ImageSegment methodsFor: 'testing' stamp: 'gm 2/22/2003 18:36'!findRogueRootsPrep	"Part of the tool to track down unwanted pointers into the segment.  Break all owner pointers in submorphs, scripts, and viewers in flaps."| wld players morphs scriptEditors |wld _ arrayOfRoots detect: [:obj | 	obj isMorph ifTrue: [obj isWorldMorph] ifFalse: [false]] ifNone: [nil].wld ifNil: [wld _ arrayOfRoots detect: [:obj | obj isMorph] 				ifNone: [^ self error: 'can''t find a root morph']].morphs _ IdentitySet new: 400.wld allMorphsAndBookPagesInto: morphs.players _ wld presenter allExtantPlayers.	"just the cached list"players do: [:pp |	scriptEditors _ pp class tileScriptNames collect: [:nn | 			pp scriptEditorFor: nn].	scriptEditors do: [:se | morphs addAll: se allMorphs]].wld submorphs do: [:mm | 	"non showing flaps"	(mm isKindOf: FlapTab) ifTrue: [		mm referent allMorphsAndBookPagesInto: morphs]].morphs do: [:mm | 	"break the back pointers"	mm isInMemory ifTrue: [	(mm respondsTo: #target) ifTrue: [		mm nearestOwnerThat: [:ow | ow == mm target 			ifTrue: [mm target: nil. true]			ifFalse: [false]]].	(mm respondsTo: #arguments) ifTrue: [		mm arguments do: [:arg | arg ifNotNil: [			mm nearestOwnerThat: [:ow | ow == arg				ifTrue: [mm arguments at: (mm arguments indexOf: arg) put: nil. true]				ifFalse: [false]]]]].	mm eventHandler ifNotNil: ["recipients point back up"		(morphs includesAllOf: (mm eventHandler allRecipients)) ifTrue: [			mm eventHandler: nil]].	"temporary, until using Model for PartsBin"	(mm isMorphicModel) ifTrue: [		(mm model isMorphicModel) ifTrue: [			mm model breakDependents]].	(mm isTextMorph) ifTrue: [mm setContainer: nil]]].(Smalltalk includesKey: #Owners) ifTrue: [Smalltalk at: #Owners put: nil].	"in case findOwnerMap: is commented out""self findOwnerMap: morphs."morphs do: [:mm | 	"break the back pointers"	mm isInMemory ifTrue: [mm privateOwner: nil]]."more in extensions?"! !!LayoutCell methodsFor: 'accessing' stamp: 'dgd 2/22/2003 14:09'!size	| n cell |	n := 0.	cell := self.	[cell isNil] whileFalse: 			[n := n + 1.			cell := cell nextCell].	^n! !!Model methodsFor: 'dependents' stamp: 'gm 2/16/2003 20:37'!topView	"Find the first top view on me. Is there any danger of their being two with the same model?  Any danger from ungarbage collected old views?  Ask if schedulled?"	dependents ifNil: [^nil].	Smalltalk isMorphic 		ifTrue: 			[dependents 				do: [:v | ((v isSystemWindow) and: [v isInWorld]) ifTrue: [^v]].			^nil].	dependents do: [:v | v superView ifNil: [v model == self ifTrue: [^v]]].	^nil! !!CodeHolder methodsFor: 'controls' stamp: 'gm 2/16/2003 20:37'!buttonWithSelector: aSelector 	"If receiver has a control button with the given action selector answer it, else answer nil.  morphic only at this point"	| aWindow aPane |	((aWindow := self containingWindow) isSystemWindow) 		ifFalse: [^nil].	(aPane := aWindow submorphNamed: 'buttonPane') ifNil: [^nil].	^aPane submorphThat: 			[:m | 			(m isKindOf: PluggableButtonMorph) and: [m actionSelector == aSelector]]		ifNone: [^nil]! !!FileList methodsFor: 'initialization' stamp: 'gm 2/16/2003 20:38'!updateButtonRow	"Dynamically update the contents of the button row, if any."	| aWindow aRow |	Smalltalk isMorphic ifFalse: [^self].	aWindow := self dependents 				detect: [:m | (m isSystemWindow) and: [m model == self]]				ifNone: [^self].	aRow := aWindow findDeepSubmorphThat: [:m | m hasProperty: #buttonRow]				ifAbsent: [^self].	aRow submorphs size - 4 timesRepeat: [aRow submorphs last delete].	self dynamicButtonServices do: 			[:service | 			aRow addMorphBack: (service buttonToTriggerIn: self).			service addDependent: self]! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:52'!actorState: anActorState 	"change the receiver's actorState"	self assureExtension actorState: anActorState! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:56'!actorStateOrNil	"answer the redeiver's actorState"	^ self hasExtension		ifTrue: [self extension actorState]! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 14:27'!balloonText	"Answer balloon help text or nil, if no help is available.  	NB: subclasses may override such that they programatically  	construct the text, for economy's sake, such as model phrases in 	a Viewer"	| text balloonSelector aString |	self hasExtension ifFalse: [^nil].	(text := self extension balloonText) ifNotNil: [^text].	(balloonSelector := self extension balloonTextSelector) ifNotNil: 			[aString := ScriptingSystem helpStringOrNilFor: balloonSelector.			(aString isNil and: [balloonSelector == #methodComment]) 				ifTrue: [aString := self methodCommentAsBalloonHelp].			((aString isNil and: [balloonSelector numArgs = 0]) 				and: [self respondsTo: balloonSelector]) 					ifTrue: [aString := self perform: balloonSelector]].	^aString ifNotNil: 			[aString asString 				withNoLineLongerThan: Preferences maxBalloonHelpLineLength]! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 19:42'!balloonTextSelector	"Answer balloon text selector item in the extension, nil if none"	^ self hasExtension		ifTrue: [self extension balloonTextSelector]! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:50'!balloonTextSelector: aSelector 	"change the receiver's balloonTextSelector"	self assureExtension balloonTextSelector: aSelector! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:57'!beSticky	"make the receiver sticky"	self assureExtension sticky: true! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 19:22'!beUnsticky	"If the receiver is marked as sticky, make it now be unsticky"	self hasExtension		ifTrue: [self extension sticky: false]! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:51'!eventHandler	"answer the receiver's eventHandler"	^ self hasExtension		ifTrue: [self extension eventHandler] ! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 19:25'!eventHandler: anEventHandler 	"Note that morphs can share eventHandlers and all is OK. "	self assureExtension eventHandler: anEventHandler! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:38'!isLocked	"answer whether the receiver is Locked"	self hasExtension		ifFalse: [^ false].	^ self extension locked! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:37'!isSticky	"answer whether the receiver is Sticky"	self hasExtension		ifFalse: [^ false].	^ self extension sticky! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:48'!lock: aBoolean 	"change the receiver's lock property"	(self hasExtension not			and: [aBoolean not])		ifTrue: [^ self].	self assureExtension locked: aBoolean! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:42'!player	"answer the receiver's player"	^ self hasExtension		ifTrue: [self extension player]! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:53'!player: anObject 	"change the receiver's player"	self assureExtension player: anObject! !!Morph methodsFor: 'accessing' stamp: 'dgd 3/7/2003 15:24'!raisedColor	"Return the color to be used for shading raised borders. The 	default is my own color, but it might want to be, eg, my 	owner's color. Whoever's color ends up prevailing, the color 	itself gets the last chance to determine, so that when, for 	example, an InfiniteForm serves as the color, callers won't choke 	on some non-Color object being returned"	(color isColor			and: [color isTransparent					and: [owner notNil]])		ifTrue: [^ owner raisedColor].	^ color asColor raisedColor!]style[(11 2 355 3 5 18 5 26 5 24 5 18 5 20)f2b,f2,f2c149047000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:47'!sticky: aBoolean 	"change the receiver's sticky property"	self extension sticky: aBoolean! !!Morph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:40'!toggleStickiness	"togle the receiver's Stickiness"	self hasExtension		ifFalse: [^ self beSticky].	self extension sticky: self extension sticky not! !!Morph methodsFor: 'accessing - extension' stamp: 'dgd 2/16/2003 19:55'!assureExtension	"creates an extension for the receiver if needed"	self hasExtension		ifFalse: [self initializeExtension].	^ self extension! !!Morph methodsFor: 'accessing - extension' stamp: 'dgd 2/16/2003 19:22'!extension	"answer the recevier's extension"	^ extension! !!Morph methodsFor: 'accessing - extension' stamp: 'dgd 2/16/2003 19:55'!hasExtension	"answer whether the receiver has extention"	^ self extension notNil! !!Morph methodsFor: 'accessing - extension' stamp: 'dgd 2/16/2003 19:57'!initializeExtension	"private - initializes the receiver's extension"	self privateExtension: MorphExtension new initialize! !!Morph methodsFor: 'accessing - extension' stamp: 'dgd 2/16/2003 19:57'!privateExtension: aMorphExtension	"private - change the receiver's extension"	extension _ aMorphExtension! !!Morph methodsFor: 'accessing - extension' stamp: 'dgd 2/16/2003 19:57'!resetExtension	"reset the extension slot if it is not needed"	(self hasExtension			and: [self extension isDefault])		ifTrue: [self privateExtension: nil] ! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 20:58'!hasProperty: aSymbol 	"Answer whether the receiver has the property named aSymbol"	self hasExtension		ifFalse: [^ false].	^ self extension hasProperty: aSymbol! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 20:08'!otherProperties	"answer the receiver's otherProperties"	^ self hasExtension		ifTrue: [self extension otherProperties]! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 20:56'!removeProperty: aSymbol 	"removes the property named aSymbol if it exists"	self hasExtension		ifFalse: [^ self].	self extension removeProperty: aSymbol! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 21:49'!setProperty: aSymbol toValue: anObject 	"change the receiver's property named aSymbol to anObject"	anObject		ifNil: [^ self removeProperty: aSymbol].	self assureExtension setProperty: aSymbol toValue: anObject! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 21:00'!valueOfProperty: aSymbol 	"answer the value of the receiver's property named aSymbol"	^ self hasExtension		ifTrue: [self extension valueOfProperty: aSymbol]! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 21:00'!valueOfProperty: aSymbol ifAbsent: aBlock 	"if the receiver possesses a property of the given name, answer  	its value. If not then evaluate aBlock and answer the result of  	this block evaluation"	^ self hasExtension		ifTrue: [self extension valueOfProperty: aSymbol ifAbsent: aBlock]		ifFalse: [aBlock value]! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 20:55'!valueOfProperty: aSymbol ifAbsentPut: aBlock 	"If the receiver possesses a property of the given name, answer  	its value. If not, then create a property of the given name, give 	it the value obtained by evaluating aBlock, then answer that  	value"	^ self assureExtension valueOfProperty: aSymbol ifAbsentPut: aBlock! !!Morph methodsFor: 'accessing - properties' stamp: 'dgd 2/16/2003 20:55'!valueOfProperty: aSymbol ifPresentDo: aBlock 	"If the receiver has a property of the given name, evaluate  	aBlock on behalf of the value of that property"	self hasExtension		ifFalse: [^ self].	^ aBlock		value: (self extension				valueOfProperty: aSymbol				ifAbsent: [^ self])! !!Morph methodsFor: 'button' stamp: 'dgd 2/22/2003 14:31'!firedMouseUpCode	"If the user has special mouseUpCodeToRun, then fire it once right now and return true, else return false"	| evt |	(self world isNil or: [self mouseUpCodeOrNil isNil]) ifTrue: [^false].	evt := MouseEvent new 				setType: nil				position: self center				buttons: 0				hand: self world activeHand.	self programmedMouseUp: evt for: self.	^true! !!Morph methodsFor: 'card in a stack' stamp: 'dgd 2/22/2003 14:26'!abstractAModel	"Find data-containing fields in me.  Make a new class, whose instance variables are named for my fields, and whose values are the values I am showing.  Use a CardPlayer for now.  Force the user to name the fields.  Make slots for text, Number Watchers, SketchMorphs, and ImageMorphs."	| instVarNames unnamed ans player twoListsOfMorphs holdsSepData docks oldPlayer iVarName |	(oldPlayer := self player) ifNotNil: 			[oldPlayer belongsToUniClass 				ifTrue: 					["Player"					oldPlayer class instVarNames notEmpty 						ifTrue: 							[self 								inform: 'I already have a regular Player, so I can''t have a CardPlayer'.							^true]]].	twoListsOfMorphs := StackMorph discoverSlots: self.	holdsSepData := twoListsOfMorphs first.	instVarNames := ''.	holdsSepData do: 			[:ea | 			iVarName := Utilities wellFormedInstanceVariableNameFrom: ea knownName.			iVarName = ea knownName ifFalse: [ea name: iVarName].			instVarNames := instVarNames , iVarName , ' '].	unnamed := twoListsOfMorphs second.	"have default names"	instVarNames isEmpty 		ifTrue: 			[self 				inform: 'No named fields were found.Please get a halo on each field and give it a name.Labels or non-data fields should be named "shared xxx".'.			^false].	unnamed notEmpty 		ifTrue: 			[ans := PopUpMenu 						confirm: 'Data fields are ' , instVarNames printString 								, ('\Some fields are not named.  Are they labels or non-data fields?' 										, '\Please get a halo on each data field and give it a name.') withCRs						trueChoice: 'All other fields are non-data fields'						falseChoice: 'Stop.  Let me give a name to some more fields'.			ans ifFalse: [^false]].	unnamed 		withIndexDo: [:mm :ind | mm setName: 'shared label ' , ind printString].	"Make a Player with instVarNames.  Make me be the costume"	player := CardPlayer instanceOfUniqueClassWithInstVarString: instVarNames				andClassInstVarString: ''.	self player: player.	player costume: self.	"Fill in the instance values.  Make docks first."	docks := OrderedCollection new.	holdsSepData do: 			[:morph | 			morph setProperty: #shared toValue: true.	"in case it is deeply embedded"			morph setProperty: #holdsSeparateDataForEachInstance toValue: true.			player class compileInstVarAccessorsFor: morph knownName.			morph isSyntaxMorph ifTrue: [morph setTarget: player].	"hookup the UpdatingString!!"			docks addAll: morph variableDocks].	player class newVariableDocks: docks.	docks do: [:dd | dd storeMorphDataInInstance: player].	"oldPlayer class mdict do: [:assoc | move to player].	move methods to new class?"	"oldPlayer become: player."	^true	"success"! !!Morph methodsFor: 'card in a stack' stamp: 'dgd 2/22/2003 19:05'!reassessBackgroundShape	"A change has been made which may affect the instance structure of the Card uniclass that holds the instance state, which can also be thought of as the 'card data'."	"Caution: still to be done: the mechanism so that when a new instance variable is added, it gets initialized in all subinstances of the receiver's player, which are the cards of this shape.  One needs to take into account here the instance variable names coming in; those that are unchanged should keep their values, but those that have newly arrived should obtain their default values from the morphs on whose behalf they are being maintained in the model"	| takenNames uniqueName requestedName variableDocks docks sepDataMorphs sorted existing name1 name2 |	self isStackBackground ifFalse: [^self beep].	"bulletproof against deconstruction"	Cursor wait showWhile: 			[variableDocks := OrderedCollection new.	"This will be stored in the uniclass's 			class-side inst var #variableDocks"			takenNames := OrderedCollection new.			sepDataMorphs := OrderedCollection new.	"fields, holders of per-card data"			self submorphs do: 					[:aMorph | 					aMorph renderedMorph holdsSeparateDataForEachInstance 						ifTrue: [sepDataMorphs add: aMorph renderedMorph]						ifFalse: 							["look for buried fields, inside a frame"							aMorph renderedMorph isShared 								ifTrue: 									[aMorph allMorphs do: 											[:mm | 											mm renderedMorph holdsSeparateDataForEachInstance 												ifTrue: [sepDataMorphs add: mm renderedMorph]]]]].			sorted := SortedCollection new 						sortBlock: [:a :b | (a valueOfProperty: #cardInstance) notNil].	"puts existing ones first"			sorted addAll: sepDataMorphs.			sorted do: 					[:aMorph | 					docks := aMorph variableDocks.					"Each morph can request multiple variables.  	This complicates matters somewhat but creates a generality for Fabrk-like uses.	Each spec is an instance of VariableDock, and it provides a point of departure	for the negotiation between the PasteUp and its constitutent morphs"					docks do: 							[:aVariableDock | 							uniqueName := self player 										uniqueInstanceVariableNameLike: (requestedName := aVariableDock 														variableName)										excluding: takenNames.							uniqueName ~= requestedName 								ifTrue: 									[aVariableDock variableName: uniqueName.									aMorph noteNegotiatedName: uniqueName for: requestedName].							takenNames add: uniqueName].					variableDocks addAll: docks].			existing := self player class instVarNames.			variableDocks := (variableDocks asSortedCollection: 							[:dock1 :dock2 | 							name1 := dock1 variableName.							name2 := dock2 variableName.							(existing indexOf: name1 ifAbsent: [0]) 								< (existing indexOf: name2 ifAbsent: [variableDocks size])]) 						asOrderedCollection.			self player class setNewInstVarNames: (variableDocks 						collect: [:info | info variableName asString]).			"NB: sets up accessors, and removes obsolete ones"			self player class newVariableDocks: variableDocks]! !!Morph methodsFor: 'card in a stack' stamp: 'aoy 2/15/2003 21:50'!showDesignationsOfObjects	"Momentarily show the designations of objects on the receiver"	| colorToUse aLabel |	self isStackBackground ifFalse: [^self].	self submorphsDo: 			[:aMorph | 			aLabel :=aMorph renderedMorph holdsSeparateDataForEachInstance 				ifTrue: 					[colorToUse := Color orange.					 aMorph externalName]				ifFalse: 					[colorToUse := aMorph isShared ifFalse: [Color red] ifTrue: [Color green].					 nil].			Display 				border: (aMorph fullBoundsInWorld insetBy: -6)				width: 6				rule: Form over				fillColor: colorToUse.			aLabel ifNotNil: 					[aLabel asString 						displayOn: Display						at: aMorph fullBoundsInWorld bottomLeft + (0 @ 5)						textColor: Color blue]].	Sensor anyButtonPressed 		ifTrue: [Sensor waitNoButton]		ifFalse: [Sensor waitButton].	World fullRepaintNeeded! !!Morph methodsFor: 'copying' stamp: 'nk 3/12/2001 17:07'!duplicateMorphCollection: aCollection	"Make and return a duplicate of the receiver"	| newCollection names |	names _ aCollection collect: [ :ea | | newMorph w |		(w _ ea world) ifNotNil:			[w nameForCopyIfAlreadyNamed: ea].	].	newCollection _ aCollection veryDeepCopy.	newCollection with: names do: [ :newMorph :name |		name ifNotNil: [ newMorph setNameTo: name ].		newMorph arrangeToStartStepping.		newMorph privateOwner: nil. "no longer in world"		newMorph isPartsDonor: false. "no longer parts donor"	].	^newCollection! !!Morph methodsFor: 'copying' stamp: 'dgd 2/16/2003 19:53'!updateReferencesUsing: aDictionary 	"Update intra-morph references within a composite morph that 	has been copied. For example, if a button refers to morph X in 	the orginal 	composite then the copy of that button in the new composite 	should refer to 	the copy of X in new composite, not the original X. This default 	implementation updates the contents of any morph-bearing slot. 	It may be 	overridden to avoid this behavior if so desired."	| old |	Morph instSize + 1		to: self class instSize		do: [:i | 			old _ self instVarAt: i.			old isMorph				ifTrue: [self						instVarAt: i						put: (aDictionary								at: old								ifAbsent: [old])]].	self hasExtension		ifTrue: [self extension updateReferencesUsing: aDictionary]! !!Morph methodsFor: 'copying' stamp: 'dgd 2/22/2003 14:36'!usableSiblingInstance	"Return another similar morph whose Player is of the same class as mine"	| aName usedNames newPlayer newMorph topRenderer |	(topRenderer := self topRendererOrSelf) == self 		ifFalse: [^topRenderer usableSiblingInstance].	self assuredPlayer assureUniClass.	newMorph := self veryDeepCopyWithSiblingOf: self player.	newPlayer := newMorph player.	newPlayer resetCostumeList.	(aName := self knownName) isNil 		ifTrue: [self player notNil ifTrue: [aName := newMorph innocuousName]].	"Force a difference here"	aName notNil 		ifTrue: 			[usedNames := (self world ifNil: [OrderedCollection new]						ifNotNil: [self world allKnownNames]) copyWith: aName.			newMorph setNameTo: (Utilities keyLike: aName						satisfying: [:f | (usedNames includes: f) not])].	newMorph privateOwner: nil.	newMorph renderedMorph eventHandler notNil 		ifTrue: [newPlayer assureEventHandlerRepresentsStatus].	self currentWorld addMorphBack: newMorph.	self presenter flushPlayerListCache.	^newMorph! !!Morph methodsFor: 'copying' stamp: 'dgd 2/16/2003 19:59'!veryDeepInner: deepCopier 	"The inner loop, so it can be overridden when a field should not  	be traced."	"super veryDeepInner: deepCopier.	know Object has no inst vars"	bounds _ bounds clone.	"Points are shared with original"	"owner _ owner.	special, see veryDeepFixupWith:"	submorphs _ submorphs veryDeepCopyWith: deepCopier.	"each submorph's fixup will install me as the owner"	"fullBounds _ fullBounds.	fullBounds is shared with original!!"	color _ color veryDeepCopyWith: deepCopier.	"color, if simple, will return self. may be complex"	self		privateExtension: (self extension veryDeepCopyWith: deepCopier)! !!Morph methodsFor: 'debug and other' stamp: 'gm 2/22/2003 13:41'!addMouseUpActionWith: codeToRun 	((codeToRun isMessageSend) not and: [codeToRun isEmptyOrNil]) 		ifTrue: [^self].	self setProperty: #mouseUpCodeToRun toValue: codeToRun.	self 		on: #mouseUp		send: #programmedMouseUp:for:		to: self.	self 		on: #mouseDown		send: #programmedMouseDown:for:		to: self.	self 		on: #mouseEnter		send: #programmedMouseEnter:for:		to: self.	self 		on: #mouseLeave		send: #programmedMouseLeave:for:		to: self! !!Morph methodsFor: 'debug and other' stamp: 'dgd 2/22/2003 14:27'!allStringsAfter: aSubmorph 	"return an OrderedCollection of strings of text in my submorphs.  If aSubmorph is non-nil, begin with that container."	| list string ok |	list := OrderedCollection new.	ok := aSubmorph isNil.	self allMorphsDo: 			[:sub | 			ok ifFalse: [ok := sub == aSubmorph].	"and do this one too"			ok 				ifTrue: 					[(string := sub userString) ifNotNil: 							[string isString ifTrue: [list add: string] ifFalse: [list addAll: string]]]].	^list! !!Morph methodsFor: 'debug and other' stamp: 'gm 2/22/2003 13:16'!buildDebugMenu: aHand 	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu aPlayer |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) 		ifTrue: 			[aMenu add: 'start drawing again' action: #resumeAfterDrawError.			aMenu addLine].	(self hasProperty: #errorOnStep) 		ifTrue: 			[aMenu add: 'start stepping again' action: #resumeAfterStepError.			aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	Smalltalk isMorphic 		ifFalse: [aMenu add: 'inspect morph (in MVC)' action: #inspect].	(self isMorphicModel) 		ifTrue: 			[aMenu 				add: 'inspect model'				target: self model				action: #inspect].	(aPlayer := self player) ifNotNil: 			[aMenu 				add: 'inspect player'				target: aPlayer				action: #inspect].	aMenu 		add: 'explore morph'		target: self		selector: #explore.	aMenu addLine.	aMenu 		add: 'viewer for Player'		target: self player		action: #beViewed.	aMenu 		balloonTextForLastItem: 'Opens a viewer on my Player -- this is the same thing you get if you click on the cyan "View" halo handle'.	aMenu 		add: 'viewer for Morph'		target: self		action: #viewMorphDirectly.	aMenu 		balloonTextForLastItem: 'Opens a Viewer on this Morph, rather than on its Player'.	aMenu addLine.	aPlayer ifNotNil: 			[aPlayer class isUniClass 				ifTrue: 					[aMenu 						add: 'browse player class'						target: aPlayer						action: #browseHierarchy]].	aMenu 		add: 'browse morph class'		target: self		selector: #browseHierarchy.	aMenu addLine.	aPlayer ifNotNil: 			[aMenu 				add: 'player protocol (tiles)'				target: aPlayer				action: #openInstanceBrowserWithTiles			"#browseProtocolForPlayer"].	aMenu 		add: 'morph protocol (text)'		target: self		selector: #haveFullProtocolBrowsed.	aMenu 		add: 'morph protocol (tiles)'		target: self		selector: #openInstanceBrowserWithTiles.	aMenu addLine.	self addViewingItemsTo: aMenu.	aMenu		add: 'make own subclass' action: #subclassMorph;		add: 'internal name ' action: #choosePartName;		add: 'save morph in file' action: #saveOnFile;		addLine;		add: 'call #tempCommand' action: #tempCommand;		add: 'define #tempCommand' action: #defineTempCommand;		addLine;		add: 'control-menu...'			target: self			selector: #invokeMetaMenu:;		add: 'edit balloon help' action: #editBalloonHelpText.	^aMenu! !!Morph methodsFor: 'debug and other' stamp: 'dgd 2/22/2003 19:05'!ownerChain	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"	| c next |	c := OrderedCollection with: self.	next := self.	[(next := next owner) notNil] whileTrue: [c add: next].	^c asArray! !!Morph methodsFor: 'debug and other' stamp: 'gm 2/22/2003 13:41'!programmedMouseUp: anEvent for: aMorph 	| aCodeString |	self deleteAnyMouseActionIndicators.	aCodeString := self valueOfProperty: #mouseUpCodeToRun ifAbsent: [^self].	(self fullBounds containsPoint: anEvent cursorPoint) ifFalse: [^self].		[(aCodeString isMessageSend) 		ifTrue: [aCodeString value]		ifFalse: 			[Compiler 				evaluate: aCodeString				for: self				notifying: nil				logged: false]] 			on: ProgressTargetRequestNotification			do: [:ex | ex resume: self]	"in case a save/load progress display needs a home"! !!Morph methodsFor: 'drawing' stamp: 'dgd 2/16/2003 20:02'!clipLayoutCells	"Drawing/layout specific. If this property is set, clip the  	submorphs of the receiver by its cell bounds."	^ self		valueOfProperty: #clipLayoutCells		ifAbsent: [false]! !!Morph methodsFor: 'drawing' stamp: 'dgd 2/16/2003 20:02'!clipSubmorphs	"Drawing specific. If this property is set, clip the receiver's  	submorphs to the receiver's clipping bounds."	^ self		valueOfProperty: #clipSubmorphs		ifAbsent: [false]! !!Morph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 14:31'!drawSubmorphsOn: aCanvas 	"Display submorphs back to front"	| drawBlock |	submorphs isEmpty ifTrue: [^self].	drawBlock := [:canvas | submorphs reverseDo: [:m | canvas fullDrawMorph: m]].	self clipSubmorphs 		ifTrue: [aCanvas clipBy: self clippingBounds during: drawBlock]		ifFalse: [drawBlock value: aCanvas]! !!Morph methodsFor: 'drawing' stamp: 'dgd 2/16/2003 21:41'!visible	"answer whether the receiver is visible"	self hasExtension		ifFalse: [^ true].	^ self extension visible! !!Morph methodsFor: 'drawing' stamp: 'dgd 2/16/2003 20:24'!visible: aBoolean 	"set the 'visible' attribute of the receiver to aBoolean"	(self hasExtension not and:[aBoolean])				ifTrue: [^ self].	self visible == aBoolean		ifTrue: [^ self].	self assureExtension visible: aBoolean.	self changed! !!Morph methodsFor: 'drop shadows' stamp: 'dgd 2/16/2003 21:42'!hasDropShadow	"answer whether the receiver has DropShadow"	^ self		valueOfProperty: #hasDropShadow		ifAbsent: [false]! !!Morph methodsFor: 'drop shadows' stamp: 'dgd 2/16/2003 21:58'!hasRolloverBorder	"answer whether the receiver has RolloverBorder"	^ self		valueOfProperty: #hasRolloverBorder		ifAbsent: [false]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 14:31'!formerOwner: aMorphOrNil 	aMorphOrNil isNil 		ifTrue: [self removeProperty: #formerOwner]		ifFalse: [self setProperty: #formerOwner toValue: aMorphOrNil]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 14:31'!formerPosition: formerPosition 	formerPosition isNil 		ifTrue: [self removeProperty: #formerPosition]		ifFalse: [self setProperty: #formerPosition toValue: formerPosition]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'aoy 2/15/2003 21:51'!slideBackToFormerSituation: evt 	| slideForm formerOwner formerPosition aWorld startPoint endPoint trans |	formerOwner := self formerOwner.	formerPosition := self formerPosition.	aWorld := self world.	trans := formerOwner transformFromWorld.	slideForm := trans isPureTranslation 				ifTrue: [self imageForm offset: 0 @ 0]				ifFalse: 					[((TransformationMorph new asFlexOf: self) transform: trans) imageForm 						offset: 0 @ 0]. 	startPoint := evt hand fullBounds origin.	endPoint := trans localPointToGlobal: formerPosition.	owner privateRemoveMorph: self.	aWorld displayWorld.	slideForm 		slideFrom: startPoint		to: endPoint		nSteps: 12		delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt! !!Morph methodsFor: 'e-toy support' stamp: 'dgd 2/22/2003 14:31'!enclosingEditor	"Return the next editor around the receiver"	| tested |	tested := owner.	[tested isNil] whileFalse: 			[tested isTileEditor ifTrue: [^tested].			tested := tested owner].	^nil! !!Morph methodsFor: 'e-toy support' stamp: 'dgd 2/22/2003 14:35'!topEditor	"Return the top-most editor around the receiver"	| found tested |	tested := self.	[tested isNil] whileFalse: 			[tested isTileEditor ifTrue: [found := tested].			tested := tested owner].	^found! !!Morph methodsFor: 'e-toy support' stamp: 'dgd 2/22/2003 14:36'!unlockOneSubpart	| unlockables aMenu reply |	unlockables := self submorphs select: [:m | m isLocked].	unlockables size <= 1 ifTrue: [^self unlockContents].	aMenu := SelectionMenu 				labelList: (unlockables collect: [:m | m externalName])				selections: unlockables.	reply := aMenu startUpWithCaption: 'Who should be be unlocked?'.	reply isNil ifTrue: [^self].	reply unlock! !!Morph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:36'!transformFrom: uberMorph 	"Return a transform to be used to map coordinates in a morph above me into my childrens coordinates, or vice-versa. This is used to support scrolling, scaling, and/or rotation. This default implementation just returns my owner's transform or the identity transform if my owner is nil. 	Note:  This method cannot be used to map into the receiver's coordinate system!!"	(self == uberMorph or: [owner isNil]) ifTrue: [^IdentityTransform new].	^owner transformFrom: uberMorph! !!Morph methodsFor: 'fileIn/out' stamp: 'dgd 2/22/2003 14:35'!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg := self valueOfProperty: #SqueakPage) ifNil: [pg := SqueakPage new]		ifNotNil: 			[pg contentsMorph ~~ self 				ifTrue: 					[self inform: 'morph''s SqueakPage property is out of date'.					pg := SqueakPage new]].	(url := pg url) ifNil: 			[url := ServerDirectory defaultStemUrl , '1.sp'.	"A new legal place"			url := FillInTheBlank 						request: 'url of a place to store this object.Must begin with file:// or ftp://'						initialAnswer: url.			url isEmpty ifTrue: [^#cancel]].	stamp := Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol := pg policy) ifNil: [pol := #neverWrite].	pg		policy: #now;		dirty: true.	pg write.	"force the write"	pg policy: pol.	^pg! !!Morph methodsFor: 'fileIn/out' stamp: 'gm 2/15/2003 14:58'!updateFromResource	| pathName newMorph f |	(pathName := self valueOfProperty: #resourceFilePath) ifNil: [^self].	(pathName asLowercase endsWith: '.morph') 		ifTrue: 			[newMorph := (FileStream readOnlyFileNamed: pathName) fileInObjectAndCode.			(newMorph isMorph) 				ifFalse: [^self error: 'Resource not a single morph']]		ifFalse: 			[f := Form fromFileNamed: pathName.			f ifNil: [^self error: 'unrecognized image file format'].			newMorph := SketchMorph withForm: f].	newMorph setProperty: #resourceFilePath toValue: pathName.	self owner replaceSubmorph: self by: newMorph! !!Morph methodsFor: 'geometry eToy' stamp: 'dgd 2/22/2003 19:04'!color: sensitiveColor sees: soughtColor 	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	"Make a mask with black where sensitiveColor is, white elsewhere"	| myImage sensitivePixelMask map patchBelowMe tfm morphAsFlexed i1 |	tfm := self transformFrom: self world.	morphAsFlexed := tfm isIdentity 				ifTrue: [self]				ifFalse: [TransformationMorph new flexing: self clone byTransformation: tfm].	myImage := morphAsFlexed imageForm offset: 0 @ 0.	sensitivePixelMask := Form extent: myImage extent depth: 1.	map := Bitmap new: (1 bitShift: (myImage depth min: 15)).	map at: (i1 := sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask 		copyBits: sensitivePixelMask boundingBox		from: myImage form		at: 0 @ 0		colorMap: map.	"get an image of the world below me"	patchBelowMe := self world 				patchAt: morphAsFlexed fullBounds				without: self				andNothingAbove: false.	"sensitivePixelMask displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: i1 put: 0.	"clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask 		copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0 @ 0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	"sensitivePixelMask displayAt: 200@0."	^(sensitivePixelMask tallyPixelValues second) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'dgd 2/22/2003 19:05'!goHome	| box |	(owner isInMemory and: [owner notNil]) 		ifTrue: 			[self visible 				ifTrue: 					[box := owner.					self left < box left ifTrue: [self position: box left @ self position y].					self right > box right 						ifTrue: [self position: (box right - self width) @ self position y].					self top < box top ifTrue: [self position: self position x @ box top].					self bottom > box bottom 						ifTrue: [self position: self position x @ (box bottom - self height)]]]! !!Morph methodsFor: 'geometry eToy' stamp: 'dgd 2/22/2003 19:06'!touchesColor: soughtColor 	"Return true if any of my pixels overlap pixels of soughtColor."	"Make a sahdow mask with black in my shape, white elsewhere"	| map patchBelowMe shadowForm tfm morphAsFlexed |	tfm := self transformFrom: self world.	morphAsFlexed := tfm isIdentity 				ifTrue: [self]				ifFalse: [TransformationMorph new flexing: self clone byTransformation: tfm].	shadowForm := morphAsFlexed shadowForm offset: 0 @ 0.	"get an image of the world below me"	patchBelowMe := (self world 				patchAt: morphAsFlexed fullBounds				without: self				andNothingAbove: false) offset: 0 @ 0.	"shadowForm displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with our shape."	map := Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm 		copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0 @ 0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	"shadowForm displayAt: 200@0."	^(shadowForm tallyPixelValues second) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'dgd 2/22/2003 14:37'!x	"Return my horizontal position relative to the cartesian origin of a relevant playfield"	| aPlayfield |	aPlayfield := self referencePlayfield.	^aPlayfield isNil 		ifTrue: [self referencePosition x]		ifFalse: [self referencePosition x - aPlayfield cartesianOrigin x]! !!Morph methodsFor: 'geometry eToy' stamp: 'aoy 2/17/2003 01:00'!x: aNumber 	"Set my horizontal position relative to the cartesian origin of the playfield or the world."	| offset aPlayfield newX |	aPlayfield := self referencePlayfield.	offset := self left - self referencePosition x.	newX := aPlayfield isNil				ifTrue: [aNumber + offset]				ifFalse: [aPlayfield cartesianOrigin x + aNumber + offset].	self position: newX @ bounds top! !!Morph methodsFor: 'geometry eToy' stamp: 'dgd 2/22/2003 14:37'!y	"Return my vertical position relative to the cartesian origin of the playfield or the world. Note that larger y values are closer to the top of the screen."	| w aPlayfield |	w := self world.	w ifNil: [^bounds top].	aPlayfield := self referencePlayfield.	^aPlayfield isNil 		ifTrue: [w cartesianOrigin y - self referencePosition y]		ifFalse: [aPlayfield cartesianOrigin y - self referencePosition y]! !!Morph methodsFor: 'geometry eToy' stamp: 'aoy 2/17/2003 01:00'!y: aNumber 	"Set my vertical position relative to the cartesian origin of the playfield or the world. Note that larger y values are closer to the top of the screen."	| w offset newY aPlayfield |	w := self world.	w ifNil: [^self position: bounds left @ aNumber].	aPlayfield := self referencePlayfield.	offset := self top - self referencePosition y.	newY := aPlayfield isNil				ifTrue: [w bottom - aNumber + offset]				ifFalse: [aPlayfield cartesianOrigin y - aNumber + offset].	self position: bounds left @ newY! !!Morph methodsFor: 'geometry testing' stamp: 'dgd 2/22/2003 14:33'!obtrudesBeyondContainer	"Answer whether the receiver obtrudes beyond the bounds of its container"	| top |	top := self topRendererOrSelf.	(top owner isNil or: [top owner isHandMorph]) ifTrue: [^false].	^(top owner bounds containsRect: top bounds) not! !!Morph methodsFor: 'halos and balloon help' stamp: 'dgd 2/22/2003 19:05'!isLikelyRecipientForMouseOverHalos	^self player notNil! !!Morph methodsFor: 'halos and balloon help' stamp: 'dgd 2/16/2003 19:30'!setBalloonText: stringOrText maxLineLength: aLength 	"Set receiver's balloon help text. Pass nil to remove the help."	(self hasExtension not			and: [stringOrText isNil])		ifTrue: [^ self].	self assureExtension		balloonText: (stringOrText				ifNotNil: [stringOrText asString withNoLineLongerThan: aLength])! !!Morph methodsFor: 'halos and balloon help' stamp: 'dgd 2/22/2003 19:06'!wantsHalo	| topOwner |	^(topOwner := self topRendererOrSelf owner) notNil 		and: [topOwner wantsHaloFor: self]! !!Morph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:00'!basicInitialize	"Do basic generic initialization of the instance variables:  	Set up the receiver, created by a #basicNew and now ready to  	be initialized, by placing initial values in the instance variables  	as appropriate"owner _ nil.	submorphs _ EmptyArray.	bounds _ self defaultBounds.		color _ self defaultColor! !!Morph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:06'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 corner: 50 @ 40! !!Morph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color blue! !!Morph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 17:30'!initialize	"initialize the state of the receiver"owner _ nil.	submorphs _ EmptyArray.	bounds _ self defaultBounds.		color _ self defaultColor! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:31'!doLayoutIn: layoutBounds 	"Compute a new layout based on the given layout bounds."	"Note: Testing for #bounds or #layoutBounds would be sufficient to	figure out if we need an invalidation afterwards but #outerBounds	is what we need for all leaf nodes so we use that."	| layout box priorBounds |	priorBounds := self outerBounds.	submorphs isEmpty ifTrue: [^fullBounds := priorBounds].	"Send #ownerChanged to our children"	submorphs do: [:m | m ownerChanged].	layout := self layoutPolicy.	layout ifNotNil: [layout layout: self in: layoutBounds].	self adjustLayoutBounds.	fullBounds := self privateFullBounds.	box := self outerBounds.	box = priorBounds 		ifFalse: [self invalidRect: (priorBounds quickMerge: box)]! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:32'!minExtent	"Layout specific. Return the minimum size the receiver can be represented in.	Implementation note: When this message is sent from an owner trying to lay out its children it will traverse down the morph tree and recompute the minimal arrangement of the morphs based on which the minimal extent is returned. When a morph with some layout strategy is encountered, the morph will ask its strategy to compute the new arrangement. However, since the final size given to the receiver is unknown at the point of the query, the assumption is made that the current bounds of the receiver are the base on which the layout should be computed. This scheme prevents strange layout changes when for instance, a table is contained in another table. Unless the inner table has been resized manually (which means its bounds are already enlarged) the arrangement of the inner table will not change here. Thus the entire layout computation is basically an iterative process which may have different results depending on the incremental changes applied."	| layout minExtent extra hFit vFit |	hFit := self hResizing.	vFit := self vResizing.	(hFit == #spaceFill or: [vFit == #spaceFill]) 		ifFalse: 			["The receiver will not adjust to parents layout by growing or shrinking,		which means that an accurate layout defines the minimum size."			^self fullBounds extent].	"An exception -- a receiver with #shrinkWrap constraints but no children is being treated #rigid (the equivalent to a #spaceFill receiver in a non-layouting owner)"	self hasSubmorphs 		ifFalse: 			[hFit == #shrinkWrap ifTrue: [hFit := #rigid].			vFit == #shrinkWrap ifTrue: [vFit := #rigid]].	layout := self layoutPolicy.	layout isNil 		ifTrue: [minExtent := 0 @ 0]		ifFalse: [minExtent := layout minExtentOf: self in: self layoutBounds].	hFit == #rigid 		ifTrue: [minExtent := self fullBounds extent x @ minExtent y]		ifFalse: 			[extra := self bounds width - self layoutBounds width.			minExtent := (minExtent x + extra) @ minExtent y].	minExtent := vFit == #rigid 				ifTrue: [minExtent x @ self fullBounds extent y]				ifFalse: 					[extra := self bounds height - self layoutBounds height.					minExtent x @ (minExtent y + extra)].	minExtent := minExtent max: self minWidth @ self minHeight.	^minExtent! !!Morph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:52'!minHeight	"answer the receiver's minHeight"	^ self		valueOfProperty: #minHeight		ifAbsent: [2]! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:32'!minHeight: aNumber 	aNumber isNil 		ifTrue: [self removeProperty: #minHeight]		ifFalse: [self setProperty: #minHeight toValue: aNumber].	self layoutChanged! !!Morph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:54'!minWidth	"answer the receiver's minWidth"	^ self		valueOfProperty: #minWidth		ifAbsent: [2]! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:32'!minWidth: aNumber 	aNumber isNil 		ifTrue: [self removeProperty: #minWidth]		ifFalse: [self setProperty: #minWidth toValue: aNumber].	self layoutChanged! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:33'!privateFullBounds	"Private. Compute the actual full bounds of the receiver"	| box |	submorphs isEmpty ifTrue: [^self outerBounds].	box := self outerBounds copy.	box := box quickMerge: (self clipSubmorphs 						ifTrue: [self submorphBounds intersect: self clippingBounds]						ifFalse: [self submorphBounds]).	^box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout-menu' stamp: 'dgd 2/22/2003 14:31'!hasNoLayoutString	^self layoutPolicy isNil 		ifTrue: ['<on>no layout']		ifFalse: ['<off>no layout']! !!Morph methodsFor: 'layout-properties' stamp: 'dgd 2/16/2003 20:07'!layoutFrame	"Layout specific. Return the layout frame describing where the  	receiver should appear in a proportional layout"	^ self hasExtension		ifTrue: [ self extension layoutFrame]! !!Morph methodsFor: 'layout-properties' stamp: 'dgd 2/16/2003 20:07'!layoutPolicy	"Layout specific. Return the layout policy describing how children 	of the receiver should appear."	^ self hasExtension		ifTrue: [ self extension layoutPolicy]! !!Morph methodsFor: 'layout-properties' stamp: 'dgd 2/16/2003 20:07'!layoutProperties	"Return the current layout properties associated with the  	receiver"	^ self hasExtension		ifTrue: [self extension layoutProperties]! !!Morph methodsFor: 'layout-properties' stamp: 'dgd 2/16/2003 20:02'!spaceFillWeight	"Layout specific. This property describes the relative weight that 	should be given to the receiver when extra space is distributed 	between different #spaceFill cells."	^ self		valueOfProperty: #spaceFillWeight		ifAbsent: [1]! !!Morph methodsFor: 'menus' stamp: 'gm 2/16/2003 20:35'!adMiscExtrasTo: aMenu 	"Add a submenu of miscellaneous extra items to the menu."	| realOwner realMorph subMenu |	subMenu := MenuMorph new defaultTarget: self.	(self isWorldMorph not 		and: [(self renderedMorph isSystemWindow) not]) 			ifTrue: [subMenu add: 'put in a window' action: #embedInWindow].	self isWorldMorph 		ifFalse: 			[subMenu add: 'adhere to edge...' action: #adhereToEdge.			subMenu addLine].	realOwner := (realMorph := self topRendererOrSelf) owner.	(realOwner isKindOf: TextPlusPasteUpMorph) 		ifTrue: 			[subMenu add: 'GeeMail stuff...'				subMenu: (realOwner textPlusMenuFor: realMorph)].	self affiliatedSelector ifNotNil: 			[subMenu add: 'open a messenger' action: #openMessenger.			subMenu 				balloonTextForLastItem: 'Open a Messenger on the actual method call used when the button action of this object is triggered.'.			subMenu addLine].	subMenu		add: 'add mouse up action' action: #addMouseUpAction;		add: 'remove mouse up action' action: #removeMouseUpAction;		add: 'hand me tiles to fire this button' action: #handMeTilesToFire.	subMenu addLine.	subMenu add: 'arrowheads on pen trails...' action: #setArrowheads.	subMenu addLine.	subMenu defaultTarget: self topRendererOrSelf.	subMenu add: 'draw new path' action: #definePath.	subMenu add: 'follow existing path' action: #followPath.	subMenu add: 'delete existing path' action: #deletePath.	subMenu addLine.	self addGenieMenuItems: subMenu hand: ActiveHand.	aMenu add: 'extras...' subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'dgd 2/22/2003 14:26'!adhereToEdge: edgeSymbol 	(owner isNil or: [owner isHandMorph]) ifTrue: [^self].	self perform: (edgeSymbol , ':') asSymbol		withArguments: (Array with: (owner perform: edgeSymbol))! !!Morph methodsFor: 'menus' stamp: 'dgd 2/22/2003 14:33'!printPSToFileNamed: aString 	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag |	fileName := aString asFileName.	fileName := FillInTheBlank 				request: 'File name? (".eps" will be added to end)'				initialAnswer: fileName.	fileName isEmpty ifTrue: [^self beep].	(fileName endsWith: '.eps') ifFalse: [fileName := fileName , '.eps'].	rotateFlag := ((PopUpMenu labels: 'portrait (tall)landscape (wide)') 				startUpWithCaption: 'Choose orientation...') = 2.	(FileStream newFileNamed: fileName)		nextPutAll: (PostscriptCanvas defaultCanvasType morphAsPostscript: self					rotated: rotateFlag);		close! !!Morph methodsFor: 'naming' stamp: 'gm 2/22/2003 13:16'!name: aName 	(aName isString) ifTrue: [self setNameTo: aName]! !!Morph methodsFor: 'naming' stamp: 'dgd 2/22/2003 14:33'!nameInModel	"Return the name for this morph in the underlying model or nil."	| w |	w := self world.	w isNil ifTrue: [^nil] ifFalse: [^w model nameFor: self]! !!Morph methodsFor: 'naming' stamp: 'dgd 2/16/2003 21:57'!setNamePropertyTo: aName 	"change the receiver's externalName"	self assureExtension externalName: aName! !!Morph methodsFor: 'naming' stamp: 'dgd 2/22/2003 14:35'!setNameTo: aName 	| nameToUse nameString |	nameToUse := aName ifNotNil: 					[(nameString := aName asString) notEmpty ifTrue: [nameString] ifFalse: ['']].	self setNamePropertyTo: nameToUse	"no Texts here!!"! !!Morph methodsFor: 'naming' stamp: 'gm 2/22/2003 13:16'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isMorphicModel) 		ifTrue: [^self slotName]		ifFalse: 			[self eventHandler ifNotNil: 					[self eventHandler mouseDownSelector ifNotNil: 							[hh := self eventHandler mouseDownSelector indexOfSubCollection: 'Mouse'										startingAt: 1.							hh > 0 								ifTrue: [^self eventHandler mouseDownSelector copyFrom: 1 to: hh - 1]].					self eventHandler mouseUpSelector ifNotNil: 							[hh := self eventHandler mouseUpSelector indexOfSubCollection: 'Mouse'										startingAt: 1.							hh > 0 ifTrue: [^self eventHandler mouseUpSelector copyFrom: 1 to: hh - 1]]]].	"	(self eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ self eventHandler mouseDownRecipient nameFor: self]]].	"	"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"	^self world specialNameInModelFor: self! !!Morph methodsFor: 'object fileIn' stamp: 'dgd 2/22/2003 14:30'!convertAugust1998: varDict using: smartRefStrm 	"These variables are automatically stored into the new instance 	('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ). 	This method is for additional changes. Use statements like (foo _ 	varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information 	in ('eventHandler' 'properties' 'costumee' )"	"This method moves all property variables as well as 	eventHandler, and costumee into a morphicExtension."	"Move refs to eventhandler and costumee into extension"	| propVal |	(varDict at: 'eventHandler') isNil 		ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') isNil 		ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') isNil 		ifFalse: 			[(varDict at: 'properties') keys do: 					[:key | 					"Move property extensions into extension"					propVal := (varDict at: 'properties') at: key.					propVal ifNotNil: 							[key == #possessive 								ifTrue: [propVal == true ifTrue: [self bePossessive]]								ifFalse: 									[key ifNotNil: [self assureExtension convertProperty: key toValue: propVal]]]]]! !!Morph methodsFor: 'object fileIn' stamp: 'dgd 2/22/2003 14:30'!convertNovember2000DropShadow: varDict using: smartRefStrm 	"Work hard to eliminate the DropShadow. Inst vars are already  	stored into."	| rend |	submorphs notEmpty 		ifTrue: 			[rend := submorphs first renderedMorph.			"a text?"			rend setProperty: #hasDropShadow toValue: true.			rend setProperty: #shadowColor toValue: (varDict at: 'color').			rend setProperty: #shadowOffset toValue: (varDict at: 'shadowOffset').			"ds owner ifNotNil: [ds owner addAllMorphs: ds  			submorphs]. ^rend does this"			rend privateOwner: owner.			self hasExtension 				ifTrue: 					[""					self extension actorState 						ifNotNil: [rend actorState: self extension actorState].					self extension externalName 						ifNotNil: [rend setNameTo: self extension externalName].					self extension player ifNotNil: 							[""							rend player: self extension player.							self extension player rawCostume: rend]].			^rend].	(rend := Morph new) color: Color transparent.	^rend! !!Morph methodsFor: 'objects from disk' stamp: 'dgd 2/22/2003 14:33'!objectForDataStream: refStrm 	"I am being written out on an object file"	| dp |	self sqkPage ifNotNil: 			[refStrm rootObject == self | (refStrm rootObject == self sqkPage) 				ifFalse: 					[self url notEmpty 						ifTrue: 							[dp := self sqkPage copyForSaving.	"be careful touching this object!!"							refStrm replace: self with: dp.							^dp]]].	self prepareToBeSaved.	"Amen"	^self! !!Morph methodsFor: 'objects from disk' stamp: 'dgd 2/22/2003 14:34'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	aFileName := ('my ' , self class name) asFileName.	"do better?"	aFileName := FillInTheBlank 				request: 'File name? (".morph" will be added to end)'				initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^self beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.morph'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName , '.morph'].	fileStream := FileStream newFileNamed: aFileName.	fileStream fileOutClass: nil andObject: self	"Puts UniClass definitions out anyway"! !!Morph methodsFor: 'parts bin' stamp: 'dgd 2/16/2003 21:37'!isPartsDonor	"answer whether the receiver is PartsDonor"	self hasExtension		ifFalse: [^ false].	^ self extension isPartsDonor! !!Morph methodsFor: 'parts bin' stamp: 'dgd 2/16/2003 21:39'!isPartsDonor: aBoolean 	"change the receiver's isPartDonor property"	(self hasExtension not			and: [aBoolean not])		ifTrue: [^ self].	self assureExtension isPartsDonor: aBoolean! !!Morph methodsFor: 'pen' stamp: 'dgd 2/22/2003 14:36'!trailMorph	"You can't draw trails on me, but try my owner."	owner isNil ifTrue: [^nil].	^owner trailMorph! !!Morph methodsFor: 'printing' stamp: 'dgd 2/22/2003 14:27'!colorString: aColor 	aColor isNil ifTrue: [^'nil'].	Color colorNames 		do: [:colorName | aColor = (Color perform: colorName) ifTrue: [^'Color ' , colorName]].	^aColor storeString! !!Morph methodsFor: 'printing' stamp: 'dgd 2/22/2003 19:05'!printOn: aStream 	| aName |	super printOn: aStream.	(aName := self knownName) notNil 		ifTrue: [aStream nextPutAll: '<' , aName , '>'].	aStream nextPutAll: '('.	aStream		print: self identityHash;		nextPutAll: ')'! !!Morph methodsFor: 'scripting' stamp: 'dgd 2/22/2003 19:06'!selectorsForViewer	"Answer a list of symbols representing all the selectors available in all my viewer categories"	| aClass aList itsAdditions |	aClass := self renderedMorph class.	aList := OrderedCollection new.	[aClass == Morph superclass] whileFalse: 			[(aClass class includesSelector: #additionsToViewerCategories) 				ifTrue: 					[itsAdditions := aClass additionsToViewerCategories.					itsAdditions do: 							[:anAddition | 							anAddition second do: 									[:aSpec | 									"the spec list"									aSpec first == #command ifTrue: [aList add: aSpec second].									aSpec first == #slot 										ifTrue: 											[aList add: (aSpec seventh).											aList add: aSpec ninth]]]].			aClass := aClass superclass].	^aList asSet copyWithoutAll: #(#unused #dummy)	"SimpleSliderMorph basicNew selectorsForViewer"! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 19:05'!isInWorld	"Return true if this morph is in a world."	^self world notNil! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 14:34'!renderedMorph	"If the receiver is a renderer morph, answer the rendered morph. Otherwise, answer the receiver. A renderer morph with no submorphs answers itself. See the comment in Morph>isRenderer."	self isRenderer ifFalse: [^self].	submorphs isEmpty ifTrue: [^self].	^self firstSubmorph renderedMorph! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 14:34'!root	"Return the root of the composite morph containing the receiver. The owner of the root is either nil, a WorldMorph, or a HandMorph. If the receiver's owner is nil, the root is the receiver itself. This method always returns a morph."	(owner isNil or: [owner isWorldOrHandMorph]) ifTrue: [^self].	^owner root! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 19:06'!topRendererOrSelf	"Answer the topmost renderer for this morph, or this morph itself if it has no renderer. See the comment in Morph>isRenderer."	| top topsOwner |	owner ifNil: [^self].	self isWorldMorph ifTrue: [^self].	"ignore scaling of this world"	top := self.	topsOwner := top owner.	[topsOwner notNil and: [topsOwner isRenderer]] whileTrue: 			[top := topsOwner.			topsOwner := top owner].	^top! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 14:36'!world	^owner isNil ifTrue: [nil] ifFalse: [owner world]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:27'!allMorphsDo: aBlock 	"Evaluate the given block for all morphs in this composite morph (including the receiver)."	submorphs do: [:m | m allMorphsDo: aBlock].	aBlock value: self! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:31'!firstSubmorph	^submorphs first! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:32'!hasSubmorphs	^submorphs notEmpty! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:32'!lastSubmorph	^submorphs last! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:32'!morphsAt: aPoint behind: aMorph unlocked: aBool 	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."	| isBack found all tfm |	all := (aMorph isNil or: [owner isNil]) 				ifTrue: 					["Traverse down"					(self fullBounds containsPoint: aPoint) ifFalse: [^#()].					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].					nil]				ifFalse: 					["Traverse up"					tfm := self transformedFrom: owner.					all := owner 								morphsAt: (tfm localPointToGlobal: aPoint)								behind: self								unlocked: aBool.					WriteStream with: all].	isBack := aMorph isNil.	self submorphsDo: 			[:m | 			isBack 				ifTrue: 					[tfm := m transformedFrom: self.					found := m 								morphsAt: (tfm globalPointToLocal: aPoint)								behind: nil								unlocked: aBool.					found notEmpty 						ifTrue: 							[all ifNil: [all := WriteStream on: #()].							all nextPutAll: found]].			m == aMorph ifTrue: [isBack := true]].	(isBack and: [self containsPoint: aPoint]) 		ifTrue: 			[all ifNil: [^Array with: self].			all nextPut: self].	^all ifNil: [#()] ifNotNil: [all contents]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:35'!shuffleSubmorphs	"Randomly shuffle the order of my submorphs.  Don't call this method lightly!!"	| bg |	self invalidRect: self fullBounds.	(submorphs notEmpty and: [submorphs last mustBeBackmost]) 		ifTrue: 			[bg := submorphs last.			bg privateDelete].	submorphs := submorphs shuffled.	bg ifNotNil: [self addMorphBack: bg].	self layoutChanged! !!Morph methodsFor: 'submorphs-accessing' stamp: 'gm 2/22/2003 13:16'!submorphNamed: aName ifNone: aBlock 	"Find the first submorph with this name, or a button with an action selector of that name"	| sub args |	self submorphs do: [:p | p knownName = aName ifTrue: [^p]].	self submorphs do: 			[:button | 			(button respondsTo: #actionSelector) 				ifTrue: [button actionSelector == aName ifTrue: [^button]].			((button respondsTo: #arguments) and: [(args := button arguments) notNil]) 				ifTrue: [(args at: 2 ifAbsent: [nil]) == aName ifTrue: [^button]].			(button isAlignmentMorph) 				ifTrue: [(sub := button submorphNamed: aName ifNone: [nil]) ifNotNil: [^sub]]].	^aBlock value! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:35'!submorphsDo: aBlock 	submorphs do: aBlock! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'dgd 2/22/2003 14:26'!addMorphNearBack: aMorph 	| bg |	(submorphs notEmpty and: [submorphs last mustBeBackmost]) 		ifTrue: 			[bg := submorphs last.			bg privateDelete].	self addMorphBack: aMorph.	bg ifNotNil: [self addMorphBack: bg]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'dgd 2/22/2003 14:30'!comeToFront	| outerMorph |	outerMorph := self topRendererOrSelf.	(outerMorph owner isNil or: [outerMorph owner hasSubmorphs not]) 		ifTrue: [^self].	outerMorph owner firstSubmorph == outerMorph 		ifFalse: [outerMorph owner addMorphFront: outerMorph]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 2/25/2003 16:16'!delete	"Remove the receiver as a submorph of its owner and make its 	new owner be nil."	| aWorld |	aWorld := self world ifNil: [World].	"or some proper of getting the World"	"Terminate genie recognition focus"	"I encountered a case where the hand was nil, so I put in a little 	protection - raa"	aWorld 		ifNotNil: [aWorld currentHand ifNotNilDo: [:h | h disableGenieFocus: self]].	owner ifNotNil: 			[owner privateRemoveMorph: self.			 owner := nil.			 (self hasExtension not or: [self player isNil]) 				ifFalse: 					["Player must be notified"					self player noteDeletionOf: self fromWorld: aWorld]]! !!Morph methodsFor: 'testing' stamp: 'dgd 2/16/2003 21:20'!knownName	"answer a name by which the receiver is known, or nil if none"	^ self hasExtension		ifTrue: [self extension externalName]! !!Morph methodsFor: 'text-anchor' stamp: 'aoy 2/15/2003 21:47'!changeDocumentAnchor	"Change the anchor from/to document anchoring"	| newType |	newType := self textAnchorType == #document 		ifTrue: [#paragraph]		ifFalse: [ #document].	owner isTextMorph 		ifTrue: 			[owner 				anchorMorph: self				at: self position				type: newType]! !!Morph methodsFor: 'text-anchor' stamp: 'aoy 2/15/2003 21:48'!changeInlineAnchor	"Change the anchor from/to line anchoring"	| newType |	newType := self textAnchorType == #inline 				ifTrue: [#paragraph]				ifFalse: [#inline]. 	owner isTextMorph 		ifTrue: 			[owner 				anchorMorph: self				at: self position				type: newType]! !!Morph methodsFor: 'text-anchor' stamp: 'aoy 2/15/2003 21:48'!changeParagraphAnchor	"Change the anchor from/to paragraph anchoring"	| newType |	newType := self textAnchorType == #paragraph 		ifTrue: [#document]		ifFalse: [#paragraph].	owner isTextMorph 		ifTrue: 			[owner 				anchorMorph: self				at: self position				type: newType]! !!Morph methodsFor: 'texture support' stamp: 'dgd 2/16/2003 20:02'!isValidWonderlandTexture	"Return true if the receiver is a valid wonderland texture"	^ self		valueOfProperty: #isValidWonderlandTexture		ifAbsent: [true]! !!Morph methodsFor: 'texture support' stamp: 'dgd 2/16/2003 20:03'!wonderlandTexture	"Return the current wonderland texture associated with the  	receiver"	^ self		valueOfProperty: #wonderlandTexture		ifAbsent: []! !!Morph methodsFor: 'texture support' stamp: 'dgd 2/22/2003 14:36'!wonderlandTexture: aTexture 	"Return the current wonderland texture associated with the receiver"	aTexture isNil 		ifTrue: [self removeProperty: #wonderlandTexture]		ifFalse: [self setProperty: #wonderlandTexture toValue: aTexture]! !!Morph methodsFor: 'undo' stamp: 'gm 2/16/2003 20:34'!undoMove: cmd redo: redo owner: formerOwner bounds: formerBounds predecessor: formerPredecessor 	"Handle undo and redo of move commands in morphic"	self owner ifNil: [^self beep].	redo 		ifFalse: 			["undo sets up the redo state first"			cmd 				redoTarget: self				selector: #undoMove:redo:owner:bounds:predecessor:				arguments: { 						cmd.						true.						owner.						bounds.						owner morphPreceding: self}].	formerOwner ifNotNil: 			[formerPredecessor ifNil: [formerOwner addMorphFront: self]				ifNotNil: [formerOwner addMorph: self after: formerPredecessor]].	self bounds: formerBounds.	(self isSystemWindow) ifTrue: [self activate]! !!Morph methodsFor: 'visual properties' stamp: 'dgd 2/16/2003 20:02'!fillStyle	"Return the current fillStyle of the receiver."	^ self		valueOfProperty: #fillStyle		ifAbsent: ["Workaround already converted morphs"			color				ifNil: [self defaultColor]]! !!Morph methodsFor: 'private' stamp: 'dgd 2/16/2003 19:53'!privateMoveBy: delta 	"Private!! Use 'position:' instead."	| fill |	self hasExtension		ifTrue: [self extension player				ifNotNil: ["Most cases eliminated fast by above test"					self getPenDown						ifTrue: ["If this is a costume for a player with its 							pen down, draw a line."							self moveWithPenDownBy: delta]]].	bounds _ bounds translateBy: delta.	fullBounds		ifNotNil: [fullBounds _ fullBounds translateBy: delta].	fill _ self fillStyle.	fill isOrientedFill		ifTrue: [fill origin: fill origin + delta]! !!BackgroundMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/17/2003 01:20'!subBounds	"calculate the submorph bounds"	| subBounds |	subBounds := nil.	self submorphsDo: 			[:m | 			subBounds := subBounds isNil						ifTrue: [m fullBounds]						ifFalse: [subBounds merge: m fullBounds]].	^subBounds! !!BackgroundMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:43'!initialize	"initialize the state of the receiver"	super initialize.""	offset _ 0 @ 0.	delta _ 1 @ 0.	running _ true! !!BorderedMorph methodsFor: 'accessing' stamp: 'aoy 2/17/2003 01:19'!borderStyle	"Work around the borderWidth/borderColor pair"	| style |	borderColor ifNil: [^BorderStyle default].	borderWidth isZero ifTrue: [^BorderStyle default].	style := self valueOfProperty: #borderStyle ifAbsent: [BorderStyle default].	(borderWidth = style width and: 			["Hah!! Try understanding this..."			borderColor == style style or: 					["#raised/#inset etc"					#simple == style style and: [borderColor = style color]]]) 		ifFalse: 			[style := borderColor isColor 				ifTrue: [BorderStyle width: borderWidth color: borderColor]				ifFalse: [(BorderStyle perform: borderColor) width: borderWidth	"argh."].			self setProperty: #borderStyle toValue: style].	^style trackColorFrom: self! !!BorderedMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 22:42'!borderStyle: aBorderStyle 	"Work around the borderWidth/borderColor pair"	aBorderStyle = self borderStyle ifTrue: [^self].	"secure against invalid border styles"	(self canDrawBorder: aBorderStyle) 		ifFalse: 			["Replace the suggested border with a simple one"			^self borderStyle: (BorderStyle width: aBorderStyle width						color: (aBorderStyle trackColorFrom: self) color)].	aBorderStyle width = self borderStyle width ifFalse: [self changed].	(aBorderStyle isNil or: [aBorderStyle == BorderStyle default]) 		ifTrue: 			[self removeProperty: #borderStyle.			borderWidth := 0.			^self changed].	self setProperty: #borderStyle toValue: aBorderStyle.	borderWidth := aBorderStyle width.	borderColor := aBorderStyle style == #simple 				ifTrue: [aBorderStyle color]				ifFalse: [aBorderStyle style].	self changed! !!BorderedMorph methodsFor: 'drawing' stamp: 'dgd 2/17/2003 19:57'!areasRemainingToFill: aRectangle 	(color isColor			and: [color isTranslucent])		ifTrue: [^ Array with: aRectangle].	self wantsRoundedCorners		ifTrue: [(self borderWidth > 0					and: [self borderColor isColor							and: [self borderColor isTranslucent]])				ifTrue: [^ aRectangle						areasOutside: (self innerBounds intersect: self boundsWithinCorners)]				ifFalse: [^ aRectangle areasOutside: self boundsWithinCorners]]		ifFalse: [(self borderWidth > 0					and: [self borderColor isColor							and: [self borderColor isTranslucent]])				ifTrue: [^ aRectangle areasOutside: self innerBounds]				ifFalse: [^ aRectangle areasOutside: self bounds]]! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:00'!basicInitialize	"Do basic generic initialization of the instance variables"	super basicInitialize.""	self borderInitialize! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:53'!borderInitialize	"initialize the receiver state related to border"	borderColor_ self defaultBorderColor.	borderWidth _ self defaultBorderWidth!]style[(16 2 49 15 4 22 11 3 4 19)f2b,f2,f2c150048000,f2,f2cmagenta;,f2,f2cmagenta;,f2,f2cmagenta;,f2! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:33'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:07'!initialize	"initialize the state of the receiver"	super initialize.""	self borderInitialize! !!BorderedSubpaneDividerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:09'!defaultBorderWidth"answer the default border width for the receiver"	^ 0! !!BorderedSubpaneDividerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:09'!defaultColor"answer the default color/fill style for the receiver"	^ Color black! !!BorderedSubpaneDividerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:09'!initialize	"initialize the state of the receiver"	super initialize.""	self extent: 1 @ 1! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 0.8! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!initialize	"initialize the state of the receiver"	super initialize.	""	damageReported _ false.	self extent: 400 @ 250.	infectionHistory _ OrderedCollection new.	transmitInfection _ false.	self addAtoms: 30! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'aoy 2/15/2003 21:38'!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to becircles of known radius. This version uses the morph's positions--i.e.the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continue j p2 distSquared m1 m2 |	count := submorphs size.	sortedAtoms := submorphs 				asSortedCollection: [:mt1 :mt2 | mt1 position x < mt2 position x].	radius := 8.	twoRadii := 2 * radius.	radiiSquared := radius squared * 2.	collisions := OrderedCollection new.	1 to: count - 1		do: 			[:i | 			m1 := sortedAtoms at: i.			p1 := m1 position.			continue := (j := i + 1) <= count.			[continue] whileTrue: 					[m2 := sortedAtoms at: j.					p2 := m2 position.					continue := p2 x - p1 x <= twoRadii  								ifTrue: 									[distSquared := (p1 x - p2 x) squared + (p1 y - p2 y) squared.									distSquared < radiiSquared 										ifTrue: [collisions add: (Array with: m1 with: m2)].									(j := j + 1) <= count]								ifFalse: [false]]].	^collisions! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'dgd 2/22/2003 13:36'!updateTemperature: currentTemperature 	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures isNil 		ifTrue: 			[recentTemperatures := OrderedCollection new.			20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature := recentTemperatures sum asFloat / recentTemperatures size! !!CRStrokeMorph methodsFor: 'adding' stamp: 'dgd 2/22/2003 13:33'!addPoint: aPoint 	"We can save some time if we don't open this morph before we know the first point."	| r |	(points notEmpty and: [points last = aPoint]) ifTrue: [^self].	points add: aPoint.	r := points last extent: 1 @ 1.	bounds := points size = 1 ifTrue: [r] ifFalse: [bounds merge: r].	fullBounds := nil.	points size = 1 		ifTrue: [self openInWorld]		ifFalse: 			[World canvas 				line: (points at: (points size - 1 max: 1))				to: points last				color: self color]! !!CachingMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 23:03'!updateCacheCanvas: aCanvas 	"Update the cached image of the morphs being held by this hand."	| myBnds rectList |	myBnds := self fullBounds.	(cacheCanvas isNil or: [cacheCanvas extent ~= myBnds extent]) 		ifTrue: 			[cacheCanvas := (aCanvas allocateForm: myBnds extent) getCanvas.			cacheCanvas translateBy: myBnds origin negated				during: [:tempCanvas | super fullDrawOn: tempCanvas].			^self].	"incrementally update the cache canvas"	rectList := damageRecorder 				invalidRectsFullBounds: (0 @ 0 extent: myBnds extent).	damageRecorder reset.	rectList do: 			[:r | 			cacheCanvas 				translateTo: myBnds origin negated				clippingTo: r				during: 					[:c | 					c fillColor: Color transparent.	"clear to transparent"					super fullDrawOn: c]]! !!CachingMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryLightGray! !!CachingMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:48'!initialize	"initialize the state of the receiver"	super initialize.	""	damageRecorder _ DamageRecorder new! !!DoCommandOnceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color blue! !!DoCommandOnceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 8! !!DoCommandOnceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:08'!initialize	"initialize the state of the receiver"	super initialize.	""		self useRoundedCorners! !!EllipseMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!EllipseMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:26'!defaultColor	"answer the default color/fill style for the receiver"	^ Color yellow! !!AlertMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:11'!defaultBorderWidth"answer the default border width for the receiver"	^ 2! !!AlertMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:11'!defaultColor"answer the default color/fill style for the receiver"	^ Color red! !!AlertMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:11'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 25 @ 25.! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultBorderWidth"answer the default border width for the receiver"	^ 0! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultColor"answer the default color/fill style for the receiver"	^ Color blue! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!initialize	"Make a new atom with a random position and velocity."	super initialize.""	self extent: 8 @ 7.		self		randomPositionIn: (0 @ 0 corner: 300 @ 300)		maxVelocity: 10! !!EyeMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:24'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.968		b: 0.935! !!EyeMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:25'!initialize	"initialize the state of the receiver"	super initialize.	""		self extent: 30 @ 37.	self addMorphFront: (iris _ EllipseMorph new extent: 6 @ 6;					 borderWidth: 0;					 color: Color black).	self lookAtFront! !!FaceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!FaceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:49'!initialize	"initialize the state of the receiver"	super initialize.	""	self addMorph: (leftEye _ EyeMorph new);	  addMorph: (rightEye _ EyeMorph new);	  addMorph: (lips _ LipsMorph new).	leftEye position: self position.	rightEye position: leftEye extent x @ 0 + leftEye position.	lips position: 0 @ 20 + (leftEye bottomRight + rightEye bottomLeft - lips extent // 2).	self bounds: self fullBounds! !!FlashThumbnailMorph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:42'!player	"answer the receiver's player"	^ player! !!FlashThumbnailMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 13:29'!drawOn: aCanvas 	(player isNil or: [frameNumber isNil]) ifTrue: [^super drawOn: aCanvas].	false 		ifTrue: 			[super drawOn: aCanvas.			^aCanvas 				drawString: frameNumber printString				in: self innerBounds				font: nil				color: Color red].	image ifNil: 			[Cursor wait showWhile: 					[image := player imageFormOfSize: self extent - (self borderWidth * 2)								forFrame: frameNumber.					frameNumber printString displayOn: image]].	aCanvas 		frameRectangle: self bounds		width: self borderWidth		color: self borderColor.	aCanvas paintImage: image at: self topLeft + self borderWidth! !!HaloMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 13:46'!drawOn: aCanvas 	"Draw this morph only if it has no target."	target isNil ifTrue: [^super drawOn: aCanvas].	Preferences showBoundsInHalo 		ifTrue: 			[aCanvas 				frameAndFillRectangle: target boundsInWorld				fillColor: Color transparent				borderWidth: 1				borderColor: Color blue]! !!HaloMorph methodsFor: 'events' stamp: 'aoy 2/17/2003 01:27'!popUpFor: aMorph event: evt 	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| hand anEvent |	self flag: #workAround.	"We should really have some event/hand here..."	anEvent := evt isNil 				ifTrue: 					[hand := aMorph world activeHand.					hand ifNil: [hand := aMorph world primaryHand]. 					hand lastEvent transformedBy: (aMorph transformedFrom: nil)]				ifFalse: 					[hand := evt hand.					evt].	self target: aMorph.	hand halo: self.	hand world addMorphFront: self.	positionOffset := anEvent position 				- (aMorph point: aMorph position in: owner).	self startStepping.	(Preferences haloTransitions or: [self isMagicHalo]) 		ifTrue: 			[self magicAlpha: 0.0.			self startSteppingSelector: #fadeInInitially]! !!HaloMorph methodsFor: 'geometry testing' stamp: 'dgd 2/22/2003 13:46'!containsPoint: aPoint 	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."	target isNil ifTrue: [^super containsPoint: aPoint] ifFalse: [^false]! !!HaloMorph methodsFor: 'handles' stamp: 'gm 2/22/2003 13:13'!addFontEmphHandle: haloSpec 	(innerTarget isTextMorph) 		ifTrue: 			[self 				addHandle: haloSpec				on: #mouseDown				send: #chooseEmphasisOrAlignment				to: innerTarget]! !!HaloMorph methodsFor: 'handles' stamp: 'gm 2/22/2003 13:13'!addFontSizeHandle: haloSpec 	(innerTarget isTextMorph) 		ifTrue: 			[self 				addHandle: haloSpec				on: #mouseDown				send: #chooseFont				to: innerTarget]! !!HaloMorph methodsFor: 'handles' stamp: 'gm 2/22/2003 13:13'!addFontStyleHandle: haloSpec 	(innerTarget isTextMorph) 		ifTrue: 			[self 				addHandle: haloSpec				on: #mouseDown				send: #chooseStyle				to: innerTarget]! !!HaloMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 0.8		b: 1.0! !!HaloMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:29'!initialize	"initialize the state of the receiver"	super initialize.	""	growingOrRotating _ false.	simpleMode _ Preferences simpleHalosInForce ! !!HaloMorph methodsFor: 'stepping' stamp: 'aoy 2/17/2003 01:28'!step	| newBounds |	target ifNil: [^self].	newBounds := target isWorldMorph  				ifTrue: [target bounds]				ifFalse: [self localHaloBoundsFor: target renderedMorph].	newBounds = self bounds ifTrue: [^self].	newBounds extent = self bounds extent 		ifTrue: [^self position: newBounds origin].	growingOrRotating 		ifFalse: 			["adjust halo bounds if appropriate"			submorphs size > 1 ifTrue: [self addHandles].	"recreates full set with new bounds"			self bounds: newBounds]! !!HaloMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 13:46'!endInteraction	"Clean up after a user interaction with the a halo control"	| m |	self isMagicHalo: false.	"no longer"	self magicAlpha: 1.0.	(target isInWorld not or: [owner isNil]) ifTrue: [^self].	[target isFlexMorph and: [target hasNoScaleOrRotation]] whileTrue: 			[m := target firstSubmorph.			target removeFlexShell.			target := m].	self isInWorld 		ifTrue: 			["make sure handles show in front, even if flex shell added"			self comeToFront.			self addHandles].	(self valueOfProperty: #commandInProgress) doIfNotNil: 			[:cmd | 			self rememberCommand: cmd.			self removeProperty: #commandInProgress]! !!HaloMorph methodsFor: 'private' stamp: 'aoy 2/15/2003 21:10'!maybeCollapse: evt with: collapseHandle 	"Ask hand to collapse my target if mouse comes up in it."	evt hand obtainHalo: self.	self delete.	(collapseHandle containsPoint: evt cursorPoint) 		ifFalse: 			[			target addHalo: evt]		ifTrue: 			[			target collapse]! !!HaloMorph methodsFor: 'private' stamp: 'aoy 2/17/2003 01:27'!showDirectionHandles: wantToShow addHandles: needHandles 	directionArrowAnchor := wantToShow 				ifTrue: [target referencePositionInWorld	"not nil means show"]				ifFalse: [nil].	needHandles ifTrue: [self addHandles] ! !!HaloMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 19:04'!showingDirectionHandles	^directionArrowAnchor notNil! !!HaloMorph methodsFor: 'private' stamp: 'aoy 2/17/2003 01:28'!startGrow: evt with: growHandle 	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	| botRt |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.	botRt := target point: target bottomRight in: owner.	positionOffset := (self world viewBox containsPoint: botRt) 				ifTrue: [evt cursorPoint - botRt]				ifFalse: [0 @ 0]. 	self setProperty: #commandInProgress		toValue: ((Command new)				cmdWording: 'resizing';				undoTarget: target					selector: #setExtentFromHalo:					argument: target extent)! !!HandMorph methodsFor: 'cursor' stamp: 'dgd 2/21/2003 22:49'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset 		ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].	cursorOrNil isNil 		ifTrue: [temporaryCursor := temporaryCursorOffset := nil]		ifFalse: 			[temporaryCursor := cursorOrNil asCursorForm.			temporaryCursorOffset := temporaryCursor offset - hotSpotOffset].	bounds := self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		changed! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:43'!drawOn: aCanvas 	"Draw the hand itself (i.e., the cursor)."	| userPic |	temporaryCursor isNil 		ifTrue: [aCanvas paintImage: NormalCursor at: bounds topLeft]		ifFalse: [aCanvas paintImage: temporaryCursor at: bounds topLeft].	self hasUserInformation 		ifTrue: 			[aCanvas 				drawString: userInitials				at: self cursorBounds topRight + (0 @ 4)				font: nil				color: color.			(userPic := self userPicture) ifNotNil: 					[aCanvas paintImage: userPic at: self cursorBounds topRight + (0 @ 24)]]! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:44'!fullDrawOn: aCanvas 	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds roundCorners rounded |	self visible ifFalse: [^self].	(aCanvas isVisible: self fullBounds) ifFalse: [^self].	disableCaching := false.	disableCaching 		ifTrue: 			[self nonCachingFullDrawOn: aCanvas.			^self].	submorphs isEmpty 		ifTrue: 			[cacheCanvas := nil.			^self drawOn: aCanvas].	"just draw the hand itself"	subBnds := Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas isNil 		or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]]) 			ifTrue: 				["could not use caching due to translucency; do full draw"				self nonCachingFullDrawOn: aCanvas.				^self].	"--> begin rounded corners hack <---"	roundCorners := cachedCanvasHasHoles == false 				and: [submorphs size = 1 and: [submorphs first wantsRoundedCorners]].	roundCorners 		ifTrue: 			[rounded := submorphs first.			aCanvas asShadowDrawingCanvas translateBy: self shadowOffset				during: 					[:shadowCanvas | 					shadowCanvas roundCornersOf: rounded						during: 							[(subBnds areasOutside: (rounded boundsWithinCorners 										translateBy: self shadowOffset negated)) 								do: [:r | shadowCanvas fillRectangle: r color: Color black]]].			aCanvas roundCornersOf: rounded				during: 					[aCanvas 						drawImage: cacheCanvas form						at: subBnds origin						sourceRect: cacheCanvas form boundingBox].			^self drawOn: aCanvas	"draw the hand itself in front of morphs"].	"--> end rounded corners hack <---"	"draw the shadow"	aCanvas asShadowDrawingCanvas translateBy: self shadowOffset		during: 			[:shadowCanvas | 			cachedCanvasHasHoles 				ifTrue: 					["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]				ifFalse: 					["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) 						do: [:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles 		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: 			[aCanvas 				drawImage: cacheCanvas form				at: subBnds origin				sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas	"draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:46'!hasUserInformation	^self userInitials notEmpty or: [self userPicture notNil]! !!HandMorph methodsFor: 'drawing' stamp: 'nk 5/6/2003 20:55'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ temporaryCursor notNil				or: [ self hasUserInformation ]]])		ifTrue: [			"using the software cursor; hide the hardware one"			Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show].			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:49'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: 			[aCanvas drawImage: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			temporaryCursor ifNotNil: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset 						extent: savedPatch extent + self shadowOffset)				from: self.			Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].	"show hardware cursor"			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:49'!savePatchFrom: aCanvas 	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect := myBnds := self fullBounds.	savedPatch ifNotNil: 			[damageRect := myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch isNil or: [savedPatch extent ~= myBnds extent]) 		ifTrue: 			["allocate new patch form if needed"			savedPatch := aCanvas form allocateForm: myBnds extent].	aCanvas contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^damageRect! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:49'!updateCacheCanvas: aCanvas 	"Update the cached image of the morphs being held by this hand."	"Note: The following is an attempt to quickly get out if there's no change"	| subBnds rectList nPix |	subBnds := Rectangle merging: (submorphs collect: [:m | m fullBounds]).	rectList := damageRecorder invalidRectsFullBounds: subBnds.	damageRecorder reset.	(rectList isEmpty 		and: [cacheCanvas notNil and: [cacheCanvas extent = subBnds extent]]) 			ifTrue: [^self].	"Always check for real translucency -- can't be cached in a form"	self submorphsDo: 			[:m | 			m wantsToBeCachedByHand 				ifFalse: 					[cacheCanvas := nil.					cachedCanvasHasHoles := true.					^self]].	(cacheCanvas isNil or: [cacheCanvas extent ~= subBnds extent]) 		ifTrue: 			[cacheCanvas := (aCanvas allocateForm: subBnds extent) getCanvas.			cacheCanvas translateBy: subBnds origin negated				during: [:tempCanvas | self drawSubmorphsOn: tempCanvas].			self submorphsDo: 					[:m | 					(m areasRemainingToFill: subBnds) isEmpty 						ifTrue: [^cachedCanvasHasHoles := false]].			nPix := cacheCanvas form tallyPixelValues first.			"--> begin rounded corners hack <---"			cachedCanvasHasHoles := (nPix = 48 						and: [submorphs size = 1 and: [submorphs first wantsRoundedCorners]]) 							ifTrue: [false]							ifFalse: [nPix > 0].			"--> end rounded corners hack <---"			^self].	"incrementally update the cache canvas"	cacheCanvas translateBy: subBnds origin negated		during: 			[:cc | 			rectList do: 					[:r | 					cc clipBy: r						during: 							[:c | 							c fillColor: Color transparent.							self drawSubmorphsOn: c]]]! !!HandMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:43'!checkForMoreKeyboard	"Quick check for more keyboard activity -- Allows, eg, many characters	to be accumulated into a single replacement during type-in."	| evtBuf |	self flag: #arNote.	"Will not work if we don't examine event queue in Sensor"	evtBuf := (Sensor eventQueue ifNil: [^nil]) nextOrNilSuchThat: 					[:buf | 					buf first = EventTypeKeyboard and: [(buf fourth) = EventKeyChar]].	evtBuf ifNil: [^nil].	^self generateKeyboardEvent: evtBuf! !!HandMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:43'!cursorPoint	"Implemented for allowing embedded worlds in an event cycle to query a hand's position and get it in its coordinates. The same can be achieved by #point:from: but this is simply much more convenient since it will look as if the hand is in the lower world."	| pos |	pos := self position.	(ActiveWorld isNil or: [ActiveWorld == owner]) ifTrue: [^pos].	^ActiveWorld point: pos from: owner! !!HandMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:48'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	ActiveEvent ifNotNil: 			["Meaning that we were invoked from within an event response.		Make sure z-order is up to date"			self mouseOverHandler processMouseOver: lastMouseEvent].	hadAny := false.	[(evtBuf := Sensor nextEvent) isNil] whileFalse: 			[evt := nil.	"for unknown event types"			type := evtBuf first.			type = EventTypeMouse ifTrue: [evt := self generateMouseEvent: evtBuf].			type = EventTypeKeyboard 				ifTrue: [evt := self generateKeyboardEvent: evtBuf].			type = EventTypeDragDropFiles 				ifTrue: [evt := self generateDropFilesEvent: evtBuf].			"All other events are ignored"			(type ~= EventTypeDragDropFiles and: [evt isNil]) ifTrue: [^self].			evt isNil 				ifFalse: 					["Finally, handle it"					self handleEvent: evt.					hadAny := true.					"For better user feedback, return immediately after a mouse event has been processed."					evt isMouse ifTrue: [^self]]].	"note: if we come here we didn't have any mouse events"	mouseClickState notNil 		ifTrue: 			["No mouse events during this cycle. Make sure click states time out accordingly"			mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny 		ifFalse: 			["No pending events. Make sure z-order is up to date"			self mouseOverHandler processMouseOver: lastMouseEvent]! !!HandMorph methodsFor: 'focus handling' stamp: 'dgd 2/21/2003 22:48'!newMouseFocus: aMorph event: event 	aMorph isNil 		ifFalse: [targetOffset := event cursorPoint - aMorph position].	^self newMouseFocus: aMorph! !!HandMorph methodsFor: 'listeners' stamp: 'dgd 2/21/2003 22:48'!removeListener: anObject from: aListenerGroup 	"Remove anObject from the given listener group. Return the new group."	| listeners |	aListenerGroup ifNil: [^nil].	listeners := aListenerGroup.	listeners := listeners copyWithout: anObject.	listeners := listeners copyWithout: nil.	"obsolete entries"	listeners isEmpty ifTrue: [listeners := nil].	^listeners! !!HandMorph methodsFor: 'private events' stamp: 'dgd 2/22/2003 18:46'!generateDropFilesEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	"Note: This is still in an experimental phase and will need more work"	| position buttons modifiers stamp numFiles dragType |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	dragType := evtBuf third.	position := evtBuf fourth @ evtBuf fifth.	buttons := 0.	modifiers := evtBuf sixth.	buttons := buttons bitOr: (modifiers bitShift: 3).	numFiles := evtBuf seventh.	dragType = 4 		ifTrue: 			["e.g., drop"			owner borderWidth: 0.			^DropFilesEvent new 				setPosition: position				contents: numFiles				hand: self].	"the others are currently not handled by morphs themselves"	dragType = 1 		ifTrue: 			["experimental drag enter"			owner				borderWidth: 4;				borderColor: owner color negated].	dragType = 2 		ifTrue: 			["experimental drag move"			].	dragType = 3 		ifTrue: 			["experimental drag leave"			owner borderWidth: 0].	^nil! !!HandMorph methodsFor: 'private events' stamp: 'dgd 2/22/2003 18:47'!generateKeyboardEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type keyValue pressType stamp |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	keyValue := evtBuf third.	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := modifiers bitShift: 3.	^KeyboardEvent new 		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp! !!HandMorph methodsFor: 'private events' stamp: 'gm 2/28/2003 01:10'!generateMouseEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| position buttons modifiers type trail stamp oldButtons evtChanged |	evtBuf first = lastEventBuffer first 		ifTrue: 			["Workaround for Mac VM bug, *always* generating 3 events on clicks"			evtChanged := false.			3 to: evtBuf size				do: [:i | (lastEventBuffer at: i) = (evtBuf at: i) ifFalse: [evtChanged := true]].			evtChanged ifFalse: [^nil]].	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	position := evtBuf third @ evtBuf fourth.	buttons := evtBuf fifth.	modifiers := evtBuf sixth.	type := buttons = 0 		ifTrue: 			[lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]		ifFalse: 			[lastEventBuffer fifth = 0 						ifTrue: [#mouseDown]						ifFalse: [#mouseMove]].	buttons := buttons bitOr: (modifiers bitShift: 3).	oldButtons := lastEventBuffer fifth 				bitOr: (lastEventBuffer sixth bitShift: 3).	lastEventBuffer := evtBuf.	type == #mouseMove 		ifTrue: 			[trail := self mouseTrailFrom: evtBuf.			^MouseMoveEvent new 				setType: type				startPoint: trail first				endPoint: trail last				trail: trail				buttons: buttons				hand: self				stamp: stamp].	^MouseButtonEvent new 		setType: type		position: position		which: (oldButtons bitXor: buttons)		buttons: buttons		hand: self		stamp: stamp! !!HandMorph methodsFor: 'private events' stamp: 'dgd 2/22/2003 14:58'!mouseTrailFrom: currentBuf 	"Current event, a mouse event buffer, is about to be processed.  If there are other similar mouse events queued up, then drop them from the queue, and report the positions inbetween."	| nextEvent trail |	trail := WriteStream on: (Array new: 1).	trail nextPut: currentBuf third @ currentBuf fourth.	[(nextEvent := Sensor peekEvent) isNil] whileFalse: 			[nextEvent first = currentBuf first 				ifFalse: [^trail contents	"different event type"].			nextEvent fifth = currentBuf fifth 				ifFalse: [^trail contents	"buttons changed"].			nextEvent sixth = currentBuf sixth 				ifFalse: [^trail contents	"modifiers changed"].			"nextEvent is similar.  Remove it from the queue, and check the next."			nextEvent := Sensor nextEvent.			trail nextPut: nextEvent third @ nextEvent fourth].	^trail contents! !!HandMorphForReplay methodsFor: 'event handling' stamp: 'dgd 2/22/2003 13:25'!processEvents	"Play back the next event"	| evt hadMouse hadAny |	hadMouse := hadAny := false.	[(evt := recorder nextEventToPlay) isNil] whileFalse: 			[evt type == #EOF 				ifTrue: 					[recorder pauseIn: self world.					^self].			evt type == #startSound 				ifTrue: 					[evt argument play.					recorder synchronize.					^self].			evt isMouse ifTrue: [hadMouse := true].			(evt isMouse or: [evt isKeyboard]) 				ifTrue: 					[self handleEvent: (evt setHand: self) resetHandlerFields.					hadAny := true]].	(mouseClickState notNil and: [hadMouse not]) 		ifTrue: 			["No mouse events during this cycle. Make sure click states time out accordingly"			mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny 		ifFalse: 			["No pending events. Make sure z-order is up to date"			self mouseOverHandler processMouseOver: lastMouseEvent]! !!HandleMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:30'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 8 @ 8.	! !!HeadMorph methodsFor: 'furnitures' stamp: 'dgd 3/7/2003 14:31'!addRandomFurnitures	self perform: #(#yourself #addBeret #addHighHat #addAfroHair #addShortHair #addSpikyHair ) atRandom.	self perform: #(#yourself #yourself #addShortMustache ) atRandom! !!HeadMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:32'!defaultColor	"answer the default color/fill style for the receiver"	^ {Color		r: 0.258		g: 0.161		b: 0.0. Color		r: 0.452		g: 0.258		b: 0.0. Color		r: 0.516		g: 0.323		b: 0.0. Color		r: 1.0		g: 0.935		b: 0.645. Color		r: 1.0		g: 0.806		b: 0.548} atRandom! !!HeadMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:32'!initialize	"initialize the state of the receiver"	super initialize.	""	self face: FaceMorph new.	self extent: self face extent * (1.5 @ 1.7).	self face align: self face center with: self center + (0 @ self height // 10).	self addRandomFurnitures.	queue _ SharedQueue new! !!ImageMorph methodsFor: 'accessing' stamp: 'aoy 2/17/2003 01:17'!image: anImage 	self changed.	image := anImage depth = 1 				ifTrue: [ColorForm mappingWhiteToTransparentFrom: anImage]				ifFalse: [anImage]. 	super extent: image extent! !!ImageMorph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 20:01'!isOpaque	"Return true if the receiver is marked as being completely opaque"	^ self		valueOfProperty: #isOpaque		ifAbsent: [false]! !!LedCharacterMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!LedCharacterMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:55'!initialize	"initialize the state of the receiver"	super initialize.	""		highlighted _ false.	char _ 0! !!LedDigitMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color green! !!LedDigitMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:34'!initialize	"initialize the state of the receiver"	super initialize.	""	highlighted _ false.	digit _ 0 ! !!LedMorph methodsFor: 'accessing' stamp: 'dgd 2/14/2003 22:46'!color: aColor 	"set the receiver's color and the submorphs color"	super color: aColor.	self		submorphsDo: [:m | m color: aColor]! !!LedMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:36'!defaultColor"answer the default color/fill style for the receiver"	^ Color green! !!LedMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:36'!initialize"initialize the state of the receiver"	super initialize.""	flashing _ false.	flash _ false.	self scrollInit.	self digits: 2.	self value: 0! !!LedTimerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:36'!initialize"initialize the state of the receiver"	super initialize.""	counting _ false.	startSeconds _ Time totalSeconds! !!MPEGDisplayMorph methodsFor: 'accessing' stamp: 'jdl 3/28/2003 09:41'!volume: aNumber 	"Set the sound playback volume to the given level, between 0.0 and 1.0."	volume := aNumber asFloat.	volume := volume max: 0.0.	volume := volume min: 1.0.	soundTrack ifNotNil: [soundTrack volume: volume]! !!MPEGDisplayMorph methodsFor: 'commands' stamp: 'jdl 3/28/2003 09:26'!setFrameRate	"Ask the user to specify the desired frame rate."	| rateString |	rateString := FillInTheBlank request: 'Desired frames per second?'				initialAnswer: desiredFrameRate printString.	rateString isEmpty ifTrue: [^self].	desiredFrameRate := rateString asNumber asFloat.	desiredFrameRate := desiredFrameRate max: 0.1! !!MPEGDisplayMorph methodsFor: 'file open/close' stamp: 'gm 2/27/2003 23:50'!openFileNamed: mpegFileName 	"Try to open the MPEG file with the given name. Answer true if successful."	| e |	self closeFile.	(FileDirectory default fileExists: mpegFileName) 		ifFalse: 			[self inform: 'File not found: ' , mpegFileName.			^false].	(MPEGFile isFileValidMPEG: mpegFileName) 		ifTrue: [mpegFile := MPEGFile openFile: mpegFileName]		ifFalse: 			[(JPEGMovieFile isJPEGMovieFile: mpegFileName) 				ifTrue: [mpegFile := JPEGMovieFile new openFileNamed: mpegFileName]				ifFalse: 					[self inform: 'Not an MPEG or JPEG movie file: ' , mpegFileName.					^false]].	mpegFile fileHandle ifNil: [^false].	"initialize soundTrack"	soundTrack := mpegFile hasAudio 		ifTrue: [mpegFile audioPlayerForChannel: 1]		ifFalse: [nil].	mpegFile hasVideo 		ifTrue: 			["set screen size and display first frame"			desiredFrameRate := mpegFile videoFrameRate: 0.			soundTrack ifNotNil: 					["compute frame rate from length of audio track"					desiredFrameRate := (mpegFile videoFrames: 0) / soundTrack duration].			e := (mpegFile videoFrameWidth: 0) @ (mpegFile videoFrameHeight: 0).			frameBuffer := Form extent: e depth: (Display depth max: 16).			super extent: e.			self nextFrame]		ifFalse: 			["hide screen for audio-only files"			super extent: 250 @ 0]! !!MPEGDisplayMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:59'!createJPEGfromFolderOfFrames	"Create a new JPEG movie file from an folder of individual frames. Prompt the user for the folder and file names and the quality setting, then do the conversion."	| result folderName jpegFileName q frameRate |	result := StandardFileMenu oldFile.	result ifNil: [^self].	folderName := result directory pathName.	jpegFileName := FillInTheBlank request: 'New movie name?'.	jpegFileName isEmpty ifTrue: [^self].	(jpegFileName asLowercase endsWith: '.jmv') 		ifFalse: [jpegFileName := jpegFileName , '.jmv'].	result := FillInTheBlank request: 'Quality level (1 to 100)?'.	q := result ifNil: [50]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	result := FillInTheBlank request: 'Frame rate?'.	frameRate := result ifNil: [10]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile 		convertFromFolderOfFramesNamed: folderName		toJPEGMovieNamed: jpegFileName		frameRate: frameRate		quality: q! !!MPEGDisplayMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:59'!createJPEGfromMPEG	"Create a new JPEG movie file from an MPEG movie. Prompt the user for the file names and the quality setting, then do the conversion."	| result mpegFileName jpegFileName q |	result := StandardFileMenu oldFile.	result ifNil: [^self].	mpegFileName := result directory pathName , FileDirectory slash 				, result name.	jpegFileName := FillInTheBlank request: 'New movie name?'.	jpegFileName isEmpty ifTrue: [^self].	(jpegFileName asLowercase endsWith: '.jmv') 		ifFalse: [jpegFileName := jpegFileName , '.jmv'].	result := FillInTheBlank request: 'Quality level (1 to 100)?'.	q := result ifNil: [50]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile 		convertMPEGFileNamed: mpegFileName		toJPEGMovieNamed: jpegFileName		quality: q! !!MPEGDisplayMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:00'!createJPEGfromSqueakMovie	"Create a new JPEG movie file from an SqueakTime movie. Prompt the user for the file names and the quality setting, then do the conversion."	| result squeakMovieFileName jpegFileName q |	result := StandardFileMenu oldFile.	result ifNil: [^self].	squeakMovieFileName := result directory pathName , FileDirectory slash 				, result name.	jpegFileName := FillInTheBlank request: 'New movie name?'.	jpegFileName isEmpty ifTrue: [^self].	(jpegFileName asLowercase endsWith: '.jmv') 		ifFalse: [jpegFileName := jpegFileName , '.jmv'].	result := FillInTheBlank request: 'Quality level (1 to 100)?'.	q := result ifNil: [50]				ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile 		convertSqueakMovieNamed: squeakMovieFileName		toJPEGMovieNamed: jpegFileName		quality: q! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:40'!initialize	"initialize the state of the receiver"	super initialize.	""	trackPointer _ true.	magnification _ 2.	lastPos _ self sourcePoint.	self extent: 128 @ 128! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'dgd 2/21/2003 23:07'!magnifiedForm	"Answer the magnified form"	| srcRect form exclusion |	lastPos := self sourcePoint.	srcRect := self sourceRectFrom: lastPos.	((srcRect intersects: self bounds) and: [RecursionLock isNil]) 		ifTrue: 			[RecursionLock := self.			exclusion := self isRound ifTrue: [owner] ifFalse: [self].			form := self currentWorld 						patchAt: srcRect						without: exclusion						andNothingAbove: false.			RecursionLock := nil]		ifFalse: 			["cheaper method if the source is not occluded"			form := Display copy: srcRect].	"smooth if non-integer scale"	^form 		magnify: form boundingBox		by: magnification		smoothing: (magnification isInteger ifTrue: [1] ifFalse: [2])! !!MagnifierMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:07'!chooseMagnification	| result |	result := (SelectionMenu selections: #(1.5 2 4 8)) 				startUpWithCaption: 'Choose magnification(currently ' 						, magnification printString , ')'.	(result isNil or: [result = magnification]) ifTrue: [^self].	magnification := result.	self extent: self extent.	"round to new magnification"	self changed	"redraw even if extent wasn't changed"! !!FishEyeMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:39'!initialize"initialize the state of the receiver"	super initialize.""	"magnification should be always 1"	magnification _ 1.	d _ 1.3.	self extent: 130 @ 130! !!FishEyeMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:04'!transformY: aFloatArray 	| focus subArray dMaxY |	focus := srcExtent y asFloat / 2.	dMaxY := (aFloatArray first) <= focus 				ifTrue: [0.0 - focus]				ifFalse: [focus].	subArray := self 				g: (aFloatArray copyFrom: 1 to: gridNum x + 1)				max: dMaxY				focus: focus.	aFloatArray 		replaceFrom: 1		to: gridNum x + 1		with: subArray		startingAt: 1! !!MatrixTransformMorph methodsFor: 'drawing' stamp: 'dgd 2/16/2003 20:51'!visible: aBoolean 	"set the 'visible' attribute of the receiver to aBoolean"	self hasExtension		ifFalse: [aBoolean				ifTrue: [^ self]].	self assureExtension visible: aBoolean! !!MatrixTransformMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:38'!initialize"initialize the state of the receiver"	super initialize.""	transform _ MatrixTransform2x3 identity! !!FlashMorph methodsFor: 'copying' stamp: 'dgd 2/16/2003 19:58'!copyExtension	"Copy my extensions dictionary"	| copiedExtension |	self hasExtension		ifFalse: [^ self].	copiedExtension _ self extension copy.	copiedExtension removeOtherProperties.	self extension otherProperties		ifNotNil: [self extension otherProperties				associationsDo: [:assoc | copiedExtension setProperty: assoc key toValue: assoc value copy]].	self privateExtension: copiedExtension! !!FlashMorph methodsFor: 'copying' stamp: 'dgd 2/22/2003 14:24'!duplicate	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| dup player |	dup := super duplicate.	player := self flashPlayer.	dup transform: (self transformFrom: self world).	"If extracted from player and no default AA level is set use prefs"	(player notNil and: [self defaultAALevel isNil]) 		ifTrue: 			[Preferences extractFlashInHighQuality ifTrue: [dup defaultAALevel: 2].			Preferences extractFlashInHighestQuality ifTrue: [dup defaultAALevel: 4]].	^dup! !!FlashMorph methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 14:24'!aboutToBeGrabbedBy: aHand 	"Usually, FlashMorphs exist in a player. 	If they're grabbed and moved outside the player	they should keep their position."	| player |	super aboutToBeGrabbedBy: aHand.	player := self flashPlayer.	player ifNotNil: [player noticeRemovalOf: self].	self transform: (self transformFrom: self world).	"If extracted from player and no default AA level is set use prefs"	(player notNil and: [self defaultAALevel isNil]) 		ifTrue: 			[Preferences extractFlashInHighQuality ifTrue: [self defaultAALevel: 2].			Preferences extractFlashInHighestQuality ifTrue: [self defaultAALevel: 4]].	^self	"Grab me"! !!FlashMorph methodsFor: 'menu' stamp: 'gm 2/28/2003 00:16'!showCompressedSize	| size string |	size := self originalFileSize.	string := size = 0 		ifTrue: ['Compressed size: not available']		ifFalse: ['Compressed size: ' , size asStringWithCommas , ' bytes'].	self world primaryHand attachMorph: ((TextMorph new)				contents: string;				beAllFont: ScriptingSystem fontForTiles)! !!FlashMorphingMorph methodsFor: 'copying' stamp: 'dgd 2/21/2003 23:04'!updateReferencesUsing: aDictionary 	| srcMorph dstMorph |	super updateReferencesUsing: aDictionary.	srcMorph := submorphs at: submorphs size - 1.	dstMorph := submorphs last.	self removeAllMorphs.	self from: srcMorph to: dstMorph! !!FlashSpriteMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:38'!initialize"initialize the state of the receiver"	super initialize.""	playing _ false.	loadedFrames _ 0.	maxFrames _ 1.	frameNumber _ 1.	sounds _ Dictionary new.	actions _ Dictionary new.	labels _ Dictionary new.	stepTime _ 1.	useTimeSync _ true! !!FlashPlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor"answer the default color/fill style for the receiver"	^ Color white! !!FlashPlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:38'!initialize	"initialize the state of the receiver"	super initialize.	""		self loopFrames: true.	localBounds _ bounds.	activationKeys _ #().	activeMorphs _ SortedCollection new: 50.	activeMorphs		sortBlock: [:m1 :m2 | m1 depth > m2 depth].	progressValue _ ValueHolder new.	progressValue contents: 0.0.	self defaultAALevel: 2.	self deferred: true! !!MenuLineMorph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:52'!minHeight"answer the receiver's minHeight"	^ 2! !!MenuLineMorph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:54'!minWidth"answer the receiver's minWidth"	^ 10! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:56'!actorState	"answer the redeiver's actorState"	^ actorState ! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:53'!actorState: anActorState "change the receiver's actorState"	actorState _ anActorState! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:51'!balloonTextSelector: aSymbol 	"change the receiver's balloonTextSelector"	balloonTextSelector _ aSymbol! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:51'!eventHandler	"answer the receiver's eventHandler"	^ eventHandler ! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:57'!externalName: aString 	"change the receiver's externalName"	externalName _ aString! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:37'!isPartsDonor	"answer whether the receiver is PartsDonor"	^ isPartsDonor! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:40'!isPartsDonor: aBoolean 	"change the receiver's isPartDonor property"	isPartsDonor _ aBoolean! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:38'!locked	"answer whether the receiver is Locked"	^ locked! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:48'!locked: aBoolean 	"change the receiver's locked property"	locked _ aBoolean! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:42'!player	"answer the receiver's player"	^ player! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:53'!player: anObject 	"change the receiver's player"	player _ anObject ! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:47'!sticky: aBoolean 	"change the receiver's sticky property"	sticky _ aBoolean! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:41'!visible	"answer whether the receiver is visible"	^ visible! !!MorphExtension methodsFor: 'accessing - layout properties' stamp: 'dgd 2/22/2003 13:32'!layoutFrame: aLayoutFrame 	aLayoutFrame isNil		ifTrue: [self removeProperty: #layoutFrame]		ifFalse: [self setProperty: #layoutFrame toValue: aLayoutFrame]! !!MorphExtension methodsFor: 'accessing - layout properties' stamp: 'dgd 2/22/2003 13:32'!layoutPolicy: aLayoutPolicy 	aLayoutPolicy isNil		ifTrue: [self removeProperty: #layoutPolicy]		ifFalse: [self setProperty: #layoutPolicy toValue: aLayoutPolicy]! !!MorphExtension methodsFor: 'accessing - layout properties' stamp: 'dgd 2/22/2003 13:32'!layoutProperties: newProperties 	"Return the current layout properties associated with the receiver"	newProperties isNil		ifTrue: [self removeProperty: #layoutProperties]		ifFalse: [self setProperty: #layoutProperties toValue: newProperties]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:05'!assureOtherProperties	"creates an otherProperties for the receiver if needed"	self hasOtherProperties		ifFalse: [self initializeOtherProperties].	^ self otherProperties! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:03'!hasOtherProperties	"answer whether the receiver has otherProperties"	^ self otherProperties notNil! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:15'!hasProperty: aSymbol 	"Answer whether the receiver has the property named aSymbol"	| property |	self hasOtherProperties		ifFalse: [^ false].	property _ self otherProperties				at: aSymbol				ifAbsent: [].	property isNil		ifTrue: [^ false].	property == false		ifTrue: [^ false].	^ true! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:12'!initializeOtherProperties	"private - initializes the receiver's otherProperties"	self privateOtherProperties: IdentityDictionary new! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:04'!otherProperties	"answer the receiver's otherProperties"	^ otherProperties! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:20'!privateOtherProperties: anIndentityDictionary 	"private - change the receiver's otherProperties"	otherProperties _ anIndentityDictionary ! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:12'!removeOtherProperties	"Remove the 'other' properties"	self privateOtherProperties: nil! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:17'!removeProperty: aSymbol 	"removes the property named aSymbol if it exists"	self hasOtherProperties		ifFalse: [^ self].	self otherProperties		removeKey: aSymbol		ifAbsent: [].	self otherProperties isEmpty		ifTrue: [self removeOtherProperties]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:49'!setProperty: aSymbol toValue: abObject 	"change the receiver's property named aSymbol to anObject"	self assureOtherProperties at: aSymbol put: abObject! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/22/2003 13:32'!sortedPropertyNames	"answer the receiver's property names in a sorted way"	| props |	props := WriteStream on: (Array new: 10).	locked == true ifTrue: [props nextPut: #locked].	visible == false ifTrue: [props nextPut: #visible].	sticky == true ifTrue: [props nextPut: #sticky].	balloonText isNil ifFalse: [props nextPut: #balloonText].	balloonTextSelector isNil ifFalse: [props nextPut: #balloonTextSelector].	externalName isNil ifFalse: [props nextPut: #externalName].	isPartsDonor == true ifTrue: [props nextPut: #isPartsDonor].	actorState isNil ifFalse: [props nextPut: #actorState].	player isNil ifFalse: [props nextPut: #player].	eventHandler isNil ifFalse: [props nextPut: #eventHandler].	self hasOtherProperties 		ifTrue: [self otherProperties associationsDo: [:a | props nextPut: a key]].	^props contents sort: [:s1 :s2 | s1 <= s2]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:00'!valueOfProperty: aSymbol "answer the value of the receiver's property named aSymbol"	^ self		valueOfProperty: aSymbol		ifAbsent: []! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:09'!valueOfProperty: aSymbol ifAbsent: aBlock 	"if the receiver possesses a property of the given name, answer  	its value. If not then evaluate aBlock and answer the result of  	this block evaluation"	self hasOtherProperties		ifFalse: [^ aBlock value].	^ self otherProperties		at: aSymbol		ifAbsent: [^ aBlock value]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:28'!valueOfProperty: aSymbol ifAbsentPut: aBlock 	"If the receiver possesses a property of the given name, answer  	its value. If not, then create a property of the given name, give 	it the value obtained by evaluating aBlock, then answer that  	value"	^self assureOtherProperties at: aSymbol ifAbsentPut: aBlock! !!MorphExtension methodsFor: 'copying' stamp: 'dgd 2/22/2003 13:32'!updateReferencesUsing: aDictionary 	"Update intra-morph references within a composite morph that  	has been copied. For example, if a button refers to morph X in  	the orginal  	composite then the copy of that button in the new composite  	should refer to  	the copy of X in new composite, not the original X. This default  	implementation updates the contents of any morph-bearing slot."	| old |	eventHandler isNil 		ifFalse: 			[self eventHandler: self eventHandler copy.			1 to: self eventHandler class instSize				do: 					[:i | 					old := eventHandler instVarAt: i.					old isMorph 						ifTrue: [eventHandler instVarAt: i put: (aDictionary at: old ifAbsent: [old])]]].	self hasOtherProperties 		ifTrue: 			[""			self otherProperties associationsDo: 					[:assn | 					assn value: (aDictionary at: assn value ifAbsent: [assn value])]]! !!MorphExtension methodsFor: 'copying' stamp: 'dgd 2/16/2003 21:11'!veryDeepFixupWith: deepCopier 	"If target and arguments fields were weakly copied, fix them  	here. If they were in the tree being copied, fix them up,  	otherwise point to the originals!!!!"	| list |	super veryDeepFixupWith: deepCopier.	self hasOtherProperties		ifTrue: [""			list _ self copyWeakly.			"Properties whose values are only copied weakly"			"replace those values if they were copied via another  			path"			list				do: [:pp | ""					(self otherProperties						at: pp						ifAbsent: [])						ifNotNil: [""							self otherProperties								at: pp								put: (deepCopier references										at: (self otherProperties at: pp)										ifAbsent: [self otherProperties at: pp])]]]! !!MorphExtension methodsFor: 'copying' stamp: 'dgd 2/16/2003 21:13'!veryDeepInner: deepCopier 	"Copy all of my instance variables. Some need to be not copied at 	all, but shared. This is special code for the dictionary. See  	DeepCopier."	| list values vv |	super veryDeepInner: deepCopier.	locked _ locked veryDeepCopyWith: deepCopier.	visible _ visible veryDeepCopyWith: deepCopier.	sticky _ sticky veryDeepCopyWith: deepCopier.	balloonText _ balloonText veryDeepCopyWith: deepCopier.	balloonTextSelector _ balloonTextSelector veryDeepCopyWith: deepCopier.	externalName _ externalName veryDeepCopyWith: deepCopier.	isPartsDonor _ isPartsDonor veryDeepCopyWith: deepCopier.	actorState _ actorState veryDeepCopyWith: deepCopier.	player _ player veryDeepCopyWith: deepCopier.	"Do copy the player of this morph"	eventHandler _ eventHandler veryDeepCopyWith: deepCopier.	"has its own restrictions"	self hasOtherProperties		ifTrue: [""			self privateOtherProperties: self otherProperties copy.			list _ self copyWeakly.			"Properties whose values are only copied weakly"			values _ list						collect: [:pp | 							vv _ self otherProperties										at: pp										ifAbsent: [].							vv								ifNotNil: [self otherProperties at: pp put: nil].							"zap it"							vv].			self				privateOtherProperties: (self otherProperties veryDeepCopyWith: deepCopier).			1				to: list size				do: [:ii | "put old values back"					(values at: ii)						ifNotNil: [self otherProperties								at: (list at: ii)								put: (values at: ii)]]]! !!MorphExtension methodsFor: 'object fileIn' stamp: 'dgd 2/16/2003 21:06'!convertProperty: aSymbol toValue: anObject 	"These special cases move old properties into named fields of the 	extension"	aSymbol == #locked		ifTrue: [^ locked _ anObject].	aSymbol == #visible		ifTrue: [^ visible _ anObject].	aSymbol == #sticky		ifTrue: [^ sticky _ anObject].	aSymbol == #balloonText		ifTrue: [^ balloonText _ anObject].	aSymbol == #balloonTextSelector		ifTrue: [^ balloonTextSelector _ anObject].	aSymbol == #actorState		ifTrue: [^ actorState _ anObject].	aSymbol == #player		ifTrue: [^ player _ anObject].	aSymbol == #name		ifTrue: [^ externalName _ anObject].	"*renamed*"	aSymbol == #partsDonor		ifTrue: [^ isPartsDonor _ anObject].	"*renamed*"	self assureOtherProperties at: aSymbol put: anObject! !!MorphExtension methodsFor: 'other' stamp: 'dgd 2/16/2003 21:09'!inspectElement	"Create and schedule an Inspector on the otherProperties and the 	named properties."	| key obj |	key _ (SelectionMenu selections: self sortedPropertyNames)				startUpWithCaption: 'Inspect which property?'.	key		ifNil: [^ self].	obj _ self otherProperties				at: key				ifAbsent: ['nOT a vALuE'].	obj = 'nOT a vALuE'		ifTrue: [(self perform: key) inspect			"named properties"]		ifFalse: [obj inspect]! !!MorphExtension methodsFor: 'other' stamp: 'dgd 2/16/2003 21:14'!isDefault	"Return true if the receiver is a default and can be omitted"	locked == true		ifTrue: [^ false].	visible == false		ifTrue: [^ false].	sticky == true		ifTrue: [^ false].	balloonText isNil		ifFalse: [^ false].	balloonTextSelector isNil		ifFalse: [^ false].	externalName isNil		ifFalse: [^ false].	isPartsDonor == true		ifTrue: [^ false].	actorState isNil		ifFalse: [^ false].	player isNil		ifFalse: [^ false].	eventHandler isNil		ifFalse: [^ false].	self hasOtherProperties		ifTrue: [self otherProperties isEmpty				ifFalse: [^ false]].	^ true! !!MorphExtension methodsFor: 'printing' stamp: 'dgd 2/16/2003 21:58'!printOn: aStream 	"Append to the argument, aStream, a sequence of characters that 	identifies the receiver." 	super printOn: aStream.	aStream nextPutAll: ' ' , self identityHashPrintString.	locked == true		ifTrue: [aStream nextPutAll: ' [locked] '].	visible == false		ifTrue: [aStream nextPutAll: '[not visible] '].	sticky == true		ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText		ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector		ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ' , balloonTextSelector printString , '] '].	externalName		ifNotNil: [aStream nextPutAll: ' [externalName = ' , externalName , ' ] '].	isPartsDonor == true		ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player		ifNotNil: [aStream nextPutAll: ' [player = ' , player printString , '] '].	eventHandler		ifNotNil: [aStream nextPutAll: ' [eventHandler = ' , eventHandler printString , '] '].	self hasOtherProperties		ifTrue: [self otherProperties isEmpty				ifFalse: [^ self]].	aStream nextPutAll: ' [other: '.	self otherProperties		keysDo: [:aKey | aStream nextPutAll: ' (' , aKey , ' -> ' , (self otherProperties at: aKey) printString , ')'].	aStream nextPut: $]! !!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'aoy 2/17/2003 01:26'!updateSubWindowExtent	"If this MorphWorldView represents a single Morphic SystemWindow, then update that window to match the size of the WorldView."	| numMorphs subWindow scrollBarWidth |	numMorphs := model submorphs size.	"(Allow for the existence of an extra NewHandleMorph (for resizing).)"	(numMorphs = 0 or: [numMorphs > 2]) ifTrue: [^self].	subWindow := model submorphs detect: [:ea | ea respondsTo: #label]				ifNone: [^self].	superView label = subWindow label ifFalse: [^self].	scrollBarWidth := (Preferences valueOfFlag: #inboardScrollbars) 				ifTrue: [0]				ifFalse: [14]. 	subWindow position: model position + (scrollBarWidth @ -16).	"adjust for WiW changes"	subWindow extent: model extent - (scrollBarWidth @ -16).	subWindow isActive ifFalse: [subWindow activate]! !!MorphicModel methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color yellow! !!MorphicModel methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 corner: 200 @ 100! !!MorphicModel methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!MorphicModel methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:47'!initialize	"initialize the state of the receiver"	super initialize.""	open _ false! !!MorphicModel methodsFor: 'naming' stamp: 'dgd 2/21/2003 23:00'!choosePartName	"When I am renamed, get a slot, make default methods, move any existing methods.  ** Does not clean up old inst var name or methods**  "	| old |	old := slotName.	super choosePartName.	slotName ifNil: [^self].	"user chose bad slot name"	self model: self world model slotName: slotName.	old isNil		ifTrue: [self compilePropagationMethods]		ifFalse: [self copySlotMethodsFrom: old]	"old ones not erased!!"! !!MorphicModel methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 18:51'!allKnownNames	"Return a list of all known names based on the scope of the receiver.  If the receiver is a member of a uniclass, incorporate the original 1997 logic that queries the known names of the values of all the instance variables."	| superNames |	superNames := super allKnownNames.	"gather them from submorph tree"	^self belongsToUniClass 		ifTrue: 			[superNames , (self instanceVariableValues 						select: [:e | e notNil and: [e knownName notNil]]						thenCollect: [:e | e knownName])]		ifFalse: [superNames]! !!MorphicModel methodsFor: 'submorphs-add/remove' stamp: 'gm 2/22/2003 12:51'!delete	(model isMorphicModel) ifFalse: [^super delete].	slotName ifNotNil: 			[(PopUpMenu confirm: 'Shall I remove the slot ' , slotName 						, 'along with all associated methods?') 				ifTrue: 					[(model class selectors select: [:s | s beginsWith: slotName]) 						do: [:s | model class removeSelector: s].					(model class instVarNames includes: slotName) 						ifTrue: [model class removeInstVarName: slotName]]				ifFalse: 					[(PopUpMenu 						confirm: '...but should I at least dismiss this morph?[choose no to leave everything unchanged]') 							ifFalse: [^self]]].	super delete! !!ComponentLikeModel methodsFor: 'naming' stamp: 'dgd 2/21/2003 23:01'!choosePartName	"When I am renamed, get a slot, make default methods, move any existing methods."	| old |	(self pasteUpMorph model isKindOf: Component) 		ifTrue: 			[self knownName ifNil: [^self nameMeIn: self pasteUpMorph]				ifNotNil: [^self renameMe]].	old := slotName.	super choosePartName.	slotName ifNil: [^self].	"user chose bad slot name"	self model: self world model slotName: slotName.	old isNil 		ifTrue: [self compilePropagationMethods]		ifFalse: [self copySlotMethodsFrom: old]	"old ones not erased!!"! !!ComponentLikeModel methodsFor: 'submorphs-add/remove' stamp: 'gm 2/22/2003 13:14'!delete	"Delete the receiver.  Possibly put up confirming dialog.  Abort if user changes mind"	(model isKindOf: Component) ifTrue: [^self deleteComponent].	(model isMorphicModel) ifFalse: [^super delete].	slotName ifNotNil: 			[(PopUpMenu confirm: 'Shall I remove the slot ' , slotName 						, '	along with all associated methods?') 				ifTrue: 					[(model class selectors select: [:s | s beginsWith: slotName]) 						do: [:s | model class removeSelector: s].					(model class instVarNames includes: slotName) 						ifTrue: [model class removeInstVarName: slotName]]				ifFalse: 					[(PopUpMenu 						confirm: '...but should I at least dismiss this morph?	[choose no to leave everything unchanged]') 							ifFalse: [^self]]].	super delete! !!MorphicModel class methodsFor: 'prototype access' stamp: 'gm 2/22/2003 19:13'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype _ nil. ^ self].	prototype _ aMorph veryDeepCopy.	(prototype isMorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !!MouseOverHandler methodsFor: 'event handling' stamp: 'dgd 2/21/2003 23:00'!processMouseOver: anEvent 	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus evt |	hand := anEvent hand.	leftMorphs := mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs := WriteStream on: (Array new: leftMorphs size).	enteredMorphs := WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs isEmpty and: [enteredMorphs position = 0]) 		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].	focus := hand mouseFocus.	"Send #mouseLeave as appropriate"	evt := anEvent asMouseLeave.	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"	leftMorphs size > 1 		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].	leftMorphs do: 			[:m | 			(m == focus or: [m hasOwner: focus]) 				ifTrue: 					[localEvt := evt transformedBy: (m transformedFrom: hand).					m handleEvent: localEvt]				ifFalse: [overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	evt := anEvent asMouseEnter.	enteredMorphs ifNil: 			["inform: was called in handleEvent:"			^leftMorphs := enteredMorphs := overMorphs := nil].	enteredMorphs := enteredMorphs contents.	enteredMorphs reverseDo: 			[:m | 			(m == focus or: [m hasOwner: focus]) 				ifTrue: 					[localEvt := evt transformedBy: (m transformedFrom: hand).					m handleEvent: localEvt]].	"And remember the over list"	overMorphs ifNil: 			["inform: was called in handleEvent:"			^leftMorphs := enteredMorphs := overMorphs := nil].	mouseOverMorphs := overMorphs contents.	leftMorphs := enteredMorphs := overMorphs := nil! !!MovieFrameSyncMorph methodsFor: 'piano rolls' stamp: 'dgd 2/21/2003 22:58'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick 	"Set frame number and milliseconds since start in case of drift"	| next |	moviePlayerMorph frameNumber: frameNumber		msSinceStart: scorePlayer millisecondsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next := self nextSyncEventAfter: index inTrack: track) isNil 		ifFalse: 			[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0 						/ (next morph frameNumber - self frameNumber)]! !!MovieClipStartMorph methodsFor: 'piano rolls' stamp: 'dgd 2/22/2003 14:09'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime 	"This code handles both the start and end morphs."	| startX endX h delta |	self startTime > rightTime 		ifTrue: [^self	"Start time has not come into view."].	self endTime < leftTime ifTrue: [^self	"End time has passed out of view."].	startX := pianoRoll xForTime: self startTime.	endX := pianoRoll xForTime: self endTime.	h := self colorMargin.	"Height of highlight bar over thumbnails."	morphList add: (self align: self bottomLeft				with: startX @ (pianoRoll bottom - pianoRoll borderWidth - h)).	morphList 		add: (endMorph align: endMorph bounds rightCenter with: endX @ self center y).	morphList add: (self colorMorph 				bounds: (self topLeft - (0 @ h) corner: endMorph right @ (self bottom + h))).	(soundTrackMorph isNil and: [moviePlayerMorph scorePlayer isNil]) 		ifFalse: 			["Wants a sound track"			(soundTrackMorph isNil or: [pianoRoll timeScale ~= soundTrackTimeScale]) 				ifTrue: 					["Needs a new sound track"					self buildSoundTrackMorphFor: pianoRoll].			morphList add: (soundTrackMorph align: soundTrackMorph bottomLeft						with: colorMorph topLeft).			self soundTrackOnBottom 				ifTrue: 					[soundTrackMorph align: soundTrackMorph bottomLeft with: self bottomLeft.					delta := 0 @ self soundTrackHeight.					self position: self position - delta.					endMorph position: endMorph position - delta.					colorMorph position: colorMorph position - delta]]! !!MovieClipStartMorph methodsFor: 'piano rolls' stamp: 'dgd 2/22/2003 14:09'!resetFrom: scorePlayer 	(movieClipPlayer cueMorph isNil 		or: [self startTime < movieClipPlayer cueMorph startTime]) 			ifTrue: 				[movieClipPlayer					openFileNamed: movieClipFileName						withScorePlayer: soundTrackPlayerReady copy						andPlayFrom: frameNumber;					setCueMorph: self;					step;					pauseFrom: scorePlayer]! !!MovieMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 18:47'!drawOn: aCanvas 	| frame |	frame := self currentFrame.	frame notNil 		ifTrue: [^frame drawOn: aCanvas]		ifFalse: [^super drawOn: aCanvas]! !!MovieMorph methodsFor: 'geometry testing' stamp: 'dgd 2/22/2003 18:48'!containsPoint: p 	| frame |	frame := self currentFrame.	^ (frame notNil and: [playMode = #stop]) 		ifTrue: [frame containsPoint: p]		ifFalse: [super containsPoint: p]! !!MovieMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 1		g: 0		b: 1! !!MovieMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:47'!initialize	"initialize the state of the receiver"	super initialize.	""		playMode _ #stop.	"#stop, #playOnce, or #loop"	msecsPerFrame _ 200.	rotationDegrees _ 0.	scalePoint _ 1.0 @ 1.0.	frameList _ EmptyArray.	currentFrameIndex _ 1.	dwellCount _ 0! !!MovieMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:47'!editDrawing	| frame |	frame := self currentFrame.	frame notNil 		ifTrue: [frame editDrawingIn: self pasteUpMorph forBackground: false]! !!MovieMorph methodsFor: 'private' stamp: 'jdl 3/28/2003 08:03'!currentFrame	frameList isEmpty ifTrue: [^nil].     currentFrameIndex := currentFrameIndex min: (frameList size).     currentFrameIndex := currentFrameIndex max: 1.	^frameList at: currentFrameIndex! !!MovieMorph methodsFor: 'private' stamp: 'jdl 3/28/2003 08:08'!setFrame: newFrameIndex 	| oldFrame p newFrame |	oldFrame := self currentFrame.	oldFrame ifNil: [^self].	self changed.	p := oldFrame referencePosition.	currentFrameIndex := newFrameIndex.     currentFrameIndex :=  currentFrameIndex min: (frameList size). 	currentFrameIndex := currentFrameIndex max: 1.	newFrame := frameList at: currentFrameIndex.	newFrame referencePosition: p.	oldFrame delete.	self addMorph: newFrame.	dwellCount := newFrame framesToDwell.	self layoutChanged.	self changed! !!MovingEyeMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:42'!defaultColor"answer the default color/fill style for the receiver"	^ Color black! !!MovingEyeMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:42'!initialize	"initialize the state of the receiver"	super initialize.	""	inner _ EllipseMorph new.	inner color: self color.	inner extent: (self extent * (1.0 @ 1.0 - IrisSize)) asIntegerPoint.	inner borderColor: self color.	inner borderWidth: 0.""	iris _ EllipseMorph new.	iris color: Color white.	iris extent: (self extent * IrisSize) asIntegerPoint.""	self addMorphCentered: inner.	inner addMorphCentered: iris.""	self extent: 26 @ 33! !!NewHandleMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:29'!initialize"initialize the state of the receiver"	super initialize.""	waitingForClickInside _ true.	Preferences noviceMode		ifTrue: [self setBalloonText: 'stretch']! !!NewParagraph methodsFor: 'composition' stamp: 'jm 2/25/2003 16:20'!OLDcomposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY 	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR maybeSlide sliding bottom priorIndex priorLine |	charIndex := start.	lines := lineColl.	lineY := startingY.	lineHeightGuess := textStyle lineGrid.	maxRightX := container left.	maybeSlide := stop < text size and: [container isMemberOf: Rectangle].	sliding := false.	priorIndex := 1.	bottom := container bottom.	scanner := CompositionScanner new text: text textStyle: textStyle.	firstLine := true.	[charIndex <= text size and: [lineY + lineHeightGuess <= bottom]] 		whileTrue: 			[sliding 				ifTrue: 					["Having detected the end of rippling recoposition, we are only sliding old lines"					priorIndex < priorLines size 						ifTrue: 							["Adjust and re-use previously composed line"							priorIndex := priorIndex + 1.							priorLine := (priorLines at: priorIndex) slideIndexBy: delta										andMoveTopTo: lineY.							lineColl addLast: priorLine.							lineY := priorLine bottom.							charIndex := priorLine last + 1]						ifFalse: 							["There are no more priorLines to slide."							sliding := maybeSlide := false]]				ifFalse: 					[lineHeight := lineHeightGuess.					saveCharIndex := charIndex.					hitCR := false.					row := container rectanglesAt: lineY height: lineHeight.					1 to: row size						do: 							[:i | 							(charIndex <= text size and: [hitCR not]) 								ifTrue: 									[line := scanner 												composeFrom: charIndex												inRectangle: (row at: i)												firstLine: firstLine												leftSide: i = 1												rightSide: i = row size.									lines addLast: line.									(text at: line last) = Character cr ifTrue: [hitCR := true].									lineHeight := lineHeight max: line lineHeight.	"includes font changes"									charIndex := line last + 1]].					lineY := lineY + lineHeight.					row notEmpty 						ifTrue: 							[lineY > bottom 								ifTrue: 									["Oops -- the line is really too high to fit -- back out"									charIndex := saveCharIndex.									row do: [:r | lines removeLast]]								ifFalse: 									["It's OK -- the line still fits."									maxRightX := maxRightX max: scanner rightX.									1 to: row size - 1										do: 											[:i | 											"Adjust heights across row if necess"											(lines at: lines size - row size + i) lineHeight: lines last lineHeight												baseline: lines last baseline].									charIndex > text size 										ifTrue: 											["end of text"											hitCR 												ifTrue: 													["If text ends with CR, add a null line at the end"													lineY + lineHeightGuess <= container bottom 														ifTrue: 															[row := container rectanglesAt: lineY height: lineHeightGuess.															row notEmpty 																ifTrue: 																	[line := (TextLine 																				start: charIndex																				stop: charIndex - 1																				internalSpaces: 0																				paddingWidth: 0)																				rectangle: row first;																				lineHeight: lineHeightGuess baseline: textStyle baseline.																	lines addLast: line]]].											lines := lines asArray.											^maxRightX].									firstLine := false]].											(maybeSlide and: [charIndex > stop]) 						ifTrue: 							["Check whether we are now in sync with previously composed lines"														[priorIndex < priorLines size 								and: [(priorLines at: priorIndex) first < (charIndex - delta)]] 									whileTrue: [priorIndex := priorIndex + 1].							(priorLines at: priorIndex) first = (charIndex - delta) 								ifTrue: 									["Yes -- next line will have same start as prior line."									priorIndex := priorIndex - 1.									maybeSlide := false.									sliding := true]								ifFalse: 									[priorIndex = priorLines size 										ifTrue: 											["Weve reached the end of priorLines,								so no use to keep looking for lines to slide."											maybeSlide := false]]]]].	firstLine 		ifTrue: 			["No space in container or empty text"			line := (TextLine 						start: start						stop: start - 1						internalSpaces: 0						paddingWidth: 0)						rectangle: (container topLeft extent: 0 @ lineHeightGuess);						lineHeight: lineHeightGuess baseline: textStyle baseline.			lines := Array with: line]		ifFalse: [self fixLastWithHeight: lineHeightGuess].	"end of container"	lines := lines asArray.	^maxRightX! !!NewParagraph methodsFor: 'display' stamp: 'gm 2/28/2003 01:40'!displaySelectionInLine: line on: aCanvas 	| leftX rightX w caretColor |	selectionStart ifNil: [^self].	"No selection"	selectionStart = selectionStop 		ifTrue: 			["Only show caret on line where clicked"			selectionStart textLine ~= line ifTrue: [^self]]		ifFalse: 			["Test entire selection before or after here"			(selectionStop stringIndex < line first 				or: [selectionStart stringIndex > (line last + 1)]) ifTrue: [^self].	"No selection on this line"			(selectionStop stringIndex = line first 				and: [selectionStop textLine ~= line]) ifTrue: [^self].	"Selection ends on line above"			(selectionStart stringIndex = (line last + 1) 				and: [selectionStop textLine ~= line]) ifTrue: [^self]].	"Selection begins on line below"	leftX := (selectionStart stringIndex < line first 				ifTrue: [line ]				ifFalse: [selectionStart ])left.	rightX := (selectionStop stringIndex > (line last + 1) or: 					[selectionStop stringIndex = (line last + 1) 						and: [selectionStop textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [selectionStop left].	selectionStart = selectionStop 		ifTrue: 			[rightX := rightX + 1.			w := self caretWidth.			caretColor := self insertionPointColor.			1 to: w				do: 					[:i | 					"Draw caret triangles at top and bottom"					aCanvas fillRectangle: ((leftX - w + i - 1) @ (line top + i - 1) 								extent: ((w - i) * 2 + 3) @ 1)						color: caretColor.					aCanvas fillRectangle: ((leftX - w + i - 1) @ (line bottom - i) 								extent: ((w - i) * 2 + 3) @ 1)						color: caretColor].			aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom)				color: caretColor]		ifFalse: 			[aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom)				color: self selectionColor]! !!Canvas methodsFor: 'drawing' stamp: 'aoy 2/15/2003 21:41'!line: pt1 to: pt2 width: width color: color1 dashLength: s1 secondColor: color2 secondDashLength: s2 startingOffset: startingOffset 	"Draw a line using the given width, colors and dash lengths.	Originally written by Stephan Rudlof; tweaked by Dan Ingalls	to use startingOffset for sliding offset as in 'ants' animations.	Returns the sum of the starting offset and the length of this line."	| dist deltaBig colors nextPhase segmentOffset phase segmentLength startPoint distDone endPoint segLens |	dist := pt1 dist: pt2.	dist = 0 ifTrue: [^startingOffset].	s1 = 0 & (s2 = 0) ifTrue: [^startingOffset].	deltaBig := pt2 - pt1.	colors := { 				color1.				color2}.	segLens := { 				s1 asFloat.				s2 asFloat}.	nextPhase := { 				2.				1}.	"Figure out what phase we are in and how far, given startingOffset."	segmentOffset := startingOffset \\ (s1 + s2).	segmentLength := segmentOffset < s1 		ifTrue: 			[phase := 1.			s1 - segmentOffset]		ifFalse: 			[phase := 2.			 s1 + s2 - segmentOffset].	startPoint := pt1.	distDone := 0.0.	[distDone < dist] whileTrue: 			[segmentLength := segmentLength min: dist - distDone.			endPoint := startPoint + (deltaBig * segmentLength / dist).			self 				line: startPoint truncated				to: endPoint truncated				width: width				color: (colors at: phase).			distDone := distDone + segmentLength.			phase := nextPhase at: phase.			startPoint := endPoint.			segmentLength := segLens at: phase].	^startingOffset + dist! !!Canvas methodsFor: 'drawing-support' stamp: 'gm 2/22/2003 14:53'!cache: aRectangle using: aCache during: aBlock 	"Cache the execution of aBlock by the given cache.	Note: At some point we may want to actually *create* the cache here;		for now we're only using it."	(aCache notNil 		and: [(aCache isForm) and: [aCache extent = aRectangle extent]]) 			ifTrue: [^self paintImage: aCache at: aRectangle origin].	aBlock value: self! !!PDA methodsFor: 'date' stamp: 'aoy 2/15/2003 21:33'!setDate: aDate fromButton: aButton down: down 	dateButtonPressed ifNotNil: [dateButtonPressed setSwitchState: false].	dateButtonPressed := down 				ifTrue:  					[self selectDate: aDate.					aButton]				ifFalse: 					[self selectDate: nil.					nil].	self currentItem: nil.	aButton ifNotNil: 			[aButton owner owner highlightToday	"ugly hack to restore highlight for today"]! !!PDA methodsFor: 'initialization' stamp: 'dgd 2/22/2003 13:27'!loadDatabase	| aName aFileStream list |	aName _ Utilities chooseFileWithSuffixFromList: #('.pda' '.pda.gz' ) withCaption: 'Choose a file to load'.	aName		ifNil: [^ self].	"User made no choice"	aName == #none		ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .data or .data.gz)'].	aFileStream _ FileStream oldFileNamed: aName.	list _ aFileStream fileInObjectAndCode.	userCategories _ list first.	allPeople _ list second.	allEvents _ list third.	recurringEvents _ list fourth.	allToDoItems _ list fifth.	allNotes _ list sixth.	date _ Date today.	self selectCategory: 'all'! !!PDA methodsFor: 'initialization' stamp: 'dgd 2/22/2003 13:28'!mergeDatabase	| aName aFileStream list |	aName _ Utilities chooseFileWithSuffixFromList: #('.pda' '.pda.gz' ) withCaption: 'Choose a file to load'.	aName		ifNil: [^ self].	"User made no choice"	aName == #none		ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .data or .data.gz)'].	aFileStream _ FileStream oldFileNamed: aName.	list _ aFileStream fileInObjectAndCode.	userCategories _ (list first , userCategories) asSet asArray sort.	allPeople _ (list second , allPeople) asSet asArray sort.	allEvents _ (list third , allEvents) asSet asArray sort.	recurringEvents _ (list fourth , recurringEvents) asSet asArray sort.	allToDoItems _ (list fifth , allToDoItems) asSet asArray sort.	allNotes _ ((list sixth)				, allNotes) asSet asArray sort.	date _ Date today.	self selectCategory: 'all'! !!PDA methodsFor: 'schedule' stamp: 'gm 3/2/2003 18:26'!updateScheduleList	(date isNil			and: [category ~= 'recurring'])		ifTrue: [scheduleList _ Array new.			scheduleListIndex _ 0.			^ self changed: #scheduleListItems].	scheduleList _ (category = 'recurring'				ifTrue: ["When 'recurring' is selected, edit actual masters"					(recurringEvents						select: [:c | c matchesKey: category andMatchesDate: date]) ]				ifFalse: ["Otherwise, recurring events just spawn copies."					((allEvents						select: [:c | c matchesKey: category andMatchesDate: date])						, ((recurringEvents								select: [:c | c matchesKey: category andMatchesDate: date])								collect: [:re | (re as: PDAEvent)										date: date])) ])sort.	scheduleListIndex _ scheduleList indexOf: currentItem.	self changed: #scheduleListItems!]style[(18 3 4 16 8 4 11 14 12 3 5 9 17 3 1 7 4 10 18 4 12 4 8 3 11 14 51 7 15 16 3 2 1 13 8 17 4 19 48 8 9 16 3 2 1 13 8 17 4 13 15 18 3 2 1 13 8 17 4 21 4 3 2 5 8 18 4 13 17 3 12 10 11 3 4 10 18)f1b,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1c200200124,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1c200200124,f1,f1cmagenta;,f1,f1c200200124,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1c200200124,f1,f1c150048000,f1,f1cmagenta;,f1,f1cred;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1c150048000,f1,f1cmagenta;,f1,f1cred;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cred;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cred;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1c200200124! !!PDA methodsFor: 'to do' stamp: 'dgd 2/22/2003 13:26'!declareItemDone	| report |	report := FillInTheBlank 				request: 'This item will be declared done as of' , date printString 						, '.Please give a short summary of status'				initialAnswer: 'Completed.'.	(report isNil or: [report isEmpty]) ifTrue: [^self].	currentItem		dayDone: date;		result: report.	self currentItem: currentItem! !!PDAEvent methodsFor: 'comparing' stamp: 'dgd 2/22/2003 14:39'!<= other 	date = other date ifFalse: [^date < other date].	time isNil ifTrue: [^true].	other time isNil ifTrue: [^false].	^time <= other time! !!PDARecurringEvent methodsFor: 'date' stamp: 'dgd 2/22/2003 14:51'!matchesDate: aDate 	(firstDate isNil or: [firstDate > aDate]) ifTrue: [^false].	(lastDate notNil and: [lastDate < aDate]) ifTrue: [^false].	recurrence == #eachDay ifTrue: [^true].	recurrence == #dayOfWeek ifTrue: [^aDate weekday = firstDate weekday].	recurrence == #dayOfMonth 		ifTrue: [^aDate dayOfMonth = firstDate dayOfMonth].	recurrence == #dateOfYear 		ifTrue: 			[^aDate monthIndex = firstDate monthIndex 				and: [aDate dayOfMonth = firstDate dayOfMonth]].	recurrence == #nthWeekdayOfMonth 		ifTrue: 			[^aDate weekday = firstDate weekday 				and: [(aDate dayOfMonth - 1) // 7 = ((firstDate dayOfMonth - 1) // 7)]].	recurrence == #nthWeekdayOfMonthEachYear 		ifTrue: 			[^aDate monthIndex = firstDate monthIndex and: 					[aDate weekday = firstDate weekday 						and: [(aDate dayOfMonth - 1) // 7 = ((firstDate dayOfMonth - 1) // 7)]]]! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'aoy 2/17/2003 01:14'!selectColor: evt 	"Update the receiver from the given event. Constrain locOfCurrent's center to lie within the color selection area. If it is partially in the transparent area, snap it entirely into it vertically."	| r |	locOfCurrent := evt cursorPoint - self topLeft.	r := Rectangle center: locOfCurrent extent: 9 @ 9.	locOfCurrent := locOfCurrent 				+ (r amountToTranslateWithin: (5 @ 11 corner: 140 @ 136)).	locOfCurrent x > 128 ifTrue: [locOfCurrent := 135 @ locOfCurrent y].	"snap into grayscale"	currentColor := locOfCurrent y < 17 				ifTrue:  					[locOfCurrent := locOfCurrent x @ 11.	"snap into transparent"					Color transparent]				ifFalse: [image colorAt: locOfCurrent].	(owner isKindOf: PaintBoxMorph) 		ifTrue: [owner takeColorEvt: evt from: self].	self changed! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/22/2003 19:03'!brush: brushButton action: aSelector nib: aMask evt: evt 	"Set the current tool and action for the paintBox.  "	currentBrush 		ifNotNil: [currentBrush == brushButton ifFalse: [currentBrush state: #off]].	currentBrush := brushButton.	"A ThreePhaseButtonMorph"	"currentBrush state: #on.	already done"	"aSelector is like brush3:.  Don't save it.  Can always say (currentBrush arguments at: 2)	aMask is the brush shape.  Don't save it.  Can always say (currentBrush arguments at: 3)"	self notifyWeakDependentsWith: { 				#currentNib.				evt.				currentBrush arguments third}.	self brushable ifFalse: [self setAction: #paint: evt: evt]	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/22/2003 19:03'!deleteCurrentStamp: evt 	"The trash is telling us to delete the currently selected stamp"	(tool arguments second) == #stamp: 		ifTrue: 			[stampHolder remove: tool.			self setAction: #paint: evt: evt]	"no use stamping with a blank stamp"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/22/2003 19:03'!eyedropper: aButton action: aSelector cursor: aCursor evt: evt 	"Take total control and pick up a color!!!!"	| pt feedbackColor |	aButton state: #on.	tool ifNotNil: [tool state: #off].	currentCursor := aCursor.	evt hand showTemporaryCursor: currentCursor		hotSpotOffset: 6 negated @ 4 negated.	"<<<< the form was changed a bit??"	feedbackColor := Display colorAt: Sensor cursorPoint.	colorMemory align: colorMemory bounds topRight		with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory.	"Full color picker"	[Sensor anyButtonPressed] whileFalse: 			[pt := Sensor cursorPoint.			"deal with the fact that 32 bit displays may have garbage in the 			alpha bits"			feedbackColor := Display depth = 32 						ifTrue: 							[Color colorFromPixelValue: ((Display pixelValueAt: pt) bitOr: 4278190080)								depth: 32]						ifFalse: [Display colorAt: pt].			"the hand needs to be drawn"			evt hand position: pt.			self world displayWorldSafely].	Sensor waitNoButton.	evt hand showTemporaryCursor: nil hotSpotOffset: 0 @ 0.	self currentColor: feedbackColor evt: evt.	colorMemory delete.	tool ifNotNil: 			[tool state: #on.			currentCursor := tool arguments third].	aButton state: #off! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/22/2003 19:03'!getNib	^currentBrush arguments third! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/21/2003 23:17'!grabFromScreen: evt 	"Allow the user to grab a picture from the screen OUTSIDE THE PAINTING AREA and install it in a blank stamp.  To get a stamp in the painting area, click on the stamp tool in a blank stamp."	"scroll to blank stamp"	| stampButton form |	stampButton := stampHolder stampButtons first.	[(stampHolder stampFormFor: stampButton) isNil] 		whileFalse: [stampHolder scroll: 1].	form := Form fromUser.	tool state: #off.	tool := stampHolder otherButtonFor: stampButton.	stampHolder stampForm: form for: tool.	"install it"	stampButton state: #on.	stampButton doButtonAction: evt.	evt hand showTemporaryCursor: (focusMorph getCursorFor: evt)! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/22/2003 19:04'!pickup: actionButton action: aSelector cursor: aCursor evt: evt 	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self 		tool: actionButton		action: aSelector		cursor: aCursor		evt: evt.	aSelector == #stamp: 		ifTrue: 			[(stampHolder pickupButtons includes: actionButton) 				ifTrue: 					[stamper := stampHolder otherButtonFor: actionButton.					^self 						pickup: stamper						action: #stamp:						cursor: (stamper arguments third)						evt: evt].			(stampHolder stampFormFor: actionButton) ifNil: 					["If not stamp there, go to pickup mode"					picker := stampHolder otherButtonFor: actionButton.					picker state: #on.					^self 						pickup: picker						action: #pickup:						cursor: (picker arguments third)						evt: evt]				ifNotNil: 					[old := stampHolder stampFormFor: actionButton.					currentCursor := ColorForm extent: old extent depth: 8.					old displayOn: currentCursor.					map := Color indexedColors copy.					map at: 1 put: Color transparent.					currentCursor colors: map.					currentCursor offset: currentCursor extent // -2.					"Emphisize the stamp button"					actionButton owner borderColor: (Color 								r: 0.65								g: 0.599								b: 0.8)	"layoutMorph"	"color: (Color r: 1.0 g: 0.645 b: 0.419);"]].	aSelector == #pickup: 		ifTrue: 			[ss := self focusMorph.			ss ifNotNil: [currentCursor := aCursor]				ifNil: 					[self notCurrentlyPainting.					self setAction: #paint: evt: evt]]! !!PaintBoxMorph methodsFor: 'actions' stamp: 'dgd 2/22/2003 19:04'!showColor	"Display the current color in all brushes, both on and off."	| offIndex onIndex center |	currentColor ifNil: [^self].	"colorPatch color: currentColor.	May delete later"	(brushes isNil or: [brushes first owner ~~ self]) 		ifTrue: 			[brushes := OrderedCollection new.			#(#brush1: #brush2: #brush3: #brush4: #brush5: #brush6:) 				do: [:sel | brushes addLast: (self submorphNamed: sel)]].	center := (brushes sixth) offImage extent // 2.	offIndex := (brushes sixth) offImage pixelValueAt: center.	onIndex := (brushes sixth) onImage pixelValueAt: center.	brushes do: 			[:bb | 			bb offImage colors at: offIndex + 1 put: currentColor.			bb offImage clearColormapCache.			bb onImage colors at: onIndex + 1 put: currentColor.			bb onImage clearColormapCache.			bb invalidRect: bb bounds].	self invalidRect: (brushes first topLeft rect: brushes last bottomRight)! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'dgd 2/22/2003 19:39'!fixupButtons	| changes answer newSelector |	changes := Dictionary new.	changes		at: #brush:action:nib: put: #brush:action:nib:evt:;		at: #tool:action:cursor: put: #tool:action:cursor:evt:;		at: #pickup:action:cursor: put: #pickup:action:cursor:evt:;		at: #keep:with: put: #keep:with:evt:;		at: #undo:with: put: #undo:with:evt:;		at: #scrollStamps:action: put: #scrollStamps:action:evt:;		at: #toss:with: put: #toss:with:evt:;		at: #eyedropper:action:cursor: put: #eyedropper:action:cursor:evt:;		at: #clear:with: put: #clear:with:evt:.	answer := WriteStream on: String new.	self allMorphsDo: 			[:each | 			(each isKindOf: ThreePhaseButtonMorph) 				ifTrue: 					[answer nextPutAll: each actionSelector.					(changes includesKey: each actionSelector) 						ifTrue: 							[each actionSelector: (newSelector := changes at: each actionSelector).							answer nextPutAll: ' <-- ' , newSelector].					answer cr]].	^answer contents	"StringHolder new		contents: answer contents;		openLabel: 'button fixups'"! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'dgd 2/22/2003 19:03'!init3	"Just a record of how we loaded in the latest paintbox button images"	| bb rect lay pic16Bit aa blt on thin |	self loadoffImage: 'etoy_default.gif'.	self allMorphsDo: 			[:button | 			(button isKindOf: ThreePhaseButtonMorph) 				ifTrue: [button offImage: nil]				ifFalse: [button position: button position + (100 @ 0)]].	(bb := self submorphNamed: #keep:) position: bb position + (100 @ 0).	(bb := self submorphNamed: #toss:) position: bb position + (100 @ 0).	(bb := self submorphNamed: #undo:) position: bb position + (100 @ 0).	"Transparent is (Color r: 1.0 g: 0 b: 1.0)"	self moveButtons.	self loadOnImage: 'etoy_in.gif'.	AllOnImage := nil.	'save space'.	self loadPressedImage: 'etoy_in.gif'.	AllPressedImage := nil.	'save space'.	self loadCursors.	"position the stamp buttons"	stampHolder stampButtons owner last delete.	stampHolder pickupButtons last delete.	stampHolder stampButtons: (stampHolder stampButtons copyFrom: 1 to: 3).	stampHolder pickupButtons: (stampHolder pickupButtons copyFrom: 1 to: 3).	"| rect |"	stampHolder pickupButtons do: 			[:button | 			"PopUpMenu notify: 'Rectangle for ',sel."			rect := Rectangle fromUser.			button bounds: rect	"image is nil"].	"| rect lay |"	stampHolder clear.	stampHolder stampButtons do: 			[:button | 			button				offImage: nil;				pressedImage: nil.			lay := button owner.			"PopUpMenu notify: 'Rectangle for ',sel."			rect := Rectangle fromUser.			button image: (Form fromDisplay: (rect insetBy: 2)).			lay borderWidth: 2.			lay bounds: rect	"image is nil"].	"| pic16Bit blt aa on |"	pic16Bit := GIFReadWriter formFromFileNamed: 'etoy_in.gif'.	"really 8"	aa := Form extent: OriginalBounds extent depth: 8.	blt := BitBlt current toForm: aa.	blt		sourceForm: pic16Bit;		combinationRule: Form over;		sourceRect: OriginalBounds;		destOrigin: 0 @ 0;		copyBits.	"Collect all the images for the buttons in the on state"	stampHolder pickupButtons do: 			[:button | 			on := ColorForm extent: button extent depth: 8.			on colors: pic16Bit colors.			on 				copy: (0 @ 0 extent: button extent)				from: button topLeft - self topLeft				in: aa				rule: Form over.			button				image: on;				pressedImage: on;				offImage: nil].	self invalidRect: bounds.	((self submorphNamed: #erase:) arguments third) offset: 12 @ 35.	((self submorphNamed: #eyedropper:) arguments third) offset: 0 @ 0.	((self submorphNamed: #fill:) arguments third) offset: 10 @ 44.	((self submorphNamed: #paint:) arguments third) offset: 3 @ 3.	"unused"	((self submorphNamed: #rect:) arguments third) offset: 6 @ 17.	((self submorphNamed: #ellipse:) arguments third) offset: 5 @ 4.	((self submorphNamed: #polygon:) arguments third) offset: 5 @ 4.	((self submorphNamed: #line:) arguments third) offset: 5 @ 17.	((self submorphNamed: #star:) arguments third) offset: 2 @ 5.	thumbnail delete.	thumbnail := nil.	(submorphs select: [:e | e class == RectangleMorph]) first 		bounds: Rectangle fromUser.	((submorphs select: [:e | e class == RectangleMorph]) first)		borderWidth: 1;		borderColor: Color black.	"| thin |"	submorphs do: [:ss | ss class == ImageMorph ifTrue: [thin := ss	"first"]].	colorMemoryThin := thin! !!PaintBoxMorph methodsFor: 'recent colors' stamp: 'dgd 2/21/2003 23:17'!fixUpRecentColors	| inner outer border box form newImage canvas morph |	self fixUpColorPicker.	recentColors := WriteStream on: Array new.	form := image.	newImage := Form extent: form extent + (0 @ 41) depth: form depth.	form displayOn: newImage.	newImage 		copy: (0 @ (form height - 10) 				extent: form width @ (newImage height - form height + 10))		from: 0 @ (form height - (newImage height - form height + 10))		in: form		rule: Form over.	canvas := newImage getCanvas.	canvas 		line: 12 @ (form height - 10)		to: 92 @ (form height - 10)		width: 1		color: Color black.	canvas := canvas copyOffset: 12 @ (form height - 9).	inner := Color 				r: 0.677				g: 0.71				b: 0.968.	outer := inner darker darker.	border := Color 				r: 0.194				g: 0.258				b: 0.194.	0 to: 1		do: 			[:y | 			0 to: 3				do: 					[:x | 					box := (x * 20) @ (y * 20) extent: 20 @ 20.					morph := BorderedMorph new 								bounds: ((box insetBy: 1) translateBy: canvas origin + bounds origin).					morph						borderWidth: 1;						borderColor: border.					morph color: Color white.					morph 						on: #mouseDown						send: #mouseDownRecent:with:						to: self.					morph 						on: #mouseMove						send: #mouseStillDownRecent:with:						to: self.					morph 						on: #mouseUp						send: #mouseUpRecent:with:						to: self.					self addMorphFront: morph.					recentColors nextPut: morph.					canvas fillRectangle: box color: Color white.					canvas frameRectangle: (box insetBy: 1) color: border.					canvas frameRectangle: box color: inner.					box := box insetBy: 1.					canvas 						line: box topRight						to: box bottomRight						width: 1						color: outer.					canvas 						line: box bottomLeft						to: box bottomRight						width: 1						color: outer]].	recentColors := recentColors contents.	(RecentColors isNil or: [RecentColors size ~= recentColors size]) 		ifTrue: [RecentColors := recentColors collect: [:each | each color]]		ifFalse: 			[RecentColors 				keysAndValuesDo: [:idx :aColor | (recentColors at: idx) color: aColor]].	self image: newImage.	self toggleStamps.	self toggleStamps! !!PaintBoxMorph methodsFor: 'recent colors' stamp: 'dgd 2/21/2003 23:17'!recentColor: aColor 	"Remember the color as one of our recent colors"	(recentColors anySatisfy: [:any | any color = aColor]) ifTrue: [^self].	"already remembered"	recentColors size to: 2		by: -1		do: 			[:i | 			(recentColors at: i) color: (recentColors at: i - 1) color.			RecentColors at: i put: (RecentColors at: i - 1)].	(recentColors first) color: aColor.	RecentColors at: 1 put: aColor! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'gm 2/16/2003 20:38'!sendContentsToPrinter	| textToPrint printer parentWindow |	textToPrint := paragraph text.	textToPrint size == 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.	parentWindow := self model dependents 				detect: [:dep | dep isSystemWindow]				ifNone: [nil].	parentWindow isNil 		ifTrue: [printer documentTitle: 'Untitled']		ifFalse: [printer documentTitle: parentWindow label].	printer printText: textToPrint! !!PasteUpMorph methodsFor: 'cursor' stamp: 'dgd 2/22/2003 14:09'!cursorWrapped: aNumber 	"Set the cursor to the given number, modulo the number of items I contain. Fractional cursor values are allowed."	| truncP oldRect newRect |	cursor ~= aNumber 		ifTrue: 			[self hasSubmorphs ifTrue: [oldRect := self selectedRect].			cursor := self asNumber: aNumber.			truncP := cursor truncated.			truncP > submorphs size 				ifTrue: [submorphs notEmpty ifTrue: [cursor \\ submorphs size] ifFalse: [1]].			truncP < 0 ifTrue: [cursor := 1].			self hasSubmorphs 				ifTrue: 					[newRect := self selectedRect.					self indicateCursor 						ifTrue: 							[self								invalidRect: oldRect;								invalidRect: newRect]]]! !!PasteUpMorph methodsFor: 'cursor' stamp: 'jdl 3/28/2003 08:17'!selectedRect	"Return a rectangle enclosing the morph at the current cursor. Note that the cursor may be a float and may be out of range, so pick the nearest morph. Assume there is at least one submorph."	| p |	p := cursor asInteger.	p := p min: submorphs size.	p := p max: 1.	^(submorphs at: p) fullBounds expandBy: 2! !!PasteUpMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 14:10'!drawOn: aCanvas 	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	(self griddingOn and: [self gridVisible]) 		ifTrue: 			[aCanvas fillRectangle: self bounds				fillStyle: (self 						gridFormOrigin: self gridOrigin						grid: self gridModulus						background: nil						line: Color lightGray)].	self updateTrailsForm.	turtleTrailsForm 		ifNotNil: [aCanvas paintImage: turtleTrailsForm at: self position].	(submorphs notEmpty and: [self indicateCursor]) 		ifTrue: 			[aCanvas 				frameRectangle: self selectedRect				width: 2				color: Color black]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'gm 2/22/2003 13:08'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| aNail representee handy posBlock tempPos |	handy := self primaryHand.	posBlock := 			[:z | 			tempPos := handy position 						- ((handy targetOffset - aMorph formerPosition) 								* (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail 		ifTrue: 			[aNail := aMorph 						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph 				ifFalse: 					[aMorph formerPosition: aMorph position.					aNail position: (posBlock value: aNail)].			^aNail].	((aMorph isKindOf: MorphThumbnail) 		and: [(representee := aMorph morphRepresented) owner isNil]) 			ifTrue: 				[representee position: (posBlock value: representee).				^representee].	self showingListView 		ifTrue: 			[^aMorph 				listViewLineForFieldList: (self valueOfProperty: #fieldListSelectors)].	(aMorph hasProperty: #newPermanentScript) 		ifTrue: [^aMorph asEmptyPermanentScriptor].	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isSyntaxMorph]) 		ifFalse: [^aMorph].	aMorph userScriptSelector isEmptyOrNil 		ifTrue: 			["non-user"			self automaticPhraseExpansion ifFalse: [^aMorph]].	^aMorph morphToDropInPasteUp: self! !!PasteUpMorph methodsFor: 'halos and balloon help' stamp: 'gm 2/16/2003 20:36'!wantsHaloFromClick	^(owner isSystemWindow) not! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color		r: 0.861		g: 1.0		b: 0.722! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 0.6! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:31'!initialize"initialize the state of the receiver"	super initialize.""	cursor _ 1.	padding _ 3.	self enableDragNDrop.	self isWorldMorph		ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true].	self clipSubmorphs: true! !!PasteUpMorph methodsFor: 'model' stamp: 'dgd 2/22/2003 14:09'!createCustomModel	"Create a model object for this world if it does not yet have one. A model object is an initially empty subclass of MorphicModel. As the user names parts and adds behavior, instance variables and methods are added to this class."	model isNil ifFalse: [^self].	model := MorphicModel newSubclass new! !!PasteUpMorph methodsFor: 'objects from disk' stamp: 'dgd 2/22/2003 14:11'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	self flag: #bob0302.	self isWorldMorph ifTrue: [^self project saveAs].	aFileName := ('my ' , self class name) asFileName.	"do better?"	aFileName := FillInTheBlank 				request: 'File name? (".project" will be added to end)'				initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^self beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.project'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName , '.project'].	fileStream := FileStream newFileNamed: aFileName.	fileStream fileOutClass: nil andObject: self	"Puts UniClass definitions out anyway"! !!PasteUpMorph methodsFor: 'pen' stamp: 'dgd 2/22/2003 14:12'!updateTrailsForm	"Update the turtle-trails form using the current positions of all pens.	Only used in conjunction with Preferences batchPenTrails."	"Details: The positions of all morphs with their pens down are recorded each time the draw method is called. If the list from the previous display cycle isn't empty, then trails are drawn from the old to the new positions of those morphs on the turtle-trails form. The turtle-trails form is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| morph oldPoint newPoint removals player tfm |	self flag: #bob.	"transformations WRONG here"	(lastTurtlePositions isNil or: [lastTurtlePositions isEmpty]) 		ifTrue: [^self].	removals := OrderedCollection new.	lastTurtlePositions associationsDo: 			[:assoc | 			player := assoc key.			morph := player costume.			(player getPenDown and: [morph trailMorph == self]) 				ifTrue: 					[oldPoint := assoc value.					tfm := morph owner transformFrom: self.					newPoint := tfm localPointToGlobal: morph referencePosition.					newPoint = oldPoint 						ifFalse: 							[assoc value: newPoint.							self 								drawPenTrailFor: morph								from: oldPoint								to: newPoint]]				ifFalse: [removals add: player]].	removals do: [:key | lastTurtlePositions removeKey: key ifAbsent: []]! !!PasteUpMorph methodsFor: 'project' stamp: 'gm 2/16/2003 20:35'!storeProjectsAsSegments	"Force my sub-projects out to disk"	submorphs do: 			[:sub | 			(sub isSystemWindow) 				ifTrue: [(sub model isKindOf: Project) ifTrue: [sub model storeSegment]]]	"OK if was already out"! !!PasteUpMorph methodsFor: 'project state' stamp: 'dgd 2/22/2003 14:12'!viewBox: newViewBox 	"I am now displayed within newViewBox; react."	self isWorldMorph 		ifTrue: 			[(self viewBox isNil or: [self viewBox extent ~= newViewBox extent]) 				ifTrue: [worldState canvas: nil].			worldState viewBox: newViewBox].	super position: newViewBox topLeft.	fullBounds := bounds := newViewBox.	"Paragraph problem workaround; clear selections to avoid screendroppings."	self flag: #arNote.	"Probably unnecessary"	self isWorldMorph 		ifTrue: 			[worldState handsDo: [:hand | hand releaseKeyboardFocus].			self fullRepaintNeeded]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'gm 2/22/2003 13:08'!currentVocabularyFor: aScriptableObject 	"Answer the Vocabulary object to be applied when scripting an object in the world."	| vocabSymbol vocab aPointVocab |	vocabSymbol := self valueOfProperty: #currentVocabularySymbol				ifAbsent: [nil].	vocabSymbol ifNil: 			[vocab := self valueOfProperty: #currentVocabulary ifAbsent: [nil].			vocab ifNotNil: 					[vocabSymbol := vocab vocabularyName.					self removeProperty: #currentVocabulary.					self setProperty: #currentVocabularySymbol toValue: vocabSymbol]].	vocabSymbol ifNotNil: [^Vocabulary vocabularyNamed: vocabSymbol]		ifNil: 			[(aScriptableObject isKindOf: Player) ifTrue: [^Vocabulary eToyVocabulary].			(aScriptableObject isNumber) 				ifTrue: [^Vocabulary numberVocabulary].			(aScriptableObject isKindOf: Time) 				ifTrue: [^Vocabulary vocabularyForClass: Time].			(aScriptableObject isString) 				ifTrue: [^Vocabulary vocabularyForClass: String].			(aScriptableObject isPoint) 				ifTrue: 					[(aPointVocab := Vocabulary vocabularyForClass: Point) 						ifNotNil: [^aPointVocab]].			(aScriptableObject isKindOf: Date) 				ifTrue: [^Vocabulary vocabularyForClass: Date].			"OrderedCollection and Holder??"			^Vocabulary fullVocabulary]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'gm 2/22/2003 13:09'!recreateScripts	"self currentWorld recreateScripts."	Preferences enable: #universalTiles.	Preferences enable: #capitalizedReferences.	"Rebuild viewers"	self flapTabs do: 			[:ff | 			(ff isMemberOf: ViewerFlapTab) 				ifTrue: 					[ff referent 						submorphsDo: [:m | (m isStandardViewer) ifTrue: [m recreateCategories]]]].	"Rebuild scriptors"	((self flapTabs collect: [:t | t referent]) copyWith: self) 		do: [:w | w allScriptEditors do: [:scrEd | scrEd unhibernate]]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'gm 2/22/2003 13:09'!relaunchAllViewers	"Relaunch all the viewers in the project"	| aViewer |	(self submorphs select: [:m | m isKindOf: ViewerFlapTab]) do: 			[:aTab | 			aViewer := aTab referent submorphs 						detect: [:sm | sm isStandardViewer]						ifNone: [nil].			aViewer ifNotNil: [aViewer relaunchViewer]			"ActiveWorld relaunchAllViewers"]! !!PasteUpMorph methodsFor: 'structure' stamp: 'dgd 2/22/2003 14:12'!world	worldState isNil ifTrue: [^super world].	^self! !!PasteUpMorph methodsFor: 'user interface' stamp: 'dgd 2/22/2003 14:11'!modelWakeUp	"I am the model of a SystemWindow, that has just been activated"	| aWindow |	owner isNil ifTrue: [^self].	"Not in Morphic world"	(owner isKindOf: TransformMorph) ifTrue: [^self viewBox: self fullBounds].	(aWindow := self containingWindow) ifNotNil: 			[self viewBox = aWindow panelRect 				ifFalse: [self viewBox: aWindow panelRect]]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'gm 2/16/2003 20:35'!findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock 	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"	| aWindow |	submorphs do: 			[:aMorph | 			(((aWindow := aMorph renderedMorph) isSystemWindow) 				and: [qualifyingBlock value: aWindow]) 					ifTrue: 						[aWindow isCollapsed ifTrue: [aWindow expand].						aWindow activateAndForceLabelToShow.						^self]].	"None found, so create one"	makeBlock value openInWorld! !!PasteUpMorph methodsFor: 'world menu' stamp: 'dgd 2/22/2003 14:10'!findDirtyBrowsers: evt 	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu := MenuMorph new.	(SystemWindow windowsIn: self		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #activate].	menu submorphs notEmpty ifTrue: [menu popUpEvent: evt in: self]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'dgd 2/22/2003 14:10'!findDirtyWindows: evt 	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu := MenuMorph new.	(SystemWindow windowsIn: self		satisfying: [:w | w model canDiscardEdits not]) do: 				[:w | 				menu 					add: w label					target: w					action: #activate].	menu submorphs notEmpty ifTrue: [menu popUpEvent: evt in: self]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'gm 2/16/2003 20:35'!findWindow: evt 	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."	| menu expanded collapsed nakedMorphs |	menu := MenuMorph new.	expanded := SystemWindow windowsIn: self				satisfying: [:w | w isCollapsed not].	collapsed := SystemWindow windowsIn: self satisfying: [:w | w isCollapsed].	nakedMorphs := self submorphsSatisfying: 					[:m | 					((m isSystemWindow) not and: [(m isKindOf: StickySketchMorph) not]) 						and: [m isFlapTab not]].	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) 		ifTrue: [^self beep].	(expanded 		asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #activateAndForceLabelToShow.				w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) 		ifFalse: [menu addLine].	(collapsed 		asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #collapseOrExpand.				w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asSortedCollection: 			[:w1 :w2 | 			w1 nameForFindWindowFeature 				caseInsensitiveLessOrEqual: w2 nameForFindWindowFeature]) 		do: 			[:w | 			menu 				add: w nameForFindWindowFeature				target: w				action: #comeToFrontAndAddHalo].	menu addTitle: 'find window'.	menu popUpEvent: evt in: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 14:09'!addMorphsAndModel: aMorphOrList 	"Dump in submorphs, model, and stepList from aMorphOrList.  Used to bring a world, paste-up, or other morph in from an object file."	aMorphOrList isMorph 		ifTrue: 			[aMorphOrList isWorldMorph 				ifFalse: 					["one morph, put on hand"					"aMorphOrList installModelIn: self.  	a chance to install model pointers"					aMorphOrList privateOwner: nil.					self firstHand attachMorph: aMorphOrList.					self startSteppingSubmorphsOf: aMorphOrList]				ifTrue: 					[model isNil 						ifTrue: [self setModel: aMorphOrList modelOrNil]						ifFalse: 							[aMorphOrList modelOrNil ifNotNil: 									[aMorphOrList modelOrNil privateOwner: nil.									self addMorph: aMorphOrList modelOrNil]].					aMorphOrList privateSubmorphs reverseDo: 							[:m | 							m privateOwner: nil.							self addMorph: m.							m changed].					(aMorphOrList instVarNamed: 'stepList') 						do: [:entry | entry first startSteppingIn: self]]]		ifFalse: 			["list, add them all"			aMorphOrList reverseDo: 					[:m | 					m privateOwner: nil.					self addMorph: m.					self startSteppingSubmorphsOf: m.	"It may not want this!!"					m changed]]! !!PasteUpMorph methodsFor: 'world state' stamp: 'gm 2/16/2003 20:35'!allNonFlapRelatedSubmorphs	"Answer all non-window submorphs that are not flap-related"	^submorphs 		select: [:m | (m isSystemWindow) not and: [m isFlapOrTab not]]! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 14:10'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(worldState canvas isNil or: 			[worldState canvas extent ~= self viewBox extent 				or: [worldState canvas form depth ~= Display depth]]) 		ifTrue: 			["allocate a new offscreen canvas the size of the window"			worldState 				canvas: (Display defaultCanvasClass extent: self viewBox extent)].	worldState canvas fillColor: color.	submorphs reverseDo: [:m | worldState canvas fullDrawMorph: m].	worldState handsReverseDo: [:h | worldState canvas fullDrawMorph: h].	worldState canvas form displayOn: Display at: self viewBox origin.	self fullRepaintNeeded.	"don't collect damage"	Display forceDisplayUpdate! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 14:10'!install	owner := nil.	"since we may have been inside another world previously"	ActiveWorld := self.	ActiveHand := self hands first.	"default"	ActiveEvent := nil.	submorphs do: [:ss | ss owner isNil ifTrue: [ss privateOwner: self]].	"Transcript that was in outPointers and then got deleted."	self viewBox: Display boundingBox.	Sensor flushAllButDandDEvents.	worldState handsDo: [:h | h initForEvents].	self installFlaps.	self borderWidth: 0.	"default"	(Preferences showSecurityStatus 		and: [SecurityManager default isInRestrictedMode]) 			ifTrue: 				[self					borderWidth: 2;					borderColor: Color red].	self presenter allExtantPlayers do: [:player | player prepareToBeRunning].	SystemWindow noteTopWindowIn: self.	self displayWorldSafely! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 14:11'!installAsActiveSubprojectIn: enclosingWorld at: newBounds titled: aString 	| window howToOpen tm boundsForWorld |	howToOpen := self embeddedProjectDisplayMode.	"#scaled may be the only one that works at the moment"	submorphs do: [:ss | ss owner isNil ifTrue: [ss privateOwner: self]].	"Transcript that was in outPointers and then got deleted."	boundsForWorld := howToOpen == #naked ifTrue: [newBounds] ifFalse: [bounds].	worldState canvas: nil.	worldState viewBox: boundsForWorld.	self bounds: boundsForWorld.	"self viewBox: Display boundingBox."	"worldState handsDo: [:h | h initForEvents]."	self installFlaps.	"SystemWindow noteTopWindowIn: self."	"self displayWorldSafely."	howToOpen == #naked ifTrue: [enclosingWorld addMorphFront: self].	howToOpen == #window 		ifTrue: 			[window := (NewWorldWindow labelled: aString) model: self.			window addMorph: self frame: (0 @ 0 extent: 1.0 @ 1.0).			window openInWorld: enclosingWorld].	howToOpen == #frame 		ifTrue: 			[window := (AlignmentMorphBob1 new)						minWidth: 100;						minHeight: 100;						borderWidth: 8;						borderColor: Color green;						bounds: newBounds.			window addMorph: self.			window openInWorld: enclosingWorld].	howToOpen == #scaled 		ifTrue: 			[self position: 0 @ 0.			window := (EmbeddedWorldBorderMorph new)						minWidth: 100;						minHeight: 100;						borderWidth: 8;						borderColor: Color green;						bounds: newBounds.			tm := BOBTransformationMorph new.			window addMorph: tm.			tm addMorph: self.			window openInWorld: enclosingWorld.			tm changeWorldBoundsToShow: bounds.			self arrangeToStartSteppingIn: enclosingWorld			"tm scale: (tm width / self width min: tm height / self height) asFloat."]! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 19:01'!paintAreaFor: aSketchMorph 	"Answer the area to comprise the onion-skinned canvas for painting/repainting aSketchMorph"	| itsOwner |	((itsOwner := aSketchMorph owner) notNil and: [itsOwner isPlayfieldLike]) 		ifTrue: [^itsOwner bounds].	"handles every plausible situation"	^self paintArea! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 14:11'!someHalo	"Return some halo that's currently visible in the world"	| m |	^(m := self haloMorphs) notEmpty ifTrue: [m first] ifFalse: [nil]! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 2/22/2003 14:12'!standardSystemController	^ScheduledControllers controllerSatisfying: 			[:c | 			c view subViews notEmpty and: [c view firstSubView model == self]]! !!ComponentLayout methodsFor: 'model' stamp: 'dgd 2/21/2003 23:06'!createCustomModel	"Create a model object for this world if it does not yet have one.	The default model for an EditView is a Component."	model isNil ifFalse: [^self].	"already has a model"	model := Component newSubclass new! !!ComponentLayout methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 19:06'!allKnownNames	^super allKnownNames 		, (self submorphs collect: [:m | m knownName] thenSelect: [:m | m notNil])! !!IndexTabs methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 0! !!IndexTabs methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.0		g: 0.6		b: 0.6! !!IndexTabs methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:43'!initialize	"Initialize the receiver. Make sure it is not open to drag and  	drop"	super initialize.	""	padding _ 10.	verticalPadding _ 4.	basicHeight _ 14.	basicWidth _ 200.		self enableDragNDrop: false! !!IndexTabs methodsFor: 'layout' stamp: 'dgd 2/22/2003 13:25'!requiredWidth	submorphs isEmpty ifTrue: [^self basicWidth].	^(submorphs detectSum: [:m | m width]) + (submorphs size * padding)! !!IndexTabs methodsFor: 'layout' stamp: 'dgd 2/22/2003 13:25'!widthImposedByOwner	((owner isNil or: [owner isWorldOrHandMorph]) 		or: [owner submorphs size < 2]) ifTrue: [^self basicWidth].	^owner submorphs second width! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:49'!mouseMove: evt 	| delta offsetEvt |	editMode isNil 		ifTrue: 			["First movement determines edit mode"			((delta := evt cursorPoint - hitLoc) dist: 0 @ 0) <= 2 				ifTrue: [^self	"No significant movement yet."].			delta x abs > delta y abs 				ifTrue: 					[delta x > 0 						ifTrue: 							["Horizontal drag"							editMode := #selectNotes]						ifFalse: 							[self playSound: nil.							offsetEvt := evt copy setCursorPoint: evt cursorPoint + (20 @ 0).							self invokeNoteMenu: offsetEvt]]				ifFalse: [editMode := #editPitch	"Vertical drag"]].	editMode == #editPitch ifTrue: [self editPitch: evt].	editMode == #selectNotes ifTrue: [self selectNotes: evt]! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'dgd 2/22/2003 14:50'!selectFrom: selection 	(trackIndex = selection first and: 			[indexInTrack >= (selection second) and: [indexInTrack <= (selection third)]]) 		ifTrue: [selected ifFalse: [self select]]		ifFalse: [selected ifTrue: [self deselect]]! !!PinMorph methodsFor: 'geometry' stamp: 'aoy 2/15/2003 21:23'!position: p 	"Adhere to owner bounds, and apply gridding"	| r side p1 corners c1 c2 sideIndex |	r := owner bounds.	side := r sideNearestTo: p.	p1 := r pointNearestTo: p.	"a point on the border"	p1 := (side = #top or: [side = #left]) 		ifTrue: [r topLeft + (p1 - r topLeft grid: 4 @ 4)]		ifFalse: [ r bottomRight + (p1 - r bottomRight grid: 4 @ 4)].	"Update pin spec(5) = side index + fraction along side"	corners := r corners.	sideIndex := #(#left #bottom #right #top) indexOf: side.	c1 := corners at: sideIndex.	c2 := corners atWrap: sideIndex + 1.	pinSpec pinLoc: sideIndex + ((p1 dist: c1) / (c2 dist: c1) min: 0.99999).	"Set new position with appropriate offset."	side = #top ifTrue: [super position: p1 - (0 @ 8)].	side = #left ifTrue: [super position: p1 - (8 @ 0)].	side = #bottom ifTrue: [super position: p1].	side = #right ifTrue: [super position: p1].	wires do: [:w | w pinMoved]! !!PinMorph methodsFor: 'wires' stamp: 'dgd 2/22/2003 14:38'!startWiring: event 	"Start wiring from this pin"	| origin handle candidates candidate wiringColor wire |	origin := self wiringEndPoint.	candidates := OrderedCollection new.	"Later this could be much faster if we define pinMorphsDo:		so that it doesn't go too deep and bypasses non-widgets."	self pasteUpMorph allMorphsDo: 			[:m | 			((m isMemberOf: PinMorph) and: [m canDockWith: self]) 				ifTrue: [candidates add: m]].	handle := NewHandleMorph new 				followHand: event hand				forEachPointDo: 					[:newPoint | 					candidate := candidates detect: [:m | m containsPoint: newPoint]								ifNone: [nil].					wiringColor := candidate isNil ifTrue: [Color black] ifFalse: [Color red].					handle						removeAllMorphs;						addMorph: (PolygonMorph 									vertices: (Array with: origin with: newPoint)									color: Color black									borderWidth: 1									borderColor: wiringColor)]				lastPointDo: 					[:lastPoint | 					(self wireTo: candidate) 						ifTrue: 							[wire := (WireMorph 										vertices: (Array with: origin with: lastPoint)										color: Color black										borderWidth: 1										borderColor: Color black) fromPin: self toPin: candidate.							self pasteUpMorph addMorph: wire.							self addWire: wire.							candidate addWire: wire]].	event hand world addMorph: handle.	handle startStepping! !!PinMorph methodsFor: 'wires' stamp: 'dgd 2/22/2003 14:38'!wireTo: otherPin 	"Note must return true or false indicating success"	(otherPin isNil or: [otherPin == self]) ifTrue: [^false].	self hasVariable 		ifTrue: 			[otherPin hasVariable 				ifTrue: [self mergeVariableWith: otherPin]				ifFalse: [otherPin shareVariableOf: self]]		ifFalse: 			[otherPin hasVariable 				ifTrue: [self shareVariableOf: otherPin]				ifFalse: 					[self addModelVariable.					otherPin shareVariableOf: self]].	component model changed: pinSpec modelReadSelector.	^true! !!PinSpec methodsFor: 'variables' stamp: 'dgd 2/22/2003 19:00'!hasVariable	^modelReadSelector notNil or: [modelWriteSelector notNil]! !!Player methodsFor: 'misc' stamp: 'dgd 2/16/2003 21:56'!actorState"answer the redeiver's actorState"	^ self costume actorState! !!Player methodsFor: 'misc' stamp: 'gm 2/22/2003 14:53'!allOpenViewers	"Answer a list of all the viewers open on the receiver.  Include viewers in closed flaps"	| aWorld all |	(aWorld := self costume world) ifNil: [^#()].	all := aWorld allMorphs.	aWorld closedViewerFlapTabs 		do: [:aTab | all addAll: aTab referent allMorphs].	^all 		select: [:m | (m isStandardViewer) and: [m scriptedPlayer == self]]! !!Player methodsFor: 'misc' stamp: 'gm 2/22/2003 14:54'!allOpenViewersOnReceiverAndSiblings	"Answer a list of all the viewers open on the receiver and any of its sibling instances.  Include viewers in closed flaps"	| aWorld all |	(aWorld := self costume world) ifNil: [^#()].	all := aWorld allMorphs.	aWorld closedViewerFlapTabs 		do: [:aTab | all addAll: aTab referent allMorphs].	^all select: 			[:m | 			(m isStandardViewer) and: [m scriptedPlayer class == self class]]! !!Player methodsFor: 'misc' stamp: 'dgd 2/22/2003 19:00'!overlaps: aPlayer 	"Answer whether my costume overlaps that of another player"	| goalCostume intersection myShadow goalShadow bb myRect goalRect |	aPlayer ifNil: [^false].	goalCostume := aPlayer costume.	"check if the 2 player costumes intersect"	intersection := costume bounds intersect: goalCostume bounds.	(intersection width = 0 or: [intersection height = 0]) 		ifTrue: [^false]		ifFalse: 			["check if the overlapping region is non-transparent"			"compute 1-bit, black and white versions (stencils) of the intersecting  			part of each morph's costume"			myRect := intersection translateBy: 0 @ 0 - costume topLeft.			myShadow := (costume imageForm contentsOfArea: myRect) stencil.			goalRect := intersection translateBy: 0 @ 0 - goalCostume topLeft.			goalShadow := (goalCostume imageForm contentsOfArea: goalRect) stencil.			"compute a pixel-by-pixel AND of the two stencils.  Result will be black 			(pixel value = 1) where black parts of the stencils overlap"			bb := BitBlt toForm: myShadow.			bb 				copyForm: goalShadow				to: 0 @ 0				rule: Form and.			"return TRUE if resulting form contains any black pixels"			^(bb destForm tallyPixelValues second) > 0]! !!Player methodsFor: 'misc' stamp: 'dgd 2/22/2003 13:45'!revertToUnscriptedPlayerIfAppropriate	| anInstance |	(self class selectors notEmpty or: [self class instVarNames notEmpty]) 		ifTrue: [^self].	anInstance := UnscriptedPlayer new.	anInstance initializeCostumesFrom: self.	self become: anInstance! !!Player methodsFor: 'misc' stamp: 'gm 2/22/2003 14:54'!tearOffTileForSelf	| tiles |	self currentHand attachMorph: (tiles := self tileReferringToSelf).	(tiles isSyntaxMorph) 		ifTrue: 			[Preferences tileTranslucentDrag 				ifTrue: [tiles lookTranslucent]				ifFalse: 					[tiles align: tiles topLeft						with: self currentHand position + tiles cursorBaseOffset]]! !!Player methodsFor: 'scripts-kernel' stamp: 'dgd 2/22/2003 13:45'!slotInfoButtonHitFor: aGetterSymbol inViewer: aViewer 	"The user made a gesture asking for slot menu for the given getter symbol in a viewer; put up the menu."	| aMenu slotSym aType typeVocab |	slotSym := Utilities inherentSelectorForGetter: aGetterSymbol.	aType := self typeForSlotWithGetter: aGetterSymbol asSymbol.	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: slotSym asString , ' (' , aType , ')'.	(typeVocab := Vocabulary vocabularyForType: aType) 		addWatcherItemsToMenu: aMenu		forGetter: aGetterSymbol.	(self slotInfo includesKey: slotSym) 		ifTrue: 			[aMenu 				add: 'change data type'				selector: #chooseSlotTypeFor:				argument: aGetterSymbol.			typeVocab addUserSlotItemsTo: aMenu slotSymbol: slotSym.			aMenu 				add: 'remove "' , slotSym , '"'				selector: #removeSlotNamed:				argument: slotSym.			aMenu 				add: 'rename  "' , slotSym , '"'				selector: #renameSlot:				argument: slotSym.			aMenu addLine].	typeVocab addExtraItemsToMenu: aMenu forSlotSymbol: slotSym.	"e.g. Player type adds hand-me-tiles"	aMenu 		add: 'show categories....'		target: aViewer		selector: #showCategoriesFor:		argument: aGetterSymbol.	self addIdiosyncraticMenuItemsTo: aMenu forSlotSymol: slotSym.	aMenu items isEmpty ifTrue: [aMenu add: 'ok' action: #yourself].	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!Player methodsFor: 'scripts-standard' stamp: 'dgd 2/22/2003 13:42'!append: aPlayer 	"Add aPlayer to the list of objects logically 'within' me.  This is visually represented by its morph becoming my costume's last submorph.   Also allow text to be appended."	| aCostume |	(aPlayer isNil or: [aPlayer == self]) ifTrue: [^self].	(aPlayer class == Text or: [aPlayer class == String]) 		ifTrue: 			[self costume class == TextFieldMorph 				ifTrue: [^self costume append: aPlayer]				ifFalse: [^self]].	(aCostume := self costume topRendererOrSelf) 		addMorphNearBack: aPlayer costume.	aPlayer costume goHome.	"assure it's in view"	(aCostume isKindOf: PasteUpMorph) 		ifTrue: [self setCursor: (aCostume submorphs indexOf: aPlayer costume)]! !!Player methodsFor: 'scripts-standard' stamp: 'dgd 2/22/2003 13:42'!bounce: soundName 	"If the receiver's current bounds obtrude beyond the bounds of its container, then 'bounce' it back within the container, and make the indicated sound while doing so"	| box bounced aCostume |	(aCostume := self costume) ifNil: [^self].	(aCostume owner isNil or: [aCostume owner isHandMorph]) ifTrue: [^self].	box := aCostume owner bounds.	bounced := false.	aCostume left < box left 		ifTrue: 			[self headRight.			bounced := true].	aCostume right > box right 		ifTrue: 			[self headLeft.			bounced := true].	aCostume top < box top 		ifTrue: 			[self headDown.			bounced := true].	aCostume bottom > box bottom 		ifTrue: 			[self headUp.			bounced := true].	bounced ifTrue: [^self makeBounceSound: soundName]! !!Player methodsFor: 'scripts-standard' stamp: 'dgd 2/22/2003 13:43'!goToRightOf: aPlayer 	"Place the object so that it lies directly to the right of the given object"	| hisCostume aCostume |	(aPlayer isNil or: [aPlayer == self]) ifTrue: [^self].	(hisCostume := aPlayer costume) isInWorld ifFalse: [^self].	(aCostume := self costume) owner == hisCostume owner 		ifFalse: [hisCostume owner addMorphFront: aCostume].	aCostume 		position: hisCostume bounds rightCenter - (0 @ (aCostume height // 2))! !!Player methodsFor: 'scripts-standard' stamp: 'dgd 2/22/2003 13:43'!makeNewDrawingIn: paintPlacePlayer 	| paintPlace |	((paintPlacePlayer isNil 		or: [((paintPlace := paintPlacePlayer costume) isKindOf: PasteUpMorph) not]) 			or: [paintPlace isInWorld not]) 			ifTrue: 				[^self 					inform: 'Error: not a plausibleplace in which to makea new drawing'].	paintPlace makeNewDrawingWithin! !!Player methodsFor: 'scripts-standard' stamp: 'dgd 2/22/2003 13:44'!moveToward: aPlayer 	"Move a standard amount in the direction of the given player.  If the object has an instance variable named 'speed', the speed of the motion will be governed by that value"	| angle aCostume |	(aPlayer isNil or: [aPlayer == self]) ifTrue: [^self].	((aCostume := self costume) bounds intersects: aPlayer costume bounds) 		ifTrue: [^self].	angle := aCostume referencePosition 				bearingToPoint: aPlayer costume referencePosition.	self setHeading: angle.	self forward: self getSpeed! !!Player methodsFor: 'scripts-standard' stamp: 'dgd 2/22/2003 13:44'!prepend: aPlayer 	"Add aPlayer to the list of objects logically 'within' me.  This is visually represented by its morph becoming my costume's first submorph.   Also allow text to be prepended."	| aCostume |	(aPlayer isNil or: [aPlayer == self]) ifTrue: [^self].	(aPlayer class == Text or: [aPlayer class == String]) 		ifTrue: 			[^ self costume class == TextFieldMorph 				ifTrue: [self costume prepend: aPlayer]				ifFalse: [self]].	(aCostume := self costume topRendererOrSelf) 		addMorphFront: aPlayer costume.	aPlayer costume goHome.	"assure it's in view"	(aCostume isKindOf: PasteUpMorph) 		ifTrue: [self setCursor: (aCostume submorphs indexOf: aPlayer costume)]! !!Player methodsFor: 'slot getters/setters' stamp: 'dgd 2/22/2003 13:43'!getFirstElement	"Answer a player representing the receiver's costume's first submorph"	| itsMorphs |	^(itsMorphs := costume submorphs) notEmpty 		ifFalse: [costume presenter standardPlayer]		ifTrue: [itsMorphs first assuredPlayer]! !!Player methodsFor: 'slot getters/setters' stamp: 'dgd 2/22/2003 13:45'!setFirstElement: aPlayer 	"Caution - this is a replacement operation!!  Replace the receiver's costume's first element with the morph represented by aPlayer"	| aCostume |	(aPlayer == self or: [(aCostume := self costume) submorphs isEmpty]) 		ifTrue: [^self].	costume replaceSubmorph: aCostume submorphs first by: aPlayer costume! !!Player methodsFor: 'slots-kernel' stamp: 'dgd 2/22/2003 13:42'!categories	"Answer a list of categories appropriate to the the receiver and its costumes"	| aList |	self hasCostumeThatIsAWorld ifTrue: [^self categoriesForWorld].	aList := OrderedCollection new.	self slotNames notEmpty ifTrue: [aList add: #'instance variables'].	aList addAll: costume categoriesForViewer.	aList remove: #scripts ifAbsent: [].	aList add: #scripts after: aList first.	^aList! !!Player methodsFor: 'slots-kernel' stamp: 'dgd 2/22/2003 13:42'!categoriesForVocabulary: aVocabulary 	"Answer a list of categories appropriate to the receiver and its costumes, in the given Vocabulary"	| aList |	self hasCostumeThatIsAWorld 		ifTrue: [aList := self categoriesForWorld]		ifFalse: 			[aList := OrderedCollection new.			self slotNames notEmpty ifTrue: [aList add: #'instance variables'].			aList addAll: costume categoriesForViewer].	aVocabulary addCustomCategoriesTo: aList.	aList remove: #scripts ifAbsent: [].	aList add: #scripts after: aList first.	^aList! !!Player methodsFor: 'slots-kernel' stamp: 'dgd 2/22/2003 13:42'!categoriesForWorld	"Answer the list of categories given that the receiver is the Player representing a World"	| aList |	aList := #(#'color & border' #'pen trails' #playfield #collections #'stack navigation') 				asOrderedCollection.	self class scripts notEmpty ifTrue: [aList addFirst: #scripts].	self slotNames notEmpty ifTrue: [aList addFirst: #'instance variables'].	^aList! !!Player methodsFor: 'slots-user' stamp: 'dgd 2/22/2003 13:42'!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it"	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector originalString |	suggestedNames := #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames := self class instVarNames.	initialAnswer := suggestedNames 				detect: [:aName | (usedNames includes: aName) not]				ifNone: 					[Utilities keyLike: 'var1'						satisfying: [:aKey | (usedNames includes: aKey) not]].	originalString := FillInTheBlank request: 'name for new inst var: '				initialAnswer: initialAnswer.	originalString isEmptyOrNil ifTrue: [^self].	itsName := ScriptingSystem 				acceptableSlotNameFrom: originalString				forSlotCurrentlyNamed: nil				asSlotNameIn: self				world: self costume world.	itsName isEmpty ifTrue: [^self].	self assureUniClass.	typeChosen := self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName		put: (SlotInformation new initialize type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self class compileAccessorsFor: itsName.	setterSelector := Utilities setterSelectorFor: itsName.	(self class allSubInstances copyWithout: self) 		do: [:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: #'instance variables'! !!Player methodsFor: 'slots-user' stamp: 'dgd 2/22/2003 13:43'!hasUserDefinedScripts	^self class scripts notEmpty! !!Player methodsFor: 'slots-user' stamp: 'dgd 2/22/2003 13:44'!offerGetterTiles: slotName 	"For a player-type slot, offer to build convenient compound tiles that otherwise would be hard to get"	| typeChoices typeChosen thePlayerThereNow slotChoices slotChosen getterTiles aCategoryViewer playerGetter fromPhrase |	typeChoices := Vocabulary typeChoices.	fromPhrase := ' from' , self externalName , '''s ' , slotName.	typeChosen := (SelectionMenu selections: typeChoices lines: #()) 				startUpWithCaption: 'Choose the TYPEof data to get' , fromPhrase.	typeChosen isEmptyOrNil ifTrue: [^self].	thePlayerThereNow := self perform: (Utilities getterSelectorFor: slotName).	thePlayerThereNow 		ifNil: [thePlayerThereNow := self presenter standardPlayer].	slotChoices := thePlayerThereNow slotNamesOfType: typeChosen.	slotChoices isEmpty 		ifTrue: [^self inform: 'sorry -- no slots of that type'].	slotChosen := (SelectionMenu selections: slotChoices asSortedArray) 				startUpWithCaption: 'Choose the datumyou want to extract from' 						, fromPhrase.	slotChosen isEmptyOrNil ifTrue: [^self].	"Now we want to tear off tiles of the form		holder's valueAtCursor's foo"	getterTiles := nil.	aCategoryViewer := CategoryViewer new initializeFor: thePlayerThereNow				categoryChoice: 'basic'.	getterTiles := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotChosen)				type: typeChosen.	aCategoryViewer := CategoryViewer new initializeFor: self				categoryChoice: 'basic'.	playerGetter := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotName)				type: #Player.	getterTiles submorphs first acceptDroppingMorph: playerGetter event: nil.	"the pad"	"simulate a drop"	getterTiles makeAllTilesGreen.	getterTiles justGrabbedFromViewer: false.	(getterTiles firstSubmorph)		changeTableLayout;		hResizing: #shrinkWrap;		vResizing: #spaceFill.	ActiveHand attachMorph: getterTiles! !!Player methodsFor: 'slots-user' stamp: 'dgd 2/22/2003 13:45'!renameSlot: oldSlotName 	| reply newSlotName |	reply := FillInTheBlank request: 'New name for "' , oldSlotName , '":'				initialAnswer: oldSlotName.	reply isEmpty ifTrue: [^self].	newSlotName := ScriptingSystem 				acceptableSlotNameFrom: reply				forSlotCurrentlyNamed: oldSlotName				asSlotNameIn: self				world: self costume currentWorld.	self renameSlot: oldSlotName newSlotName: newSlotName! !!Player methodsFor: 'slots-user' stamp: 'gm 2/22/2003 14:54'!setPrecisionFor: slotName 	"Set the precision for the given slot name"	| aList aMenu reply val aGetter places |	aGetter := Utilities getterSelectorFor: slotName.	places := Utilities 				decimalPlacesForFloatPrecision: (self defaultFloatPrecisionFor: aGetter).	aList := #('0' '1' '2' '3' '4' '5' '6').	aMenu := SelectionMenu labels: aList				selections: (aList collect: [:m | m asNumber]).	reply := aMenu 				startUpWithCaption: 'How many decimal places? (currently ' 						, places asString , ')'.	reply ifNotNil: 			[(self slotInfo includesKey: slotName) 				ifTrue: 					["it's a user slot"					(self slotInfoAt: slotName) 						floatPrecision: (Utilities floatPrecisionForDecimalPlaces: reply).					self class allInstancesDo: 							[:anInst | 							reply == 0 								ifFalse: 									[((val := anInst instVarNamed: slotName asString) isInteger) 										ifTrue: [anInst instVarNamed: slotName asString put: val asFloat]].							anInst updateAllViewers]]				ifFalse: 					["it's specifying a preference for precision on a system-defined numeric slot"					self noteDecimalPlaces: reply forGetter: aGetter.					self updateAllViewers]]! !!Player methodsFor: 'slots-user' stamp: 'gm 2/24/2003 18:06'!slotInfoAt: slotName 	| info |	info := self slotInfo at: slotName ifAbsent: [nil].	info ifNil: 			[self slotInfo at: slotName put: (info := SlotInformation new initialize)].	(info isKindOf: Symbol) 		ifTrue: 			["bkward compat"			self slotInfo at: slotName put: (info := SlotInformation new type: info)].	^info! !!Player methodsFor: 'viewer' stamp: 'dgd 2/22/2003 13:43'!hasUserDefinedSlots	^self class slotInfo notEmpty! !!Player methodsFor: 'viewer' stamp: 'dgd 2/22/2003 13:43'!infoFor: anElement inViewer: aViewer 	"The user made a gesture asking for info/menu relating"	| aMenu elementType aSelector |	elementType := self elementTypeFor: anElement				vocabulary: aViewer currentVocabulary.	elementType = #systemSlot | (elementType == #userSlot) 		ifTrue: [^self slotInfoButtonHitFor: anElement inViewer: aViewer].	aMenu := MenuMorph new defaultTarget: self.	aMenu defaultTarget: self.	aSelector := anElement asSymbol.	elementType == #userScript 		ifTrue: 			[aMenu 				add: 'destroy "' , anElement , '"'				selector: #removeScriptWithSelector:				argument: aSelector.			aMenu 				add: 'rename  "' , anElement , '"'				selector: #renameScript:				argument: aSelector.			aMenu 				add: 'textual scripting pane'				selector: #makeIsolatedCodePaneForSelector:				argument: aSelector.			aSelector numArgs > 0 				ifTrue: 					[aMenu 						add: 'remove parameter'						selector: #ceaseHavingAParameterFor:						argument: aSelector]				ifFalse: 					[aMenu 						add: 'add parameter'						selector: #startHavingParameterFor:						argument: aSelector.					aMenu 						add: 'button to fire this script'						selector: #tearOffButtonToFireScriptForSelector:						argument: aSelector].			aMenu 				add: 'edit balloon help'				selector: #editDescriptionForSelector:				argument: aSelector].	aMenu 		add: 'show categories....'		target: aViewer		selector: #showCategoriesFor:		argument: aSelector.	aMenu items isEmpty 		ifTrue: 			["Never 0 at the moment because of show categories addition"			aMenu add: 'ok' action: nil].	aMenu addTitle: anElement asString , ' (' , elementType , ')'.	aMenu popUpInWorld: aViewer world! !!Player methodsFor: 'viewer' stamp: 'dgd 2/22/2003 13:44'!renameScript: oldSelector 	"The user has asked to rename the script formerly known by oldSelector; obtain a new selector from the user, check it out, and if all is well, ascribe the new name as appropriate"	| reply newSelector aUserScript |	self flag: #deferred.	"Relax the restriction below, before too long"	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript okayToRename 		ifFalse: 			[self 				inform: 'Sorry, we do not permit you to renameclassic-tiled scripts that are currentlytextually coded.  Go back to tile scriptsand try again.  Humble apologies.'.			^self].	reply := FillInTheBlank request: 'Script Name' initialAnswer: oldSelector.	reply isEmpty ifTrue: [^self].	reply = oldSelector ifTrue: [^self beep].	newSelector := self acceptableScriptNameFrom: reply				forScriptCurrentlyNamed: oldSelector.	Preferences universalTiles 		ifTrue: 			["allow colons"			(reply copyWithout: $:) = newSelector 				ifTrue: [newSelector := reply asSymbol]				ifFalse: [self inform: 'name will be modified']].	self renameScript: oldSelector newSelector: newSelector! !!CardPlayer methodsFor: 'card data' stamp: 'dgd 2/22/2003 14:43'!allStringsAfter: aText 	"return an OrderedCollection of strings of text in my instance vars.  If aText is non-nil, begin with that object."	| list ok instVarValue string |	list := OrderedCollection new.	ok := aText isNil.	self class variableDocks do: 			[:vdock | 			instVarValue := self perform: vdock playerGetSelector.			ok ifFalse: [ok := instVarValue == aText].	"and do this one too"			ok 				ifTrue: 					[string := nil.					instVarValue isString ifTrue: [string := instVarValue].					instVarValue isText ifTrue: [string := instVarValue string].					instVarValue isNumber ifTrue: [string := instVarValue printString].					instVarValue isMorph ifTrue: [string := instVarValue userString].	"not used"					string ifNotNil: 							[string isString ifTrue: [list add: string] ifFalse: [list addAll: string]]]].	privateMorphs 		ifNotNil: [privateMorphs do: [:mm | list addAll: (mm allStringsAfter: nil)]].	^list! !!Component methodsFor: 'variables' stamp: 'gm 3/2/2003 18:35'!addVariableNamed: varName 	"Adjust name if necessary and add it"	| otherNames i partName |	otherNames := self class allInstVarNames.	i := nil.		[partName := i isNil 		ifTrue: [varName]		ifFalse: [varName , i printString].	otherNames includes: partName] 			whileTrue: [i := i isNil ifTrue: [1] ifFalse: [i + 1]].	self class addInstVarName: partName.	"Now compile read method and write-with-change method"	self class 		compile: (String streamContents: 					[:s | 					s						nextPutAll: partName;						cr;						tab;						nextPutAll: '^' , partName])		classified: 'view access'		notifying: nil.	self class 		compile: (String streamContents: 					[:s | 					s						nextPutAll: partName , 'Set: newValue';						cr;						tab;						nextPutAll: partName , ' _ newValue.';						cr;						tab;						nextPutAll: 'self changed: #' , partName , '.';						cr;						tab;						nextPutAll: '^ true'	"for components that expect a boolean for accept"])		classified: 'view access'		notifying: nil.	^Array with: partName asSymbol with: (partName , 'Set:') asSymbol! !!MouseDownMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:45'!handlesMouseDown: evt 	^model notNil! !!MouseOverMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:40'!handlesMouseOver: evt 	^model notNil! !!PolygonMorph methodsFor: 'access' stamp: 'aoy 2/15/2003 20:51'!borderColor: aColor 	super borderColor: aColor.	(borderColor isColor and: [borderColor isTranslucentColor]) 		== (aColor isColor and: [aColor isTranslucentColor]) 			ifFalse: 				["Need to recompute fillForm and borderForm					if translucency of border changes."				self releaseCachedState]! !!PolygonMorph methodsFor: 'dashes' stamp: 'dgd 2/22/2003 18:55'!borderDashOffset	borderDashSpec size < 4 ifTrue: [^0.0].	^(borderDashSpec fourth) asFloat! !!PolygonMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 18:56'!drawArrowOn: aCanvas at: endPoint from: priorPoint 	"Draw a triangle oriented along the line from priorPoint to  	endPoint. Answer the wingBase."	| pts spec wingBase |	pts := self arrowBoundsAt: endPoint from: priorPoint.	wingBase := pts size = 4 				ifTrue: [pts third]				ifFalse: [(pts copyFrom: 2 to: 3) average].	spec := self valueOfProperty: #arrowSpec ifAbsent: [5 @ 4].	spec x sign = spec y sign 		ifTrue: [aCanvas drawPolygon: pts fillStyle: borderColor]		ifFalse: 			[aCanvas 				drawPolygon: pts				fillStyle: Color transparent				borderWidth: (borderWidth + 1) // 2				borderColor: borderColor].	^wingBase! !!PolygonMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 14:17'!drawDashedBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas. NOTE: mostly copied from  	drawBorderOn:"	| lineColor bevel topLeftColor bottomRightColor bigClipRect p1i p2i segmentOffset |	(borderColor isNil 		or: [borderColor isColor and: [borderColor isTransparent]]) ifTrue: [^self].	lineColor := borderColor.	bevel := false.	"Border colors for bevelled effects depend on CW ordering of  	vertices"	borderColor == #raised 		ifTrue: 			[topLeftColor := color lighter.			bottomRightColor := color darker.			bevel := true].	borderColor == #inset 		ifTrue: 			[topLeftColor := owner colorForInsets darker.			bottomRightColor := owner colorForInsets lighter.			bevel := true].	bigClipRect := aCanvas clipRect expandBy: (self borderWidth + 1) // 2.	segmentOffset := self borderDashOffset.	self lineSegmentsDo: 			[:p1 :p2 | 			p1i := p1 asIntegerPoint.			p2i := p2 asIntegerPoint.			(arrows ~= #none and: [closed not]) 				ifTrue: 					["Shorten line ends so as not to interfere with tip  					of arrow."					((arrows == #back or: [arrows == #both]) and: [p1 = vertices first]) 						ifTrue: [p1i := anArray first asIntegerPoint].					((arrows == #forward or: [arrows == #both]) and: [p2 = vertices last]) 						ifTrue: [p2i := anArray last asIntegerPoint]].			(closed or: 					["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) 						<= ((p1i max: p2i) min: bigClipRect corner)]) 				ifTrue: 					[bevel 						ifTrue: 							[lineColor := (p1i quadrantOf: p2i) > 2 										ifTrue: [topLeftColor]										ifFalse: [bottomRightColor]].					segmentOffset := aCanvas 								line: p1i								to: p2i								width: borderWidth								color: lineColor								dashLength: borderDashSpec first								secondColor: borderDashSpec third								secondDashLength: borderDashSpec second								startingOffset: segmentOffset]]! !!PolygonMorph methodsFor: 'geometry' stamp: 'dgd 2/22/2003 14:14'!closestPointTo: aPoint 	| curvePoint closestPoint dist minDist |	closestPoint := minDist := nil.	self lineSegmentsDo: 			[:p1 :p2 | 			curvePoint := aPoint nearestPointOnLineFrom: p1 to: p2.			dist := curvePoint dist: aPoint.			(closestPoint isNil or: [dist < minDist]) 				ifTrue: 					[closestPoint := curvePoint.					minDist := dist]].	^closestPoint! !!PolygonMorph methodsFor: 'geometry' stamp: 'dgd 2/22/2003 18:56'!merge: aPolygon 	"Expand myself to enclose the other polygon.  (Later merge overlapping or disjoint in a smart way.)  For now, the two polygons must share at least two vertices.  Shared vertices must come one after the other in each polygon.  Polygons must not overlap."	| shared mv vv hv xx |	shared := vertices select: [:mine | aPolygon vertices includes: mine].	shared size < 2 ifTrue: [^nil].	"not sharing a segment"	mv := vertices asOrderedCollection.	[shared includes: mv first] whileFalse: 			["rotate them"			vv := mv removeFirst.			mv addLast: vv].	hv := aPolygon vertices asOrderedCollection.	[mv first = hv first] whileFalse: 			["rotate him until same shared vertex is first"			vv := hv removeFirst.			hv addLast: vv].	[shared size > 2] whileTrue: 			[shared := shared asOrderedCollection.			(self 				mergeDropThird: mv				in: hv				from: shared) ifNil: [^nil]].	"works by side effect on the lists"	(mv second) = hv last 		ifTrue: 			[mv				removeFirst;				removeFirst.			^self setVertices: (hv , mv) asArray].	(hv second) = mv last 		ifTrue: 			[hv				removeFirst;				removeFirst.			^self setVertices: (mv , hv) asArray].	(mv second) = (hv second) 		ifTrue: 			[hv removeFirst.			mv remove: (mv second).			xx := mv removeFirst.			^self setVertices: (hv , (Array with: xx) , mv reversed) asArray].	mv last = hv last 		ifTrue: 			[mv removeLast.			hv removeFirst.			^self setVertices: (mv , hv reversed) asArray].	^nil! !!PolygonMorph methodsFor: 'geometry' stamp: 'dgd 2/22/2003 18:57'!mergeDropThird: mv in: hv from: shared 	"We are merging two polygons.  In this case, they have at least three identical shared vertices.  Make sure they are sequential in each, and drop the middle one from vertex lists mv, hv, and shared.  First vertices on lists are identical already."	"know (mv first = hv first)"	| mdrop vv |	(shared includes: (mv at: mv size - 2)) 		ifTrue: [(shared includes: mv last) ifTrue: [mdrop := mv last]]		ifFalse: 			[(shared includes: mv last) 				ifTrue: [(shared includes: mv second) ifTrue: [mdrop := mv first]]].	(shared includes: (mv third)) 		ifTrue: [(shared includes: mv second) ifTrue: [mdrop := mv second]].	mdrop ifNil: [^nil].	mv remove: mdrop.	hv remove: mdrop.	shared remove: mdrop.	[shared includes: mv first] whileFalse: 			["rotate them"			vv := mv removeFirst.			mv addLast: vv].	[mv first = hv first] whileFalse: 			["rotate him until same shared vertex is first"			vv := hv removeFirst.			hv addLast: vv]! !!PolygonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color		r: 0.0		g: 0.419		b: 0.935! !!PolygonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color orange! !!PolygonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:10'!initialize"initialize the state of the receiver"	super initialize.""	vertices _ Array				with: 5 @ 0				with: 20 @ 10				with: 0 @ 20.	closed _ true.	smoothCurve _ false.	arrows _ #none.	self computeBounds! !!PolygonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:09'!vertices: verts color: aColor borderWidth: borderWidthInteger borderColor: anotherColor 	super initialize.""	vertices _ verts.	color _ aColor.	borderWidth _ borderWidthInteger.	borderColor _ anotherColor.	closed _ vertices size > 2.	arrows _ #none.	self computeBounds! !!PolygonMorph methodsFor: 'smoothing' stamp: 'dgd 2/22/2003 14:14'!coefficients	"Compute an array for the coefficients.  This is copied from Flegal's old	code in the Spline class."	| length extras verts coefficients |	curveState ifNotNil: [^curveState first].	verts := closed 				ifTrue: [vertices copyWith: vertices first]				ifFalse: [vertices].	length := verts size.	extras := 0.	coefficients := Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5		by: 4		do: 			[:k | 			1 to: length				do: 					[:i | 					(coefficients at: k) at: i						put: (k = 1 								ifTrue: [(verts at: i) x asFloat]								ifFalse: [(verts at: i) y asFloat])].			1 to: extras				do: 					[:i | 					(coefficients at: k) at: length + i put: ((coefficients at: k) at: i + 1)].			self 				derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: 			[1 to: 8				do: 					[:i | 					coefficients at: i put: ((coefficients at: i) copyFrom: 2 to: length + 1)]].	curveState := { 				coefficients.				nil.				nil}.	self computeNextToEndPoints.	^coefficients! !!PolygonMorph methodsFor: 'smoothing' stamp: 'dgd 2/22/2003 14:15'!computeNextToEndPoints	| pointAfterFirst pointBeforeLast |	pointAfterFirst := nil.	self lineSegmentsDo: 			[:p1 :p2 | 			pointAfterFirst isNil ifTrue: [pointAfterFirst := p2 asIntegerPoint].			pointBeforeLast := p1 asIntegerPoint].	curveState at: 2 put: pointAfterFirst.	curveState at: 3 put: pointBeforeLast! !!PolygonMorph methodsFor: 'smoothing' stamp: 'dgd 2/22/2003 14:16'!derivs: a first: point1 second: point2 third: point3 	"Compute the first, second and third derivitives (in coeffs) from	the Points in this Path (coeffs at: 1 and coeffs at: 5)."	| len v anArray |	len := a size.	len < 2 ifTrue: [^self].	len > 2 		ifTrue: 			[v := Array new: len.			v at: 1 put: 4.0.			anArray := Array new: len.			anArray at: 1 put: 6.0 * (a first - (a second * 2.0) + (a third)).			2 to: len - 2				do: 					[:i | 					v at: i put: 4.0 - (1.0 / (v at: i - 1)).					anArray at: i						put: 6.0 * ((a at: i) - ((a at: i + 1) * 2.0) + (a at: i + 2)) 								- ((anArray at: i - 1) / (v at: i - 1))].			point2 at: len - 1 put: (anArray at: len - 2) / (v at: len - 2).			len - 2 to: 2				by: 0 - 1				do: 					[:i | 					point2 at: i						put: ((anArray at: i - 1) - (point2 at: i + 1)) / (v at: i - 1)]].	point2 at: 1 put: (point2 at: len put: 0.0).	1 to: len - 1		do: 			[:i | 			point1 at: i				put: (a at: i + 1) - (a at: i) 						- (((point2 at: i) * 2.0 + (point2 at: i + 1)) / 6.0).			point3 at: i put: (point2 at: i + 1) - (point2 at: i)]! !!PolygonMorph methodsFor: 'smoothing' stamp: 'dgd 2/22/2003 14:21'!lineSegmentsDo: endPointsBlock 	"Emit a sequence of segment endpoints into endPointsBlock."	| n t x y x1 x2 x3 y1 y2 y3 beginPoint endPoint cs |	smoothCurve 		ifFalse: 			[beginPoint := nil.			vertices do: 					[:vert | 					beginPoint ifNotNil: [endPointsBlock value: beginPoint value: vert].					beginPoint := vert].			(closed or: [vertices size = 1]) 				ifTrue: [endPointsBlock value: beginPoint value: vertices first].			^self].	"For curves we include all the interpolated sub segments."	vertices size < 1 ifTrue: [^self].	cs := self coefficients.	beginPoint := (x := cs first first) @ (y := cs fifth first).	1 to: cs first size - 1		do: 			[:i | 			"taylor series coefficients"			x1 := cs second at: i.			y1 := cs sixth at: i.			x2 := (cs third at: i) / 2.0.			y2 := (cs seventh at: i) / 2.0.			x3 := (cs fourth at: i) / 6.0.			y3 := ((cs eighth) at: i) / 6.0.			"guess n"			n := 5 						max: (((x2 abs + y2 abs) * 2.0 + (cs third at: i + 1) abs 								+ (cs seventh at: i + 1) abs) / 100.0) 								rounded.			1 to: n - 1				do: 					[:j | 					t := j asFloat / n.					endPoint := (((x3 * t + x2) * t + x1) * t + x) 								@ (((y3 * t + y2) * t + y1) * t + y).					endPointsBlock value: beginPoint value: endPoint.					beginPoint := endPoint].			endPoint := (x := cs first at: i + 1) @ (y := cs fifth at: i + 1).			endPointsBlock value: beginPoint value: endPoint.			beginPoint := endPoint]! !!PolygonMorph methodsFor: 'smoothing' stamp: 'dgd 2/22/2003 18:57'!nextToFirstPoint	"For arrow direction"	smoothCurve 		ifTrue: 			[curveState ifNil: [self coefficients].			^curveState second]		ifFalse: [^vertices second]! !!PolygonMorph methodsFor: 'smoothing' stamp: 'dgd 2/22/2003 18:58'!nextToLastPoint	"For arrow direction"	smoothCurve 		ifTrue: 			[curveState ifNil: [self coefficients].			^curveState third]		ifFalse: [^vertices at: vertices size - 1]! !!PolygonMorph methodsFor: 'stepping and presenter' stamp: 'dgd 2/22/2003 18:58'!step	borderDashSpec ifNil: [^super step].	borderDashSpec size < 5 ifTrue: [^super step].	"Only for dashed lines with creep"	borderDashSpec at: 4 put: (borderDashSpec fourth) + borderDashSpec fifth.	self changed.	^super step! !!PolygonMorph methodsFor: 'testing' stamp: 'dgd 2/22/2003 18:58'!wantsSteps	super wantsSteps ifTrue: [^true].	"For crawling ants effect of dashed line."	borderDashSpec ifNil: [^false].	^borderDashSpec size = 5 and: [(borderDashSpec fifth) > 0]! !!PolygonMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 18:56'!computeArrowFormAt: endPoint from: priorPoint 	"Compute a triangle oriented along the line from priorPoint to  	endPoint. Then draw those lines in a form and return that  	form, with appropriate offset"	| p1 pts box arrowForm bb origin |	pts := self arrowBoundsAt: endPoint from: priorPoint.	box := ((pts first rect: pts last) encompass: (pts second)) expandBy: 1.	arrowForm := Form extent: box extent asIntegerPoint.	bb := (BitBlt current toForm: arrowForm)				sourceForm: nil;				fillColor: Color black;				combinationRule: Form over;				width: 1;				height: 1.	origin := box topLeft.	p1 := pts last - origin.	pts do: 			[:p | 			bb drawFrom: p1 to: p - origin.			p1 := p - origin].	arrowForm convexShapeFill: Color black.	^arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 14:15'!curveBounds	| curveBounds pointAfterFirst pointBeforeLast |	smoothCurve 		ifFalse: 			[^(Rectangle encompassing: vertices) expandBy: (borderWidth + 1) // 2].	"Compute the bounds from actual curve traversal, with leeway for borderWidth.	Also note the next-to-first and next-to-last points for arrow directions."	curveState := nil.	"Force recomputation"	curveBounds := vertices first corner: vertices last.	pointAfterFirst := nil.	self lineSegmentsDo: 			[:p1 :p2 | 			pointAfterFirst isNil 				ifTrue: 					[pointAfterFirst := p2 asIntegerPoint.					curveBounds := curveBounds encompass: p1 asIntegerPoint].			curveBounds := curveBounds encompass: p2 asIntegerPoint.			pointBeforeLast := p1 asIntegerPoint].	curveState at: 2 put: pointAfterFirst.	curveState at: 3 put: pointBeforeLast.	^curveBounds expandBy: (borderWidth + 1) // 2! !!BalloonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:33'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!BalloonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!BalloonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ self class balloonColor! !!BalloonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:20'!initialize	"initialize the state of the receiver"	super initialize.	""	self beSmoothCurve.	offsetFromTarget _ 0 @ 0! !!BlobMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ random next < 0.25		ifTrue: [Color random]		ifFalse: [Color random alpha: random next * 0.4 + 0.4]! !!BlobMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:42'!initialize	"initialize the state of the receiver"	random _ Random new.	sneaky _ random next < 0.75.	super initialize.""	self beSmoothCurve; initializeBlobShape; setVelocity! !!BlobMPEGMorph methodsFor: 'initialization' stamp: 'aoy 2/15/2003 21:43'!initialize: primaryFlag mpegPlayer: aMpegPlayerOrFileName 	| rect sizeToOverLapBoundary |	primary := primaryFlag.	rect := self bounds.	sizeToOverLapBoundary := 3.0.	mpegLogic := primary 				ifTrue:  					[form := Form 								extent: ((sizeToOverLapBoundary * rect width) 										@ (sizeToOverLapBoundary * rect height)) truncated								depth: 32.					movieDrawArea := SketchMorph withForm: form.					MPEGPlayer playFile: aMpegPlayerOrFileName onMorph: movieDrawArea]				ifFalse: 					[form := aMpegPlayerOrFileName form.					movieDrawArea := aMpegPlayerOrFileName movieDrawArea.					aMpegPlayerOrFileName mpegLogic]! !!EnvelopeLineMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/14/2003 20:17'!vertices: verts borderWidth: bw borderColor: bc 	super initialize.	vertices _ verts.		borderWidth _ bw.	borderColor _ bc.	closed _ false.	arrows _ #none.	self computeBounds! !!EnvelopeLineMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor"answer the default color/fill style for the receiver"	^ Color transparent! !!LipsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!LipsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!LipsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!LipsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:18'!initialize	"initialize the state of the receiver"	super initialize.	""	self beSmoothCurve.	vertices _ {11 @ 3. 35 @ 1. 60 @ 5. 67 @ 17. 34 @ 24. 3 @ 17}.		closed _ true.	self neutral; updateShape! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'dgd 2/21/2003 23:06'!outlinePolygon: vertices 	target moveto: (vertices first).	2 to: vertices size do: [:i | target lineto: (vertices at: i)].	target closepath! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'dgd 2/21/2003 23:06'!outlineQuardraticBezierShape: vertices 	target moveto: (vertices first).	3 to: vertices size		by: 3		do: 			[:i | 			target 				curvetoQuadratic: (vertices at: i)				from: (vertices at: i - 2)				via: (vertices at: i - 1)].	target closepath! !!PostscriptCanvas methodsFor: 'drawing support' stamp: 'gm 2/24/2003 18:07'!stroke: strokeColor 	strokeColor ifNil: [^self].	(strokeColor isKindOf: Symbol) 		ifTrue: [^self paint: Color gray operation: #stroke	"punt"].	strokeColor isSolidFill 		ifTrue: [^self paint: strokeColor asColor operation: #stroke].	self preserveStateDuring: 			[:inner | 			inner				strokepath;				fill: strokeColor]! !!PostscriptCanvas methodsFor: 'drawing-polygons' stamp: 'gm 2/24/2003 18:07'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc 	self		outlinePolygon: vertices;		setLinewidth: bw;		fill: aColor			andStroke: ((bc isKindOf: Symbol) ifTrue: [Color gray] ifFalse: [bc])! !!PostscriptCanvas methodsFor: 'initialization' stamp: 'dgd 2/22/2003 19:38'!initializeFontMap	"Initialize the dictionary mapping message names to actions for C code generation."	fontMap := Dictionary new.	fontMap		at: 'NewYork' put: self fontsForNewYork;		at: 'Helvetica' put: self fontsForHelvetica;		at: 'Palatino' put: self fontsForPalatino;		at: 'ComicBold' put: self fontsForComicBold;		at: 'ComicPlain' put: self fontsForComicPlain! !!DSCPostscriptCanvas methodsFor: 'as yet unclassified' stamp: 'aoy 2/15/2003 21:46'!pageBBox	| pageSize offset bbox trueExtent |	trueExtent := EPSCanvas bobsPostScriptHacks 		ifTrue: [savedMorphExtent	"this one has been rotated"]		ifFalse: [psBounds extent].	pageSize := self defaultImageableArea.	offset := ((pageSize extent - trueExtent) / 2 max: 0 @ 0) 				+ self defaultMargin.	bbox := offset extent: psBounds extent.	^bbox! !!PreferencesPanel class methodsFor: 'cleanup' stamp: 'gm 2/22/2003 18:58'!deleteAllPreferencesPanels	"Called manually to clobber all existing preferences panels"	"PreferencesPanel deleteAllPreferencesPanels"	| aWindow |	self allInstancesDo:		[:aPanel |			(aWindow _ aPanel containingWindow) isMorph				ifTrue:					[aWindow delete]].	self killExistingMVCViews.	UpdatingThreePhaseButtonMorph allInstancesDo: "clobber old stand-alone prefs buttons"		[:m | (m actionSelector == #togglePreference:) ifTrue:			[(m owner isAlignmentMorph) ifTrue:				[m owner delete]]]! !!Presenter methodsFor: 'misc' stamp: 'dgd 2/22/2003 19:08'!currentlyViewing: aPlayer 	"Only detects viewers in tabs"	aPlayer ifNil: [^false].	^aPlayer viewerFlapTab notNil! !!Presenter methodsFor: 'playerList' stamp: 'dgd 2/22/2003 19:08'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.Call #flushPlayerListCache to force recomputation."	playerList ifNotNil: [^playerList].	^playerList := (associatedMorph allMorphs select: [:m | m player notNil]				thenCollect: [:m | m player]) asSet 				asArray! !!Presenter methodsFor: 'playerList' stamp: 'dgd 2/21/2003 22:35'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList := self uniclassesAndCounts) isEmpty 		ifTrue: [^self inform: 'there are no scripted players'].	aString := String streamContents: 					[:aStream | 					aList do: 							[:aPair | 							aStream 								nextPutAll: aPair first name , ' -- ' , aPair second printString 										, ' instance' , (aPair second > 1 ifTrue: ['s'] ifFalse: ['']) 										, ', named '.							aPair first allInstancesDo: 									[:inst | 									aStream										space;										nextPutAll: inst externalName].							aStream cr].					aStream cr.					aList do: 							[:aPair | 							aStream cr.							aStream 								nextPutAll: '--------------------------------------------------------------------------------------------'.							aStream								cr;								nextPutAll: aPair first name.							aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString) 		openLabel: 'All scripts of all players in this world'	"self currentWorld presenter reportPlayersAndScripts"! !!Presenter methodsFor: 'tile support' stamp: 'dgd 2/22/2003 19:08'!booleanTiles	"Answer some boolean-valued tiles.  This dates back to very early etoy work in 1997, and presently has no sent senders"	| list rcvr op arg |	list := #(#(0 #< 1) #(0 #<= 1) #(0 #= 1) #(0 #~= 1) #(0 #> 1) #(0 #>= 1)).	list := list asOrderedCollection collect: 					[:entry | 					rcvr := entry first.					op := (entry second) asSymbol.					arg := entry last.					self 						phraseForReceiver: rcvr						op: op						arg: arg						resultType: #Boolean].	list add: (self 				phraseForReceiver: Color red				op: #=				arg: Color red				resultType: #Boolean).	^list	"copyWith: CompoundTileMorph new"! !!Presenter methodsFor: 'tile support' stamp: 'gm 2/22/2003 14:53'!constantTile: anObject 	"Answer a constant tile that represents the object"	(anObject isColor) 		ifTrue: 			[^ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)].	^anObject newTileMorphRepresentative 		typeColor: (ScriptingSystem colorForType: (self typeForConstant: anObject))! !!Presenter methodsFor: 'tile support' stamp: 'dgd 2/21/2003 22:35'!phraseForReceiver: rcvr op: op arg: arg resultType: resultType 	"Answer a PhraseTileMorph affiliated with the given receiver, initialized to hold the given operator, argument, and result type"	| m argTile rcvrTile |	arg isNil 		ifTrue: 			[m := PhraseTileMorph new 						setOperator: op						type: resultType						rcvrType: (self typeForConstant: rcvr)]		ifFalse: 			[m := PhraseTileMorph new 						setOperator: op						type: resultType						rcvrType: (self typeForConstant: rcvr)						argType: (self typeForConstant: arg).			argTile := self constantTile: arg.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	rcvrTile := self constantTile: rcvr.	"	TilePadMorph makeReceiverColorOfResultType ifTrue: [rcvrTile color: m color]."	rcvrTile position: m firstSubmorph position.	m firstSubmorph addMorph: rcvrTile.	m vResizing: #shrinkWrap.	^m! !!Presenter methodsFor: 'viewer' stamp: 'dgd 2/22/2003 19:09'!viewMorph: aMorph 	| aPlayer aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown 		ifFalse: 			[((aPalette := aMorph standardPalette) notNil and: [aPalette isInWorld]) 				ifTrue: [^aPalette viewMorph: aMorph]].	aPlayer := (topItem := aMorph topRendererOrSelf) assuredPlayer.	aViewer := self nascentPartsViewer.	self cacheSpecs: topItem.	"redo the spec cache once in a while"	"19 sept 2000 - allow flaps in any paste up"	flapLoc := associatedMorph.	"world"	Preferences viewersInFlaps 		ifTrue: 			[aViewer setProperty: #noInteriorThumbnail toValue: true.			aViewer initializeFor: aPlayer barHeight: 0.			aViewer enforceTileColorPolicy.			aViewer fullBounds.	"force layout"			"associatedMorph addMorph: aViewer."	"why???"			flapLoc hideViewerFlapsOtherThanFor: aPlayer.			aFlapTab := flapLoc viewerFlapTabFor: topItem.			aFlapTab referent submorphs 				do: [:m | (m isKindOf: Viewer) ifTrue: [m delete]].			aViewer visible: true.			aFlapTab applyThickness: aViewer width + 25.			aFlapTab spanWorld.			aFlapTab showFlap.			aViewer position: aFlapTab referent position.			aFlapTab referent addMorph: aViewer beSticky.	"moved"			flapLoc startSteppingSubmorphsOf: aFlapTab.			flapLoc startSteppingSubmorphsOf: aViewer.			^aFlapTab].	aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds.	"force layout"	Preferences automaticViewerPlacement 		ifTrue: 			[aPoint := aMorph bounds right 						@ (aMorph center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).			aRect := (aPoint extent: aViewer width @ nominalHeight) 						translatedToBeWithin: flapLoc bounds.			aViewer position: aRect topLeft.			aViewer visible: true.			associatedMorph addMorph: aViewer.			flapLoc startSteppingSubmorphsOf: aViewer.			"it's already in the world, somewhat coincidentally"			^aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Project methodsFor: 'menu messages' stamp: 'gm 2/16/2003 20:37'!viewLocFor: exitedProject 	"Look for a view of the exitedProject, and return its center"	| ctlr |	world isMorph 		ifTrue: 			[world submorphsDo: 					[:v | 					((v isSystemWindow) and: [v model == exitedProject]) 						ifTrue: [^v center]]]		ifFalse: 			[ctlr := world controllerWhoseModelSatisfies: [:p | p == exitedProject].			ctlr ifNotNil: [^ctlr view windowBox center]].	^Sensor cursorPoint	"default result"! !!Project methodsFor: 'release' stamp: 'gm 2/16/2003 20:37'!subProjects	"Answer a list of all the subprojects  of the receiver.  This is nastily idiosyncratic."	^self isMorphic 		ifTrue: 			[world submorphs 				select: [:m | (m isSystemWindow) and: [m model isKindOf: Project]]				thenCollect: [:m | m model]]		ifFalse: 			[(world controllersSatisfying: [:m | m model isKindOf: Project]) 				collect: [:c | c model]]! !!Project class methodsFor: 'squeaklet on server' stamp: 'gm 2/16/2003 20:50'!openBlankProjectNamed: projName	| proj projViewer |	proj _ Project newMorphicOn: nil.	proj changeSet name: projName.	proj world addMorph: (		TextMorph new 			beAllFont: ((TextStyle default fontOfSize: 26) emphasized: 1);			color: Color red;			contents: 'Welcome to a new project - ',projName	).	CurrentProjectRefactoring currentBeParentTo: proj.	projViewer _ (CurrentProject findProjectView: projName) ifNil: [^proj].	(projViewer owner isSystemWindow) ifTrue: [			projViewer owner model: proj].	^ projViewer project: proj! !!ProjectLoading class methodsFor: 'as yet unclassified' stamp: 'gm 2/16/2003 20:51'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNil withProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world." 	| morphOrList proj trusted localDir projStream archive mgr projectsToBeDeleted baseChangeSet |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"		^self inform: 'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,'	].	ProgressNotification signal: '2:fileSizeDetermined ',preStream size printString.	preStream isZipArchive 		ifTrue:[	archive _ ZipArchive new readFrom: preStream.				projStream _ self projectStreamFromArchive: archive]		ifFalse:[projStream _ preStream].	trusted _ SecurityManager default positionToSecureContentsOf: projStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		(preStream respondsTo: #close) ifTrue:[preStream close].		^self]].	localDir _ Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName ~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) 				nextPutAll: preStream contents;				close.		].	].	morphOrList _ projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet _ Smalltalk changes.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	[morphOrList _ morphOrList fileInObjectAndCode] ensure: [				Smalltalk newChanges: baseChangeSet].	mgr _ ResourceManager new initializeFrom: ResourceCollector current.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName: aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj _ morphOrList arrayOfRoots 			detect: [:mm | mm class == Project] 			ifNone: [^self inform: 'No project found in this file'].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		CurrentProjectRefactoring currentBeParentTo: proj.		projectsToBeDeleted _ OrderedCollection new.		existingView ifNil: [			Smalltalk isMorphic ifTrue: [				proj createViewIfAppropriate.			] ifFalse: [				ChangeSorter allChangeSets add: proj changeSet.				ProjectView openAndEnter: proj.				"Note: in MVC we get no further than the above"			].		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSorter allChangeSets add: proj changeSet.		Project current projectParameters 			at: #deleteWhenEnteringNewProject 			ifPresent: [ :ignored | 				projectsToBeDeleted add: Project current.				Project current removeParameter: #deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters 				at: #projectsToBeDeleted 				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	(morphOrList isKindOf: SqueakPage) ifTrue: [		morphOrList _ morphOrList contentsMorph	].	(morphOrList isKindOf: PasteUpMorph) ifFalse: [		^ self inform: 'This is not a PasteUpMorph or exported Project.'	].	(Project newMorphicOn: morphOrList) enter! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'gm 2/22/2003 13:14'!safeProjectName	| projectName args |	projectName := self valueOfProperty: #SafeProjectName ifAbsent: ['???'].	self isTheRealProjectPresent 		ifFalse: 			[project class == DiskProxy 				ifTrue: 					[args := project constructorArgs.					((args isKindOf: Array) 						and: [args size = 1 and: [args first isString]]) 							ifTrue: [^args first]]				ifFalse: [^projectName]].	self setProperty: #SafeProjectName toValue: project name.	^project name! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'gm 2/16/2003 20:34'!safeProjectName: aString 	self addProjectNameMorphFiller.	self isTheRealProjectPresent ifFalse: [^self].	project renameTo: aString.	self setProperty: #SafeProjectName toValue: project name.	self updateNamePosition.	(owner isSystemWindow) ifTrue: [owner setLabel: aString]! !!ProjectViewMorph methodsFor: 'events' stamp: 'gm 2/16/2003 20:34'!enter	"Enter my project."	self world == self outermostWorldMorph ifFalse: [^1 beep].	"can't do this at the moment"	project class == DiskProxy 		ifFalse: 			[(project world notNil and: 					[project world isMorph 						and: [project world hasOwner: self outermostWorldMorph]]) 				ifTrue: [^1 beep	"project is open in a window already"]].	project class == DiskProxy 		ifTrue: 			["When target is not in yet"			self enterWhenNotPresent.	"will bring it in"			project class == DiskProxy ifTrue: [^self inform: 'Project not found']].	(owner isSystemWindow) ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project 		enter: false		revert: false		saveForRevert: false! !!ProjectViewMorph methodsFor: 'events' stamp: 'gm 2/16/2003 20:34'!enterAsActiveSubproject	"Enter my project."	project class == DiskProxy 		ifTrue: 			["When target is not in yet"			[self enterWhenNotPresent	"will bring it in"] on: ProjectEntryNotification				do: [:ex | ^ex projectToEnter enterAsActiveSubprojectWithin: self world].			project class == DiskProxy ifTrue: [self error: 'Could not find view']].	(owner isSystemWindow) ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project enterAsActiveSubprojectWithin: self world! !!ProjectViewMorph methodsFor: 'rounding' stamp: 'gm 2/16/2003 20:34'!wantsRoundedCorners	^Preferences roundedWindowCorners 		and: [(owner isSystemWindow) not]! !!RectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.613		g: 0.903		b: 1.0! !!AbstractMediaEventMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!AbstractMediaEventMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color paleYellow! !!AbstractMediaEventMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:38'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutPolicy: TableLayout new;	  listDirection: #leftToRight;	  wrapCentering: #topLeft;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  layoutInset: 2;	  rubberBandCells: true! !!AlignmentMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:02'!basicInitialize	"Do basic generic initialization of the instance variables"	super basicInitialize.	""	self layoutPolicy: TableLayout new;	  listDirection: #leftToRight;	  wrapCentering: #topLeft;	  hResizing: #spaceFill;	  vResizing: #spaceFill;	  layoutInset: 2;	  rubberBandCells: true! !!AlignmentMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 0! !!AlignmentMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 0.8! !!AlignmentMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:19'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutPolicy: TableLayout new;	 listDirection: #leftToRight;	 wrapCentering: #topLeft;	 hResizing: #spaceFill;	 vResizing: #spaceFill;	 layoutInset: 2;	 rubberBandCells: true! !!AlignmentMorph methodsFor: 'object fileIn' stamp: 'gm 2/22/2003 13:12'!convertOldAlignmentsNov2000: varDict using: smartRefStrm 	"major change - much of AlignmentMorph is now implemented more generally in Morph"	"These are going away 	#('orientation' 'centering' 'hResizing' 'vResizing' 	'inset' 'minCellSize' 'layoutNeeded' 'priorFullBounds')"	| orientation centering hResizing vResizing inset minCellSize inAlignment |	orientation := varDict at: 'orientation'.	centering := varDict at: 'centering'.	hResizing := varDict at: 'hResizing'.	vResizing := varDict at: 'vResizing'.	inset := varDict at: 'inset'.	minCellSize := varDict at: 'minCellSize'.	(orientation == #horizontal or: [orientation == #vertical]) 		ifTrue: [self layoutPolicy: TableLayout new].	self cellPositioning: #topLeft.	self rubberBandCells: true.	orientation == #horizontal ifTrue: [self listDirection: #leftToRight].	orientation == #vertical ifTrue: [self listDirection: #topToBottom].	centering == #topLeft ifTrue: [self wrapCentering: #topLeft].	centering == #bottomRight ifTrue: [self wrapCentering: #bottomRight].	centering == #center 		ifTrue: 			[self wrapCentering: #center.			orientation == #horizontal 				ifTrue: [self cellPositioning: #leftCenter]				ifFalse: [self cellPositioning: #topCenter]].	(inset isNumber or: [inset isPoint]) ifTrue: [self layoutInset: inset].	(minCellSize isNumber or: [minCellSize isPoint]) 		ifTrue: [self minCellSize: minCellSize].	(self hasProperty: #clipToOwnerWidth) ifTrue: [self clipSubmorphs: true].	"now figure out if our owner was an AlignmentMorph, even if it is reshaped..."	inAlignment := false.	owner isMorph 		ifTrue: [(owner isAlignmentMorph) ifTrue: [inAlignment := true]]		ifFalse: 			["e.g., owner may be reshaped"			(owner class instanceVariablesString 				findString: 'orientation centering hResizing vResizing') > 0 				ifTrue: 					["this was an alignment morph being reshaped"					inAlignment := true]].	"And check for containment in system windows"	owner isSystemWindow ifTrue: [inAlignment := true].	(hResizing == #spaceFill and: [inAlignment not]) 		ifTrue: [self hResizing: #shrinkWrap]		ifFalse: [self hResizing: hResizing].	(vResizing == #spaceFill and: [inAlignment not]) 		ifTrue: [self vResizing: #shrinkWrap]		ifFalse: [self vResizing: vResizing]! !!AllScriptsTool methodsFor: 'parts bin' stamp: 'dgd 2/22/2003 19:37'!initializeToStandAlone	super initializeToStandAlone.	self		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		hResizing: #spaceFill;		extent: 1 @ 1;		vResizing: #spaceFill;		rubberBandCells: true.	self initializeFor: self currentWorld presenter! !!BalloonRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:33'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ GradientFillStyle ramp: {0.0 -> Color black. 1.0 -> Color white}! !!BalloonRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 10! !!BalloonRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	| result |	result _ GradientFillStyle ramp: {0.0 -> Color green. 0.5 -> Color yellow. 1.0 -> Color red}.	result radial: true.	^ result! !!BalloonRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:41'!initialize"initialize the state of the receiver"	super initialize.""	self extent: 100 @ 100! !!BasicButton methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:33'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color yellow darker! !!BasicButton methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!BasicButton methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color yellow! !!BasicButton methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:52'!initialize	"initialize the state of the receiver"	super initialize.	""	self label: 'Button'; useRoundedCorners! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/17/2003 19:56'!changeExtent: aPoint 	self extent: aPoint.	pageHolder extent: self extent - self borderWidth! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:55'!defaultBorderWidth"answer the default border width for the receiver"	^ 2! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:55'!defaultColor"answer the default color/fill style for the receiver"	^ Color lightGray! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:56'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: Display extent - 100;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 3.	pageHolder _ PasteUpMorph new behaveLikeHolder extent: self extent -self borderWidth.	pageHolder hResizing: #shrinkWrap.	"pageHolder cursor: 0."	"causes a walkback as of 5/25/2000"	self addControls.	self addMorphBack: pageHolder! !!BooklikeMorph methodsFor: 'page controls' stamp: 'dgd 2/22/2003 14:14'!showPageControls: controlSpecs 	| spacer pageControls anIndex |	self hidePageControls.	anIndex := (submorphs notEmpty and: [submorphs first hasProperty: #header]) 				ifTrue: [2]				ifFalse: [1].	spacer := (Morph new)				color: color;				extent: 0 @ 10.	spacer setProperty: #pageControl toValue: true.	self privateAddMorph: spacer atIndex: anIndex.	pageControls := self makePageControlsFrom: controlSpecs.	pageControls		borderWidth: 0;		layoutInset: 4.	pageControls setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	pageControls eventHandler: (EventHandler new 				on: #mouseDown				send: #move				to: self).	self privateAddMorph: pageControls beSticky atIndex: anIndex! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:10'!fromRemoteStream: strm 	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!  Index and pages must live in the same directory.  If the book has moved, save the current correct urls for each of the pages.  Self must already have a url stored in property #url."	| remote dict bookUrl oldStem stem oldUrl endPart |	remote := strm fileInObjectAndCode.	bookUrl := (SqueakPage new)				url: (self valueOfProperty: #url);				url.	"expand a relative url"	oldStem := SqueakPage stemUrl: (remote second) url.	oldStem := oldStem copyUpToLast: $/.	stem := SqueakPage stemUrl: bookUrl.	stem := stem copyUpToLast: $/.	oldStem = stem 		ifFalse: 			["Book is in new directory, fix page urls"			2 to: remote size				do: 					[:ii | 					oldUrl := (remote at: ii) url.					endPart := oldUrl copyFrom: oldStem size + 1 to: oldUrl size.					(remote at: ii) url: stem , endPart]].	self initialize.	pages := OrderedCollection new.	2 to: remote size do: [:ii | pages add: (remote at: ii)].	currentPage		fullReleaseCachedState;		delete.	"the blank one"	currentPage := remote second.	dict := remote first.	self setProperty: #modTime toValue: (dict at: #modTime).	dict at: #allText		ifPresent: [:val | self setProperty: #allText toValue: val].	dict at: #allTextUrls		ifPresent: [:val | self setProperty: #allTextUrls toValue: val].	#(#color #borderWidth #borderColor #pageSize) 		with: #(#color: #borderWidth: #borderColor: #pageSize:)		do: [:key :sel | dict at: key ifPresent: [:val | self perform: sel with: val]].	^self! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:09'!initialize"initialize the state of the receiver"	super initialize.""	self setInitialState.	pages _ OrderedCollection new.	self showPageControls.	self class		turnOffSoundWhile: [self insertPage]! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:07'!setInitialState	self listDirection: #topToBottom;	  wrapCentering: #topLeft;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  layoutInset: 5.	pageSize _ 160 @ 300.	self enableDragNDrop! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 2/21/2003 23:10'!insertPage: aPage pageSize: aPageSize atIndex: anIndex 	| sz predecessor |	sz := aPageSize 				ifNil: [currentPage isNil ifTrue: [pageSize] ifFalse: [currentPage extent]]				ifNotNil: [aPageSize].	aPage extent: sz.	(pages isEmpty | anIndex isNil or: [anIndex > pages size]) 		ifTrue: [pages add: aPage]		ifFalse: 			[anIndex <= 1 				ifTrue: [pages addFirst: aPage]				ifFalse: 					[predecessor := anIndex isNil 								ifTrue: [currentPage]								ifFalse: [pages at: anIndex].					self pages add: aPage after: predecessor]].	self goToPageMorph: aPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 2/21/2003 23:11'!insertPageColored: aColor 	"Insert a new page for the receiver, using the given color as its background color"	| sz newPage bw bc |	bc := currentPage isNil 				ifTrue: 					[sz := pageSize.					bw := 0.					Color blue muchLighter]				ifFalse: 					[sz := currentPage extent.					bw := currentPage borderWidth.					currentPage borderColor].	newPagePrototype ifNil: 			[newPage := (PasteUpMorph new)						extent: sz;						color: aColor.			newPage				borderWidth: bw;				borderColor: bc]		ifNotNil: [Cursor wait showWhile: [newPage := newPagePrototype veryDeepCopy]].	newPage setNameTo: self defaultNameStemForNewPages.	newPage vResizeToFit: false.	pages isEmpty 		ifTrue: [pages add: (currentPage := newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 2/21/2003 23:11'!insertPageSilentlyAtEnd	"Create a new page at the end of the book.  Do not turn to it."	| sz newPage bw bc cc |	cc := currentPage isNil 				ifTrue: 					[sz := pageSize.					bw := 0.					bc := Color blue muchLighter.					color]				ifFalse: 					[sz := currentPage extent.					bw := currentPage borderWidth.					bc := currentPage borderColor.					currentPage color].	newPagePrototype ifNil: 			[newPage := (PasteUpMorph new)						extent: sz;						color: cc.			newPage				borderWidth: bw;				borderColor: bc]		ifNotNil: [Cursor wait showWhile: [newPage := newPagePrototype veryDeepCopy]].	newPage setNameTo: self defaultNameStemForNewPages.	newPage vResizeToFit: false.	pages isEmpty 		ifTrue: [pages add: (currentPage := newPage)	"had been none"]		ifFalse: [pages add: newPage after: pages last].	^newPage! !!BookMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:17'!findText: keys inStrings: rawStrings startAt: startIndex container: oldContainer pageNum: pageNum 	"Call once to search a page of the book.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start wasIn strings old |	good := true.	start := startIndex.	strings := oldContainer ifNil: 					["normal case"					rawStrings]				ifNotNil: 					[(pages at: pageNum) isInMemory 						ifFalse: [rawStrings]						ifTrue: [(pages at: pageNum) allStringsAfter: oldContainer]].	keys do: 			[:searchString | 			"each key"			good 				ifTrue: 					[thisWord := false.					strings do: 							[:longString | 							(index := longString 										findString: searchString										startingAt: start										caseSensitive: false) > 0 								ifTrue: 									[thisWord not & (searchString == keys first) 										ifTrue: 											[insideOf := longString.											place := index].									thisWord := true].							start := 1].	"only first key on first container"					good := thisWord]].	good 		ifTrue: 			["all are on this page"			wasIn := (pages at: pageNum) isInMemory.			self goToPage: pageNum.			wasIn 				ifFalse: 					["search again, on the real current text.  Know page is in."					^self 						findText: keys						inStrings: ((pages at: pageNum) allStringsAfter: nil)						startAt: startIndex						container: oldContainer						pageNum: pageNum	"recompute"]].	(old := self valueOfProperty: #searchContainer) ifNotNil: 			[(old respondsTo: #editor) 				ifTrue: 					[old editor selectFrom: 1 to: 0.	"trying to remove the previous selection!!"					old changed]].	good 		ifTrue: 			["have the exact string object"			(container := oldContainer) ifNil: 					[container := self 								highlightText: keys first								at: place								in: insideOf]				ifNotNil: 					[container userString == insideOf 						ifFalse: 							[container := self 										highlightText: keys first										at: place										in: insideOf]						ifTrue: 							[(container isTextMorph) 								ifTrue: 									[container editor selectFrom: place to: keys first size - 1 + place.									container changed]]].			self setProperty: #searchContainer toValue: container.			self setProperty: #searchOffset toValue: place.			self setProperty: #searchKey toValue: keys.	"override later"			ActiveHand newKeyboardFocus: container.			^true].	^false! !!BookMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:17'!highlightText: stringToHilite at: index in: insideOf 	"Find the container with this text and highlight it.  May not be able to do it for stringMorphs."	"Find the container with that text"	| container |	self 		allMorphsDo: [:sub | insideOf == sub userString ifTrue: [container := sub]].	container ifNil: 			[self 				allMorphsDo: [:sub | insideOf = sub userString ifTrue: [container := sub]]].	"any match"	container ifNil: [^nil].	"Order it highlighted"	(container isTextMorph) 		ifTrue: 			[container editor selectFrom: index to: stringToHilite size - 1 + index].	container changed.	^container! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:11'!loadImagesIntoBook	"PowerPoint stores GIF presentations as individual slides named Slide1, Slide2, etc.	Load these into the book.  mjg 9/99"	| directory filenumber form newpage |	directory := ((StandardFileMenu oldFileFrom: FileDirectory default) 				ifNil: [^nil]) directory.	directory isNil ifTrue: [^nil].	"Start loading 'em up!!"	filenumber := 1.	[directory fileExists: 'Slide' , filenumber asString] whileTrue: 			[Transcript				show: 'Slide' , filenumber asString;				cr.			Smalltalk bytesLeft < 1000000 				ifTrue: 					["Make some room"					(self valueOfProperty: #url) isNil 						ifTrue: [self savePagesOnURL]						ifFalse: [self saveAsNumberedURLs]].			form := Form 						fromFileNamed: (directory fullNameFor: 'Slide' , filenumber asString).			newpage := PasteUpMorph new extent: form extent.			newpage addMorph: (SketchMorph withForm: form).			self pages addLast: newpage.			filenumber := filenumber + 1].	"After adding all, delete the first page."	self goToPage: 1.	self deletePageBasic.	"Save the book"	(self valueOfProperty: #url) isNil 		ifTrue: [self savePagesOnURL]		ifFalse: [self saveAsNumberedURLs]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:49'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url := self valueOfProperty: #url) ifNil: 			["for .bo index file"			url := FillInTheBlank 						request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://'						initialAnswer: self getStemUrl , '.bo'.			url notEmpty ifTrue: [self setProperty: #url toValue: url] ifFalse: [^self]].	onServer := self class new fromURL: url.	"Later: test book times?"	onPgs := onServer pages collect: 					[:out | 					sq := SqueakPageCache pageCache at: out url ifAbsent: [nil].					(sq notNil and: [sq contentsMorph isInMemory]) 						ifTrue: 							[(out sqkPage lastChangeTime > sq lastChangeTime 								or: [sq contentsMorph isNil]) 									ifTrue: 										[SqueakPageCache atURL: out url put: out sqkPage.										out]									ifFalse: [sq contentsMorph]]						ifFalse: 							[SqueakPageCache atURL: out url put: out sqkPage.							out]].	which := (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.	"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls		toValue: (onServer valueOfProperty: #allTextUrls)! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12'!reserveUrls	"Save a dummy version of the book first, assign all pages URLs, write dummy files to reserve the url, and write the index.  Good when I have pages with interpointing bookmarks."	| stem |	(stem := self getStemUrl) isEmpty ifTrue: [^self].	pages doWithIndex: 			[:pg :ind | 			"does write the current page too"			pg url ifNil: [pg reserveUrl: stem , ind printString , '.sp']]	"self saveIndexOnURL."! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12'!saveAsNumberedURLs	"Write out all pages in this book that are not showing, onto a server.  The local disk could be the server.  For any page that does not have a SqueakPage and a url already, name that page file by its page number.  Any pages that are already totally out will stay that way."	| stem list firstTime |	firstTime := (self valueOfProperty: #url) isNil.	stem := self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^self].	firstTime ifTrue: [self setProperty: #futureUrl toValue: stem , '.bo'].	self reserveUrlsIfNeeded.	pages doWithIndex: 			[:aPage :ind | 			"does write the current page too"			aPage isInMemory 				ifTrue: 					["not out now"					aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].					aPage saveOnURL: stem , ind printString , '.sp']].	list := pages collect: [:aPage | aPage sqkPage prePurge].	"knows not to purge the current page"	list := (list select: [:each | each notNil]) asArray.	"do bulk become:"	(list collect: [:each | each contentsMorph]) 		elementsExchangeIdentityWith: (list 				collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).	self saveIndexOnURL.	self presenter ifNotNil: [self presenter flushPlayerListCache].	firstTime 		ifTrue: 			["Put a thumbnail into the hand"			URLMorph grabForBook: self.			self setProperty: #futureUrl toValue: nil	"clean up"]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12'!saveIndexOfOnly: aPage 	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL. (page file names must be unique even if they live in different directories.)"	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls fName |	mine := self valueOfProperty: #url.	mine ifNil: [^self saveIndexOnURL].	Cursor wait showWhile: [strm := ServerFile new fullPath: mine].	strm ifNil: [^self saveIndexOnURL].	strm class == String ifTrue: [^self saveIndexOnURL].	strm exists ifFalse: [^self saveIndexOnURL].	"write whole thing if missing"	strm := strm asStream.	strm class == String ifTrue: [^self saveIndexOnURL].	remote := strm fileInObjectAndCode.	dict := remote first.	allText := dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls := dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size 		ifTrue: 			[self 				error: '.bo size mismatch.  Please tell Ted what you just did to this book.'].	(pageURL := aPage url) ifNil: [self error: 'just had one!!'].	fName := pageURL copyAfterLast: $/.	2 to: remote size		do: 			[:ii | 			((remote at: ii) url 				findString: fName				startingAt: 1				caseSensitive: false) > 0 				ifTrue: [index := ii].	"fast"			(remote at: ii) xxxReset].	index ifNil: 			["new page, what existing page does it follow?"			num := self pageNumberOf: aPage.			1 to: num - 1				do: [:ii | (pages at: ii) url ifNotNil: [pre := (pages at: ii) url]].			pre ifNil: [after := remote size + 1]				ifNotNil: 					["look for it on disk, put me after"					pre := pre copyAfterLast: $/.					2 to: remote size						do: 							[:ii | 							((remote at: ii) url 								findString: pre								startingAt: 1								caseSensitive: false) > 0 								ifTrue: [after := ii + 1]].					after ifNil: [after := remote size + 1]].			remote := remote 						copyReplaceFrom: after						to: after - 1						with: #(1).			allText ifNotNil: 					[dict at: #allText						put: (allText 								copyReplaceFrom: after - 1								to: after - 2								with: #(#())).					dict at: #allTextUrls						put: (allTextUrls 								copyReplaceFrom: after - 1								to: after - 2								with: #(#()))].			index := after].	remote at: index put: aPage sqkPage copyForSaving.	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds 		ifTrue: [dict at: #modTime put: Time totalSeconds].	allText ifNotNil: 			[(dict at: #allText) at: index - 1 put: (aPage allStringsAfter: nil).			(dict at: #allTextUrls) at: index - 1 put: pageURL].	sf := ServerDirectory new fullPath: mine.	Cursor wait showWhile: 			[remoteFile := sf fileNamed: mine.			remoteFile fileOutClass: nil andObject: remote			"remoteFile close"]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:12'!saveIndexOnURL	"Make up an index to the pages of this book, with thumbnails, and store it on the server.  (aDictionary, aMorphObjectOut, aMorphObjectOut, aMorphObjectOut).  The last part corresponds exactly to what pages looks like when they are all out.  Each holds onto a SqueakPage, which holds a url and a thumbnail."	| dict list mine sf remoteFile urlList |	pages isEmpty ifTrue: [^self].	dict := Dictionary new.	dict at: #modTime put: Time totalSeconds.	"self getAllText MUST have been called at start of this operation."	dict at: #allText put: (self valueOfProperty: #allText).	#(#color #borderWidth #borderColor #pageSize) 		do: [:sel | dict at: sel put: (self perform: sel)].	self reserveUrlsIfNeeded.	"should already be done"	list := pages copy.	"paste dict on front below"	"Fix up the entries, should already be done"	list doWithIndex: 			[:out :ind | 			out isInMemory 				ifTrue: 					[(out valueOfProperty: #SqueakPage) ifNil: [out saveOnURLbasic].					list at: ind put: out sqkPage copyForSaving]].	urlList := list collect: [:ppg | ppg url].	self setProperty: #allTextUrls toValue: urlList.	dict at: #allTextUrls put: urlList.	list := (Array with: dict) , list.	mine := self valueOfProperty: #url.	mine ifNil: 			[mine := self getStemUrl , '.bo'.			self setProperty: #url toValue: mine].	sf := ServerDirectory new fullPath: mine.	Cursor wait showWhile: 			[remoteFile := sf fileNamed: mine.			remoteFile dataIsValid.			remoteFile fileOutClass: nil andObject: list			"remoteFile close"]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:13'!saveOnUrlPage: pageMorph 	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: 			[self 				inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.			^self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) isNil and: [pages first url notNil]) 		ifTrue: 			[response := (PopUpMenu 						labels: 'Old book\New book sharing old pages' withCRs) 							startUpWithCaption: 'Modify the old book, or make a new\book sharing its pages?' 									withCRs.			response = 2 				ifTrue: 					["Make up new url for .bo file and confirm with user."					"Mark as shared"										[rand := String new: 4.					1 to: rand size						do: [:ii | rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].					(newPlace := self getStemUrl) isEmpty ifTrue: [^self].					newPlace := (newPlace copyUpToLast: $/) , '/BK' , rand , '.bo'.					dir := ServerFile new fullPath: newPlace.					dir includesKey: dir fileName] 							whileTrue.	"keep doing until a new file"					self setProperty: #url toValue: newPlace].			response = 0 ifTrue: [^self]].	stem := self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^self].	ind := pages identityIndexOf: pageMorph				ifAbsent: [self error: 'where is the page?'].	pageMorph isInMemory 		ifTrue: 			["not out now"			pageMorph saveOnURL: stem , ind printString , '.sp'].	self saveIndexOfOnly: pageMorph! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:13'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: 			[self 				inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.'.			^self].	self getAllText.	"stored with index later"	response := (PopUpMenu 				labels: 'Use page numbers\Type in file names\Save in a new place (using page numbers)\Save in a new place (typing names)\Save new book sharing old pages' 						withCRs) 					startUpWithCaption: 'Each page will be a file on the server.  \Do you want to page numbers be the names of the files? \or name each one yourself?' 							withCRs.	response = 1 		ifTrue: 			[self saveAsNumberedURLs.			^self].	response = 3 		ifTrue: 			[self				forgetURLs;				saveAsNumberedURLs.			^self].	response = 4 ifTrue: [self forgetURLs].	response = 5 		ifTrue: 			["Make up new url for .bo file and confirm with user."			"Mark as shared"						[rand := String new: 4.			1 to: rand size				do: [:ii | rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			(newPlace := self getStemUrl) isEmpty ifTrue: [^self].			newPlace := (newPlace copyUpToLast: $/) , '/BK' , rand , '.bo'.			dir := ServerFile new fullPath: newPlace.			dir includesKey: dir fileName] 					whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace.			self saveAsNumberedURLs.			bookUrl := self valueOfProperty: #url.			(SqueakPage stemUrl: bookUrl) = (SqueakPage stemUrl: currentPage url) 				ifTrue: [bookUrl := true].	"not a shared book"			(URLMorph grabURL: currentPage url) book: bookUrl.			^self].	response = 0 ifTrue: [^self].	"self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"	pages do: 			[:aPage | 			"does write the current page too"			aPage isInMemory 				ifTrue: 					["not out now"					aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].					aPage saveOnURLbasic]].	"ask user if no url"	list := pages collect: [:aPage | aPage sqkPage prePurge].	"knows not to purge the current page"	list := (list select: [:each | each notNil]) asArray.	"do bulk become:"	(list collect: [:each | each contentsMorph]) 		elementsExchangeIdentityWith: (list 				collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).	firstTime := (self valueOfProperty: #url) isNil.	self saveIndexOnURL.	self presenter ifNotNil: [self presenter flushPlayerListCache].	firstTime 		ifTrue: 			["Put a thumbnail into the hand"			URLMorph grabForBook: self.			self setProperty: #futureUrl toValue: nil	"clean up"]! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:13'!textSearch	"search the text on all pages of this book"	| wanted wants list str |	list := self valueOfProperty: #searchKey ifAbsent: [#()].	str := String streamContents: 					[:strm | 					list do: 							[:each | 							strm								nextPutAll: each;								space]].	wanted := FillInTheBlank 				request: 'words to search for.  Order is not important.Beginnings of words are OK.'				initialAnswer: str.	wants := wanted findTokens: Character separators.	wants isEmpty ifTrue: [^self].	self getAllText.	"save in allText, allTextUrls"	^self findText: wants	"goes to the page and highlights the text"! !!BookMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 23:14'!textSearch: stringWithKeys 	"search the text on all pages of this book"	| wants |	wants := stringWithKeys findTokens: Character separators.	wants isEmpty ifTrue: [^self].	self getAllText.	"save in allText, allTextUrls"	^self findText: wants	"goes to the page and highlights the text"! !!BookMorph methodsFor: 'menus' stamp: 'dgd 2/21/2003 23:11'!printPSToFile	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag |	fileName := 'MyBook' asFileName.	fileName := FillInTheBlank 				request: 'File name? (".ps" will be added to end)'				initialAnswer: fileName.	fileName isEmpty ifTrue: [^self beep].	(fileName endsWith: '.ps') ifFalse: [fileName := fileName , '.ps'].	rotateFlag := ((PopUpMenu labels: 'portrait (tall)landscape (wide)') 				startUpWithCaption: 'Choose orientation...') = 2.	(FileStream newFileNamed: fileName)		nextPutAll: (DSCPostscriptCanvas morphAsPostscript: self rotated: rotateFlag);		close! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/22/2003 18:49'!goToPageMorph: newPage transitionSpec: transitionSpec 	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex := pages identityIndexOf: newPage ifAbsent: [^self	"abort"].	readIn := newPage isInMemory not.	oldPageIndex := pages identityIndexOf: currentPage ifAbsent: [nil].	ascending := (oldPageIndex isNil or: [newPage == currentPage]) 				ifTrue: [nil]				ifFalse: [oldPageIndex < pageIndex].	tSpec := transitionSpec ifNil: 					["If transition not specified by requestor..."					newPage valueOfProperty: #transitionSpec						ifAbsent: 							[" ... then consult new page"							self transitionSpecFor: self	" ... otherwise this is the default"]].	self flag: #arNote.	"Probably unnecessary"	(aWorld := self world) ifNotNil: [self primaryHand releaseKeyboardFocus].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage notNil 		ifTrue: 			[(((pages at: pageIndex) owner isKindOf: TransitionMorph) 				and: [(pages at: pageIndex) isInWorld]) 					ifTrue: [^self	"In the process of a prior pageTurn"].			self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].			ascending ifNotNil: 					["Show appropriate page transition and start new page when done"					currentPage stopStepping.					(pages at: pageIndex) position: currentPage position.					^(TransitionMorph 						effect: tSpec second						direction: tSpec third						inverse: (ascending or: [transitionSpec notNil]) not) 							showTransitionFrom: currentPage							to: (pages at: pageIndex)							in: self							whenStart: [self playPageFlipSound: tSpec first]							whenDone: 								[currentPage									delete;									fullReleaseCachedState.								self insertPageMorphInCorrectSpot: (pages at: pageIndex).								self adjustCurrentPageForFullScreen.								self snapToEdgeIfAppropriate.								aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].								self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].								(aWorld := self world) ifNotNil: 										["WHY??"										aWorld displayWorld].								readIn 									ifTrue: 										[currentPage updateThumbnailUrlInBook: self url.										currentPage sqkPage computeThumbnail	"just store it"]]].			"No transition, but at least decommission current page"			currentPage				delete;				fullReleaseCachedState].	self insertPageMorphInCorrectSpot: (pages at: pageIndex).	self adjustCurrentPageForFullScreen.	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld := self world) ifNotNil: 			["WHY??"			aWorld displayWorld].	readIn 		ifTrue: 			[currentPage updateThumbnailUrl.			currentPage sqkPage computeThumbnail	"just store it"]! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/22/2003 18:49'!goToPageMorph: newPage transitionSpec: transitionSpec runTransitionScripts: aBoolean 	"Install the given page as the new current page; use the given transition spec, and if the boolean parameter is true, run closing and opening scripts on the outgoing and incoming players"	| pageIndex aWorld oldPageIndex ascending tSpec readIn |	pages isEmpty ifTrue: [^self].	self setProperty: #searchContainer toValue: nil.	"forget previous search"	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	pageIndex := pages identityIndexOf: newPage ifAbsent: [^self	"abort"].	readIn := newPage isInMemory not.	oldPageIndex := pages identityIndexOf: currentPage ifAbsent: [nil].	ascending := (oldPageIndex isNil or: [newPage == currentPage]) 				ifTrue: [nil]				ifFalse: [oldPageIndex < pageIndex].	tSpec := transitionSpec ifNil: 					["If transition not specified by requestor..."					newPage valueOfProperty: #transitionSpec						ifAbsent: 							[" ... then consult new page"							self transitionSpecFor: self	" ... otherwise this is the default"]].	self flag: #arNote.	"Probably unnecessary"	(aWorld := self world) ifNotNil: [self primaryHand releaseKeyboardFocus].	currentPage ifNotNil: [currentPage updateCachedThumbnail].	self currentPage notNil 		ifTrue: 			[(((pages at: pageIndex) owner isKindOf: TransitionMorph) 				and: [(pages at: pageIndex) isInWorld]) 					ifTrue: [^self	"In the process of a prior pageTurn"].			aBoolean 				ifTrue: [self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts]].			ascending ifNotNil: 					["Show appropriate page transition and start new page when done"					currentPage stopStepping.					(pages at: pageIndex) position: currentPage position.					^(TransitionMorph 						effect: tSpec second						direction: tSpec third						inverse: (ascending or: [transitionSpec notNil]) not) 							showTransitionFrom: currentPage							to: (pages at: pageIndex)							in: self							whenStart: [self playPageFlipSound: tSpec first]							whenDone: 								[currentPage									delete;									fullReleaseCachedState.								self insertPageMorphInCorrectSpot: (pages at: pageIndex).								self adjustCurrentPageForFullScreen.								self snapToEdgeIfAppropriate.								aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].								aBoolean 									ifTrue: [self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].								(aWorld := self world) ifNotNil: 										["WHY??"										aWorld displayWorld].								readIn 									ifTrue: 										[currentPage updateThumbnailUrlInBook: self url.										currentPage sqkPage computeThumbnail	"just store it"]]].			"No transition, but at least decommission current page"			currentPage				delete;				fullReleaseCachedState].	self insertPageMorphInCorrectSpot: (pages at: pageIndex).	self adjustCurrentPageForFullScreen.	self snapToEdgeIfAppropriate.	aWorld ifNotNil: [self world startSteppingSubmorphsOf: currentPage].	self currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts].	(aWorld := self world) ifNotNil: 			["WHY??"			aWorld displayWorld].	readIn 		ifTrue: 			[currentPage updateThumbnailUrl.			currentPage sqkPage computeThumbnail	"just store it"]! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/21/2003 23:10'!goToPageUrl: aUrl 	| pp short |	pp := pages detect: [:pg | pg url = aUrl] ifNone: [nil].	pp ifNil: 			[short := (aUrl findTokens: '/') last.			pp := pages detect: 							[:pg | 							pg url ifNil: [false] ifNotNil: [(pg url findTokens: '/') last = short]	"it moved"]						ifNone: [pages first]].	self goToPageMorph: pp! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/21/2003 23:11'!nextPage	currentPage isNil ifTrue: [^self goToPage: 1].	self goToPage: (self pageNumberOf: currentPage) + 1! !!BookMorph methodsFor: 'navigation' stamp: 'dgd 2/21/2003 23:11'!previousPage	currentPage isNil ifTrue: [^self goToPage: 1].	self goToPage: (self pageNumberOf: currentPage) - 1! !!BookMorph methodsFor: 'sorting' stamp: 'dgd 2/21/2003 23:09'!acceptSortedContentsFrom: aHolder 	"Update my page list from the given page sorter."	| goodPages rejects toAdd sqPage |	goodPages := OrderedCollection new.	rejects := OrderedCollection new.	aHolder submorphs doWithIndex: 			[:m :i | 			toAdd := nil.			(m isKindOf: PasteUpMorph) ifTrue: [toAdd := m].			(m isKindOf: BookPageThumbnailMorph) 				ifTrue: 					[toAdd := m page.					m bookMorph == self 						ifFalse: 							["borrowed from another book. preserve the original"							toAdd := toAdd veryDeepCopy.							"since we came from elsewhere, cached strings are wrong"							self removeProperty: #allTextUrls.							self removeProperty: #allText]].			toAdd class == String 				ifTrue: 					["a url"					toAdd := pages detect: [:aPage | aPage url = toAdd] ifNone: [toAdd]].			toAdd class == String 				ifTrue: 					[sqPage := SqueakPageCache atURL: toAdd.					toAdd := sqPage contentsMorph 								ifNil: [sqPage copyForSaving	"a MorphObjectOut"]								ifNotNil: [sqPage contentsMorph]].			toAdd ifNil: [rejects add: m] ifNotNil: [goodPages add: toAdd]].	self newPages: goodPages.	goodPages isEmpty ifTrue: [self insertPage].	rejects notEmpty 		ifTrue: 			[self 				inform: rejects size printString , ' objects vanished in this process.']! !!CRDisplayPropertiesMorph methodsFor: 'view hooks' stamp: 'gm 2/22/2003 13:13'!aspectRatio: aString 	| point |	[point := Point readFromString: aString] on: Error do: [].	((point isPoint) and: [point x isNumber and: [point y isNumber]]) 		ifTrue: [tempProperties aspectRatio: (point min: 1000 @ 1000 max: 0 @ 0)]! !!CodecDemoMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:20'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.806		b: 0.677! !!CodecDemoMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:20'!initialize	"initialize the state of the receiver"	super initialize.	""		self codecClassName: 'MuLawCodec'! !!DoubleClickExample methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:22'!defaultColor"answer the default color/fill style for the receiver"	^ Color red! !!EToyCommunicatorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:32'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;	 hResizing: #shrinkWrap.	resultQueue _ SharedQueue new.	fields _ Dictionary new.	self useRoundedCorners! !!AudioChatGUI methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!AudioChatGUI methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color yellow! !!AudioChatGUI methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:48'!initialize	"initialize the state of the receiver"	super initialize.	""	transmitWhileRecording _ false.	handsFreeTalking _ false.	mycodec _ GSMCodec new.	myrecorder _ ChatNotes new.	mytargetip _ ''.		self start2.	self changeTalkButtonLabel! !!AudioChatGUI methodsFor: 'stuff' stamp: 'aoy 2/17/2003 01:01'!changeTalkButtonLabel	| bText |	self transmitWhileRecording.	handsFreeTalking 		ifTrue: 			[theTalkButton				labelUp: 'Talk';				labelDown: 'Release';				label: 'Talk'.			bText := 'Click once to begin a message. Click again to end the message.']		ifFalse: 			[theTalkButton				labelUp: 'Talk';				labelDown: (transmitWhileRecording 							ifTrue: ['TALKING']							ifFalse: ['RECORDING']);				label: 'Talk'.			bText := 'Press and hold to record a message.'].	bText := transmitWhileRecording 		ifTrue: [bText , ' The message will be sent while you are speaking.']		ifFalse: [bText , ' The message will be sent when you are finished.'].	theTalkButton setBalloonText: bText! !!EToyChatMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ self standardBorderColor! !!EToyChatMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 8! !!EToyChatMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 400 @ 100 extent: 200 @ 150! !!EToyChatMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color paleYellow! !!EToyChatMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:36'!initialize	"initialize the state of the receiver"	super initialize.	""	acceptOnCR _ true.	self listDirection: #topToBottom;		 layoutInset: 0;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 rubberBandCells: false;		 minWidth: 200;		 minHeight: 200;		 rebuild ! !!EToyFridgeMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!EToyFridgeMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!EToyFridgeMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color paleRed! !!EToyFridgeMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:58'!initialize	"initialize the state of the receiver"	super initialize.	""	groupMode _ true.	self listDirection: #topToBottom;		 layoutInset: 10;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 setProperty: #normalBorderColor toValue: self borderColor;		 setProperty: #flashingColors toValue: {Color red. Color yellow};		 rebuild! !!EToyGateKeeperMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!EToyGateKeeperMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!EToyGateKeeperMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!EToyGateKeeperMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:42'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 layoutInset: 4;		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 useRoundedCorners;		 rebuild ! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:54'!initialize	"initialize the state of the receiver"super initialize.""	namedFields _ Dictionary new.		self rebuild! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 18:05'!rebuild	"rebuilds the receiver"	^ self! !!EToyListenerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 18:59'!mouseDownEvent: event for: aMorph 	| menu selection depictedObject |	depictedObject := aMorph firstSubmorph valueOfProperty: #depictedObject.	menu := CustomMenu new.	menu		add: 'Grab' action: [event hand attachMorph: depictedObject veryDeepCopy];		add: 'Delete'			action: 				[self class removeFromGlobalIncomingQueue: depictedObject.				self rebuild].	selection := menu build startUpCenteredWithCaption: 'Morph from ' 						, (aMorph submorphs second) firstSubmorph contents.	selection ifNil: [^self].	selection value! !!EToyListenerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color blue! !!EToyListenerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!EToyListenerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!EToyListenerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:44'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 layoutInset: 4;		 rebuild ! !!EToyMorphsWelcomeMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color yellow! !!EToyMorphsWelcomeMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:27'!initialize	"initialize the state of the receiver"	| earMorph |	super initialize.	""		self layoutInset: 8 @ 8.	"earMorph _ (EToyListenerMorph makeListeningToggle: true)  	asMorph."	earMorph _ TextMorph new contents: 'Morphswelcomehere';				 fontName: #ComicBold size: 18;				 centered;				 lock.	self addARow: {earMorph}.	self setBalloonText: 'My presence in this world means received morphs may appear automatically'! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBrown! !!EToyProjectHistoryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:46'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 layoutInset: 4;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 useRoundedCorners;		 rebuild ! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:58'!validateTheProjectName	| proposed |	proposed := (namedFields at: 'projectname') contents string 				withBlanksTrimmed.	proposed isEmpty 		ifTrue: 			[self inform: 'I do need a name for the project'.			^false].	proposed size > 24 		ifTrue: 			[self inform: 'Please make the name 24 characters or less'.			^false].	(Project isBadNameForStoring: proposed) 		ifTrue: 			[self inform: 'Please remove any funny characters from the name'.			^false].	proposed = theProject name ifTrue: [^true].	(ChangeSorter changeSetNamed: proposed) ifNotNil: 			[Utilities inform: 'Sorry that name is already used'.			^false].	^true! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ color darker! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 8! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:26'!defaultColor	"answer the default color/fill style for the receiver"	^ Color paleYellow! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:54'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;	  hResizing: #shrinkWrap;	  layoutInset: 4;	  useRoundedCorners;	  rebuild! !!EToyProjectQueryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ self color darker! !!EToyProjectQueryMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:26'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.545		g: 0.47		b: 0.621! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'aoy 2/15/2003 20:59'!startAudioChat: toggleMode 	| chat r |	(self valueOfProperty: #embeddedAudioChatHolder) ifNotNil: 			[toggleMode ifFalse: [^self].			^self killExistingChat].	chat := AudioChatGUI new ipAddress: self ipAddress.	(self ownerThatIsA: EToyFridgeMorph) isNil 		ifTrue: 			[chat				removeConnectButton;				vResizing: #shrinkWrap;				hResizing: #shrinkWrap;				borderWidth: 2.	"we already know the connectee"			r := (self addARow: { 								chat}) vResizing: #shrinkWrap.			self world startSteppingSubmorphsOf: chat.			self setProperty: #embeddedAudioChatHolder toValue: r.			self				hResizing: #shrinkWrap;				vResizing: #shrinkWrap]		ifFalse: 			[chat openInWorld: self world]! !!EToySenderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color magenta! !!EToySenderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 4! !!EToySenderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:26'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightMagenta! !!EToySenderMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:58'!initialize	"initialize the state of the receiver"	Socket initializeNetwork.	"we may want our IP address"	Preferences defaultAuthorName.	"seems like a good place to insure we have a name"	super initialize.	""	self listDirection: #topToBottom;		 layoutInset: 4;		 setProperty: #normalBorderColor toValue: self borderColor;		 setProperty: #flashingColors toValue: {Color red. Color yellow}! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'dgd 2/22/2003 14:23'!acceptGraphPoint: p at: index 	| ms val points whichLim linePoint other boundedP |	boundedP := p adhereTo: graphArea bounds.	ms := self msFromX: boundedP x.	points := envelope points.	ms := self 				constrain: ms				adjacentTo: index				in: points.	(index = 1 or: [(whichLim := limits indexOf: index) > 0]) 		ifTrue: 			["Limit points must not move laterally"			ms := (points at: index) x].	val := self valueFromY: boundedP y.	points at: index put: ms @ val.	linePoint := (self xFromMs: ms) @ (self yFromValue: val).	(whichLim notNil and: [whichLim between: 1 and: 2]) 		ifTrue: 			["Loop start and loop end must be tied together"			other := limits at: 3 - whichLim.	" 1 <--> 2 "			points at: other put: (points at: other) x @ val.			line verticesAt: other put: (line vertices at: other) x @ linePoint y].	"Make sure envelope feels the change in points array..."	envelope 		setPoints: points		loopStart: limits first		loopEnd: (limits second).	^linePoint! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'dgd 2/22/2003 14:24'!deletePoint: ix 	"If the point is a limit point, return false,	otherwise, delete the point at ix, and return true."	(limits includes: ix) ifTrue: [^false].	1 to: limits size		do: 			[:i | 			"Decrease limit indices beyond the deletion"			(limits at: i) > ix ifTrue: [limits at: i put: (limits at: i) - 1]].	envelope 		setPoints: (envelope points 				copyReplaceFrom: ix				to: ix				with: Array new)		loopStart: (limits first)		loopEnd: (limits second).	^true! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'dgd 2/22/2003 14:24'!insertPointAfter: ix 	"If there is not enough roon (in x) then return false.	Otherwise insert a point between ix and ix+1 and return true."	| points pt |	points := envelope points.	(points at: ix + 1) x - (points at: ix) x < 20 ifTrue: [^false].	pt := ((points at: ix + 1) + (points at: ix)) // 2.	1 to: limits size		do: 			[:i | 			"Increase limit indices beyond the insertion"			(limits at: i) > ix ifTrue: [limits at: i put: (limits at: i) + 1]].	envelope 		setPoints: (points 				copyReplaceFrom: ix + 1				to: ix				with: (Array with: pt))		loopStart: (limits first)		loopEnd: (limits second).	^true! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 14:23'!adjustScale: evt 	| scaleString oldScale baseValue |	oldScale := envelope scale.	scaleString := FillInTheBlank request: 'Enter the new full-scale value...'				initialAnswer: oldScale printString.	scaleString isEmpty ifTrue: [^self].	envelope scale: (Number readFrom: scaleString) asFloat.	baseValue := envelope updateSelector = #pitch: ifTrue: [0.5] ifFalse: [0.0].	envelope 		setPoints: (envelope points collect: 					[:p | 					p x @ ((p y - baseValue) * oldScale / envelope scale + baseValue min: 1.0								max: 0.0)])		loopStart: (limits first)		loopEnd: (limits second).	self buildView! !!EtoyLoginMorph methodsFor: 'actions' stamp: 'dgd 2/21/2003 22:36'!doOK	| proposed |	proposed := theNameMorph contents string.	proposed isEmpty ifTrue: [^self inform: 'Please enter your login name'].	proposed size > 24 		ifTrue: [^self inform: 'Please make the name 24 characters or less'].	(Project isBadNameForStoring: proposed) 		ifTrue: [^self inform: 'Please remove any funny characters'].	(actionBlock value: proposed) ifTrue: [self delete]! !!EtoyLoginMorph methodsFor: 'building' stamp: 'gm 3/11/2003 21:51'!buttonColor	^ Color paleYellow darker!]style[(11 4 23)f2b,f2,f1cred;! !!EtoyLoginMorph methodsFor: 'initialization' stamp: 'gm 3/11/2003 21:53'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color paleYellow darker!]style[(18 2 61 27)f2b,f2,f2c145043000,f2! !!EtoyLoginMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 8! !!EtoyLoginMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 16:01'!defaultColor	"answer the default color/fill style for the receiver"	| result |	result _ GradientFillStyle ramp: {0.0					-> (Color							r: 0.5							g: 0.5							b: 1.0). 1.0					-> (Color							r: 0.8							g: 0.8							b: 1.0)}.	result origin: self bounds origin.	result direction: 0 @ self bounds height.	^ result!]style[(12 2 54 3 7 4 6 3 17 8 3 10 5 11 3 11 3 11 3 3 3 10 5 11 3 11 3 11 3 5 6 9 4 17 6 12 1 3 4 19 6)f2b,f2,f2c150048000,f2,f2cblue;i,f2,f2cblue;i,f2,f2cmagenta;,f2,f2c200200124,f2,f2cmagenta;,f2,f2c200200124,f2,f2c200200124,f2,f2c200200124,f2,f2c200200124,f2,f2cmagenta;,f2,f2c200200124,f2,f2c200200124,f2,f2c200200124,f2,f2cblue;i,f2,f2cmagenta;,f2,f2cblue;i,f2,f2c200200124,f2,f2cmagenta;,f2,f2cblue;i! !!EtoyLoginMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:28'!initialize	"initialize the state of the receiver"		super initialize.	""	self vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		 beSticky;		 useRoundedCorners;		 rebuild.	! !!EventRecorderMorph methodsFor: 'commands' stamp: 'dgd 2/22/2003 19:01'!condense	"Shorten the tape by deleting mouseMove events that can just as well be	interpolated later at playback time."	"e1, e2, and e3 are three consecutive events on the tape.	t1, t2, and t3 are the associated time steps for each of them."	| e1 e2 t1 t2 e3 t3 |	tape := Array streamContents: 					[:tStream | 					e1 := e2 := e3 := nil.					t1 := t2 := t3 := nil.					1 to: tape size						do: 							[:i | 							e1 := e2.							t1 := t2.							e2 := e3.							t2 := t3.							e3 := tape at: i.							t3 := e3 timeStamp.							((e1 notNil and: 									[e2 type == #mouseMove 										& (e1 type == #mouseMove or: [e3 type == #mouseMove])]) 								and: 									["Middle point within 3 pixels of mean of outer two"									e2 position 										onLineFrom: e1 position										to: e3 position										within: 2.5]) 									ifTrue: 										["Delete middle mouse move event.  Absorb its time into e3"										e2 := e1.										t2 := t1]									ifFalse: [e1 ifNotNil: [tStream nextPut: (e1 copy setTimeStamp: t1)]]].					e2 ifNotNil: [tStream nextPut: (e2 copy setTimeStamp: t2)].					e3 ifNotNil: [tStream nextPut: (e3 copy setTimeStamp: t3)]]! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 23:15'!nextEventToPlay	"Return the next event when it is time to be replayed.	If it is not yet time, then return an interpolated mouseMove.	Return nil if nothing has happened.	Return an EOF event if there are no more events to be played."	| nextEvent now nextTime lastP delta |	(tapeStream isNil or: [tapeStream atEnd]) 		ifTrue: [^MorphicUnknownEvent new setType: #EOF argument: nil].	now := Time millisecondClockValue.	nextEvent := tapeStream next.	deltaTime ifNil: [deltaTime := now - nextEvent timeStamp].	nextTime := nextEvent timeStamp + deltaTime.	now < time 		ifTrue: 			["clock rollover"			time := now.			deltaTime := nil.			^nil	"continue it on next cycle"].	time := now.	now >= nextTime 		ifTrue: 			[nextEvent := nextEvent copy setTimeStamp: nextTime.			lastEvent := nextEvent isMouse ifTrue: [nextEvent] ifFalse: [nil].			^nextEvent].	tapeStream skip: -1.	"Not time for the next event yet, but interpolate the mouse.	This allows tapes to be compressed when velocity is fairly constant."	lastEvent ifNil: [^nil].	lastP := lastEvent position.	delta := (nextEvent position - lastP) * (now - lastEvent timeStamp) 				// (nextTime - lastEvent timeStamp).	delta = lastDelta ifTrue: [^nil].	"No movement"	lastDelta := delta.	^MouseMoveEvent new 		setType: #mouseMove		startPoint: lastEvent position		endPoint: lastP + delta		trail: #()		buttons: lastEvent buttons		hand: nil		stamp: now! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'dgd 2/21/2003 23:15'!checkTape	"See if this tape was already converted to the new format"	tape ifNil: [^self].	tape isEmpty ifTrue: [^self].	(tape first isKindOf: Association) 		ifTrue: [tape := self convertV0Tape: tape]! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'dgd 2/21/2003 23:16'!writeTape	| args b |	args := (b := self button: 'writeTape') isNil 				ifTrue: [#()]				ifFalse: [b arguments].	(args notEmpty and: [args first notEmpty]) 		ifTrue: 			[args first.			self writeTape: args first]		ifFalse: 			[(Smalltalk at: #RequestBoxMorph				ifAbsent: 					[^self writeTape: (FillInTheBlank request: 'Tape to write'								initialAnswer: 'tapeName.tape')]) 					request: 'Tape to write'					respondTo: self					selector: #writeTape:]! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color red! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:21'!initialize	"initialize the state of the receiver"	super initialize.	""	saved _ true.	self listDirection: #topToBottom;		 wrapCentering: #center;		 cellPositioning: #topCenter;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 2;		 minCellSize: 4;		 addButtons! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:58'!initialize	"initialize the state of the receiver"	super initialize.	""	Preferences roundedWindowCorners		ifTrue: [self useRoundedCorners].		self extent: 200 @ 70.	responseUponCancel _ ''! !!FillInTheBlankMorphWithDictMenu methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:58'!initialize	"initialize the state of the receiver"	super initialize.""	self setBalloonText: 'Use the context menu to insert dictionaries'! !!FloatingBookControlsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!FloatingBookControlsMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:16'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 0;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap ! !!GeeBookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.909		g: 0.819		b: 0.09! !!GeeBookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:10'!initialize	"initialize the state of the receiver"	super initialize.	""	newPagePrototype _ GeeBookPageMorph new extent: Display extent // 3 ! !!GeePrinterDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ self color darker! !!GeePrinterDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 8! !!GeePrinterDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color paleYellow! !!GeePrinterDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:52'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		 useRoundedCorners.	printSpecs		ifNil: [printSpecs _ PrintSpecifications defaultSpecs].	self rebuild ! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/24/2003 18:06'!buildFakeSlider: nameStringOrSymbol selector: aSymbol help: helpString 	| col |	col := self inAColumn: { 						(nameStringOrSymbol isKindOf: Symbol) 							ifTrue: 								[(UpdatingStringMorph new)									useStringFormat;									getSelector: nameStringOrSymbol;									target: self;									growable: true;									minimumWidth: 24;									lock]							ifFalse: [self lockedString: nameStringOrSymbol]}.	col		borderWidth: 2;		borderColor: color darker;		color: color muchLighter;		hResizing: #shrinkWrap;		setBalloonText: helpString;		on: #mouseMove			send: #mouseAdjust:in:			to: self;		on: #mouseDown			send: #mouseAdjust:in:			to: self;		on: #mouseUp			send: #clearSliderFeedback			to: self;		setProperty: #changeSelector toValue: aSymbol.	^col! !!GenericPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:15'!defaultBorderWidth"answer the default border width for the receiver"	^ 4! !!GenericPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:16'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 4.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	thingsToRevert _ Dictionary new.	self useRoundedCorners! !!ButtonPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:17'!defaultBorderColor"answer the default border color/fill style for the receiver"	^ self defaultColor darker! !!ButtonPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:17'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.935		g: 0.839		b: 0.452! !!ButtonPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:17'!initialize	"initialize the state of the receiver"	super initialize.	""	myTarget		ifNil: [myTarget _ RectangleMorph new openInWorld].	thingsToRevert at: #buttonProperties: put: myTarget buttonProperties.	self rebuild! !!GradientFillMorph methodsFor: 'drawing' stamp: 'gm 2/22/2003 13:15'!drawOn: aCanvas 	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color"	| style |	super drawOn: aCanvas.	(color isColor) ifFalse: [^self].	"An InfiniteForm, for example"	color = Color transparent ifTrue: [^self].	"Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^self].	"same color; no gradient"	"Check if we can use the cached gradient fill"	((self valueOfProperty: #cachedGradientColor1) = color 		and: [(self valueOfProperty: #cachedGradientColor2) = fillColor2]) 			ifTrue: [style := self valueOfProperty: #cachedGradientFill].	style ifNil: 			[style := GradientFillStyle ramp: { 								0.0 -> color.								1.0 -> fillColor2}.			self setProperty: #cachedGradientColor1 toValue: color.			self setProperty: #cachedGradientColor2 toValue: fillColor2.			self setProperty: #cachedGradientFill toValue: style].	style origin: self position.	style direction: (gradientDirection == #vertical 				ifTrue: [0 @ self height]				ifFalse: [self width @ 0]).	aCanvas fillRectangle: self innerBounds fillStyle: style! !!GraphMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 14:40'!interpolatedValueAtCursor	| sz prev frac next |	data isEmpty ifTrue: [^0].	sz := data size.	cursor < 0 ifTrue: [^data first].	"just to be safe, though cursor shouldn't be negative"	prev := cursor truncated.	frac := cursor - prev.	prev < 1 ifTrue: [prev := sz].	prev > sz ifTrue: [prev := 1].	"assert: 1 <= prev <= sz"	frac = 0 ifTrue: [^data at: prev].	"no interpolation needed"	"interpolate"	next := prev = sz ifTrue: [1] ifFalse: [prev + 1].	^(1.0 - frac) * (data at: prev) + (frac * (data at: next))! !!GraphMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 14:40'!lastValue	data isEmpty ifTrue: [^0].	^data last! !!GraphMorph methodsFor: 'drawing' stamp: 'dgd 2/22/2003 14:39'!drawOn: aCanvas 	| c |	cachedForm isNil 		ifTrue: 			[c := Display defaultCanvasClass extent: bounds extent.			c translateBy: bounds origin negated				during: [:tempCanvas | self drawDataOn: tempCanvas].			cachedForm := c form].	aCanvas 		cache: bounds		using: cachedForm		during: [:cachingCanvas | self drawDataOn: cachingCanvas].	self drawCursorOn: aCanvas! !!GraphMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:27'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 0.8		b: 0.6! !!GraphMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:28'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 365 @ 80.	dataColor _ Color darkGray.	cursor _ 1.0.	"may be fractional"	cursorColor _ Color red.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	hasChanged _ false.	self		data: ((0 to: 360 - 1)				collect: [:x | (100.0 * x degreesToRadians sin) asInteger])! !!GraphMorph methodsFor: 'stepping and presenter' stamp: 'dgd 2/22/2003 14:40'!step	"Make a deferred damage rectangle if I've changed. This allows applications to call methods that invalidate my display at high-bandwidth without paying the cost of doing the damage reporting on ever call; they can merely set hasChanged to true."	super step.	hasChanged isNil ifTrue: [hasChanged := false].	hasChanged 		ifTrue: 			[self changed.			hasChanged := false]! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'dgd 2/14/2003 19:08'!initializeFor: aTarget withForms: formList coexist: aBoolean 	"World primaryHand attachMorph: (GraphicalMenu new  	initializeFor: nil  	withForms: Form allInstances coexist: true)"	| buttons bb anIndex buttonCage imageWrapper |	target _ aTarget.	coexistWithOriginal _ aBoolean.	formChoices _ formList.	currentIndex _ 1.	self hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	buttons _ AlignmentMorph newRow.	buttons borderWidth: 0;		 layoutInset: 0.	buttons hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 extent: 5 @ 5.	buttons wrapCentering: #topLeft.	buttonCage _ AlignmentMorph newColumn.	buttonCage hResizing: #shrinkWrap;		 vResizing: #spaceFill.	buttonCage addTransparentSpacerOfSize: 0 @ 10.	bb _ SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'Prev';			 actionSelector: #downArrowHit;			 actWhen: #whilePressed).	buttons addTransparentSpacerOfSize: 9 @ 0.	bb _ SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'Next';			 actionSelector: #upArrowHit;			 actWhen: #whilePressed).	buttons addTransparentSpacerOfSize: 5 @ 0.	buttons submorphs last color: Color white.	buttonCage addMorphBack: buttons.	buttonCage addTransparentSpacerOfSize: 0 @ 12.	buttons _ AlignmentMorph newRow.	bb _ SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'OK';			 actionSelector: #okay).	buttons addTransparentSpacerOfSize: 5 @ 0.	bb _ SimpleButtonMorph new target: self;				 borderColor: Color black.	buttons addMorphBack: (bb label: 'Cancel';			 actionSelector: #cancel).	buttonCage addMorphBack: buttons.	buttonCage addTransparentSpacerOfSize: 0 @ 10.	self addMorphFront: buttonCage.	imageWrapper _ Morph new color: Color transparent;				 extent: 102 @ 82.	imageWrapper addMorphBack: (formDisplayMorph _ ImageMorph new extent: 100 @ 100).	self addMorphBack: imageWrapper.	target		ifNotNil: [(anIndex _ formList						indexOf: target form						ifAbsent: [])				ifNotNil: [currentIndex _ anIndex]].	self updateThumbnail! !!GraphicalMenu methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:34'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color blue darker! !!GraphicalMenu methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!GraphicalMenu methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!GraphicalDictionaryMenu methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:10'!initializeFor: aTarget fromDictionary: aDictionary 	"Initialize me for a target and a dictionary."	| imageWrapper anIndex aButton controlsWrapper asm |	self listDirection: #topToBottom.	self addMorphBack: (controlsWrapper _ AlignmentMorph newRow).	self baseDictionary: aDictionary.	target _ aTarget.	coexistWithOriginal _ true.		self hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	controlsWrapper borderWidth: 0;		 layoutInset: 0;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 extent: 5 @ 5.	controlsWrapper wrapCentering: #topLeft;		 color: Color white;		 vResizing: #spaceFill.	controlsWrapper addTransparentSpacerOfSize: 18 @ 0.	controlsWrapper addMorphBack: (IconicButton new borderWidth: 0;						labelGraphic: (ScriptingSystem formAtKey: 'TinyMenu');			 color: Color transparent;			 actWhen: #buttonDown;			 actionSelector: #showMenu;			 target: self;			 setBalloonText: 'menu').	controlsWrapper addTransparentSpacerOfSize: 14 @ 0.	aButton _ SimpleButtonMorph new target: self;				 borderColor: Color black.	controlsWrapper addMorphBack: (aButton label: 'Prev';			 actionSelector: #downArrowHit;			 actWhen: #whilePressed;			 setBalloonText: 'show previous picture';			 yourself).	controlsWrapper addTransparentSpacerOfSize: 15 @ 0.	aButton _ SimpleButtonMorph new target: self;				 borderColor: Color black.	controlsWrapper addMorphBack: (aButton label: 'Next';			 actionSelector: #upArrowHit;			 actWhen: #whilePressed;			 setBalloonText: 'show next pictutre').	self addMorphBack: controlsWrapper.	self addTransparentSpacerOfSize: 0 @ 12.	self addMorphBack: (asm _ UpdatingStringMorph new contents: ' ';					 target: self;					 putSelector: #renameGraphicTo:;					 getSelector: #truncatedNameOfGraphic;					 useStringFormat).	asm setBalloonText: 'The name of the current graphic'.	self addTransparentSpacerOfSize: 0 @ 12.	self addMorphBack: (AlignmentMorph newRow height: 4;			 borderWidth: 0;			 color: Color black).	imageWrapper _ Morph new color: Color transparent;				 extent: 190 @ 82.	imageWrapper addMorphBack: (formDisplayMorph _ ImageMorph new extent: 100 @ 100).	self addMorphBack: imageWrapper.	target		ifNotNil: [(anIndex _ formChoices						indexOf: target form						ifAbsent: [])				ifNotNil: [currentIndex _ anIndex]].	self updateThumbnail! !!HeadingMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:34'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!HeadingMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:33'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 1.0		b: 1.0! !!HeadingMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:34'!initialize	"initialize the state of the receiver"	super initialize.	""	degrees _ 90.0.	magnitude _ 1.0.		self extent: 160 @ 160! !!InterimSoundMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!InterimSoundMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0		g: 0.8		b: 0.6! !!InterimSoundMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:57'!initialize	"initialize the state of the receiver"	super initialize.	""		self extent: 30 @ 30.	self addGraphic.	sound _ PluckedSound				pitch: 880.0				dur: 2.0				loudness: 0.5! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:35'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.452		g: 0.935		b: 0.548! !!KlattFrameMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:35'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom.	! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:37'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:37'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.484		g: 0.613		b: 0.0! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:37'!initialize"initialize the state of the receiver"	| slider |	super initialize.""	self listDirection: #topToBottom.	self wrapCentering: #center;		 cellPositioning: #topCenter.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	channel _ 0.	controller _ 7.	"channel volume"	slider _ SimpleSliderMorph new target: self;				 actionSelector: #newSliderValue:;				 minVal: 0;				 maxVal: 127;				 extent: 128 @ 10.	self addMorphBack: slider.	self		addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel! !!MPEGMoviePlayerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:39'!defaultColor	"answer the default color/fill style for the receiver"		| fill |	fill _ GradientFillStyle ramp: {0.0					-> (Color							r: 0.355							g: 0.548							b: 1.0). 1.0					-> (Color							r: 0.774							g: 0.935							b: 1.0)}.	fill origin: self bounds topLeft + (61 @ 7).	fill direction: 33 @ 37.	fill radial: false.	^ fill! !!MPEGMoviePlayerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:40'!initialize"initialize the state of the receiver"	super initialize.	""	self hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	borderWidth _ 2.	self listDirection: #topToBottom.	self cornerStyle: #rounded.	self layoutInset: 4.	moviePlayer _ MPEGDisplayMorph new.	self addMorphFront: moviePlayer.	self addButtonRow.	self addVolumeSlider.	self addPositionSlider.	self extent: 10 @ 10! !!MenuMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 23:18'!lastSelection	"Return the label of the last selected item or nil."	selectedItem isNil ifTrue: [^selectedItem selector] ifFalse: [^nil]! !!MenuMorph methodsFor: 'construction' stamp: 'aoy 2/17/2003 01:20'!labels: labelList lines: linesArray selections: selectionsArray 	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelArray := (labelList isMemberOf: String) 				ifTrue: [labelList findTokens: String cr]				ifFalse: [labelList]. 	1 to: labelArray size		do: 			[:i | 			self add: (labelArray at: i) action: (selectionsArray at: i).			(linesArray includes: i) ifTrue: [self addLine]]! !!MenuMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:55'!keyStroke: evt 	| matchString char asc selectable |	(self rootMenu hasProperty: #hasUsedKeyboard) 		ifFalse: 			[self rootMenu setProperty: #hasUsedKeyboard toValue: true.			self changed].	(evt commandKeyPressed and: [self commandKeyHandler notNil]) 		ifTrue: 			[self commandKeyHandler commandKeyTypedIntoMenu: evt.			^self deleteIfPopUp: evt].	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner].	(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt! !!MenuMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:10'!removeStayUpBox	| box |	submorphs isEmpty ifTrue: [^self].	(submorphs first isAlignmentMorph) ifFalse: [^self].	box := submorphs first submorphs last.	(box isKindOf: IconicButton) 		ifTrue: 			[box				labelGraphic: (Form extent: box extent depth: 8);				shedSelvedge;				borderWidth: 0;				lock]! !!MenuMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:55'!setTarget: evt 	"Set the default target object to be used for add item commands, and re-target all existing items to the new target or the the invoking hand."	| rootMorphs old |	rootMorphs := self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1 		ifTrue: [defaultTarget := rootMorphs second]		ifFalse: [^self].	"re-target all existing items"	self items do: 			[:item | 			old := item target.			old isHandMorph 				ifTrue: [item target: evt hand]				ifFalse: [item target: defaultTarget]]! !!MidiInputMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/28/2003 00:00'!atChannel: channelIndex from: aPopUpChoice selectInstrument: selection 	| oldSnd name snd instSelector |	oldSnd := midiSynth instrumentForChannel: channelIndex.	(selection beginsWith: 'edit ') 		ifTrue: 			[name := selection copyFrom: 6 to: selection size.			aPopUpChoice contentsClipped: name.			(oldSnd isKindOf: FMSound) | (oldSnd isKindOf: LoopedSampledSound) 				ifTrue: [EnvelopeEditorMorph openOn: oldSnd title: name].			(oldSnd isKindOf: SampledInstrument) 				ifTrue: [EnvelopeEditorMorph openOn: oldSnd allNotes first title: name].			^self].	snd := nil.	1 to: instrumentSelector size		do: 			[:i | 			(channelIndex ~= i and: 					[(instSelector := instrumentSelector at: i) notNil 						and: [selection = instSelector contents]]) 				ifTrue: [snd := midiSynth instrumentForChannel: i]].	"use existing instrument prototype"	snd ifNil: 			[snd := (selection = 'clink' 						ifTrue: 							[(SampledSound samples: SampledSound coffeeCupClink samplingRate: 11025)]						ifFalse: [(AbstractSound soundNamed: selection) ])copy ].	midiSynth instrumentForChannel: channelIndex put: snd.	(instrumentSelector at: channelIndex) contentsClipped: selection! !!MidiInputMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!MidiInputMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryLightGray! !!MidiInputMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:24'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;	  wrapCentering: #center;		 cellPositioning: #topCenter;	  hResizing: #spaceFill;	  vResizing: #spaceFill;	  layoutInset: 3.	midiPortNumber _ nil.	midiSynth _ MIDISynth new.	instrumentSelector _ Array new: 16.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: (AlignmentMorph newColumn color: color;			 layoutInset: 0).	self addChannelControlsFor: 1.	self extent: 20 @ 20! !!MonthMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:41'!defaultColor"answer the default color/fill style for the receiver"	^ Color red! !!MonthMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:41'!initialize	"initialize the state of the receiver"	super initialize.	""	tileRect _ 0 @ 0 extent: 23 @ 19.	self layoutInset: 1;		 listDirection: #topToBottom;		 vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 month: Date today month.	self rubberBandCells: false.	self extent: 160 @ 130! !!MonthMorph methodsFor: 'initialization' stamp: 'aoy 2/15/2003 21:17'!initializeHeader	| title sep frame button monthName |	title := (self findA: WeekMorph) title.	title hResizing: #spaceFill.	"should be done by WeekMorph but isn't"	title submorphsDo: [:m | m hResizing: #spaceFill].	monthName := month name.	self width < 160 		ifTrue: 			[monthName := (#(6 7 9) includes: month index) 				ifTrue: [monthName copyFrom: 1 to: 4]				ifFalse: [monthName copyFrom: 1 to: 3]].	sep := (Morph new)				color: Color transparent;				extent: title width @ 1.	self		addMorph: sep;		addMorph: title;		addMorph: sep copy.	button := (SimpleButtonMorph new)				target: self;				actWhen: #whilePressed;				color: (Color 							r: 0.8							g: 0.8							b: 0.8).	frame := (AlignmentMorph new)				color: Color transparent;				listDirection: #leftToRight;				hResizing: #spaceFill;				vResizing: #shrinkWrap;				layoutInset: 0.	frame		addMorph: (button					label: '>>';					actionSelector: #nextYear;					width: 15);		addMorph: ((button copy)					label: '>';					actionSelector: #next;					width: 15);		addMorph: (((AlignmentMorph new)					color: Color transparent;					listDirection: #topToBottom;					wrapCentering: #center;					cellPositioning: #topCenter;					extent: (title fullBounds width - (button width * 3)) @ title height) 						addMorph: (StringMorph new 								contents: monthName , ' ' , month year printString));		addMorph: ((button copy)					label: '<';					actionSelector: #previous;					width: 15);		addMorph: ((button copy)					label: '<<';					actionSelector: #previousYear;					width: 15).	"hResizing: #shrinkWrap;"	self addMorph: frame! !!MorphExample methodsFor: 'initialization' stamp: 'dgd 2/21/2003 19:59'!initialize	"initialize the state of the receiver"	super initialize.	phase _ 1.	self extent: 200 @ 200.	ball _ EllipseMorph new extent: 30 @ 30.	self		addMorph: ((star _ StarMorph new extent: 150 @ 150) center: self center)! !!MoviePlayerMorph methodsFor: 'geometry' stamp: 'dgd 2/22/2003 19:01'!position: newPos 	super position: newPos.	(currentPage notNil and: [currentPage left odd]) 		ifTrue: 			["crude word alignment for depth = 16"			super position: newPos + (1 @ 0)]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryLightGray! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:07'!setInitialState	super setInitialState.""	self layoutInset: 3.	pageSize _ frameSize _ 200 @ 200.	frameDepth _ 8.	self disableDragNDrop! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/22/2003 13:22'!stopSoundTrackIfAny	scorePlayer isNil ifTrue: [^self].	(scorePlayer isKindOf: SampledSound) 		ifTrue: [scorePlayer endGracefully]		ifFalse: [scorePlayer := nil]! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 13:21'!addSoundTrack	| fileName |	fileName := Utilities chooseFileWithSuffixFromList: #('.aif' '.wav')				withCaption: 'Choose a sound track file'.	fileName isNil ifTrue: [^self].	soundTrackFileName := fileName.	self tryToShareScoreFor: soundTrackFileName.	scorePlayer ifNil: 			[('*aif' match: fileName) 				ifTrue: [scorePlayer := SampledSound fromAIFFfileNamed: fileName].			('*wav' match: fileName) 				ifTrue: [scorePlayer := SampledSound fromWaveFileNamed: fileName]].	soundTrackForm ifNotNil: 			["Compute new soundTrack if we're showing it."			self				showHideSoundTrack;				showHideSoundTrack]! !!MoviePlayerMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 13:21'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu := MVCMenuMorph new defaultTarget: self.	aMenu add: 'make a new movie' action: #makeAMovie.	aMenu add: 'open movie file' action: #openMovieFile.	aMenu add: 'add sound track' action: #addSoundTrack.	aMenu addLine.	scorePlayer ifNotNil: 			[soundTrackForm isNil 				ifTrue: [aMenu add: 'show sound track' action: #showHideSoundTrack]				ifFalse: [aMenu add: 'hide sound track' action: #showHideSoundTrack]].	aMenu add: 'make thumbnail' action: #thumbnailForThisPage.	cueMorph ifNotNil: 			["Should check if piano roll and score already have a start event		prior to this time."			aMenu add: 'end clip here' action: #endClipHere].	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'dgd 2/22/2003 13:22'!startRunning	| ms |	(frameBufferIfScaled ifNil: [currentPage image]) unhibernate.	movieFile := AsyncFile new 				open: (FileDirectory default fullNameFor: movieFileName)				forWrite: false.	movieFile 		primReadStart: movieFile fileHandle		fPosition: (self filePosForFrameNo: frameNumber)		count: self fileByteCountPerFrame.	scorePlayer isNil 		ifTrue: 			[ms := Time millisecondClockValue.			msAtStart := ms - ((frameNumber - 1) * msPerFrame).			msAtLastSync := ms - msAtStart]		ifFalse: 			[(playDirection > 0 and: [scorePlayer isKindOf: SampledSound]) 				ifTrue: 					[scorePlayer						reset;						playSilentlyUntil: (frameNumber - 1) * msPerFrame / 1000.0;						initialVolume: 1.0.										[scorePlayer resumePlaying.					msAtLastSync := scorePlayer millisecondsSinceStart] 							forkAt: Processor userInterruptPriority].			msAtLastSync := scorePlayer millisecondsSinceStart].	frameAtLastSync := frameNumber! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'dgd 2/22/2003 13:22'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If scorePlayer is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  If the movie is running ahead, then some calls on step will skip their  action until the right time.  If the movie is running behind, then the frame may advance by more than one to maintain synchronization."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	"This code may not work right for playing backwards right now.	Single-step and backwards (dir <= 0) should just run open-loop."	| byteCount simTime ms nextFrameNumber |	movieFile isNil ifTrue: [^self].	scorePlayer isNil 		ifTrue: 			[(ms := Time millisecondClockValue) < msAtStart 				ifTrue: 					["clock rollover"					msAtStart := ms - (frameNumber * msPerFrame)].			simTime := ms - msAtStart]		ifFalse: [simTime := scorePlayer millisecondsSinceStart].	playDirection > 0 		ifTrue: 			[nextFrameNumber := frameAtLastSync 						+ ((simTime - msAtLastSync) // msPerFrame).			nextFrameNumber = frameNumber 				ifTrue: 					[((scorePlayer isKindOf: AbstractSound) and: [scorePlayer isPlaying not]) 						ifTrue: [^self stopRunning].					^self]]		ifFalse: 			[nextFrameNumber := playDirection < 0 						ifTrue: [frameNumber - 1]						ifFalse: [frameNumber]].	byteCount := self fileByteCountPerFrame.	self stepSoundTrack.	movieFile waitForCompletion.	movieFile 		primReadResult: movieFile fileHandle		intoBuffer: (frameBufferIfScaled ifNil: [currentPage image]) bits		at: 1		count: byteCount // 4.	frameBufferIfScaled ifNotNil: 			["If this player has been shrunk, then we have to warp to the current page."			(WarpBlt current toForm: currentPage image)				sourceForm: frameBufferIfScaled;				combinationRule: 3;				cellSize: (playDirection = 0 							ifTrue: 								["Use smoothing if just stepping"								2]							ifFalse: [1]);				copyQuad: frameBufferIfScaled boundingBox innerCorners					toRect: currentPage image boundingBox].	currentPage changed.	frameNumber := nextFrameNumber.	(playDirection = 0 or: 			[(playDirection > 0 and: [frameNumber >= frameCount]) 				or: [playDirection < 0 and: [frameNumber <= 1]]]) 		ifTrue: [^self stopRunning].	"Start the read operation for the next frame..."	movieFile 		primReadStart: movieFile fileHandle		fPosition: (self filePosForFrameNo: frameNumber)		count: byteCount! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'aoy 2/15/2003 21:45'!stepSoundTrack	| x image timeInMillisecs |	scorePlayer ifNil: [^self].	soundTrackForm ifNil: [^self].	timeInMillisecs := playDirection = 0 		ifTrue: 			["Stepping forward or back"			 (frameNumber - 1) * msPerFrame]		ifFalse: 			["Driven by sound track"			 scorePlayer millisecondsSinceStart].	x := timeInMillisecs / 1000.0 * scorePlayer originalSamplingRate // 250.	image := soundTrackMorph image.	image 		copy: (image boundingBox translateBy: (x - (image width // 2)) @ 0)		from: soundTrackForm		to: 0 @ 0		rule: Form over.	soundTrackMorph changed! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:29'!initialize	"initialize the state of the receiver"	super initialize.	""	fullDisplay _ false.		lastFullUpdateTime _ 0.	self listDirection: #topToBottom;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap! !!NebraskaServerMorph methodsFor: 'initialization' stamp: 'aoy 2/15/2003 21:35'!setColorsAndBorder	| worldColor c |	c := ((Preferences menuColorFromWorld and: [Display depth > 4]) 				and: [(worldColor := self currentWorld color) isColor]) 					ifTrue: 						[worldColor luminance > 0.7 							ifTrue: [worldColor mixed: 0.8 with: Color black]							ifFalse: [worldColor mixed: 0.4 with: Color white]]					ifFalse: [Preferences menuColor]. 	self color: c.	self borderColor: #raised.	self borderWidth: Preferences menuBorderWidth.	self useRoundedCorners! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/16/2003 20:36'!numberOneColor: aColor 	myTarget fillStyle isGradientFill 		ifFalse: 			[^(myTarget isSystemWindow) 				ifTrue: [myTarget setWindowColor: aColor]				ifFalse: [myTarget fillStyle: aColor]].	myTarget fillStyle 		firstColor: aColor		forMorph: myTarget		hand: nil! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/16/2003 20:36'!rebuild	self removeAllMorphs.	self addARow: { 				self lockedString: 'Properties for ' , myTarget name}.	self addARow: { 				self inAColumn: { 							self paneForCornerRoundingToggle.							self paneForStickinessToggle.							self paneForLockedToggle}}.	self addARow: { 				self paneForMainColorPicker.				self paneFor2ndGradientColorPicker}.	self addARow: { 				self paneForBorderColorPicker.				self paneForShadowColorPicker}.	self 		addARow: { 				self 					buttonNamed: 'Accept'					action: #doAccept					color: color lighter					help: 'keep changes made and close panel'.				self 					buttonNamed: 'Cancel'					action: #doCancel					color: color lighter					help: 'cancel changes made and close panel'} , self rebuildOptionalButtons.	thingsToRevert := Dictionary new.	"thingsToRevert at: #fillStyle: put: myTarget fillStyle."	(myTarget isSystemWindow) 		ifTrue: [thingsToRevert at: #setWindowColor: put: myTarget paneColorToUse].	thingsToRevert at: #hasDropShadow: put: myTarget hasDropShadow.	thingsToRevert at: #shadowColor: put: myTarget shadowColor.	(myTarget respondsTo: #borderColor:) 		ifTrue: [thingsToRevert at: #borderColor: put: myTarget borderColor].	thingsToRevert at: #borderWidth: put: myTarget borderWidth.	thingsToRevert at: #cornerStyle: put: myTarget cornerStyle.	thingsToRevert at: #sticky: put: myTarget isSticky.	thingsToRevert at: #lock: put: myTarget isLocked! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'gm 2/22/2003 13:16'!rebuildOptionalButtons	| answer |	answer := { 				self transparentSpacerOfSize: 20 @ 3.				self 					buttonNamed: 'Button'					action: #doButtonProperties					color: color lighter					help: 'open a button properties panel for the morph'}.	(myTarget isTextMorph) 		ifTrue: 			[answer := answer , { 								self 									buttonNamed: 'Text'									action: #doTextProperties									color: color lighter									help: 'open a text properties panel for the morph'}].	^answer! !!ObjectPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:44'!defaultBorderColor"answer the default border color/fill style for the receiver"	^ self defaultColor darker! !!ObjectPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:44'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.548		g: 0.839		b: 0.452! !!ObjectPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:44'!initialize"initialize the state of the receiver"	super initialize.""	myTarget		ifNil: [myTarget _ RectangleMorph new openInWorld].	self rebuild! !!ObjectsTool methodsFor: 'search' stamp: 'dgd 2/22/2003 13:36'!showMorphsMatchingSearchString	"Put items matching the search string into my lower pane"	| quads |	self setSearchStringFromSearchPane.	submorphs last removeAllMorphs.	searchString isEmpty ifTrue: [^self].	quads := OrderedCollection new.	Morph withAllSubclasses do: 			[:aClass | 			aClass addPartsDescriptorQuadsTo: quads				if: [:info | info formalName includesSubstring: searchString caseSensitive: false]].	self installQuads: quads fromButton: nil! !!PhonemeRecognizerMorph methodsFor: 'button and menu commands' stamp: 'dgd 2/22/2003 13:46'!readPhonemes	"Read a previously saved phoneme set from a file."	| fname s newPhonemes |	fname := Utilities chooseFileWithSuffixFromList: #('.pho' '.phonemes')				withCaption: 'Phoneme file?'.	fname isNil ifTrue: [^self].	fname ifNil: [^self].	s := FileStream readOnlyFileNamed: fname.	newPhonemes := s fileInObjectAndCode.	s close.	phonemeRecords := newPhonemes! !!PianoKeyboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryLightGray! !!PianoKeyboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:56'!initialize	"initialize the state of the receiver"	super initialize.	""		whiteKeyColor _ Color gray: 0.95.	blackKeyColor _ Color black.	playingKeyColor _ Color red.	nOctaves _ 6.	self buildKeyboard.	soundPrototype _ FMSound brass1 duration: 9.9! !!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:55'!initialize"initialize the state of the receiver"	super initialize.""	buildingChord _ false.	self addRecordingControls.	self duration: 4 onOff: true.	self durMod: #normal onOff: true.	self articulation: #normal onOff: true.	insertMode _ false! !!MIDIPianoKeyboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:55'!initialize"initialize the state of the receiver"	super initialize.""	SimpleMIDIPort midiIsSupported		ifTrue: [midiPort _ SimpleMIDIPort openDefault].	channel _ 1.	velocity _ 100! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'dgd 2/21/2003 22:56'!copySelection	selection isNil ifTrue: [^self].	NotePasteBuffer := (score tracks at: selection first) 				copyFrom: selection second				to: selection third! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'dgd 2/21/2003 22:56'!cutSelection	selection isNil ifTrue: [^self].	self copySelection.	self deleteSelection! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'dgd 2/21/2003 22:56'!deleteSelection	| selMorphs priorEvent x |	(selection isNil or: [selection second = 0]) ifTrue: [^self].	score cutSelection: selection.	selection second > 1 		ifTrue: 			[selection at: 2 put: selection second - 1.			selection at: 3 put: selection second.			priorEvent := (score tracks at: selection first) at: selection second.			(x := self xForTime: priorEvent time) < (self left + 30) 				ifTrue: [self autoScrollForX: x - ((30 + self width) // 4)]]		ifFalse: [selection := nil].	scorePlayer updateDuration.	self rebuildFromScore.	selMorphs := self 				submorphsSatisfying: [:m | (m isKindOf: PianoRollNoteMorph) and: [m selected]].	selMorphs isEmpty ifFalse: [(selMorphs last noteOfDuration: 0.3) play]! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'dgd 2/21/2003 22:56'!insertSelection	self selection isNil ifTrue: [^self].	score insertEvents: NotePasteBuffer at: self selection.	scorePlayer updateDuration.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'dgd 2/21/2003 22:56'!insertTransposed	| delta transposedNotes |	(delta := (SelectionMenu 				selections: ((12 to: -12 by: -1) collect: [:i | i printString])) 					startUpWithCaption: 'offset...') ifNil: [^self].	transposedNotes := NotePasteBuffer 				collect: [:note | note copy midiKey: note midiKey + delta].	selection isNil ifTrue: [^self].	score insertEvents: transposedNotes at: self selection.	scorePlayer updateDuration.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:01'!initialize	"initialize the state of the receiver"	super initialize.	""		self extent: 400 @ 300.	showMeasureLines _ true.	showBeatLines _ false.	self timeSignature: 4 over: 4.	self clipSubmorphs: true! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGreen! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:35'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom.	self hResizing: #shrinkWrap.	"<--so naked buttons work right"	self vResizing: #shrinkWrap.	self wrapCentering: #center;		 cellPositioning: #topCenter.	model _ nil.	label _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	shortcutCharacter _ nil.	askBeforeChanging _ false.	triggerOnMouseDown _ false.	onColor _ self color darker.	offColor _ self color.	feedbackColor _ Color red.	showSelectionFeedback _ false.	allButtons _ nil.	argumentsProvider _ nil.	argumentsSelector _ nil.	self extent: 20 @ 15! !!PluggableButtonMorph methodsFor: 'private' stamp: 'dgd 2/21/2003 22:40'!getMenu: shiftPressed 	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector isNil ifTrue: [^nil].	menu := MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 		ifTrue: [^model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 		ifTrue: 			[^model 				perform: getMenuSelector				with: menu				with: shiftPressed].	^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'dgd 2/21/2003 22:41'!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	^ getStateSelector isNil 		ifTrue: [false]		ifFalse: [model perform: getStateSelector]! !!PluggableCollectionMorph methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:51'!balloonTextSelector: aSymbol "change the receiver's balloonTextSelector"	balloonTextSelector _ aSymbol! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'gm 2/24/2003 18:07'!getCollection	^(self collectionOrSelector isKindOf: Symbol) 		ifTrue: [self model perform: self collectionOrSelector]		ifFalse: [self collectionOrSelector]! !!PluggableCollectionMorph methodsFor: 'model access' stamp: 'gm 2/22/2003 13:16'!objectToString: anObject 	^self isObjectToStringAvailable 		ifTrue: 			[self model perform: self objectToStringSelector				withArguments: (Array with: anObject)]		ifFalse: 			[(anObject isString) 				ifTrue: [anObject]				ifFalse: [anObject printString]]! !!ProjectNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color orange! !!ProjectNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:30'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 6;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  useRoundedCorners.	mouseInside _ false.	self addButtons! !!KidNavigationMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:35'!defaultColor	"answer the default color/fill style for the receiver"	| result |	result _ GradientFillStyle ramp: {0.0					-> (Color							r: 0.032							g: 0.0							b: 0.484). 1.0					-> (Color							r: 0.194							g: 0.032							b: 1.0)}.	result origin: self bounds topLeft.	result direction: 0 @ 200.	result radial: false.	^ result! !!KidNavigationMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:35'!initialize	"initialize the state of the receiver"	| |	super initialize.	""	self layoutInset: 12.	self removeAllMorphs.	self addButtons! !!NebraskaNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/16/2003 14:11'!defaultColor	"answer the default color/fill style for the receiver"	^ Color yellow ! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/14/2003 21:06'!addControls	| b r partsBinButton newButton |	newButton _ ImageMorph new				image: (World project makeThumbnail scaledToSize: 24 @ 18).	newButton		on: #mouseDown		send: #insertNewProject:		to: self.	newButton setBalloonText: 'Make a new Project'.	(partsBinButton _ UpdatingThreePhaseButtonMorph checkBox) target: self;		 actionSelector: #togglePartsBinStatus;		 arguments: #();		 getSelector: #getPartsBinStatus.	(r _ AlignmentMorph newRow) color: Color transparent;		 borderWidth: 0;		 layoutInset: 0;		 wrapCentering: #center;		 cellPositioning: #topCenter;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 extent: 5 @ 5.	b _ SimpleButtonMorph new target: self;				 color: self defaultColor darker;				 borderColor: Color black.	r		addMorphBack: (self wrapperFor: (b label: 'Okay';					 actionSelector: #acceptSort)).	b _ SimpleButtonMorph new target: self;				 color: self defaultColor darker;				 borderColor: Color black.	r		addMorphBack: (self wrapperFor: (b label: 'Cancel';					 actionSelector: #delete));				addMorphBack: (self wrapperFor: newButton);		 addTransparentSpacerOfSize: 8 @ 0;				addMorphBack: (self wrapperFor: partsBinButton);				addMorphBack: (self wrapperFor: (StringMorph contents: 'Parts bin') lock).	self addMorphFront: r! !!ProjectSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:54'!defaultBorderWidth	"answer the default border width for the receiver"	^ 0 ! !!ProjectSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.365		g: 0.634		b: 0.729! !!ProjectSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:54'!initialize	"initialize the state of the receiver"	super initialize.	""	self useRoundedCorners.	pageHolder useRoundedCorners; borderWidth: 0;		color: (self				gridFormOrigin: 0 @ 0				grid: 16 @ 16				background: Color white				line: Color blue muchLighter)! !!ReferenceMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 13:20'!highlight	| str |	isHighlighted := true.	submorphs notEmpty 		ifTrue: 			[((str := submorphs first) isKindOf: StringMorph) 				ifTrue: [str color: self highlightColor]				ifFalse: 					[self						borderWidth: 1;						borderColor: self highlightColor]]! !!ReferenceMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 13:21'!isCurrentlyGraphical	"Answer whether the receiver is currently showing a graphical face"	| first |	^submorphs notEmpty and: 			[((first := submorphs first) isKindOf: ImageMorph) 				or: [first isKindOf: SketchMorph]]! !!ReferenceMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 13:21'!unHighlight	| str |	isHighlighted := false.	self borderWidth: 0.	submorphs notEmpty 		ifTrue: 			[((str := submorphs first) isKindOf: StringMorph orOf: RectangleMorph) 				ifTrue: [str color: self regularColor]]! !!ReferenceMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:49'!defaultBorderWidth"answer the default border width for the receiver"	^ 0! !!ReferenceMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:48'!defaultColor"answer the default color/fill style for the receiver"	^ Color transparent! !!ReferenceMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:49'!initialize"initialize the state of the receiver"	super initialize.""	isHighlighted _ false.	referent _ nil! !!ReferenceMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 12:51'!isCurrentlyTextual	| first |	^((first := submorphs first) isKindOf: StringMorph) 		or: [first isTextMorph]! !!ReferenceMorph methodsFor: 'naming' stamp: 'dgd 2/22/2003 13:21'!setNameTo: aString 	super setNameTo: aString.	(submorphs notEmpty and: [submorphs first isKindOf: StringMorph]) 		ifTrue: [submorphs first contents: aString]! !!FlapTab methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:49'!initialize"initialize the state of the receiver"	super initialize.""	edgeToAdhereTo _ #left.	flapShowing _ false.	slidesOtherObjects _ false.	popOutOnDragOver _ false.	popOutOnMouseOver _ false.	inboard _ false.	dragged _ false! !!FlapTab methodsFor: 'menu' stamp: 'gm 2/22/2003 13:11'!isCurrentlyTextual	| first |	^submorphs notEmpty and: 			[((first := submorphs first) isKindOf: StringMorph) 				or: [first isTextMorph]]! !!FlapTab methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:40'!useTextualTab	| stringToUse colorToUse |	self preserveDetails.	colorToUse := self valueOfProperty: #priorColor				ifAbsent: [Color green muchLighter].	submorphs notEmpty ifTrue: [self removeAllMorphs].	stringToUse := self valueOfProperty: #priorWording				ifAbsent: ['Unnamed Flap'].	self 		assumeString: stringToUse		font: Preferences standardFlapFont		orientation: self orientation		color: colorToUse! !!FlapTab methodsFor: 'solid tabs' stamp: 'dgd 2/21/2003 22:39'!changeTabThickness	| newThickness |	newThickness := FillInTheBlank request: 'New thickness:'				initialAnswer: self tabThickness printString.	newThickness notEmpty ifTrue: [self applyTabThickness: newThickness]! !!FlapTab methodsFor: 'textual tabs' stamp: 'aoy 2/15/2003 21:18'!assumeString: aString font: aFont orientation: orientationSymbol color: aColor 	| aTextMorph workString tabStyle |	labelString := aString asString.	workString := orientationSymbol == #vertical 				ifTrue: 					[String streamContents: 							[:s | 							labelString do: [:c | s nextPut: c] separatedBy: [s nextPut: Character cr]]]				ifFalse: [labelString]. 	tabStyle := (TextStyle new)				leading: -4;				newFontArray: (Array with: aFont).	aTextMorph := (TextMorph new setTextStyle: tabStyle) 				contents: (workString asText addAttribute: (TextKern kern: 3)).	self removeAllMorphs.	self		borderWidth: 2;		borderColor: #raised.	aColor ifNotNil: [self color: aColor].	self addMorph: aTextMorph centered.	aTextMorph lock	"FlapTab allSubInstancesDo: [:ft | ft reformatTextualTab]"! !!RemoteHandMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:51'!processEvents	"Process user input events from the remote input devices."	| evt |	evt := self getNextRemoteEvent.	[evt notNil] whileTrue: 			[evt type == #worldExtent 				ifTrue: 					[remoteWorldExtent := evt argument.					^self].			self handleEvent: evt.			evt := self getNextRemoteEvent]! !!RulerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:50'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!RulerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:50'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 1.0! !!ScaleMorph methodsFor: 'drawing' stamp: 'gm 2/28/2003 00:14'!buildLabels	| scale x1 y1 y2 x captionMorph tickMorph loopStart offset |	majorTickLength * minorTickLength < 0 		ifTrue: [minorTickLength := 0 - minorTickLength].	self removeAllMorphs.	caption ifNotNil: 			[captionMorph := StringMorph contents: caption.			offset := captionAbove 				ifTrue: [majorTickLength abs + captionMorph height + 7]				ifFalse: [2].			captionMorph align: captionMorph bounds bottomCenter				with: self bounds bottomCenter - (0 @ offset).			self addMorph: captionMorph].	tickPrintBlock ifNotNil: 			["Calculate the offset for the labels, depending on whether or not 			  1) there's a caption   			below, 2) the labels are above or below the ticks, and 3) the   			ticks go up or down"			offset := labelsAbove 						ifTrue: [majorTickLength abs + minorTickLength abs + 2]						ifFalse: [2].			caption 				ifNotNil: [captionAbove ifFalse: [offset := offset + captionMorph height + 2]].			scale := (self innerBounds width - 1) / (stop - start) asFloat.			x1 := self innerBounds left.			y1 := self innerBounds bottom.			y2 := y1 - offset.			"Start loop on multiple of majorTick"			loopStart := (start / majorTick) ceiling * majorTick.			loopStart to: stop				by: majorTick				do: 					[:v | 					x := x1 + (scale * (v - start)).					tickMorph := StringMorph contents: (tickPrintBlock value: v).					tickMorph align: tickMorph bounds bottomCenter with: x @ y2.					tickMorph left < self left 						ifTrue: [tickMorph position: self left @ tickMorph top].					tickMorph right > self right 						ifTrue: [tickMorph position: (self right - tickMorph width) @ tickMorph top].					self addMorph: tickMorph]]! !!ScaleMorph methodsFor: 'drawing' stamp: 'aoy 2/15/2003 21:15'!drawMajorTicksOn: aCanvas 	| scale x1 y1 y2 x y3 even yy loopStart checkStart yoffset randomLabel |	scale := (self innerBounds width - 1) / (stop - start) asFloat.	yoffset := majorTickLength < 0 		ifTrue: [ majorTickLength abs + 1]		ifFalse: [1].	caption ifNotNil: 			[captionAbove 				ifFalse: 					[randomLabel := StringMorph contents: 'Foo'.					yoffset := yoffset + randomLabel height + 2]].	tickPrintBlock ifNotNil: 			[labelsAbove 				ifFalse: 					[randomLabel := StringMorph contents: '50'.					yoffset := yoffset + randomLabel height + 2]].	x1 := self innerBounds left.	y1 := self innerBounds bottom - yoffset.	y2 := y1 - majorTickLength.	y3 := y1 - ((minorTickLength + majorTickLength) // 2).	even := true.	"Make sure major ticks start drawing on a multiple of majorTick"	loopStart := (start / majorTick) ceiling * majorTick.	checkStart := (start / (majorTick / 2.0)) ceiling * majorTick.	"Check to see if semimajor tick should be drawn before majorTick"	checkStart = (loopStart * 2) 		ifFalse: 			[loopStart := checkStart / 2.0.			even := false].	loopStart to: stop		by: majorTick / 2.0		do: 			[:v | 			x := x1 + (scale * (v - start)).			yy := even ifTrue: [y2] ifFalse: [y3].			aCanvas 				line: x @ y1				to: x @ yy				width: 1				color: Color black.			even := even not]! !!ScaleMorph methodsFor: 'drawing' stamp: 'aoy 2/15/2003 21:16'!drawMinorTicksOn: aCanvas 	| scale x1 y1 y2 x loopStart yoffset randomLabel |	scale := (self innerBounds width - 1) / (stop - start) asFloat.	yoffset := majorTickLength < 0 				ifTrue: [majorTickLength abs + 1]				ifFalse: [1]. 	caption ifNotNil: 			[captionAbove 				ifFalse: 					[randomLabel := StringMorph contents: 'Foo'.					yoffset := yoffset + randomLabel height + 2]].	tickPrintBlock ifNotNil: 			[labelsAbove 				ifFalse: 					[randomLabel := StringMorph contents: '50'.					yoffset := yoffset + randomLabel height + 2]].	x1 := self innerBounds left.	y1 := self innerBounds bottom - yoffset.	y2 := y1 - minorTickLength.	loopStart := (start / minorTick) ceiling * minorTick.	loopStart to: stop		by: minorTick		do: 			[:v | 			x := x1 + (scale * (v - start)).			aCanvas 				line: x @ y1				to: x @ y2				width: 1				color: Color black]! !!ScaleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 0! !!ScaleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGreen! !!ScaleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:00'!initialize	"initialize the state of the receiver"	super initialize.	""		start _ 0.	stop _ 100.	minorTick _ 1.	majorTick _ 10.	minorTickLength _ 3.	majorTickLength _ 10.	caption _ nil.	tickPrintBlock _ [:v | v printString].	labelsAbove _ true.	captionAbove _ true! !!ScorePlayerMorph methodsFor: 'controls' stamp: 'gm 2/28/2003 00:28'!atTrack: trackIndex from: aPopUpChoice selectInstrument: selection 	| oldSnd name snd |	oldSnd := scorePlayer instrumentForTrack: trackIndex.	(selection beginsWith: 'edit ') 		ifTrue: 			[name := selection copyFrom: 6 to: selection size.			aPopUpChoice contentsClipped: name.			(oldSnd isKindOf: FMSound) | (oldSnd isKindOf: LoopedSampledSound) 				ifTrue: [EnvelopeEditorMorph openOn: oldSnd title: name].			(oldSnd isKindOf: SampledInstrument) 				ifTrue: [EnvelopeEditorMorph openOn: oldSnd allNotes first title: name].			^self].	snd := nil.	1 to: instrumentSelector size		do: 			[:i | 			(trackIndex ~= i and: [selection = (instrumentSelector at: i) contents]) 				ifTrue: [snd := scorePlayer instrumentForTrack: i]].	"use existing instrument prototype"	snd ifNil: 			[snd := (selection = 'clink' 				ifTrue: 					[(SampledSound samples: SampledSound coffeeCupClink								samplingRate: 11025) ]				ifFalse: [(AbstractSound soundNamed: selection)]) copy].	scorePlayer instrumentForTrack: trackIndex put: snd.	(instrumentSelector at: trackIndex) contentsClipped: selection! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryLightGray! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:25'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 wrapCentering: #center;		 cellPositioning: #topCenter;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 3;		 onScorePlayer: ScorePlayer new initialize title: ' ';		 extent: 20 @ 20 ! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:52'!saveAsAIFF	"Create a stereo AIFF audio file with the result of performing my score."	| fileName |	fileName := FillInTheBlank request: 'New file name?'.	fileName isEmpty ifTrue: [^self].	(fileName asLowercase endsWith: '.aif') 		ifFalse: [fileName := fileName , '.aif'].	scorePlayer storeAIFFOnFileNamed: fileName! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:52'!saveAsSunAudio	"Create a stereo Sun audio file with the result of performing my score."	| fileName |	fileName := FillInTheBlank request: 'New file name?'.	fileName isEmpty ifTrue: [^self].	(fileName asLowercase endsWith: '.au') 		ifFalse: [fileName := fileName , '.au'].	scorePlayer storeSunAudioOnFileNamed: fileName! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:52'!saveAsWAV	"Create a stereo WAV audio file with the result of performing my score."	| fileName |	fileName := FillInTheBlank request: 'New file name?'.	fileName isEmpty ifTrue: [^self].	(fileName asLowercase endsWith: '.wav') 		ifFalse: [fileName := fileName , '.wav'].	scorePlayer storeWAVOnFileNamed: fileName! !!ScreeningMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:57'!fullDrawOn: aCanvas 	| mergeForm |	submorphs isEmpty ifTrue: [^super fullDrawOn: aCanvas].	(aCanvas isVisible: self fullBounds) ifFalse: [^self].	(submorphs size = 1 or: [displayMode == #showScreenOnly]) 		ifTrue: [^aCanvas fullDrawMorph: self screenMorph].	displayMode == #showSourceOnly 		ifTrue: [^aCanvas fullDrawMorph: self sourceMorph].	displayMode == #showScreenOverSource 		ifTrue: 			[aCanvas fullDrawMorph: self sourceMorph.			^aCanvas fullDrawMorph: self screenMorph].	displayMode == #showScreened 		ifTrue: 			[aCanvas fullDrawMorph: self screenMorph.			self flag: #fixCanvas.	"There should be a more general way than this"			mergeForm := self sourceMorph 						imageFormForRectangle: self screenMorph bounds.			(BitBlt current toForm: mergeForm) 				copyForm: self screenForm				to: 0 @ 0				rule: Form and				colorMap: (Bitmap with: 0 with: 4294967295).			aCanvas paintImage: mergeForm at: self screenMorph position]! !!ScreeningMorph methodsFor: 'menus' stamp: 'dgd 2/21/2003 22:57'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	submorphs isEmpty 		ifTrue: [^aCustomMenu add: '*Please add a source morph*' action: #itself].	submorphs size = 1 		ifTrue: [^aCustomMenu add: '*Please add a screen morph*' action: #itself].	submorphs size > 2 		ifTrue: [^aCustomMenu add: '*I have too many submorphs*' action: #itself].	aCustomMenu add: 'show screen only' action: #showScreenOnly.	aCustomMenu add: 'show source only' action: #showSourceOnly.	aCustomMenu add: 'show screen over source' action: #showScreenOverSource.	aCustomMenu add: 'show source screened' action: #showScreened.	aCustomMenu add: 'exchange source and screen' action: #exchange.	displayMode == #showScreenOnly 		ifTrue: 			[aCustomMenu add: 'choose passing color' action: #choosePassingColor.			aCustomMenu add: 'choose blocking color' action: #chooseBlockingColor]! !!ScreeningMorph methodsFor: 'private' stamp: 'aoy 2/15/2003 21:40'!screenForm	| screenImage colorMap pickValue elseValue |	screenForm ifNotNil: [^screenForm].	passElseBlock ifNil: [passElseBlock := true].	passingColor ifNil: [passingColor := Color black].	elseValue := passElseBlock 		ifTrue: 			[pickValue := 4294967295.			 0]		ifFalse: 			[pickValue := 0.			 4294967295].	screenImage := self screenMorph 				imageFormForRectangle: self screenMorph bounds.	colorMap := screenImage newColorMap atAllPut: elseValue.	colorMap at: (passingColor indexInMap: colorMap) put: pickValue.	screenForm := Form extent: screenImage extent.	screenForm 		copyBits: screenForm boundingBox		from: screenImage		at: 0 @ 0		colorMap: colorMap.	^screenForm! !!ScreeningMorph methodsFor: 'private' stamp: 'dgd 2/21/2003 22:57'!screenMorph	^submorphs first! !!ScreeningMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 18:53'!sourceMorph	^submorphs second! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'dgd 2/22/2003 19:38'!buttonRowForEditor	"Answer a row of buttons that comprise the header at the top of the Scriptor"	| aRow aString buttonFont aStatusMorph aButton aColumn aTile |	buttonFont := Preferences standardButtonFont.	aRow := (AlignmentMorph newRow)				color: Color transparent;				layoutInset: 0.	aRow hResizing: #shrinkWrap.	aRow vResizing: #shrinkWrap.	self hasParameter 		ifFalse: 			[aRow addMorphFront: ((SimpleButtonMorph new)						label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);						target: self;						color: Color yellow;						borderWidth: 0;						actWhen: #whilePressed;						actionSelector: #tryMe;						balloonTextSelector: #tryMe).			aRow addTransparentSpacerOfSize: 6 @ 10].	self addDismissButtonTo: aRow.	aRow addTransparentSpacerOfSize: 6 @ 1.	aColumn := AlignmentMorph newColumn beTransparent.	aColumn addTransparentSpacerOfSize: 0 @ 4.	aButton := UpdatingThreePhaseButtonMorph checkBox.	aButton		target: self;		actionSelector: #toggleWhetherShowingTiles;		getSelector: #showingMethodPane.	aButton 		setBalloonText: 'toggle between showing tiles and showing textual code'.	aColumn addMorphBack: aButton.	aRow addMorphBack: aColumn.	aRow addTransparentSpacerOfSize: 6 @ 10.	aString := playerScripted externalName.	aRow addMorphBack: (aButton := (SimpleButtonMorph new useSquareCorners)						label: aString font: buttonFont;						target: self;						setNameTo: 'title').	aButton		actWhen: #buttonDown;		actionSelector: #offerScriptorMenu.	aButton		on: #mouseEnter			send: #menuButtonMouseEnter:			to: aButton;		on: #mouseLeave			send: #menuButtonMouseLeave:			to: aButton.	aButton borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButton color: ScriptingSystem uniformTileInteriorColor.	aButton balloonTextSelector: #offerScriptorMenu.	aRow addTransparentSpacerOfSize: 4 @ 1.	aButton := (Preferences universalTiles 				ifTrue: [SyntaxUpdatingStringMorph]				ifFalse: [UpdatingStringMorph]) new.	aButton		useStringFormat;		target: self;		getSelector: #scriptTitle;		setNameTo: 'script name';		font: ScriptingSystem fontForNameEditingInScriptor;		putSelector: #setScriptNameTo:;		setProperty: #okToTextEdit toValue: true;		step.	aRow addMorphBack: aButton.	aButton setBalloonText: 'Click here to edit the name of the script.'.	aRow addTransparentSpacerOfSize: 6 @ 0.	self hasParameter 		ifTrue: 			[aTile := TypeListTile new choices: Vocabulary typeChoices dataType: nil.			aTile addArrows.			aTile setLiteral: #Number.			aTile 				on: #mouseDown				send: #handUserParameterTile				to: self.			"(aButton _ SimpleButtonMorph new useSquareCorners label: 'parameter' font: buttonFont; target: self; setNameTo: 'parameter').			aButton actWhen: #buttonDown; actionSelector: #handUserParameterTile."			aRow addMorphBack: aTile.			aTile borderColor: Color red.			aTile color: ScriptingSystem uniformTileInteriorColor.			aTile setBalloonText: 'Drag from here to get a parameter tile']		ifFalse: 			[aRow 				addMorphBack: (aStatusMorph := self scriptInstantiation statusControlMorph)].	aRow addTransparentSpacerOfSize: 6 @ 1.	aRow addMorphBack: ((IconicButton new)				borderWidth: 0;				labelGraphic: (ScriptingSystem formAtKey: 'AddTest');				color: Color transparent;				actWhen: #buttonDown;				target: self;				actionSelector: #addYesNoToHand;				shedSelvedge;				balloonTextSelector: #addYesNoToHand).	aRow addTransparentSpacerOfSize: 12 @ 10.	self addDestroyButtonTo: aRow.	(playerScripted existingScriptInstantiationForSelector: scriptName) 		ifNotNilDo: [:inst | inst updateStatusMorph: aStatusMorph].	^aRow! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ ScriptingSystem colorBehindTiles! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:24'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 cellPositioning: #topLeft;		 setProperty: #autoFitContents toValue: true;	 layoutInset: 2;	 useRoundedCorners.	firstTileRow _ 1.	"index of first tile-carrying submorph"	self addNewRow.	showingMethodPane _ false! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:03'!updateToPlayer: newPlayer 	"Make certain that the script name and the names of actors within are up to date"	| currentName titleMorph |	playerScripted ifNil: 			["likely a naked test/yes/no fragment!!"			^self].	newPlayer == playerScripted ifTrue: [^self].	"Already points to him"	self allMorphs do: 			[:m | 			(m isKindOf: TileMorph) 				ifTrue: 					[m retargetFrom: playerScripted to: newPlayer.					m bringUpToDate]].	playerScripted := newPlayer.	currentName := playerScripted externalName.	submorphs isEmpty ifTrue: [^self].	self firstSubmorph submorphsDo: 			[:m | 			"align"			"try quick way"			m knownName = 'title' ifTrue: [titleMorph := m]].	titleMorph ifNil: 			[titleMorph := self firstSubmorph 						findDeepSubmorphThat: [:m | m knownName = 'title']						ifAbsent: [nil]].	titleMorph ifNotNil: 			[titleMorph label: currentName , ' ' , self scriptName				font: ScriptingSystem fontForTiles]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 2/21/2003 23:03'!hibernate	"Possibly delete the tiles, but only if using universal tiles."	| tw |	Preferences universalTiles ifFalse: [^self].	(tw := self findA: TwoWayScrollPane) isNil 		ifFalse: 			[self setProperty: #sizeAtHibernate toValue: self extent.	"+ tw xScrollerHeight"			submorphs size > 1 ifTrue: [tw delete]]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'gm 2/22/2003 18:59'!methodNodeMorph	"Answer the morph that constitutes the receiver's method node"	submorphs size < 2  ifTrue: [^ nil].	^ self findDeepSubmorphThat:		[:aMorph | (aMorph isSyntaxMorph) and:				[aMorph parseNode isKindOf: MethodNode]]			ifAbsent: [nil]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'aoy 2/15/2003 21:13'!storeCodeOn: aStream indent: tabCount 	| lastOwner |	lastOwner := nil.	self tileRows do: 			[:r | 			r do: 					[:m | 					((m isKindOf: TileMorph) 						or: [(m isKindOf: CompoundTileMorph) or: [m isKindOf: PhraseTileMorph]]) 							ifTrue: 								[tabCount timesRepeat: [aStream tab].								(m owner ~= lastOwner and: [lastOwner ~= nil]) 									ifTrue: 										[aStream											nextPut: $.;											cr;											tab.										]									ifFalse: 										[lastOwner ~= nil ifTrue: [aStream space].										].								m storeCodeOn: aStream indent: tabCount.								lastOwner := m owner]]]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 2/21/2003 23:03'!unhibernate	"Recreate my tiles from my method if I have new universal tiles."	self topEditor == self ifFalse: [^self].	"Part of a compound test"	self updateHeader.	self world ifNil: 			[(playerScripted isNil or: [playerScripted isUniversalTiles not]) 				ifTrue: [^self]]		ifNotNil: [Preferences universalTiles ifFalse: [^self]].	self insertUniversalTiles.	self showingMethodPane: false! !!ScriptEditorMorph methodsFor: 'scripting' stamp: 'dgd 2/21/2003 23:03'!bringUpToDate	"Make certain that the player name in my header is up to date.  Names emblazoned on submorphs of mine are handled separately by direct calls to their #bringUpToDate methods -- the responsibility here is strictly for the name in the header."	| currentName |	playerScripted ifNil: 			["likely a naked test/yes/no fragment!!"			^self].	currentName := playerScripted externalName.	submorphs isEmpty ifTrue: [^self].	(self firstSubmorph findDeepSubmorphThat: [:m | m knownName = 'title']		ifAbsent: [^self]) label: currentName font: ScriptingSystem fontForTiles! !!BooleanScriptEditor methodsFor: 'dropping/grabbing' stamp: 'gm 2/22/2003 13:14'!wantsDroppedMorph: aMorph event: evt 	"Answer whether the receiver would be interested in accepting the morph"	(submorphs detect: [:m | m isAlignmentMorph] ifNone: [nil]) 		ifNotNil: [^false].	^(aMorph isKindOf: PhraseTileMorph) 		and: [(#(#Command #Unknown) includes: aMorph resultType capitalized) not]! !!BooleanScriptEditor methodsFor: 'other' stamp: 'dgd 2/22/2003 14:44'!storeCodeOn: aStream indent: tabCount 	(submorphs notEmpty and: [submorphs first submorphs notEmpty]) 		ifTrue: 			[aStream nextPutAll: '(('.			super storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ') ~~ false)'.			^self].	aStream nextPutAll: ' true '! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'dgd 2/22/2003 14:50'!frequency	(frequency isNil or: [frequency = 0]) ifTrue: [frequency := 1].	^frequency! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'dgd 2/16/2003 21:42'!player	"answer the receiver's player"	^ player! !!ScriptInstantiation methodsFor: 'running' stamp: 'dgd 2/22/2003 14:50'!runIfTicking: nowTick 	| ticks rate |	status == #ticking ifFalse: [^self].	rate := self tickingRate.	ticks := (lastTick isNil or: [nowTick < lastTick]) 				ifTrue: 					[lastTick := nowTick.					1]				ifFalse: [((nowTick - lastTick) * rate / 1000) asInteger].	ticks <= 0 ifTrue: [^self].	"Scripts which have been out of the world and then return can have a huge number of ticks accumulated. A better fix would be to reset <lastTick> when a script leaves/enters the world. Also, if the system is falling behind, this attempt to catch up can result in falling further behind, leading to sluggish behavior and termination of ticking status. Whether the user really wants this catch up behavior needs to be determined (often she will not, I suspect) and better ways of doing it need to be found"	ticks := 1.	1 to: ticks * self frequency do: [:i | player perform: selector].	lastTick := nowTick.	ticks > 10 		ifTrue: 			["check if we're lagging behind"			ticks <= ((Time millisecondClockValue - lastTick) * rate / 1000) asInteger 				ifTrue: 					["e.g., time to run script is higher than number of ticks"					self status: #paused.					self updateAllStatusMorphs]]! !!ScrollPane methodsFor: 'event handling' stamp: 'gm 2/16/2003 20:34'!mouseEnter: event 	hasFocus := true.	(owner isSystemWindow) ifTrue: [owner paneTransition: event].	self hideOrShowScrollBar! !!ScrollPane methodsFor: 'event handling' stamp: 'gm 2/16/2003 20:34'!mouseLeave: event 	hasFocus := false.	retractableScrollBar ifTrue: [self hideScrollBar].	(owner isSystemWindow) ifTrue: [owner paneTransition: event]! !!ScrollPane methodsFor: 'geometry' stamp: 'aoy 2/15/2003 21:36'!resizeScrollBar	| w topLeft borderHeight innerWidth |	w := self scrollbarWidth.	innerWidth := self flatColoredScrollBarLook 		ifTrue: 			[borderHeight := borderWidth.			0]		ifFalse: 			[borderHeight := 0.			 1].	topLeft := scrollBarOnLeft 				ifTrue: 					[retractableScrollBar 						ifTrue: [bounds topLeft - ((w - borderWidth) @ (0 - borderHeight))]						ifFalse: [bounds topLeft + ((borderWidth - innerWidth) @ borderHeight)]]				ifFalse: 					[retractableScrollBar 						ifTrue: [bounds topRight - (borderWidth @ (0 - borderHeight))]						ifFalse: 							[bounds topRight - ((w + borderWidth - innerWidth) @ (0 - borderHeight))]].	scrollBar 		bounds: (topLeft extent: w @ (bounds height - (borderHeight * 2)))! !!ScrollPane methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!ScrollPane methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:10'!initialize	"initialize the state of the receiver"	super initialize.	""	self initializePreferences.	hasFocus _ false.	self initializeScrollBar.	""	self extent: 150 @ 120! !!ScrollPane methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:51'!initializePreferences	"initialize the receiver's Preferences"	retractableScrollBar _ (Preferences valueOfFlag: #inboardScrollbars) not.	scrollBarOnLeft _ (Preferences valueOfFlag: #scrollBarsOnRight) not! !!ScrollPane methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:51'!initializeScrollBar"initialize the receiver's scrollBar"	scrollBar _ ScrollBar new model: self slotName: 'scrollBar'.	scrollBar borderWidth: 1;		 borderColor: Color black.	""	scroller _ TransformMorph new color: Color transparent.	scroller offset: -3 @ 0.	self addMorph: scroller.	""	scrollBar initializeEmbedded: retractableScrollBar not.	retractableScrollBar		ifFalse: [self addMorph: scrollBar]! !!ScrollPane methodsFor: 'menu' stamp: 'dgd 2/22/2003 14:49'!getMenu: shiftKeyState 	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector isNil ifTrue: [^nil].	menu := MenuMorph new defaultTarget: model.	aTitle := getMenuTitleSelector 				ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 		ifTrue: 			[aMenu := model perform: getMenuSelector with: menu.			aTitle ifNotNil: [aMenu addTitle: aTitle].			^aMenu].	getMenuSelector numArgs = 2 		ifTrue: 			[aMenu := model 						perform: getMenuSelector						with: menu						with: shiftKeyState.			aTitle ifNotNil: [aMenu addTitle: aTitle].			^aMenu].	^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!AlansTextPlusMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!AlansTextPlusMorph methodsFor: 'initialization' stamp: 'gm 3/10/2003 22:58'!initialize	"initialize the state of the receiver"	super initialize.	""	self initializeThePasteUp.	self position: 100@100.	self extent: Display extent // 3.	self useRoundedCorners.	! !!AlansTextPlusMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 16:38'!initializeThePasteUp"initialize the receiver's thePasteUp"	thePasteUp _ TextPlusPasteUpMorph new borderWidth: 0;				 color: color.	scroller addMorph: thePasteUp! !!PluggableListMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 23:05'!mouseUp: event 	"The mouse came up within the list; take appropriate action"	| aMorph |	aMorph := self itemFromPoint: event position.	aMorph ifNotNil: [aMorph highlightForMouseDown: false].	model okToChange ifFalse: [^self].	(autoDeselect == false and: [aMorph isNil]) ifTrue: [^self].	"work-around the no-mans-land bug"	"No change if model is locked"	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].	Cursor normal show! !!PluggableListMorph methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:05'!getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector isNil ifTrue: [^0].	^model perform: getIndexSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:05'!getList	"Answer the list to be displayed."	| lst |	getListSelector isNil ifTrue: [^#()].	lst := model perform: getListSelector.	lst isNil ifTrue: [^#()].	^lst! !!PluggableListMorph methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:05'!modifierKeyPressed: aChar 	| args |	keystrokeActionSelector isNil ifTrue: [^nil].	args := keystrokeActionSelector numArgs.	args = 1 ifTrue: [^model perform: keystrokeActionSelector with: aChar].	args = 2 		ifTrue: 			[^model 				perform: keystrokeActionSelector				with: aChar				with: self].	^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!ListComponent methodsFor: 'components' stamp: 'gm 2/27/2003 23:19'!initFromPinSpecs	| ioPin |	getListSelector := pinSpecs first modelReadSelector.	ioPin := pinSpecs second.	getIndexSelector := ioPin isInput 		ifTrue: [ioPin modelReadSelector]		ifFalse: [nil].	setIndexSelector := ioPin isOutput 				ifTrue: [ioPin modelWriteSelector]				ifFalse: [nil].	setSelectionSelector := pinSpecs third modelWriteSelector! !!PluggableListMorphByItem methodsFor: 'model access' stamp: 'dgd 2/22/2003 13:22'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector isNil ifTrue: [^0].	item := model perform: getIndexSelector.	^itemList findFirst: [:x | x = item]! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'aoy 2/15/2003 21:42'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| index oldIndex oldVal aMorph |	event position y < self top 		ifTrue: 			[scrollBar scrollUp: 1.			aMorph := self itemFromPoint: scroller topLeft + (1 @ 1)]		ifFalse: 			[aMorph := event position y > self bottom 				ifTrue: 					[scrollBar scrollDown: 1.					self itemFromPoint: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self itemFromPoint: event position]].	aMorph ifNil: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	index := scroller submorphs indexOf: aMorph.	index = 0 		ifTrue: [^self	"minimize chance of selecting with a pane border drag"].	dragOnOrOff ifNil: 			["Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff := (self listSelectionAt: index) not].	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: index put: dragOnOrOff == true.	aMorph changed! !!PluggableMessageCategoryListMorph methodsFor: 'model access' stamp: 'dgd 2/22/2003 14:13'!getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special '-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector isNil 		ifTrue: 			["should not happen!!"			priorRawList := nil.			^#()].	model classListIndex = 0 ifTrue: [^priorRawList := Array new].	priorRawList := model perform: getRawListSelector.	^(Array with: ClassOrganizer allCategory) , priorRawList! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'dgd 2/22/2003 13:22'!list: arrayOfLists 	| listOfStrings arrayOfMorphs index |	lists := arrayOfLists.	scroller removeAllMorphs.	listOfStrings := arrayOfLists isNil 				ifTrue: [Array new]				ifFalse: [arrayOfLists isEmpty ifFalse: [arrayOfLists first]].	list := listOfStrings ifNil: [Array new].	list isEmpty 		ifTrue: 			[self setScrollDeltas.			^self selectedMorph: nil].	arrayOfMorphs := self createMorphicListsFrom: arrayOfLists.	self layoutMorphicLists: arrayOfMorphs.	arrayOfMorphs do: [:morphList | scroller addAllMorphs: morphList].	index := self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > arrayOfMorphs first size]) 				ifFalse: [arrayOfMorphs first at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0! !!PluggableMultiColumnListMorphByItem methodsFor: 'model access' stamp: 'dgd 2/21/2003 22:40'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector isNil ifTrue: [^0].	item := model perform: getIndexSelector.	^itemList findFirst: [:x | x = item]! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:25'!initialize	"initialize the state of the receiver"	super initialize.""	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true.	"Use the dictionary #Text for gestures"	self gestureDictionaryOrName: #Text! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'dgd 2/21/2003 23:02'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: 			[(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?') 					ifFalse: [^self flash]].	textToAccept := textMorph asText.	ok := setTextSelector isNil or: 					[setTextSelector numArgs = 2 						ifTrue: 							[model 								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [model perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: 			[self setText: self getText.			self hasUnacceptedEdits: false.			(model dependents detect: 					[:dep | 					(dep isKindOf: PluggableTextMorph) 						and: [dep getTextSelector == #annotation]]				ifNone: [nil]) doIfNotNil: [:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: 			["(don't bother if there was an error during compile)"			(model isKindOf: CodeHolder) ifTrue: [model updateCodePaneIfNeeded].			WorldState addDeferredUIMessage: 					[self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					self selectFrom: saveSelection first to: saveSelection last]]] 			on: Error			do: []! !!PluggableTextMorph methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:02'!getSelection	"Answer the model's selection interval."	getSelectionSelector isNil ifTrue: [^1 to: 0].	"null selection"	^model perform: getSelectionSelector! !!PluggableTextMorph methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:02'!getText	"Retrieve the current model text"	| newText |	getTextSelector isNil ifTrue: [^Text new].	newText := model perform: getTextSelector.	newText ifNil: [^Text new].	^newText shallowCopy! !!PluggableTextMorph methodsFor: 'updating' stamp: 'dgd 2/22/2003 18:58'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: 			[self setText: self getText.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: 			[self handleEdit: 					[ParagraphEditor abandonChangeText.	"no replacement!!"					(textMorph editor)						setSearch: model autoSelectString;						againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: 			[self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: 			[self handleEdit: [self appendEntry].			^self refreshWorld].	aSymbol == #clearText 		ifTrue: 			[self handleEdit: [self changeText: Text new].			^self refreshWorld].	aSymbol == #bs 		ifTrue: 			[self handleEdit: [self bsText].			^self refreshWorld].	aSymbol == #codeChangedElsewhere 		ifTrue: 			[self hasEditingConflicts: true.			^self changed]! !!AcceptableCleanTextMorph methodsFor: 'menu commands' stamp: 'dgd 2/21/2003 22:50'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept := textMorph asText.	ok := setTextSelector isNil or: 					[setTextSelector numArgs = 2 						ifTrue: 							[model 								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [model perform: setTextSelector with: textToAccept]].	ok 		ifTrue: 			[self setText: self getText.			self hasUnacceptedEdits: false]! !!MethodMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:25'!initialize	"initialize the state of the receiver"	super initialize.	self useRoundedCorners! !!PluggableTextMorphWithModel methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:25'!initialize	"initialize the state of the receiver"	super initialize.	self		on: self		text: #getMyText		accept: #setMyText:		readSelection: nil		menu: nil! !!SelectionMorph methodsFor: 'halo commands' stamp: 'gm 2/22/2003 13:15'!addOrRemoveItems: handOrEvent 	"Make a new selection extending the current one."	| oldOwner hand |	hand := (handOrEvent isHandMorph) 				ifTrue: [handOrEvent]				ifFalse: [handOrEvent hand].	hand 		addMorphBack: ((self class 				newBounds: (hand lastEvent cursorPoint extent: 16 @ 16)) 					setOtherSelection: self).	oldOwner := owner.	self world abandonAllHalos.	"Will delete me"	oldOwner addMorph: self! !!SelectionMorph methodsFor: 'halo commands' stamp: 'nk 5/6/2003 21:00'!doDup: evt fromHalo: halo handle: dupHandle.	selectedItems _ self duplicateMorphCollection: selectedItems.	selectedItems do: [:m | self owner addMorph: m].	dupDelta isNil		ifTrue: ["First duplicate operation -- note starting location"				dupLoc _ self position.				evt hand grabMorph: self.				halo removeAllHandlesBut: dupHandle]		ifFalse: ["Subsequent duplicate does not grab, but only moves me and my morphs"				dupLoc _ nil.				self position: self position + dupDelta]! !!SelectionMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color blue! !!SelectionMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!SelectionMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!SelectionMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:23'!initialize	"initialize the state of the receiver"	super initialize.	""		selectedItems _ OrderedCollection new.	itemsAlreadySelected _ OrderedCollection new.	slippage _ 0 @ 0! !!SelectionMorph methodsFor: 'undo' stamp: 'jm 2/25/2003 16:27'!undoMove: cmd redo: redo owner: oldOwners bounds: oldBoundses predecessor: oldPredecessors 	"Handle undo and redo of move commands in morphic"	| item |	redo 		ifFalse: 			["undo sets up the redo state first"			cmd 				redoTarget: self				selector: #undoMove:redo:owner:bounds:predecessor:				arguments: { 						cmd.						true.						selectedItems collect: [:m | m owner].						selectedItems collect: [:m | m bounds].						selectedItems collect: [:m | m owner morphPreceding: m]}].	1 to: selectedItems size do: 				[:i | 				item := selectedItems at: i.				(oldOwners at: i) ifNotNil: 						[(oldPredecessors at: i) ifNil: [(oldOwners at: i) addMorphFront: item]							ifNotNil: [(oldOwners at: i) addMorph: item after: (oldPredecessors at: i)]].				item bounds: (oldBoundses at: i).				item isSystemWindow ifTrue: [item activate]]! !!SelectionMorph methodsFor: 'private' stamp: 'dgd 2/21/2003 23:18'!setOtherSelection: otherOrNil 	otherSelection := otherOrNil.	otherOrNil isNil 		ifTrue: [super borderColor: Color blue]		ifFalse: 			[itemsAlreadySelected := otherSelection selectedItems.			super borderColor: Color green]! !!SimpleBorder methodsFor: 'drawing' stamp: 'aoy 2/17/2003 01:14'!drawLineFrom: startPoint to: stopPoint on: aCanvas 	| lineColor |	lineColor := (stopPoint truncated quadrantOf: startPoint truncated) > 2 				ifTrue: [self topLeftColor]				ifFalse: [self bottomRightColor].	aCanvas 		line: startPoint		to: stopPoint 		width: self width		color: lineColor! !!ComplexBorder methodsFor: 'drawing' stamp: 'aoy 2/17/2003 01:08'!drawLineFrom: startPoint to: stopPoint on: aCanvas 	"Here we're using the balloon engine since this is much faster than BitBlt w/ brushes."	| delta length dir cos sin tfm w h w1 w2 h1 h2 fill |	width isPoint 		ifTrue: 			[w := width x.			h := width y]		ifFalse: [w := h := width].	w1 := w // 2.	w2 := w - w1.	h1 := h // 2.	h2 := h - h1.	"Compute the rotational transform from (0@0) -> (1@0) to startPoint -> stopPoint"	delta := stopPoint - startPoint.	length := delta r.	dir := length > 1.0e-10 ifTrue: [delta / length] ifFalse: [ 1 @ 0].	cos := dir dotProduct: 1 @ 0.	sin := dir crossProduct: 1 @ 0.	tfm := (MatrixTransform2x3 new)				a11: cos;				a12: sin;				a21: sin negated;				a22: cos.	"Install the start point offset"	tfm offset: startPoint.	"Now get the fill style appropriate for the given direction"	fill := self fillStyleForDirection: dir.	"And draw..."	aCanvas asBalloonCanvas transformBy: tfm		during: 			[:cc | 			cc drawPolygon: { 						(0 - w1) @ (0 - h1).	"top left"						(length + w2) @ (0 - h1).	"top right"						(length + w2) @ h2.	"bottom right"						(0 - w1) @ h2	"bottom left"}				fillStyle: fill]! !!ComplexBorder methodsFor: 'private' stamp: 'aoy 2/17/2003 01:02'!colorsForDirection: direction 	"Return an array of colors describing the receiver in the given direction"	| colorArray dT cc |	cc := self colors.	direction x * direction y <= 0 		ifTrue: 			["within up->right or down->left transition; no color blend needed"			colorArray := (direction x > 0 or: [direction y < 0]) 						ifTrue: 							["up->right"							cc copyFrom: 1 to: width]						ifFalse: 							["down->left"							"colors are stored in reverse direction when following a line"							(cc copyFrom: width + 1 to: cc size) reversed]]		ifFalse: 			["right->down or left->up transition; need color blend"			colorArray := Array new: width.			dT := direction x asFloat / (direction x + direction y).			(direction x > 0 or: [direction y >= 0]) 				ifTrue: 					["top-right"					1 to: width						do: 							[:i | 							colorArray at: i put: ((cc at: i) mixed: dT with: (cc at: cc size - i + 1))]]				ifFalse: 					["bottom-left"					1 to: width						do: 							[:i | 							colorArray at: i put: ((cc at: cc size - i + 1) mixed: dT with: (cc at: i))]]].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'aoy 2/17/2003 01:03'!computeAltInsetColors	| base light dark w colorArray param hw |	base := self color asColor.	light := Color white.	dark := Color black.	w := self width isPoint 				ifTrue: [self width x max: self width y]				ifFalse: [self width].	w := w asInteger.	colorArray := Array new: w * 2.	hw := 0.5 / w.	0 to: w - 1		do: 			[:i | 			param := false 						ifTrue: 							["whats this ???!! false ifTrue:[]"							0.5 + (hw * i)]						ifFalse: [0.5 + (hw * (w - i))].			colorArray at: i + 1 put: (base mixed: param with: dark).	"darken"			colorArray at: colorArray size - i put: (base mixed: param with: light)	"brighten"].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'aoy 2/17/2003 01:05'!computeAltRaisedColors	| base light dark w colorArray param hw |	base := self color asColor.	light := Color white.	dark := Color black.	w := self width isPoint 				ifTrue: [self width x max: self width y]				ifFalse: [self width].	w := w asInteger.	colorArray := Array new: w * 2.	hw := 0.5 / w.	0 to: w - 1		do: 			[:i | "again !! false ifTrue:[] ?!!"			param := false ifTrue: [0.5 + (hw * i)] ifFalse: [0.5 + (hw * (w - i))].			colorArray at: i + 1 put: (base mixed: param with: light).	"brighten"			colorArray at: colorArray size - i put: (base mixed: param with: dark)	"darken"].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'aoy 2/17/2003 01:06'!computeInsetColors	| base light dark w colorArray param hw |	base := self color asColor.	light := Color white.	dark := Color black.	w := self width isPoint 				ifTrue: [self width x max: self width y]				ifFalse: [self width].	w := w asInteger.	colorArray := Array new: w * 2.	hw := 0.5 / w.	0 to: w - 1		do: 			[:i | 			param := true 				ifTrue: [ 0.5 + (hw * i)]				ifFalse: [0.5 + (hw * (w - i))].			colorArray at: i + 1 put: (base mixed: param with: dark).	"darken"			colorArray at: colorArray size - i put: (base mixed: param with: light)	"brighten"].	^colorArray! !!ComplexBorder methodsFor: 'private' stamp: 'aoy 2/17/2003 01:07'!computeRaisedColors	| base light dark w colorArray param hw |	base := self color asColor.	light := Color white.	dark := Color black.	w := self width isPoint 				ifTrue: [self width x max: self width y]				ifFalse: [self width].	w := w asInteger.	colorArray := Array new: w * 2.	hw := 0.5 / w.	0 to: w - 1		do: 			[:i | 			param := true ifTrue: [0.5 + (hw * i)] ifFalse: [0.5 + (hw  * (w - i))].			colorArray at: i + 1 put: (base mixed: param with: light).	"brighten"			colorArray at: colorArray size - i put: (base mixed: param with: dark)	"darken"].	^colorArray! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 22:57'!fitContents	| aMorph aCenter |	aCenter := self center.	submorphs isEmpty ifTrue: [^self].	aMorph := submorphs first.	self extent: aMorph extent + (borderWidth + 6).	self center: aCenter.	aMorph position: aCenter - (aMorph extent // 2)! !!SimpleButtonMorph methodsFor: 'button' stamp: 'dgd 2/22/2003 18:53'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[Cursor normal 				showWhile: [target perform: actionSelector withArguments: arguments]].	actWhen == #startDrag ifTrue: [oldColor ifNotNil: [self color: oldColor]]! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:54'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetOffset.	target := rootMorphs size > 1 		ifTrue: [rootMorphs second]		ifFalse: [nil]! !!ChatButtonMorph methodsFor: 'events' stamp: 'dgd 2/22/2003 18:40'!doButtonDownAction	(target notNil and: [actionDownSelector notNil]) 		ifTrue: [Cursor normal showWhile: [target perform: actionDownSelector]]! !!ChatButtonMorph methodsFor: 'events' stamp: 'dgd 2/22/2003 18:40'!doButtonUpAction	(target notNil and: [actionUpSelector notNil]) 		ifTrue: [Cursor normal showWhile: [target perform: actionUpSelector]]! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 23:16'!keyStroke: event 	"Process potential command keys"	| args aCharacter |	(self scrollByKeyboard: event) ifTrue: [^self].	keystrokeActionSelector isNil ifTrue: [^nil].	aCharacter := event keyCharacter.	(args := keystrokeActionSelector numArgs) = 1 		ifTrue: [^model perform: keystrokeActionSelector with: aCharacter].	args = 2 		ifTrue: 			[^model 				perform: keystrokeActionSelector				with: aCharacter				with: self].	^self 		error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 23:16'!mouseUp: event 	| aMorph |	aMorph := self itemFromPoint: event position.	aMorph ifNil: [^self].	aMorph highlightedForMouseDown ifFalse: [^self].	aMorph highlightForMouseDown: false.	model okToChange ifFalse: [^self].	"No change if model is locked"	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].	Cursor normal show! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:26'!initialize	"initialize the state of the receiver"	super initialize.	self		on: #mouseMove		send: #mouseStillDown:onItem:		to: self! !!SimpleHierarchicalListMorph methodsFor: 'updating' stamp: 'dgd 2/21/2003 23:16'!update: aSymbol 	aSymbol == getSelectionSelector 		ifTrue: 			[self selection: self getCurrentSelectionItem.			^self].	aSymbol == getListSelector 		ifTrue: 			[self list: self getList.			^self].	((aSymbol isKindOf: Array) 		and: [aSymbol notEmpty and: [aSymbol first == #openPath]]) 			ifTrue: 				[^(scroller submorphs at: 1 ifAbsent: [^self]) 					openPath: aSymbol allButFirst]! !!EToyHierarchicalTextMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:25'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!EToyHierarchicalTextMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:27'!initialize	"initialize the state of the receiver"	super initialize.	self useRoundedCorners! !!SimpleSwitchMorph methodsFor: 'button' stamp: 'dgd 2/22/2003 18:40'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	| newState |	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[newState := color = onColor.			target perform: actionSelector				withArguments: (arguments copyWith: newState)]! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 15:12'!valuesForHand: anEventOrHand	| hand valuesForHand |	forEachHand ifNil: [forEachHand _ IdentityDictionary new].	hand _ (anEventOrHand isKindOf: HandMorph) 				ifTrue: [anEventOrHand] ifFalse: [anEventOrHand hand].	valuesForHand _ forEachHand at: hand ifAbsentPut: [Dictionary new].	^valuesForHand! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'gm 2/22/2003 12:59'!valuesForHandIfPresent: anEventOrHand 	| hand |	forEachHand ifNil: [forEachHand := IdentityDictionary new].	hand := (anEventOrHand isHandMorph) 				ifTrue: [anEventOrHand]				ifFalse: [anEventOrHand hand].	^forEachHand at: hand ifAbsent: [nil]! !!SketchEditorMorph methodsFor: 'access' stamp: 'dgd 2/21/2003 23:07'!ticksToDwell	ticksToDwell isNil ifTrue: [ticksToDwell := 1].	^ticksToDwell! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'aoy 2/15/2003 21:46'!forward: evt direction: button 	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center := bounds center.	"+ (rotationButton width - 6 @ 0)"	dir := evt isNumber 				ifTrue:  					[Point r: 100 degrees: evt - 90.0					"convert to 0 on X axis"]				ifFalse: [evt cursorPoint - center].	ww := (bounds height min: bounds width) // 2 - 7.	button 		setVertices: (Array with: center + (Point r: ww degrees: dir degrees)				with: center + (Point r: ww - 15 degrees: dir degrees)).	(ff := self valueOfProperty: #fwdToggle) 		position: center + (Point r: ww - 7 degrees: dir degrees + 6.5) 				- (ff extent // 2).	self showDirType! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'dgd 2/21/2003 23:06'!pickup: evt 	"Grab a part of the picture (or screen) and store it in a known place.  Note where we started.  Use a rubberband rectangle to show what is being selected."	| rect oldRect sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	rect := sOrigin rect: evt cursorPoint + (14 @ 14).	(priorEvt := self get: #lastEvent for: evt) isNil 		ifFalse: 			["Last draw will stick out, must erase the area"			oldRect := sOrigin rect: priorEvt cursorPoint + (14 @ 14).			self restoreRect: (oldRect insetBy: -2)].	formCanvas 		frameAndFillRectangle: (rect insetBy: -2)		fillColor: Color transparent		borderWidth: 2		borderColor: Color gray.	self invalidRect: (rect insetBy: -2)! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'dgd 2/21/2003 23:06'!pickupMouseUp: evt 	"Grab a part of the picture (or screen) and store it in a known place. Like Copy on the Mac menu. Then switch to the stamp tool."	| rr pForm ii oldRect sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	(priorEvt := self get: #lastEvent for: evt) isNil 		ifFalse: 			["Last draw will stick out, must erase the area"			oldRect := sOrigin rect: priorEvt cursorPoint + (14 @ 14).			self restoreRect: (oldRect insetBy: -2)].	self primaryHand showTemporaryCursor: nil.	"later get rid of this"	rr := sOrigin rect: evt cursorPoint + (14 @ 14).	ii := rr translateBy: 0 @ 0 - bounds origin.	(rr intersects: bounds) 		ifTrue: 			[pForm := paintingForm copy: ii.			pForm isAllWhite 				ifFalse: 					["means transparent"					"normal case.  Can be transparent in parts"					]				ifTrue: 					[pForm := nil					"Get an un-dimmed picture of other objects on the playfield"					"don't know how yet"]].	pForm ifNil: [pForm := Form fromDisplay: rr].	"Anywhere on the screen"	palette pickupForm: pForm evt: evt.	evt hand showTemporaryCursor: (self getCursorFor: evt)! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'dgd 2/21/2003 23:06'!rect: evt 	"While moving corner, just write on the canvas. When done, write 	on the paintingForm"	| rect within oldRect now diff cor cColor sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	rect := sOrigin rect: (now := evt cursorPoint).	cColor := self getColorFor: evt.	evt shiftPressed 		ifTrue: 			[diff := evt cursorPoint - sOrigin.			now := sOrigin + (Point r: (diff x abs min: diff y abs) * 2								degrees: diff degrees // 90 * 90 + 45).			rect := sOrigin rect: now].	(priorEvt := self get: #lastEvent for: evt) isNil 		ifFalse: 			[oldRect := sOrigin rect: priorEvt cursorPoint.			priorEvt shiftPressed 				ifTrue: 					[diff := priorEvt cursorPoint - sOrigin.					cor := sOrigin + (Point r: (diff x abs min: diff y abs) * 2										degrees: diff degrees // 90 * 90 + 45).					oldRect := sOrigin rect: cor].			within := rect containsRect: oldRect.			within & cColor isTransparent not 				ifFalse: 					["Last draw will stick out, must erase the area"					self restoreRect: oldRect]].	cColor == Color transparent 		ifTrue: 			[formCanvas 				frameAndFillRectangle: rect				fillColor: cColor				borderWidth: (self getNibFor: evt) width				borderColor: Color black]		ifFalse: 			[formCanvas 				frameAndFillRectangle: rect				fillColor: cColor				borderWidth: 0				borderColor: Color transparent].	self invalidRect: rect! !!SketchEditorMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:45'!mouseMove: evt 	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt priorEvt |	WorldState canSurrenderToOS: false.	"we want maximum responsiveness"	pt := evt cursorPoint.	priorEvt := self get: #lastEvent for: evt.	(priorEvt notNil and: [pt = priorEvt cursorPoint]) ifTrue: [^self].	self perform: (self getActionFor: evt) with: evt.	"Each action must do invalidRect:"	self 		set: #lastEvent		for: evt		to: evt.	false 		ifTrue: 			["So senders will find the things performed here"			self				paint: nil;				fill: nil;				erase: nil;				pickup: nil;				stamp: nil.			self				rect: nil;				ellipse: nil;				polygon: nil;				line: nil;				star: nil]! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white alpha: 0.5! !!SketchMorph methodsFor: 'accessing' stamp: 'gm 2/22/2003 13:14'!scaleFactor	"Answer the number representing my scaleFactor, assuming the receiver to be unflexed (if flexed, the renderer's scaleFactor is called instead"	| qty |	((qty := self scalePoint) isPoint) ifTrue: [^1.0].	^qty! !!SketchMorph methodsFor: 'drawing' stamp: 'gm 2/28/2003 00:27'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| scalePt smoothPix pair |	scalePoint ifNil: [scalePoint := 1 @ 1].	scalePt := scalePoint x abs @ scalePoint y abs.	rotationStyle == #none ifTrue: [scalePt := 1 @ 1].	smoothPix := (scalePt x < 1.0 or: [scalePt y < 1.0]) 		ifTrue: [2]		ifFalse: [1].	rotationStyle = #leftRight 		ifTrue: 			[self heading asSmallAngleDegrees < 0.0 				ifTrue: [scalePt := scalePt x negated @ scalePt y]].	rotationStyle = #upDown 		ifTrue: 			[self heading asSmallAngleDegrees abs > 90.0 				ifTrue: [scalePt := scalePt x @ scalePt y negated]].	rotatedForm := scalePt = (1 @ 1) 				ifTrue: [originalForm]				ifFalse: 					["ar 11/19/2001: I am uncertain what happens in the case of rotationStyle ~~ normal"					(rotationStyle == #normal and: [self useInterpolation]) 						ifTrue: [^self generateInterpolatedForm].					pair := WarpBlt current 								rotate: originalForm								degrees: 0								center: originalForm boundingBox center								scaleBy: scalePt								smoothing: smoothPix.					pair first]! !!SketchMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:51'!initialize"initialize the state of the receiver"	^ self initializeWith: (ScriptingSystem formAtKey: 'Painting') deepCopy! !!SketchMorph methodsFor: 'menu' stamp: 'aoy 2/17/2003 01:25'!editDrawingIn: aPasteUpMorph forBackground: forBackground 	| w bnds sketchEditor pal aPaintTab aWorld aPaintBox tfx |	self world assureNotPaintingElse: [^self].	w := aPasteUpMorph world.	w prepareToPaint.	w displayWorld.	self visible: false.	bnds := forBackground 				ifTrue: [aPasteUpMorph boundsInWorld]				ifFalse: 					[bnds := self boundsInWorld expandBy: 60 @ 60.					(aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds]. 	sketchEditor := SketchEditorMorph new.	forBackground 		ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor 		initializeFor: self		inBounds: bnds		pasteUpMorph: aPasteUpMorph.	sketchEditor afterNewPicDo: 			[:aForm :aRect | 			self visible: true.			self form: aForm.			tfx := aPasteUpMorph transformFrom: aPasteUpMorph world.			self topRendererOrSelf position: (tfx globalPointToLocal: aRect origin).			self rotationStyle: sketchEditor rotationStyle.			self forwardDirection: sketchEditor forwardDirection.			(aPaintTab := (aWorld := self world) paintingFlapTab) 				ifNotNil: [aPaintTab hideFlap]				ifNil: [(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete]].			self presenter drawingJustCompleted: self.			forBackground ifTrue: [self goBehind	"shouldn't be necessary"]]		ifNoBits: 			["If no bits drawn.  Must keep old pic.  Can't have no picture"			self visible: true.			aWorld := self currentWorld.			"sometimes by now I'm no longer in a world myself, but we still need				 to get ahold of the world so that we can deal with the palette"			((pal := aPasteUpMorph standardPalette) notNil and: [pal isInWorld]) 				ifTrue: 					[(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete].					pal viewMorph: self]				ifFalse: 					[(aPaintTab := (aWorld := self world) paintingFlapTab) 						ifNotNil: [aPaintTab hideFlap]						ifNil: [(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete]]]]! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'dgd 2/21/2003 23:07'!objectsInMemory	"See if page or bookMorph need to be brought in from a server."	| bookUrl bk wld try |	bookMorph ifNil: 			["fetch the page"			page class == String ifFalse: [^self].	"a morph"			try := (SqueakPageCache atURL: page) fetchContents.			try ifNotNil: [page := try].			^self].	bookMorph class == String 		ifTrue: 			[bookUrl := bookMorph.			(wld := self world) ifNil: [wld := Smalltalk currentWorld].			bk := BookMorph isInWorld: wld withUrl: bookUrl.			bk == #conflict 				ifTrue: [^self inform: 'This book is already open in some other project'].			bk == #out ifTrue: [(bk := BookMorph new fromURL: bookUrl) ifNil: [^self]].			bookMorph := bk].	page class == String 		ifTrue: 			[page := bookMorph pages detect: [:pg | pg url = page]						ifNone: [bookMorph pages first]]! !!BookPageThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!BookPageThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:53'!initialize	"initialize the state of the receiver"	| f |	super initialize.	""	flipOnClick _ false.		f _ Form extent: 60 @ 80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!BookPageThumbnailMorph methodsFor: 'objects from disk' stamp: 'dgd 2/21/2003 23:07'!objectForDataStream: refStrm 	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	bookMorph class == String & (page class == String) 		ifTrue: [^super objectForDataStream: refStrm].	bookMorph isNil & (page class == String) 		ifTrue: [^super objectForDataStream: refStrm].	bookMorph isNil & (page url notNil) 		ifTrue: [^super objectForDataStream: refStrm].	bookMorph isNil & page url isNil 		ifTrue: 			[self error: 'page should already have a url'			"find page's book, and remember it"			"bookMorph _ "].	clone := self clone.	(bookUrl := bookMorph url) 		ifNil: [bookUrl := self valueOfProperty: #futureUrl].	bookUrl ifNil: 			[bb := RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			refStrm replace: self with: bb.			^bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: 			["Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."			stem := SqueakPage stemUrl: bookUrl.			ind := bookMorph pages identityIndexOf: page.			page reserveUrl: stem , ind printString , '.sp'].	clone instVarNamed: 'page' put: page url.	refStrm replace: self with: clone.	^clone! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'gm 2/22/2003 13:12'!originalColor: colorOrSymbol 	"Set the receiver's original color.  It is at this point that a command is launched to represent the action of the picker, in support of Undo."	originalColor := (colorOrSymbol isColor) 				ifTrue: [colorOrSymbol]				ifFalse: [Color lightGreen].	originalForm fill: RevertBox fillColor: originalColor.	selectedColor := originalColor.	self locationIndicator 		center: self topLeft + (self positionOfColor: originalColor)! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'aoy 2/15/2003 21:24'!target: anObject 	target := anObject.	selectedColor := (target respondsTo: #color)  				ifTrue: [target color]				ifFalse: [Color white]! !!ColorPickerMorph methodsFor: 'private' stamp: 'dgd 2/21/2003 22:59'!modalBalloonHelpAtPoint: cursorPoint 	self flag: #arNote.	"Throw this away. There needs to be another way."	self submorphsDo: 			[:m | 			m wantsBalloon 				ifTrue: 					[(m valueOfProperty: #balloon) isNil						ifTrue: 							[(m containsPoint: cursorPoint) ifTrue: [m showBalloon: m balloonText]]						ifFalse: [(m containsPoint: cursorPoint) ifFalse: [m deleteBalloon]]]]! !!ColorPickerMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 18:41'!updateTargetColor	| nArgs |	(target notNil and: [selector notNil]) 		ifTrue: 			[self updateSelectorDisplay.			nArgs := selector numArgs.			nArgs = 1 ifTrue: [^target perform: selector with: selectedColor].			nArgs = 2 				ifTrue: 					[^target 						perform: selector						with: selectedColor						with: sourceHand].			nArgs = 3 				ifTrue: 					[^target 						perform: selector						with: selectedColor						with: argument						with: sourceHand]]! !!ColorPickerMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 18:41'!updateTargetColorWith: aColor 	"Update the target so that it reflects aColor as the color choice"	(target notNil and: [selector notNil]) 		ifTrue: 			[self updateSelectorDisplay.			^target perform: selector withArguments: (self argumentsWith: aColor)]! !!FatBitsPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryVeryLightGray! !!FatBitsPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:54'!initialize	"initialize the state of the receiver"	super initialize.	""	self setCurrentToolTo: self toolsForPaintBrush.	formToEdit _ Form extent: 50 @ 40 depth: 8.	formToEdit fill: formToEdit boundingBox fillColor: Color veryVeryLightGray.	brushSize _ magnification _ 4.		brushColor _ Color red.	backgroundColor _ Color white.	self revert! !!FatBitsPaint methodsFor: 'menus' stamp: 'dgd 2/22/2003 19:38'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu		add: 'background color' action: #setBackgroundColor:;		add: 'pen color' action: #setPenColor:;		add: 'pen size' action: #setPenSize:;		add: 'fill' action: #fill;		add: 'magnification' action: #setMagnification:;		add: 'accept' action: #accept;		add: 'revert' action: #revert;		add: 'inspect' action: #inspectForm;		add: 'file out' action: #fileOut;		add: 'selection...' action: #selectionMenu:;		add: 'tools...' action: #toolMenu:! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 14:41'!revealOriginal	((owner isKindOf: PasteUpMorph) and: [owner alwaysShowThumbnail]) 		ifTrue: [^self beep].	morphRepresented owner isNil 		ifTrue: [^owner replaceSubmorph: self by: morphRepresented].	self beep! !!MorphThumbnail methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!MorphThumbnail methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:51'!initialize	"initialize the state of the receiver"	| f |	super initialize.	""	f _ Form extent: 60 @ 80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'dgd 2/16/2003 21:37'!isPartsDonor	"answer whether the receiver is PartsDonor"	^ self partRepresented isPartsDonor! !!MorphThumbnail methodsFor: 'parts bin' stamp: 'dgd 2/16/2003 21:40'!isPartsDonor: aBoolean	"change the receiver's isPartDonor property"	self partRepresented isPartsDonor: aBoolean! !!MultiuserTinyPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryVeryLightGray! !!MultiuserTinyPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:52'!initialize	"initialize the state of the receiver"	super initialize.	""		drawState _ IdentityDictionary new.	self clear! !!Slider methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #inset! !!Slider methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!Slider methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 corner: 16 @ 100! !!Slider methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!Slider methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:30'!initialize	"initialize the state of the receiver"	super initialize.	""	value _ 0.0.	descending _ false.	self initializeSlider! !!ScrollBar methodsFor: 'initialize' stamp: 'aoy 2/15/2003 21:37'!initializeMenuButton	"Preferences disable: #scrollBarsWithoutMenuButton"	"Preferences enable: #scrollBarsWithoutMenuButton"	(Preferences valueOfFlag: #scrollBarsWithoutMenuButton) ifTrue: [^self].	menuButton := self roundedScrollbarLook 		ifTrue: 			[RectangleMorph 						newBounds: ((bounds isWide 								ifTrue: [upButton bounds topRight]								ifFalse: [upButton bounds bottomLeft]) extent: self buttonExtent)]		ifFalse: 			[RectangleMorph 						newBounds: (self innerBounds topLeft extent: self buttonExtent)						color: self thumbColor].	menuButton 		on: #mouseEnter		send: #menuButtonMouseEnter:		to: self.	menuButton 		on: #mouseDown		send: #menuButtonMouseDown:		to: self.	menuButton 		on: #mouseLeave		send: #menuButtonMouseLeave:		to: self.	menuButton 		addMorphCentered: (RectangleMorph newBounds: (0 @ 0 extent: 4 @ 2)				color: Color black).	self roundedScrollbarLook 		ifTrue: 			[menuButton color: Color veryLightGray.			menuButton borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [menuButton setBorderWidth: 1 borderColor: #raised].	self addMorph: menuButton! !!ScrollBar methodsFor: 'initialize' stamp: 'aoy 2/15/2003 21:37'!initializeUpButton	upButton := self roundedScrollbarLook 				ifTrue:  					[RectangleMorph 						newBounds: (self innerBounds topLeft extent: self buttonExtent)]				ifFalse: 					[RectangleMorph 						newBounds: ((menuButton ifNil: [self innerBounds topLeft]								ifNotNil: 									[bounds isWide 										ifTrue: [menuButton bounds topRight]										ifFalse: [menuButton bounds bottomLeft]]) 									extent: self buttonExtent)].	upButton color: self thumbColor.	upButton 		on: #mouseDown		send: #scrollUpInit		to: self.	upButton 		on: #mouseUp		send: #finishedScrolling		to: self.	upButton 		addMorphCentered: (ImageMorph new image: (self 						cachedImageAt: (bounds isWide ifTrue: ['left'] ifFalse: ['up'])						ifAbsentPut: 							[bounds isWide 								ifTrue: [self upArrow8Bit rotateBy: #left centerAt: 0 @ 0]								ifFalse: [self upArrow8Bit]])).	self roundedScrollbarLook 		ifTrue: 			[upButton color: Color veryLightGray.			upButton borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [upButton setBorderWidth: 1 borderColor: #raised].	self addMorph: upButton! !!ScrollBar methodsFor: 'scroll timing' stamp: 'dgd 2/21/2003 23:05'!waitForDelay1: delay1 delay2: delay2 	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll isNil ifTrue: [self resetTimer].	"Only needed for old instances"	now := Time millisecondClockValue.	(scrollDelay := currentScrollDelay) isNil 		ifTrue: [scrollDelay := delay1	"initial delay"].	currentScrollDelay := scrollDelay * 9 // 10 max: delay2.	"decrease the delay"	timeOfLastScroll := now.	^true! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 14:13'!setActionSelector	| oldSel newSel |	oldSel := setValueSelector isNil ifTrue: [''] ifFalse: [setValueSelector].	newSel := FillInTheBlank 				request: 'Please type the selector to be sent tothe target when this slider is changed'				initialAnswer: oldSel.	newSel isEmpty ifFalse: [self actionSelector: newSel]! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:55'!setTarget: evt 	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	target _ rootMorphs size > 1				ifTrue: [rootMorphs second]! !!SimpleSliderMorph methodsFor: 'model access' stamp: 'dgd 2/22/2003 18:58'!setValue: newValue 	"Update the target with this sliders new value."	| scaledValue |	self value: newValue.	scaledValue := newValue * (maxVal - minVal) + minVal.	truncate ifTrue: [scaledValue := scaledValue truncated].	(target notNil and: [setValueSelector notNil]) 		ifTrue: 			[Cursor normal showWhile: 					[target perform: setValueSelector						withArguments: (arguments copyWith: scaledValue)]]! !!Sonogram methodsFor: 'all' stamp: 'jdl 3/28/2003 09:30'!plotColumn: dataArray 	| chm1 i normVal r |	columnForm unhibernate.	chm1 := columnForm height - 1.	0 to: chm1		do: 			[:y | 			i := y * (dataArray size - 1) // chm1 + 1.			normVal := ((dataArray at: i) - minVal) / (maxVal - minVal).			normVal := normVal max: 0.0.			normVal := normVal min: 1.0.			columnForm bits at: chm1 - y + 1				put: (pixValMap at: (normVal * 255.0) truncated + 1)].	(lastX := lastX + 1) > (image width - 1) ifTrue: [self scroll].	image 		copy: (r := lastX @ 0 extent: 1 @ image height)		from: (32 // image depth - 1) @ 0		in: columnForm		rule: Form over.	"self changed."	self invalidRect: (r translateBy: self position)! !!SorterTokenMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 23:16'!forMorph: aMorph 	| it |	morphRepresented := aMorph.	aMorph submorphs notEmpty 		ifTrue: 			[self addMorphBack: (it := aMorph submorphs first veryDeepCopy).			it position: self position + (1 @ 1).			it lock].	self fitContents! !!SorterTokenMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color blue! !!SorterTokenMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!SorterTokenMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!SoundDemoMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:34'!playAll	| snd |	soundColumn submorphs isEmpty		ifTrue: [^ self].	self setTimbreFromTile: soundColumn submorphs first.	snd _ SampledSound bachFugueVoice1On: SampledSound new.	soundColumn submorphs size >= 2		ifTrue: [""self setTimbreFromTile: soundColumn submorphs second.			snd _ snd						+ (AbstractSound bachFugueVoice2On: SampledSound new)].	soundColumn submorphs size >= 3		ifTrue: [""self setTimbreFromTile: soundColumn submorphs third.			snd _ snd						+ (AbstractSound bachFugueVoice3On: SampledSound new)].	snd play! !!SoundDemoMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:35'!playV1	soundColumn submorphs isEmpty		ifTrue: [^ self].	self		setTimbreFromTile: (soundColumn submorphs first).	(SampledSound bachFugueVoice1On: SampledSound new) play! !!SoundDemoMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:35'!playV2	soundColumn submorphs size < 2		ifTrue: [^ self].	self		setTimbreFromTile: (soundColumn submorphs second).	(SampledSound bachFugueVoice2On: SampledSound new) playSilentlyUntil: 4.8;		 resumePlaying! !!SoundDemoMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:35'!playV3	soundColumn submorphs size < 3		ifTrue: [^ self].	self		setTimbreFromTile: (soundColumn submorphs third).	(AbstractSound bachFugueVoice3On: SampledSound new) playSilentlyUntil: 14.4;		 resumePlaying! !!SoundDemoMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!SoundDemoMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!SoundDemoMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:04'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 wrapCentering: #center;		 cellPositioning: #topCenter;		 hResizing: #spaceFill;		 vResizing: #spaceFill;		 layoutInset: 3;		 addMorph: self makeControls;	initializeSoundColumn.	self extent: 118 @ 150! !!SoundDemoMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:52'!initializeSoundColumn"initialize the receiver's soundColumn"	soundColumn _ AlignmentMorph newColumn.	soundColumn enableDragNDrop.	self addMorphBack: soundColumn! !!SoundEventMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGreen! !!SoundEventMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:39'!initialize"initialize the state of the receiver"	super initialize.""	self height: 10! !!SoundLoopMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!SoundLoopMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 corner: 128 @ 128 + (self defaultBorderWidth * 2)! !!SoundLoopMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!SoundLoopMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:50'!initialize	"initialize the state of the receiver"	super initialize.	""		controlIndex _ 0.	self addCursorMorph! !!SpeakerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:51'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.484		b: 0.258! !!SpeakerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:51'!initialize"initialize the state of the receiver"	super initialize.""	self addGraphic.	bufferSize _ 5000.	buffer _ WriteStream				on: (SoundBuffer newMonoSampleCount: bufferSize).	lastConePosition _ 0.	sound _ SequentialSound new! !!SpeakerMorph methodsFor: 'speaker' stamp: 'jdl 3/28/2003 09:38'!appendSample: aFloat 	"Append the given sample, a number between -100.0 and 100.0, to my buffer. Flush the buffer if it is full."	lastConePosition := aFloat.	lastConePosition := lastConePosition min: 100.0.	lastConePosition := lastConePosition max: -100.0.	buffer nextPut: (327.67 * lastConePosition) truncated.	buffer position >= bufferSize ifTrue: [self flushBuffer]! !!SpectrumAnalyzerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:52'!defaultBorderWidth"answer the default border width for the receiver"	^ 2! !!SpectrumAnalyzerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:52'!initialize"initialize the state of the receiver"	super initialize.""	self listDirection: #topToBottom.	soundInput _ SoundInputStream new samplingRate: 22050.	fft _ FFT new: 512.	displayType _ 'sonogram'.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self addButtonRow.	self addLevelSlider.	self addMorphBack: self makeLevelMeter.	self addMorphBack: (Morph new extent: 10 @ 10;			 color: Color transparent).	"spacer"	self resetDisplay! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'gm 2/28/2003 00:11'!processBuffer: buf 	"Analyze one buffer of data."	| data |	data := displayType = 'signal' 		ifTrue: [buf]		ifFalse: [fft transformDataFrom: buf startingAt: 1].	graphMorph ifNotNil: 			[graphMorph				data: data;				changed].	sonogramMorph ifNotNil: 			[data := data collect: [:v | v sqrt].	"square root compresses dynamic range"			data /= 400.0.			sonogramMorph plotColumn: (data copyFrom: 1 to: data size // 1)]! !!StackMorph methodsFor: 'background' stamp: 'dgd 2/21/2003 23:01'!addCardsFromString: aString slotNames: slotNames 	"Using the current background, add cards from a string, which is expected be tab- and return-delimited"	| count |	count := 0.	aString asString linesDo: 			[:aLine | 			aLine notEmpty 				ifTrue: 					[count := count + 1.					self 						insertCardOfBackground: self currentPage						withDataFrom: aLine						forInstanceVariables: slotNames]].	self inform: count asString , ' card(s) added'! !!StackMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:13'!findText: keys inStrings: rawStrings startAt: startIndex container: oldContainer cardNum: cardNum 	"Call once to search a card of the stack.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start strings old |	good := true.	start := startIndex.	strings := oldContainer ifNil: 					["normal case"					rawStrings]				ifNotNil: [self currentPage allStringsAfter: oldContainer text].	keys do: 			[:searchString | 			"each key"			good 				ifTrue: 					[thisWord := false.					strings do: 							[:longString | 							(index := longString findWordStart: searchString startingAt: start) > 0 								ifTrue: 									[thisWord not & (searchString == keys first) 										ifTrue: 											[insideOf := longString.											place := index].									thisWord := true].							start := 1].	"only first key on first container"					good := thisWord]].	good 		ifTrue: 			["all are on this page"			"wasIn _ (pages at: pageNum) isInMemory."			self goToCardNumber: cardNum			"wasIn ifFalse: ['search again, on the real current text.  Know page is in.'.			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil)         recompute it					startAt: startIndex container: oldContainer 				pageNum: pageNum]"].	(old := self valueOfProperty: #searchContainer) ifNotNil: 			[(old respondsTo: #editor) 				ifTrue: 					[old editor selectFrom: 1 to: 0.	"trying to remove the previous selection!!"					old changed]].	good 		ifTrue: 			["have the exact string object"			(container := oldContainer) ifNil: 					[container := self 								highlightText: keys first								at: place								in: insideOf]				ifNotNil: 					[container userString == insideOf 						ifFalse: 							[container := self 										highlightText: keys first										at: place										in: insideOf]						ifTrue: 							[(container isTextMorph) 								ifTrue: 									[container editor selectFrom: place to: keys first size - 1 + place.									container changed]]].			self setProperty: #searchContainer toValue: container.			self setProperty: #searchOffset toValue: place.			self setProperty: #searchKey toValue: keys.	"override later"			ActiveHand newKeyboardFocus: container.			^true].	^false! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:12'!initialize"initialize the state of the receiver"	| pt ext oldR points |	super initialize.	""	pt _ 10 @ 10.	ext _ pt r.	oldR _ ext.	points _ 5.	vertices _ (0 to: 359 by: 360 // points // 2)				collect: [:angle | (Point r: (oldR _ oldR = ext									ifTrue: [ext * 5 // 12]									ifFalse: [ext]) degrees: angle + pt degrees)						+ (45 @ 45)].	self computeBounds! !!StarSqueakMorph methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:53'!makeParameterSlider	| menu choice s |	menu := CustomMenu new title: 'Parameter?'.	self sliderParameters do: [:rec | menu add: rec first action: rec].	choice := menu startUp.	choice ifNil: [^self].	s := self 				newSliderForParameter: choice first				target: self				min: (choice second)				max: (choice third)				description: (choice fourth).	self world activeHand attachMorph: s! !!StarSqueakMorph methodsFor: 'stepping and presenter' stamp: 'dgd 2/21/2003 22:53'!oneStep	"Perform one step of the StarSqueak world. Execute all turtle and world demons."	"run demons in random order and increment the generation counter"	| currentTurtles |	turtleDemons notEmpty 		ifTrue: 			["Note: Make a copy of turtles list that won't change if turtles are created/deleted."			currentTurtles := turtles copy.			turtleDemons shuffled 				do: [:sel | 1 to: currentTurtles size do: [:i | (currentTurtles at: i) perform: sel]]].	worldDemons shuffled do: [:sel | self perform: sel].	generation := generation + 1.	turtlesAtPatchCacheValid := false! !!StarSqueakMorph methodsFor: 'turtles' stamp: 'dgd 2/21/2003 22:53'!turtlesAtX: x y: y do: aBlock 	"Evaluate the given block for each turtle at the given location."	| t |	t := self firstTurtleAtX: x y: y.	[t isNil] whileFalse: 			[aBlock value: t.			t := t nextTurtle]! !!StarSqueakMorph methodsFor: 'private' stamp: 'jdl 3/28/2003 09:32'!displayPatchVariableOn: aForm color: aColor shift: shiftAmount 	"Display patchVariableToDisplay in the given color. The opacity (alpha) of of each patch is determined by the patch variable value for that patch and shiftAmount. If shiftAmount is zero, the source value is unscaled. Positive shiftAmount values result in right shifting the source value by the given number of bits (That is, multiplying by 2^N. Negative values perform right shifts, dividing by 2^N)."	| patchVar bitBlt w rowOffset alpha |	patchVariableToDisplay ifNil: [^self].	patchVar := patchVariables at: patchVariableToDisplay ifAbsent: [^self].	"set up the BitBlt"	bitBlt := (BitBlt toForm: aForm)				sourceRect: (0 @ 0 extent: pixelsPerPatch);				fillColor: aColor;				combinationRule: 30.	w := dimensions x.	0 to: dimensions y - 1		do: 			[:y | 			rowOffset := y * w + 1.			0 to: w - 1				do: 					[:x | 					alpha := (patchVar at: rowOffset + x) bitShift: shiftAmount.					alpha := alpha min: 255.					alpha > 1 						ifTrue: 							["if not transparent, fill using the given alpha"							bitBlt destOrigin: (x * pixelsPerPatch) @ (y * pixelsPerPatch).							bitBlt copyBitsTranslucent: alpha]]]! !!StarSqueakMorph methodsFor: 'private' stamp: 'jdl 3/28/2003 09:34'!setPatchBrightnessAtX: x y: y to: percent 	"Set the brightness of the patch at the given location to the given level, where 0 is black and 100 is full brightness."	| c brightness |	c := self getPatchColorAtX: x y: y.	brightness := percent / 100.0.	brightness := brightness max: 0.03125.	self 		setPatchColorAtX: x		y: y		to: (Color 				h: c hue				s: c saturation				v: brightness)! !!StarSqueakMorph methodsFor: 'private' stamp: 'jdl 3/28/2003 09:36'!uphillOf: patchVarName forTurtle: aTurtle 	"Answer the heading the points in the direction of increasing value for the given patch variable. If there is no gradient, or if the turtle is outside the world bounds, answer the turtles current heading."	| patchVar turtleX turtleY startX endX startY endY maxVal rowOffset thisVal maxValX maxValY |	patchVar := patchVariables at: patchVarName ifAbsent: [^aTurtle heading].	turtleX := aTurtle x truncated + 1.	turtleY := aTurtle y truncated + 1.	turtleX := turtleX max: 1.	turtleY := turtleY max: 1.	turtleX := turtleX min: dimensions x.	turtleY := turtleY min: dimensions y.	startX := turtleX - sniffRange max: 1.	endX := turtleX + sniffRange min: dimensions x.	startY := turtleY - sniffRange max: 1.	endY := turtleY + sniffRange min: dimensions y.	maxVal := patchVar at: (turtleY - 1) * dimensions x + turtleX.	maxValX := nil.	startY to: endY		do: 			[:y | 			rowOffset := (y - 1) * dimensions x.			startX to: endX				do: 					[:x | 					thisVal := patchVar at: rowOffset + x.					thisVal > maxVal 						ifTrue: 							[maxValX := x.							maxValY := y.							maxVal := thisVal]]].	nil = maxValX ifTrue: [^aTurtle heading].	^(((maxValX - turtleX) @ (maxValY - turtleY)) degrees + 90.0) \\ 360.0! !!StarSqueakMorph methodsFor: 'private-primitives' stamp: 'jdl 3/28/2003 09:46'!primDiffuseFrom: srcBitmap to: dstBitmap width: width height: height delta: delta 	"Diffuse the integer values of the source patch variable Bitmap into the output Bitmap. Each cell of the output is the average of the NxN area around it in the source, where N = (2 * delta) + 1."	| area startY endY startX endX sum rowStart |	<primitive: 'primitiveDiffuseFromToWidthHeightDelta' module: 'StarSqueakPlugin'>	area := (2 * delta + 1) * (2 * delta + 1).	1 to: height		do: 			[:y | 			startY := y - delta.			startY := startY max: 1.			endY := y + delta.			endY := endY min: height.			1 to: width				do: 					[:x | 					startX := x - delta.					startX := startX max: 1.					endX := x + delta.					endX := endX min: width.					sum := 0.					startY to: endY						do: 							[:y2 | 							rowStart := (y2 - 1) * width.							startX to: endX do: [:x2 | sum := sum + (srcBitmap at: rowStart + x2)]].					dstBitmap at: (y - 1) * width + x put: sum // area]]! !!StarSqueakMorph methodsFor: 'private-primitives' stamp: 'gm 2/28/2003 00:35'!primMapFrom: srcBitmap to: dstBitmap width: w height: h patchSize: patchSize rgbFlags: rgbFlags shift: shiftAmount 	"Map values in the source bitmap (interpreted as unsigned 32-bit integers) to 2x2 patches of color in the destination bitmap. The color brightness level is determined by the source value and the color hue is determined by the bottom three bits of the rgbFlags value. For example, if rgbFlags is 1, you get shades of blue, if it is 6 you get shades of yellow, and if it is 7, you get shades of gray. The shiftAmount is used to scale the source data values by a power of two. If shiftAmount is zero, the data is unscaled. Positive shiftAmount values result in right shifting the source data by the given number of bits (multiplying by 2^N, negative values perform right shifts (dividing by 2^N). The width parameter gives the width of the Form that owns the destination bitmap."	| rgbMult srcIndex level pixel offset |	<primitive: 'primitiveMapFromToWidthHeightPatchSizeRgbFlagsShift' module: 'StarSqueakPlugin'>	rgbMult := 0.	(rgbFlags bitAnd: 4) > 0 ifTrue: [rgbMult := rgbMult + 65536].	(rgbFlags bitAnd: 2) > 0 ifTrue: [rgbMult := rgbMult + 256].	(rgbFlags bitAnd: 1) > 0 ifTrue: [rgbMult := rgbMult + 1].	srcIndex := 0.	0 to: h // patchSize - 1		do: 			[:y | 			0 to: w // patchSize - 1				do: 					[:x | 					level := (srcBitmap at: (srcIndex := srcIndex + 1)) bitShift: shiftAmount.					level _ level min: 255..					pixel := level <= 0 								ifTrue: 									["non-transparent black"									1]								ifFalse: [level * rgbMult].					"fill a patchSize x patchSize square with the pixel value"					offset := (y * w + x) * patchSize.					offset to: offset + ((patchSize - 1) * w)						by: w						do: 							[:rowStart | 							rowStart + 1 to: rowStart + patchSize								do: [:dstIndex | dstBitmap at: dstIndex put: pixel]]]]! !!StringMorph methodsFor: 'accessing' stamp: 'aoy 2/17/2003 01:13'!contents: newContents contents := 	newContents isText 		ifTrue: 			[emphasis := newContents emphasisAt: 1.			 newContents string]		ifFalse: 			[contents = newContents ifTrue: [^self].	"no substantive change"			newContents].	self fitContents! !!StringMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 23:07'!fontToUse	| fontToUse |	fontToUse := font isNil ifTrue: [TextStyle defaultFont] ifFalse: [font].	(emphasis isNil or: [emphasis = 0]) 		ifTrue: [^fontToUse]		ifFalse: [^fontToUse emphasized: emphasis]! !!StringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!StringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:57'!initWithContents: aString font: aFont emphasis: emphasisCode 	super initialize.		font _ aFont.	emphasis _ emphasisCode.	hasFocus _ false.	self contents: aString! !!StringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	font _ nil.	emphasis _ 0.	hasFocus _ false! !!StringMorph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:52'!minHeight"answer the receiver's minHeight"	^ self fontToUse height! !!StringMorph methodsFor: 'parts bin' stamp: 'dgd 2/14/2003 21:58'!initializeToStandAlone	super initializeToStandAlone.		font _ nil.	emphasis _ 0.	hasFocus _ false.	self contents: 'String: Shift-click on me to edit'! !!BorderedStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	self		borderStyle: (SimpleBorder width: 1 color: Color white)! !!ClockMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	showSeconds _ true.	self step! !!FrameRateMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	lastDisplayTime _ 0.	framesSinceLastDisplay _ 0! !!IndentingListItemMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	indentLevel _ 0.	isExpanded _ false! !!InfoStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	stepTime _ 1000.	block _ [Time now]! !!MenuItemMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 14:51'!contentString: aString 	aString isNil 		ifTrue: [self removeProperty: #contentString]		ifFalse: [self setProperty: #contentString toValue: aString]! !!MenuItemMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 14:51'!contents: aString withMarkers: aBool inverse: inverse 	"Set the menu item entry. If aBool is true, parse aString for embedded markers."	| markerIndex marker indent |	self contentString: nil.	"get rid of old"	aBool ifFalse: [^super contents: aString].	self removeAllMorphs.	"get rid of old markers if updating"	(aString notEmpty and: [aString first = $<]) 		ifFalse: [^super contents: aString].	markerIndex := aString indexOf: $>.	markerIndex = 0 ifTrue: [^super contents: aString].	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 		ifFalse: [^super contents: aString].	self contentString: aString.	"remember actual string"	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 				ifTrue: [self onImage]				ifFalse: [self offImage].	"Indent the string using white spaces"	indent := ' '.	font := self fontToUse.	[(font widthOfString: indent) < (marker width + 4)] 		whileTrue: [indent := indent copyWith: Character space].	"Set the string"	super 		contents: indent , (aString copyFrom: markerIndex + 1 to: aString size).	"And set the marker"	marker := ImageMorph new image: marker.	marker position: self left @ (self top + 2).	self addMorphFront: marker! !!MenuItemMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:52'!mouseLeaveDragging: evt 	"The mouse left the receiver. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."	owner ifNil: [^self].	evt hand mouseFocus == owner ifFalse: [^self].	"If we have a submenu, make sure we've got some time to enter it before actually leaving the menu item"	subMenu isNil 		ifTrue: [owner selectItem: nil event: evt]		ifFalse: 			[self 				addAlarm: #deselectTimeOut:				with: evt				after: 500]! !!MenuItemMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:07'!defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 extent: 10 @ 10! !!MenuItemMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:43'!initialize	"initialize the state of the receiver"	super initialize.	""		contents _ ''.	hasFocus _ false.	isEnabled _ true.	subMenu _ nil.	isSelected _ false.	target _ nil.	selector _ nil.	arguments _ nil.	font _ Preferences standardMenuFont.	self hResizing: #spaceFill;		 vResizing: #shrinkWrap! !!MenuItemMorph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:52'!minWidth	"answer the receiver's minWidth"	| f |	f := self fontToUse.	^(f widthOfString: contents) + (subMenu isNil ifTrue: [0] ifFalse: [10])! !!PopUpChoiceMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:50'!mouseDown: evt 	| items menu selectedItem |	(target isNil or: [getItemsSelector isNil]) ifTrue: [^self].	items := target perform: getItemsSelector withArguments: getItemsArgs.	menu := CustomMenu new.	items do: [:item | menu add: item action: item].	selectedItem := menu startUp.	selectedItem ifNil: [^self].	self contentsClipped: selectedItem.	"Client can override this if necess"	actionSelector ifNotNil: 			[target perform: actionSelector				withArguments: (arguments copyWith: selectedItem)]! !!PopUpChoiceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:44'!initialize"initialize the state of the receiver"	super initialize.""	self contents: 'PopUpChoice of Colors'.	target _ Color.	actionSelector _ nil.	arguments _ EmptyArray.	getItemsSelector _ #colorNames.	getItemsArgs _ EmptyArray! !!StringButtonMorph methodsFor: 'button' stamp: 'dgd 2/22/2003 18:45'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[Cursor normal 				showWhile: [target perform: actionSelector withArguments: arguments]]! !!StringButtonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:44'!initialize	"initialize the state of the receiver"	super initialize.	""	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	self contents: 'Flash' ! !!StringButtonMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:55'!setTarget: evt 	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	target _ rootMorphs size > 1		ifTrue: [rootMorphs second]		ifFalse: [nil]! !!SubpaneDividerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:53'!defaultColor"answer the default color/fill style for the receiver"	^ Color black! !!SubpaneDividerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:53'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 1 @ 1! !!SyntaxMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 18:48'!messageNode	"Return the enclosing messageNode that is the full message.  It has a receiver."	^self orOwnerSuchThat: [:oo | oo receiverNode notNil]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'dgd 2/22/2003 13:41'!selector	"Find the selector I represent, or have inside of me.  My parseNode is a SelectorNode or a MessageNode."	| sel cnt |	parseNode class == SelectorNode 		ifTrue: [^self decompile asString asSymbol].	parseNode class == KeyWordNode ifTrue: [^self decompile asString asSymbol].	parseNode class == MessageNode | (parseNode class == MessagePartNode) 		ifFalse: [^nil].	"Must be one of those to have a selector"	"Beware of messageParts.  If MessagePartNode, only returns this one keyword."	sel := ''.	cnt := 0.	submorphs do: 			[:mm | 			mm isSyntaxMorph 				ifTrue: 					[cnt := cnt + 1.					(mm nodeClassIs: SelectorNode) ifTrue: [^mm selector].					(mm nodeClassIs: MessagePartNode) ifTrue: [sel := sel , mm selector].					(mm nodeClassIs: KeyWordNode) ifTrue: [sel := sel , mm decompile asString].					(mm nodeClassIs: ReturnNode) ifTrue: [cnt := cnt - 1].					(mm nodeClassIs: MessageNode) 						ifTrue: 							[parseNode receiver ifNil: [sel := mm selector].							cnt = 2 & (sel isEmpty) 								ifTrue: 									["not the receiver.  Selector and arg"									sel := mm selector]]]].	sel ifNil: [^nil].	sel notEmpty ifTrue: [^sel asSymbol].	^nil! !!SyntaxMorph methodsFor: 'accessing' stamp: 'aoy 2/15/2003 21:31'!unSpaceAndUpShift: aString appending: extraChars 	| answer upShiftNext |	answer := WriteStream on: String new.	upShiftNext := false.	aString do: 			[:ch | 			upShiftNext :=( ch == Character space) 				ifTrue: [ true]				ifFalse: 					[answer nextPut: (upShiftNext ifTrue: [ch asUppercase] ifFalse: [ch]).					 false]].	answer := answer contents.	extraChars isEmptyOrNil ifTrue: [^answer].	(answer endsWith: extraChars) ifFalse: [answer := answer , extraChars].	^answer! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'gm 2/22/2003 12:49'!wantsDroppedMorph: aMorph event: evt 	"For the moment, you have to drop it the right place.  We do not look at enclosing morphs"	"Two ways to do this:  Must always destroy old node, then drag in new one.		Or, drop replaces what you drop on.  Nasty with blocks."	(aMorph isSyntaxMorph) ifFalse: [^false].	(self structureMatchWith: aMorph) ifFalse: [^false].	"gross structure"	"Only look at types if NoviceMode -- building EToys"	^self okToBeReplacedBy: aMorph	"test the types"	"^ true"! !!SyntaxMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 13:39'!handlesMouseDown: evt 	evt yellowButtonPressed ifTrue: [^true].	parseNode isNil ifTrue: [^false].	owner isSyntaxMorph 		ifTrue: [(owner isMethodNode and: [self isBlockNode not]) ifTrue: [^false]].	"Can only take block out of a MethodNode"	^true! !!SyntaxMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:48'!mouseLeave: evt 	"Move grab highlight back out a level"	"Transcript cr; print: self; show: ' leave'."	self rootTile isMethodNode ifFalse: [^self].	"not in a script"	self unhighlightBorder.	(owner notNil and: [owner isSyntaxMorph]) 		ifTrue: [owner highlightForGrab: evt]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:48'!mouseLeaveDragging: evt 	"Transcript cr; print: self; show: ' leaveDragging'."	self rootTile isMethodNode ifFalse: [^self].	"not in a script"	self isBlockNode 		ifTrue: 			[self				stopStepping;				removeDropZones.			(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]]) 				ifNotNilDo: [:m | m startStepping].	"Activate outer block."			self submorphs do: 					[:ss | 					"cancel drop color in line beside mouse"					ss color = self dropColor ifTrue: [ss setDeselectedColor]]].	"Move drop highlight back out a level"	self unhighlight.	(owner notNil and: [owner isSyntaxMorph]) 		ifTrue: [owner isBlockNode ifFalse: [owner highlightForDrop: evt]]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'dgd 2/22/2003 18:48'!unhighlightOwner	"Unhighlight my owner"	(owner notNil and: [owner isSyntaxMorph]) ifTrue: [owner unhighlight]! !!SyntaxMorph methodsFor: 'highlighting' stamp: 'dgd 2/22/2003 18:49'!unhighlightOwnerBorder	"Unhighlight my owner's border"	(owner notNil and: [owner isSyntaxMorph]) 		ifTrue: [owner unhighlightBorder]! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'dgd 2/22/2003 13:38'!addTemporaries: temporaries 	| tempMorph outerMorph w2 |	temporaries notEmpty ifFalse: [^self].	self alansTest1 		ifFalse: 			[tempMorph := self addRow: #tempVariable on: MethodTempsNode new.			temporaries do: [:temp | temp asMorphicSyntaxIn: tempMorph]				separatedBy: 					[tempMorph addMorphBack: (tempMorph transparentSpacerOfSize: 4 @ 4)].			^self].	outerMorph := self addRow: #tempVariable on: nil.	outerMorph setSpecialTempDeclarationFormat1.	outerMorph 		addMorphBack: (w2 := self noiseStringMorph: self noiseBeforeBlockArg).	w2 emphasis: 1.	tempMorph := outerMorph addRow: #tempVariable on: MethodTempsNode new.	tempMorph setSpecialTempDeclarationFormat2.	temporaries do: 			[:temp | 			tempMorph 				addToken: temp name				type: #tempVariableDeclaration				on: temp]		separatedBy: [tempMorph addMorphBack: self tokenVerticalSeparator]! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'dgd 2/22/2003 13:38'!alansMessageNode: aNode receiver: receiver selector: selector keywords: key arguments: args 	| receiverMorph testAndReceiver anotherSelf wordyMorph template |	template := self alansTemplateStyleFor: key.	receiver ifNotNil: 			["i.e. not a cascade"			anotherSelf := self constructSelfVariant: receiver and: key.			anotherSelf ifNotNil: 					[wordyMorph := self addString: anotherSelf special: false.					wordyMorph setProperty: #wordyVariantOfSelf toValue: true.					self addMorph: wordyMorph.					self layoutInset: 1.					^self].			testAndReceiver := self.			template = 1 				ifTrue: 					[testAndReceiver := self addRow: #keyword1 on: nil.					self setSpecialOuterTestFormat.					testAndReceiver addNoiseString: 'Test'].			false 				ifTrue: 					["template = 2"					testAndReceiver := self addRow: #keyword1 on: nil.					"self setSpecialOuterTestFormat."					testAndReceiver addNoiseString: 'Repeat for'].			receiverMorph := receiver asMorphicSyntaxIn: testAndReceiver.			template = 1 ifTrue: [receiverMorph setConditionalPartStyle]].	"unary messages"	args isEmpty 		ifTrue: 			[^self 				alanUnaryPostRcvr: aNode				key: key				selector: selector].	"binary messages"	key last = $: 		ifFalse: 			[^self 				alanBinaryPostRcvr: aNode				key: key				args: args].	"keyword messages"	receiverMorph ifNotNil: [receiverMorph setConditionalPartStyle].	self setSpecialOuterTestFormat.	self 		alanKeywordMessage: aNode		isAConditional: template		key: key		args: args! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'dgd 2/22/2003 13:39'!blockNode: aNode arguments: arguments statements: statements 	| row column |	column := self addColumn: #block on: aNode.	self alansTest1 ifFalse: [column layoutInset: 5 @ -1].	self alansTest1 		ifTrue: 			[column setProperty: #deselectedBorderColor toValue: self lighterColor].	aNode addCommentToMorph: column.	arguments notEmpty 		ifTrue: 			[row := column addRow: #blockarg1 on: BlockArgsNode new.			row addNoiseString: self noiseBeforeBlockArg.			arguments do: 					[:arg | 					row 						addToken: arg name						type: #blockarg2						on: arg]].	statements do: 			[:each | 			(row := each asMorphicSyntaxIn: column) borderWidth: 1.			self alansTest1 ifTrue: [row setSpecialOuterTestFormat].			each addCommentToMorph: column].	^column! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'dgd 2/22/2003 13:39'!blockNodeCollect: aNode arguments: arguments statements: statements 	| row column c2 r2 r3 |	column := self addColumn: #blockCollectOnly on: aNode.	self alansTest1 ifFalse: [column layoutInset: 5 @ -1].	aNode addCommentToMorph: column.	arguments notEmpty 		ifTrue: 			[row := column addRow: #blockarg1 on: BlockArgsNode new.			row addNoiseString: 'collect using' emphasis: 1.			r3 := row addRow: #blockarg1b on: nil.	"aNode"			r3 setConditionalPartStyle.			arguments do: 					[:arg | 					r3 						addToken: arg name						type: #blockarg2						on: arg]].	r2 := column addRow: #block on: aNode.	r2 setProperty: #ignoreNodeWhenPrinting toValue: true.	r2 addNoiseString: self noiseBeforeBlockArg emphasis: 1.	c2 := r2 addColumn: #block on: aNode.	c2 setProperty: #ignoreNodeWhenPrinting toValue: true.	statements do: 			[:each | 			(each asMorphicSyntaxIn: c2) borderWidth: 1.			each addCommentToMorph: c2].	^column! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'gm 2/22/2003 13:42'!finalAppearanceTweaks	| deletes lw |	SizeScaleFactor ifNil: [SizeScaleFactor := 0.15].	SizeScaleFactor := 0.0.	"disable this feature.  Default was for giant tiles"	self usingClassicTiles 		ifTrue: 			[self 				allMorphsDo: [:each | (each isSyntaxMorph) ifTrue: [each lookClassic]].			^self].	deletes := OrderedCollection new.	self allMorphsDo: 			[:each | 			(each respondsTo: #setDeselectedColor) ifTrue: [each setDeselectedColor].			"(each hasProperty: #variableInsetSize) ifTrue: [			each layoutInset: 				((each valueOfProperty: #variableInsetSize) * SizeScaleFactor) rounded]."			each isSyntaxMorph 				ifTrue: 					[lw := each layoutInset.					lw isPoint ifTrue: [lw := lw x].					each layoutInset: lw @ 0	"(6 * SizeScaleFactor) rounded"]].	deletes do: [:each | each delete]! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'dgd 2/22/2003 13:39'!messageNode: aNode receiver: receiver selector: selector keywords: key arguments: args 	| keywords column row receiverMorph receiverWidth messageWidth onlyOne nodeWithNilReceiver isAConditional |	self alansTest1 		ifTrue: 			[^self 				alansMessageNode: aNode				receiver: receiver				selector: selector				keywords: key				arguments: args].	isAConditional := #(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 				includes: key.	receiver ifNotNil: 			["i.e. not a cascade"			receiverMorph := receiver asMorphicSyntaxIn: self].	keywords := key keywords.	args isEmpty 		ifTrue: 			[row := (self addSingleKeywordRow: key) layoutInset: 1.			^row parseNode: selector].	receiverWidth := receiver ifNil: [0]				ifNotNil: [receiverMorph fullBounds width].	onlyOne := args size = 1.	(receiverWidth <= 80 and: [onlyOne]) 		ifTrue: 			[self 				messageOneArg: key				receiver: receiver				selector: selector				args: args.			^self].	nodeWithNilReceiver := aNode copy receiver: nil.	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	"onlyOne ifTrue: [column parseNode: nil].	is a spacer"	messageWidth := 0.	keywords with: (args copyFrom: 1 to: keywords size)		do: 			[:kwd :arg | 			isAConditional 				ifTrue: [column addMorphBack: (column transparentSpacerOfSize: 3 @ 3)].			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				borderWidth: 1;				parseNode: (nodeWithNilReceiver 							as: (onlyOne ifTrue: [MessageNode] ifFalse: [MessagePartNode]));				borderColor: row stdBorderColor.			isAConditional 				ifTrue: [row addMorphBack: (row transparentSpacerOfSize: 20 @ 6)].			row 				addToken: kwd				type: #keyword2				on: (onlyOne 						ifTrue: [SelectorNode new key: kwd code: nil	"fill this in?"]						ifFalse: [KeyWordNode new]).			arg asMorphicSyntaxIn: row.			messageWidth := messageWidth + row fullBounds width].	onlyOne 		ifTrue: 			[self replaceSubmorph: column by: row.			column := row].	receiverMorph ifNil: [^self].	receiverWidth + messageWidth < 350 		ifTrue: 			[isAConditional ifFalse: [self unfoldMessage].			^self].	((receiverWidth > 200 		or: [receiverWidth > 80 and: [column fullBounds height > 20]]) or: 				[receiverMorph fullBounds width > 30 					and: [column fullBounds height > 100 or: [column fullBounds width > 250]]]) 		ifTrue: [^self foldMessage]! !!SyntaxMorph methodsFor: 'node types' stamp: 'gm 2/22/2003 12:30'!isLeafTile	self hasSubmorphs ifFalse: [^false].	(self firstSubmorph isSyntaxMorph) ifTrue: [^false].	(self firstSubmorph isMemberOf: Morph) ifTrue: [^false].	^true! !!SyntaxMorph methodsFor: 'node types' stamp: 'dgd 2/22/2003 13:40'!rootTile	^self 		orOwnerSuchThat: [:m | m owner isNil or: [m owner isSyntaxMorph not]]! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'aoy 2/15/2003 21:30'!addArg: index 	"I rep a SelectorNode.  My string has been replaced.  Append an argument to my owner."	"See if any sample args are recorded"	| sel rec aVocabulary mi sample descrip mthNode tiles |	sel := self decompile asString asSymbol.	rec := self receiverObject.	sample := rec class == Error 				ifFalse: 					[aVocabulary := self vocabularyToUseWith: rec.					mi := aVocabulary methodInterfaceAt: sel ifAbsent: [nil].					mi ifNil: [5]						ifNotNil: 							[descrip := mi argumentVariables at: index.							descrip sample]]				ifTrue: [5]. 	mthNode := self string: sample storeString toTilesIn: sample class.	tiles := mthNode submorphs at: mthNode submorphs size - 1.	"before the ^ self"	self owner addMorphBack: tiles! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'dgd 2/22/2003 13:40'!offerPopUp	"Put up a halo to allow user to change		Literals (Integer, true),		Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,),		Variable (Color),		not AssignmentNode (_ inc dec),	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge dismiss rr duplicate |	(self hasProperty: #myPopup) ifTrue: [^self].	"already has one"	any := false.	(upDown := self upDownArrows) ifNotNil: [any := true].	"includes menu of selectors"	(retract := self retractArrow) ifNotNil: [any := true].	(extend := self extendArrow) ifNotNil: [any := true].	(dismiss := self dismisser) ifNotNil: [any := true].	(duplicate := self duplicator) ifNotNil: [any := true].	"(assign _ self assignmentArrow) ifNotNil: [any _ true].			get from menu or any other assignment"	submorphs last class == ColorTileMorph 		ifFalse: [(colorPatch := self colorPatch) ifNotNil: [any := true]].	any ifFalse: [^self].	"Transcript cr; print: parseNode class; space; 		print: (self hasProperty: #myPopup); endEntry."	panel := (RectangleMorph new)				color: Color transparent;				borderWidth: 0.	upDown ifNotNil: 			[panel addMorphBack: upDown first.			upDown first align: upDown first topLeft with: panel topLeft + (0 @ 0).			panel addMorphBack: upDown second.			upDown second align: upDown second topLeft				with: upDown first bottomLeft + (0 @ 1).			upDown size > 2 				ifTrue: 					[panel addMorphBack: upDown third.					upDown third align: upDown third topLeft						with: upDown first topRight + (2 @ 3)]].	rr := self right.	colorPatch ifNotNil: 			[rr := rr + colorPatch submorphs first width + 1.			self addMorphBack: colorPatch	"always in tile"			"colorPatch align: colorPatch topLeft 					with: panel topLeft + (1@1)"].	retract ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: retract.			retract align: retract topLeft with: (edge + 2) @ (panel top + 3)].	extend ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: extend.			extend align: extend topLeft with: (edge + 2) @ (panel top + 3)].	duplicate ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: duplicate.			duplicate align: duplicate topLeft with: (edge + 2) @ (panel top + 1)].	dismiss ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: dismiss.			dismiss align: dismiss topLeft with: (edge + 2) @ (panel top + 1)].	"	assign ifNotNil: [		edge _ panel submorphs isEmpty 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: assign.		assign align: assign topLeft with: (edge+2) @ (panel top + 2)]."	panel align: panel topLeft with: rr @ (self top - 2).	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	self addMorphBack: panel	"Any reason ever to have panel below?"	"(owner listDirection = #topToBottom and: [self listDirection = #leftToRight])		ifTrue: [self addMorphBack: panel]		ifFalse: [owner addMorph: panel after: self]."! !!SyntaxMorph methodsFor: 'printing' stamp: 'dgd 2/22/2003 13:40'!ownerPrecedence	"Return the selector precedence of my owner.  1 for unary (asInteger), 2 for binary arithmetic (+), and 3 for keyword selectors (from:to:).  Subtract 0.5 if self is an arg, not the receiver (the case of a + (b + c))"	| oo below sel pp |	oo := owner.	below := self.		[oo isSyntaxMorph ifFalse: [^10].	"I do not need parens"	oo parseNode isNil] 			whileTrue: 				[below := oo.				oo := oo owner].	(sel := oo selector) ifNil: [^10].	(pp := sel precedence) = 3 ifTrue: [^2.5].	"keyword messages need parens"	^oo receiverNode == below ifTrue: [pp] ifFalse: [pp - 0.5]! !!SyntaxMorph methodsFor: 'printing' stamp: 'gm 2/22/2003 12:34'!submorphsDoIfSyntax: block1 ifString: block2 otherwise: block3 	submorphs do: 			[:sub | 			sub isSyntaxMorph 				ifTrue: [block1 value: sub]				ifFalse: 					[(sub isKindOf: StringMorph) 						ifTrue: [block2 value: sub]						ifFalse: 							[(sub isTextMorph) 								ifTrue: [block2 value: sub]								ifFalse: [block3 value: sub]]]]! !!SyntaxMorph methodsFor: 'selection' stamp: 'dgd 2/22/2003 13:41'!setSelection: newSpec 	"A selectionSpec is {Inner morph.  Where clicked.  Outer morph}.	First mouseDown starts a selection (with outerMorph isNil).	Dragging more than 4 pixels means to grab a copy of the current outer selection.		The current selection is the outerMorph, or the inner if it is nil.	Each mouseUp extends the selection to the next outer morph that is selectable.		Except if this is the first click."	| rootTile |	(rootTile := self rootTile) valueOfProperty: #selectionSpec		ifPresentDo: [:oldSpec | oldSpec third ifNotNilDo: [:m | m deselect]].	(newSpec isNil or: [newSpec third isNil and: [self isMethodNode]]) 		ifTrue: 			[self deselect.			^rootTile removeProperty: #selectionSpec].	"Select outer morph of the new selection"	newSpec third isNil 		ifTrue: [self select	"first click down"]		ifFalse: [newSpec third select	"subsequent clicks"].	rootTile setProperty: #selectionSpec toValue: newSpec! !!SyntaxMorph methodsFor: 'tests' stamp: 'gm 2/22/2003 12:35'!testForNode: targetNode andDo: aBlock 	targetNode == parseNode ifTrue: [aBlock value: self].	self submorphsDo: 			[:each | 			(each isSyntaxMorph) 				ifTrue: [each testForNode: targetNode andDo: aBlock]]! !!SyntaxMorph methodsFor: 'type checking' stamp: 'dgd 2/22/2003 18:48'!receiverOrArgTypeAbove	"Return the type for me according to the message that encloses me."	| enclosing sub list |	(self nodeClassIs: BlockNode) ifTrue: [^#command].	enclosing := owner.	sub := self.		[enclosing isSyntaxMorph ifFalse: [^#unknown].	(enclosing nodeClassIs: MessageNode) 		ifTrue: 			[list := enclosing submorphs 						select: [:ss | ss isSyntaxMorph and: [ss parseNode notNil]].			list size = 1 				ifFalse: 					[^(list indexOf: sub) = 1 						ifTrue: [enclosing receiverTypeFor: enclosing selector]						ifFalse: [enclosing argTypeFor: enclosing selector]]].	(enclosing nodeClassIs: BlockNode) ifTrue: [^#command].	sub := enclosing.	enclosing := enclosing owner.	true] 			whileTrue! !!SyntaxMorph methodsFor: 'type checking' stamp: 'gm 2/22/2003 19:35'!resultType	"Look up my result type.  If I am a constant, use that class.  If I am a message, look up the selector."	| list value soundChoices |	parseNode class == BlockNode ifTrue: [^#blockContext].	parseNode class == AssignmentNode ifTrue: [^#command].	parseNode class == ReturnNode ifTrue: [^#command].	"Need more restriction than this"	list := submorphs 				select: [:ss | ss isSyntaxMorph and: [ss parseNode notNil]].	list size > 1 ifTrue: [^self resultTypeFor: self selector].	list size = 1 		ifTrue: 			["test for levels that are just for spacing in layout"			(list first isSyntaxMorph and: [list first nodeClassIs: MessageNode]) 				ifTrue: [^list first resultType]].	"go down one level"	value := self try.	value class == Error ifTrue: [^#unknown].	(value isNumber) ifTrue: [^#Number].	(value isKindOf: Boolean) ifTrue: [^#Boolean].	(value isForm) ifTrue: [^#Graphic].	value class == String 		ifTrue: 			[soundChoices := #('silence').	"default, if no SampledSound class"			Smalltalk at: #SampledSound				ifPresent: [:sampledSound | soundChoices := sampledSound soundNames].			(soundChoices includes: value) ifTrue: [^#Sound]].	(value isKindOf: Player) ifTrue: [^#Player].	^value class name asLowercase	"asSymbol (not needed)"! !!SyntaxMorph methodsFor: 'vocabulary' stamp: 'gm 2/22/2003 12:31'!limitClassToUseWith: aValue vocabulary: aVocabulary 	"Answer the most generic whose method should be shown in a selector pop-up in the receiver that is put up on behalf of aValue"	(aValue isNumber) ifTrue: [^Number].	"Ted: This hook allows you to intervene as suits your purposes here if you don't like the defaults."	^aValue defaultLimitClassForVocabulary: aVocabulary! !!SyntaxMorph methodsFor: 'vocabulary' stamp: 'gm 2/22/2003 12:48'!vocabularyToUseWith: aValue 	"Answer a vocabulary to use with the given value"	(aValue isNumber) ifTrue: [^Vocabulary numberVocabulary].	(aValue isKindOf: Time) ifTrue: [^Vocabulary vocabularyForClass: Time].	(aValue isString) ifTrue: [^Vocabulary vocabularyForClass: String].	aValue class isUniClass ifTrue: [^Vocabulary eToyVocabulary].	^self currentVocabulary! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 23:17'!bobsplace2: letter after: before newLine: isNewLine 	"Position this letter. Put its left edge where the previous letter's right edge is. Move down to the next line if isNewLine is true. Add some 	leading for condensed or expanded text."	(self doFirstThatWorks)		if: [before isNil]			do: [self selfWrittenAsIll march: letter to: leftMargin topRight];		if: [isNewLine]			do: 				[self selfWrittenAsIll march: letter					to: leftMargin right @ (before bottom + 1)];		if: [true] do: [self selfWrittenAsIll march: letter to: before topRight]! !!SyntaxTestMethods methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 23:17'!bobsplace: letter after: before newLine: isNewLine 	"Position this letter. Put its left edge where the previous letter's right 	edge is. Move down to the next line if isNewLine is true. Add some 	leading for condensed or expanded text."	before isNil		ifTrue: [self selfWrittenAsIll march: letter to: leftMargin topRight]		ifFalse: 			[isNewLine 				ifTrue: 					[self selfWrittenAsIll march: letter						to: leftMargin right @ (before bottom + 1)]				ifFalse: [self selfWrittenAsIll march: letter to: before topRight]].	^self! !!SystemWindow methodsFor: 'accessing' stamp: 'dgd 2/22/2003 19:02'!borderWidthForRounding	"Pane borders effectively increase the border size.	This is a hack, but it usually looks good."	self isCollapsed ifTrue: [^2].	(paneMorphs notNil 		and: [paneMorphs notEmpty and: [paneMorphs first borderWidth > 0]]) 			ifTrue: [^self borderWidth + paneMorphs first borderWidth]			ifFalse: [^self borderWidth]! !!SystemWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Preferences alternativeWindowLook		ifTrue: [#raised]		ifFalse: [Color black]! !!SystemWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ Preferences alternativeWindowLook		ifTrue: [2]		ifFalse: [1]! !!SystemWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Preferences alternativeWindowLook		ifTrue: [Color white]		ifFalse: [Color black]! !!SystemWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:47'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.""	allowReframeHandles _ true.	labelString		ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	self layoutPolicy: ProportionalLayout new.	self wantsLabel		ifTrue: [label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 1.			"Add collapse box so #labelHeight will work"			collapseBox _ IconicButton new target: self;						 actionSelector: #collapseOrExpand;						 labelGraphic: self class collapseBoxImage;						 color: Color transparent;						 extent: 14 @ 14;						 setBalloonText: 'collapse this window';						 borderWidth: 0.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			labelArea				addMorph: (stripes first borderWidth: 1).			labelArea				addMorph: (stripes second borderWidth: 2).			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorph: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorph: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']]].	self		on: #mouseEnter		send: #spawnReframeHandle:		to: self.	self		on: #mouseLeave		send: #spawnReframeHandle:		to: self.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new! !!SystemWindow methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:39'!convertAlignment	"Primarily Jesse Welton's code to convert old system windows to ones with modern layout scheme"	| frame |	self layoutPolicy: ProportionalLayout new.	(paneMorphs isNil 		or: [paneRects isNil or: [paneMorphs size ~= paneRects size]]) 			ifFalse: 				[self addLabelArea.				self putLabelItemsInLabelArea.				self setFramesForLabelArea.				paneMorphs with: paneRects					do: 						[:m :r | 						frame := LayoutFrame new.						frame							leftFraction: r left;							rightFraction: r right;							topFraction: r top;							bottomFraction: r bottom.						m layoutFrame: frame.						m							hResizing: #spaceFill;							vResizing: #spaceFill]].	(labelArea isNil and: [self wantsLabel]) 		ifTrue: 			[self addLabelArea.			self putLabelItemsInLabelArea.			self setFramesForLabelArea.			paneMorphs ifNotNil: 					[paneMorphs do: 							[:m | 							frame := m layoutFrame ifNil: [LayoutFrame new].							frame topOffset: (frame topOffset ifNil: [0]) - self labelHeight.							frame bottomFraction ~= 1.0 								ifTrue: 									[frame bottomOffset: (frame bottomOffset ifNil: [0]) - self labelHeight]]]].	label ifNotNil: 			[frame := LayoutFrame new.			frame				leftFraction: 0.5;				topFraction: 0;				leftOffset: label width negated // 2.			label layoutFrame: frame].	collapseBox ifNotNil: 			[frame := LayoutFrame new.			frame				rightFraction: 1;				topFraction: 0;				rightOffset: -1;				topOffset: 1.			collapseBox layoutFrame: frame].	stripes ifNotNil: 			[frame := LayoutFrame new.			frame				leftFraction: 0;				topFraction: 0;				rightFraction: 1;				leftOffset: 1;				topOffset: 1;				rightOffset: -1.			stripes first layoutFrame: frame.			stripes first height: self labelHeight - 2.			stripes first hResizing: #spaceFill.			frame := LayoutFrame new.			frame				leftFraction: 0;				topFraction: 0;				rightFraction: 1;				leftOffset: 3;				topOffset: 3;				rightOffset: -3.			stripes last layoutFrame: frame.			stripes last height: self labelHeight - 6.			stripes last hResizing: #spaceFill].	menuBox ifNotNil: 			[frame := LayoutFrame new.			frame				leftFraction: 0;				leftOffset: 19;				topFraction: 0;				topOffset: 1.			menuBox layoutFrame: frame].	closeBox ifNotNil: 			[frame := LayoutFrame new.			frame				leftFraction: 0;				leftOffset: 4;				topFraction: 0;				topOffset: 1.			closeBox layoutFrame: frame]! !!SystemWindow methodsFor: 'menu' stamp: 'gm 2/16/2003 20:35'!makeSecondTopmost	| aWorld nextWindow |	aWorld := self world.	nextWindow := aWorld submorphs 				detect: [:m | (m isSystemWindow) and: [m ~~ self]]				ifNone: [^self].	nextWindow activate.	aWorld addMorph: self behind: nextWindow! !!SystemWindow methodsFor: 'menu' stamp: 'gm 2/16/2003 20:35'!sendToBack	| aWorld nextWindow |	aWorld := self world.	nextWindow := aWorld submorphs 				detect: [:m | (m isSystemWindow) and: [m ~~ self]]				ifNone: [^self].	nextWindow activate.	aWorld addMorphNearBack: self! !!SystemWindow methodsFor: 'panes' stamp: 'gm 2/22/2003 13:14'!existingPaneColor	"Answer the existing pane color for the window, obtaining it from the first paneMorph if any, and fall back on using the second stripe color if necessary."	| aColor |	Preferences alternativeWindowLook 		ifTrue: 			[aColor := self valueOfProperty: #paneColor.			aColor 				ifNil: [self setProperty: #paneColor toValue: (aColor := self paneColor)].			^aColor].	paneMorphs isEmptyOrNil 		ifFalse: 			[((aColor := paneMorphs first color) isColor) ifTrue: [^aColor]].	^stripes ifNotNil: [stripes second color] ifNil: [Color blue lighter]! !!SystemWindow methodsFor: 'panes' stamp: 'aoy 2/17/2003 01:11'!paneColor	| cc |	(cc := self valueOfProperty: #paneColor) ifNotNil: [^cc].	Display depth > 2 		ifTrue: 			[model ifNotNil: 					[model isInMemory 						ifTrue: 							[cc := Color colorFrom: model defaultBackgroundColor.							Preferences alternativeWindowLook 								ifTrue: 									[cc := (cc = Color lightYellow or: [cc = Color white]) 										ifTrue: [Color gray: 0.67]										ifFalse: [cc duller]]]].			cc 				ifNil: [cc := paneMorphs isEmptyOrNil ifFalse: [paneMorphs first color]]].	cc ifNil: [cc := Color white].	self paneColor: cc.	^cc! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'aoy 2/15/2003 21:06'!spawnPaneFrameHandle: event 	| resizer localPt side growingPane newBounds adjoiningPanes limit cursor |	(self world firstSubmorph isKindOf: NewHandleMorph) 		ifTrue: [^self	"Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight + 4) 		containsPoint: event cursorPoint) 			ifTrue: [^self	"in label or top of top pane"].	growingPane := self paneWithLongestSide: [:s | side := s]				near: event cursorPoint.	growingPane ifNil: [^self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) 		ifTrue: [^self].	(side == #top and: [growingPane top = self panelRect top]) ifTrue: [^self].	adjoiningPanes := paneMorphs 				select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit := adjoiningPanes isEmpty 				ifFalse: 					[(adjoiningPanes collect: [:pane | pane bounds perform: side]) 						perform: ((#(#top #left) includes: side) ifTrue: [#max] ifFalse: [#min])]				ifTrue: [self bounds perform: side].	cursor := Cursor resizeForEdge: side.	resizer := (NewHandleMorph new)				sensorMode: self fastFramingOn;				followHand: event hand					forEachPointDo: 						[:p | 						localPt := self pointFromWorld: p.						newBounds := growingPane bounds 									withSideOrCorner: side									setToPoint: localPt									minExtent: 40 @ 20									limit: limit.						self fastFramingOn 							ifTrue: 								["For fast display, only higlight the rectangle during loop"								Cursor currentCursor == cursor 									ifFalse: 										[(event hand)											visible: false;											refreshWorld;											visible: true.										cursor show].								newBounds := growingPane bounds newRectButtonPressedDo: 												[:f | 												growingPane bounds 													withSideOrCorner: side													setToPoint: (self pointFromWorld: Sensor cursorPoint)													minExtent: 40 @ 20													limit: limit].].								self 									reframePanesAdjoining: growingPane									along: side									to: newBounds.]					lastPointDo: [:p | ]					withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'testing' stamp: 'jam 3/9/2003 15:13'!isSystemWindow"answer whatever the receiver is a SystemWindow"	^ true! !!SystemWindow methodsFor: 'top window' stamp: 'aoy 2/15/2003 21:03'!lockInactivePortions	"Make me unable to respond to mouse and keyboard.  Control boxes remain active, except in novice mode"	self submorphsDo: [:m | m == labelArea ifFalse: [m lock]].	labelArea ifNotNil: 			[labelArea submorphsDo: 					[:m | 					(m == closeBox or: [m == collapseBox]) 						ifTrue: [m lock]]]! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'dgd 2/21/2003 22:36'!canExtractAll	^self members notEmpty! !!ArchiveViewer methodsFor: 'initialization' stamp: 'dgd 2/22/2003 19:38'!createButtonBar	| bar button narrowFont |	narrowFont := StrikeFont allSubInstances detectMin: 					[:ea | 					ea 						widthOfString: 'Contents'						from: 1						to: 8].	bar := AlignmentMorph newRow.	bar		color: self backgroundColor;		rubberBandCells: false;		vResizing: #shrinkWrap;		cellInset: 6 @ 0.	#(#('New\Archive' #canCreateNewArchive #createNewArchive 'Create a new, empty archive and discard this one') #('Load\Archive' #canOpenNewArchive #openNewArchive 'Open another archive and discard this one') #('Save\Archive As' #canSaveArchive #saveArchive 'Save this archive under a new name') #('Extract\All' #canExtractAll #extractAll 'Extract all this archive''s members into a directory') #('Add\File' #canAddMember #addMember 'Add a file to this archive') #('Add from\Clipboard' #canAddMember #addMemberFromClipboard 'Add the contents of the clipboard as a new file') #('Add\Directory' #canAddMember #addDirectory 'Add the entire contents of a directory, with all of its subdirectories') #('Extract\Member As' #canExtractMember #extractMember 'Extract the selected member to a file') #('Delete\Member' #canDeleteMember #deleteMember 'Remove the selected member from this archive') #('Rename\Member' #canRenameMember #renameMember 'Rename the selected member') #('View All\Contents' #canViewAllContents #changeViewAllContents 'Toggle the view of all the selected member''s contents')) 		do: 			[:arr | 			| buttonLabel |			buttonLabel := (TextMorph new)						string: arr first withCRs							fontName: narrowFont familyName							size: narrowFont pointSize							wrap: false;						hResizing: #shrinkWrap;						lock;						yourself.			(button := PluggableButtonMorph 						on: self						getState: arr second						action: arr third)				vResizing: #shrinkWrap;				hResizing: #spaceFill;				onColor: self buttonOnColor offColor: self buttonOffColor;				label: buttonLabel;				setBalloonText: arr fourth.			bar addMorphBack: button.			buttonLabel composeToBounds].	^bar! !!PDAMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!PDAMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:48'!initialize	"initialize the state of the receiver"	super initialize.	""		self extent: 406 @ 408.	PDA new initialize openAsMorphIn: self! !!PartsWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor	"answer the default color/fill style for the receiver"	^ Color white! !!PartsWindow methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:46'!initialize	"initialize the state of the receiver"	| aFont aForm |	super initialize.	""		openForEditing _ false.	aFont _ Preferences standardButtonFont.	self addMorph: (prevButton _ SimpleButtonMorph new borderWidth: 0;					 label: '<' font: aFont;					 color: Color transparent;					 setBalloonText: 'previous page';					 actionSelector: #previousPage;					 target: self;					 extent: 16 @ 16).	self addMorph: (nextButton _ SimpleButtonMorph new borderWidth: 0;					 label: '>' font: aFont;					 color: Color transparent;					 setBalloonText: 'next page';					 actionSelector: #nextPage;					 target: self;					 extent: 16 @ 16).	menuButton _ ThreePhaseButtonMorph new onImage: (aForm _ ScriptingSystem formAtKey: 'OfferToUnlock');								offImage: (ScriptingSystem formAtKey: 'OfferToLock');								pressedImage: (ScriptingSystem formAtKey: 'OfferToLock');				 extent: aForm extent;				 state: #on.	menuButton target: self;		 actionSelector: #toggleStatus;		 actWhen: #buttonUp.	menuButton setBalloonText: 'open for editing'.	self addMorph: menuButton.	" 	self addMorph: (menuButton _ SimpleButtonMorph new  	borderWidth: 0;  	label: '' font: aFont; color: Color transparent;  	actWhen: #buttonDown;  	actionSelector: #invokePartsWindowMenu; target: self; extent:  	16@16)."	self adjustBookControls! !!PreDebugWindow methodsFor: 'initialization' stamp: 'aoy 2/15/2003 21:39'!initialize	| aFont proceedLabel debugLabel aWidth |	super initialize.	true 		ifFalse: 			["Preferences optionalMorphicButtons"			(aWidth := self widthOfFullLabelText) > 280 ifTrue: [^self].	"No proceed/debug buttons if title too long"			debugLabel := aWidth > 210 				ifTrue: 					["Abbreviated buttons if title pretty long"					proceedLabel := 'p'.					'd']				ifFalse: 					["Full buttons if title short enough"					proceedLabel := 'proceed'.					'debug'].			aFont := Preferences standardButtonFont.			self addMorph: (proceedButton := (SimpleButtonMorph new)								borderWidth: 0;								label: proceedLabel font: aFont;								color: Color transparent;								actionSelector: #proceed;								target: self).			proceedButton setBalloonText: 'continue execution'.			self addMorph: (debugButton := (SimpleButtonMorph new)								borderWidth: 0;								label: debugLabel font: aFont;								color: Color transparent;								actionSelector: #debug;								target: self).			debugButton setBalloonText: 'bring up a debugger'.			proceedButton submorphs first color: Color blue.			debugButton submorphs first color: Color red].	self adjustBookControls! !!SystemWindow class methodsFor: 'top window' stamp: 'gm 2/16/2003 20:55'!noteTopWindowIn: aWorld	| newTop |	"TopWindow must be nil or point to the top window in this project."	TopWindow _ nil.	aWorld ifNil: [^ self].	newTop _ nil.	aWorld submorphsDo:		[:m | (m isSystemWindow) ifTrue:			[(newTop == nil and: [m activeOnlyOnTop])				ifTrue: [newTop _ m].			(m model isKindOf: Project)				ifTrue: ["This really belongs in a special ProjWindow class"						m label ~= m model name ifTrue: [m setLabel: m model name]]]].	newTop == nil ifFalse: [newTop activate]! !!SystemWindow class methodsFor: 'top window' stamp: 'gm 2/16/2003 20:55'!windowsIn: aWorld satisfying: windowBlock	| windows s |	windows _ OrderedCollection new.	aWorld ifNil: [^windows].	"opening MVC in Morphic - WOW!!"	aWorld submorphs do:		[:m |		((m isSystemWindow) and: [windowBlock value: m])			ifTrue: [windows addLast: m]			ifFalse: [((m isKindOf: TransformationMorph) and: [m submorphs size = 1])					ifTrue: [s _ m firstSubmorph.							((s isSystemWindow) and: [windowBlock value: s])								ifTrue: [windows addLast: s]]]].	^ windows! !!TTSampleFontMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!TTSampleFontMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!TTSampleFontMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:43'!initialize	"initialize the state of the receiver"	super initialize.	smoothing _ 4.	self extent: 300 @ 300! !!TTSampleStringMorph methodsFor: 'geometry testing' stamp: 'dgd 2/22/2003 14:42'!containsPoint: aPoint 	"^ super containsPoint: aPoint"	"so much faster..."	| picker |	(self bounds containsPoint: aPoint) ifFalse: [^false].	picker := BalloonCanvas on: (Form extent: 1 @ 1 depth: 32).	picker transformBy: (MatrixTransform2x3 withOffset: aPoint negated).	self drawOn: picker.	^(picker form bits first) ~= 0! !!TTSampleStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 0! !!TTSampleStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ {Color magenta. Color yellow. Color orange. Color lightGray} atRandom! !!TabSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:56'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse appearanceMorph oldTop aMenu |	tabsToUse := OrderedCollection new.	rejects := OrderedCollection new.	pageHolder submorphs doWithIndex: 			[:m :i | 			toAdd := nil.			(m isKindOf: BookMorph) ifTrue: [toAdd := SorterTokenMorph forMorph: m].			(m isKindOf: SorterTokenMorph) 				ifTrue: 					[toAdd := m morphRepresented.					(toAdd referent isKindOf: MenuMorph) 						ifTrue: 							[(aMenu := toAdd referent) setProperty: #paletteMenu toValue: true.							(aMenu submorphs size > 1 and: 									[(aMenu submorphs second isKindOf: MenuItemMorph) 										and: [aMenu submorphs second contents = 'dismiss this menu']]) 								ifTrue: 									[aMenu submorphs first delete.	"delete title"									aMenu submorphs first delete.	"delete stay-up item"									(aMenu submorphs first isKindOf: MenuLineMorph) 										ifTrue: [aMenu submorphs first delete]]].					toAdd removeAllMorphs.					toAdd addMorph: (appearanceMorph := m submorphs first).					appearanceMorph position: toAdd position.					appearanceMorph lock.					toAdd fitContents].			toAdd ifNil: [rejects add: m] ifNotNil: [tabsToUse add: toAdd]].	tabsToUse isEmpty 		ifTrue: [^self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	book tabsMorph color: pageHolder color.	oldTop := self topRendererOrSelf.	"in case some maniac has flexed the sorter"	oldOwner := oldTop owner.	oldTop delete.	oldOwner addMorphFront: book! !!TabbedPalette methodsFor: 'dropping/grabbing' stamp: 'dgd 2/21/2003 23:00'!wantsDroppedMorph: aMorph event: evt 	(tabsMorph bounds containsPoint: (self pointFromWorld: evt cursorPoint)) 		ifTrue: [^false	"unless it's a book, perhaps, someday"].	^currentPage isNil or: [currentPage wantsDroppedMorph: aMorph event: evt]! !!TabbedPalette methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!TabbedPalette methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:08'!initialize	"Initialize the receiver, which was just created via a call to the  	class's #basicNew"	super initialize.	""	pageSize _ self defaultPageSize.	self removeEverything.		tabsMorph _ IndexTabs new.	self addMorph: tabsMorph! !!TabbedPalette methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:07'!setInitialState	super setInitialState.""	self layoutInset: 0.	pageSize _ 156 @ 232! !!TableLayout methodsFor: 'layout' stamp: 'jdl 3/28/2003 08:18'!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph 	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell := cellHolder key.	cells := cellHolder value.	properties wrapDirection == #none 		ifTrue: [wrap := SmallInteger maxVal]		ifFalse: 			[wrap := aBool ifTrue: [newBounds width] ifFalse: [newBounds height].			wrap := wrap max: (maxCell x)].	spacing := properties cellSpacing.	(spacing == #globalRect or: [spacing = #globalSquare]) 		ifTrue: 			["Globally equal spacing is a very special case here, so get out fast and easy"			^self 				computeGlobalCellArrangement: cells				in: newBounds				horizontal: aBool				wrap: wrap				spacing: spacing].	output := WriteStream on: Array new.	inset := properties cellInset asPoint.	aBool ifFalse: [inset := inset transposed].	first := last := nil.	maxExtent := 0 @ 0.	sum := 0.	index := 1.	n := 0.	hFill := vFill := false.	[index <= cells size] whileTrue: 			[w := sum.			cell := cells at: index.			cellMax := maxExtent max: cell cellSize.	"e.g., minSize"			sum := (spacing == #localRect or: [spacing == #localSquare]) 						ifTrue: 							["Recompute entire size of current row"							max := spacing == #localSquare 										ifTrue: [cellMax x max: cellMax y]										ifFalse: [cellMax x].							(n + 1) * max]						ifFalse: [sum + cell cellSize x].			(sum + (n * inset x) > wrap and: [first notNil]) 				ifTrue: 					["It doesn't fit and we're not starting a new line"					(spacing == #localSquare or: [spacing == #localRect]) 						ifTrue: 							[spacing == #localSquare 								ifTrue: [maxExtent := (maxExtent x max: maxExtent y) asPoint].							first do: [:c | c cellSize: maxExtent]].					w := w + ((n - 1) * inset x).					"redistribute extra space"					first nextCell 						ifNotNil: [first nextCell do: [:c | c addExtraSpace: inset x @ 0]].					last := LayoutCell new.					last cellSize: w @ maxExtent y.					last hSpaceFill: hFill.					last vSpaceFill: vFill.					last nextCell: first.					output position = 0 ifFalse: [last addExtraSpace: 0 @ inset y].					output nextPut: last.					first := nil.					maxExtent := 0 @ 0.					sum := 0.					n := 0.					hFill := vFill := false]				ifFalse: 					["It did fit; use next item from input"					first ifNil: [first := last := cell]						ifNotNil: 							[last nextCell: cell.							last := cell].					index := index + 1.					n := n + 1.					maxExtent := cellMax.					hFill := hFill or: [cell hSpaceFill].					vFill := vFill or: [cell vSpaceFill]]].	first ifNotNil: 			[last := LayoutCell new.			sum := sum + ((n - 1) * inset x).			first nextCell 				ifNotNil: [first nextCell do: [:c | c addExtraSpace: inset x @ 0]].			last cellSize: sum @ maxExtent y.			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse: [last addExtraSpace: 0 @ inset y].			output nextPut: last].	output := output contents.	properties listSpacing == #equal 		ifTrue: 			["Make all the heights equal"			max := output inject: 0 into: [:size :c | size max: c cellSize y].			output do: [:c | c cellSize: c cellSize x @ max]].	^output! !!TableLayout methodsFor: 'layout' stamp: 'aoy 2/15/2003 20:49'!computeExtraSpacing: arrangement in: newBounds horizontal: aBool target: aMorph 	"Compute the required extra spacing for laying out the cells"	"match newBounds extent with arrangement's orientation"	| extent extra centering n extraPerCell cell last hFill vFill max amount allow |	extent := newBounds extent.	aBool ifFalse: [extent := extent transposed].	"figure out if we have any horizontal or vertical space fillers"	hFill := vFill := false.	max := 0 @ 0.	arrangement do: 			[:c | 			max := (max x max: c cellSize x) @ (max y + c cellSize y).			max := max max: c cellSize.			hFill := hFill or: [c hSpaceFill].			vFill := vFill or: [c vSpaceFill]].	"Take client's shrink wrap constraints into account.	Note: these are only honored when there are no #spaceFill children,	or when #rubberBandCells is set."	allow := properties rubberBandCells not.	aMorph hResizing == #shrinkWrap 		ifTrue: 			[aBool 				ifTrue: [allow & hFill ifFalse: [extent := max x @ (max y max: extent y)]]				ifFalse: [allow & vFill ifFalse: [extent := (max x max: extent x) @ max y]]].	aMorph vResizing == #shrinkWrap 		ifTrue: 			[aBool 				ifFalse: [allow & hFill ifFalse: [extent := max x @ (max y max: extent y)]]				ifTrue: [allow & vFill ifFalse: [extent := (max x max: extent x) @ max y]]].	"Now compute the extra v space"	extra := extent y 				- (arrangement inject: 0 into: [:sum :c | sum + c cellSize y]).	extra > 0 		ifTrue: 			["Check if we have any #spaceFillers"			vFill 				ifTrue: 					["use only #spaceFillers"					n := arrangement inject: 0								into: [:sum :c | c vSpaceFill ifTrue: [sum + 1] ifFalse: [sum]].					n isZero ifFalse: [extraPerCell := extra asFloat / n asFloat].					extra := last := 0.					arrangement do: 							[:c | 							c vSpaceFill 								ifTrue: 									[extra := (last := extra) + extraPerCell.									amount := 0 @ (extra truncated - last truncated).									c do: [:cc | cc cellSize: cc cellSize + amount]]]]				ifFalse: 					["no #spaceFillers; distribute regularly"					centering := properties wrapCentering.					"centering == #topLeft ifTrue:[]."	"add all extra space to the last cell; e.g., do nothing"					centering == #bottomRight 						ifTrue: 							["add all extra space to the first cell"							arrangement first addExtraSpace: 0 @ extra].					centering == #center 						ifTrue: 							["add 1/2 extra space to the first and last cell"							arrangement first addExtraSpace: 0 @ (extra // 2)].					centering == #justified 						ifTrue: 							["add extra space equally distributed to each cell"							n := arrangement size - 1 max: 1.							extraPerCell := extra asFloat / n asFloat.							extra := last := 0.							arrangement do: 									[:c | 									c addExtraSpace: 0 @ (extra truncated - last truncated).									extra := (last := extra) + extraPerCell]]]].	"Now compute the extra space for the primary direction"	centering := properties listCentering.	1 to: arrangement size		do: 			[:i | 			cell := arrangement at: i.			extra := extent x - cell cellSize x.			extra > 0 				ifTrue: 					["Check if we have any #spaceFillers"					cell := cell nextCell.					cell hSpaceFill 						ifTrue: 							["use only #spaceFillers"														n := cell inject: 0										into: [:sum :c | c hSpaceFill ifTrue: [sum + c target spaceFillWeight] ifFalse: [sum]].							n isZero ifFalse: [extraPerCell := extra asFloat / n asFloat].							extra := last := 0.							cell do: 									[:c | 									c hSpaceFill 										ifTrue: 											[extra := (last := extra) + (extraPerCell * c target spaceFillWeight).											amount := extra truncated - last truncated.											c cellSize: c cellSize + (amount @ 0)]]]						ifFalse: 							["no #spaceFiller; distribute regularly"													"centering == #topLeft ifTrue:[]"	"add all extra space to the last cell; e.g., do nothing"							centering == #bottomRight 								ifTrue: 									["add all extra space to the first cell"									cell addExtraSpace: extra @ 0].							centering == #center 								ifTrue: 									["add 1/2 extra space to the first and last cell"									cell addExtraSpace: (extra // 2) @ 0].							centering == #justified 								ifTrue: 									["add extra space equally distributed to each cell"									n := cell size - 1 max: 1.									extraPerCell := extra asFloat / n asFloat.									extra := last := 0.									cell do: 											[:c | 											c addExtraSpace: (extra truncated - last truncated) @ 0.											extra := (last := extra) + extraPerCell]]]]]! !!TableLayout methodsFor: 'layout' stamp: 'aoy 2/17/2003 01:23'!layout: aMorph in: box 	"Compute the layout for the given morph based on the new bounds"	| cells arrangement horizontal newBounds |	aMorph hasSubmorphs ifFalse: [^self].	properties := aMorph assureTableProperties.	newBounds := box origin asIntegerPoint corner: box corner asIntegerPoint.	(properties wrapDirection == #none and: [properties cellSpacing == #none]) 		ifTrue: 			["get into the fast lane"			properties listCentering == #justified 				ifFalse: 					["can't deal with that"					properties listDirection == #leftToRight 						ifTrue: [^self layoutLeftToRight: aMorph in: newBounds].					properties listDirection == #topToBottom 						ifTrue: [^self layoutTopToBottom: aMorph in: newBounds]]].	horizontal := (properties listDirection == #topToBottom 				or: [properties listDirection == #bottomToTop]) not. 	"Step 1: Compute the minimum extent for all the children of aMorph"	cells := self 				computeCellSizes: aMorph				in: (0 @ 0 corner: newBounds extent)				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement := self 				computeCellArrangement: cells				in: newBounds				horizontal: horizontal				target: aMorph.	"Step 3: Compute the extra spacing for each cell"	self 		computeExtraSpacing: arrangement		in: newBounds		horizontal: horizontal		target: aMorph.	"Step 4: Place the children within the cells accordingly"	self 		placeCells: arrangement		in: newBounds		horizontal: horizontal		target: aMorph! !!TableLayout methodsFor: 'layout' stamp: 'gm 2/28/2003 01:43'!minExtentOf: aMorph in: box 	"Return the minimal size aMorph's children would require given the new bounds"	| cells arrangement horizontal newBounds minX minY dir |	minExtentCache isNil ifFalse: [^minExtentCache].	aMorph hasSubmorphs ifFalse: [^0 @ 0].	properties := aMorph assureTableProperties.	(properties wrapDirection == #none and: [properties cellSpacing == #none]) 		ifTrue: 			["Get into the fast lane"			dir := properties listDirection.			(dir == #leftToRight or: [dir == #rightToLeft]) 				ifTrue: [^self minExtentHorizontal: aMorph].			(dir == #topToBottom or: [dir == #bottomToTop]) 				ifTrue: [^self minExtentVertical: aMorph]].	newBounds := box origin asIntegerPoint corner: box corner asIntegerPoint.	horizontal := (properties listDirection == #topToBottom 				or: [properties listDirection == #bottomToTop]) not.	"Step 1: Compute the minimum extent for all the children of aMorph"	cells := self 				computeCellSizes: aMorph				in: (0 @ 0 corner: newBounds extent)				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement := self 				computeCellArrangement: cells				in: newBounds				horizontal: horizontal				target: aMorph.	"Step 3: Extract the minimum size out of the arrangement"	minX := minY := 0.	arrangement do: 			[:cell | 			minX := minX max: cell cellSize x + cell extraSpace x.			minY := minY + cell cellSize y + cell extraSpace y].	minExtentCache := horizontal ifTrue: [minX @ minY] ifFalse: [minY @ minX].	^minExtentCache! !!TableLayout methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:42'!placeCells: arrangement in: newBounds horizontal: aBool target: aMorph 	"Place the morphs within the cells accordingly"	| xDir yDir anchor yDist place cell xDist cellRect corner inset |	inset := properties cellInset.	(inset isNumber and: [inset isZero]) ifTrue: [inset := nil].	aBool 		ifTrue: 			["horizontal layout"			properties listDirection == #rightToLeft 				ifTrue: 					[xDir := -1 @ 0.					properties wrapDirection == #bottomToTop 						ifTrue: 							[yDir := 0 @ -1.							anchor := newBounds bottomRight]						ifFalse: 							[yDir := 0 @ 1.							anchor := newBounds topRight]]				ifFalse: 					[xDir := 1 @ 0.					properties wrapDirection == #bottomToTop 						ifTrue: 							[yDir := 0 @ -1.							anchor := newBounds bottomLeft]						ifFalse: 							[yDir := 0 @ 1.							anchor := newBounds topLeft]]]		ifFalse: 			["vertical layout"			properties listDirection == #bottomToTop 				ifTrue: 					[xDir := 0 @ -1.					properties wrapDirection == #rightToLeft 						ifTrue: 							[yDir := -1 @ 0.							anchor := newBounds bottomRight]						ifFalse: 							[yDir := 1 @ 0.							anchor := newBounds bottomLeft]]				ifFalse: 					[xDir := 0 @ 1.					anchor := properties wrapDirection == #rightToLeft 								ifTrue: 									[yDir := -1 @ 0.									newBounds topRight]								ifFalse: 									[yDir := 1 @ 0.									newBounds topLeft]]].	1 to: arrangement size		do: 			[:i | 			cell := arrangement at: i.			cell extraSpace ifNotNil: [anchor := anchor + (cell extraSpace y * yDir)].			yDist := cell cellSize y * yDir.	"secondary advance direction"			place := anchor.			cell := cell nextCell.			[cell isNil] whileFalse: 					[cell extraSpace ifNotNil: [place := place + (cell extraSpace x * xDir)].					xDist := cell cellSize x * xDir.	"primary advance direction"					corner := place + xDist + yDist.					cellRect := Rectangle origin: (place min: corner)								corner: (place max: corner).					inset ifNotNil: [cellRect := cellRect insetBy: inset].					cell target layoutInBounds: cellRect.					place := place + xDist.					cell := cell nextCell].			anchor := anchor + yDist]! !!TableLayout methodsFor: 'optimized' stamp: 'jdl 3/28/2003 08:48'!layoutLeftToRight: aMorph in: newBounds 	"An optimized left-to-right list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell props |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint x.	extent := newBounds extent.	n := 0.	vFill := false.	sum := 0.	width := height := 0.	first := last := nil.	block := 			[:m | 			props := m layoutProperties ifNil: [m].			props disableTableLayout 				ifFalse: 					[n := n + 1.					cell := LayoutCell new target: m.					props hResizing == #spaceFill 						ifTrue: 							[cell hSpaceFill: true.							extra := m spaceFillWeight.							cell extraSpace: extra.							sum := sum + extra]						ifFalse: [cell hSpaceFill: false].					props vResizing == #spaceFill ifTrue: [vFill := true].					size := m minExtent.					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX ifTrue: [sizeX := minX] ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY ifTrue: [sizeY := minY] ifFalse: [sizeY := sizeY min: maxY].					cell cellSize: sizeX.					last ifNil: [first := cell] ifNotNil: [last nextCell: cell].					last := cell.					width := width + sizeX.					sizeY > height ifTrue: [height := sizeY]]].	properties reverseTableCells 		ifTrue: [aMorph submorphsReverseDo: block]		ifFalse: [aMorph submorphsDo: block].	n > 1 ifTrue: [width := width + ((n - 1) * inset)].	(properties hResizing == #shrinkWrap 		and: [properties rubberBandCells or: [sum isZero]]) 			ifTrue: [extent := width @ (extent y max: height)].	(properties vResizing == #shrinkWrap 		and: [properties rubberBandCells or: [vFill not]]) 			ifTrue: [extent := (extent x max: width) @ height].	posX := newBounds left.	posY := newBounds top.	"Compute extra vertical space"	extra := extent y - height.	extra := extra max: 0.	extra > 0 		ifTrue: 			[vFill 				ifTrue: [height := extent y]				ifFalse: 					[centering := properties wrapCentering.					centering == #bottomRight ifTrue: [posY := posY + extra].					centering == #center ifTrue: [posY := posY + (extra // 2)]]].	"Compute extra horizontal space"	extra := extent x - width.	extra := extra max: 0.	extraPerCell := 0.	extra > 0 		ifTrue: 			[sum isZero 				ifTrue: 					["extra space but no #spaceFillers"					centering := properties listCentering.					centering == #bottomRight ifTrue: [posX := posX + extra].					centering == #center ifTrue: [posX := posX + (extra // 2)]]				ifFalse: [extraPerCell := extra asFloat / sum asFloat]].	n := 0.	extra := last := 0.	cell := first.	[cell isNil] whileFalse: 			[n := n + 1.			width := cell cellSize.			(extraPerCell > 0 and: [cell hSpaceFill]) 				ifTrue: 					[extra := (last := extra) + (extraPerCell * cell extraSpace).					amount := extra truncated - last truncated.					width := width + amount].			cell target layoutInBounds: (posX @ posY extent: width @ height).			posX := posX + width + inset.			cell := cell nextCell]! !!TableLayout methodsFor: 'optimized' stamp: 'jdl 3/28/2003 08:50'!layoutTopToBottom: aMorph in: newBounds 	"An optimized top-to-bottom list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell props |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint y.	extent := newBounds extent.	n := 0.	vFill := false.	sum := 0.	width := height := 0.	first := last := nil.	block := 			[:m | 			props := m layoutProperties ifNil: [m].			props disableTableLayout 				ifFalse: 					[n := n + 1.					cell := LayoutCell new target: m.					props vResizing == #spaceFill 						ifTrue: 							[cell vSpaceFill: true.							extra := m spaceFillWeight.							cell extraSpace: extra.							sum := sum + extra]						ifFalse: [cell vSpaceFill: false].					props hResizing == #spaceFill ifTrue: [vFill := true].					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX ifTrue: [sizeX := minX] ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY ifTrue: [sizeY := minY] ifFalse: [sizeY := sizeY min: maxY].					cell cellSize: sizeY.					first ifNil: [first := cell] ifNotNil: [last nextCell: cell].					last := cell.					height := height + sizeY.					sizeX > width ifTrue: [width := sizeX]]].	properties reverseTableCells 		ifTrue: [aMorph submorphsReverseDo: block]		ifFalse: [aMorph submorphsDo: block].	n > 1 ifTrue: [height := height + ((n - 1) * inset)].	(properties vResizing == #shrinkWrap 		and: [properties rubberBandCells or: [sum isZero]]) 			ifTrue: [extent := (extent x max: width) @ height].	(properties hResizing == #shrinkWrap 		and: [properties rubberBandCells or: [vFill not]]) 			ifTrue: [extent := width @ (extent y max: height)].	posX := newBounds left.	posY := newBounds top.	"Compute extra horizontal space"	extra := extent x - width.	extra := extra max: 0.	extra > 0 		ifTrue: 			[vFill 				ifTrue: [width := extent x]				ifFalse: 					[centering := properties wrapCentering.					centering == #bottomRight ifTrue: [posX := posX + extra].					centering == #center ifTrue: [posX := posX + (extra // 2)]]].	"Compute extra vertical space"	extra := extent y - height.	extra := extra max: 0.	extraPerCell := 0.	extra > 0 		ifTrue: 			[sum isZero 				ifTrue: 					["extra space but no #spaceFillers"					centering := properties listCentering.					centering == #bottomRight ifTrue: [posY := posY + extra].					centering == #center ifTrue: [posY := posY + (extra // 2)]]				ifFalse: [extraPerCell := extra asFloat / sum asFloat]].	n := 0.	extra := last := 0.	cell := first.	[cell isNil] whileFalse: 			[n := n + 1.			height := cell cellSize.			(extraPerCell > 0 and: [cell vSpaceFill]) 				ifTrue: 					[extra := (last := extra) + (extraPerCell * cell extraSpace).					amount := extra truncated - last truncated.					height := height + amount].			cell target layoutInBounds: (posX @ posY extent: width @ height).			posY := posY + height + inset.			cell := cell nextCell]! !!TableLayout methodsFor: 'optimized' stamp: 'jdl 3/28/2003 08:37'!minExtentHorizontal: aMorph 	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint.	n := 0.	width := height := 0.	aMorph submorphsDo: 			[:m | 			m disableTableLayout 				ifFalse: 					[n := n + 1.					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX 						ifTrue: [sizeX := minX]						ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY 						ifTrue: [sizeY := minY]						ifFalse: [sizeY := sizeY min: maxY].					width := width + sizeX.					sizeY > height ifTrue: [height := sizeY]]].	n > 1 ifTrue: [width := width + ((n - 1) * inset x)].	^minExtentCache := width @ height! !!TableLayout methodsFor: 'optimized' stamp: 'jdl 3/28/2003 08:39'!minExtentVertical: aMorph 	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint.	n := 0.	width := height := 0.	aMorph submorphsDo: 			[:m | 			m disableTableLayout 				ifFalse: 					[n := n + 1.					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX 						ifTrue: [sizeX := minX]						ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY 						ifTrue: [sizeY := minY]						ifFalse: [sizeY := sizeY min: maxY].					height := height + sizeY.					sizeX > width ifTrue: [width := sizeX]]].	n > 1 ifTrue: [height := height + ((n - 1) * inset y)].	^minExtentCache := width @ height! !!TableLayout methodsFor: 'utilities' stamp: 'aoy 2/17/2003 01:22'!indexForInserting: aMorph at: aPoint in: owner 	"Return the insertion index based on the layout strategy defined for some morph. Used for drop insertion."	| horizontal morphList index |	owner hasSubmorphs ifFalse: [^1].	aMorph disableTableLayout ifTrue: [^1].	horizontal := (owner listDirection == #topToBottom 				or: [owner listDirection == #bottomToTop]) not .	morphList := owner submorphs.	owner reverseTableCells ifTrue: [morphList := morphList reversed].	index := self 				indexForInserting: aPoint				inList: morphList				horizontal: horizontal				target: owner.	owner reverseTableCells ifTrue: [index := morphList size - index + 2].	^index ifNil: [1]! !!TableLayout methodsFor: 'utilities' stamp: 'aoy 2/17/2003 01:22'!indexForInserting: aPoint inList: morphList horizontal: aBool target: aMorph 	| box cmp1 cmp2 cmp3 noWrap |	properties := aMorph layoutProperties.	noWrap := properties wrapDirection == #none.	aBool 		ifTrue: 			["horizontal"			properties listDirection == #rightToLeft 				ifTrue: [cmp1 := [:rect | aPoint x > rect left]]				ifFalse: [cmp1 := [:rect | aPoint x < rect right]].			properties wrapDirection == #bottomToTop 				ifTrue: 					[cmp2 := [:rect | aPoint y > rect top].					cmp3 := [:rect | aPoint y > rect bottom]]				ifFalse: 					[cmp2 := [:rect | aPoint y < rect bottom].					cmp3 := [:rect | aPoint y < rect top]]]		ifFalse: 			["vertical"			properties listDirection == #bottomToTop 				ifTrue: [cmp1 := [:rect | aPoint y > rect top]]				ifFalse: [cmp1 := [:rect | aPoint y < rect bottom]].			properties wrapDirection == #rightToLeft 				ifTrue: 					[cmp2 := [:rect | aPoint x > rect left].					cmp3 := [:rect | aPoint x > rect right]]				ifFalse: 					[cmp2 := [:rect | aPoint x < rect right].					cmp3 := [:rect | aPoint x < rect left]]]. 	morphList keysAndValuesDo: 			[:index :m | 			self flag: #arNote.	"it is not quite clear if we can really use #fullBounds here..."			box := m fullBounds.			noWrap 				ifTrue: 					["Only in one direction"					(cmp1 value: box) ifTrue: [^index]]				ifFalse: 					["Check for inserting before current row"					(cmp3 value: box) ifTrue: [^index].					"Check for inserting before current cell"					((cmp1 value: box) and: [cmp2 value: box]) ifTrue: [^index]]].	^morphList size + 1! !!Text methodsFor: 'accessing' stamp: 'gm 2/15/2003 14:59'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs := IdentitySet new.	runs withStartStopAndValueDo: 			[:start :stop :attribs | 			attribs 				do: [:attrib | attrib anchoredMorph ifNotNil: [morphs add: attrib anchoredMorph]]].	^morphs select: [:m | m isMorph]! !!Text methodsFor: 'accessing' stamp: 'gm 2/15/2003 14:59'!embeddedMorphsFrom: start to: stop 	"return the list of morphs embedded in me"	| morphs |	morphs := IdentitySet new.	runs 		runsFrom: start		to: stop		do: 			[:attribs | 			attribs 				do: [:attr | attr anchoredMorph ifNotNil: [morphs add: attr anchoredMorph]]].	^morphs select: [:m | m isMorph]! !!TextComponent methodsFor: 'components' stamp: 'gm 2/28/2003 00:35'!initFromPinSpecs	| ioPin |	ioPin := pinSpecs first.	getTextSelector := ioPin isInput 		ifTrue: [ioPin modelReadSelector]		ifFalse: [nil].	setTextSelector := ioPin isOutput 				ifTrue: [ioPin modelWriteSelector]				ifFalse: [nil]! !!TextComponent methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:25'!initialize	"initialize the state of the receiver"	super initialize.	self extent: 144 @ 42! !!FunctionComponent methodsFor: 'button' stamp: 'dgd 2/22/2003 14:25'!fire	| arguments newValue |	outputSelector ifNil: [^outputValue := nil].	functionSelector ifNil: [^outputValue := nil].	arguments := inputSelectors 				collect: [:s | s ifNil: [nil] ifNotNil: [model perform: s]].	newValue := (arguments findFirst: [:a | a isNil]) = 0 				ifTrue: [model perform: functionSelector withArguments: arguments]				ifFalse: [nil].	newValue = outputValue 		ifFalse: 			[model perform: outputSelector with: newValue.			outputValue := newValue]! !!PrintComponent methodsFor: 'menu commands' stamp: 'dgd 2/21/2003 23:04'!accept	"Inform the model of text to be accepted, and return true if OK."	| textToAccept |	self canDiscardEdits ifTrue: [^self flash].	setTextSelector isNil ifTrue: [^self].	textToAccept := textMorph asText.	model perform: setTextSelector		with: (Compiler evaluate: textToAccept logged: false).	self setText: textToAccept.	self hasUnacceptedEdits: false! !!PrintComponent methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:04'!getText	"Retrieve the current model text"	getTextSelector isNil ifTrue: [^Text new].	^(model perform: getTextSelector) printString asText! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:31'!composeOneLine	| rectangles |	rectangles := theContainer rectanglesAt: currentY height: defaultLineHeight.	rectangles notEmpty 		ifTrue: [(self composeAllRectangles: rectangles) ifNil: [^nil]]		ifFalse: [currentY := currentY + defaultLineHeight].	self checkIfReadyToSlide! !!TextContainer methodsFor: 'container protocol' stamp: 'dgd 2/22/2003 19:06'!rectanglesAt: lineY height: lineHeight 	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair := Array with: lineY with: lineHeight.	rects := rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^rects].	outerWidth := minWidth + (2 * OuterMargin).	self shadowForm.	"Compute the shape"	lineRect := 0 @ (lineY - shadowForm offset y) 				extent: shadowForm width @ lineHeight.	lineForm := shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues second) = lineRect area 		ifTrue: 			[rects := Array with: (shadowForm offset x @ lineY extent: lineRect extent)]		ifFalse: 			["No such luck -- scan the horizontal profile for segments of minWidth"			hProfile := lineForm xTallyPixelValue: 1 orNot: false.			rects := OrderedCollection new.			thisWidth := 0.			thisX := 0.			1 to: hProfile size				do: 					[:i | 					count := hProfile at: i.					count >= lineHeight 						ifTrue: [thisWidth := thisWidth + 1]						ifFalse: 							[thisWidth >= outerWidth 								ifTrue: 									[rects addLast: ((thisX + shadowForm offset x) @ lineY 												extent: thisWidth @ lineHeight)].							thisWidth := 0.							thisX := i]].			thisWidth >= outerWidth 				ifTrue: 					[rects addLast: ((thisX + shadowForm offset x) @ lineY 								extent: thisWidth @ lineHeight)]].	rects := rects collect: [:r | r insetBy: OuterMargin @ 0].	rectangleCache at: pair put: rects.	^rects! !!TextFieldMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:54'!defaultColor"answer the default color/fill style for the receiver"	^ Color veryLightGray lighter! !!TextFieldMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:54'!initialize	"initialize the state of the receiver"	| tm |	super initialize.	""		self addMorph: (tm _ TextMorph new).	tm fillingOnOff! !!TextMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 22:27'!getFirstCharacter	"obtain the first character from the receiver if it is empty, return a  	black dot"	| aString |	^ (aString _ text string) isEmpty		ifTrue: ['']		ifFalse: [aString first] ! !!TextMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 22:32'!setFirstCharacter: source 	"Set the first character of the receiver as indicated"	| aChar chars |	aChar _ source asCharacter.	(chars _ self getCharacters) isEmpty		ifTrue: [self				newContents: (String with: aChar)]		ifFalse: [chars first = aChar				ifFalse: [self						newContents: (String								streamContents: [:aStream | 									aStream nextPut: aChar.									aStream										nextPutAll: (chars copyFrom: 2 to: chars size)])]] ! !!TextMorph methodsFor: 'change reporting' stamp: 'dgd 2/21/2003 22:29'!ownerChanged	| priorEditor |	super ownerChanged.	container ifNotNil: 			[editor isNil 				ifTrue: [self releaseParagraph]				ifFalse: 					[priorEditor := editor.					self releaseParagraph.					self installEditorToReplace: priorEditor]]! !!TextMorph methodsFor: 'editing' stamp: 'dgd 2/21/2003 22:29'!passKeyboardFocusTo: otherMorph 	| w |	self flag: #arNote.	"Do we need this?!!"	(w := self world) isNil 		ifFalse: 			[w 				handsDo: [:h | h keyboardFocus == self ifTrue: [h newKeyboardFocus: otherMorph]]]! !!TextMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 19:04'!hasFocus	^editor notNil! !!TextMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:29'!keyboardFocusChange: aBoolean 	| w |	aBoolean 		ifTrue: 			["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"]]		ifFalse: 			["A hand has clicked elsewhere..."			(w := self world) isNil 				ifFalse: 					[w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].					"Release control unless some hand is still holding on"					self releaseEditor]]! !!TextMorph methodsFor: 'geometry' stamp: 'dgd 2/21/2003 22:29'!privateMoveBy: delta 	super privateMoveBy: delta.	editor isNil 		ifTrue: [paragraph ifNotNil: [paragraph moveBy: delta]]		ifFalse: 			["When moving text with an active editor, save and restore all state."			paragraph moveBy: delta.			self installEditorToReplace: editor]! !!TextMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!TextMorph methodsFor: 'linked frames' stamp: 'dgd 2/21/2003 22:26'!firstInChain	"Return the first morph in a chain of textMorphs"	| first |	first := self.	[first predecessor isNil] whileFalse: [first := first predecessor].	^first! !!TextMorph methodsFor: 'linked frames' stamp: 'dgd 2/21/2003 22:32'!startingIndex	predecessor isNil		ifTrue: [^ 1].	^ predecessor lastCharacterIndex + 1 ! !!TextMorph methodsFor: 'linked frames' stamp: 'dgd 2/21/2003 22:32'!withSuccessorsDo: aBlock 	"Evaluate aBlock for each morph in my successor chain"	| each |	each := self.	[each isNil] whileFalse: 			[aBlock value: each.			each := each successor]! !!TextMorph methodsFor: 'menus' stamp: 'dgd 2/21/2003 22:25'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'text color...' action: #changeTextColor.	aCustomMenu 		addUpdating: #autoFitString		target: self		action: #autoFitOnOff.	aCustomMenu 		addUpdating: #wrapString		target: self		action: #wrapOnOff.	aCustomMenu add: 'text margins...' action: #changeMargins:.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	(Preferences valueOfFlag: #noviceMode) not 		& (Preferences valueOfFlag: #simpleMenus) not 			ifTrue: 				[aCustomMenu add: 'code pane menu...' action: #yellowButtonActivity.				aCustomMenu add: 'code pane shift menu....'					action: #shiftedYellowButtonActivity].	outer := self owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) 		ifTrue: 			[container isNil 				ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]				ifFalse: 					[aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse: 			[(container isNil or: [container fillsOwner not]) 				ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]				ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].			(container isNil or: [container avoidsOcclusions not]) 				ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]				ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]]! !!TextMorph methodsFor: 'scripting access' stamp: 'dgd 2/21/2003 22:31'!setAllButFirstCharacter: source 	"Set all but the first char of the receiver to the source"	| aChar chars |	aChar _ source asCharacter.	(chars _ self getCharacters) isEmpty		ifTrue: [self newContents: '' , source asString]		ifFalse: [chars first = aChar				ifFalse: [""					self						newContents: (String								streamContents: [:aStream | 									aStream nextPut: chars first.									aStream nextPutAll: source])]] ! !!TextMorph methodsFor: 'visual properties' stamp: 'dgd 2/16/2003 20:03'!fillStyle	"Return the current fillStyle of the receiver."	^ self		valueOfProperty: #fillStyle		ifAbsent: [backgroundColor				ifNil: [Color transparent]]! !!TextMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 14:57'!fit	"Adjust my bounds to fit the text.  Should be a no-op if autoFit is not specified.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para cBounds lastOfLines heightOfLast |	self isAutoFit 		ifTrue: 			[newExtent := (self paragraph extent max: 9 @ textStyle lineGrid) + (0 @ 2).			newExtent := newExtent + (2 * borderWidth).			margins 				ifNotNil: [newExtent := ((0 @ 0 extent: newExtent) expandBy: margins) extent].			newExtent ~= bounds extent 				ifTrue: 					[(container isNil and: [successor isNil]) 						ifTrue: 							[para := paragraph.	"Save para (layoutChanged smashes it)"							super extent: newExtent.							paragraph := para]].			container notNil & successor isNil 				ifTrue: 					[cBounds := container bounds truncated.					"23 sept 2000 - try to allow vertical growth"					lastOfLines := self paragraph lines last.					heightOfLast := lastOfLines bottom - lastOfLines top.					(lastOfLines last < text size 						and: [lastOfLines bottom + heightOfLast >= self bottom]) 							ifTrue: 								[container releaseCachedState.								cBounds := cBounds origin corner: cBounds corner + (0 @ heightOfLast)].					self privateBounds: cBounds]].	"These statements should be pushed back into senders"	self paragraph positionWhenComposed: self position.	successor ifNotNil: [successor predecessorChanged].	self changed	"Too conservative: only paragraph composition					should cause invalidation."! !!TextMorph methodsFor: 'private' stamp: 'dgd 2/21/2003 22:29'!predecessorChanged	| newStart oldStart |	(self hasProperty: #CreatingParagraph) ifTrue: [^self].	newStart := predecessor isNil 				ifTrue: [1]				ifFalse: [predecessor lastCharacterIndex + 1].	(self paragraph adjustedFirstCharacterIndex ~= newStart 		or: [newStart >= text size]) 			ifTrue: 				[paragraph composeAllStartingAt: newStart.				self fit]			ifFalse: 				["If the offset to end of text has not changed, just slide"				oldStart := self firstCharacterIndex.				self withSuccessorsDo: [:m | m adjustLineIndicesBy: newStart - oldStart]]! !!TextMorph methodsFor: 'private' stamp: 'dgd 2/22/2003 19:04'!updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor back |	paragraph ifNil: [^self].	wrapFlag ifNil: [wrapFlag := true].	editor ifNotNil: 			[oldEditor := editor.			sel := editor selectionInterval.			editor storeSelectionInParagraph].	text := paragraph text.	paragraph textStyle = textStyle 		ifTrue: [self fit]		ifFalse: 			["Broadcast style changes to all morphs"			newStyle := paragraph textStyle.			(self firstInChain text: text textStyle: newStyle) recomposeChain.			editor ifNotNil: [self installEditorToReplace: editor]].	super layoutChanged.	sel ifNil: [^self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil: 			[sel first <= (self paragraph lines first last + 1) 				ifTrue: 					[oldLast := predecessor lastCharacterIndex.					predecessor paragraph 						recomposeFrom: oldLast						to: text size						delta: 0.					oldLast = predecessor lastCharacterIndex 						ifFalse: 							[predecessor changed.	"really only last line"							self predecessorChanged]]].	((back := predecessor notNil 				and: [sel first <= self paragraph firstCharacterIndex]) or: 				[successor notNil 					and: [sel first > (self paragraph lastCharacterIndex + 1)]]) 		ifTrue: 			["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."			back ifTrue: [predecessor recomposeChain] ifFalse: [self recomposeChain].			self firstInChain withSuccessorsDo: 					[:m | 					(sel first between: m firstCharacterIndex and: m lastCharacterIndex + 1) 						ifTrue: 							[m installEditorToReplace: oldEditor.							^self passKeyboardFocusTo: m]].			self error: 'Inconsistency in text editor'	"Must be somewhere in the successor chain"].	editor ifNil: 			["Reinstate selection after, eg, style change"			self installEditorToReplace: oldEditor]! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:33'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color		r: 1.0		g: 0.355		b: 0.452! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 6! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color blue! !!ClipboardMorph methodsFor: 'parts bin' stamp: 'dgd 2/14/2003 22:09'!initializeToStandAlone	super initializeToStandAlone.""	self initialize.	""	self extent: 200 @ 100.	self		backgroundColor: (Color				r: 0.484				g: 1.0				b: 0.484).	self setBalloonText: 'This shows the current contents of the text clipboard'.	self newContents: Clipboard clipboardText! !!TextMorphEditor methodsFor: 'accessing' stamp: 'dgd 2/21/2003 22:50'!zapSelectionWith: aText 	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start := startBlock stringIndex.	stop := stopBlock stringIndex.	(aText isEmpty and: [stop > start]) 		ifTrue: 			["If deleting, then set emphasisHere from 1st character of the deletion"			emphasisHere := (paragraph text attributesAt: start						forStyle: paragraph textStyle) select: [:att | att mayBeExtended]].	(start = stop and: [aText isEmpty]) 		ifFalse: 			[paragraph 				replaceFrom: start				to: stop - 1				with: aText				displaying: false.	"** was true in super"			self computeIntervalFrom: start to: start + aText size - 1.			UndoInterval := otherInterval := self selectionInterval].	self userHasEdited	" -- note text now dirty"! !!TextMorphEditor methodsFor: 'editing keys' stamp: 'dgd 2/22/2003 19:08'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply curFont menuList |	true ifTrue: [^self changeTextFont].	self flag: #arNote.	"Move this up once we get rid of MVC"	curFont := (paragraph text fontAt: startBlock stringIndex				withStyle: paragraph textStyle) fontNameWithPointSize.	aList := paragraph textStyle fontNamesWithPointSizes.	menuList := aList collect: 					[:fntName | 					fntName = curFont ifTrue: ['<on>' , fntName] ifFalse: ['<off>' , fntName]].	reply := (SelectionMenu labelList: menuList selections: aList) startUp.	reply notNil 		ifTrue: 			[self replaceSelectionWith: (Text string: self selection asString						attribute: (TextFontChange fontNumber: (aList indexOf: reply)))]! !!TextMorphEditor methodsFor: 'menu messages' stamp: 'dgd 2/22/2003 19:08'!changeEmphasisOrAlignment	| aList reply code align menuList |	self flag: #arNote.	"Move this up once we get rid of MVC"	aList := #(#plain #bold #italic #narrow #underlined #struckOut #leftFlush #centered #rightFlush #justified).	align := paragraph text alignmentAt: startBlock stringIndex				ifAbsent: [paragraph textStyle alignment].	code := paragraph text emphasisAt: startBlock stringIndex.	menuList := WriteStream on: Array new.	menuList nextPut: (code = 0 ifTrue: ['<on>plain'] ifFalse: ['<off>plain']).	menuList 		nextPutAll: (#(#bold #italic #underlined #struckOut) collect: 					[:emph | 					(code anyMask: (TextEmphasis perform: emph) emphasisCode) 						ifTrue: ['<on>' , emph]						ifFalse: ['<off>' , emph]]).	((paragraph text attributesAt: startBlock stringIndex		forStyle: paragraph textStyle) 			anySatisfy: [:attr | attr isKern and: [attr kern < 0]]) 			ifTrue: [menuList nextPut: '<on>narrow']			ifFalse: [menuList nextPut: '<off>narrow'].	menuList nextPutAll: (#(#leftFlush #centered #rightFlush #justified) 				collectWithIndex: 					[:type :i | 					align = (i - 1) ifTrue: ['<on>' , type] ifFalse: ['<off>' , type]]).	aList := #(#plain #bold #italic #underlined #struckOut #narrow #leftFlush #centered #rightFlush #justified).	reply := (SelectionMenu 				labelList: menuList contents				lines: #(1 6)				selections: aList) startUpWithoutKeyboard.	reply notNil 		ifTrue: 			[(#(#leftFlush #centered #rightFlush #justified) includes: reply) 				ifTrue: 					[self setAlignment: reply.					paragraph composeAll.					self recomputeInterval]				ifFalse: 					[self setEmphasis: reply.					paragraph composeAll.					self recomputeSelection.					self mvcRedisplay]].	^true! !!TextMorphEditor methodsFor: 'menu messages' stamp: 'dgd 2/22/2003 19:08'!changeStyle	"Let user change styles for the current text pane."	| aList reply style theStyle menuList |	self flag: #arNote.	"Move this up once we get rid of MVC"	aList := (StrikeFont familyNames)				remove: 'DefaultTextStyle' ifAbsent: [];				asOrderedCollection.	theStyle := paragraph textStyle.	menuList := aList collect: 					[:styleName | 					"Hack!! use defaultFont for comparison - we have no name that we could use for compare and the style changes with alignment so they're no longer equal."					(TextConstants at: styleName) defaultFont == theStyle defaultFont 						ifTrue: ['<on>' , styleName]						ifFalse: ['<off>' , styleName]].	theStyle = TextStyle default 		ifTrue: [menuList addFirst: '<on>DefaultTextStyle']		ifFalse: [menuList addFirst: '<off>DefaultTextStyle'].	aList addFirst: 'DefaultTextStyle'.	reply := (SelectionMenu 				labelList: menuList				lines: #(1)				selections: aList) startUp.	reply notNil 		ifTrue: 			[(style := TextStyle named: reply) ifNil: 					[self beep.					^true].			paragraph textStyle: style copy.			paragraph composeAll.			self recomputeSelection.			self mvcRedisplay].	^true! !!TextMorphEditor methodsFor: 'private' stamp: 'dgd 2/21/2003 22:50'!againOrSame: bool 	| bk keys |	(bk := morph ownerThatIsA: BookMorph) ifNotNil: 			[(keys := bk valueOfProperty: #tempSearchKey ifAbsent: [nil]) ifNil: 					["Cmd-f"					keys := bk valueOfProperty: #searchKey ifAbsent: [nil]	"Cmd-g"]				ifNotNil: [bk removeProperty: #tempSearchKey].			keys ifNotNil: 					[keys notEmpty						ifTrue: 							[bk findText: keys.							^(morph respondsTo: #editView) 								ifTrue: [morph editView selectionInterval: self selectionInterval]]]].	super againOrSame: bool.	(morph respondsTo: #editView) 		ifTrue: [morph editView selectionInterval: self selectionInterval]! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:54'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY 	"Here we determine the 'lines' of text that will fit along each segment of the curve. For each line, we determine its rectangle, then the dest wuadrilateral that it willbe rotated to.  Then, we take the outer hull to determine a dest rectangle for WarpBlt.  In addition we need the segment pivot point and angle, from which the source quadrilateral may be computed."	| charIndex scanner line firstLine curveSegments segIndex pa pb segLen lineRect textSegments segDelta segAngle destRect destQuad i oldBounds |	(oldBounds := container bounds) ifNotNil: [curve invalidRect: oldBounds].	charIndex := startingIndex.	lines := startingLines.	curveSegments := curve lineSegments.	container textDirection < 0 		ifTrue: 			[curveSegments := curveSegments reversed 						collect: [:seg | Array with: (seg second) with: seg first]].	textSegments := OrderedCollection new.	scanner := SegmentScanner new text: text textStyle: textStyle.	segIndex := 1.	"For curves, segIndex is just an index."	firstLine := true.	pa := curveSegments first first.	[charIndex <= text size and: [segIndex <= curveSegments size]] whileTrue: 			[curve isCurve ifFalse: [pa := (curveSegments at: segIndex) first].			pb := (curveSegments at: segIndex) last.			segDelta := pb - pa.	"Direction of this segment"			segLen := segDelta r.			lineRect := 0 @ 0 extent: segLen asInteger @ textStyle lineGrid.			line := scanner 						composeFrom: charIndex						inRectangle: lineRect						firstLine: firstLine						leftSide: true						rightSide: true.			line setRight: scanner rightX.			line width > 0 				ifTrue: 					[lines addLast: line.					segAngle := segDelta theta.					destQuad := line rectangle corners collect: 									[:p | 									(p translateBy: pa - (0 @ (line baseline + container baseline))) 										rotateBy: segAngle negated										about: pa].					destRect := Rectangle encompassing: destQuad.					textSegments addLast: (Array 								with: destRect truncated								with: pa								with: segAngle).					pa := pa + ((pb - pa) * line width / segLen).					charIndex := line last + 1].			segIndex := segIndex + 1.			firstLine := false].	lines isEmpty 		ifTrue: 			["No space in container or empty text"			line := (TextLine 						start: startingIndex						stop: startingIndex - 1						internalSpaces: 0						paddingWidth: 0)						rectangle: (0 @ 0 extent: 10 @ textStyle lineGrid);						lineHeight: textStyle lineGrid baseline: textStyle baseline.			lines := Array with: line.			textSegments addLast: (Array 						with: (curve vertices first extent: line rectangle extent)						with: curve vertices first						with: 0.0)].	"end of segments, now attempt word break."	lines last last < text size 		ifTrue: 			[			[lines size > 1 				and: [(text at: (i := lines last last) + 1) ~= Character space]] 					whileTrue: 						[i = lines last first 							ifTrue: 								[lines removeLast.								textSegments removeLast]							ifFalse: [lines last stop: i - 1]]].	lines := lines asArray.	container textSegments: textSegments asArray.	curve invalidRect: container bounds.	^maxRightX! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:54'!textSegmentsDo: blockForLineDestPivotAngle 	| segments segSpec |	(segments := container textSegments) ifNil: [^self].	1 to: lines size		do: 			[:i | 			segSpec := segments at: i.			blockForLineDestPivotAngle 				value: (lines at: i)				value: (segSpec first)				value: (segSpec second)				value: (segSpec third)]! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:54'!warpMapForDepth: destDepth withTransparentFor: bkgndColor 	(CachedWarpDepth = destDepth and: [CachedWarpColor = bkgndColor]) 		ifTrue: 			["Map is OK as is -- return it"			^CachedWarpMap].	(CachedWarpMap isNil or: [CachedWarpDepth ~= destDepth]) 		ifTrue: 			["Have to recreate the map"			CachedWarpMap := Color computeColormapFrom: 32 to: destDepth.			CachedWarpDepth := destDepth]		ifFalse: 			["Map is OK, if we restore prior color substiution"			CachedWarpMap at: (CachedWarpColor indexInMap: CachedWarpMap)				put: (CachedWarpColor pixelValueForDepth: destDepth)].	"Now map the background color into transparent, and return the new map"	CachedWarpColor := bkgndColor.	CachedWarpMap at: (CachedWarpColor indexInMap: CachedWarpMap) put: 0.	^CachedWarpMap! !!TextOnCurveContainer methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:36'!bounds	textSegments ifNil: [^nil].	^textSegments inject: (textSegments first first)		into: [:bnd :each | bnd merge: (each first)]! !!TextOnCurveContainer methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:37'!translateBy: delta 	textSegments isNil ifTrue: [^self].	textSegments := textSegments collect: 					[:ls | 					Array 						with: (ls first translateBy: delta)						with: (ls second translateBy: delta)						with: ls third]! !!TextPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:55'!defaultBorderColor"answer the default border color/fill style for the receiver"	^ self defaultColor darker! !!TextPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:55'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.355		g: 0.742		b: 0.839! !!TextPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:55'!initialize	"initialize the state of the receiver"	super initialize.	""	applyToWholeText _ true.	myTarget		ifNil: [""			myTarget _ TextMorph new openInWorld.			myTarget contents: ''].		activeTextMorph _ TextMorph new extent: 300 @ 100;				 contents: myTarget contents wrappedTo: 300;				 text: myTarget contents textStyle: myTarget textStyle;				 releaseCachedState.	thingsToRevert at: #wrapFlag: put: myTarget isWrapped;		 at: #autoFit: put: myTarget isAutoFit;		 at: #margins: put: myTarget margins.	self rebuild! !!TheWorldMenu methodsFor: 'commands' stamp: 'aoy 2/15/2003 21:19'!splitNewMorphList: list depth: d 	| middle c prev next out |	d <= 0 ifTrue: [^Array with: list].	middle := list size // 2 + 1.	c := (list at: middle) name first.	prev := middle - 1.	[prev > 0 and: [(list at: prev) name first = c]] 		whileTrue: [prev := prev - 1].	next := middle + 1.	[next <= list size and: [(list at: next) name first = c]] 		whileTrue: [next := next + 1].	"Choose the better cluster"	middle := middle - prev < (next - middle) 				ifTrue: [prev + 1]				ifFalse: [next]. 	middle = 1 ifTrue: [middle := next].	middle >= list size ifTrue: [middle := prev + 1].	(middle = 1 or: [middle >= list size]) ifTrue: [^Array with: list].	out := WriteStream on: Array new.	out nextPutAll: (self splitNewMorphList: (list copyFrom: 1 to: middle - 1)				depth: d - 1).	out 		nextPutAll: (self splitNewMorphList: (list copyFrom: middle to: list size)				depth: d - 1).	^out contents! !!TheWorldMenu methodsFor: 'commands' stamp: 'dgd 2/21/2003 22:33'!worldMenuHelp	"self currentWorld primaryHand worldMenuHelp"	| aList aMenu cnts explanation |	aList := OrderedCollection new.	#(#helpMenu #changesMenu #openMenu #debugMenu #projectMenu #scriptingMenu #windowsMenu #playfieldMenu #appearanceMenu #flapsMenu) 		with: #('help' 'changes' 'open' 'debug' 'projects' 'authoring tools' 'windows' 'playfield options' 'appearance' 'flaps')		do: 			[:sel :title | 			aMenu := self perform: sel.			aMenu items do: 					[:it | 					((cnts := it contents) = 'keep this menu up' or: [cnts isEmpty]) 						ifFalse: [aList add: cnts , ' - ' , title]]].	aList := aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation := String streamContents: 					[:aStream | 					aList do: 							[:anItem | 							aStream								nextPutAll: anItem;								cr]].	(StringHolder new contents: explanation) 		openLabel: 'Where in the world menu is...'! !!TheWorldMenu methodsFor: 'construction' stamp: 'gm 2/28/2003 01:42'!alphabeticalMorphMenu	| list splitLists menu firstChar lastChar subMenu |	list := Morph withAllSubclasses select: [:m | m includeInNewMorphMenu].	list := list asArray sortBy: [:c1 :c2 | c1 name < c2 name].	splitLists := self splitNewMorphList: list depth: 3.	menu := MenuMorph new defaultTarget: self.	1 to: splitLists size		do: 			[:i | 			firstChar := i = 1 				ifTrue: [$A]				ifFalse: 					[((splitLists at: i - 1) last name first asInteger + 1) 								asCharacter].			lastChar := i = splitLists size 						ifTrue: [$Z]						ifFalse: [(splitLists at: i) last name first].			subMenu := MenuMorph new.			(splitLists at: i) do: 					[:cl | 					subMenu 						add: cl name						target: self						selector: #newMorphOfClass:event:						argument: cl].			menu add: firstChar asString , ' - ' , lastChar asString subMenu: subMenu].	^menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'gm 2/24/2003 18:08'!fillIn: aMenu from: dataForMenu 	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:			nil							Indicates to add a line			first element is symbol		Add updating item with the symbol as the wording selector			second element is a list		second element has the receiver and selector			first element is a string		Add menu item with the string as its wording			second element is a list		second element has the receiver and selector			a third element exists		Use it as the balloon text			a fourth element exists		Use it as the enablement selector (updating case only)"	| item |	dataForMenu do: 			[:itemData | 			itemData ifNil: [aMenu addLine]				ifNotNil: 					[item := (itemData first isKindOf: Symbol) 								ifTrue: 									[aMenu 										addUpdating: itemData first										target: self										selector: #doMenuItem:with:										argumentList: { 												itemData second}]								ifFalse: 									[aMenu 										add: itemData first										target: self										selector: #doMenuItem:with:										argumentList: { 												itemData second}].					itemData size >= 3 						ifTrue: 							[aMenu balloonTextForLastItem: itemData third.							itemData size >= 4 ifTrue: [item enablementSelector: itemData fourth]]]].	^aMenu! !!ThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 13:24'!loadPage	| theProject projectInfo url gotoPage theBook |	projectInfo := listOfPages at: currentIndex.	url := projectInfo first.	gotoPage := projectInfo at: 2 ifAbsent: [nil].	[Project fromUrl: url] on: ProjectEntryNotification		do: 			[:ex | 			self deleteCurrentPage.			theProject := ex projectToEnter enterAsActiveSubprojectWithin: self world.			theProject world showExpandedView.			loadedProject := theProject.			gotoPage ifNotNil: 					[theBook := loadedProject world findA: BookMorph.					theBook ifNotNil: [theBook goToPage: gotoPage]].			^loadedProject]! !!ThreadNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color red lighter! !!ThreadNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:28'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 6;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  useRoundedCorners;	  ensureSuitableDefaults;	  addButtons! !!InternalThreadNavigationMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/22/2003 14:13'!loadPageWithProgress	| projectInfo projectName |	projectInfo := listOfPages at: currentIndex.	projectName := projectInfo first.	loadedProject := Project named: projectName.	self class know: listOfPages as: threadName.	WorldState 		addDeferredUIMessage: 			[InternalThreadNavigationMorph openThreadNamed: threadName				atIndex: currentIndex] 					fixTemps.	loadedProject ifNil: 			[(ComplexProgressIndicator new)				targetMorph: self;				historyCategory: 'project loading';				withProgressDo: 						[						[loadedProject := CurrentProjectRefactoring 									currentFromMyServerLoad: projectName] 								on: ProjectViewOpenNotification								do: 									[:ex | 									ex resume: false									"we probably don't want a project view morph in this case"]]].	loadedProject ifNil: [^self inform: 'I cannot find that project'].	self delete.	loadedProject enter! !!InternalThreadNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/16/2003 14:15'!defaultColor	"answer the default color/fill style for the receiver"	^ (Color		r: 0.27		g: 0.634		b: 0.365)		alpha: 0.25! !!InternalThreadNavigationMorph methodsFor: 'piano rolls' stamp: 'dgd 2/22/2003 14:13'!triggerActionFromPianoRoll	| proj |	WorldState addDeferredUIMessage: 			[self currentIndex >= listOfPages size 				ifTrue: [1 beep]				ifFalse: 					[currentIndex := self currentIndex + 1.					proj := Project named: ((listOfPages at: currentIndex) first).					proj world setProperty: #letTheMusicPlay toValue: true.					proj enter]]! !!ThreePhaseButtonMorph methodsFor: 'button' stamp: 'dgd 2/22/2003 18:45'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target notNil and: [actionSelector notNil]) 		ifTrue: 			[Cursor normal 				showWhile: [target perform: actionSelector withArguments: arguments].			target isMorph ifTrue: [target changed]]! !!ThreePhaseButtonMorph methodsFor: 'printing' stamp: 'dgd 2/22/2003 18:45'!printOn: aStream 	| string |	aStream nextPutAll: '3PButton'.	arguments notEmpty 		ifTrue: [string := arguments at: (2 min: arguments size)].	aStream nextPutAll: '('.	(string notNil and: [string ~~ self]) 		ifTrue: 			[aStream				print: string;				space]		ifFalse: 			[aStream				print: actionSelector;				space].	aStream		print: self identityHash;		nextPutAll: ')'! !!ThumbnailMorph methodsFor: 'display' stamp: 'gm 2/22/2003 13:15'!drawMeOn: aCanvas 	"Draw a small view of a morph in another place.  Guard against infinite recursion if that morph has a thumbnail of itself inside.  Now also works if the thing to draw is a plain Form rather than a morph."	| viewedMorphBox myBox scale c shrunkForm aWorld aFormOrMorph |	super drawOn: aCanvas.	((aFormOrMorph := self formOrMorphToView) isForm) 		ifTrue: [^self drawForForm: aFormOrMorph on: aCanvas].	(((aFormOrMorph notNil and: [(aWorld := aFormOrMorph world) notNil]) 		and: [aWorld ~~ aFormOrMorph or: [lastFormShown isNil]]) 			and: [RecursionDepth + 1 < RecursionMax]) 			ifTrue: 				[RecursionDepth := RecursionDepth + 1.				viewedMorphBox := aFormOrMorph fullBounds.				myBox := self innerBounds.				scale := myBox width / (viewedMorphBox width max: viewedMorphBox height).				c := Display defaultCanvasClass extent: viewedMorphBox extent							depth: aCanvas depth.				c translateBy: viewedMorphBox topLeft negated					during: 						[:tempCanvas | 						"recursion happens here"						tempCanvas fullDrawMorph: aFormOrMorph].				shrunkForm := c form 							magnify: c form boundingBox							by: scale							smoothing: 1.				lastFormShown := shrunkForm.				RecursionDepth := RecursionDepth - 1]			ifFalse: 				["This branch used if we've recurred, or if the thumbnail views a World that's already been rendered once, or if the referent is not in a world at the moment"				lastFormShown ifNotNil: [shrunkForm := lastFormShown]].	shrunkForm ifNotNil: 			[aCanvas paintImage: shrunkForm				at: self center - shrunkForm boundingBox center			"sw 12/20/1999 13:35 special-case code for SketchMorph commented out, since it seems to have done more harm than good: 			((aFormOrMorph isKindOf: SketchMorph) and: [false])				ifTrue:					[diag _ aFormOrMorph form extent  asInteger.					viewedMorphBox _						(aFormOrMorph bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ aFormOrMorph fullBounds]."]! !!ThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:57'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!ThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:56'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.781		g: 0.781		b: 0.781! !!ThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:57'!initialize	"Initialize the receiver, obeying a #nominalExtent property if I  	have one"	| anExtent |	super initialize.	""	anExtent _ self				valueOfProperty: #nominalExtent				ifAbsent: [25 @ 25].	self		extent: (anExtent				)! !!ThumbnailMorph methodsFor: 'what to view' stamp: 'gm 2/22/2003 13:15'!formOrMorphToView	"Answer the form to be viewed, or the morph to be viewed, or nil"	| actualViewee |	(objectToView isForm) ifTrue: [^objectToView].	actualViewee := viewSelector ifNil: [objectToView]				ifNotNil: [objectToView perform: viewSelector].	^actualViewee == 0 		ifTrue: [nil	"valueAtCursor result for an empty HolderMorph"]		ifFalse: 			[(actualViewee isKindOf: Player) 				ifTrue: [actualViewee costume]				ifFalse: [actualViewee]]! !!PlayerReferenceReadout methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:58'!mouseDown: evt 	"Allow the user to respecify this by direct clicking"	| aMorph |	(putSelector == #unused or: [putSelector isNil]) ifTrue: [^self].	Sensor waitNoButton.	aMorph := self world chooseClickTarget.	aMorph ifNil: [^self].	objectToView perform: putSelector with: aMorph assuredPlayer.	self changed! !!TickIndicatorMorph methodsFor: 'initialization' stamp: 'gm 3/10/2003 22:10'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ self defaultColor darker! !!TickIndicatorMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:59'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.767		g: 0.767		b: 1.0! !!TickIndicatorMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:59'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 20 @ 20.	index _ 0! !!TickIndicatorMorph methodsFor: 'stepping and presenter' stamp: 'dgd 2/21/2003 22:41'!stepAt: nowTick 	| delta |	self isTicking 		ifTrue: 			[(lastTick isNil or: [nowTick < lastTick]) ifTrue: [lastTick := nowTick].			delta := (nowTick - lastTick) // stepTime.			delta > 0 				ifTrue: 					[index := index + delta.					lastTick := nowTick.					self changed]]! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:21'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:21'!defaultColor"answer the default color/fill style for the receiver"	^ Color orange muchLighter! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:22'!initialize	"initialize the state of the receiver"	| r |	super initialize.	""	self layoutInset: 2.	self listDirection: #topToBottom.	self hResizing: #spaceFill;		 vResizing: #shrinkWrap;		 cellInset: 0 @ 1;		 minCellSize: 200 @ 14.	r _ AlignmentMorph newRow color: color;				 layoutInset: 0.	r setProperty: #demandsBoolean toValue: true.	r addMorphBack: (Morph new color: color;			 extent: 2 @ 5).	"spacer"	r		addMorphBack: (StringMorph new contents: 'Test').	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (testPart _ BooleanScriptEditor new borderWidth: 0;					 layoutInset: 1).	testPart color: Color transparent.	testPart hResizing: #spaceFill.	self addMorphBack: r.	r _ AlignmentMorph newRow color: color;				 layoutInset: 0.	r addMorphBack: (Morph new color: color;			 extent: 30 @ 5).	"spacer"	r		addMorphBack: (StringMorph new contents: 'Yes').	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (yesPart _ ScriptEditorMorph new borderWidth: 0;					 layoutInset: 2).	yesPart hResizing: #spaceFill.	yesPart color: Color transparent.	self addMorphBack: r.	r _ AlignmentMorph newRow color: color;				 layoutInset: 0.	r addMorphBack: (Morph new color: color;			 extent: 35 @ 5).	"spacer"	r		addMorphBack: (StringMorph new contents: 'No').	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (noPart _ ScriptEditorMorph new borderWidth: 0;					 layoutInset: 2).	noPart hResizing: #spaceFill.	noPart color: Color transparent.	self addMorphBack: r.	self bounds: self fullBounds! !!PhraseTileMorph methodsFor: 'code generation' stamp: 'dgd 2/22/2003 19:08'!storeCodeOn: aStream indent: tabCount 	"Add in some smarts for division by zero."	aStream nextPut: $(.	submorphs first storeCodeOn: aStream indent: tabCount.	aStream space.	submorphs second storeCodeOn: aStream indent: tabCount.	submorphs size > 2 		ifTrue: 			[(self catchDivideByZero: aStream indent: tabCount) 				ifFalse: 					[aStream space.					(submorphs third) storeCodeOn: aStream indent: tabCount]].	aStream nextPut: $)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'dgd 2/22/2003 19:40'!initialize	"Initialize a nascent instance"	super initialize.	resultType _ #unknown.	brightenedOnEnter _ false.	self wrapCentering: #center; cellPositioning: #leftCenter.	self hResizing: #shrinkWrap.	borderWidth _ 0.	self layoutInset: 0.	self extent: 5@5.  "will grow to fit"	justGrabbedFromViewer _ true.  "All new PhraseTileMorphs that go through the initialize process (rather than being copied) are placed in viewers; the clones dragged out from them will thus have this set the right way; the drop code resets this to false"! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'gm 2/24/2003 18:06'!vocabulary: aVocab 	"Set the vocabulary"	vocabularySymbol := (aVocab isKindOf: Symbol) 				ifTrue: [aVocab]				ifFalse: [aVocab vocabularyName]! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'dgd 2/22/2003 19:07'!catchDivideByZero: aStream indent: tabCount 	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	submorphs second type = #operator ifFalse: [^false].	"not me"	submorphs second operatorOrExpression == #/ ifFalse: [^false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs third) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^true! !!TileMessageNode methodsFor: 'printing' stamp: 'dgd 2/21/2003 22:52'!printToDoOn: aMorph indent: level 	| limitNode |	limitNode := (arguments last isNil 				or: [(arguments last isMemberOf: AssignmentNode) not]) 					ifTrue: [arguments first]					ifFalse: [arguments last value].	(selector key = #to:by:do: 		and: [arguments second isConstantNumber and: [arguments second key = 1]]) 			ifTrue: 				[self 					printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments third))					on: aMorph					indent: level]			ifFalse: 				[self 					printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aMorph					indent: level]! !!TileMorph methodsFor: 'accessing' stamp: 'gm 2/22/2003 13:11'!resultType	"Answer the result type of the receiver"	type == #literal 		ifTrue: 			[(literal isNumber) ifTrue: [^#Number].			(literal isString) ifTrue: [^#String].			(literal isKindOf: Boolean) ifTrue: [^#Boolean]].	type == #expression ifTrue: [^#Number].	type == #objRef ifTrue: [^#Player].	^#unknown! !!TileMorph methodsFor: 'code generation' stamp: 'aoy 2/15/2003 21:29'!storeCodeOn: aStream indent: tabCount 	"Store code representing the receiver onto the stream, with the given amount of indentation"	| op playerBearingCode |	playerBearingCode := self playerBearingCode.	"Must determine whom is scripted for what follows to work; if it's ever nil, we've got trouble"	type = #expression 		ifTrue: 			[^aStream				nextPut: $(;				nextPutAll: operatorOrExpression;				nextPut: $)].	type = #literal 		ifTrue: 			[^aStream				nextPut: $(;				nextPutAll: literal printString;				nextPut: $)].	type == #objRef 		ifTrue: 			[^playerBearingCode == actualObject 				ifTrue: 					["If the object is the method's own 'self' then we MUST, rather than just MAY, put out 'self' rather than the referencer call, though the latter will temporarily work if only one instance of the uniclass exists."					aStream nextPutAll: 'self']				ifFalse: 					[Preferences capitalizedReferences 						ifTrue: 							["Global dictionary References"							self flag: #deferred.	"Start deploying the meesage-receiver hints soon"							aStream nextPutAll: actualObject uniqueNameForReference]						ifFalse: 							["old class-inst-var-based scheme used  Feb 1998 to Oct 2000, and indeed						ongoing in school year 2000-01 at the open school"							aStream nextPutAll: 'self class '.							aStream 								nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]]].	type = #operator 		ifTrue: 			[op := ((UpdatingOperators includesKey: operatorOrExpression) 				and: [self precedingTileType = #slotRef]) 					ifTrue: [UpdatingOperators at: operatorOrExpression]					ifFalse: [operatorOrExpression].			^op isEmpty 				ifTrue: [aStream position: aStream position - 1]				ifFalse: [aStream nextPutAll: op]]	"The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 1 @ 1.	self		typeColor: (Color				r: 0.8				g: 1.0				b: 0.6).	type _ #literal.	"#literal, #slotRef, #objRef, #operator, #expression"	slotName _ ''.	literal _ 1.	self layoutPolicy: TableLayout new.	self cellInset: 2 @ 0.	self layoutInset: 1 @ 0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 22:56'!isPossessive	possessive isNil ifTrue: [^false].	^possessive! !!TileMorph methodsFor: 'initialization' stamp: 'gm 2/24/2003 18:08'!rawVocabulary: aVocabulary 	"Set the receiver's vocabulary, without side effects."	vocabularySymbol := (aVocabulary isKindOf: Symbol) 				ifTrue: [aVocabulary]				ifFalse: [aVocabulary vocabularyName]! !!AssignmentTileMorph methodsFor: 'code generation' stamp: 'aoy 2/15/2003 21:09'!storeCodeOn: aStream indent: tabCount 	"Generate code for an assignment statement.  The code generated looks presentable in the case of simple assignment, though the code generated for the increment/decrement/multiply cases is still the same old assignGetter... sort for now"aStream nextPutAll: (Utilities setterSelectorFor: assignmentRoot).			aStream space."Simple assignment, don't need existing value"	assignmentSuffix = ':' 		ifFalse: 			["Assignments that require that old values be retrieved"						self assignmentReceiverTile storeCodeOn: aStream indent: tabCount.			aStream space.			aStream nextPutAll: (Utilities getterSelectorFor: assignmentRoot).			aStream space.			aStream nextPutAll: (self operatorForAssignmentSuffix: assignmentSuffix).			aStream space]! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize"initialize the state of the receiver"	super initialize.""	type _ #operator.	assignmentSuffix _ ':'! !!ColorTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize"initialize the state of the receiver"	super initialize.""	type _ #literal.	self addColorSwatch! !!ColorSeerTile methodsFor: 'code generation' stamp: 'dgd 2/22/2003 14:25'!storeCodeOn: aStream indent: tabCount 	"We have a hidden arg. Output two keywords with interspersed arguments."	| parts |	parts := operatorOrExpression keywords.	"color:sees:"	^aStream		nextPutAll: (parts first);		space;		nextPutAll: colorSwatch color printString;		space;		nextPutAll: (parts second)! !!ColorSeerTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	| m1 m2 desiredW wording |	super initialize.""	self removeAllMorphs.	"get rid of the parts of a regular Color tile"	type _ #operator.	operatorOrExpression _ #color:sees:.	wording _ (Vocabulary eToyVocabulary				methodInterfaceAt: operatorOrExpression				ifAbsent: []) elementWording.	m1 _ StringMorph contents: wording font: ScriptingSystem fontForTiles.	m2 _ Morph new extent: 12 @ 8;								color: (Color						r: 0.8						g: 0						b: 0).	desiredW _ m1 width + 6.	self extent: (desiredW max: self basicWidth)			@ self class defaultH.	m1 position: bounds center x - (m1 width // 2) @ (bounds top + 5).	m2 position: bounds center x - (m2 width // 2) + 3 @ (bounds top + 8).	self addMorph: m1;		 addMorphFront: m2.	colorSwatch _ m2! !!GraphicTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	super initialize.""	type _ #literal.	self		useForm: (ScriptingSystem formAtKey: #Menu)! !!MenuTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	super initialize.""	self addArrows; setLiteral: 'send to back'.	self labelMorph useStringFormat; putSelector: nil! !!ParameterTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	super initialize.""	self typeColor: Color red! !!RandomNumberTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize	"Initialize the receiver fully, including adding all its relevant 	submorphs "	| m1 m2 |	super initialize.""	self vResizing: #shrinkWrap.	self		typeColor: (ScriptingSystem colorForType: #Number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ UpdatingStringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 target: self;		 getSelector: #literal;		 putSelector: #literal:.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel.	self makeAllTilesGreen! !!SoundTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	super initialize.""	self addArrows; setLiteral: 'croak'.	self labelMorph useStringFormat! !!SymbolListTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize	"initialize the receiver. Set up an event handler so that a click on 	the tile will produce a pop-up of alternatives"	super initialize.""	literal _ #nothing.	self		on: #mouseDown		send: #offerAllChoicesInAPopUp		to: self! !!TilePadMorph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:42'!acceptDroppingMorph: aMorph event: evt 	| editor wasPossessive |	wasPossessive := submorphs notEmpty and: [submorphs first isPossessive].	self prepareToUndoDropOf: aMorph.	self removeAllMorphs.	aMorph position: self position.	self addMorph: aMorph.	wasPossessive ifTrue: [aMorph bePossessive].	aMorph lastTile addRetractArrow.	"if can"	(editor := self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'mouse' stamp: 'dgd 2/22/2003 14:43'!prepareToUndoDropOf: aMorph 	| m |	m := self owner.	[m isNil] whileFalse: 			[(m isKindOf: ScriptEditorMorph) ifTrue: [^m prepareToUndoDropOf: aMorph].			m := m owner]! !!TinyPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color veryVeryLightGray! !!TinyPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:53'!initialize	"initialize the state of the receiver"	super initialize.	""		brushColor _ Color red.	brushSize _ 3.	self clear! !!TranscriptStream methodsFor: 'initialization' stamp: 'gm 2/16/2003 20:39'!closeAllViews	"Transcript closeAllViews"	self dependents do: 			[:d | 			(d isKindOf: PluggableTextView) 				ifTrue: [d topView controller closeAndUnscheduleNoTerminate].			(d isSystemWindow) ifTrue: [d delete]]! !!TransferMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:00'!defaultColor"answer the default color/fill style for the receiver"	^ Color blue alpha: 0.4! !!TransferMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:00'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 0 @ 0.	accepted _ false.	copy _ false.	! !!TransformMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:52'!transformFrom: uberMorph 	"Return a transform to map coorinates of uberMorph, a morph above me in my owner chain, into the coordinates of my submorphs."	(self == uberMorph or: [owner isNil]) ifTrue: [^transform].	^(owner transformFrom: uberMorph) composedWithLocal: transform! !!TransformMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGreen! !!TransformMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:39'!initialize	"initialize the state of the receiver"	super initialize.	""		smoothing _ 1.	transform _ MorphicTransform identity! !!FlashSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:27'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!TransformationMorph methodsFor: 'accessing' stamp: 'jdl 3/28/2003 08:13'!scaleToMatch: aPoint 	| scaleFactor tfm originalScale |	tfm := transform withScale: 1.0.	originalScale := ((tfm localBoundsToGlobal: self renderedMorph fullBounds) 				corner - (tfm localPointToGlobal: self renderedMorph referencePosition)) 				r.	"Catch cases where the reference point is on fullBounds corner"	originalScale := originalScale max: 1.0.	scaleFactor := (aPoint - self referencePosition) r / originalScale.	scaleFactor := scaleFactor < 1.0 				ifTrue: 					[scaleFactor 						detentBy: 0.05						atMultiplesOf: 0.25						snap: false]				ifFalse: 					[scaleFactor 						detentBy: 0.1						atMultiplesOf: 0.5						snap: false].	self adjustAfter: [self scale: ((scaleFactor min: 8.0) max: 0.1)]! !!TransformationMorph methodsFor: 'printing' stamp: 'dgd 2/21/2003 22:42'!printOn: aStream 	super printOn: aStream.	submorphs isEmpty 		ifTrue: [aStream nextPutAll: ' with no transformee!!']		ifFalse: [aStream nextPutAll: ' on ' , submorphs first printString]! !!TransformationMorph methodsFor: 'private' stamp: 'aoy 2/17/2003 01:02'!chooseSmoothing	"Choose appropriate smoothing, after a change of scale or rotation."	smoothing := (self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)]) 		ifTrue: [ 2]		ifFalse: [1]! !!BOBTransformationMorph methodsFor: 'layout' stamp: 'dgd 2/21/2003 23:02'!layoutChanged	"use the version from Morph"	| myGuy |	fullBounds := nil.	owner ifNotNil: [owner layoutChanged].	submorphs notEmpty 		ifTrue: 			[(myGuy := self firstSubmorph) isWorldMorph 				ifFalse: 					[worldBoundsToShow = myGuy bounds 						ifFalse: [self changeWorldBoundsToShow: (worldBoundsToShow := myGuy bounds)]]			"submorphs do: [:m | m ownerChanged]"	"<< I don't see any reason for this"]! !!TransitionMorph methodsFor: 'initialization' stamp: 'dgd 2/22/2003 14:22'!initiateReplacement	| n |	startForm := effect = #dissolve 				ifTrue: [(startMorph imageForm: 16 forRectangle: bounds) offset: 0 @ 0]				ifFalse: [(startMorph imageFormForRectangle: bounds) offset: 0 @ 0].	endForm := (endMorph imageFormForRectangle: bounds) offset: 0 @ 0.	nSteps isNil 		ifTrue: 			[self nSteps: 30 stepTime: 10.			(#(#zoom #pageForward #pageBack) includes: effect) 				ifTrue: 					[n := 20 * 100000 // self bounds area min: 20 max: 4.					self nSteps: n stepTime: 10].			#dissolve = effect 				ifTrue: 					[n := 20 * 50000 // self bounds area min: 20 max: 4.					self nSteps: n stepTime: 10]].	startBlock value.	"with forms in place there should b no further delay."	self arrangeToStartStepping! !!TransitionMorph methodsFor: 'private' stamp: 'aoy 2/17/2003 01:09'!effect: effectSymbol direction: dirSymbol 	| i |	effect := effectSymbol.	"Default directions"	(#(#zoom #zoomFrame #frenchDoor) includes: effectSymbol) 		ifTrue: 			[direction := (#(#in #out #inH #outH) includes: dirSymbol) 				ifTrue: [dirSymbol]				ifFalse: [#in]]		ifFalse: 			[i := #(#right #downRight #down #downLeft #left #upLeft #up #upRight) 						indexOf: dirSymbol						ifAbsent: [5].			direction := (0 @ 0) eightNeighbors at: i]! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:52'!createScrollBarNamed: aString "creates a scroll bar named as aString"	| result |	result _ ScrollBar new model: self slotName: aString.	result borderWidth: 2;		 borderColor: #inset.	^ result! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:53'!createScroller"create a scroller"	| result |	result _ TransformMorph new color: Color transparent.	result offset: 0 @ 0.	^ result! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #inset! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:03'!initialize	"initialize the state of the receiver"	super initialize.	""	self addMorph: (yScrollBar _ self createScrollBarNamed: 'yScrollBar');		 addMorph: (xScrollBar _ self createScrollBarNamed: 'xScrollBar');		 addMorph: (scroller _ self createScroller).	""	self extent: 150 @ 120! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'dgd 2/21/2003 22:33'!getMenu: shiftKeyState 	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector isNil ifTrue: [^nil].	menu := MenuMorph new defaultTarget: model.	aTitle := getMenuTitleSelector 				ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 		ifTrue: 			[aMenu := model perform: getMenuSelector with: menu.			aTitle ifNotNil: [aMenu addTitle: aTitle].			^aMenu].	getMenuSelector numArgs = 2 		ifTrue: 			[aMenu := model 						perform: getMenuSelector						with: menu						with: shiftKeyState.			aTitle ifNotNil: [aMenu addTitle: aTitle].			^aMenu].	^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!TypeListTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize	"Initialize the receiver. Cheesily, we use the extension arrow 	graphic for a menu icon temporarily"	super initialize"".	self addMenuIcon! !!URLMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!URLMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:53'!initialize	"initialize the state of the receiver"	super initialize.	""		isBookmark _ false! !!URLMorph methodsFor: 'private' stamp: 'gm 2/22/2003 13:16'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	| thum |	page ifNil: [page := SqueakPageCache atURL: url].	(thum := page thumbnail) ifNil: [^nil].	^(thum isForm) 		ifTrue: [thum]		ifFalse: [thum form	"a BookPageThumbnailMorph"]! !!UndescribedTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize	"Initialize the receiver. This is in its infancy -- just a place-holder 	at present"	super initialize.""	self extent: 20 @ 22.	self setLiteral: 'arg'! !!UniclassScript methodsFor: 'versions' stamp: 'aoy 2/15/2003 21:33'!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| aMenu chosenStampAndTileList |	formerScriptingTiles isEmptyOrNil ifTrue: [^self beep].	chosenStampAndTileList := formerScriptingTiles size == 1 		ifTrue: [ formerScriptingTiles first]		ifFalse: 			[aMenu := SelectionMenu 						labelList: (formerScriptingTiles collect: [:e | e first])						selections: formerScriptingTiles.			aMenu startUp].	chosenStampAndTileList ifNotNil: 			[anEditor reinsertSavedTiles: chosenStampAndTileList second.			isTextuallyCoded := false]! !!UpdatingMenuItemMorph methodsFor: 'enablement' stamp: 'aoy 2/17/2003 01:18'!enablementSelector: aSelector 	enablementSelector := (aSelector isKindOf: BlockContext) 				ifTrue: [aSelector copyForSaving]				ifFalse: [aSelector] ! !!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'dgd 2/21/2003 22:40'!updateContents	"Update the receiver's contents"	| newString enablement nArgs |	(wordingProvider isNil or: [wordingSelector isNil]) ifTrue: [^self].	newString := contents.	nArgs := wordingSelector numArgs.	newString := nArgs == 0 				ifTrue: [wordingProvider perform: wordingSelector]				ifFalse: 					[(nArgs == 1 and: [wordingArgument notNil]) 						ifTrue: [wordingProvider perform: wordingSelector with: wordingArgument]						ifFalse: 							[nArgs == arguments size 								ifTrue: [wordingProvider perform: wordingSelector withArguments: arguments]]].	newString = contents ifFalse: [self contents: newString].	enablementSelector ifNotNil: 			[(enablement := self enablement) == isEnabled 				ifFalse: [self isEnabled: enablement]]! !!UpdatingRectangleMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:45'!handlesMouseDown: evt 	^putSelector notNil! !!UpdatingRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color lightGray lighter! !!UpdatingRectangleMorph methodsFor: 'target access' stamp: 'dgd 2/22/2003 14:40'!readFromTarget	"Read the color value from my target"	| v |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	target isMorph ifTrue: [target isInWorld ifFalse: [^contents]].	v := self valueProvider perform: getSelector.	lastValue := v.	^v! !!ColorSwatch methodsFor: 'target access' stamp: 'dgd 2/22/2003 13:32'!readFromTarget	"Obtain a value from the target and set it into my lastValue"	| v |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	v := target perform: getSelector with: argument.	lastValue := v.	^v! !!ScriptableButton methodsFor: 'script' stamp: 'aoy 2/15/2003 20:48'!editButtonsScript	"The user has touched my Scriptor halo-handle.  Bring up a Scriptor on the script of the button."	| cardsPasteUp cardsPlayer anEditor |	cardsPasteUp := self pasteUpMorph.	(cardsPlayer := cardsPasteUp assuredPlayer) assureUniClass.	anEditor := scriptSelector ifNil: 					[scriptSelector := cardsPasteUp scriptSelectorToTriggerFor: self.					cardsPlayer newTextualScriptorFor: scriptSelector.					(scriptSelector beginsWith: 'script') 						ifTrue: 							[							cardsPlayer scriptEditorFor: scriptSelector	"as tiles"]						]				ifNotNil: 					[(cardsPlayer class selectors includes: scriptSelector) 						ifTrue: [cardsPlayer scriptEditorFor: scriptSelector]						ifFalse: 							["Method somehow got removed; I guess we start afresh"							scriptSelector := nil.							^self editButtonsScript]].	self currentHand attachMorph: anEditor! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'aoy 2/17/2003 01:15'!contents: newContents 	"This is the original StringMorph implementation of #contents:, restored down in UpdatingStringMorph because a recent 'optimization' of the StringMorph version of this method broke UpdatingStringMorphs."	contents := newContents isText 				ifTrue:  					[emphasis := newContents emphasisAt: 1.					newContents string]				ifFalse: 					[contents = newContents ifTrue: [^self].	"no substantive change"					newContents].	self fitContents.	self changed! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'dgd 2/22/2003 19:01'!setFontStyle	| aList reply style |	aList := (TextConstants select: [:anItem | anItem isKindOf: TextStyle]) 				keys asOrderedCollection.	reply := (SelectionMenu labelList: aList selections: aList) startUp.	reply notNil 		ifTrue: 			[(style := TextStyle named: reply) ifNil: 					[self beep.					^true].			self font: style defaultFont]! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:44'!initialize	"Initialie the receiver to have default values in its instance 	variables "	super initialize.""	format _ #default.	"formats: #string, #default"	target _ getSelector _ putSelector _ nil.	floatPrecision _ 1.	growable _ true.	stepTime _ 50.	autoAcceptOnFocusLoss _ true.	minimumWidth _ 8.	maximumWidth _ 300! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'dgd 2/22/2003 19:01'!informTarget	"Obtain a value from my contents, and tell my target about it.  The putSelector can take one argument (traditional) or two (as used by Croquet)"	| newValue typeIn |	(target notNil and: [putSelector notNil]) 		ifTrue: 			[typeIn := contents.			(newValue := self valueFromContents) ifNotNil: 					[self checkTarget.					putSelector numArgs = 1 						ifTrue: [target perform: putSelector with: newValue].					putSelector numArgs = 2 						ifTrue: 							[target 								perform: putSelector								with: newValue								with: self].					target isMorph ifTrue: [target changed]].			self fitContents.			(format == #default and: [newValue isNumber]) 				ifTrue: [self setDecimalPlacesFromTypeIn: typeIn]]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'dgd 2/21/2003 23:01'!readFromTarget	"Update my readout from my target"	| v |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	self checkTarget.	v := target perform: getSelector.	"scriptPerformer"	(v isKindOf: Text) ifTrue: [v := v asString].	^self acceptValueFromTarget: v! !!UpdatingBooleanStringMorph methodsFor: 'target access' stamp: 'dgd 2/22/2003 18:59'!informTarget	"Determine a value by evaluating my readout, and send that value to my target"	| newValue |	(target notNil and: [putSelector notNil]) 		ifTrue: 			[newValue := self valueFromContents.			newValue ifNotNil: 					[target 						perform: putSelector						with: getSelector						with: newValue.					target isMorph ifTrue: [target changed]].			self growable 				ifTrue: 					[self						readFromTarget;						fitContents.					owner updateLiteralLabel]]! !!KeyboardEvent methodsFor: 'encoding' stamp: 'dgd 2/22/2003 18:53'!decodeFromStringArray: array 	"decode the receiver from an array of strings"	type := array first asSymbol.	position := CanvasDecoder decodePoint: (array second).	buttons := CanvasDecoder decodeInteger: (array third).	keyValue := CanvasDecoder decodeInteger: array fourth! !!MouseButtonEvent methodsFor: 'encoding' stamp: 'dgd 2/22/2003 19:00'!decodeFromStringArray: array 	"decode the receiver from an array of strings"	type := array first asSymbol.	position := CanvasDecoder decodePoint: (array second).	buttons := CanvasDecoder decodeInteger: (array third).	whichButton := CanvasDecoder decodeInteger: (array fourth)! !!MouseMoveEvent methodsFor: 'encoding' stamp: 'dgd 2/22/2003 19:01'!decodeFromStringArray: array 	"decode the receiver from an array of strings"	type := array first asSymbol.	position := CanvasDecoder decodePoint: (array second).	buttons := CanvasDecoder decodeInteger: (array third).	startPoint := CanvasDecoder decodePoint: (array fourth)! !!UserScript methodsFor: 'versions' stamp: 'aoy 2/15/2003 21:26'!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| aMenu result |	formerScriptEditors isEmptyOrNil ifTrue: [^self beep].	result := formerScriptEditors size == 1 		ifTrue: [formerScriptEditors first]		ifFalse: 			[aMenu := SelectionMenu 						labelList: (formerScriptEditors collect: [:e | e timeStamp])						selections: formerScriptEditors.			aMenu startUp].	result 		ifNotNil: [self revertScriptVersionFrom: anEditor installing: result]! !!UserScript methodsFor: 'versions' stamp: 'dgd 2/21/2003 22:39'!saveScriptVersion: timeStampCurrentlyIgnored 	self isTextuallyCoded 		ifFalse: 			[formerScriptEditors isNil 				ifTrue: [formerScriptEditors := OrderedCollection new].			currentScriptEditor 				ifNotNil: [formerScriptEditors add: currentScriptEditor veryDeepCopy].			formerScriptEditors size > 100 				ifTrue: [^self error: 'apparent runaway versions']]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'gm 2/16/2003 20:53'!storeTextWindowContentsToFileNamed: aName	"Utilities storeTextWindowContentsToFileNamed: 'TextWindows'"	| windows aDict assoc aRefStream textToUse aTextView |	"there is a reference to World, but this method seems to be unused"	aDict _ Dictionary new.	Smalltalk isMorphic		ifTrue:			[windows _ World submorphs select: [:m | m isSystemWindow].			windows do:				[:w | assoc _ w titleAndPaneText.				assoc ifNotNil:					[w holdsTranscript ifFalse:						[aDict add: assoc]]]]		ifFalse:			[windows _ ScheduledControllers controllersSatisfying:				[:c | (c model isMemberOf: StringHolder) or: [c model isKindOf: Workspace]].			windows do:				[:aController | 					aTextView _ aController view subViews detect: [:m | m isKindOf: PluggableTextView] ifNone: [nil].					textToUse _ aTextView						ifNil:		[aController model contents]						ifNotNil:	[aTextView controller text].  "The latest edits, whether accepted or not"					aDict at: aController view label put: textToUse]].	aDict size = 0 ifTrue: [^ self inform: 'no windows found to export.'].	aRefStream _ ReferenceStream fileNamed: aName.	aRefStream nextPut: aDict.	aRefStream close.	self inform: 'Done!!  ', aDict size printString, ' window(s) exported.'! !!Viewer methodsFor: 'special phrases' stamp: 'dgd 2/22/2003 19:02'!colorSeesPhrase	"In classic tiles, answer a complete phrase that represents the colorSees test"	| outerPhrase |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs second) delete.	"operator"	outerPhrase addMorphBack: ColorSeerTile new.	(outerPhrase submorphs second) goBehind.	"Make it third"	outerPhrase submorphs last addMorph: (ColorTileMorph new 				typeColor: (ScriptingSystem colorForType: #Color)).	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'dgd 2/22/2003 19:02'!overlapsPhrase	"Answer a conjured-up overlaps phrase in classic tile"	| outerPhrase |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Player.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	outerPhrase addMorphBack: (TileMorph new setOperator: #overlaps:).	(outerPhrase submorphs second) goBehind.	"Make it third"	outerPhrase submorphs last addMorph: scriptedPlayer tileToRefer.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'dgd 2/22/2003 19:02'!seesColorPhrase	"In classic tiles, answer a complete phrase that represents the seesColor test"	| outerPhrase seesColorTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs second) delete.	"operator"	seesColorTile := TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs second) goBehind.	"Make it third"	"	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new 				typeColor: (ScriptingSystem colorForType: #Color)).	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'dgd 2/22/2003 19:02'!touchesAPhrase	"Answer a conjured-up touchesA phrase in classic tile"	| outerPhrase |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Player.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	outerPhrase addMorphBack: (TileMorph new setOperator: #touchesA:).	(outerPhrase submorphs second) goBehind.	"Make it third"	outerPhrase submorphs last addMorph: scriptedPlayer tileToRefer.	^outerPhrase! !!CategoryViewer methodsFor: 'categories' stamp: 'dgd 2/22/2003 14:25'!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList := scriptedPlayer categoriesForViewer: self.	aLinePosition := aList indexOf: #miscellaneous ifAbsent: [nil].	aList := aList 				collect: [:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	lineList := aLinePosition ifNil: [#()]				ifNotNil: [Array with: aLinePosition].	aList isEmpty ifTrue: [aList add: #'instance variables'].	aMenu := CustomMenu 				labels: aList				lines: lineList				selections: aList.	reply := aMenu startUpWithCaption: 'category'.	reply ifNil: [^self].	self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'dgd 2/22/2003 19:00'!getterTilesFor: getterSelector type: aType 	"Answer classic getter for the given name/type"	"aPhrase _ nil, assumed"	| selfTile selector aPhrase |	(#(#color:sees: #colorSees) includes: getterSelector) 		ifTrue: [aPhrase := self colorSeesPhrase].	(#(#seesColor: #isOverColor) includes: getterSelector) 		ifTrue: [aPhrase := self seesColorPhrase].	(#(#overlaps: #overlaps) includes: getterSelector) 		ifTrue: [aPhrase := self overlapsPhrase].	(#(#touchesA: #touchesA) includes: getterSelector) 		ifTrue: [aPhrase := self touchesAPhrase].	aPhrase ifNil: 			[aPhrase := PhraseTileMorph new setSlotRefOperator: getterSelector asSymbol						type: aType].	selfTile := self tileForSelf bePossessive.	selfTile position: aPhrase firstSubmorph position.	aPhrase firstSubmorph addMorph: selfTile.	selector := aPhrase submorphs second.	(Vocabulary vocabularyNamed: aType capitalized) 		ifNotNilDo: [:aVocab | aVocab wantsSuffixArrow ifTrue: [selector addSuffixArrow]].	selector updateLiteralLabel.	aPhrase enforceTileColorPolicy.	^aPhrase! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'gm 2/22/2003 13:12'!makeSetter: selectorAndTypePair event: evt from: aMorph 	"Classic tiles: make a Phrase that comprises a setter of a slot, and hand it to the user."	| argType m argTile selfTile argValue actualGetter |	argType := selectorAndTypePair second.	actualGetter := selectorAndTypePair first asSymbol.	m := PhraseTileMorph new 				setAssignmentRoot: (Utilities inherentSelectorForGetter: actualGetter)				type: #command				rcvrType: #Player				argType: argType				vocabulary: self currentVocabulary.	argValue := self scriptedPlayer 				perform: selectorAndTypePair first asSymbol.	(argValue isKindOf: Player) 		ifTrue: [argTile := argValue tileReferringToSelf]		ifFalse: 			[argTile := ScriptingSystem tileForArgType: argType.			(argType == #Number and: [argValue isNumber]) 				ifTrue: 					[(scriptedPlayer decimalPlacesForGetter: actualGetter) 						ifNotNilDo: [:places | (argTile findA: UpdatingStringMorph) decimalPlaces: places]].			argTile				setLiteral: argValue;				updateLiteralLabel].	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile := self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	m openInHand! !!SearchingViewer methodsFor: 'search' stamp: 'dgd 2/21/2003 23:03'!doSearchFrom: aSource 	"Perform the search operation"	| searchFor aVocab aList all anInterface useTranslations scriptNames addedMorphs |	searchString := (aSource isKindOf: PluggableTextMorph) 				ifFalse: [aSource]				ifTrue: [aSource text string].	searchFor := searchString asString asLowercase withBlanksTrimmed.	aVocab := self outerViewer currentVocabulary.	(useTranslations := (scriptedPlayer isKindOf: Player) 				and: [aVocab isKindOf: EToyVocabulary]) 			ifTrue: 				[all := scriptedPlayer costume selectorsForViewer.				all addAll: (scriptNames := scriptedPlayer class namedTileScriptSelectors)]			ifFalse: [all := scriptNames := scriptedPlayer class allSelectorsUnderstood].	aList := all select: 					[:aSelector | 					(aVocab 						includesSelector: aSelector						forInstance: scriptedPlayer						ofClass: scriptedPlayer class						limitClass: ProtoObject) and: 								[(useTranslations and: 										[(anInterface := aVocab methodInterfaceAt: aSelector ifAbsent: [nil]) 											notNil and: 													[anInterface elementWording includesSubstring: searchFor														caseSensitive: false]]) 									or: 										[((scriptNames includes: aSelector) or: [useTranslations not]) 											and: [aSelector includesSubstring: searchFor caseSensitive: false]]]].	aList := aList asSortedArray.	self removeAllButFirstSubmorph.	"that being the header"	self addAllMorphs: (addedMorphs := scriptedPlayer 						tilePhrasesForSelectorList: aList						inViewer: self).	self enforceTileColorPolicy.	self secreteCategorySymbol.	self world ifNotNil: [self world startSteppingSubmorphsOf: self].	self adjustColorsAndBordersWithin.	owner ifNotNil: 			[owner isStandardViewer ifTrue: [owner fitFlap].			addedMorphs isEmpty 				ifTrue: [self inform: 'No matches found for "' , searchFor , '"']]! !!StandardViewer methodsFor: 'categories' stamp: 'gm 2/22/2003 13:01'!categoryViewerFor: categoryInfo 	"Answer a category viewer for the given category info"	| aViewer |	aViewer := ((categoryInfo isCollection) 				and: [categoryInfo first == #search]) 					ifFalse: [CategoryViewer new]					ifTrue: [SearchingViewer new].	aViewer initializeFor: scriptedPlayer categoryChoice: categoryInfo.	^aViewer! !!StandardViewer methodsFor: 'categories' stamp: 'dgd 2/21/2003 22:35'!likelyCategoryToShow	"Choose a category to show based on what's already showing and on some predefined heuristics"	| possible all aCat currVocab |	all := (scriptedPlayer categoriesForViewer: self) asOrderedCollection.	possible := all copy.	currVocab := self currentVocabulary.	self categoryMorphs do: 			[:m | 			aCat := currVocab categoryWhoseTranslatedWordingIs: m currentCategory.			aCat ifNotNil: [possible remove: aCat categoryName ifAbsent: []]].	(currVocab isKindOf: EToyVocabulary) 		ifTrue: 			["hateful!!"			((possible includes: #'instance variables') 				and: [scriptedPlayer hasUserDefinedSlots]) ifTrue: [^#'instance variables'].			((possible includes: #scripts) and: [scriptedPlayer hasUserDefinedScripts]) 				ifTrue: [^#scripts]].	#(#basic) 		do: [:preferred | (possible includes: preferred) ifTrue: [^preferred]].	((scriptedPlayer isKindOf: Player) 		and: [scriptedPlayer hasOnlySketchCostumes]) 			ifTrue: [(possible includes: #tests) ifTrue: [^#tests]].	#(#'color & border' #tests #color #flagging #comparing) 		do: [:preferred | (possible includes: preferred) ifTrue: [^preferred]].	^possible isEmpty ifFalse: [possible first] ifTrue: [all first]! !!StandardViewer methodsFor: 'initialization' stamp: 'aoy 2/15/2003 21:42'!addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean 	"Add the header morph to the receiver, using anInteger as a guide for its height, and if aBoolean is true, include a dismiss buton for it"	| header aFont aButton aTextMorph nail wrpr costs headWrapper |	header := (AlignmentMorph newRow)				color: self color muchLighter;				wrapCentering: #center;				cellPositioning: #leftCenter.	aFont := Preferences standardButtonFont.	aBoolean 		ifTrue: 			[header addMorph: (aButton := SimpleButtonMorph new label: 'O' font: aFont).			aButton				target: self;				color: Color tan;				actionSelector: #dismiss;				setBalloonText: 'remove this entire Viewer from the screendon''t worry -- nothing will be lost!!.'.			header addTransparentSpacerOfSize: 4 @ 1].	aButton := (IconicButton new)				borderWidth: 0;				labelGraphic: (ScriptingSystem formAtKey: #AddCategoryViewer);				color: Color transparent;				actWhen: #buttonDown;				target: self;				actionSelector: #addCategoryViewer;				setBalloonText: 'click here to addanother category pane';				shedSelvedge.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 4 @ 1.	costs := scriptedPlayer costumes.	costs ifNotNil: 			[(costs size > 1 				or: [costs size = 1 and: [costs first ~~ scriptedPlayer costume]]) 					ifTrue: 						[header addUpDownArrowsFor: self.						(wrpr := header submorphs last) submorphs second 							setBalloonText: 'switch to previous costume'.						wrpr submorphs first setBalloonText: 'switch to next costume']].	nail := (self hasProperty: #noInteriorThumbnail) 				ifFalse:  					[ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume]				ifTrue: [ImageMorph new image: Cursor menu].	nail 		on: #mouseDown		send: #offerViewerMenuForEvt:morph:		to: scriptedPlayer.	header addMorphBack: nail.	nail 		setBalloonText: 'click here to get a menuthat will allow you toadd an instance variable,,tear off a tile, etc..'.	(self hasProperty: #noInteriorThumbnail) 		ifFalse: 			[nail				borderWidth: 3;				borderColor: #raised].	header addTransparentSpacerOfSize: 5 @ 5.	"	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' font: (aFont _ StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'I' font: aFont;  color: Color transparent; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5."	self viewsMorph ifTrue: [scriptedPlayer costume assureExternalName].	aTextMorph := (UpdatingStringMorph new)				useStringFormat;				target: scriptedPlayer;				getSelector: #nameForViewer;				setNameTo: 'name';				font: ScriptingSystem fontForNameEditingInScriptor.	self viewsMorph 		ifTrue: 			[aTextMorph putSelector: #setName:.			aTextMorph setProperty: #okToTextEdit toValue: true].	aTextMorph step.	header addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s name.'.	header beSticky.	anInteger > 0 		ifTrue: 			[headWrapper := AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: 0 @ anInteger.			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse: [self addMorph: header]! !!StandardViewer methodsFor: 'initialization' stamp: 'gm 2/22/2003 13:44'!affordsUniclass	"Answer true iff the receiver operates on behalf of an object that is, or could become, a member of a Uniclass"	| viewee |	^(viewee := self objectViewed) belongsToUniClass or: 			[((viewee isInteger) not and: [viewee isBehavior not]) 				and: [self userLevel > 0]]! !!ViewerEntry methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.985		b: 0.985! !!ViewerEntry methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:07'!initialize"initialize the state of the receiver"	super initialize.""	self layoutInset: 0! !!ViewerFlapTab methodsFor: 'transition' stamp: 'aoy 2/15/2003 21:19'!unhibernate	"recreate my viewer"	| wasShowing viewer |	referent ifNotNil: [(referent findA: Viewer) ifNotNil: [^self]].	wasShowing := flapShowing.	"guard against not-quite-player-players"	viewer := ((scriptedPlayer respondsTo: #costume) 				and: [scriptedPlayer costume isMorph]) 					ifTrue: [self presenter viewMorph: scriptedPlayer costume]					ifFalse: [self presenter viewObjectDirectly: scriptedPlayer]. 	wasShowing ifFalse: [self hideFlap].	^viewer! !!ViewerLine methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.985		b: 0.985! !!ViewerLine methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:32'!initialize	"Initialize the receiver"	super initialize.	""	self layoutInset: 0! !!WatchMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:01'!defaultColor"answer the default color/fill style for the receiver"	^ Color green! !!WatchMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:01'!initialize	"initialize the state of the receiver"	super initialize.	""	self handsColor: Color red.	self centerColor: Color gray.	romanNumerals _ false.	antialias _ false.	fontName _ 'NewYork'.	self extent: 130 @ 130.	self start! !!WaveEditor methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:02'!defaultBorderWidth"answer the default border width for the receiver"	^ 2! !!WaveEditor methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:02'!defaultColor"answer the default color/fill style for the receiver"	^ Color lightGray! !!WaveEditor methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:02'!initialize	"initialize the state of the receiver"	super initialize.	""	samplingRate _ SoundPlayer samplingRate.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.	"zero means unknown"	self extent: 5 @ 5;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 3.	graph _ GraphMorph new extent: 450 @ 100.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.	self		addMorphBack: (Morph				newBounds: (0 @ 0 extent: 0 @ 3)				color: Color transparent).	self addMorphBack: (keyboard _ PianoKeyboardMorph new)! !!WaveEditor methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:59'!chooseLoopStart	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: 			[Utilities informUser: 'Finding possible loop points...'				during: [possibleLoopStarts := self findPossibleLoopStartsFrom: graph cursor]].	bestLoops := possibleLoopStarts copyFrom: 1				to: (100 min: possibleLoopStarts size).	menu := CustomMenu new.	bestLoops do: 			[:entry | 			secs := (loopEnd - entry first) asFloat / self samplingRate roundTo: 0.01.			menu 				add: entry third printString , ' cycles; ' , secs printString , ' secs'				action: entry].	choice := menu startUp.	choice ifNil: [^self].	loopCycles := choice third.	start := self fractionalLoopStartAt: choice first.	self loopLength: loopEnd asFloat - start + 1.0! !!WaveEditor methodsFor: 'menu' stamp: 'gm 2/28/2003 01:12'!makeLoopedSampledSound	| data end snd basePitch |	data := graph data.	snd := (loopEnd = 0 or: [loopLength = 0]) 				ifTrue: 					["save as unlooped"					basePitch := perceivedFrequency = 0 						ifTrue: [100.0]						ifFalse: [perceivedFrequency].					LoopedSampledSound new 						unloopedSamples: data						pitch: basePitch						samplingRate: samplingRate]				ifFalse: 					[end := (loopEnd min: data size) max: 1.					basePitch := samplingRate * loopCycles / loopLength.					LoopedSampledSound new 						samples: data						loopEnd: end						loopLength: loopLength						pitch: basePitch						samplingRate: samplingRate].	snd addReleaseEnvelope.	^snd! !!WaveEditor methodsFor: 'other' stamp: 'dgd 2/22/2003 18:59'!findPossibleLoopStartsFrom: index 	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r := OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart := loopEnd + 1.	"Assumed to be a zero-crossing."	i := self zeroCrossingAfter: postLoopCycleStart 						+ (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength := i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i := self zeroCrossingAfter: postLoopCycleStart 						- (1.1 * postLoopCycleLength) asInteger.	cycleLength := postLoopCycleStart - i.	cycleCount := 1.	[cycleLength > 0] whileTrue: 			[err := self 						autoCorrolationBetween: i						and: postLoopCycleStart						length: postLoopCycleLength.			r add: (Array 						with: i						with: err						with: cycleCount						with: ((loopEnd - i) asFloat / self samplingRate roundTo: 0.01)).			oldI := i.			i := self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.			cycleLength := oldI - i.	"will be zero when start of data is encountered"			cycleCount := cycleCount + 1].	r := r asSortedCollection: [:e1 :e2 | (e1 second) < (e2 second)].	^r asArray! !!WaveEditor methodsFor: 'other' stamp: 'gm 2/27/2003 23:31'!normalize: sampleArray 	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max scale out |	max := 0.	sampleArray do: 			[:s | 			max _ max max: s abs].	scale := ((1 << 15) - 1) asFloat / max.	out := sampleArray species new: sampleArray size.	1 to: sampleArray size		do: [:i | out at: i put: (scale * (sampleArray at: i)) truncated].	^out! !!WebPageMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 23:18'!drawOn: aCanvas 	super drawOn: aCanvas.	image isNil ifFalse: [aCanvas image: image at: bounds origin]! !!WebPageMorph methodsFor: 'model access' stamp: 'dgd 2/21/2003 23:18'!getBg	"Retrieve the current model background color/image"	getBgSelector isNil ifTrue: [^Color white].	^(model perform: getBgSelector) ifNil: [Color white]! !!WebPageMorph methodsFor: 'other' stamp: 'gm 2/22/2003 13:11'!isImage: aForm 	(aForm isForm) ifFalse: [^false].	^true! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'dgd 2/21/2003 23:18'!resetViewBox	| c |	(c := worldState canvas) isNil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0 @ 0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = (self viewBox intersect: parentWorld viewBox) extent 		ifFalse: [^self resetViewBoxForReal]! !!WiWPasteUpMorph methodsFor: 'project state' stamp: 'dgd 2/21/2003 23:18'!viewBox: newViewBox 	| vb |	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	((vb := self viewBox) isNil or: [vb ~= newViewBox]) 		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	bounds := newViewBox.	worldState assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self flag: #arNote.	"Probably unnecessary"	worldState handsDo: [:h | h releaseKeyboardFocus].	self fullRepaintNeeded! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'dgd 2/22/2003 14:38'!resetViewBox	| c |	(c := worldState canvas) isNil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0 @ 0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = self viewBox extent 		ifFalse: [^self resetViewBoxForReal]! !!MVCWiWPasteUpMorph methodsFor: 'project state' stamp: 'dgd 2/22/2003 14:38'!viewBox: newViewBox 	| vb |	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	((vb := self viewBox) isNil or: [vb ~= newViewBox]) 		ifTrue: [worldState canvas: nil].	worldState viewBox: newViewBox.	self bounds: newViewBox.	"works better here than simply storing into bounds"	worldState assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self flag: #arNote.	"Probably unnecessary"	worldState handsDo: [:h | h releaseKeyboardFocus].	self fullRepaintNeeded! !!WireMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/21/2003 22:51'!otherPinFrom: aPin 	^ pins first = aPin ifTrue: [pins second] ifFalse: [pins first]! !!WireMorph methodsFor: 'event handling' stamp: 'dgd 2/21/2003 22:50'!mouseUp: evt 	handles isNil ifTrue: [self addHandles] ifFalse: [self removeHandles]! !!WorldState methodsFor: 'alarms' stamp: 'dgd 2/22/2003 13:31'!removeAlarm: aSelector for: aTarget 	"Remove the alarm with the given selector"	| alarm |	alarm := self alarms 				detect: [:any | any receiver == aTarget and: [any selector == aSelector]]				ifNone: [nil].	alarm isNil ifFalse: [self alarms remove: alarm]! !!WorldState methodsFor: 'canvas' stamp: 'dgd 2/22/2003 13:29'!canvas: x 	canvas := x.	damageRecorder isNil 		ifTrue: [damageRecorder := DamageRecorder new]		ifFalse: [damageRecorder doFullRepaint]! !!WorldState methodsFor: 'object fileIn' stamp: 'dgd 2/22/2003 13:30'!convertStepList	"Convert the old-style step list (an Array of Arrays) into the new-style StepMessage heap"	| newList wakeupTime morphToStep |	(stepList isKindOf: Heap) 		ifTrue: 			[^stepList sortBlock: self stepListSortBlock	"ensure that we have a cleaner block"].	newList := Heap sortBlock: self stepListSortBlock.	stepList do: 			[:entry | 			wakeupTime := entry second.			morphToStep := entry first.			newList add: (StepMessage 						scheduledAt: wakeupTime						stepTime: nil						receiver: morphToStep						selector: #stepAt:						arguments: nil)].	stepList := newList! !!WorldState methodsFor: 'stepping' stamp: 'dgd 2/22/2003 13:31'!runLocalStepMethodsIn: aWorld 	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now morphToStep stepTime priorWorld |	now := Time millisecondClockValue.	priorWorld := ActiveWorld.	ActiveWorld := aWorld.	self triggerAlarmsBefore: now.	stepList isEmpty 		ifTrue: 			[ActiveWorld := priorWorld.			^self].	(now < lastStepTime or: [now - lastStepTime > 5000]) 		ifTrue: [self adjustWakeupTimes: now].	"clock slipped"	[stepList isEmpty not and: [stepList first scheduledTime < now]] 		whileTrue: 			[lastStepMessage := stepList removeFirst.			morphToStep := lastStepMessage receiver.			(morphToStep shouldGetStepsFrom: aWorld) 				ifTrue: 					[lastStepMessage value: now.					lastStepMessage ifNotNil: 							[stepTime := lastStepMessage stepTime ifNil: [morphToStep stepTime].							lastStepMessage scheduledTime: now + (stepTime max: 1).							stepList add: lastStepMessage]].			lastStepMessage := nil].	lastStepTime := now.	ActiveWorld := priorWorld! !!WorldState methodsFor: 'update cycle' stamp: 'dgd 2/22/2003 13:30'!displayWorldSafely: aWorld 	"Update this world's display and keep track of errors during draw methods."	| oldHandler errCtx errMorph |	oldHandler := Processor activeProcess errorHandler.	[aWorld displayWorld] ifError: 			[:err :rcvr | 			"Handle a drawing error"			errCtx := thisContext.						[errCtx := errCtx sender.			"Search the sender chain to find the morph causing the problem"			[errCtx notNil and: [errCtx receiver isMorph not]] 				whileTrue: [errCtx := errCtx sender].			"If we're at the root of the context chain then we have a fatal drawing problem"			errCtx isNil ifTrue: [^self handleFatalDrawingError: err].			errMorph := errCtx receiver.			"If the morph causing the problem has already the #drawError flag set,			then search for the next morph above in the caller chain."			errMorph hasProperty: #errorOnDraw] 					whileTrue.			errMorph setProperty: #errorOnDraw toValue: true.			"Install the old error handler, so we can re-raise the error"			Processor activeProcess errorHandler: oldHandler.			rcvr error: err]! !!WorldState methodsFor: 'update cycle' stamp: 'dgd 2/22/2003 13:31'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect validList |	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort: [:r1 :r2 | r1 area > r2 area].	damageRecorder reset.	n := submorphs size.	morphs := OrderedCollection new: n * 2.	rects := OrderedCollection new: n * 2.	validList := OrderedCollection new: n * 2.	rectList do: 			[:dirtyRect | 			dirtyRect allAreasOutsideList: validList				do: 					[:r | 					"Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."					rectToFill := r.					i := 1.					[rectToFill isNil or: [i > n]] whileFalse: 							[mm := submorphs at: i.							((mm fullBounds intersects: r) and: [mm visible]) 								ifTrue: 									[morphs addLast: mm.									rects addLast: rectToFill.									remnants := mm areasRemainingToFill: rectToFill.									remnants size = 1 ifTrue: [rectToFill := remnants first].									remnants isEmpty ifTrue: [rectToFill := nil]].							i := i + 1].					"Now paint from bottom to top, but using the reduced rectangles."					rectToFill 						ifNotNil: [aWorld drawOn: (c := aCanvas copyClipRect: rectToFill)].					[morphs isEmpty] whileFalse: 							[(rect := rects removeLast) == rectToFill 								ifFalse: [c := aCanvas copyClipRect: (rectToFill := rect)].							c fullDrawMorph: morphs removeLast].					morphs reset.					rects reset.					validList add: r]].	^validList! !!ZASMScriptMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color blue! !!ZASMScriptMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 2! !!ZASMScriptMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!ZASMScriptMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:46'!initialize	"initialize the state of the receiver"	super initialize.	""	somethingChanged _ true.	self dragEnabled: true;		 layoutPolicy: TableLayout new;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 6;				 rubberBandCells: true! !!ZoomAndScrollControllerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color transparent! !!ZoomAndScrollControllerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 0! !!ZoomAndScrollControllerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!ZoomAndScrollControllerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:36'!initialize	"initialize the state of the receiver"	| displayer dataMorph |	super initialize.	""	hasFocus _ true.	currentKeyDown _ Set new.	upDownCodes _ Dictionary new.	upDownCodes at: 126 put: #up;		 at: 125 put: #down;		 at: 123 put: #out;		 at: 124 put: #in.	"arrow keys on the mac"	self extent: 40 @ 40;		 vResizing: #rigid;		 hResizing: #spaceFill;		 setBalloonText: 'Drag in here to zoom, tilt and pan the page above'.	dataMorph _ AlignmentMorph newColumn.	dataMorph color: Color yellow;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	dataMorph		on: #mouseDown		send: #grabCameraPositionEvent:morph:		to: self.	displayer _ UpdatingStringMorph new getSelector: #cameraPointRounded;				 target: self;				 growable: true;				 putSelector: nil.	dataMorph addMorph: displayer lock.	displayer _ UpdatingStringMorph new getSelector: #cameraScale;				 target: self;				 growable: true;				 floatPrecision: 0.001;				 putSelector: nil.	dataMorph addMorph: displayer lock.	self addMorph: dataMorph! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color red! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightGray! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:32'!initialize	"initialize the state of the receiver"	super initialize.	""	usingBalloon _ true.	self createInteriorTransform ! !!ZoomMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!ZoomMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!ZoomMorph removeSelector: #initialize!!ZoomMorph reorganize!('as yet unclassified' zoomFromMorph:toMorph:andThen: zoomTo:)('initialization' defaultColor)('stepping and presenter' step)('testing' stepTime)!!ZoomAndScrollMorph class reorganize!('no messages')!!ZoomAndScrollMorph reorganize!('as yet unclassified' changeOffsetBy: changeOffsetTo: changeScaleTo: changeTiltFactor: changeZoomFactor: getTiltFactor getZoomFactor panImageBy: scaleImageBy: tiltImageBy:)('dropping/grabbing' wantsDroppedMorph:event:)('geometry' extent:)('initialization' createInteriorTransform defaultBorderColor defaultColor initialize)('layout' acceptDroppingMorph:event:)('scripting' cameraPoint cameraPoint: myTransformMorph offsetX offsetX: offsetY offsetY: scale scale:)('stepping and presenter' step)('testing' stepTime)!!ZoomAndScrollControllerMorph class reorganize!('scripting' additionsToViewerCategories)!!ZoomAndScrollControllerMorph reorganize!('as yet unclassified' cameraPoint cameraPoint: cameraPointRounded cameraScale cameraScale: changeKeys currentCameraVersion deadZoneWidth doProgrammedMoves editAScript fractionLeftInMove: grabCameraPositionEvent:morph: patchOldVersion1 pauseProgrammedMoves resumeProgrammedMoves runAScript saveScript:as: setProgrammedMoves: target: targetScriptDictionary turnToPage:position:scale:transition:)('drawing' drawOn:)('event handling' handlesKeyboard: handlesMouseDown: handlesMouseOver: hasFocus keyDown: keyStroke: keyUp: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('menus' addCustomMenuItems:hand:)('stepping and presenter' step)('testing' stepTime)!!ZASMStepsMorph class reorganize!('no messages')!ZASMStepsMorph removeSelector: #defaultColor!ZASMStepsMorph removeSelector: #initialize!!ZASMStepsMorph reorganize!('as yet unclassified' getStepCount setStepCount:)('event handling' handlesMouseDown: mouseDown:)!!ZASMScriptMorph class reorganize!('no messages')!!ZASMScriptMorph reorganize!('as yet unclassified' compileScript decompileScript:named:for: fixup saveScript)('dropping/grabbing' wantsDroppedMorph:event:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('layout' acceptDroppingMorph:event: layoutChanged)('menus' addCustomMenuItems:hand:)('stepping and presenter' step)('testing' stepTime wantsSteps)!!ZASMCameraMarkMorph class reorganize!('no messages')!ZASMCameraMarkMorph removeSelector: #initialize!ZASMCameraMarkMorph removeSelector: #resetFrom:!!ZASMCameraMarkMorph reorganize!('as yet unclassified' cameraController cameraPoint:cameraScale:controller: cameraPoint:cameraScale:controller:page: gotoMark menuPageVisualFor:event: setCameraValues setTransition:)('copying' veryDeepCopyWith:)('dropping/grabbing' justDroppedInto:event:)('event handling' handlesMouseDown: mouseDown: mouseUp:)('menu' setTransition)('menus' addCustomMenuItems:hand:)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: pauseFrom: resumeFrom:)!!WorldWindow class reorganize!('as yet unclassified' test1 test2)!!WorldWindow reorganize!('event handling' mouseUp:)('geometry' extent:)('initialization' openInWorld:)('layout' fullBounds)('menu' buildWindowMenu)('resize/collapse' collapseOrExpand)!!CautiousModel class reorganize!('no messages')!!WorldViewModel class reorganize!('no messages')!!CautiousModel reorganize!('updating' okToChange)!!WorldViewModel reorganize!('as yet unclassified' initialExtent:)('user interface' fullScreenSize initialExtent)!!WorldState class reorganize!('accessing' classVersion)('as yet unclassified' canSurrenderToOS: lastCycleTime)('class initialization' addDeferredUIMessage: deferredUIMessages initialize)('instance creation' new)!!WorldState reorganize!('Nebraska support' addRemoteCanvas: assuredRemoteCanvas releaseRemoteServer remoteCanvasesDo: remoteServer remoteServer: removeRemoteCanvas:)('alarms' addAlarm:withArguments:for:at: adjustAlarmTimes: alarmSortBlock alarms removeAlarm:for: triggerAlarmsBefore:)('canvas' assuredCanvas canvas canvas: doFullRepaint recordDamagedRect: resetDamageRecorder viewBox viewBox:)('hands' activeHand activeHand: addHand: hands handsDo: handsReverseDo: removeHand: selectHandsToDrawForDamage:)('initialization' initialize stepListSize stepListSortBlock stepListSummary)('object fileIn' convertAlarms convertStepList)('objects from disk' convertToCurrentVersion:refStream:)('stepping' adjustWakeupTimes: adjustWakeupTimesIfNecessary cleanseStepListForWorld: isStepping: isStepping:selector: listOfSteppingMorphs runLocalStepMethodsIn: runStepMethodsIn: startStepping:at:selector:arguments:stepTime: stopStepping: stopStepping:selector:)('undo' commandHistory)('undo support' clearCommandHistory)('update cycle' checkIfUpdateNeeded displayWorld:submorphs: displayWorldAsTwoTone:submorphs:color: displayWorldSafely: doDeferredUpdatingFor: doOneCycleFor: doOneCycleInBackground doOneCycleNowFor: doOneSubCycleFor: drawWorld:submorphs:invalidAreasOn: forceDamageToScreen: handleFatalDrawingError: interCyclePause: startBackgroundProcess)!!WireMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!WireMorph reorganize!('as yet unclassified' fromPin:toPin: otherPinFrom: pinMoved)('editing' addHandles)('event handling' handlesMouseDown: mouseUp:)('submorphs-add/remove' delete)!!WindowColorSpec class reorganize!('instance creation' classSymbol:wording:brightColor:pastelColor:helpMessage:)!!WindowColorSpec reorganize!('access' brightColor classSymbol helpMessage pastelColor wording)('initialization' classSymbol:wording:brightColor:pastelColor:helpMessage:)('printing' printOn:)!!MVCWiWPasteUpMorph class reorganize!('no messages')!!WiWPasteUpMorph class reorganize!('as yet unclassified' say: show)!!MVCWiWPasteUpMorph reorganize!('activation' becomeTheActiveWorldWith: revertToParentWorldWithEvent:)('as yet unclassified' worldUnderCursor)('change reporting' invalidRect:from:)('geometry' position: resetViewBox resetViewBoxForReal)('project' project)('project state' viewBox:)!WiWPasteUpMorph removeSelector: #runStepMethods!!WiWPasteUpMorph reorganize!('WiW support' restartWorldCycleWithEvent: validateMouseEvent:)('activation' becomeTheActiveWorldWith: revertToParentWorldWithEvent:)('event handling' mouseDown:)('geometry' extent: resetViewBox resetViewBoxForReal)('initialization' hostWindow: initialize)('project state' viewBox:)('update cycle' doDeferredUpdating)('world state' displayWorld doOneCycle goBack jumpToProject restoreDisplay)!!WeekMorph class reorganize!('instance creation' newWeek:month:tileRect:model: on:)('new-morph participation' includeInNewMorphMenu)!!WeekMorph reorganize!('all' initializeDays: initializeForWeek:month:tileRect:model: next selectedDates tile tileLabeled: title week:month:model:)('initialization' initialize)!!WebPageMorph class reorganize!('instance creation' on:bg:text:readSelection:menu:)!!WebPageMorph reorganize!('drawing' drawOn:)('initialization' on:bg:text:readSelection:menu:)('layout' layoutChanged)('model access' getBg)('other' drawImage: isImage:)('updating' update:)!!WaveEditor class reorganize!('instance creation' openOn:)('parts bin' descriptionForPartsBin)!!WaveEditor reorganize!('accessing' data: graph loopCycles loopCycles: loopEnd loopEnd: loopLength loopLength: loopStart loopStart: perceivedFrequency perceivedFrequency: samplingRate samplingRate:)('initialization' addControls addLoopPointControls defaultBorderWidth defaultColor initialize)('menu' chooseLoopStart invokeMenu jumpToLoopEnd jumpToLoopStart makeLoopedSampledSound play playAfterCursor playBeforeCursor playFrom:to: playLoop playTestNote saveInstrument setLoopEnd setLoopStart setOneCycle setUnlooped setUnpitched showEnvelope showFFTAtCursor trimAfterCursor trimBeforeCursor)('other' autoCorrolationBetween:and:length: errorBetween:and: findPossibleLoopStartsFrom: fractionalLoopStartAt: interpolatedWindowAt:width: normalize: scrollTime: stretch:by: zeroCrossingAfter:)('stepping and presenter' step)!!PDAClockMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!WatchMorph class reorganize!('as yet unclassified' fontName:bgColor:centerColor:)('parts bin' descriptionForPartsBin)!!PDAClockMorph reorganize!('accessing' color color:)('as yet unclassified' faceColor:)('drawing' drawOn:)!!WatchMorph reorganize!('accessing' antialias: centerColor: fontName: handsColor:)('drawing' drawOn:)('geometry' extent:)('initialization' defaultColor initialize)('labels' createLabels)('menus' addCustomMenuItems:hand: antiAliasString changeCenterColor changeFont changeHandsColor romanNumeralString toggleAntialias toggleRoman)('stepping and presenter' step)('private' radius:hourAngle:)!!ViewerRow class reorganize!('no messages')!!ViewerRow reorganize!('access' elementSymbol elementSymbol: entryType playerBearingCode)('initialization' initialize)!!ViewerLine class reorganize!('no messages')!!ViewerLine reorganize!('access' elementSymbol elementSymbol: entryType)('initialization' defaultColor initialize)('slot' slotName)!!ViewerFlapTab class reorganize!('new-morph participation' includeInNewMorphMenu)('printing' defaultNameStemForInstances)!!ViewerFlapTab reorganize!('access' scriptedPlayer)('accessing' isCurrentlyGraphical)('compact' changeCompactFlap compactFlapString isFlapCompact makeFlapCompact:)('menu' graphicalMorphForTab)('menus' addCustomMenuItems:hand:)('submorphs-accessing' allNonSubmorphMorphs)('transition' hibernate initializeFor:topAt: unhibernate)!!ViewerEntry class reorganize!('no messages')!!ViewerEntry reorganize!('access' entryType playerBearingCode viewerRow)('contents' contents:notifying: contentsSelection)('initialization' defaultColor initialize)('menu' codePaneMenu:shifted:)('slot' slotName userSlotInformation)!!StandardViewer class reorganize!('no messages')!!SearchingViewer class reorganize!('no messages')!!CategoryViewer class reorganize!('no messages')!!Viewer class reorganize!('no messages')!!StandardViewer reorganize!('categories' addCategoryViewer addCategoryViewerFor: addCategoryViewerFor:atEnd: addSearchPane categoriesCurrentlyShowing categoryMorphs categoryViewerFor: chooseLimitClass likelyCategoryToShow limitClass limitClass: outerViewer recreateCategories setLimitClass: symbolsOfCategoriesCurrentlyShowing)('classification' isStandardViewer)('debug and other' viewMorphDirectly)('initialization' addHeaderMorphWithBarHeight:includeDismissButton: affordsUniclass fitFlap initialHeightToAllow initializeFor:barHeight: initializeFor:barHeight:includeDismissButton: initializeFor:barHeight:includeDismissButton:showCategories: rawVocabulary: switchToVocabulary: useVocabulary: userLevel viewsMorph)('macpal' currentVocabulary)('user interface' dismiss downArrowHit hasDismissButton openLexicon relaunchViewer standardViewerColor upArrowHit)!!SearchingViewer reorganize!('categories' categoryWording: currentCategory updateCategoryNameTo:)('header pane' addNamePaneTo: maybeAddArrowsTo:)('initialization' establishContents initializeFor:categoryChoice: setCategorySymbolFrom:)('search' doSearchFrom: rawSearchString: searchString searchString:notifying:)('support' categoryRestorationInfo)!!CategoryViewer reorganize!('categories' adjustColorsAndBordersWithin beReplacedByCategory: categoryNameWhoseTranslatedWordingIs: categoryWhoseTranslatedWordingIs: categoryWording: chooseCategory chooseCategoryWhoseTranslatedWordingIs: chosenCategorySymbol chosenCategorySymbol: currentCategory downArrowHit nextCategory previousCategory secreteCategorySymbol showCategoriesFor: upArrowHit updateCategoryNameTo:)('e-toy support' adoptVocabulary: setNaturalLanguageTo:)('editing pane' contents:notifying:)('entries' addIsOverColorDetailTo: addOverlapsDetailTo: addTouchesADetailTo: infoButtonFor: phraseForCommandFrom: phraseForVariableFrom: readoutFor:type:readOnly:getSelector:putSelector: wantsRowMenuFor:)('get/set slots' arrowSetterButton:args: arrowSetterButtonFor:type: getterButtonFor:type: getterTilesFor:type: makeGetter:event:from: makeGetter:from:forPart: makeSetter:event:from: makeSetter:from:forPart: makeUniversalTilesGetter:event:from: newGetterTilesFor:methodInterface: newMakeGetter:event:from: newMakeGetter:from:forMethodInterface: newMakeGetter:from:forPart: newMakeSetter:event:from: newMakeSetter:from:forPart: newMakeSetterFromInterface:evt:from: newSetterTilesFor:methodInterface: newTilesFor:setter:)('header pane' addHeaderMorph addNamePaneTo: maybeAddArrowsTo:)('initialization' establishContents initializeFor: initializeFor:categoryChoice: setCategorySymbolFrom:)('macpal' currentVocabulary)('scripting' isTileScriptingElement)('support' booleanPhraseForRetrieverOfType:retrieverOp:player: booleanPhraseFromPhrase: categoryRestorationInfo contentsSelection invisiblySetPlayer: limitClass outerViewer tileForSelf)!!Viewer reorganize!('access' scriptedPlayer scriptedPlayer:)('commands' chooseVocabulary newPermanentScript nextCostume previousCostume)('copying' veryDeepFixupWith: veryDeepInner:)('dropping/grabbing' repelsMorph:event: wantsToBeDroppedInto:)('e-toy support' isAViewer isCandidateForAutomaticViewing objectViewed)('initialization' initialize)('queries' aboutMethod: browseImplementorsOf: browseMethodFull: browseMethodInheritance: browseSendersOf: browseVersionsOf:)('special phrases' colorSeesPhrase overlapsPhrase seesColorPhrase touchesAPhrase)('transition' noteDeletionOf: retargetFrom:to:)!!VeryPickyMorph class reorganize!('no messages')!!VeryPickyMorph reorganize!('as yet unclassified' passengerMorph:)('converting' complexContents)('drawing' drawOn:)('dropping/grabbing' justDroppedInto:event:)('initialization' initialize)('submorphs-add/remove' delete)!!VariableDock class reorganize!('no messages')!!VariableDock reorganize!('accessing' definingMorph playerGetSelector type)('getters and setters' computePlayerGetterAndSetterSelectors)('initialization' dockMorphUpToInstance: storeMorphDataInInstance: variableName:type:definingMorph:morphGetSelector:morphPutSelector:)('name' variableName variableName:)('printing' printOn:)('type and default value' variableType)!!UserScript class reorganize!('no messages')!!UserScript reorganize!('script editor' allScriptVersionsDo: bringUpToDate currentScriptEditor currentScriptEditor: formerScriptEditors instantiatedScriptEditor releaseCachedState)('textually coded' becomeTextuallyCoded isTextuallyCoded)('updating' updateToPlayer:)('versions' recreateScriptFrom: revertScriptVersionFrom: revertScriptVersionFrom:installing: revertToLastSavedTileVersionFor: saveScriptVersion: savedTileVersionsCount)!!MouseMoveEvent class reorganize!('no messages')!!MouseButtonEvent class reorganize!('no messages')!!MouseEvent class reorganize!('no messages')!!KeyboardEvent class reorganize!('no messages')!!UserInputEvent class reorganize!('no messages')!!MouseMoveEvent reorganize!('accessing' endPoint startPoint trail)('comparing' = hash)('dispatching' sentTo:)('encoding' decodeFromStringArray: encodedAsStringArray)('initialize' type:readFrom:)('printing' printOn: storeOn:)('testing' isMove)('transforming' transformBy: translateBy:)('private' setType:startPoint:endPoint:trail:buttons:hand:stamp:)!!MouseButtonEvent reorganize!('accessing' blueButtonChanged redButtonChanged yellowButtonChanged)('dispatching' sentTo:)('encoding' decodeFromStringArray: encodedAsStringArray)('genie' addMouseButtons: toggleMouseButtons:)('initialize' type:readFrom:)('printing' storeOn:)('private' setType:position:which:buttons:hand:stamp:)!MouseEvent removeSelector: #position!!MouseEvent reorganize!('accessing' cursorPoint noticeMouseOver:)('button state' anyButtonPressed blueButtonPressed redButtonPressed targetPoint yellowButtonPressed)('comparing' = hash)('converting' asMouseEnter asMouseLeave asMouseMove asMouseOver)('dispatching' sentTo:)('genie' addMouseButtons: toggleBlueButton toggleMouseButtons: toggleRedButton toggleYellowButton)('initialize' type:readFrom:)('printing' printOn: storeOn:)('testing' isDraggingEvent isMouse isMouseDown isMouseEnter isMouseLeave isMouseMove isMouseUp isMove)('private' setType: setType:position:buttons:hand:)!!KeyboardEvent reorganize!('comparing' = hash)('dispatching' sentTo:)('encoding' decodeFromStringArray: encodedAsStringArray)('initialize' type:readFrom:)('keyboard' keyCharacter keyValue)('printing' printOn: storeOn:)('testing' isKeyDown isKeyUp isKeyboard isKeystroke isMouseMove)('private' setType:buttons:position:keyValue:hand:stamp:)!!UserInputEvent reorganize!('accessing' buttons handler handler: position type wasHandled wasHandled:)('encoding' encodedAsStringArray)('genie' addButtons: toggleButtons: toggleCommandKey toggleControlKey toggleMacOptionKey toggleShift)('initialize' copyHandlerState: resetHandlerFields)('modifier state' anyModifierKeyPressed commandKeyPressed controlKeyPressed macOptionKeyPressed shiftPressed)('printing' buttonString modifierString)('transforming' transformBy: transformedBy: translateBy: translatedBy:)('private' setPosition:)!!EtoyUpdatingThreePhaseButtonMorph class reorganize!('as yet unclassified' setForms)('instance creation' checkBox)!!UpdatingThreePhaseButtonMorph class reorganize!('no messages')!!EtoyUpdatingThreePhaseButtonMorph reorganize!('stepping and presenter' step)!!UpdatingThreePhaseButtonMorph reorganize!('as yet unclassified' getSelector:)('button' doButtonAction)('event handling' mouseUp:)('stepping and presenter' step)('testing' wantsSteps)!!UpdatingStringMorphWithArgument class reorganize!('no messages')!!UpdatingStringMorphWithArgument reorganize!('as yet unclassified' argumentTarget:argumentGetSelector:)('copying' veryDeepFixupWith: veryDeepInner:)('target access' readFromTarget)!!UpdatingNumericStringMorph class reorganize!('no messages')!!UpdatingBooleanStringMorph class reorganize!('no messages')!!SyntaxUpdatingStringMorph class reorganize!('no messages')!!NameStringInHalo class reorganize!('no messages')!!UpdatingStringMorph class reorganize!('instance creation' on:selector:)!!UpdatingNumericStringMorph reorganize!('accessing' max max: min min:)('target access' acceptValueFromTarget:)!!UpdatingBooleanStringMorph reorganize!('event handling' handlesMouseDown: mouseDown: mouseUp:)('target access' informTarget)!!SyntaxUpdatingStringMorph reorganize!('drawing' drawOn:)!!NameStringInHalo reorganize!('accessing' interimContents:)('as yet unclassified' placeContents)('drawing' drawOn:)('editing' cancelEdits)!!UpdatingStringMorph reorganize!('accessing' autoAcceptOnFocusLoss autoAcceptOnFocusLoss: contents: decimalPlaces decimalPlaces: fitContents floatPrecision floatPrecision: format getSelector getSelector: growable growable: maximumWidth minimumWidth minimumWidth: putSelector putSelector: pvtFloatPrecision: target target: valueFromContents)('card & stack' setNewContentsFrom:)('card in a stack' couldHoldSeparateDataForEachInstance)('copying' veryDeepFixupWith: veryDeepInner:)('editing' acceptContents acceptValue: doneWithEdits lostFocusWithoutAccepting setDecimalPlaces: setFontSize setFontStyle setPrecision setToAllowTextEdit toggleGrowability userEditsAllowed)('event handling' handlesMouseDown: mouseDown: wouldAcceptKeyboardFocus)('events-processing' handlerForMouseDown:)('formats' useDefaultFormat useStringFormat)('initialization' initialize)('menus' addCustomMenuItems:hand: putOnBackground)('player' currentDataValue variableDocks)('stepping' stepTime: updateContentsFrom:)('stepping and presenter' step)('target access' acceptValueFromTarget: checkTarget informTarget readFromTarget setDecimalPlacesFromTypeIn:)('testing' stepTime)!!ScriptableButton class reorganize!('parts bin' descriptionForPartsBin)('printing' defaultNameStemForInstances)('scripting' additionsToViewerCategories authoringPrototype)!!UpdatingSimpleButtonMorph class reorganize!('no messages')!!ScriptableButton reorganize!('accessing' label label: label:font: scriptSelector scriptSelector:)('button' doButtonAction)('halos and balloon help' wantsScriptorHaloHandle)('menu' setLabel)('parts bin' initializeToStandAlone)('script' editButtonsScript)('thumbnail' demandsThumbnailing)!!UpdatingSimpleButtonMorph reorganize!('as yet unclassified' wordingSelector:)('stepping and presenter' step)('testing' stepTime wantsSteps)!!ColorSwatch class reorganize!('no messages')!!UpdatingRectangleMorph class reorganize!('no messages')!!ColorSwatch reorganize!('as yet unclassified' argument:)('setting' setTargetColor:)('target access' readFromTarget)('testing' stepTime)!UpdatingRectangleMorph removeSelector: #initialize!!UpdatingRectangleMorph reorganize!('accessing' contents contents: getSelector: putSelector putSelector: target target: userEditsAllowed)('copying' veryDeepFixupWith: veryDeepInner:)('event handling' handlesMouseDown: mouseUp:)('initialization' defaultBorderColor)('setting' setTargetColor: valueProvider)('stepping and presenter' step)('target access' readFromTarget)('testing' stepTime)!!UpdatingMenuMorph class reorganize!('no messages')!!UpdatingMenuMorph reorganize!('initialization' updater:updateSelector:)('update' updateMenu)!!UpdatingMenuItemMorph class reorganize!('no messages')!!UpdatingMenuItemMorph reorganize!('e-toy support' adaptToWorld:)('enablement' enablement enablementSelector:)('stepping and presenter' arrangeToStartSteppingIn: step)('testing' stepTime)('wording' wordingArgument: wordingProvider:wordingSelector:)('world' updateContents)!!UnscriptedCardPlayer class reorganize!('no messages')!!UnscriptedPlayer class reorganize!('compiling' acceptsLoggingOfCompilation wantsChangeSetLogging)('instance creation' isUniClass newUserInstance)('namespace' referenceSelectorFor:)('reference' ephemeralPlayerRef)('testing' isSystemDefined officialClass)!!UnscriptedCardPlayer reorganize!('uniclass' rootClassForUniclasses)!!UnscriptedPlayer reorganize!('copying' copyUniClassWith:)('slots-user' hasUserDefinedScripts)('testing' wantsSteps)('uniclass' rootClassForUniclasses)('viewer' assureUniClass belongsToUniClass hasUserDefinedSlots)!!UniclassScript class reorganize!('no messages')!UniclassScript removeSelector: #okayToRename!!UniclassScript reorganize!('initialization' convertFromUserScript: initialize isTextuallyCoded playerClass:selector:)('initialize-release' releaseCachedState)('script editor' currentScriptEditor: currentScriptEditorDo: instantiatedScriptEditorForPlayer: recompileScriptFromTilesUnlessTextuallyCoded)('textually coded' becomeTextuallyCoded lastSourceString)('updating' bringUpToDate revertToLastSavedTileVersionFor: saveScriptVersion:)('versions' recreateScriptFrom: revertScriptVersionFrom: savedTileVersionsCount)!!UndescribedTile class reorganize!('no messages')!!UndescribedTile reorganize!('initialization' initialize)!!URLMorph class reorganize!('instance creation' grabForBook: grabURL: newBookmarkForURL: newForURL:)!!URLMorph reorganize!('accessing' book book: isBookmark isBookmark: page url)('drawing' drawOn:)('event handling' handlesMouseDown: handlesMouseUp: mouseDown: mouseUp:)('initialization' defaultColor initialize)('updating' pageHasChanged:)('private' enclosingBook enclosingPage label:font: setURL:page: thumbnailOrNil)!!TypeListTile class reorganize!('no messages')!!TypeListTile reorganize!('arrows' addMenuIcon arrowAction: showSuffixChoices)('initialization' initialize)('menus' addCustomMenuItems:hand:)('user interface' acceptNewLiteral: adjustHelpMessage)!!PluggableTileScriptorMorph class reorganize!('no messages')!!TwoWayScrollPane class reorganize!('new-morph participation' includeInNewMorphMenu)!!PluggableTileScriptorMorph reorganize!('as yet unclassified' syntaxMorph)('event handling' keyStroke:)('updating' update:)!TwoWayScrollPane removeSelector: #addCustomMenuItems:hand:!!TwoWayScrollPane reorganize!('access' scroller wantsSlot)('accessing' colorForInsets)('event handling' handlesMouseDown: handlesMouseOver: keyStroke: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp:)('events-processing' rejectsEvent:)('geometry' extent: fitContents leftoverScrollRange resizeScrollBar resizeScroller scrollBarFills: scrollBy: scrollIntoView:extra: setScrollDeltas totalScrollRange)('geometry testing' containsPoint:)('initialization' createScrollBarNamed: createScroller defaultBorderColor initialize)('layout' doLayoutIn:)('menu' getMenu: leftOrRight menuTitleSelector: retractableOrNot scrollBarOnLeft:)('retractable scroll bar' hideOrShowScrollBar hideOrShowScrollBar:forRange: xScrollerHeight)('scroll bar events' scrollBarMenuButtonPressed: shiftedYellowButtonActivity unshiftedYellowButtonActivity xScrollBarMenuButtonPressed: xScrollBarValue: yScrollBarMenuButtonPressed: yScrollBarValue: yellowButtonActivity:)!!TrashCanMorph class reorganize!('as yet unclassified' playDeleteSound playMouseEnterSound playMouseLeaveSound samplesForDelete samplesForMouseEnter samplesForMouseLeave)('miscellaneous' moveToTrash:)('parts bin' descriptionForPartsBin)!!TrashCanMorph reorganize!('dropping/grabbing' wantsDroppedMorph:event:)('event handling' doubleClick: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: startDrag:)('initialization' initialize)('layout' acceptDroppingMorph:event:)('parts bin' initializeToStandAlone)('printing' printOn:)('private' findActivePaintBox showStampIn: stopShowingStampIn:)!!TranslucentProgessMorph class reorganize!('no messages')!!TranslucentProgessMorph reorganize!('WiW support' morphicLayerNumber)('as yet unclassified' opaqueBackgroundColor: revealingStyle)('drawing' drawOn:)!!TransitionMorph class reorganize!('available effects' allEffects directionsForEffect:)('initialization' effect:direction: effect:direction:inverse:)('new-morph participation' includeInNewMorphMenu)!!TransitionMorph reorganize!('change reporting' invalidate:areasOutside:)('drawing' areasRemainingToFill: drawDissolveOn: drawFrenchDoorOn: drawOn: drawPageBackOn: drawPageForwardOn: drawSlideAwayOn: drawSlideBorderOn: drawSlideBothOn: drawSlideOverOn: drawZoomFrameOn: drawZoomOn:)('initialization' completeReplacement initiateReplacement nSteps:stepTime: showTransitionFrom:to:in:whenStart:whenDone: startMorph:endMorph:startBlock:completionBlock:)('stepping and presenter' step)('testing' stepTime)('updating' changed)('private' effect:direction: prevStepFrom:to: stepFrom:to:)!!TransformationB2Morph class reorganize!('no messages')!!BOBTransformationMorph class reorganize!('no messages')!!TransformationMorph class reorganize!('no messages')!!TransformationB2Morph reorganize!('as yet unclassified' useRegularWarpBlt:)('drawing' drawSubmorphsOn:)('geometry' computeBounds extent:)('private' adjustAfter:)!!BOBTransformationMorph reorganize!('as yet unclassified' changeWorldBoundsToShow: drawSubmorphsOnREAL: extentFromParent: recomputeExtent useRegularWarpBlt:)('drawing' drawSubmorphsOn:)('geometry' extent:)('layout' layoutChanged)('private' adjustAfter:)!!TransformationMorph reorganize!('accessing' forwardDirection hasNoScaleOrRotation rotationDegrees: scaleFactor scaleToMatch:)('classification' isFlexMorph isRenderer)('drawing' drawOn:)('dropping/grabbing' grabTransform)('geometry' computeBounds extent: transformedBy:)('geometry eToy' degreesOfFlex forwardDirection: heading heading: referencePosition setDirectionFrom:)('initialization' asFlexOf: flexing:byTransformation:)('layout' layoutChanged)('menu' removeFlexShell)('naming' innocuousName)('printing' printOn:)('rotate scale and flex' rotationDegrees)('submorphs-add/remove' replaceSubmorph:by:)('testing' stepTime)('private' adjustAfter: chooseSmoothing)!!FlashSorterMorph class reorganize!('no messages')!!TransformMorph class reorganize!('no messages')!FlashSorterMorph removeSelector: #initialize!!FlashSorterMorph reorganize!('editing' makeMovie)('geometry' extent:)('initialization' addThumbnails: defaultColor makeControls on: openInWindow)('interaction' mouseDown:onItem: mouseStillDown:onItem: mouseUp:onItem:)('layout' doLayout)!!TransformMorph reorganize!('accessing' angle angle: colorForInsets offset offset: scale scale: setOffset:angle:scale: smoothing: smoothingOff smoothingOn transform transform:)('change reporting' invalidRect:from:)('drawing' drawSubmorphsOn:)('dropping/grabbing' grabTransform)('event handling' transformFrom:)('geometry' localSubmorphBounds localVisibleSubmorphBounds)('geometry testing' containsPoint:)('halos and balloon help' wantsHaloFromClick)('initialization' defaultColor initialize)('layout' fullBounds submorphBounds)('menus' addCustomMenuItems:hand:)('private' privateFullMoveBy:)!!TransferMorphLineAnimation class reorganize!('no messages')!!TransferMorphLineAnimation reorganize!('initialization' initPolygon on:)('update' updateAnimation)!!TransferMorphAnimation class reorganize!('instance creation' on:)!!TransferMorphAnimation reorganize!('accessing' transferMorph)('initialization' on:)('update' updateAnimation)('updating' update:)!!TransferMorph class reorganize!('class initialization' initIcons initialize)('instance creation' withPassenger: withPassenger:from:)!!TransferMorph reorganize!('accessing' dragTransferType: draggedMorph draggedMorph: dropNotifyRecipient dropNotifyRecipient: move passenger passenger: source source:)('copying' copy)('drag and drop' dragTransferType)('dropping/grabbing' aboutToBeGrabbedBy: justDroppedInto:event: result: result:from: undoGrabCommand)('initialization' defaultColor initialize)('submorphs-add/remove' delete)('testing' shouldCopy)('private' animationForMoveSuccess: initDraggedMorph privateFullMoveBy:)!!TinyPaint class reorganize!('no messages')!!TinyPaint reorganize!('event handling' handlesMouseDown: mouseDown: mouseMove:)('initialization' defaultColor initialize)('menu' brushColor: clear fill setPenColor: setPenSize)('menus' addCustomMenuItems:hand:)!!TilePadMorph class reorganize!('color' colorFudge)!!TilePadMorph reorganize!('code generation' storeCodeOn:indent:)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' handlesMouseOverDragging: mouseEnterDragging: mouseLeaveDragging:)('layout' acceptDroppingMorph:event:)('menus' addCustomMenuItems:hand:)('miscellaneous' basicWidth isColorConstant: isOutsideRef: lastTile restoreDefaultTile setToBearDefaultLiteral setType: type)('mouse' canAccept: prepareToUndoDropOf:)('printing' printOn:)!!SymbolListTile class reorganize!('no messages')!!SoundReadoutTile class reorganize!('no messages')!!StringReadoutTile class reorganize!('no messages')!!SoundTile class reorganize!('no messages')!!RandomNumberTile class reorganize!('no messages')!!ParameterTile class reorganize!('no messages')!!NumericReadoutTile class reorganize!('instance creation' borderedPrototype simplePrototype)('parts bin' supplementaryPartsDescriptions)('scripting' authoringPrototype)!!MenuTile class reorganize!('no messages')!!GraphicTile class reorganize!('no messages')!!ColorSeerTile class reorganize!('no messages')!!ColorTileMorph class reorganize!('no messages')!!BooleanTile class reorganize!('no messages')!!AssignmentTileMorph class reorganize!('no messages')!!TileMorph class reorganize!('class initialization' downPicture fixCaretForms initialize readInArrowGraphics upPicture)('constants' defaultH)!!SymbolListTile reorganize!('accessing' literal:)('arrows' arrowAction:)('event handling' handlesMouseDown: mouseStillDown: wantsKeyboardFocusFor:)('events-processing' mouseDownPriority)('initialization' choices:dataType: initialize)('misc' setLiteralInitially:)('player viewer' updateLiteralLabel)('user interface' acceptNewLiteral: adjustHelpMessage offerAllChoicesInAPopUp)('private' line1:)!!SoundReadoutTile reorganize!('arrows' arrowAction:)('literal' setLiteralTo:width:)!!StringReadoutTile reorganize!('accessing' literal:)('literal' setLiteralTo:width:)('misc' basicWidth)!!SoundTile reorganize!('access' sound)('accessing' resultType)('event handling' mouseDown: mouseMove: wantsKeyboardFocusFor:)('initialization' initialize)!!RandomNumberTile reorganize!('accessing' labelMorph)('code generation' storeCodeOn:indent:)('event handling' handlesMouseDown:)('initialization' initialize)('misc' numericValue)('player viewer' updateLiteralLabel)!!ParameterTile reorganize!('access' scriptEditor)('accessing' resultType)('code generation' storeCodeOn:indent:)('initialization' forScriptEditor: initialize)('type' assureTypeStillValid)!NumericReadoutTile removeSelector: #handlesMouseStillDown:!!NumericReadoutTile reorganize!('accessing' abandonLabelFocus literal:)('event handling' mouseDown: mouseStillDown:)('literal' setLiteralTo:width:)('misc' basicWidth minimumWidth)('mouse' handlesMouseMove:)('parts bin' initializeToStandAlone)('testing' basicType)!!MenuTile reorganize!('accessing' resultType)('arrows' arrowAction:)('event handling' handlesMouseDown: mouseDown:)('events-processing' handlerForMouseDown: mouseDownPriority)('initialization' initialize)!!GraphicTile reorganize!('accessing' resultType)('code generation' storeCodeOn:indent:)('initialization' initialize setLiteral: useForm:)!ColorSeerTile removeSelector: #updateLiteralLabel!!ColorSeerTile reorganize!('code generation' storeCodeOn:indent:)('initialization' initialize updateWordingToMatchVocabulary)!!ColorTileMorph reorganize!('accessing' resultType)('code generation' storeCodeOn:indent:)('event handling' handlesMouseDown: mouseDown: mouseUp:)('initialization' initialize setLiteral:)('other' addColorSwatch colorSwatch colorSwatchColor:)('player viewer' updateLiteralLabel)!!BooleanTile reorganize!('accessing' resultType)!!AssignmentTileMorph reorganize!('arrow' addArrowsIfAppropriate)('arrows' arrowAction:)('code generation' assignmentReceiverTile operatorForAssignmentSuffix: storeCodeOn:indent:)('initialization' computeOperatorOrExpression initialize setAssignmentSuffix: setRoot:dataType: updateWordingToMatchVocabulary)('player viewer' updateLiteralLabel)!!TileMorph reorganize!('accessing' abandonLabelFocus associatedPlayer labelMorph lastTile literal literal: operatorOrExpression playerBearingCode resultType slotName type)('arrows' addArrows addRetractArrow addSuffixArrow addSuffixIfCan arrowAction: couldRetract deleteLastTwoTiles deleteSuffixArrow showSuffixChoices variableDelay:)('change reporting' colorChangedForSubmorph: ownerChanged)('code generation' acceptNewLiteral codeString precedingTileType scriptEdited storeCodeOn:indent:)('copying' veryDeepFixupWith: veryDeepInner:)('dropping/grabbing' justGrabbedFrom:)('e-toy support' adoptVocabulary: isCandidateForAutomaticViewing setNaturalLanguageTo:)('event handling' handlesMouseDown: handlesMouseStillDown: mouseDown: mouseStillDown: wantsKeyboardFocusFor:)('events-processing' handlerForMouseDown:)('initialization' actualObject bePossessive defaultBorderWidth initialize isPossessive rawVocabulary: referTo: retargetFrom:to: setExpression:label: setLiteral: setOperator: setOperator:andUseWording: setOperatorAndUseArrows: setSlotRefOperator: setToReferTo: updateWordingToMatchVocabulary)('macpal' currentVocabulary scriptPerformer)('menus' addCustomMenuItems:hand:)('misc' basicWidth currentEToyVocabulary handReferentMorph minimumWidth numericValue setLiteralInitially: typeColor:)('mouse handling' arrowDelta presentOperatorAlternatives:)('player viewer' updateLiteralLabel)('printing' printOn:)('scripting' bringUpToDate isTileLike isTileScriptingElement restoreTypeColor useUniformTileColor)('tiles from method' selectorTile:in:)('private' convertAlignment line1: test)!!TileMessageNode class reorganize!('no messages')!!TileMessageNode reorganize!('printing' printIfNilNotNil:indent: printIfOn:indent: printKeywords:arguments:on:indent: printReceiver:on:indent: printToDoOn:indent: printWhileOn:indent:)!!SystemQueryPhrase class reorganize!('no messages')!!PhraseTileMorph class reorganize!('backward compatibility' markViewerOrigination)!!CompoundTileMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!CommandTilesMorph class reorganize!('no messages')!!TileLikeMorph class reorganize!('no messages')!!SystemQueryPhrase reorganize!('code generation' storeCodeOn:indent:)('initialization' initialize)('miscellaneous' actualObject associatedPlayer)!!PhraseTileMorph reorganize!('all' rowOfRightTypeFor:forActor:)('code generation' codeString storeCodeOn:indent:)('dropping/grabbing' justDroppedInto:event:)('e-toy support' isCandidateForAutomaticViewing setAsActionInButtonProperties:)('event handling' handlesMouseDown: mouseDown:)('initialization' initialize setAssignmentRoot:type:rcvrType:argType: setAssignmentRoot:type:rcvrType:argType:vocabulary: setOperator:type:rcvrType: setOperator:type:rcvrType:argType: setSlotRefOperator:type: vocabulary:)('macpal' currentVocabulary)('menus' addCustomMenuItems:hand:)('miscellaneous' actualObject associatedPlayer bePossessive justGrabbedFromViewer justGrabbedFromViewer: justGrabbedFromViewerOrNil lastTile operatorTile resultType sproutNewScriptor tileRows try userScriptSelector userScriptSelector:)('mouse' catchDivideByZero:indent: morphToDropInPasteUp:)('queries' isCommand isPossessive)('scripting' bringUpToDate isTileScriptingElement)!!CompoundTileMorph reorganize!('access' associatedPlayer scriptee)('code generation' codeString storeCodeBlockFor:on:indent: storeCodeOn:indent:)('dropping/grabbing' wantsDroppedMorph:event:)('e-toy support' isTileEditor)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging:)('initialization' defaultBorderWidth defaultColor initialize)('layout' acceptDroppingMorph:event:)('miscellaneous' install recompileScript resultType rowOfRightTypeFor:forActor: scriptEdited tile:isOnLineAfter: tileRows type)('mouse' prepareToUndoDropOf: targetPartFor:)!!CommandTilesMorph reorganize!('initialization' initialize setMorph:)('miscellaneous' tileRows)!!TileLikeMorph reorganize!('dropping/grabbing' justGrabbedFrom:)('scripting' isTileLike)!!TickIndicatorMorph class reorganize!('no messages')!!TickIndicatorMorph reorganize!('accessing' color: isTicking isTicking: stepTime:)('drawing' drawOn:)('geometry' extent:)('initialization' defaultBorderColor defaultColor initialize)('stepping and presenter' stepAt:)('testing' stepTime wantsSteps)('private' privateMoveBy:)!!PlayerReferenceReadout class reorganize!('no messages')!!ThumbnailMorph class reorganize!('as yet unclassified' recursionReset)('class initialization' initialize)!!PlayerReferenceReadout reorganize!('event handling' handlesMouseDown: mouseDown:)('initialization' objectToView:viewSelector:putSelector:)!!ThumbnailMorph reorganize!('caching' releaseCachedState)('copying' veryDeepFixupWith: veryDeepInner:)('display' drawForForm:on: drawMeOn:)('drawing' drawOn:)('initialization' defaultBorderWidth defaultColor initialize objectToView: objectToView:viewSelector:)('scripting' tearOffTile)('stepping and presenter' step)('testing' stepTime)('texture support' installAsWonderlandTextureOn:)('what to view' actualViewee formOrMorphToView morphToView)!!Thumbnail class reorganize!('no messages')!!Thumbnail reorganize!('initialization' initialize maxWidth:minHeight: setStandardDefaultMetrics)('thumnail creation' makeThumbnailFromForm:)!!ThreePhaseButtonMorph class reorganize!('class initialization' initialize)('instance creation' checkBox radioButton)!ThreePhaseButtonMorph removeSelector: #extent!!ThreePhaseButtonMorph reorganize!('accessing' actionSelector actionSelector: arguments arguments: authorModeOwner: dragIfAuthoring: offImage offImage: onImage onImage: pressedImage pressedImage: state: target target:)('button' doButtonAction)('copying' updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('drawing' drawOn:)('e-toy support' adaptToWorld:)('event handling' doButtonAction: handlesMouseDown: handlesMouseStillDown: mouseDown: mouseMove: mouseStillDown: mouseUp:)('geometry' extent:)('initialization' initialize)('printing' printOn:)('stepping and presenter' step)('submorphs-add/remove' actWhen:)('testing' isOn stepTime wantsSteps)!!InternalThreadNavigationMorph class reorganize!('as yet unclassified' cacheThumbnailFor: clearThumbnailCache getThumbnailFor: know:as: knownThreads openThreadNamed:atIndex: sorterFormForProject:sized:)('parts bin' descriptionForPartsBin)!!ThreadNavigationMorph class reorganize!('as yet unclassified' example1)!InternalThreadNavigationMorph removeSelector: #initialColor!InternalThreadNavigationMorph removeSelector: #initialize!!InternalThreadNavigationMorph reorganize!('as yet unclassified' acceptSortedContentsFrom: addButtons buttonForMenu currentIndex deleteCurrentPage destroyThread editThisThread ensureSuitableDefaults getRecentThread insertNewProject insertNewProjectActionFor: jumpToIndex: jumpWithinThread listOfPages: loadPageWithProgress makeThumbnailForPageNumber:scaledToSize:default: moreCommands myThumbnailSize positionAppropriately showMenuFor:event: skipOverNext switchToThread: threadName threadName:index: threadOfAllProjects threadOfNoProjects)('initialization' defaultColor)('piano rolls' triggerActionFromPianoRoll)('stepping and presenter' step)!ThreadNavigationMorph removeSelector: #initialColor!!ThreadNavigationMorph reorganize!('WiW support' morphicLayerNumber)('as yet unclassified' addButtons colorForButtons currentIndex deleteCurrentPage ensureSuitableDefaults exitTheSequence firstPage fontForButtons lastPage listOfPages: loadPage loadPageWithProgress makeButton:balloonText:for: nextPage previousPage showMenuFor:event:)('buttons' buttonExit buttonFirst buttonForward buttonLast buttonPrevious)('initialization' defaultColor initialize)('stepping and presenter' step)('testing' stepTime wantsSteps)!!TheWorldMenu class reorganize!('open-menu registry' loadSqueakMap openPackageLoader registerOpenCommand: registerStandardInternetApps registeredOpenCommands unregisterOpenCommand: unregisterOpenCommandWithReceiver:)!!TheWorldMenu reorganize!('action' commandKeyTypedIntoMenu: createStandardPartsBin doMenuItem:with: launchCustomPartsBin menuColorString openMessageNames projectThumbnail roundedCornersString setGradientColor soundEnablingString staggerPolicyString toggleFlapSuppressionInProject toggleWindowPolicy uniTilesClassicString)('commands' beIsolated changeBackgroundColor cleanUpWorld inspectWorldModel loadProject lookForSlips mvcProjectsAllowed newMorphOfClass:event: openChangeSorter1 openChangeSorter2 openEmail openFileList openMVCProject openMorphicProject openSelectorBrowser openTranscript openWorkspace printWorldOnFile projectForMyWorld propagateChanges quitSession readMorphFromAFile saveAndQuit saveSession saveWorldInFile setDisplayDepth splitNewMorphList:depth: startMessageTally startThenBrowseMessageTally worldMenuHelp)('construction' alphabeticalMorphMenu appearanceMenu buildWorldMenu changesMenu colorForDebugging: debugMenu fillIn:from: helpMenu myMenuColor newMorph playfieldMenu projectMenu remoteMenu scriptingMenu)('mechanics' adaptToWorld: menu: world:project:hand:)('popups' appearanceDo changesDo debugDo doPopUp: helpDo openWindow playfieldDo projectDo remoteDo scriptingDo standardFontDo)('scripting' adaptedToWorld:)('windows & flaps menu' flapsDo flapsMenu formulateFlapsMenu: globalFlapsEnabled newGlobalFlapString suppressFlapsString windowsDo windowsMenu)!!TextPropertiesMorph class reorganize!('no messages')!!TextPropertiesMorph reorganize!('as yet unclassified' activeEditor activeTextMorph adjustTargetMargin: applyToWholeText changeKernBy: changeSelectionAttributeTo: changeStyle changeTargetColorTo: changeToNormalText doAccept kernMinus kernPlus offerFontMenu paneForApplyToWholeText paneForAutoFitToggle paneForMargins paneForTextColorPicker paneForWrappingToggle rebuild targetHasAutoFit targetHasWrapping targetTextColor toggleApplyToWholeText toggleBold toggleItalic toggleNarrow toggleSelectionAttribute: toggleStruckOut toggleTargetAutoFit toggleTargetWrapping toggleUnderlined)('initialization' defaultBorderColor defaultColor initialize)!!TextPlusPasteUpMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!TextPlusPasteUpMorph reorganize!('as yet unclassified' allTextPlusMorphs disablePageBreaksWhile: fullDrawForPrintingOn: nearestTextPlusMorphTo: printer select:or:asClosestTo: showPageBreaksString textPlusMenuFor: togglePageBreaks)('drawing' drawOn:)('dropping/grabbing' wantsDroppedMorph:event:)('initialization' initialize)('layout' acceptDroppingMorph:event:)('menus' addCustomMenuItems:hand:)('world state' dragThroughOnDesktop:)!!TextPlusMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!TextPlusMorph removeSelector: #extent:!!TextPlusMorph reorganize!('as yet unclassified' addAlansAnchorFor: addColumnBreak addItem: addJumpBeginning addJumpEnd allJumpEndStrings chooseOneJumpEnd doJumpTo: doYellowButtonPress: fixAllLeftOffsets jumpToDocumentTop keyboardFocusLostForSure linkNewlyDroppedMorph: makeSuccessorMorph parentGeeMail removeAlansAnchorFor: removeJumpEndFor: repositionAnchoredMorphs scrollSelectionToTop textPlusMenuFor:)('editing' handleInteraction:fromEvent:)('event handling' keyboardFocusChange: mouseDown: mouseMove: mouseUp:)('linked frames' addSuccessor: recomposeChain)('private' predecessorChanged releaseEditor releaseParagraph releaseParagraphReally updateFromParagraph)!!TextPlusJumpStart class reorganize!('no messages')!!TextPlusJumpStart reorganize!('as yet unclassified' actOnClickFor: emphasizeScanner: jumpLabel jumpLabel:)!!TextPlusJumpEnd class reorganize!('no messages')!!TextPlusJumpEnd reorganize!('as yet unclassified' emphasizeScanner: jumpLabel jumpLabel:)!!TextOnCurvePS class reorganize!('no messages')!!TextOnCurvePS reorganize!('display' displayOn:using:at:)!!TextOnCurveContainer class reorganize!('no messages')!!TextOnCurveContainer reorganize!('as yet unclassified' baseline baseline: bounds paragraphClass releaseCachedState textDirection textDirection: textSegments textSegments: top translateBy:)!!TextOnCurve class reorganize!('no messages')!!TextOnCurve reorganize!('access' extent textOwner:)('as yet unclassified' composeLinesFrom:withLines:atY: pointInLine:forDestPoint:segStart:segAngle: releaseCachedState textSegmentsDo: warpMapForDepth:withTransparentFor:)('composition' composeAll composeLinesFrom:to:delta:into:priorLines:atY:)('display' asParagraphForPostscript displayOn:using:at:)('selection' characterBlockAtPoint: containsPoint: selectionRectsFrom:to:)('private' moveBy:)!!TextMorphForEditView class reorganize!('new-morph participation' includeInNewMorphMenu)!TextMorphForEditView removeSelector: #handlesKeyboard:!!TextMorphForEditView reorganize!('accept/cancel' acceptOnCR:)('debug and other' tempCommand)('drawing' drawNullTextOn:)('edit view' editView setEditView:)('editing' acceptContents acceptOnCR cancelEdits handleInteraction:fromEvent: hasUnacceptedEdits:)('event handling' autoScrollView: keyStroke: mouseDown: mouseMove: mouseUp: wouldAcceptKeyboardFocusUponTab)('initialization' initialize)('macpal' flash)('miscellaneous' selectAll)('objects from disk' convertToCurrentVersion:refStream:)('private' updateFromParagraph)!!TextMorphEditor class reorganize!('instance creation' new)!!TextMorphEditor reorganize!('accessing' morph morph: setSearch: transformFrom: userHasEdited zapSelectionWith:)('as yet unclassified' totalTextHeight visibleHeight)('attributes' changeTextFont)('binding' bindingOf:)('controlling' controlInitialize controlTerminate)('current selection' select selectAndScroll selectAndScrollToTop)('displaying' flash)('editing keys' chooseColor inspectIt: offerFontMenu tempCommand:)('events' mouseDown: mouseMove: mouseUp:)('menu commands' offerMenuFromEsc:)('menu messages' accept align cancel changeEmphasisOrAlignment changeStyle find mvcRedisplay)('mvc compatibility' selectForTopFrom:to: storeSelectionInParagraph userHasNotEdited)('new selection' selectFrom:to:)('nonediting/nontyping keys' raiseContextMenu:)('scrolling' scrollBy: updateMarker)('typing support' dispatchOnCharacter:with: readKeyboard recognizeCharacters recognizeCharactersWhileMouseIn:)('private' againOrSame:)!!StringMorphEditor class reorganize!('new-morph participation' includeInNewMorphMenu)!!ShowEmptyTextMorph class reorganize!('no messages')!!EToyTextNode class reorganize!('as yet unclassified' newNode)('new-morph participation' includeInNewMorphMenu)!!ClipboardMorph class reorganize!('parts bin' descriptionForPartsBin)!!TextMorph class reorganize!('class initialization' initialize)('new-morph participation' includeInNewMorphMenu)('parts bin' borderedPrototype descriptionForPartsBin exampleBackgroundField exampleBackgroundLabel fancyPrototype supplementaryPartsDescriptions)('scripting' additionsToViewerCategories authoringPrototype)!StringMorphEditor removeSelector: #handlesKeyboard:!!StringMorphEditor reorganize!('drawing' drawOn:)('event handling' keyStroke: keyboardFocusChange:)!!ShowEmptyTextMorph reorganize!('drawing' drawOn:)!!EToyTextNode reorganize!('as yet unclassified' addChild: addNewChildAfter: children clipToOwner: firstDisplay firstDisplayedOnLevel: removeChild: showInOpenedState withAllChildrenDo:)('event handling' keyStroke: keyboardFocusChange:)('initialization' initialize)!!ClipboardMorph reorganize!('initialization' defaultBorderColor defaultBorderWidth defaultColor)('parts bin' initializeToStandAlone)('stepping and presenter' step)('testing' stepTime wantsSteps)!TextMorph removeSelector: #layoutChanged!!TextMorph reorganize!('accessing' asText autoFit: backgroundColor backgroundColor: borderWidth: contents contents: contents:wrappedTo: contentsAsIs: contentsWrapped: crAction crAction: editor fontName:size: getCharacters getFirstCharacter hasTranslucentColor isAutoFit isWrapped margins margins: newContents: setCharacters: setFirstCharacter: text textColor textColor: textStyle userString wrapFlag:)('alignment' centered justified leftFlush rightFlush)('anchors' adjustTextAnchor: anchorMorph:at:type:)('caching' loadCachedState releaseCachedState)('card & stack' newContents:fromCard: setNewContentsFrom:)('card in a stack' couldHoldSeparateDataForEachInstance)('change reporting' ownerChanged)('classification' isTextMorph)('containment' fillingOnOff occlusionsOnOff recognizerArena setContainer:)('copying' copy updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('drawing' areasRemainingToFill: debugDrawLineRectsOn: drawNullTextOn: drawOn:)('e-toy support' configureForKids getNumericValue setNumericValue:)('editing' acceptContents acceptOnCR cancelEdits chooseAlignment chooseEmphasis chooseEmphasisOrAlignment chooseFont chooseStyle enterClickableRegion: handleEdit: handleInteraction:fromEvent: hasUnacceptedEdits: passKeyboardFocusTo: xeqLinkText:withParameter:)('event handling' handlesKeyboard: handlesMouseDown: hasFocus keyStroke: keyboardFocusChange: mouseDown: mouseMove: mouseUp: wouldAcceptKeyboardFocusUponTab)('events-processing' handleKeystroke: handleMouseMove:)('genie-dispatching' handleGesture: lastGesture lastGesture: setAlignment:)('genie-processing' defaultGestureDictionaryOrName gestureHandler)('geometry' bounds container defaultLineHeight extent: minimumExtent privateMoveBy: textBounds)('geometry testing' containsPoint:)('initialization' beAllFont: defaultColor initialize setTextStyle: string:fontName:size: string:fontName:size:wrap:)('layout' acceptDroppingMorph:event:)('linked frames' addPredecessor: addSuccessor: firstCharacterIndex firstInChain isLinkedTo: lastCharacterIndex predecessor recomposeChain startingIndex successor withSuccessorsDo:)('menu' autoFitOnOff autoFitString changeMargins: changeTextColor followCurve reverseCurveDirection setCurveBaseline: shiftedYellowButtonActivity wrapOnOff wrapString yellowButtonActivity)('menus' addCustomMenuItems:hand:)('objects from disk' convertToCurrentVersion:refStream:)('player' currentDataValue variableDocks)('printing' fullPrintOn:)('scripting access' getAllButFirstCharacter setAllButFirstCharacter:)('submorphs-add/remove' addMorphFront:fromWorldPosition: delete goBehind)('testing' basicType)('visual properties' fillStyle fillStyle:)('private' adjustLineIndicesBy: clippingRectangle composeToBounds compositionRectangle fit installEditor installEditorToReplace: paragraph paragraphClass predecessor:successor: predecessorChanged privateOwner: privateRemoveMorph: releaseEditor releaseParagraph releaseParagraphReally selectionChanged setDefaultContentsIfNil setPredecessor: setSuccessor: text:textStyle: text:textStyle:wrap:color:predecessor:successor: updateFromParagraph)!!TextLine class reorganize!('instance creation' start:stop:internalSpaces:paddingWidth:)!!TextLine reorganize!('accessing' baseline bottom bottomRight first internalSpaces internalSpaces: last left leftMargin leftMargin: leftMarginForAlignment: lineHeight paddingWidth paddingWidth: rectangle rectangle: right rightMargin setRight: stop: top topLeft width)('comparing' =)('printing' printOn:)('scanning' justifiedPadFor: justifiedTabDeltaFor:)('updating' moveBy: slide: slideIndexBy:andMoveTopTo:)('private' firstIndex:lastIndex: internalSpaces:paddingWidth: lineHeight:baseline:)!!TextFieldMorph class reorganize!('instance creation' exampleBackgroundField)('scripting' authoringPrototype)!!TextFieldMorph reorganize!('card & stack' setNewContentsFrom:)('card in a stack' couldHoldSeparateDataForEachInstance)('initialization' defaultColor initialize)('just like textMorph' append: contents contents: fit fontName:size: lineCount prepend:)('player' currentDataValue variableDocks)!!SimplerTextContainer class reorganize!('no messages')!!TextContainer class reorganize!('class initialization' initialize)!!SimplerTextContainer reorganize!('container protocol' bottom left rectanglesAt:height: top)!!TextContainer reorganize!('access' avoidsOcclusions avoidsOcclusions: fillsOwner fillsOwner: paragraphClass releaseCachedState textMorph)('container protocol' bottom left rectanglesAt:height: top topLeft translateBy: width)('private' bounds computeShadow for:minWidth: shadowForm vertProfile)!!TextComposer class reorganize!('as yet unclassified' characterForColumnBreak)!!TextComposer reorganize!('as yet unclassified' addNullLineForIndex: addNullLineWithIndex:andRectangle: checkIfReadyToSlide composeAllLines composeAllRectangles: composeEachRectangleIn: composeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:wantsColumnBreaks: composeOneLine fixupLastLineIfCR slideOneLineDown)!!PrintComponent class reorganize!('no messages')!!FunctionComponent class reorganize!('no messages')!!TextComponent class reorganize!('no messages')!!PrintComponent reorganize!('components' initPinSpecs)('menu commands' accept)('model access' getText)!!FunctionComponent reorganize!('as yet unclassified' addPin headerString)('button' fire)('components' initFromPinSpecs initPinSpecs)('menu commands' accept)('menus' addCustomMenuItems:hand:)('model access' getText)('updating' update:)!!TextComponent reorganize!('components' initComponentIn: initFromPinSpecs initPinSpecs)('initialization' initialize)!!TextAnchorPlus class reorganize!('no messages')!!TextAnchorPlus reorganize!('as yet unclassified' emphasizeScanner:)!!TextAnchor class reorganize!('no messages')!TextAnchor removeSelector: #emphasizeScanner:!!TextAnchor reorganize!('as yet unclassified' anchoredMorph anchoredMorph: couldDeriveFromPrettyPrinting mayBeExtended)('comparing' =)!!TableLayoutProperties class reorganize!('no messages')!!TableLayoutProperties reorganize!('accessing' cellInset: cellPositioning: cellSpacing: layoutInset: listCentering: listDirection: listSpacing: maxCellSize: minCellSize: reverseTableCells: rubberBandCells: wrapCentering: wrapDirection:)('initialize' initialize)('table defaults' cellInset cellPositioning cellSpacing layoutInset listCentering listDirection listSpacing maxCellSize minCellSize reverseTableCells rubberBandCells wrapCentering wrapDirection)('testing' includesTableProperties)!!TableLayout class reorganize!('no messages')!!TableLayout reorganize!('layout' computeCellArrangement:in:horizontal:target: computeCellSizes:in:horizontal: computeExtraSpacing:in:horizontal:target: computeGlobalCellArrangement:in:horizontal:wrap:spacing: flushLayoutCache layout:in: minExtentOf:in: placeCells:in:horizontal:target:)('optimized' layoutLeftToRight:in: layoutTopToBottom:in: minExtentHorizontal: minExtentVertical:)('testing' isTableLayout)('utilities' indexForInserting:at:in: indexForInserting:inList:horizontal:target:)!!CRDictionaryMorph class reorganize!('instance creation' dictionary:)!!TabbedPalette class reorganize!('parts bin' descriptionForPartsBin)('printing' defaultNameStemForInstances)('scripting' authoringPrototype)!!CRDictionaryMorph reorganize!('accessing' ensureLayout hasCloseButton hasCloseButton: hasLayout)('initialization' openInWorld:)('initialize-release' initializeDictionary: layout)('naming' name:)('stepping and presenter' arrangeToStartSteppingIn: step)('submorphs' createAcceptButton createAdvancedTabMorph createBasicButton createBasicLabelStringMorph: createBasicTabMorph createBasicUpdatingButtonOn:action:get: createBasicUpdatingNumberMorphOn:get:put:min:max: createBasicUpdatingStringMorphOn:get:put: createBrowseTabMorph createCancelButton createCapturingTabMorph createCloseButton createDefaultButtons createEmptyTabMorph createStatsTabMorph wrapInAlignmentMorph:)('submorphs-add/remove' delete)('testing' name stepTime)('updating' acceptAdvanced acceptBasic acceptCapturing canChange canChangeAsk: changed indicateChanged update: updateAdvanced updateAll updateBasic updateCapturing)('user-interface' selectTab:)('view hooks' acceptAction acuteAngleRelevance acuteAngleRelevance: alertDistance alertDistance: alertDistanceDifference alertDistanceDifference: alertRelativeDistanceDifference alertRelativeDistanceDifference: angleRelevance angleRelevance: angleSector angleSector: cancelAction closeAction editParents escapeTime escapeTime: exportedName exportedName: includeCapturedPoints isAlertEnabled isRejectEnabled minAngle minAngle: minDirectionLengthPercentage minDirectionLengthPercentage: parentCount rejectDistance rejectDistance: rejectDistanceDifference rejectDistanceDifference: rejectRelativeDistanceDifference rejectRelativeDistanceDifference: shapeRelevance shapeRelevance: sizeRelevance sizeRelevance: speedPercentage speedPercentage: startEndRelevance startEndRelevance: strokeRelevance strokeRelevance: switchAlert switchIncludeCapturedPoints switchReject timeRelevance timeRelevance:)('private' modelIncludeCapturedPoints setOldValues)!TabbedPalette removeSelector: #defaultBorderWidth!!TabbedPalette reorganize!('dropping/grabbing' wantsDroppedMorph:event:)('e-toy support' succeededInRevealing:)('halos and balloon help' defersHaloOnClickTo:)('initialization' addTabFor:font: addTabForBook: addTabForBook:withBalloonText: defaultColor defaultPageSize initialize newTabs: setInitialState)('misc' addBookMenuItemsTo:hand:)('misc menu items' becomeStandardPalette recolorTabs showNoPalette showNoPaletteAndHighlightTab: sortTabs:)('miscellaneous' currentPalette tabsMorph)('navigation' transitionSpecFor:)('palette menu' addMenuTab)('scraps tab' hasScrapsTab scrapsBook showScrapsTab)('submorphs-add/remove' replaceSubmorph:by:)('user-interface' selectTab: selectTabNamed: selectTabOfBook: tabMorphs tabNamed:)('viewer tab' viewMorph:)!!TabSorterMorph class reorganize!('no messages')!!TabSorterMorph reorganize!('as yet unclassified' acceptSort addControls cancelSort sortTabsFor:)('initialization' initialize)!!TabMorph class reorganize!('printing' defaultNameStemForInstances)!!TabMorph reorganize!('as yet unclassified' convertToReferenceMorph isHighlighted morphToInstall morphToInstall: tabSelected)('copying' veryDeepFixupWith: veryDeepInner:)!!TTSampleStringMorph class reorganize!('parts bin' descriptionForPartsBin)!TTSampleStringMorph removeSelector: #defaultBorderColor!TTSampleStringMorph removeSelector: #initialize!!TTSampleStringMorph reorganize!('accessing' font: string string:)('drawing' drawOn:)('geometry testing' containsPoint:)('halos and balloon help' addOptionalHandlesTo:box:)('initialization' defaultBorderWidth defaultColor)('initialize' initializeString)('menus' addCustomMenuItems:hand: edit howTo loadFromURL loadFromURL:)('parts bin' initializeToStandAlone)('private' computeTransform)!!TTSampleFontMorph class reorganize!('instance creation' font:)!TTSampleFontMorph removeSelector: #defaultBorderColor!!TTSampleFontMorph reorganize!('accessing' doesBevels font font: smoothing smoothing: transform)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' areasRemainingToFill: drawCharactersOn: drawOn:)('geometry' extent: position:)('halos and balloon help' addOptionalHandlesTo:box: balloonHelpTextForHandle:)('initialization' defaultBorderWidth defaultColor initialize openInWorld)('initialize' open)('menu' createSample getSmoothingLevel nextSmoothingLevel)('menus' addCustomMenuItems:hand:)('rotate scale and flex' newTransformationMorph)('testing' canDrawBorder:)('updating' changed)('private' computeTransform privateMoveBy:)!!SystemWindowWithButton class reorganize!('no messages')!!SystemWindowWithButton reorganize!('as yet unclassified' adjustExtraButton buttonInTitle:)('geometry' extent:)('label' setLabelWidgetAllowance)('resize/collapse' wantsExpandBox)!!PreDebugWindow class reorganize!('new-morph participation' includeInNewMorphMenu)!!PartsWindow class reorganize!('no messages')!!PDAMorph class reorganize!('parts bin' descriptionForPartsBin)!!NewWorldWindow class reorganize!('no messages')!!IRCMorph class reorganize!('class initialization' initialize)('queries' hasPrototype)!!FlashPlayerWindow class reorganize!('no messages')!!CollapsedMorph class reorganize!('as yet unclassified' collapsedMorphOrNilFor:)!!ArchiveViewer class reorganize!('class initialization' initialize serviceOpenInZipViewer)('file list services' extractAllFrom: serviceAddToNewZip serviceExtractAll)('fileIn/Out' fileReaderServicesForFile:suffix: services)('initialize-release' unload)('instance creation' addFileToNewZip: open openOn:)('parts bin' descriptionForPartsBin)!!SystemWindow class reorganize!('accessing' classVersion)('instance creation' closeBoxImage collapseBoxImage labelled: newWithoutLabel)('new-morph participation' includeInNewMorphMenu)('top window' clearTopWindow closeTopWindow noteTopWindowIn: sendTopWindowToBack wakeUpTopWindowUponStartup windowsIn:satisfying:)!!PreDebugWindow reorganize!('as yet unclassified' adjustBookControls debug proceed setBalloonTextForCloseBox)('geometry' extent:)('initialization' initialize)('label' setLabelWidgetAllowance)!!PartsWindow reorganize!('as yet unclassified' adjustBookControls book: closeEditing invokePartsWindowMenu openEditing saveAsCustomPartsBin sortPages toggleStatus)('geometry' extent:)('initialization' defaultColor initialize)('label' setLabelWidgetAllowance)('menus' addCustomMenuItems:hand:)('resize/collapse' wantsExpandBox)!!PDAMorph reorganize!('initialization' defaultColor initialize)('parts bin' initializeToStandAlone)('stepping' wantsStepsWhenCollapsed)('stepping and presenter' step)('testing' stepTime wantsSteps)!!NewWorldWindow reorganize!('initialization' openInWorld:)('label' setStripeColorsFrom:)('menu' setWindowColor:)('panes' addMorph:frame: updatePaneColors)('resize/collapse' spawnReframeHandle:)('stepping' amendSteppingStatus)('testing' wantsSteps)!!IRCMorph reorganize!('access' consoleText fullName fullName: nick nick: portAsString portAsString: server server: userName userName:)('console' addToConsole: consoleSelection consoleTextSelection)('dependents access' release)('initialization' initialize)('interface' connect ircMessageRecieved: makeConnection openChannel: openChannelList openConnection openMotd sendCommand:)('menus' addCustomMenuItems:hand:)('stepping' wantsStepsWhenCollapsed)('stepping and presenter' step)('submorphs-add/remove' delete)('testing' stepTime wantsSteps)!!FlashPlayerWindow reorganize!('as yet unclassified' addProgressIndicator addProgressIndicator: adjustBookControls startPlaying stopPlaying)('geometry' extent:)('initialization' initialize model:)('open/close' openInMVCExtent: openInWorldExtent:)('panes' addMorph:frame:)('resize/collapse' collapseOrExpand)!!CollapsedMorph reorganize!('collapse/expand' beReplacementFor: uncollapseToHand)('menu' buildWindowMenu)('queries' isMyUncollapsedMorph:)('resize/collapse' collapseOrExpand wantsExpandBox)!!ArchiveViewer reorganize!('accessing' archive fileName members selectedMember)('archive operations' canCreateNewArchive canExtractAll canOpenNewArchive canSaveArchive commentArchive createNewArchive extractAll extractAllPossibleInDirectory: extractDirectoriesIntoDirectory: extractFilesIntoDirectory: openNewArchive saveArchive writePrependingFile)('initialization' archive: backgroundColor buttonColor buttonOffColor buttonOnColor contents contents: createButtonBar createListHeadingUsingFont: createWindow fileName: initialize)('member list' displayLineFor: highlightMemberList:with: memberIndex memberIndex: memberList memberMenu:shifted:)('member operations' addDirectory addMember addMemberFromClipboard canAddMember canDeleteMember canExtractMember canRenameMember canViewAllContents changeViewAllContents commentMember deleteMember extractMember inspectMember renameMember)('menu' buildWindowMenu)('message handling' perform:orSendTo:)('panes' paneColor paneColorToUse)('parts bin' initializeToStandAlone)('updating' windowIsClosing)('user interface' defaultBackgroundColor)!SystemWindow removeSelector: #wantsHaloFromClick!!SystemWindow reorganize!('accessing' borderWidthForRounding colorForInsets raisedColor wantsToBeCachedByHand)('drawing' areasRemainingToFill: makeMeVisible scrollBarColor)('dropping/grabbing' justDroppedInto:event: wantsToBeDroppedInto:)('e-toy support' isCandidateForAutomaticViewing)('event handling' handlesMouseDown: handlesMouseOverDragging: mouseDown: mouseEnterDragging: mouseLeaveDragging: mouseMove: mouseUp:)('events' doFastFrameDrag: paneTransition: secondaryPaneTransition:divider:)('events-processing' handleListenEvent:)('geometry' extent: labelRect paneMorphs panelRect position: positionSubmorphs removeMenuBox setPaneRectsFromBounds)('halos and balloon help' wantsHalo)('initialization' addCloseBox addExpandBox addLabelArea addMenuControl applyModelExtent defaultBorderColor defaultBorderWidth defaultColor initialize maximumExtent maximumExtent: model: openInMVC openInWorld: setFramesForLabelArea)('label' getRawLabel label labelHeight labelWidgetAllowance relabel relabelEvent: setLabel: setLabelWidgetAllowance setStripeColorsFrom: wantsLabel widthOfFullLabelText)('layout' convertAlignment layoutBounds putLabelItemsInLabelArea)('menu' buildWindowMenu deleteCloseBox fullScreen fullScreenMaximumExtent makeClosable makeSecondTopmost makeUnclosable offerWindowMenu sendToBack setWindowColor setWindowColor: takeOutOfWindow)('menus' addCustomMenuItems:hand: changeColor collapse)('naming' tryToRenameTo:)('objects from disk' convertToCurrentVersion:refStream:)('open/close' closeBoxHit mustNotClose openAsIs openAsIsIn: openInMVCExtent: openInWorld:extent: openInWorldExtent:)('panes' addMorph:frame: existingPaneColor holdsTranscript paneColor paneColor: paneColorToUse paneMorphSatisfying: replacePane:with: restoreDefaultPaneColor setUpdatablePanesFrom: titleAndPaneText updatablePanes updatePaneColors)('resize/collapse' allowReframeHandles allowReframeHandles: collapseOrExpand collapsedFrame doFastWindowReframe: expand expandBoxHit fastFramingOn fullFrame getBoundsWithFlex getCollapsedFrame isCollapsed mouseLeaveEvent:fromPane: paneWithLongestSide:near: reframePanesAdjoining:along:to: setBoundsWithFlex: spawnOffsetReframeHandle:divider: spawnPaneFrameHandle: spawnReframeHandle: unexpandedFrame unexpandedFrame: wantsExpandBox)('rounding' wantsRoundedCorners)('stepping' amendSteppingStatus wantsStepsWhenCollapsed)('stepping and presenter' stepAt:)('submorphs-add/remove' addMorph:fullFrame: delete)('testing' isSystemWindow shouldDropOnMouseUp stepTime wantsSteps)('top window' activate activateAndForceLabelToShow activeOnlyOnTop activeOnlyOnTop: adjustBorderUponActivationWhenLabeless adjustBorderUponDeactivationWhenLabeless extantSketchEditor isActive lockInactivePortions passivate)('updating' update:)('user interface' initialExtent)('viewer' externalName)!!SyntaxTestMethods class reorganize!('no messages')!!SyntaxTestMethods reorganize!('as yet unclassified' altStyleTester bobsplace2:after:newLine: bobsplace:after:newLine: doAndCollect makeRandomString pickUpFood repeatExample st76LeftArrowTest: wordyTestMethod)!!SyntaxMorph class reorganize!('accessing' sourceCodeTemplate)('as yet unclassified' allSpecs column:on: methodNodeOuter: noTileColor row:on: setSize:andMakeResizable: standardInset test testAll testAllMethodsOver: testClass:andMethod: translateColor:)('class initialization' initialize)!SyntaxMorph removeSelector: #addMorphBack:!SyntaxMorph removeSelector: #changed!!SyntaxMorph reorganize!('accessing' actualObject argumentNodes balloonText borderColor: cleanUpString: color: dissectMessage editor enclosingPane getCurrentValue messageNode parseNode parseNode: parsedInClass parsedInClass: readOut receiverNode receiverObject rename: selector unSpaceAndUpShift:appending: userScriptSelector userScriptSelector:)('alans styles' aSimpleStringMorphWith: alansCurrentFontPreference alansTemplateStyleFor: anUpdatingStringMorphWith:special: constructSelfVariant:and: darkerColor fontToUseForSpecialWord: lighterColor noiseBeforeBlockArg noiseStringMorph: noiseWordBeforeVariableNode:string: setConditionalPartStyle setSpecialOuterTestFormat setSpecialTempDeclarationFormat1 setSpecialTempDeclarationFormat2 shouldBeBrokenIntoWords: specialColor:andBorder: splitAtCapsAndDownshifted: standardCellPositioning standardInset substituteKeywordFor: tokenVerticalSeparator translateFromWordySelfVariant: translateToWordyGetter: translateToWordySelfVariant: translateToWordySetter:)('card & stack' setNewContentsFrom: setTarget:)('card in a stack' couldHoldSeparateDataForEachInstance)('change reporting' colorChangedForSubmorph:)('classification' isSyntaxMorph)('debugging' debugger debugger: hostContext)('drawing' drawOn: lookTranslucent)('dropping/grabbing' cleanupAfterItDroppedOnMe highlightForDrop: justDroppedInto:event: morphToDropInPasteUp: structureMatchWith: wantsDroppedMorph:event:)('event handling' cursorBaseOffset handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: wantsKeyboardFocusFor:)('formatting options' alansTest1 controlContrast2: controlContrast: controlSpacing2: controlSpacing: lookClassic usingClassicTiles)('highlighting' compoundBorderColor dropColor grabColor highlightForGrab: stdBorderColor unhighlight unhighlightBorder unhighlightOwner unhighlightOwnerBorder)('initialization' inAPluggableScrollPane inAScrollPane openInWindow returnNode:expression: sample:)('insertion drop zones' removeDropZones trackDropZones)('layout' acceptDroppingMorph:event: addBlockArg: addColumn:on: addNoiseString: addNoiseString:emphasis: addRow:on: addSingleKeywordRow: addString:special: addTempVar: addTextRow: addToBlock:event: addToken:type:on: addTokenSpecialCase:type:on: addUnaryRow:style: foldMessage foldMessageOneArg isKnownVarName: removeReturnNode tempVarNodesDo: try unfoldMessage)('macpal' currentVocabulary)('menus' accept acceptIfInScriptor acceptIgnoring: acceptInCategory: acceptSilently acceptUnlogged decompile getMenuBlock offerTilesMenuFor:in: offerVarsMenuFor:in: putOnBackground showCode showMenu:)('new tiles' attachTileForCode:nodeType: attachToHand instVarTile: string:toTilesIn:)('node to morph' addTemporaries: addTemporaryControls alanBinaryPostRcvr:key:args: alanKeywordMessage:isAConditional:key:args: alanKwdCollect:isAConditional:key:args: alanKwdIfDo:isAConditional:key:args: alanKwdRepeatForDoing:isAConditional:key:args: alanKwdSetter2:isAConditional:key:args: alanKwdSetter:isAConditional:key:args: alanUnaryGetter:key: alanUnaryPostRcvr:key:selector: alansMessageNode:receiver:selector:keywords:arguments: assignmentNode:variable:value: blockNode:arguments:statements: blockNodeCollect:arguments:statements: cascadeNode:receiver:messages: changeBasicStyle finalAppearanceTweaks isStandardGetterSelector: isStandardSetterKeyword: messageNode:receiver:selector:keywords:arguments: messageOneArg:receiver:selector:args: methodNodeInner:selectorOrFalse:precedence:arguments:temporaries:primitive:block: methodNodeOuter: vanillaMessageNode:receiver:selector:arguments:)('node types' immediatelyBelowTheMethodNode isAVariable isBlockNode isDeclaration isLeafTile isMethodNode isNoun isSelfTile nodeClassIs: rootTile)('player' currentDataValue variableDocks)('pop ups' addArg: assignmentArrow changeSound: colorPatch deleteLine deletePopup dismisser dupTile: duplicator event:arrow:upDown: extend extendArrow newAssignment offerPopUp replaceKeyWord:menuItem: replaceSel:menuItem: retract retractArrow selectorMenu selectorMenuAsk: setSelector:in: tossOutArg: upDown:event:arrow: upDownArithOp: upDownArrows upDownAssignment: upDownDone upDownMore:event:arrow:)('printing' getHeader: ownerPrecedence printAssignmentNodeOn:indent: printBlockArgsNodeOn:indent: printBlockNodeOn:indent: printCascadeNodeOn:indent: printMessageNodeOn:indent: printMethodNodeOn:indent: printMethodTempsNodeOn:indent: printOn: printOn:indent: printSimpleStringMorph:on: printStatementsOn:indent: printVariableNodeOn:indent: structure submorphsDoIfSyntax:ifString: submorphsDoIfSyntax:ifString:otherwise:)('scripting' tearOffTile)('selection' currentSelectionDo: deselect isSelectable scaleColorByUserPref: select setDeselectedColor setSelection:)('stepping and presenter' step)('submorphs-accessing' findA:)('testing' stepTime wantsSteps)('tests' test testForNode:andDo: toDo)('type checking' allSpecs argTypeFor: okToBeReplacedBy: receiverOrArgType receiverOrArgTypeAbove receiverTypeFor: resultType resultTypeFor:)('updating' update:)('viewer' externalName)('visual properties' fillStyle:)('vocabulary' limitClassToUseWith:vocabulary: vocabularyToUseWith:)!!SubpaneDividerMorph class reorganize!('instance creation' forBottomEdge forTopEdge horizontal vertical)!!SubpaneDividerMorph reorganize!('accessing' borderColor borderColor: resizingEdge)('initialization' defaultColor firstEnter: horizontal initialize resizingEdge: vertical)!!StringButtonMorph class reorganize!('printing' defaultNameStemForInstances)!!PDAChoiceMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!DropDownChoiceMorph class reorganize!('class initialization' initialize)!!PopUpChoiceMorph class reorganize!('no messages')!!MenuItemMorph class reorganize!('class initialization' initialize)('scripting' additionsToViewerCategories)!!InfoStringMorph class reorganize!('instance creation' on:)!!IndentingListParagraphMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!IndentingListItemMorph class reorganize!('no messages')!!FrameRateMorph class reorganize!('parts bin' descriptionForPartsBin)('scripting' authoringPrototype)!!ClockMorph class reorganize!('parts bin' descriptionForPartsBin)('scripting' authoringPrototype)!!BorderedStringMorph class reorganize!('no messages')!!StringMorph class reorganize!('instance creation' contents: contents:font: contents:font:emphasis:)('parts bin' descriptionForPartsBin)('scripting' authoringPrototype)('testing' test test2)!StringButtonMorph removeSelector: #defaultColor!!StringButtonMorph reorganize!('accessing' actionSelector actionSelector: arguments arguments: target target:)('button' doButtonAction)('copying' updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('e-toy support' adaptToWorld:)('event handling' handlesMouseDown: handlesMouseStillDown: mouseDown: mouseMove: mouseStillDown: mouseUp:)('initialization' initialize)('menu' setActWhen setActionSelector setArguments setLabel setTarget:)('menus' addCustomMenuItems:hand:)('submorphs-add/remove' actWhen:)!!PDAChoiceMorph reorganize!('accessing' color color:)('drawing' drawOn:)!!DropDownChoiceMorph reorganize!('accessing' border border: items items:)('copying' veryDeepInner:)('drawing' drawOn: maxExtent:)('event handling' mouseDown:)('list access' getCurrentSelectionIndex selection:)!!PopUpChoiceMorph reorganize!('as yet unclassified' actionSelector actionSelector: arguments arguments: getItemsArgs getItemsArgs: getItemsSelector getItemsSelector: target target:)('copying' veryDeepFixupWith: veryDeepInner:)('event handling' handlesMouseDown: mouseDown:)('initialization' initialize)!MenuItemMorph removeSelector: #defaultColor!MenuItemMorph removeSelector: #minHeight!!MenuItemMorph reorganize!('accessing' allWordingsNotInSubMenus: arguments arguments: contentString contentString: contents: contents:withMarkers: contents:withMarkers:inverse: hasSubMenu hasSubMenu: isEnabled isEnabled: isStayUpItem itemWithWording: selector selector: subMenu subMenu: target target:)('button' doButtonAction)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' drawOn:)('dropping/grabbing' aboutToBeGrabbedBy:)('e-toy support' adaptToWorld:)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp:)('events' activateOwnerMenu: activateSubmenu: deselectTimeOut: invokeWithEvent:)('events-processing' handleMouseUp:)('halos and balloon help' wantsHaloFromClick)('initialization' defaultBounds deleteIfPopUp: initialize)('layout' minWidth)('layout-properties' hResizing vResizing)('meta-actions' duplicateMorph:)('selecting' deselect: isSelected: select:)('private' deselectItem notObsolete offImage onImage)!!InfoStringMorph reorganize!('accessing' block block: stepTime:)('initialization' initialize)('stepping and presenter' step)('testing' stepTime)!IndentingListParagraphMorph removeSelector: #privateBounds:!!IndentingListParagraphMorph reorganize!('as yet unclassified' desiredHeight isExpanded: position:andWidth: repositionText takeFocus textMorphBounds textMorphLeft toggleExpandedState)('drawing' drawOn: drawToggleOn:in:)('event handling' keyStroke:)('initialization' initWithContents:prior:forList:indentLevel:)('layout' layoutChanged)!!IndentingListItemMorph reorganize!('accessing' balloonText highlight)('as yet unclassified' addChildrenForList:addingTo:withExpandedItems: canExpand children childrenDo: firstChild indentLevel isExpanded isExpanded: nextSibling nextSibling: openPath: recomputeAllForList:addingTo:withExpandedItems: recomputeForList:addingTo:withExpandedItems: recursiveAddTo: recursiveDelete toggleExpandedState toggleRectangle withSiblingsDo:)('converting' complexContents withoutListWrapper)('drawing' drawOn: drawToggleOn:in: unhighlight)('halos and balloon help' boundsForBalloon)('initialization' initWithContents:prior:forList:indentLevel: initialize)('layout' acceptDroppingMorph:event:)('mouse events' inToggleArea:)!!FrameRateMorph reorganize!('initialization' initialize)('parts bin' initializeToStandAlone)('stepping and presenter' step)('testing' stepTime)!!ClockMorph reorganize!('initialization' initialize)('menus' addCustomMenuItems:hand:)('parts bin' initializeToStandAlone)('seconds' showSeconds: toggleShowingSeconds)('stepping and presenter' step)('testing' stepTime)!!BorderedStringMorph reorganize!('accessing' measureContents)('drawing' drawOn:)('initialization' initWithContents:font:emphasis: initialize)!!StringMorph reorganize!('accessing' contents contents: contentsClipped: fitContents font font: font:emphasis: fontName:size: fontToUse handsWithMeForKeyboardFocus interimContents: measureContents minimumWidth setWidth: userString valueFromContents)('drawing' drawOn: lookTranslucent)('editing' acceptContents acceptValue: cancelEdits doneWithEdits launchMiniEditor: lostFocusWithoutAccepting wantsKeyboardFocusOnShiftClick)('event handling' handlesMouseDown: hasFocus mouseDown: wouldAcceptKeyboardFocus)('font' emphasis:)('halos and balloon help' addOptionalHandlesTo:box: boundsForBalloon)('initialization' defaultColor initWithContents:font:emphasis: initialize)('layout' fullBounds minHeight)('menu' changeEmphasis changeFont)('menus' addCustomMenuItems:hand:)('parts bin' initializeToStandAlone)('printing' balloonTextForClassAndMethodString balloonTextForLexiconString balloonTextForMethodString fullPrintOn: printOn:)!!StretchyImageMorph class reorganize!('no messages')!!StretchyImageMorph reorganize!('as yet unclassified' form:)('drawing' drawOn:)('initialization' initialize)!!StoryboardBookMorph class reorganize!('parts bin' descriptionForPartsBin)!!StoryboardBookMorph reorganize!('as yet unclassified' changeTiltFactor: changeZoomFactor: getTiltFactor getZoomFactor offsetX offsetX: offsetY offsetY: scale scale:)('initialization' initialize)('navigation' insertPageMorphInCorrectSpot:)!!StoreEncoder class reorganize!('configuring' filterSelector)!!StoreEncoder reorganize!('no messages')!!StickySketchMorph class reorganize!('no messages')!!StickySketchMorph reorganize!('e-toy support' mustBeBackmost)('halos and balloon help' wantsHalo)('thumbnail' permitsThumbnailing)!!StepMessage class reorganize!('instance creation' scheduledAt:stepTime:receiver:selector:arguments:)!!StepMessage reorganize!('accessing' stepTime:)('printing' printOn:)('testing' stepTime)!!StarSqueakTrees class reorganize!('parts bin' descriptionForPartsBin)!!StarSqueakTrees reorganize!('initialization' initialize)('menu' setTreeDepth setTreeType)('menus' addCustomMenuItems:hand:)('parts bin' initializeToStandAlone)('setup' setup)!!StarSqueakTermites class reorganize!('no messages')!!StarSqueakTermites reorganize!('all' setupPatches setupTurtles)('setup' setup)!!StarSqueakSlimeMold class reorganize!('parts bin' descriptionForPartsBin)!!StarSqueakSlimeMold reorganize!('initialization' initialize)('menu' sliderParameters)('other' diffusePheromone evaporatePheromone)('parameters' cellCount cellCount:)('setup' setup)!!StarSqueakForestFire class reorganize!('no messages')!!StarSqueakDiffusion class reorganize!('no messages')!!StarSqueakAntColony class reorganize!('no messages')!!StarSqueakMorph class reorganize!('class initialization' initialize)!!StarSqueakForestFire reorganize!('demons' consumeFuel spreadFire)('initialization' initialize)('menu' sliderParameters)('parameters' treePercentage treePercentage:)('setup' setup setupBorder setupFire setupTrees)!!StarSqueakDiffusion reorganize!('initialization' initialize)('menu' sliderParameters)('other' setupTurtles)('parameters' dyeCount dyeCount: waterCount waterCount:)('setup' setup)!!StarSqueakAntColony reorganize!('initialization' initialize)('menu' sliderParameters)('other' diffusePheromone evaporatePheromone setupFood: setupNest: setupPatches setupTurtles)('parameters' antCount antCount: backgroundColor)('setup' setup)!!StarSqueakMorph reorganize!('accessing' diffusionRate diffusionRate: evaporationRate evaporationRate: pixelsPerPatch pixelsPerPatch:)('drawing' areasRemainingToFill: display drawOn:)('geometry' extent:)('initialization' initialize)('menu' fullSpeed makeParameterSlider setScale singleStep sliderParameters slowSpeed startOver startRunning stopRunning)('menus' addCustomMenuItems:hand:)('parts bin' initializeToStandAlone)('patches' clearPatches createPatchVariable: decayPatchVariable: diffusePatchVariable: patchesDo:)('setup' addTurtleDemon: addWorldDemon: clearAll displayPatchVariable: displayPatchVariable:logScale: random: setup starSqueakDimensions)('stepping and presenter' oneStep step)('testing' stepTime)('turtles' makeTurtles: makeTurtles:class: turtles turtlesAtX:y:do: turtlesDo:)('private' createPatchFormGetterAndSetter deleteTurtle: dimensions displayPatchVariableOn:color:shift: firstTurtleAtX:y: getPatchBrightnessAtX:y: getPatchColorAtX:y: getPatchVariable:atX:y: incrementPatchVariable:atX:y:by: newSliderForParameter:target:min:max:description: patchVariable:ifAbsent: replicateTurtle: setPatchBrightnessAtX:y:to: setPatchColorAtX:y:to: setPatchVariable:atX:y:to: sumPatchVariable:neighborsAtX:y: uphillOf:forTurtle:)('private-primitives' primDiffuseFrom:to:width:height:delta: primEvaporate:rate: primMapFrom:to:width:height:patchSize:rgbFlags:shift: testDiffusePrim testEvaporatePrim)!!StarMorph class reorganize!('parts bin' descriptionForPartsBin)!!StarMorph reorganize!('editing' addHandles dragVertex:event:fromHandle: updateHandles)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('parts bin' initializeToStandAlone)!!EToySystem class reorganize!('development support' cleanupsForRelease loadJanForms stripMethodsForExternalRelease)('external release' methodsToStripForExternalRelease)('misc' fixComicCharacters)('stripped' prepareRelease previewEToysOn:)!!StandardScriptingSystem class reorganize!('class initialization' initialize)!!EToySystem reorganize!('no messages')!!StandardScriptingSystem reorganize!('font & color choices' colorBehindTiles fontForNameEditingInScriptor fontForTiles smallBoldFont statusColorSymbolFor: uniformTileInteriorColor)('form dictionary' deletePrivateGraphics deletePrivateGraphics:afterStoringToFileNamed: formAtKey: formAtKey:extent:depth: formDictionary inspectFormDictionary installSolidMenuForm mergeGraphicsFrom: patchInNewStandardPlayerForm privateGraphics readFormsFromFileNamed: readFormsFromFileNamed:andStoreIntoGlobal: restorePrivateGraphics saveForm:atKey: saveFormsToFileNamed: squeakyMouseForm standardForms)('help dictionary' helpStringOrNilFor: initializeHelpStrings statusHelpString)('parts bin' anyButtonPressedTiles noButtonPressedTiles prototypicalHolder resetStandardPartsBin tilesForQuery:label:)('script-control' goButton goUp:with: scriptControlButtons stepButton stepDown:with: stepStillDown:with: stepUp:with: stopButton stopUp:with:)('tile colors' colorForType: colorFudge)('universal slots & scripts' acceptableSlotNameFrom:forSlotCurrentlyNamed:asSlotNameIn:world: doesOperatorWantArrows: systemSlotNamesOfType:)('utilities' allClassVarNamesInSystem allKnownClassVariableNames arithmeticalOperatorsAndHelpStrings cleanupsForRelease customizeForEToyUsers: helpStringForOperator: holderWithAlphabet informScriptingUser: newScriptingSpace newScriptingSpace2 numericComparitorsAndHelpStrings prepareForExternalReleaseNamed: reclaimSpace referenceAt: referenceAt:put: reinvigorateThumbnailsInViewerFlapTabs resetAllScriptingReferences resetStaleScriptingReferences setterSelectorForGetter: spaceReclaimed standardEventStati stripGraphicsForExternalRelease tileForArgType: tryButtonFor: wordingForOperator:)('viewer' uniqueNameForReference)!!StackMorph class reorganize!('authoring prototype' designationsExplainer)('misc' discoverSlots:)('navigation buttons' nextCardButton previousCardButton)('parts bin' descriptionForPartsBin stackHelpWindow)('scripting' additionsToViewerCategories authoringPrototype)!!StackMorph reorganize!('accessing' cardNumberOf: cardsOrPages)('as yet unclassified' commitCardData insertCardOfBackground insertCardOfBackground: openInsideLook)('background' addCardsFromAFile addCardsFromClipboardData addCardsFromClipboardDataForInstanceVariables: addCardsFromFile: addCardsFromString: addCardsFromString:slotNames: backgroundWithCard: backgrounds beDefaultsForNewCards changeInstVarOrder insertAsBackground:resize: makeNewBackground sortByField: sortCards)('card access' browseCardClass cardIndexOf: cards currentCard deleteAllCardsExceptThisOne deleteCard deleteCard: goToCard goToCard: goToCardNumber: goToFirstCardInBackground goToFirstCardOfStack goToLastCardInBackground goToLastCardOfStack insertCardOfBackground:withDataFrom:forInstanceVariables: makeCurrentCardFirstInStack makeCurrentCardLastInStack moveCardOnePositionEarlier moveCardOnePositionLater privateCards privateCards:)('card in a stack' explainDesignations goToNextCardInStack goToPreviousCardInStack insertCard reassessBackgroundShape relaxGripOnVariableNames reshapeBackground showDesignationsOfObjects stackDo:)('controls' pageControlsMorphFrom:)('debugging' inspectCurrentBackground inspectCurrentCard inspectCurrentStack)('initialization' initialize initializeWith:)('insert and delete' defaultNameStemForNewPages)('menu' findText: findText:inStrings:startAt:container:cardNum: findViaTemplate formatList: getAllText invokeBookMenu offerBookishMenu offerStackDebugMenu templateMatches writeSingletonData)('misc' addBookMenuItemsTo:hand:)('page controls' fullControlSpecs shortControlSpecs)('parts bin' initializeToStandAlone)('submorphs-accessing' allNonSubmorphMorphs)!!SquishedNameMorph class reorganize!('no messages')!!SquishedNameMorph reorganize!('as yet unclassified' colorAroundName fontForName isEditingName stringToShow target:getSelector:setSelector:)('drawing' drawOn:)!!SpectrumAnalyzerMorph class reorganize!('no messages')!!SpectrumAnalyzerMorph reorganize!('initialization' defaultBorderWidth initialize)('menu and buttons' invokeMenu resetDisplay setDisplayType setFFTSize setSamplingRate)('stepping and presenter' start step stop stopStepping)('submorphs-add/remove' delete)('testing' stepTime)('private' addButtonRow addLevelSlider buttonName:action: makeLevelMeter makeStatusLight processBuffer: removeAllDisplays showSignal showSonogram showSpectrum updateDisplay)!!SpeakerMorph class reorganize!('scripting' additionsToViewerCategories)!!SpeakerMorph reorganize!('initialization' addGraphic defaultColor initialize speakerGraphic)('speaker' appendSample: conePosition conePosition: flushBuffer stopSound)!!SoundSequencerMorph class reorganize!('no messages')!!SoundSequencerMorph reorganize!('as yet unclassified' makeControlPanel play reset)('initialization' initialize)('stepping and presenter' stop)!!SoundMorph class reorganize!('no messages')!!SoundMorph reorganize!('as yet unclassified' buildImage reset sound sound:)('dropping/grabbing' justDroppedInto:event:)('initialization' initialize)!!SoundLoopMorph class reorganize!('no messages')!!SoundLoopMorph reorganize!('as yet unclassified' addCursorMorph allowSubmorphExtraction buildSound play)('dropping/grabbing' wantsDroppedMorph:event:)('geometry' extent:)('initialization' defaultBorderWidth defaultBounds defaultColor initialize)('playing' controlRate doControl mixSampleCount:into:startingAt:leftVol:rightVol: playSampleCount:into:startingAt: positionCursor reset samplesRemaining samplingRate)('stepping and presenter' step stop)('testing' stepTime)!!SoundEventMorph class reorganize!('no messages')!!SoundEventMorph reorganize!('as yet unclassified' sound:)('caching' releaseCachedState)('initialization' defaultColor initialize)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: justDroppedIntoPianoRoll:event:)!!SoundDemoMorph class reorganize!('no messages')!!SoundDemoMorph reorganize!('as yet unclassified' makeControls playAll playV1 playV2 playV3 setTimbreFromTile: stopSound)('initialization' defaultBorderWidth defaultColor initialize initializeSoundColumn)!!SorterTokenMorph class reorganize!('no messages')!SorterTokenMorph removeSelector: #initialize!!SorterTokenMorph reorganize!('as yet unclassified' fitContents forMorph:)('initialization' defaultBorderColor defaultBorderWidth defaultColor)('thumbnail' morphRepresented)!!Sonogram class reorganize!('no messages')!!Sonogram reorganize!('all' extent:minVal:maxVal:scrollDelta: plotColumn: scroll)('geometry' extent:)!!SlotInformation class reorganize!('no messages')!!SlotInformation reorganize!('access' documentation documentation: floatPrecision floatPrecision: type type: variableDock variableDock:)('initialization' initialize)('printing' printOn:)!!SimpleSliderMorph class reorganize!('parts bin' descriptionForPartsBin)('printing' defaultNameStemForInstances)('scripting' additionsToViewerCategories authoringPrototype)!!ScrollBar class reorganize!('as yet unclassified' alwaysShowFlatScrollbarForAlternativeLook)('class initialization' initialize)!!Slider class reorganize!('new-morph participation' includeInNewMorphMenu)!!SimpleSliderMorph reorganize!('accessing' actionSelector actionSelector: arguments arguments: maxVal maxVal: minVal minVal: target target:)('copying' updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('e-toy support' getNumericValue setNumericValue:)('initialization' initialize)('menu' clearTarget descendingString setActionSelector setArguments setLabel setMaxVal setMinVal setMinVal: setTarget: toggleDescending toggleTruncate truncateString)('menus' addCustomMenuItems:hand:)('model access' setValue:)('parts bin' initializeToStandAlone)('private' adjustToValue: getScaledValue setMaxVal: setScaledValue: truncate truncate:)!ScrollBar removeSelector: #computeSlider!!ScrollBar reorganize!('access' alternativeScrollbarLook interval: pagingArea roundedScrollbarLook scrollDelta scrollDelta:pageDelta: sliderColor: sliderShadowColor thumbColor)('accessing' adoptPaneColor:)('as yet unclassified' cachedImageAt:ifAbsentPut:)('geometry' buttonExtent expandSlider extent: sliderExtent sliderThickness totalSliderArea)('initialization' initialize)('initialize' initializeDownButton initializeEmbedded: initializeMenuButton initializePagingArea initializeSlider initializeUpButton upArrow8Bit)('model access' setValue:)('other events' menuButtonMouseDown: mouseDownInSlider:)('scroll timing' resetTimer waitForDelay1:delay2:)('scrolling' doScrollByPage doScrollDown doScrollUp finishedScrolling scrollBarAction scrollBarAction: scrollDown scrollDown: scrollDownInit scrollPageInit: scrollUp scrollUp: scrollUpInit setNextDirectionFromEvent:)('stepping and presenter' step)('testing' stepTime wantsSteps)!!Slider reorganize!('access' descending descending: pagingArea sliderColor sliderColor: sliderShadowColor thumbColor wantsSlot)('geometry' computeSlider extent: roomToMove sliderExtent sliderThickness totalSliderArea)('initialization' defaultBorderColor defaultBorderWidth defaultBounds defaultColor initialize)('initialize' initializeSlider)('model access' setValue: value:)('other events' mouseDownInSlider: mouseUpInSlider:)('scrolling' scrollAbsolute:)!!MultiuserTinyPaint class reorganize!('class initialization' initialize)!!MorphThumbnail class reorganize!('no messages')!!JoystickMorph class reorganize!('new-morph participation' includeInNewMorphMenu)('parts bin' descriptionForPartsBin)('scripting' additionsToViewerCategories authoringPrototype)!!FlexMorph class reorganize!('no messages')!!FatBitsPaint class reorganize!('no messages')!!ColorPickerMorph class reorganize!('as yet unclassified' perniciousBorderColor)('class initialization' initialize)!!BookPageThumbnailMorph class reorganize!('no messages')!!SketchMorph class reorganize!('instance creation' exampleBackgroundSketch fromFile: fromStream: withForm:)('new-morph participation' includeInNewMorphMenu)('scripting' additionsToViewerCategories)!!MultiuserTinyPaint reorganize!('event handling' handlesMouseDown: mouseDown: mouseMove:)('initialization' defaultColor initialize)('menu' brushColor:hand: clear fill: penSize:hand: setPenColor: setPenSize:)('menus' addCustomMenuItems:hand:)('private' createDrawStateFor:)!!MorphThumbnail reorganize!('as yet unclassified' computeThumbnail grabOriginal morphRepresented: revealOriginal smaller)('copying' veryDeepFixupWith: veryDeepInner:)('initialization' defaultColor initialize)('menus' addCustomMenuItems:hand:)('naming' innocuousName)('parts bin' isPartsDonor isPartsDonor: partRepresented)('thumbnail' morphRepresented representativeNoTallerThan:norWiderThan:thumbnailHeight:)!!JoystickMorph reorganize!('accessing' amount angle leftRight upDown)('event handling' handlesMouseDown: mouseMove: mouseUp:)('initialization' initialize)('menu' setXRange setYRange stopTrackingJoystick toggleAutoCenter trackRealJoystick)('menus' addCustomMenuItems:hand:)('other' moveHandleToCenter)('parts bin' initializeToStandAlone)('stepping and presenter' step)('testing' stepTime)!!FlexMorph reorganize!('accessing' borderColor: borderWidth: form)('as yet unclassified' changeBorderColor: changeBorderWidth: loadOriginalForm originalMorph originalMorph: updateFromOriginal)('caching' releaseCachedState)('drawing' drawOn: generateRotatedForm)('geometry' extent:)('initialization' initialize)('layout' layoutChanged)('menus' addCustomMenuItems:hand:)!!FatBitsPaint reorganize!('drawing' drawOn:)('event handling' handlesMouseDown: mouseDown: mouseMove:)('events' mouseDownDefault: mouseDownSelection: mouseMovePaintBrushMode: pointGriddedFromEvent: toolMenu:)('geometry testing' containsPoint:)('initialization' defaultColor editForm: initialize openWith: setCurrentToolTo: toolsForPaintBrush toolsForSelection)('menu' accept backgroundColor: brushColor: copySelection cutSelection editSelection fileOut fill inspectForm magnification: mouseMoveSelectionMode: pasteSelection penSize: revert selectionAsForm selectionMenu: setBackgroundColor: setMagnification: setPenColor: setPenSize: unmagnifiedForm)('menus' addCustomMenuItems:hand:)!!ColorPickerMorph reorganize!('accessing' argument argument: deleteOnMouseUp deleteOnMouseUp: locationIndicator originalColor: selectedColor selector selector: sourceHand sourceHand: target target: updateContinuously updateContinuously:)('drawing' drawOn:)('e-toy support' isCandidateForAutomaticViewing)('event handling' handlesMouseDown: inhibitDragging mouseDown: mouseUp:)('geometry testing' containsPoint:)('halos and balloon help' isLikelyRecipientForMouseOverHalos)('initialization' buildChartForm choseModalityFromPreference initialize initializeForPropertiesPanel initializeModal: updateSelectorDisplay)('menu' pickUpColorFor: toggleDeleteOnMouseUp toggleUpdateContinuously)('menus' addCustomMenuItems:hand:)('other' addToWorld:near: bestPositionNear:inWorld: indicateColorUnderMouse putUpFor:near: trackColorUnderMouse)('stepping and presenter' step)('submorphs-add/remove' delete)('testing' stepTime)('private' anchorAndRunModeless: argumentsWith: deleteAllBalloons modalBalloonHelpAtPoint: pickColorAt: positionOfColor: trackColorAt: updateAlpha: updateColor:feedbackColor: updateTargetColor updateTargetColorWith:)!BookPageThumbnailMorph removeSelector: #addMorphsTo:pianoRoll:eventTime:betweenTime:and:!BookPageThumbnailMorph removeSelector: #justDroppedIntoPianoRoll:event:!BookPageThumbnailMorph removeSelector: #pauseFrom:!BookPageThumbnailMorph removeSelector: #resetFrom:!BookPageThumbnailMorph removeSelector: #resumeFrom:!!BookPageThumbnailMorph reorganize!('as yet unclassified' bookMorph computeThumbnail doPageFlip inBook: makeFlexMorphFor: page page: pageMorph:inBook: pageNumber:inBook: setPageSound: setPageVisual: smaller toggleBookmark)('copying' veryDeepFixupWith: veryDeepInner:)('event handling' handlesMouseDown: mouseDown:)('fileIn/Out' objectsInMemory)('initialization' defaultColor initialize)('menus' addCustomMenuItems:hand:)('objects from disk' objectForDataStream:)('piano rolls' encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick:)!SketchMorph removeSelector: #wantsRecolorHandle!!SketchMorph reorganize!('accessing' form form: framesToDwell framesToDwell: nominalForm: originalForm: rotatedForm scaleFactor scalePoint scalePoint: setNewFormFrom: useInterpolation useInterpolation: wearCostume:)('caching' releaseCachedState)('card in a stack' couldHoldSeparateDataForEachInstance)('drawing' canBeEnlargedWithB3D drawHighResolutionOn:in: drawInterpolatedImage:on: drawOn: drawPostscriptOn: generateInterpolatedForm generateRotatedForm)('e-toy support' acquirePlayerSimilarTo: appearsToBeSameCostumeAs: asWearableCostume baseGraphic baseGraphic: rotationStyle rotationStyle:)('geometry' extent:)('geometry eToy' forwardDirection: heading:)('geometry testing' containsPoint:)('halos and balloon help' isLikelyRecipientForMouseOverHalos wantsDirectionHandles wantsDirectionHandles:)('initialization' initialize initializeWith:)('layout' layoutChanged)('menu' addBorderToShape: callThisBaseGraphic editDrawing editDrawingIn:forBackground: erasePixelsOfColor: insertIntoMovie: recolorPixelsOfColor: reduceColorPalette: restoreBaseGraphic restoreBaseGraphicFromMenu setRotationStyle toggleInterpolation useInterpolationString)('menus' addCustomMenuItems:hand: addFillStyleMenuItems:hand: addToggleItemsToHaloMenu: collapse)('objects from disk' convertToCurrentVersion:refStream:)('other' newForm: replaceSelfWithMovie)('parts bin' initializeToStandAlone)('pen support' clearExtent:fillColor: penOnMyForm revealPenStrokes)('player' currentDataValue variableDocks)('testing' basicType canDrawAtHigherResolution)!!SketchEditorMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!SketchEditorMorph removeSelector: #initialize!!SketchEditorMorph reorganize!('Nebraska support' get:for: getActionFor: getBrushFor: getColorFor: getCursorFor: getNibFor: set:for:to: valuesForHand: valuesForHandIfPresent:)('WiW support' morphicLayerNumber)('access' enclosingPasteUpMorph hostView painting palette registrationPoint registrationPoint: ticksToDwell ticksToDwell:)('accessing' forwardDirection)('actions & preps' clear ellipse: erase: erasePrep: fill: flipHoriz: flipVert: forward:direction: line: notes paint: pickup: pickupMouseUp: polyEdit: polyEditing polyEditing: polyFreeze polyNew: polygon: rect: render: replaceOnly: restoreRect: rotateBy: rotateDone: rotateScalePrep: scaleBy: shiftConstrainPoint: showDirType stamp: star: toggleDirType:in:)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' drawOn:)('e-toy support' rotationStyle)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp:)('initialization' defaultColor initializeFor:inBounds:pasteUpMorph: initializeFor:inBounds:pasteUpMorph:paintBoxPosition:)('palette handling' cancelPainting:evt: clearPainting: dimTheWindow paintBoxChanged: paletteAttached: paletteDetached: savePainting:evt: undoPainting:evt:)('start & finish' addRotationScaleHandles afterNewPicDo:ifNoBits: cancel: cancelOutOfPainting deleteSelfAndSubordinates deliverPainting:evt: prepareToPaint: save: setRotations: undo: verifyState:)!!SimpleSwitchMorph class reorganize!('no messages')!!SimpleSwitchMorph reorganize!('as yet unclassified' offColor offColor: onColor onColor: setSwitchState:)('button' doButtonAction)('copying' updateReferencesUsing:)('event handling' mouseDown: mouseMove: mouseUp:)('initialization' initialize initializeWithLabel:)!!EToyHierarchicalTextMorph class reorganize!('instance creation' new on:list:selected:changeSelected:menu:keystroke:)!!SimpleHierarchicalListMorph class reorganize!('instance creation' on:list:selected:changeSelected: on:list:selected:changeSelected:menu: on:list:selected:changeSelected:menu:keystroke:)!!EToyHierarchicalTextMorph reorganize!('as yet unclassified' adjustSubmorphPositions indentingItemClass)('event handling' keyStroke:)('geometry' extent:)('initialization' defaultColor initialize)('selection' selectedMorph:)!!SimpleHierarchicalListMorph reorganize!('accessing' itemFromPoint:)('as yet unclassified' addMorphsTo:from:allowSorting:withExpandedItems:atLevel: addSubmorphsAfter:fromCollection:allowSorting: adjustSubmorphPositions columns columns: expandedForm getCurrentSelectionItem indentingItemClass insertNewMorphs: notExpandedForm noteRemovalOfAll: selectionOneOf: sortingSelector:)('debug and other' installModelIn:)('drawing' drawOn: highlightSelection unhighlightSelection)('dropping/grabbing' potentialDropMorph potentialDropMorph: resetPotentialDropMorph wantsDroppedMorph:event:)('event handling' handlesKeyboard: handlesMouseOverDragging: keyStroke: mouseDown: mouseEnter: mouseEnterDragging: mouseLeaveDragging: mouseMove: mouseUp: startDrag:)('events' expand:to: expandAll expandAll: expandAll:except: toggleExpandedState:event:)('events-processing' handleMouseMove:)('geometry' extent: scrollDeltaHeight)('initialization' autoDeselect: currentlyExpanded initialize list: listItemHeight on:list:selected:changeSelected:menu:keystroke:)('layout' acceptDroppingMorph:event:)('model access' getList)('obsolete' mouseDown:onItem: mouseEnterDragging:onItem: mouseLeaveDragging:onItem: removeObsoleteEventHandlers startDrag:onItem:)('selection' maximumSelection minimumSelection numSelectionsInView selectedMorph selectedMorph: selection: selectionIndex: setSelectedMorph:)('updating' update:)!!SimpleButtonDelayedMenuMorph class reorganize!('no messages')!!ScriptActivationButton class reorganize!('scripting' additionsToViewerCategories)!!IconicButton class reorganize!('no messages')!!ChatButtonMorph class reorganize!('no messages')!!SimpleButtonMorph class reorganize!('as yet unclassified' newWithLabel:)('printing' defaultNameStemForInstances)('scripting' additionsToViewerCategories authoringPrototype)!SimpleButtonDelayedMenuMorph removeSelector: #color:!!SimpleButtonDelayedMenuMorph reorganize!('event handling' handlesMouseStillDown: mouseDown: mouseStillDown: mouseUp:)!!ScriptActivationButton reorganize!('as yet unclassified' establishLabelWording)('menu' setLabel)('menus' addCustomMenuItems:hand:)('scripting' bringUpToDate isTileScriptingElement)!!IconicButton reorganize!('accessing' borderInset borderRaised)('as yet unclassified' labelFromString: labelGraphic: shedSelvedge)('initialization' borderNormal borderThick buttonSetup initialize initializeToShow:withLabel:andSend:to: initializeWithThumbnail:withLabel:andSend:to: setDefaultLabel stationarySetup)('menu' addLabelItemsTo:hand:)!ChatButtonMorph removeSelector: #setDefaultLabel!!ChatButtonMorph reorganize!('accessing' actionDownSelector: actionUpSelector: labelDown: labelUp:)('event handling' mouseDown: mouseUp:)('events' doButtonDownAction doButtonUpAction)!!SimpleButtonMorph reorganize!('accessing' actionSelector actionSelector: arguments arguments: fitContents label label: label:font: labelString: target target:)('button' doButtonAction)('copying' recolor: updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('e-toy support' adaptToWorld:)('event handling' handlesMouseDown: handlesMouseStillDown: mouseDown: mouseMove: mouseStillDown: mouseUp:)('geometry' extent:)('initialization' initialize initializeAllButLabel initializeWithLabel: setDefaultLabel)('menu' addLabelItemsTo:hand: setActWhen setActionSelector setArguments setLabel setPageSound: setPageVisual: setTarget:)('menus' addCustomMenuItems:hand:)('objects from disk' objectForDataStream:)('submorphs-add/remove' actWhen actWhen:)('visual properties' updateVisualState:)!!RaisedBorder class reorganize!('no messages')!!InsetBorder class reorganize!('no messages')!!ComplexBorder class reorganize!('instance creation' style:)!!SimpleBorder class reorganize!('no messages')!!RaisedBorder reorganize!('accessing' bottomRightColor colorsAtCorners style topLeftColor)('color tracking' trackColorFrom:)!!InsetBorder reorganize!('accessing' bottomRightColor colorsAtCorners style topLeftColor)('color tracking' trackColorFrom:)!!ComplexBorder reorganize!('accessing' colors style style: widthForRounding)('color tracking' trackColorFrom:)('drawing' drawLineFrom:to:on: drawPolyPatchFrom:to:on:usingEnds: framePolygon2:on: framePolygon:on: frameRectangle:on:)('initialize' releaseCachedState)('testing' isComplex)('private' colorsForDirection: computeAltFramedColors computeAltInsetColors computeAltRaisedColors computeColors computeFramedColors computeInsetColors computeRaisedColors fillStyleForDirection: intersectFrom:with:to:with:)!!SimpleBorder reorganize!('accessing' baseColor baseColor: bottomRightColor color color: style topLeftColor width width:)('drawing' drawLineFrom:to:on: frameRectangle:on:)!!ShadowDrawingCanvas class reorganize!('no messages')!!ShadowDrawingCanvas reorganize!('accessing' shadowColor shadowColor:)('initialization' on:)('testing' isShadowDrawing)('private' image:at:sourceRect:rule: mapColor:)!!SelectionMorph class reorganize!('no messages')!!SelectionMorph reorganize!('accessing' borderColor: borderWidth:)('drawing' drawOn:)('dropping/grabbing' aboutToBeGrabbedBy: justDroppedInto:event: slideToTrash:)('geometry' bounds: extent:)('halo commands' addOrRemoveItems: alignBottomEdges alignCentersHorizontally alignCentersVertically alignLeftEdges alignRightEdges alignTopEdges doDup:fromHalo:handle: organizeIntoColumn organizeIntoRow)('halos and balloon help' addHandlesTo:box: addOptionalHandlesTo:box: balloonHelpTextForHandle: hasHalo:)('initialization' defaultBorderColor defaultBorderWidth defaultColor extendByHand: extendByHandPlus: initialize)('menus' addCustomMenuItems:hand: maybeAddCollapseItemTo:)('submorphs-add/remove' dismissViaHalo)('undo' borderColorForItems: borderWidthForItems: fillStyleForItems: refineUndoTarget:selector:arguments:in: undoMove:redo:owner:bounds:predecessor:)('visual properties' fillStyle:)('private' doneExtending privateFullMoveBy: selectSubmorphsOf: selectedItems setOtherSelection: setSelectedItems:)!!ScrollingToolHolder class reorganize!('no messages')!!ScrollingToolHolder reorganize!('as yet unclassified' clear normalize otherButtonFor: pickupButtons pickupButtons: remove: scroll: stampButtons stampButtons: stampForm:for: stampFormFor: updateReferencesUsing:)!!ScrollableField class reorganize!('parts bin' descriptionForPartsBin)!!ScrollableField reorganize!('contents' setMyText:)('parts bin' initializeToStandAlone)!!PluggableTextMorphWithModel class reorganize!('scripting' authoringPrototype)!!MethodMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!AcceptableCleanTextMorph class reorganize!('no messages')!!PluggableTextMorph class reorganize!('as yet unclassified' on:text:accept: on:text:accept:readSelection:menu:)!!PluggableMultiColumnListMorphByItem class reorganize!('no messages')!!PluggableMultiColumnListMorph class reorganize!('no messages')!!PluggableMessageCategoryListMorph class reorganize!('as yet unclassified' on:list:selected:changeSelected:menu:keystroke:getRawListSelector:)!!PluggableListMorphOfMany class reorganize!('instance creation' on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:menu: on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:menu:keystroke:)!!PluggableListMorphByItem class reorganize!('no messages')!!ListComponent class reorganize!('no messages')!!PluggableListMorph class reorganize!('instance creation' on:list:selected:changeSelected: on:list:selected:changeSelected:menu: on:list:selected:changeSelected:menu:keystroke:)!!GeeMailMorph class reorganize!('new-morph participation' includeInNewMorphMenu)('parts bin' descriptionForPartsBin)!!AlansTextPlusMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!ScrollPane class reorganize!('new-morph participation' includeInNewMorphMenu)!!PluggableTextMorphWithModel reorganize!('card in a stack' couldHoldSeparateDataForEachInstance)('contents' getMyText newTextContents: setMyText:)('initialization' initialize)('player' currentDataValue variableDocks)('submorphs-add/remove' delete)!!MethodMorph reorganize!('as yet unclassified' installRollBackButtons:)('initialization' initialize)('scrolling' showScrollBar)('stepping and presenter' step)('testing' stepTime)!!AcceptableCleanTextMorph reorganize!('menu commands' accept)!!PluggableTextMorph reorganize!('accessing' getTextSelector)('debug and other' installModelIn:)('dependents access' canDiscardEdits hasUnacceptedEdits)('drawing' drawOn: wantsFrameAdornments)('dropping/grabbing' wantsDroppedMorph:event:)('editor access' handleEdit: scrollSelectionIntoView scrollSelectionIntoView: selectAll setTextMorphToSelectAllOnMouseEnter)('event handling' handlesKeyboard: keyStroke: mouseEnter: mouseLeave:)('genie-dispatching' handleGesture:)('geometry' extent: extraScrollRange resetExtent scrollDeltaHeight)('initialization' acceptOnCR: editString: font: initialize on:text:accept:readSelection:menu:)('interactive error protocol' correctFrom:to:with: correctSelectionWithString: deselect nextTokenFrom:direction: notify:at:in: select selectFrom:to: selectInvisiblyFrom:to: selectionInterval)('layout' acceptDroppingMorph:event:)('menu commands' accept again browseChangeSetsWithSelector browseIt cancel changeStyle chooseAlignment classCommentsContainingIt classNamesContainingIt copySelection cut debugIt doIt explain exploreIt fileItIn find findAgain implementorsOfIt inspectIt languagePrefs methodNamesContainingIt methodSourceContainingIt methodStringsContainingit offerFontMenu paste pasteRecent presentSpecialMenu prettyPrint prettyPrintWithColor printIt printerSetup recognizeCharacters referencesToIt saveContentsInFile selectionAsTiles sendContentsToPrinter sendersOfIt setSearchString spawn tileForIt toggleAnnotationPaneSize translateIt undo verifyWordSpelling wordDefinition yellowButtonActivity)('model access' eToyGetMainFont getSelection getText selectionInterval: setSelection: setText: setTextColor: text)('scroll bar events' scrollBarMenuButtonPressed: yellowButtonActivity:)('transcript' appendEntry appendTextEtoy: bsText changeText: replaceSelectionWith:)('unaccepted edits' askBeforeDiscardingEdits: hasEditingConflicts hasEditingConflicts: hasUnacceptedEdits: promptForCancel)('updating' update:)!!PluggableMultiColumnListMorphByItem reorganize!('initialization' list:)('model access' changeModelSelection: getCurrentSelectionIndex)!!PluggableMultiColumnListMorph reorganize!('accessing' itemFromPoint:)('drawing' drawOn: highlightSelection unhighlightSelection)('initialization' calculateColumnOffsetsFrom: calculateColumnWidthsFrom: createMorphicListsFrom: layoutMorphicLists: list:)('selection' selectionIndex:)!!PluggableMessageCategoryListMorph reorganize!('as yet unclassified' on:list:selected:changeSelected:menu:keystroke:getRawListSelector:)('model access' getList)('updating' verifyContents)!PluggableListMorphOfMany removeSelector: #mouseDown:onItem:!PluggableListMorphOfMany removeSelector: #mouseEnterDragging:onItem:!PluggableListMorphOfMany removeSelector: #mouseUp:onItem:!!PluggableListMorphOfMany reorganize!('drawing' drawOn: listSelectionAt: listSelectionAt:put:)('event handling' mouseDown: mouseMove: mouseUp:)('initialization' list: on:list:primarySelection:changePrimarySelection:listSelection:changeListSelection:menu:keystroke:)('updating' update:)!!PluggableListMorphByItem reorganize!('initialization' list:)('model access' changeModelSelection: getCurrentSelectionIndex)!!ListComponent reorganize!('components' initFromPinSpecs initPinSpecs)('initialization' list:)('model access' changeModelSelection:)!PluggableListMorph removeSelector: #wantsKeyboardFocusFor:!!PluggableListMorph reorganize!('accessing' highlightSelector highlightSelector: itemFromPoint:)('debug and other' installModelIn:)('drag and drop' potentialDropMorph potentialDropMorph: resetPotentialDropMorph)('drawing' drawOn: highlightSelection superDrawOn: unhighlightSelection)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' doubleClick: handlesKeyboard: handlesMouseOverDragging: keyStroke: keyboardFocusChange: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp: startDrag:)('events' handlesBasicKeys)('events-processing' handleMouseMove:)('geometry' scrollDeltaHeight)('initialization' autoDeselect: doubleClickSelector: font font: getListSelector: initForKeystrokes keystrokeActionSelector: list: listItemHeight on:list:selected:changeSelected:menu:keystroke:)('layout' acceptDroppingMorph:event:)('menu' getMenu:)('menus' addCustomMenuItems:hand: copyListToClipboard copySelectionToClipboard setListFont)('model access' basicKeyPressed: changeModelSelection: commandKeyTypedIntoMenu: getCurrentSelectionIndex getList modifierKeyPressed: specialKeyPressed:)('obsolete' doubleClick:onItem: mouseDown:onItem: mouseEnterDragging:onItem: mouseLeaveDragging:onItem: mouseUp:onItem: removeObsoleteEventHandlers startDrag:onItem:)('selection' getListSelector maximumSelection minimumSelection numSelectionsInView selectedMorph: selection selection: selectionIndex: setGetListSelector: setSelectedMorph:)('submorphs-accessing' allSubmorphNamesDo:)('updating' update: verifyContents)!!GeeMailMorph reorganize!('no messages')!AlansTextPlusMorph removeSelector: #defaultBounds!!AlansTextPlusMorph reorganize!('access' wantsSlot)('as yet unclassified' addGeeMailMenuItemsTo: adjustPasteUpSize allTextPlusMorphs convertToBook keepScrollBarAlways keepScrollbarString makeBookStyle: makeGalleyStyle mouseUp:inMorph: pageRectanglesForPrinting scrollSelectionIntoView:alignTop:inTextMorph: scrollToPage: scrollToYAbsolute: showPageBreaksString toggleKeepScrollbar togglePageBreaks)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' handlesMouseDown:)('geometry' extraScrollRange)('initialization' defaultColor initialize initializeThePasteUp)('layout' doLayoutIn:)('menu' getMenu:)('menus' addCustomMenuItems:hand: printPSToFile)('scroll bar events' scrollBarValue:)('scrolling' hideScrollBar)!ScrollPane removeSelector: #defaultBorderWidth!!ScrollPane reorganize!('access' flatColoredScrollBarLook retractableScrollBar scrollBarOnLeft scroller scroller: wantsSlot)('accessing' adoptPaneColor:)('event handling' handlesMouseDown: handlesMouseOver: hasFocus keyStroke: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp:)('geometry' extent: extraScrollRange innerBounds leftoverScrollRange resetExtent resizeScrollBar resizeScroller scrollBarFills: scrollBy: scrollDeltaHeight scrollbarWidth totalScrollRange unadjustedScrollRange)('geometry testing' containsPoint:)('initialization' defaultBorderColor initialize initializePreferences initializeScrollBar setScrollDeltas)('menu' getMenu: leftOrRight menuTitleSelector: retractable: retractableOrNot scrollBarOnLeft:)('menus' addCustomMenuItems:hand:)('pane events' scrollByKeyboard:)('scroll bar events' scrollBarMenuButtonPressed: scrollBarValue: shiftedTextPaneMenuRequest shiftedYellowButtonActivity unshiftedYellowButtonActivity yellowButtonActivity:)('scrolling' hideOrShowScrollBar hideScrollBar hideScrollBarIndefinitely isRetractableScrollbarShowing isScrollable isScrollbarShowing isScrolled isScrolledFromTop showScrollBar)!!ScriptingDomain class reorganize!('no messages')!!ScriptingDomain reorganize!('user interface' addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor initialExtent)!!ScriptStatusLine class reorganize!('no messages')!!ScriptStatusLine reorganize!('event handling' wantsKeyboardFocusFor:)!!ScriptStatusControl class reorganize!('no messages')!!ScriptStatusControl reorganize!('access' scriptInstantiation updateStatus)('initialization' assurePauseTickControlsShow initializeFor: intoWorld: maybeRemovePauseTickControls)('mouse gestures' mouseDownTick:onItem: mouseUpTick:onItem: offerTickingMenu: pausedUp:with: tickingUp:with:)('script status' scriptIsPaused scriptIsTicking)!!ScriptInstantiation class reorganize!('no messages')!!ScriptInstantiation reorganize!('anonymity' initializePermanentScriptFor:selector:)('frequency' frequency frequency: tickingRate tickingRate:)('misc' assignStatusToAllSiblings assignStatusToAllSiblingsIn: assureEventHandlerRepresentsStatus offerMenuIn: offerShiftedMenuIn: playersExternalName prepareToBeRunning statusControlRowIn: userScriptObject)('player & selector access' changeSelectorTo: player player: player:selector:status: selector selector:)('printing' printOn:)('running' pausedOrTicking runIfClosing runIfOpening runIfTicking: startRunningIfPaused stopTicking)('status control' chooseTriggerFrom: explainStatusAlternatives fireOnce presentScriptStatusPopUp presentTickingMenu resetToNormalIfCurrently: status status: statusControlMorph typeInTickingRate updateAllStatusMorphs updateStatusMorph:)!!BooleanScriptEditor class reorganize!('no messages')!!ScriptEditorMorph class reorganize!('instance creation' writingUniversalTiles writingUniversalTiles:)('new-morph participation' includeInNewMorphMenu)!!BooleanScriptEditor reorganize!('dropping/grabbing' wantsDroppedMorph:event:)('other' hibernate storeCodeOn:indent: unhibernate)!ScriptEditorMorph removeSelector: #defaultBorderColor!ScriptEditorMorph removeSelector: #setDefaultBorderCharacteristics!!ScriptEditorMorph reorganize!('access' morph myMorph scriptInstantiation)('buttons' actuallyDestroyScript addDestroyButtonTo: addDismissButtonTo: addYesNoToHand chooseFrequency chooseTrigger destroyScript dismiss editMethodDescription hasParameter install installWithNewLiteral makeIsolatedCodePane playerScripted replaceRow1 scriptName scriptTitle scriptee showSourceInScriptor tryMe updateStatus updateStatusMorph:)('caching' releaseCachedState)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' drawOn:)('dropping/grabbing' assureParameterTilesValid buttonRowForEditor prepareToUndoDropOf: removeSpaces repelsMorph:event: setParameterType: trackDropZones wantsDroppedMorph:event: willingToBeDiscarded)('e-toy support' adaptToWorld: isCandidateForAutomaticViewing isTileEditor objectViewed)('event handling' handlesMouseOver: handlesMouseOverDragging: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging:)('frequency' setFrequencyTo: typeInFrequency)('geometry' extent:)('initialization' defaultBorderWidth defaultColor initialize phrase: playerScripted: setMorph: setMorph:scriptName: updateHeader updateToPlayer:)('layout' acceptDroppingMorph:event:)('menu' autoFitOnOff autoFitString)('menus' addCustomMenuItems:hand:)('other' addParameter becomeTextuallyCoded ceaseHavingAParameter codeString explainStatusAlternatives handUserButtonDownTile handUserButtonUpTile handUserParameterTile handUserRandomTile handUserTileForSelf hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: hibernate insertUniversalTiles insertUniversalTilesForClass:selector: isEmpty isTextuallyCoded methodNodeMorph methodString modernize offerScriptorMenu recompileScript recreateScript reinsertSavedTiles: renameScript renameScriptTo: revertScriptVersion setScriptNameTo: setTimeStamp storeCodeOn:indent: tearOfButtonToFireScript tileRows timeStamp toggleWhetherShowingTiles unhibernate userScriptObject)('save & revert' revertToTileVersion saveScriptVersion savedTileVersionsCount)('scripting' bringUpToDate isTileScriptingElement)('submorphs-accessing' indexOfMorphAbove:)('submorphs-add/remove' dismissViaHalo)('testing' stepTime typeForParameter)('textually-coded scripts' showingMethodPane showingMethodPane:)('tiles from method' fromExistingMethod:forPlayer:)('private' addNewRow insertTileRow:after: removeEmptyRows rowInsertionIndexFor: scriptEdited)!!ScreeningMorph class reorganize!('no messages')!!ScreeningMorph reorganize!('drawing' fullDrawOn:)('geometry testing' containsPoint:)('initialization' initialize)('layout' layoutChanged)('menu' chooseBlockingColor choosePassingColor exchange showScreenOnly showScreenOverSource showScreened showSourceOnly)('menus' addCustomMenuItems:hand:)('submorphs-add/remove' addMorph:)('private' privateRemoveMorph: screenForm screenMorph sourceMorph)!!ScorePlayerMorph class reorganize!('class initialization' initialize playMidiFile: servicePlayMidiFile)('fileIn/Out' fileReaderServicesForFile:suffix: services)('initialize-release' unload)('parts bin' descriptionForPartsBin)('system hookup' onMIDIFileNamed: openOn:title:)!!ScorePlayerMorph reorganize!('accessing' scorePlayer)('controls' atTrack:from:selectInstrument: rewind setLogRate:)('initialization' closeMIDIPort defaultBorderWidth defaultColor initialize onScorePlayer:title: openMIDIFile openMIDIPort)('layout' makeControls makeMIDIController: makePianoRoll makeRow panAndVolControlsFor: rateControl scrollControl showResumeButtonInTheWorld standaloneResumeButton trackControlsFor: trackNumAndMuteButtonFor: volumeControl)('menu' instrumentChoicesForTrack: invokeMenu makeAPauseEvent: saveAsAIFF saveAsSunAudio saveAsWAV updateInstrumentsFromLibraryExcept:)('rounding' wantsRoundedCorners)('stepping and presenter' step)!!ScaleMorph class reorganize!('examples' example1 example2 example3 example4)!!ScaleMorph reorganize!('accessing' caption caption: captionAbove: labelsAbove: majorTickLength: minorTickLength: start: stop: tickPrintBlock:)('drawing' buildLabels drawMajorTicksOn: drawMinorTicksOn: drawOn: drawTicksOn:)('geometry' checkExtent: extent:)('initialization' defaultBorderWidth defaultColor initialize start:stop:minorTick:minorTickLength:majorTick:majorTickLength: start:stop:minorTick:minorTickLength:majorTick:majorTickLength:caption:tickPrintBlock: start:stop:minorTick:minorTickLength:majorTick:majorTickLength:caption:tickPrintBlock:labelsAbove:captionAbove:)('objects from disk' convertToCurrentVersion:refStream:)('stepping and presenter' start stop)!!RulerMorph class reorganize!('parts bin' descriptionForPartsBin)!RulerMorph removeSelector: #initialize!!RulerMorph reorganize!('drawing' drawOn:)('initialization' defaultBorderWidth defaultColor)!!RemoteHandMorph class reorganize!('no messages')!!RemoteHandMorph reorganize!('connections' lastEventTransmitted lastEventTransmitted: lastWorldExtent lastWorldExtent: readyToTransmit remoteHostAddress startListening startTransmittingEvents startTransmittingEventsTo: stopListening stopTransmittingEvents)('drawing' drawOn: needsToBeDrawn)('event handling' processEvents transmitEvent:)('events-processing' handleListenEvent:)('geometry' worldBounds)('initialization' initialize)('other' withdrawFromWorld)('private' appendNewDataToReceiveBuffer getNextRemoteEvent receiveData)!!RemoteControlledHandMorph class reorganize!('instance creation' on:)!!RemoteControlledHandMorph reorganize!('drawing' needsToBeDrawn)('event handling' processEvents)('events' convertRemoteClientToBuffered queueEvent: setViewExtent:)('geometry' worldBounds)('initialization' decoder: initialize nebraskaClient:)!!RemoteCanvas class reorganize!('instance creation' connection:clipRect:transform:)!!RemoteCanvas reorganize!('Nebraska/embeddedWorlds' transform2By:clippingTo:during:smoothing:)('accessing' clipRect contentsOfArea:into: extent origin shadowColor shadowColor:)('as yet unclassified' apply:)('drawing' balloonFillOval:fillStyle:borderWidth:borderColor: balloonFillRectangle:fillStyle: infiniteFillRectangle:fillStyle: line:to:width:color: paragraph:bounds:color:)('drawing-general' roundCornersOf:in:during:)('drawing-images' stencil:at:sourceRect:color:)('drawing-ovals' fillOval:color:borderWidth:borderColor: fillOval:fillStyle:borderWidth:borderColor:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor:)('drawing-rectangles' fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor:)('drawing-support' clipBy:during: privateShadowColor: showAt:invalidRects: transformBy:clippingTo:during:smoothing: translateBy:during:)('drawing-text' drawString:from:to:in:font:color:)('initialization' asBufferedCanvas connection:clipRect:transform: flush purgeOutputQueue)('misc' processIO)('nil' backlog)('other' forceToScreen:)('private' drawCommand: image:at:sourceRect:rule:)!!FlapTab class reorganize!('as yet unclassified' givenID:matches:)('new-morph participation' includeInNewMorphMenu)('printing' defaultNameStemForInstances)!!ReferenceMorph class reorganize!('instance creation' forMorph: forMorph:font:)('printing' defaultNameStemForInstances)('scripting' additionsToViewerCategories)!FlapTab removeSelector: #isCurrentlyGraphical!!FlapTab reorganize!('WiW support' morphicLayerNumber)('access' acquirePlausibleFlapID flapID flapID: flapIDOrNil flapShowing orientation referentThickness tabThickness)('accessing' labelString)('change reporting' ownerChanged)('classification' isFlapTab)('disused options' inboard inboard: slidesOtherObjects)('e-toy support' isCandidateForAutomaticViewing succeededInRevealing:)('edge' applyEdgeFractionWithin: computeEdgeFraction edgeFraction edgeFraction: edgeString edgeToAdhereTo edgeToAdhereTo: ifVertical:ifHorizontal: setEdge: setEdgeToAdhereTo)('event handling' mouseMove: mouseUp:)('events' tabSelected)('genie-menu' addGenieMenuItems:hand:)('globalness' isGlobalFlap isGlobalFlapString toggleIsGlobalFlap)('graphical tabs' graphicalTab graphicalTabString)('initialization' adaptToWorld initialize provideDefaultFlapIDBasedOn: setName:edge:color:)('layout' layoutChanged)('menu' applyThickness: changeFlapColor changeTabText destroyFlap existingWording flapMenuTitle isCurrentlyTextual preserveDetails sharedFlapsAllowed thicknessString useTextualTab wording)('menus' addCustomMenuItems:hand: addTitleForHaloMenu: changeColor)('misc' fitContents)('miscellaneous' balloonTextForFlapsMenu)('mouseover & dragover' arrangeToPopOutOnDragOver: arrangeToPopOutOnMouseOver: dragoverString makeNewDrawing: mouseoverString setToPopOutOnDragOver: setToPopOutOnMouseOver: startOrFinishDrawing: toggleDragOverBehavior toggleMouseOverBehavior)('objects from disk' objectForDataStream:)('parts bin' partsBinString togglePartsBinMode)('positioning' adjustPositionVisAVisFlap fitOnScreen positionObject: positionObject:atEdgeOf: positionReferent spanWorld stickOntoReferent transposeParts)('printing' printOn:)('rounding' roundedCorners wantsRoundedCorners)('show & hide' adjustPositionAfterHidingFlap hideFlap hideFlapUnlessBearingHalo hideFlapUnlessOverReferent lastReferentThickness: maybeHideFlapOnMouseLeave maybeHideFlapOnMouseLeaveDragging openFully showFlap showFlapIfHandLaden:)('solid tabs' applyTabThickness: changeTabSolidity changeTabThickness isCurrentlySolid notSolid solidTab solidTabString useSolidTab)('submorphs-add/remove' dismissViaHalo)('textual tabs' assumeString:font:orientation:color: reformatTextualTab textualTab textualTabString useStringTab:)('thumbnail' permitsThumbnailing)!!ReferenceMorph reorganize!('accessing' borderWidth: highlight isCurrentlyGraphical morphToInstall referent referent: unHighlight)('button' doButtonAction)('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('events' tabSelected)('initialization' defaultBorderWidth defaultColor initialize)('layout' layoutChanged)('menu' changeTabGraphic changeTabText existingWording graphicalMorphForTab isCurrentlyTextual preserveDetails setLabelFontTo: useGraphicalTab useTextualTab)('menus' addCustomMenuItems:hand:)('misc' fitContents isHighlighted morphToInstall: morphToInstall:font: sorterToken)('naming' setNameTo:)('submorphs-accessing' allNonSubmorphMorphs)!!RecordingControlsMorph class reorganize!('parts bin' descriptionForPartsBin)!!ProjectSorterMorph class reorganize!('no messages')!!NebraskaNavigationMorph class reorganize!('no messages')!!KidNavigationMorph class reorganize!('no messages')!!ProjectNavigationMorph class reorganize!('as yet unclassified' preferredNavigator)!!ProgressMorph class reorganize!('example' example)('instance creation' label:)!!PluggableCollectionMorph class reorganize!('instance creation' collection: model:collectionOrSelector:okaySelector:cancelSelector:addSelector:deleteSelector:gotoSelector:menuSelector:changeSelector:valueMorphSelector:keyMorphSelector:objectToStringSelector:releaseSelector:balloonTextSelector:)!!PluggableButtonMorph class reorganize!('example' example)('instance creation' on: on:getState:action: on:getState:action:label: on:getState:action:label:menu:)!!PianoRollScoreMorph class reorganize!('no messages')!!MIDIPianoKeyboardMorph class reorganize!('no messages')!!KeyboardMorphForInput class reorganize!('no messages')!!PianoKeyboardMorph class reorganize!('parts bin' descriptionForPartsBin)!!PhraseWrapperMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!PhonemeRecognizerMorph class reorganize!('no messages')!!ObjectsTool class reorganize!('parts bin' descriptionForPartsBin)!!ListViewLine class reorganize!('no messages')!!ClassRepresentativeMorph class reorganize!('no messages')!!ObjectRepresentativeMorph class reorganize!('no messages')!!ObjectPropertiesMorph class reorganize!('no messages')!!NetworkTerminalBorderMorph class reorganize!('no messages')!!NebraskaServerMorph class reorganize!('as yet unclassified' killOldServers serveWorld: serveWorld:onPort:)!!MoviePlayerMorph class reorganize!('class initialization' initialize)('fileIn/Out' fileReaderServicesForFile:suffix: openAsMovie: serviceOpenAsMovie services)('initialize-release' unload)!!MorphExample class reorganize!('no messages')!!MonthMorph class reorganize!('as yet unclassified' newWithModel:)!!MidiInputMorph class reorganize!('no messages')!!MVCMenuMorph class reorganize!('instance creation' from:title:)!!DumberMenuMorph class reorganize!('no messages')!!MenuMorph class reorganize!('example' example)('images' closeBoxImage pushPinImage)('instance creation' entitled:)!!MPEGMoviePlayerMorph class reorganize!('class initialization' initialize)('fileIn/Out' fileReaderServicesForFile:suffix: services)('parts bin' descriptionForPartsBin)!!MIDIControllerMorph class reorganize!('no messages')!!KlattFrameMorph class reorganize!('no messages')!!InterimSoundMorph class reorganize!('no messages')!!HeadingMorph class reorganize!('no messages')!!GraphicalDictionaryMenu class reorganize!('example' example)!!GraphicalMenu class reorganize!('no messages')!!GraphMorph class reorganize!('parts bin' descriptionForPartsBin)('scripting' additionsToViewerCategories)!!GradientFillMorph class reorganize!('no messages')!!ButtonPropertiesMorph class reorganize!('no messages')!!GenericPropertiesMorph class reorganize!('no messages')!!GeePrinterDialogMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!GeeBookMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!FloatingBookControlsMorph class reorganize!('no messages')!!FillInTheBlankMorphWithCharMenu class reorganize!('no messages')!!FillInTheBlankMorphWithDictMenu class reorganize!('default constants' defaultAnswerExtent)('instance creation' request:initialAnswer:centerAt:inWorld:onCancelReturn:)!!FillInTheBlankMorph class reorganize!('default constants' defaultAnswerExtent)('instance creation' request: request:initialAnswer: request:initialAnswer:centerAt: request:initialAnswer:centerAt:inWorld: request:initialAnswer:centerAt:inWorld:onCancelReturn: request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR: request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerExtent: request:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:answerHeight: requestPassword: requestPassword:initialAnswer:centerAt:inWorld:onCancelReturn:acceptOnCR:)!!EventRecorderMorph class reorganize!('class initialization' initialize)('fileIn/Out' fileReaderServicesForFile:suffix: services)('initialize-release' unload)('instance creation' fromFileNamed: openTapeFromFile: readFrom:)('parts bin' descriptionForPartsBin)!!EtoyLoginMorph class reorganize!('instance creation' loginAndDo:ifCanceled:)!!EnvelopeEditorMorph class reorganize!('as yet unclassified' openOn:title:)!!EmbeddedWorldBorderMorph class reorganize!('no messages')!!EToySenderMorph class reorganize!('as yet unclassified' instanceForIP: instanceForIP:inWorld: nameForIPAddress: pictureForIPAddress:)('parts bin' descriptionForPartsBin)!!EToyProjectQueryMorph class reorganize!('as yet unclassified' onServer: test1:)!!EToyProjectDetailsMorph class reorganize!('as yet unclassified' getFullInfoFor:ifValid:expandedFormat: test1:)!!EToyProjectRenamerMorph class reorganize!('as yet unclassified' validate:andDo:)!!EToyProjectHistoryMorph class reorganize!('parts bin' descriptionForPartsBin)!!EToyMultiChatMorph class reorganize!('as yet unclassified' chatWindowForIP:name:picture:inWorld:)('parts bin' descriptionForPartsBin)!!EToyMorphsWelcomeMorph class reorganize!('as yet unclassified' morphsWelcomeInWorld:)('parts bin' descriptionForPartsBin)!!EToyListenerMorph class reorganize!('as yet unclassified' addToGlobalIncomingQueue: bumpUpdateCounter commResult: commResultDeferred: confirmListening critical: ensureListenerInCurrentWorld flashIndicator: globalIncomingQueue globalIncomingQueueCopy isListening makeListeningToggle: makeListeningToggleNew: removeFromGlobalIncomingQueue: resetIndicator: startListening stopListening)('class initialization' initialize)('parts bin' descriptionForPartsBin)('system startup' shutDown: startUp:)!!EToyGenericDialogMorph class reorganize!('no messages')!!EToyGateKeeperMorph class reorganize!('as yet unclassified' acceptRequest:from:at: acceptableTypesFor: entryForIPAddress: knownIPAddresses updateCounter)('new-morph participation' includeInNewMorphMenu)!!EToyFridgeMorph class reorganize!('as yet unclassified' addRecipient: fridgeForm fridgeRecipients newItem: newItems removeRecipientWithIPAddress: updateCounter)('parts bin' descriptionForPartsBin)!!EToyChatMorph class reorganize!('as yet unclassified' chatFrom:name:text: chatWindowForIP:name:picture:inWorld: doChatsInternalToBadge instanceForIP:inWorld:)('parts bin' descriptionForPartsBin)!!EToyChatOrBadgeMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!AudioChatGUI class reorganize!('as yet unclassified' debugLog: handleNewAudioChat2From:sentBy:ipAddress: handleNewAudioChatFrom:sentBy:ipAddress: newAudioMessages newCompressedSoundFrom: numberOfNewMessages playNextAudioMessage playOnArrival)('class initialization' initialize)('creation' openAsMorph)('parts bin' descriptionForPartsBin)!!EToyCommunicatorMorph class reorganize!('as yet unclassified' allForIPAddress: instanceReport otherCleanup playArrivalSound)('new-morph participation' includeInNewMorphMenu)!!DoubleClickExample class reorganize!('parts bin' descriptionForPartsBin)!!CodecDemoMorph class reorganize!('no messages')!!CRDisplayPropertiesMorph class reorganize!('instance creation' properties:)!!CRAddFeatureMorph class reorganize!('instance creation' model:)!!BookMorph class reorganize!('booksAsProjects' makeBookOfProjects:named:)('class initialization' initialize)('fileIn/Out' fileReaderServicesForFile:suffix: openFromFile: serviceLoadAsBook services)('initialize-release' unload)('parts bin' descriptionForPartsBin)('scripting' additionsToViewerCategories authoringPrototype nextPageButton previousPageButton)('url' alreadyInFromUrl: grabURL: isInWorld:withUrl:)!!BooklikeMorph class reorganize!('as yet unclassified' turnOffSoundWhile:)('class initialization' initialize)!!BookPageSorterMorph class reorganize!('no messages')!!BasicButton class reorganize!('printing' defaultNameStemForInstances)!!BalloonRectangleMorph class reorganize!('no messages')!!AllScriptsTool class reorganize!('instance creation' allScriptsToolForActiveWorld launchAllScriptsToolFor:)('parts bin' descriptionForPartsBin)('printing' defaultNameStemForInstances)!!AlignmentMorphBob1 class reorganize!('no messages')!!AlignmentMorph class reorganize!('instance creation' columnPrototype inAColumn: inARow: newColumn newRow newSpacer: newVariableTransparentSpacer rowPrototype)('parts bin' supplementaryPartsDescriptions)('scripting' additionsToViewerCategories)!!AbstractMediaEventMorph class reorganize!('no messages')!!RectangleMorph class reorganize!('as yet unclassified' roundRectPrototype)('parts bin' descriptionForPartsBin diagonalPrototype gradientPrototype supplementaryPartsDescriptions)!!RecordingControlsMorph reorganize!('accessing' recorder)('button commands' done makeSoundMorph makeTile playback record trim)('copying' updateReferencesUsing:)('drawing' show)('initialization' addButtonRows initialize)('other' addRecordLevelSlider buttonName:action: makeRecordMeter makeStatusLight)('stepping and presenter' startStepping step stop stopStepping)('testing' stepTime)!ProjectSorterMorph removeSelector: #myColor!!ProjectSorterMorph reorganize!('as yet unclassified' addControls clickFromSorterEvent:morph: insertNewProject: morphsForMyContentsFrom:sizedTo: navigator:listOfPages: sorterMorphForProjectNamed:)('initialization' defaultBorderWidth defaultColor initialize)!NebraskaNavigationMorph removeSelector: #initialColor!!NebraskaNavigationMorph reorganize!('as yet unclassified' addButtons bufferNebraska buttonBuffered buttonScale currentNavigatorVersion fontForButtons nebraskaBorder: nebraskaTerminal: positionVertically quitNebraska toggleFullView)('dropping/grabbing' wantsToBeDroppedInto:)('initialization' defaultColor)('stepping and presenter' step)('the buttons' buttonQuit)!!KidNavigationMorph reorganize!('accessing' balloonText)('as yet unclassified' addButtons amountToShowWhenSmall colorForButtons fontForButtons)('event handling' handlesMouseDown: mouseEnter: mouseLeave: mouseUp:)('initialization' defaultColor initialize)('stepping and presenter' step)('the actions' quitSqueak)!ProjectNavigationMorph removeSelector: #initialColor!!ProjectNavigationMorph reorganize!('WiW support' morphicLayerNumber)('accessing' color:)('as yet unclassified' addButtons amountToShowWhenSmall checkForRebuild colorForButtons currentNavigatorVersion fontForButtons inFlapsSuppressedMode inFullScreenMode makeButton:balloonText:for: makeTheButtons orientationString orientedVertically positionVertically retractIfAppropriate showMenuFor:event: toggleOrientation)('dropping/grabbing' justDroppedInto:event:)('event handling' handlesMouseOver: mouseEnter: mouseLeave:)('initialization' defaultColor initialize openInWorld:)('menus' addCustomMenuItems:hand:)('stepping and presenter' step)('testing' stepTime wantsSteps)('the actions' doFindButtonMenuEvent: doNewPainting doPublishButtonMenuEvent: editProjectInfo findAProject findAProjectSimple findAnything fullScreenOff fullScreenOn getNewerVersionIfAvailable getSoundVolume gotoAnother newProject nextProject previousProject publishDifferent publishProject publishProjectAs publishStyle:forgetURL:withRename: quitSqueak setSoundVolume: shareThisWorld soundDownEvt:morph: soundStillDownEvt:morph: soundUpEvt:morph: tellAFriend toggleFlapsSuppressed undoLastCommand)('the buttons' buttonFind buttonFlaps buttonFullScreen buttonGoTo buttonNewProject buttonNewer buttonNext buttonPaint buttonPrev buttonPublish buttonQuit buttonShare buttonSound buttonTell buttonUndo findSomethingOnSuperSwiki speakerIcon)!!ProgressMorph reorganize!('accessing' done done: incrDone: label label: progress subLabel subLabel:)('initialization' initLabelMorph initProgressMorph initSubLabelMorph initialize setupMorphs)('private' fontOfPointSize: labelMorph subLabelMorph)!!PluggableCollectionMorph reorganize!('accessing' addSelector addSelector: balloonTextSelector balloonTextSelector: cancelSelector cancelSelector: changeSelector changeSelector: collectionOrSelector collectionOrSelector: collectionOrSelector:key: currentKey currentKeyMorph currentValue currentValueMorph deleteSelector deleteSelector: ensureLayout gotoSelector gotoSelector: hasLayout keyMorphSelector keyMorphSelector: menuSelector menuSelector: model model: objectToStringSelector objectToStringSelector: okaySelector okaySelector: releaseSelector releaseSelector: setKey: setKey:toString: setToValue: valueMorphSelector valueMorphSelector:)('buttons' addButton basicButton cancelButton deleteButton gotoButton menuButton nextButton okayButton prevButton)('initialization' initialize openInWorld:)('initialize-release' addButtonsTo:space: layout)('model access' addAction balloonText: cancelAction changeRequest deleteAction getCollection gotoAction menuAction nextAction objectToString: okayAction prevAction release: release:replaceBy: resendMenuAction: wrap:into:modelSelector:)('submorphs-add/remove' delete)('updating' update: updateAll updateCollection updateContents)('private' arrayOfDictionaryKeys: close collection collection: collectionKeys collectionKeys: currentIndex currentIndex: decrementIndex incrementIndex indexOfKey:toString: isAddAvailable isBalloonTextAvailable isCancelAvailable isChangeAvailable isCurrentIndexValid isDeleteAvailable isGotoAvailable isIndexValid: isMenuAvailable isModelAvailable isObjectToStringAvailable isOkayAvailable isReleaseAvailable keyAtIndex: keyMorph keyMorph: normalizeCurrentIndexRotate: normalizeIndex:in:rotate: normalizeIndex:rotate: objectToMorph: setCollection: setCollection:key: setKeyNoUpdate: setKeyNoUpdate:toString: setModel:collectionOrSelector:okaySelector:cancelSelector:addSelector:deleteSelector:gotoSelector:menuSelector:changeSelector:valueMorphSelector:keyMorphSelector:objectToStringSelector:releaseSelector:balloonTextSelector: valueAtIndex: valueAtKey: valueMorph valueMorph:)!!PluggableButtonMorph reorganize!('accessing' action: actionSelector askBeforeChanging askBeforeChanging: feedbackColor: label label: label:font: model: offColor offColor: onColor:offColor: performAction shortcutCharacter shortcutCharacter: triggerOnMouseDown triggerOnMouseDown:)('arguments' arguments: argumentsProvider:argumentsSelector:)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' drawOn:)('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('events' updateFeedbackForEvt:)('initialization' defaultBorderWidth defaultColor initialize)('initialize-release' on:getState:action:label:menu:)('updating' update:)('private' getMenu: getModelState invokeMenu:)!!PianoRollScoreMorph reorganize!('accessing' beatsPerMeasure: movieClipPlayer movieClipPlayer: notePerBeat: score scorePlayer selection selection: timeScale timeSignature:over:)('drawing' addNotes drawMeasureLinesOn: drawOn: drawStaffOn: isBlackKey: rebuildFromScore)('editing' appendEvent:fullDuration: copySelection cutSelection deleteSelection insertSelection insertTransposed)('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('geometry' contractTime expandTime extent: midiKeyForY: tickTimeAtCursor timeForX: xForTime: yForMidiKey:)('initialization' defaultBorderWidth defaultColor initialize on: updateLowestNote)('layout' acceptDroppingMorph:event: fullBounds layoutChanged)('menu' addKeyboard addMovieClipPlayer beatLinesOnOff invokeScoreMenu: measureLinesOnOff)('menus' addCustomMenuItems:hand:)('scrolling' autoScrollForX: goToTime: moveCursorToTime: notesInRect:)('stepping and presenter' step)('testing' stepTime)('private' privateRemoveMorph:)!!MIDIPianoKeyboardMorph reorganize!('as yet unclassified' closeMIDIPort makeMIDIController: openMIDIPort turnOffNote turnOnNote:)('initialization' initialize)('menus' addCustomMenuItems:hand:)('simple keyboard' mouseDownPitch:event:noteMorph: mouseUpPitch:event:noteMorph:)!!KeyboardMorphForInput reorganize!('events' soundForEvent:inTrack:)('initialization' addRecordingControls initialize pianoRoll:)('note controls' articulation:onOff: backspaceNote buildChord: deleteNotes durMod:onOff: duration:onOff: emitRest fullDuration noteDuration velocity)('simple keyboard' mouseDownPitch:event:noteMorph: mouseUpPitch:event:noteMorph:)!!PianoKeyboardMorph reorganize!('initialization' defaultColor initialize)('simple keyboard' buildKeyboard mouseDownEvent:noteMorph:pitch: mouseDownPitch:event:noteMorph: mouseMoveEvent:noteMorph:pitch: mouseMovePitch:event:noteMorph: mouseUpEvent:noteMorph:pitch: mouseUpPitch:event:noteMorph: soundPrototype:)!!PhraseWrapperMorph reorganize!('dropping/grabbing' repelsMorph:event:)('parts bin' isPartsBin)!!PhonemeRecognizerMorph reorganize!('accessing' currentPhonemeMouthPosition currentPhonemeName getMouthPosition)('analysis' findMatchFor:samplingRate:)('button and menu commands' addPhoneme changePhonemeDetails deletePhoneme invokeMenu makeTile matchSoundFile playPhoneme readPhonemes savePhonemes setSilentPhoneme showPhonemeFeatures startRecognizing stopRecognizing)('initialization' initialize)('stepping and presenter' step stopStepping)('testing' stepTime)('private' addButtonRows addLevelSlider addPhonemeDisplay addTitle buttonName:action: makeLevelMeter makeStatusLight promptForDetailsOfPhoneme: selectPhonemeFromMenu selectPhonemeFromMenu:)!!ObjectsTool reorganize!('alphabetic' alphabeticTabs installQuads:fromButton: showAlphabeticCategory:fromButton: showAlphabeticTabs)('categories' showCategories showCategory:fromButton: tabsForCategories)('initialization' initializeForFlap tweakAppearanceAfterModeShift)('major modes' modeSymbol modeSymbol: modeTabs)('menu' resetThumbnails)('menus' addCustomMenuItems:hand: presentHelp)('miscellaneous' setExtentFromHalo:)('parts bin' initializeToStandAlone)('search' newSearchPane searchPane searchPaneCharacter: setSearchStringFromSearchPane showMorphsMatchingSearchString showSearchPane)('tabs' initializeWithTabs: paneForTabs: prepareInitialAppearanceForTabs: tabsPane)!!ListViewLine reorganize!('e-toy support' listViewLineForFieldList:)('object represented' objectRepresented:)('thumbnail' morphRepresented)!!ClassRepresentativeMorph reorganize!('no messages')!!ObjectRepresentativeMorph reorganize!('as yet unclassified' objectRepresented: objectRepresented:labelString:)('macpal' objectRepresented)('naming' nameOfObjectRepresented)('scripting' categoriesForViewer)!!ObjectPropertiesMorph reorganize!('as yet unclassified' adjustTargetBorderWidth: adjustTargetGradientDirection: adjustTargetGradientOrigin: adjustTargetShadowOffset: doEnables makeTargetGradientFill makeTargetSolidFill numberOneColor numberOneColor: rebuild rebuildOptionalButtons targetBorderColor targetBorderColor: targetHasGradientFill targetHasSolidFill targetRadial tgt2ndGradientColor tgt2ndGradientColor: toggleTargetGradientFill toggleTargetRadial toggleTargetSolidFill)('initialization' defaultBorderColor defaultColor initialize)('panes' borderPrototype:help: paneFor2ndGradientColorPicker paneForBorderColorPicker paneForBorderStyle paneForBorderWidth paneForCornerRoundingToggle paneForDropShadowToggle paneForGradientDirection paneForGradientFillToggle paneForGradientOrigin paneForLockedToggle paneForMainColorPicker paneForRadialGradientToggle paneForShadowColorPicker paneForShadowOffset paneForSolidFillToggle paneForStickinessToggle toggleBorderStyle:with:from:)!!NetworkTerminalBorderMorph reorganize!('as yet unclassified' toggleFullView)('boxes' boxesAndColorsAndSelectors)('initialization' initialize)!!NebraskaServerMorph reorganize!('accessing' currentBacklogString currentStatusString server)('drawing' updateCurrentStatusString)('initialization' defaultColor initialize rebuild setColorsAndBorder toggleFull)('stepping and presenter' step)('submorphs-add/remove' delete)('testing' stepTime)('updating' update:)!!MoviePlayerMorph reorganize!('access' cueMorph fileName frameCount frameNumber: frameNumber:msSinceStart: msPerFrame msPerFrame: pageFormForFrame: relativePosition scorePlayer scorePlayer: setCueMorph: soundTrackFileName)('controls and layout' showHideSoundTrack)('copying' duplicate)('event handling' handlesMouseDown: mouseDown:)('geometry' extent: position:)('initialization' defaultBorderWidth defaultColor duplicateMore openFileNamed: openFileNamed:withScorePlayer:andPlayFrom: setInitialState stopSoundTrackIfAny)('menu' addSoundTrack endClipHere invokeBookMenu makeAMovie openMovieFile scanBySlider thumbnailForThisPage)('menu commands' firstPage insertPage)('movie clip player' pianoRoll pianoRoll:)('navigation' goToPage: lastPage nextPage previousPage)('page controls' fullControlSpecs showPageControls showPageControls:)('piano rolls' pauseFrom: resetFrom: resumeFrom:)('player control' goToRelativePosition: playForward playReverse stopPlay)('rounding' wantsRoundedCorners)('stepping' fileByteCountPerFrame filePosForFrameNo: startRunning step stepSoundTrack stopRunning)('stepping and presenter')('testing' stepTime)('private' makeMyPage makeThumbnailInHand: pvtOpenFileNamed: tryToShareScoreFor:)!!MorphExample reorganize!('initialization' initialize)('stepping and presenter' step)!!MonthMorph reorganize!('access' month selectedDates)('controls' chooseYear month: next nextYear previous previousYear startMondayOrSundayString toggleStartMonday)('initialization' defaultColor highlightToday initialize initializeHeader initializeWeeks model:)('menus' addCustomMenuItems:hand:)('stepping and presenter' step)('testing' stepTime)!!MidiInputMorph reorganize!('as yet unclassified' addChannel addChannelControlsFor: atChannel:from:selectInstrument: channelNumAndMuteButtonFor: closeMIDIPort disableReverb: instrumentChoicesForChannel: invokeMenu makeControls makeRow panAndVolControlsFor: setMIDIPort toggleOnOff updateInstrumentsFromLibraryExcept:)('initialization' defaultBorderWidth defaultColor initialize)!!MVCMenuMorph reorganize!('invoking' displayAt:during: informUserAt:during: invokeAt:in: invokeAt:in:allowKeyboard:)('private' cancelValue: selectMVCItem:)!!DumberMenuMorph reorganize!('menu' setInvokingView:)!!MenuMorph reorganize!('WiW support' morphicLayerNumber)('accessing' allWordings allWordingsNotInSubMenus: commandKeyHandler commandKeyHandler: defaultTarget hasSubMenu: itemWithWording: items lastItem lastSelection popUpOwner popUpOwner: rootMenu stayUp stayUp:)('construction' add:action: add:selector:argument: add:subMenu: add:subMenu:target:selector:argumentList: add:target:action: add:target:selector: add:target:selector:argument: add:target:selector:argumentList: addLine addList: addService:for: addServices2:for:extraLines: addServices:for:extraLines: addStayUpIcons addStayUpItem addStayUpItemSpecial addTitle: addTitle:updatingSelector:updateTarget: addUpdating:action: addUpdating:enablement:action: addUpdating:enablementSelector:target:selector:argumentList: addUpdating:target:action: addUpdating:target:selector:argumentList: addWithLabel:enablement:action: addWithLabel:enablementSelector:target:selector:argumentList: balloonTextForLastItem: defaultTarget: labels:lines:selections: title:)('control' activeSubmenu: deleteIfPopUp deleteIfPopUp: popUpAdjacentTo:forHand:from: popUpAt:forHand:in: popUpAt:forHand:in:allowKeyboard: popUpEvent:in: popUpForHand:in: popUpInWorld popUpInWorld: popUpNoKeyboard selectItem:event:)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' drawOn:)('dropping/grabbing' justDroppedInto:event: undoGrabCommand wantsToBeDroppedInto:)('e-toy support' isCandidateForAutomaticViewing)('event handling' handlesKeyboard: handlesMouseDown: keyStroke: keyboardFocusChange: mouseDown: mouseUp:)('events' activate:)('events-processing' handleFocusEvent:)('initialization' initialize setDefaultParameters setTitleParametersFor:)('keyboard control' displayFiltered: moveSelectionDown:event:)('menu' addItem addTitle detachSubMenu: removeStayUpBox removeStayUpItems setInvokingView: setTarget: toggleStayUp: toggleStayUpIgnore:evt:)('menus' addCustomMenuItems:hand:)('meta-actions' invokeMetaMenu:)('modal control' invokeModal invokeModal: invokeModalAt:in:allowKeyboard: isModalInvokationDone isModalInvokationDone: modalSelection modalSelection:)('submorphs-add/remove' delete)('private' positionAt:relativeTo:inWorld: selectedItem)!MPEGMoviePlayerMorph removeSelector: #moviePlayerFillStyle!!MPEGMoviePlayerMorph reorganize!('drawing' drawOn:)('initialization' defaultColor initialize)('menu' invokeMenu)('stepping and presenter' step)('testing' stepTime)('private' addButtonRow addPositionSlider addQuitButton addVolumeSlider buttonFillStyle buttonName:action: quit)!!MIDIControllerMorph reorganize!('accessing' channel channel: controller controller: midiPort midiPort:)('initialization' defaultBorderWidth defaultColor initialize)('menu' controllerList controllerName: setChannel: setController:)('menus' addCustomMenuItems:hand:)('other' newSliderValue: updateLabel)!!KlattFrameMorph reorganize!('initialization' addSliderForParameter:target:min:max:description: addSlidersForParameters: addTestButton defaultColor frame: frame:edit: initialize newSliderForParameter:target:min:max:description: newSliderNamed:min:max:)('menu' playTest)('stepping and presenter' step)('testing' stepTime)!!InterimSoundMorph reorganize!('as yet unclassified' addGraphic sound sound: speakerGraphic)('event handling' handlesMouseDown: mouseDown:)('initialization' defaultBorderWidth defaultColor initialize)!!HeadingMorph reorganize!('accessing' degrees degrees: magnitude magnitude:)('drawing' drawArrowFrom:to:width:color:on: drawOn:)('event handling' handlesMouseDown: mouseMove:)('geometry' extent:)('initialization' defaultBorderWidth defaultColor initialize)!GraphicalDictionaryMenu removeSelector: #defaultBorderColor!GraphicalDictionaryMenu removeSelector: #defaultBorderWidth!GraphicalDictionaryMenu removeSelector: #defaultColor!!GraphicalDictionaryMenu reorganize!('initialization' baseDictionary: initializeFor:fromDictionary:)('menu commands' copyName findEntry handMeOne removeEntry renameEntry renameGraphicTo: repaintEntry showMenu truncatedNameOfGraphic)('private' nameOfGraphic)!!GraphicalMenu reorganize!('as yet unclassified' argument argument: cancel downArrowHit initializeFor:withForms:coexist: okay selector selector: upArrowHit updateThumbnail)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)!!GraphMorph reorganize!('accessing' color: cursorAtEnd cursorColor cursorColor: cursorColorAtZeroCrossing cursorColorAtZeroCrossings: cursorWrapped: data data: dataColor dataColor: interpolatedValueAtCursor lastValue lastValue: startIndex startIndex: valueAtCursor valueAtCursor:)('commands' appendValue: centerCursor clear loadSineWave loadSound: loadSoundData: playOnce reverse)('drawing' drawOn:)('e-toy support' cursor cursor:)('event handling' handlesMouseDown: mouseMove:)('initialization' defaultColor initialize)('layout' layoutChanged)('menu' openWaveEditor readDataFromFile)('menus' addCustomMenuItems:hand:)('objects from disk' convertToCurrentVersion:refStream:)('stepping and presenter' step)('private' drawCursorOn: drawDataOn: flushCachedForm keepIndexInView:)!!GradientFillMorph reorganize!('accessing' hasTranslucentColor)('as yet unclassified' gradientFillColor: setGradientColor:)('drawing' drawOn:)('initialization' initialize)('menu' beHorizontal beVertical)('menus' addCustomMenuItems:hand:)('updating' changed)!ButtonPropertiesMorph removeSelector: #doAccept!ButtonPropertiesMorph removeSelector: #doMainProperties!!ButtonPropertiesMorph reorganize!('as yet unclassified' acceptDroppingMorph:event:in: addTextToTarget adjustTargetMouseDownHaloSize: adjustTargetMouseOverHaloSize: adjustTargetRepeatingInterval: allowDropsInto:withIntent: attachMorphOfClass:to: clearDropHighlightingEvt:morph: doEnables doRemoveProperties mouseDownEvent:for: mouseEnterDraggingEvt:morph: mouseLeaveDraggingEvt:morph: paneForActsOnMouseDownToggle paneForActsOnMouseUpToggle paneForButtonSelectorReport paneForButtonTargetReport paneForChangeMouseDownLook paneForChangeMouseEnterLook paneForChangeVisibleMorph paneForMouseDownColorPicker paneForMouseDownHaloWidth paneForMouseOverColorPicker paneForMouseOverHaloWidth paneForRepeatingInterval paneForWantsFiringWhileDownToggle paneForWantsRolloverToggle rebuild removeTextFromTarget targetActsOnMouseDown targetActsOnMouseUp targetProperties targetRepeatingWhileDown targetWantsRollover toggleTargetActsOnMouseDown toggleTargetActsOnMouseUp toggleTargetRepeatingWhileDown toggleTargetWantsRollover valueForMouseDownHaloWidth valueForMouseOverHaloWidth valueForRepeatingInterval wantsDroppedMorph:event:in:)('initialization' defaultBorderColor defaultColor initialize)!!GenericPropertiesMorph reorganize!('as yet unclassified' addARow: buildFakeSlider:selector:help: buttonNamed:action:color:help: clearSliderFeedback colorPickerFor:getter:setter: directToggleButtonFor:getter:setter:help: doAccept doButtonProperties doCancel doEnables doMainProperties doTextProperties enable:when: inAColumn: inAColumn:named: inARow: inARow:named: lockedString: mouseAdjust:in: openNearTarget showSliderFeedback: targetMorph:)('dropping/grabbing' wantsToBeDroppedInto:)('initialization' defaultBorderWidth initialize)('stepping and presenter' step)('testing' stepTime)!!GeePrinterDialogMorph reorganize!('as yet unclassified' buttonColor buttonNamed:action:color:help: cancelButton doCancel doPreview doPrint getChoice: previewButton printButton printSpecs:printBlock: rebuild toggleChoice:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)!!GeeBookMorph reorganize!('as yet unclassified' geeMail: geePageRectangles rebuildPages)('initialization' defaultColor initialize)!FloatingBookControlsMorph removeSelector: #defaultBorderColor!!FloatingBookControlsMorph reorganize!('WiW support' morphicLayerNumber)('initialization' defaultBorderWidth initialize)('stepping and presenter' step)('testing' stepTime wantsSteps)!!FillInTheBlankMorphWithCharMenu reorganize!('code pane menu' createBasicMenu createCapitalLettersMenu createCommandKeysMenu createDigitsMenu createGenieMenu createModifierKeysMenu createMouseMenu createSmallLettersMenu createSpecialCharsMenu createTextMenu)('menu' codePaneMenu:shifted:)('private' simulateString:)!!FillInTheBlankMorphWithDictMenu reorganize!('code pane menu' originalCodePaneMenu:shifted:)('initialization' initialize)('menu' codePaneMenu:shifted:)('private' dictionaryName: simulateString:)!FillInTheBlankMorph removeSelector: #defaultBorderWidth!FillInTheBlankMorph removeSelector: #perform:orSendTo:!!FillInTheBlankMorph reorganize!('WiW support' morphicLayerNumber)('accessing' response response: selectionInterval)('dropping/grabbing' undoGrabCommand)('event handling' handlesMouseDown: mouseDown:)('initialization' defaultColor initialize responseUponCancel: setPasswordQuery:initialAnswer:answerHeight:acceptOnCR: setQuery:initialAnswer:answerExtent:acceptOnCR: setQuery:initialAnswer:answerHeight:acceptOnCR:)('invoking' getUserResponse)('menu' accept cancel codePaneMenu:shifted:)('objects from disk' convertToCurrentVersion:refStream:)('submorphs-add/remove' delete)!!EventRecorderMorph reorganize!('accessing' button: recTime)('commands' button condense play record setStatusLight: shrink)('event handling' nextEventToPlay synchronize)('events-processing' handleListenEvent:)('fileIn/Out' checkTape convertV0Tape: readFrom: readFromV0: readFromV1: readTape readTape: writeCheck writeFileNamed: writeTape writeTape:)('initialization' addButtons addJournalFile addVoiceControls buttonFor: caption:voiceRecorder:tape: defaultBorderColor defaultBorderWidth defaultColor initialize makeARowForButtons makeASpacer makeStatusLight)('menus' addCustomMenuItems:hand:)('pause/resume' pauseIn: resumeIn: resumePlayIn: resumeRecordIn:)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: justDroppedIntoPianoRoll:event: myDurationInMS)('stepping and presenter' step stop)('testing' stepTime wantsSteps)!!EtoyLoginMorph reorganize!('actions' doCancel doOK)('building' buttonColor buttonNamed:action:color:help: cancelButton myFont okButton)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize openInWorld:)('initialize' name:actionBlock:cancelBlock: rebuild)!!EnvelopeEditorMorph reorganize!('construction' addControls addCurves addHandlesIn: addKeyboard buildGraphAreaIn: buildView colorForEnvelope: curveChoices handleOffset: soundChoices)('editing' acceptGraphPoint:at: addEnvelopeNamed: buildScalesIn: clickOn:evt:from: clickOnLine:evt:envelope: constrain:adjacentTo:in: deletePoint: insertPointAfter: limitHandleMove:event:from: limitHandleMoveEvent:from:index:)('geometry' extent:)('initialization' editEnvelope: editSound: initOnSound:title: initialize soundBeingEdited)('menu' adjustScale: chooseDenominator: chooseEnvelope: chooseFrom:envelopeItem: chooseFrom:soundItem: chooseSound: editNewSound editSoundNamed: readFileNamed: readFromDisk: removeEnvelope saveLibToDisk: saveSound: saveToDisk: setDenominator:)('menus' addCustomMenuItems:hand:)('playing' playNothing)('rounding' wantsRoundedCorners)('scaling' maxTime msFromX: valueFromY: xFromMs: yFromValue:)('stepping and presenter' step)('testing' stepTime)!!EmbeddedWorldBorderMorph reorganize!('WiW support' morphicLayerNumber)('as yet unclassified' goAppView goFactoryView goFullView goNormalProjectEntry myTransformation myWorldChanged toggleZoom worldIEnclose xxxfixLayout)('boxes' appViewBoxArea boxesAndColorsAndSelectors factoryViewBoxArea fullViewBoxArea genericBoxArea: normalEntryBoxArea zoomBoxArea)('drawing' drawOn:)('event handling' handlesMouseDown: mouseDown:)('geometry' extent:)('initialization' initialize)('layout' minHeight: minWidth:)('menus' addCustomMenuItems:hand:)!!EToySenderMorph reorganize!('as yet unclassified' checkOnAFriend currentBadgeVersion establishDropZone: fixOldVersion ipAddress ipAddress: killExistingChat mouseEnteredDZ mouseLeftDZ sendStatusCheck sendStatusReply startAudioChat startAudioChat: startChat startChat: startNebraskaClient startTelemorphic tellAFriend transmitStreamedObject: transmittedObjectCategory userName userName:userPicture:userEmail:userIPAddress: userPicture)('debug and other' installModelIn:)('dropping/grabbing' aboutToBeGrabbedBy: wantsDroppedMorph:event:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('layout' acceptDroppingMorph:event:)('parts bin' initializeToStandAlone)('stepping and presenter' step)!EToyProjectQueryMorph removeSelector: #defaultBorderWidth!EToyProjectQueryMorph removeSelector: #setColorsAndBorder!!EToyProjectQueryMorph reorganize!('as yet unclassified' doOK fillInDetails project:actionBlock: rebuild)('initialization' defaultBorderColor defaultColor)!!EToyProjectDetailsMorph reorganize!('as yet unclassified' copyOutDetails doExpand doOK expandButton expandedFormat expandedFormat: fieldToDetailsMappings fillInDetails project:actionBlock: projectDetails: rebuild)!EToyProjectRenamerMorph removeSelector: #setColorsAndBorder!!EToyProjectRenamerMorph reorganize!('as yet unclassified' buttonColor buttonNamed:action:color:help: cancelButton doCancel doOK fieldForProjectName myFont okButton project:actionBlock: rebuild validateTheProjectName)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)!!EToyProjectHistoryMorph reorganize!('as yet unclassified' closeMyFlapIfAny jumpToProject mouseDown:in: mouseLeave:in: mouseMove:in: mouseUp:in: rebuild)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('stepping and presenter' step)!!EToyMultiChatMorph reorganize!('as yet unclassified' acceptTo:forMorph: chatFrom:name:text: editEvent:for: rebuild standardBorderColor transmittedObjectCategory updateIPAddressField:)('dropping/grabbing' wantsDroppedMorph:event:)('initialization' initialize)('layout' acceptDroppingMorph:event:)!!EToyMorphsWelcomeMorph reorganize!('initialization' defaultColor initialize)!!EToyListenerMorph reorganize!('as yet unclassified' addNewObject:thumbForm:sentBy:ipAddress: mouseDownEvent:for: mouseUpEvent:for: rebuild startListening stopListening)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('stepping and presenter' step)('submorphs-add/remove' delete)!!EToyGenericDialogMorph reorganize!('as yet unclassified' genericTextFieldNamed: inAColumnForText: lockedString: myFont)('initialization' initialize rebuild)!!EToyGateKeeperMorph reorganize!('as yet unclassified' open rebuild)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('stepping and presenter' step)!!EToyFridgeMorph reorganize!('as yet unclassified' getChoice: groupToggleButton mouseEnterEither: mouseLeaveEither: noteRemovalOf: rebuild toggleChoice: transmittedObjectCategory trulyFlashIndicator:)('drawing' drawOn:)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseUp:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('layout' acceptDroppingMorph:event:)('stepping and presenter' step)!!EToyChatMorph reorganize!('as yet unclassified' acceptTo:forMorph: appendMessage: chatFrom:name:text: getChoice: improveText:forMorph: insetTheScrollbars ipAddress open openIn: rebuild recipientForm: reportError: setIPAddress: standardBorderColor startOfMessageFromMe toggleChoice: transmittedObjectCategory)('initialization' defaultBorderColor defaultBorderWidth defaultBounds defaultColor initialize)!!EToyChatOrBadgeMorph reorganize!('no messages')!AudioChatGUI removeSelector: #defaultBorderColor!!AudioChatGUI reorganize!('initialization' buttonColor connectButton defaultBorderWidth defaultColor initialize ipAddress: messageWaitingAlertIndicator playButton recordAndStopButton start2 talkBacklogIndicator talkButton toggleForHandsFreeTalking toggleForPlayOnArrival toggleForSendWhileTalking)('sending' handsFreeTalking record samplingRateForTransmission send sendAnyCompletedSounds sendOneOfMany: talkBacklog talkButtonDown talkButtonUp transmitWhileRecording)('stepping and presenter' start step stop)('stuff' changeTalkButtonLabel connect currentConnectionStateString getChoice: objectsInQueue playNextMessage removeConnectButton toggleChoice:)('testing' stepTime stepTimeIn:)('user interface' defaultBackgroundColor initialExtent)!!EToyCommunicatorMorph reorganize!('as yet unclassified' addGateKeeperMorphs buttonNamed:action:color:help: commResult: editEvent:for: field:is: flashIndicator: handleResult: indicatorFieldNamed:color:help: open reportError: resetIndicator: stopFlashing textEntryFieldNamed:with:help: toggleButtonFor:attribute: transmitStreamedObject:as:to: transmitStreamedObject:to: trulyFlashIndicator:)('initialization' initialize)('stepping and presenter' step)('submorphs-add/remove' delete)('testing' stepTime wantsSteps)!DoubleClickExample removeSelector: #initialize!!DoubleClickExample reorganize!('accessing' balloonText)('event handling' click: doubleClick: handlesMouseDown: mouseDown: startDrag:)('initialization' defaultColor)!!CodecDemoMorph reorganize!('as yet unclassified' codecClassName: selectCodec)('dropping/grabbing' wantsDroppedMorph:event:)('initialization' defaultColor initialize)('layout' acceptDroppingMorph:event:)('menus' addCustomMenuItems:hand:)!!CRDisplayPropertiesMorph reorganize!('accessing' ensureLayout hasLayout)('initialization' openInWorld:)('initialize-release' initializeProperties: layout)('naming' name:)('submorphs' createAcceptButton createBasicButton createBasicLabelStringMorph: createBasicUpdatingButtonOn:action:get: createBasicUpdatingNumberMorphOn:get:put:min:max: createBasicUpdatingStringMorphOn:get:put: createCancelButton createDefaultButtons)('submorphs-add/remove' delete)('testing' name)('updating' accept canChange canChangeAsk: changed indicateChanged update: updateAll)('view hooks' acceptAction aspectRatio aspectRatio: cancelAction isActive maxSize maxSize: minCaptureDistance minCaptureDistance: minMoveDistance minMoveDistance: switchActive)('private' modelIsActive setOldValues)!!CRAddFeatureMorph reorganize!('accessing' addFeatureAndUpdate: defaultChar defaultChar: model)('buttons' addToDefaultButton addToXButton basicButton cancelButton menuButton resetButton)('events-processing' processEvent:using:)('genie-dispatching' gesture:)('genie-processing' allowsGestureEscape allowsGesturePreprocessing gestureDictionary handlesGestureStart:)('initialize-release' initializeModel: layout)('model access' addToActionAskUser: addToDefaultAction addToXAction cancelAction createMorphForFeature objectToString:)('updating' update: updateContents)('private' addFeature: avgFeature bestStrokeFeature featureMorph featureMorph: lastFeature menuAction model: removeLastAction resetAction setHotspotAction: shownFeature strokeDistance:and: switchShowLastAction)!!BookMorph reorganize!('accessing' cardsOrPages currentPage pageNamed: pageNumberOf: pages pages: setAllPagesColor: userString)('caching' releaseCachedState)('copying' updateReferencesUsing:)('dropping/grabbing' allowSubmorphExtraction wantsDroppedMorph:event:)('e-toy support' configureForKids succeededInRevealing:)('filter streaming' fullDrawPostscriptOn:)('halos and balloon help' defersHaloOnClickTo:)('initialization' defaultColor fromRemoteStream: fromURL: initialize newPages: newPages:currentIndex: removeEverything setInitialState)('insert and delete' defaultNameStemForNewPages deletePage deletePageBasic insertPage:pageSize: insertPage:pageSize:atIndex: insertPageColored: insertPageLabel:morphs: insertPageSilentlyAtEnd)('layout' acceptDroppingMorph:event:)('menu' bookmarkForThisPage buildThreadOfProjects copyUrl findText: findText:inStrings:startAt:container:pageNum: forgetURLs getAllText getStemUrl goToPage highlightText:at:in: invokeBookMenu keepTogether loadImagesIntoBook makeUniformPageSize menuPageSoundFor:event: menuPageSoundForAll: menuPageSoundForThisPage: menuPageVisualFor:event: menuPageVisualForAll: menuPageVisualForThisPage: pageControlsVisible pasteBookPage reload reserveUrls reserveUrlsIfNeeded saveAsNumberedURLs saveIndexOfOnly: saveIndexOnURL saveOnUrlPage: saveOneOnURL savePagesOnURL setNewPagePrototype setPageColor textSearch textSearch: thumbnailForThisPage toggleFullScreen toggleShowingOfPageControls uncachePageSorter)('menu commands' sortPages)('menus' printPSToFile)('misc' addBookMenuItemsTo:hand:)('navigation' buildFloatingPageControls goToPage: goToPage:transitionSpec: goToPage:transitionSpec:runTransitionScripts: goToPageMorph: goToPageMorph:fromBookmark: goToPageMorph:runTransitionScripts: goToPageMorph:transitionSpec: goToPageMorph:transitionSpec:runTransitionScripts: goToPageUrl: goto: insertPageMorphInCorrectSpot: lastPage nextPage pageNumber previousPage setWrapPages: showMoreControls transitionSpecFor:)('other' adjustCurrentPageForFullScreen exitFullScreen goFullScreen isInFullScreenMode makeMinimalControlsWithColor:title: resizePagesTo:)('parts bin' initializeToStandAlone)('printing' asPostscript pagesHandledAutomatically)('scripting' chooseAndRevertToVersion installRollBackButtons methodHolderVersions methodHolders revertToCheckpoint:)('sorting' acceptSortedContentsFrom: morphsForPageSorter sortPages:)('submorphs-accessing' allNonSubmorphMorphs)('submorphs-add/remove' abandon)!!BooklikeMorph reorganize!('e-toy support' currentPlayerDo:)('menu commands' clearNewPagePrototype firstPage insertPage sortPages)('menus' addCustomMenuItems:hand:)('misc' addBookMenuItemsTo:hand: move pageSize pageSize: playPageFlipSound: showingFullScreenString showingPageControlsString)('page controls' fewerPageControls fullControlSpecs hidePageControls makePageControlsFrom: shortControlSpecs showPageControls showPageControls:)!!BookPageSorterMorph reorganize!('as yet unclassified' acceptSort addControls book:morphsToSort: changeExtent: closeButtonOnly columnWith: getPartsBinStatus pageHolder rowWith: togglePartsBinStatus wrapperFor:)('copying' veryDeepFixupWith: veryDeepInner:)('dropping/grabbing' wantsToBeDroppedInto:)('initialization' defaultBorderWidth defaultColor initialize)!!BasicButton reorganize!('as yet unclassified' label label: label:font: setLabel)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('menus' addCustomMenuItems:hand:)!!BalloonRectangleMorph reorganize!('accessing' doesBevels)('drawing' drawOn:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('rotate scale and flex' newTransformationMorph)('testing' canDrawBorder:)!!AllScriptsTool reorganize!('initialization' addSecondLineOfControls initializeFor:)('menus' dismissButton presentHelp)('parts bin' initializeToStandAlone)('stepping and presenter' step)('testing' stepTime wantsSteps)('toggles' openUpButton showingAllInstances showingOnlyActiveScripts showingOnlyTopControls toggleWhetherShowingAllInstances toggleWhetherShowingOnlyActiveScripts toggleWhetherShowingOnlyTopControls)!!AlignmentMorph reorganize!('classification' isAlignmentMorph)('e-toy support' configureForKids)('event handling' wantsKeyboardFocusFor:)('initialization' addUpDownArrowsFor: basicInitialize defaultBorderWidth defaultColor initialize openInWindowLabeled:inWorld:)('object fileIn' convertOldAlignmentsNov2000:using:)('objects from disk' convertToCurrentVersion:refStream:)('visual properties' canHaveFillStyles)!AbstractMediaEventMorph removeSelector: #defaultBorderColor!!AbstractMediaEventMorph reorganize!('as yet unclassified' endTime)('initialization' defaultBorderWidth defaultColor initialize)('piano rolls' justDroppedIntoPianoRoll:event:)!!RectangleMorph reorganize!('accessing' wantsToBeCachedByHand)('initialization' defaultColor)('visual properties' canHaveFillStyles)!!ProportionalLayout class reorganize!('no messages')!!ProportionalLayout reorganize!('layout' layout:in: minExtentOf:in:)('testing' isProportionalLayout)!!PropertyListEncoder class reorganize!('configuring' filterSelector)!!PropertyListEncoder reorganize!('writing' writeArrayedCollection: writeDictionary:)!!ProjectViewMorph class reorganize!('class initialization' initialize)('fileIn/Out' fileReaderServicesForFile:suffix: services)('initialize-release' unload)('instance creation' on:)('project window creation' newMVCProject newMorphicProject newMorphicProjectOn: newProjectViewInAWindowFor: openFromDirectory:andFileName: openFromDirectoryAndFileName: openFromFile: openFromFileList: serviceOpenProjectFromFile)!ProjectViewMorph removeSelector: #convertToCurrentVersion:refStream:!!ProjectViewMorph reorganize!('accessing' balloonText borderWidthForRounding project thumbnail)('as yet unclassified' addProjectNameMorph addProjectNameMorphFiller editTheName: expungeProject)('caching' releaseCachedState)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' colorAroundName drawOn: ensureImageReady fontForName isEditingName isTheRealProjectPresent safeProjectName safeProjectName: showBorderAs: updateImageFrom: updateNamePosition)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: handlesMouseStillDown: mouseDown: mouseEnter: mouseLeave: mouseLeaveDragging: mouseStillDown: mouseUp: wantsKeyboardFocusFor:)('events' checkForNewerVersionAndLoad deletingProject: enter enterAsActiveSubproject enterWhenNotPresent lastProjectThumbnail: on: project: seeIfNameChanged showMenuForProjectView showMouseState: withProgressDo:)('fileIn/out' storeSegment)('filter streaming' fullDrawPostscriptOn:)('geometry' extent:)('initialization' initialize)('layout' acceptDroppingMorph:event:)('objects from disk' objectForDataStream:)('piano rolls' triggerActionFromPianoRoll)('rounding' wantsRoundedCorners)('stepping and presenter' step)('submorphs-add/remove' abandon)('testing' stepTime)('user interface' eToyStreamedRepresentationNotifying:)!!PrintEncoder class reorganize!('configuring' filterSelector)!!PostscriptEncoderToDisk class reorganize!('creation' stream)!!PostscriptEncoder class reorganize!('configuring' clearCharacterMappings filterSelector macToPSCharacterChart mapMacStringToPS:)!!PrintableEncoder class reorganize!('no messages')!!PrintEncoder reorganize!('no messages')!!PostscriptEncoderToDisk reorganize!('no messages')!!PostscriptEncoder reorganize!('Postscript generation' clip closepath comment: comment:with: concat: curvetoQuadratic:from:via: fill lineto: moveto: newpath oval: preserveStateDuring: rect: rectclip: rectfill: remapFontForSqueak: safeGrestore scale: selectflippedfont:size: selectflippedfont:size:ascent: selectfont:size: setLinewidth: setrgbcolor: showpage stroke strokepath translate: writeMatrix: writePoint:)('writing' writeNumber:)!!PrintableEncoder reorganize!('writing' writeNumber:base:)!!PrintSpecifications class reorganize!('as yet unclassified' defaultSpecs defaultSpecs:)('instance creation' new)!!PrintSpecifications reorganize!('as yet unclassified' drawAsBitmapFlag drawAsBitmapFlag: initialize landscapeFlag landscapeFlag: scaleToFitPage scaleToFitPage:)!!Presenter class reorganize!('no messages')!!Presenter reorganize!('access' associatedMorph associatedMorph: world)('button creation' addTrashCan)('misc' currentlyViewing: drawingJustCompleted: morph:droppedIntoPasteUpMorph: standardPlayfield: tempCommand)('palette & parts bin' ownStandardPalette standardPalette: systemQueryPhraseWithActionString:labelled:)('playerList' allExtantPlayers allKnownScriptSelectors allPlayersWithUniclasses flushPlayerListCache reinvigorateAllScriptsTool: reportPlayersAndScripts toolToViewScriptInstantiations uniclassesAndCounts)('printing' printOn:)('scripting' adaptedToWorld:)('standardPlayer etc' createStandardPlayer positionStandardPlayer standardPlayer)('stop-step-go buttons' allGoButtons allStepButtons allStopButtons goButtonState: goUp:with: startRunningScripts startRunningScriptsFrom: stepButtonState: stepDown:with: stepStillDown:with: stepUp:with: stopButtonState: stopRunningScripts stopRunningScriptsFrom: stopUp:with:)('tile support' booleanTiles constantTile: phraseForReceiver:op:arg:resultType: typeForConstant: valueTiles)('viewer' cacheSpecs: nascentPartsViewer nascentPartsViewerFor: updateViewer: updateViewer:forceToShow: viewMorph: viewObject: viewObjectDirectly:)!!PostscriptDummyWarp class reorganize!('as yet unclassified' canvas:)!!PostscriptDummyWarp reorganize!('dummy' canvas canvas: cellSize: colorMap: combinationRule: drawPostscriptContext: preserveStateDuring: sourceForm: sourceQuad:destRect: subCanvas: transform transform: transformBy: warpBits)!!PostscriptCharacterScanner class reorganize!('as yet unclassified' scannerWithCanvas:paragraph:bounds:)!!PostscriptCharacterScanner reorganize!('accessing' bounds: canvas canvas: defaultFont font paragraph paragraph: setDestForm: textStyle)('displaying' displayLine:offset:leftInRun:)('textstyle support' addEmphasis: addKern: indentationLevel: placeEmbeddedObject: setActualFont: setFont: setTextStylesForOffset: textColor:)!!EPSCanvas class reorganize!('as yet unclassified' bobsPostScriptHacks)('configuring' baseOffset)!!DSCPostscriptCanvasToDisk class reorganize!('as yet unclassified' morphAsPostscript:rotated:offsetBy:specs: morphAsPostscript:rotated:specs:)('configuring' defaultTarget)('testing' morphAsPostscript:rotated:offsetBy:)!!DSCPostscriptCanvas class reorganize!('no messages')!!PostscriptCanvas class reorganize!('configuring' baseOffset defaultCanvasType defaultTarget filterSelector)('testing' morphAsPostscript: morphAsPostscript:rotated: morphAsPostscript:rotated:offsetBy:)!!EPSCanvas reorganize!('drawing-general' fullDraw:)('initialization' writePSIdentifierRotated:)('morph drawing' setupGStateForMorph:)!!DSCPostscriptCanvasToDisk reorganize!('as yet unclassified' morphAsPostscript:rotated:offsetBy: morphAsPostscript:rotated:offsetBy:specs:)!!DSCPostscriptCanvas reorganize!('as yet unclassified' defaultImageableArea defaultMargin defaultPageSize pageBBox pageOffset)('drawing-general' fullDraw:)('initialization' writePSIdentifierRotated:)('morph drawing' fullDrawBookMorph: setupGStateForMorph:)!PostscriptCanvas removeSelector: #point:color:!!PostscriptCanvas reorganize!('accessing' clipRect contentsOfArea:into: origin topLevelMorph topLevelMorph:)('ballon compatibility' aaLevel: transformBy:during:)('drawing' drawGeneralBezierShape:color:borderWidth:borderColor: drawOval:color:borderWidth:borderColor: drawRectangle:color:borderWidth:borderColor: fillColor: infiniteFillRectangle:fillStyle: line:to:brushForm: line:to:width:color: paragraph:bounds:color: text:at:font:color:justified:parwidth: text:at:font:color:spacePad: textStyled:at:font:color:justified:parwidth:)('drawing support' clip closepath comment: comment:with: defaultFont defineFont: drawGradient: drawPostscriptContext: fill: fill:andStroke: lineto: moveto: outlinePolygon: outlineQuardraticBezierShape: oval: paint:operation: postscriptFontInfoForFont: postscriptFontNameForFont: rect: setColor: setFont: setLinewidth: stroke: strokepath transformBy: translate:)('drawing-general' draw: fullDraw:)('drawing-images' stencil:at:color:)('drawing-ovals' fillOval:color:borderWidth:borderColor:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor:)('drawing-rectangles' fillRectangle:color: fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameRectangle:width:color:)('drawing-support' clipBy:during: preserveStateDuring: transformBy:clippingTo:during:smoothing: translateBy:during:)('drawing-text' drawString:from:to:in:font:color:)('initialization' bounds: fontsForComicBold fontsForComicPlain fontsForHelvetica fontsForNewYork fontsForPalatino initializeFontMap reset resetContentRotated: writeHeaderRotated: writePSIdentifierRotated: writeProcset writeSetupForRect:)('misc canvas' asBalloonCanvas setOrigin:clipRect: warpFrom:toRect:)('morph drawing' drawPage: drawPages: fullDrawBookMorph: setupGStateForMorph:)('other' translateBy:clippingTo:during:)('printing' printContentsOn: psSize)('testing' doesRoundedCorners)('private' image:at:sourceRect:rule:)!!LipsMorph class reorganize!('class initialization' initialize)!!LineMorph class reorganize!('as yet unclassified' from:to:color:width:)('instance creation' new)('new-morph participation' newStandAlone)('parts bin' descriptionForPartsBin)!!EnvelopeLineMorph class reorganize!('no messages')!!CurveMorph class reorganize!('instance creation' arrowPrototype)('parts bin' descriptionForPartsBin supplementaryPartsDescriptions)!!BlobMPEGMorph class reorganize!('instance creation' buildMorphics: newWithMovie: newWithMovieNoSound:)!!BlobMorph class reorganize!('instance creation' new)('instance remembering' delete: remember:)('parts bin' descriptionForPartsBin)!!BalloonMorph class reorganize!('instance creation' string:for: string:for:corner:)('utility' balloonColor balloonFont chooseBalloonFont setBalloonColorTo: setBalloonFontTo:)('private' getBestLocation:for:corner: getTextMorph:for: getVertices:)!!PolygonMorph class reorganize!('instance creation' arrowPrototype fromHand: fromHandFreehand: shapeFromPen:color:borderWidth:borderColor: vertices:color:borderWidth:borderColor:)('parts bin' descriptionForPartsBin supplementaryPartsDescriptions)!!LipsMorph reorganize!('accessing' verticesString)('actions' articulate: grin hideTongue horror neutral newVerticesCentered: newVerticesCentered:scaled: openness: sad showTongue smile surprise updateShape)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)!!LineMorph reorganize!('no messages')!!EnvelopeLineMorph reorganize!('as yet unclassified' vertices:borderWidth:borderColor:)('editing' dragVertex:event:fromHandle: dropVertex:event:fromHandle: newVertex:event:fromHandle:)('initialization' defaultColor)!!CurveMorph reorganize!('initialization' initialize)('parts bin' initializeToStandAlone)!!BlobMPEGMorph reorganize!('access' form form: movieDrawArea mpegLogic mpegLogic: primary quadNumber quadNumber: stream)('drawing' drawOn: playStream: playVideoStream:)('initialization' initialize:mpegPlayer: initializeBlobShape initializeChildMpegPlayer: initializePrimaryMpegPlayer:)('stepping' adjustColors limitRange: mergeBlobs)('testing' stepTime)!BlobMorph removeSelector: #initializeColor!BlobMorph removeSelector: #initializeToStandAlone!!BlobMorph reorganize!('copying' veryDeepCopy)('debug and other' installModelIn:)('geometry' setConstrainedPosition:hangOut:)('geometry testing' containsPoint:)('initialization' defaultColor initialize initializeBlobShape maximumVelocity setVelocity)('parts bin')('stepping' adjustColors bounceOffWalls limitRange: mergeBlobs mergeSelfWithBlob:atPoint: oozeAFewPointsOf: selfPolarPointRadius:degrees:)('stepping and presenter' step)('submorphs-add/remove' delete)('testing' stepTime)!!BalloonMorph reorganize!('WiW support' morphicLayerNumber)('accessing' balloonOwner)('classification' isBalloonHelp)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize popUpFor:hand: popUpForHand:)('menus' adjustedCenter)('stepping and presenter' step)('testing' stepTime)('private' setTarget:)!PolygonMorph removeSelector: #defaultBorderWidth!PolygonMorph removeSelector: #initializeToStandAlone!!PolygonMorph reorganize!('access' borderColor: isClosed isCurve isOpen makeOpenOrClosed openOrClosePhrase vertices)('accessing' borderWidth: couldHaveRoundedCorners)('caching' loadCachedState releaseCachedState)('dashes' borderDashOffset dashedBorder:)('debug and other' installModelIn:)('drawing' areasRemainingToFill: drawArrowOn:at:from: drawArrowsOn: drawBorderOn: drawBorderOn:usingEnds: drawClippedBorderOn:usingEnds: drawDashedBorderOn: drawDashedBorderOn:usingEnds: drawOn: drawOnFormCanvas: drawPostscriptOn:)('dropping/grabbing' justDroppedInto:event:)('editing' addHandles dragVertex:event:fromHandle: dragVertex:fromHandle:vertIndex: dropVertex:event:fromHandle: dropVertex:fromHandle:vertIndex: newVertex:event:fromHandle: newVertex:fromHandle:afterVert: updateHandles verticesAt:put:)('event handling' handlesMouseDown: mouseDown:)('geometry' closestPointTo: extent: merge: mergeDropThird:in:from: transformedBy:)('geometry eToy' heading: referencePosition rotationCenter rotationCenter:)('geometry testing' containsPoint:)('halo control' rotationDegrees:)('initialization' beSmoothCurve beStraightSegments defaultBorderColor defaultColor initialize vertices:color:borderWidth:borderColor:)('menu' arrowLength: arrowSpec: customizeArrows: handlesShowingPhrase makeBackArrow makeBothArrows makeClosed makeForwardArrow makeNoArrows makeOpen quickFill: removeHandles showOrHideHandles showingHandles specifyDashedLine standardArrows toggleHandles toggleSmoothing unrotatedLength unrotatedLength: unrotatedWidth unrotatedWidth:)('menus' addCustomMenuItems:hand: setRotationCenterFrom:)('objects from disk' convertToCurrentVersion:refStream:)('rotate scale and flex' addFlexShellIfNecessary rotationDegrees)('smoothing' coefficients computeNextToEndPoints derivs:first:second:third: lineSegmentsDo: nextToFirstPoint nextToLastPoint)('stepping and presenter' step)('testing' stepTime wantsSteps)('visual properties' canHaveFillStyles fillStyle fillStyle:)('private' arrowBoundsAt:from: arrowForms borderForm computeArrowFormAt:from: computeBounds curveBounds filledForm getVertices includesHandle: lineSegments privateMoveBy: setVertices:)!!NullCanvas class reorganize!('no messages')!!MultiCanvas class reorganize!('instance creation' new)!!ClippingCanvas class reorganize!('instance creation' canvas:clipRect:)!!CachingCanvas class reorganize!('instance creation' on:)!!BufferedCanvas class reorganize!('no messages')!!PluggableCanvas class reorganize!('no messages')!NullCanvas removeSelector: #apply:!NullCanvas removeSelector: #isBalloonCanvas!NullCanvas removeSelector: #isShadowDrawing!!NullCanvas reorganize!('accessing' clipRect extent form origin)('copying' copyClipRect:)('drawing-support' clipBy:during: transformBy:clippingTo:during:smoothing: translateBy:during:)!!MultiCanvas reorganize!('accessing' addCanvas: clipRect contentsOfArea:into: depth extent removeCanvas:)('initialization' allocateForm: depth: extent: initialize)('private' apply:)!!ClippingCanvas reorganize!('accessing' clipRect contentsOfArea:into: form shadowColor)('initialization' canvas:clipRect:)('testing' isBalloonCanvas isShadowDrawing)('private' apply:)!!CachingCanvas reorganize!('accessing' contentsOfArea:into: form)('canvas methods' allocateForm: showAt:invalidRects:)('initialization' mainCanvas:)('private' apply:)!BufferedCanvas removeSelector: #apply:!!BufferedCanvas reorganize!('Nebraska/embeddedWorlds' displayIsFullyUpdated)('accessing' clipRect extent origin)('as yet unclassified' asBufferedCanvas checkIfTimeToDisplay connection:clipRect:transform:remoteCanvas: purgeOutputQueue sendDeltas)('drawing-general' drawMorph:)('drawing-support' clipBy:during:)('other' forceToScreen:)!!PluggableCanvas reorganize!('accessing' clipRect contentsOfArea:into: extent origin shadowColor:)('canvas methods' balloonFillOval:fillStyle:borderWidth:borderColor: balloonFillRectangle:fillStyle: infiniteFillRectangle:fillStyle: showAt:invalidRects:)('drawing' line:to:brushForm: line:to:width:color: paragraph:bounds:color: render:)('drawing-general' roundCornersOf:in:during:)('drawing-images' paintImage:at: paintImage:at:sourceRect: stencil:at:sourceRect:color:)('drawing-ovals' fillOval:color:borderWidth:borderColor: fillOval:fillStyle:borderWidth:borderColor:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor:)('drawing-rectangles' fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor:)('drawing-support' clipBy:during: transformBy:clippingTo:during:smoothing: translateBy:during:)('drawing-text' drawString:from:to:in:font:color:)('initialization' flush)('other' flushDisplay forceToScreen: translateBy:clippingTo:during:)('private' apply: image:at:sourceRect:rule:)!!MouseOverMorph class reorganize!('no messages')!!MouseDownMorph class reorganize!('no messages')!!MouseSensorMorph class reorganize!('as yet unclassified' includeInNewMorphMenu)!!MouseOverMorph reorganize!('event handling' handlesMouseOver: mouseEnter: mouseLeave: mouseMove:)!!MouseDownMorph reorganize!('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('menu' addCustomMenuItems:hand: plugAllToModel plugAllToSlots plugMouseDownToModel plugMouseDownToSlot plugMouseMoveToModel plugMouseMoveToSlot)!!MouseSensorMorph reorganize!('drawing' fullDrawOn:)('initialization' initialize)('testing' installed)!!Component1 class reorganize!('no messages')!!Component class reorganize!('as yet unclassified' addSlotNamed: includeInNewMorphMenu)('compiling' acceptsLoggingOfCompilation wantsChangeSetLogging)!!Component reorganize!('drag and drop' justDroppedInto:event:)('initialize' initComponentIn:)('naming' chooseNameLike: nameMeIn: renameMe)('variables' addVariableNamed: removeVariableNamed:)('viewer' externalName)!!CardPlayer class reorganize!('compiling' acceptsLoggingOfCompilation wantsChangeSetLogging)('instance creation' isUniClass)('slots' compileAccessorsFor: removeAccessorsFor:)('testing' officialClass)('user-defined inst vars' resortInstanceVariables: setNewInstVarNames:)('variable docks' newVariableDocks: setSlotInfoFromVariableDocks variableDocks variableDocks:)!!CardPlayer reorganize!('as template' matchIndex matchIndex: matchNames results)('card data' allStringsAfter: asKeys commitCardPlayerData commitCardPlayerDataFrom: installPrivateMorphsInto: match:fields: privateMorphs url)('misc' tileReferringToSelf)('printing' printOn:)('scripts-kernel' renameScript:newSelector: retargetButton:oldSelector:newSelector:)!Player removeSelector: #categoriesForViewer:!Player removeSelector: #scriptPerformer!!Player reorganize!('accessing' presenter)('card/stack commands' deleteCard firstPage getRoundedCorners goToCard: goToFirstCardInBackground goToFirstCardOfStack goToLastCardInBackground goToLastCardOfStack goToNextCardInStack goToPreviousCardInStack goto: insertCard lastPage nextPage previousPage setRoundedCorners:)('copying' copyUniClassWith: initializeCostumesFrom: veryDeepFixupWith: veryDeepInner:)('costume' availableCostumeNames availableCostumesForArrows ceaseHavingAParameterFor: changeParameterTypeFor: clearOwnersPenTrails clearPenTrails costume costume: costumeRespondingTo: costumesDo: forgetOtherCostumes getValueFromCostume: hasAnyBorderedCostumes hasCostumeThatIsAWorld hasOnlySketchCostumes knownSketchCostumeWithSameFormAs: newCostume rawCostume: recaptureUniqueCostumes rememberCostume: renderedCostume: renderedCostume:remember: resetCostumeList restoreBaseGraphic sendMessageToCostume: sendMessageToCostume:with: setCostumeSlot:toValue: setParameterFor:toType: stamp stampAndErase startHavingParameterFor: tearOffButtonToFireScriptForSelector: typeforParameterFor: wearCostumeOf: wearCostumeOfClass: wearCostumeOfName:)('error handling' doesNotUnderstand:)('fileIn/Out' releaseCachedState)('heading' headDown headLeft headRight headUp)('macpal' isUniversalTiles slotInfo)('menus' step)('misc' actorState adoptScriptsFrom allOpenViewers allOpenViewersOnReceiverAndSiblings beNotZero: browseEToyVocabulary color color:sees: decimalPlacesForGetter: dummy erase getIsOverColor: grabPlayerIn: grabScriptorForSelector:in: impartSketchScripts indicateLocationOnScreen makeBounceSound: noteDecimalPlaces:forGetter: noteDeletionOf:fromWorld: offerAlternateViewerMenuFor:event: openSearchingVocabularyBrowser openUnderlyingScriptorFor: ordinalNumber overlaps: revealPlayerIn: revertToUnscriptedPlayerIfAppropriate roundUpStrays seesColor: stack tearOffTileForSelf thumbnailMenuEvt:forMorph: tileReferringToSelf touchesA: unhideHiddenObjects uninstallFrom: unusedScriptName updateAllViewers updateAllViewersAndForceToShow: viewerFlapTab width)('name' tryToRenameTo:)('objects from disk' storeDataOn:)('pen' addPlayerMenuItemsTo:hand: arrowheadsOnAllPens choosePenColor: choosePenSize clearTurtleTrails colorUnder defaultPenColor defaultPenSize getPenArrowheads getPenColor getPenDown getPenSize liftAllPens liftPen lowerAllPens lowerPen noArrowheadsOnAllPens penColor: setPenArrowheads: setPenColor: setPenDown: setPenSize:)('printing' printOn: stringForReadout)('scripting' defaultFloatPrecisionFor: methodInterfacesForInstanceVariablesCategoryIn: methodInterfacesForScriptsCategoryIn:)('scripts-execution' assureEventHandlerRepresentsStatus assureNoScriptOtherThan:hasStatus: fireOnce prepareToBeRunning runAllClosingScripts runAllOpeningScripts runAllTickingScripts: scriptingError: startRunning startRunningScripts stepAt: stopProgramatically stopRunning)('scripts-kernel' acceptScript:for: acceptableScriptNameFrom:forScriptCurrentlyNamed: addIdiosyncraticMenuItemsTo:forSlotSymol: allScriptEditors editDescriptionForSelector: emptyScript existingScriptInstantiationForSelector: expungeEmptyScripts expungeEmptyUnRenamedScripts hasScriptInvoking:ofPlayer: hasScriptReferencing:ofPlayer: instantiatedUserScriptsDo: isEmptyTileScript: isExpendableScript: makeIsolatedCodePaneForSelector: methodInterfaceForEmptyScript newTextualScriptorFor: noteRenameOf:to:inPlayer: okayToDestroyScriptNamed: okayToRemoveSlotNamed: pacifyScript: removeScript:fromWorld: removeScriptWithSelector: removeScriptWithoutUpdatingViewers: removeScriptWithoutUpdatingViewers:fromWorld: renameScript:newSelector: runScript: scriptEditorFor: scriptInstantiationForSelector: scriptorsForSelector:inWorld: slotInfoButtonHitFor:inViewer: sourceCodeFor: tilesToCall: universalTilesForInterface:)('scripts-standard' append: assignStatus:toAllFor: bounce: changeScript:toStatus: clear contents contents: doButtonAction doMenuItem: doScript: fire followPath forward: getObtrudes goToRightOf: hide include: initiatePainting loadSineWave loadSound: makeNewDrawingIn: menuItemAfter: menuItemBefore: moveToward: pauseAll: pauseScript: play prepend: removeAll reverse show shuffleContents startAll: startScript: stopAll: stopScript: tellAllSiblings: turn: wrap)('scripts-vector' * + - / asPoint decr: dividedBy: incr: multBy:)('slot getters/setters' bookEmbodied cameraPoint cameraPoint: getActWhen getAllButFirstCharacter getAmount getAngle getBaseGraphic getBorderColor getBorderStyle getBorderWidth getBottom getBrightnessUnder getCameraPoint getCardNumber getCellInset getCharacters getClipSubmorphs getColor getColorUnder getConePosition getCostume getCostumeAtCursor getCursor getCursorWrapped getDescending getDistance getDragEnabled getDropEnabled getDropShadow getFirstCharacter getFirstElement getGetListSelector getGraphic getGraphicAtCursor getHResizing getHeading getHeadingTheta getHeadingUnrounded getHeight getHolder getIndexInOwner getIsLocked getIsUnderMouse getKnobColor getLabel getLastValue getLayoutInset getLeft getLeftRight getLength getListCentering getListDirection getLuminanceUnder getMaxVal getMinVal getMouseX getMouseY getName getNewClone getNumberAtCursor getNumericValue getOffsetX getOffsetY getPageNumber getPlayerAtCursor getRadialGradientFill getResistsRemoval getRight getRotationStyle getSampleAtCursor getSaturationUnder getScale getScaleFactor getSecondColor getShadowColor getSpeed getSticky getTheta getTop getTruncate getUpDown getUseGradientFill getVResizing getValueAtCursor getViewingByIcon getWidth getWrapDirection getX getY handTheUserACopy setActWhen: setAllButFirstCharacter: setBaseGraphic: setBorderColor: setBorderStyle: setBorderWidth: setBottom: setCameraPoint: setCardNumber: setCellInset: setCharacters: setClipSubmorphs: setColor: setColorUnder: setConePosition: setCostume: setCursor: setCursorWrapped: setDescending: setDistance: setDragEnabled: setDropEnabled: setDropShadow: setFirstCharacter: setFirstElement: setGetListSelector: setGraphic: setHResizing: setHeading: setHeadingTheta: setHeight: setIndexInOwner: setIsLocked: setKnobColor: setLabel: setLastValue: setLayoutInset: setLeft: setLength: setListCentering: setListDirection: setMaxVal: setMinVal: setName: setNumberAtCursor: setNumericValue: setOffsetX: setOffsetY: setPageNumber: setRadialGradientFill: setResistsRemoval: setRight: setRotationStyle: setSampleAtCursor: setScale: setScaleFactor: setSecondColor: setShadowColor: setSticky: setTheta: setTop: setTruncate: setUseGradientFill: setVResizing: setValueAtCursor: setViewingByIcon: setWidth: setWrapDirection: setX: setY: stackEmbodied)('slots-assignment' assignDecrGetter:setter:amt: assignGetter:setter:amt: assignIncrGetter:setter:amt: assignMultGetter:setter:amt:)('slots-kernel' absorbBackgroundDataFrom:forInstanceVariables: categories categoriesForVocabulary: categoriesForWorld slotNames typeForSlot: typeForSlot:vocabulary: typeForSlotWithGetter:)('slots-user' addInstanceVariable addInstanceVariableNamed:type:value: addSpecialSetter: chooseSlotTypeFor: chooseUserSlot compileInstVarAccessorsFor: defaultValueOfType: hasUserDefinedScripts initialValueForSlotOfType: offerGetterTiles: removeSlotNamed: renameSlot: renameSlot:newSlotName: setPrecisionFor: slotInfoAt: slotInfoAt:ifAbsent: slotInfoForGetter: slotNamesOfType: tearOffFancyWatcherFor: tearOffWatcherFor: valueOfType:from:)('slots-wonderland' getFogColor getFogDensity getFogRangeEnd getFogRangeStart getFogType setFogColor: setFogDensity: setFogRangeEnd: setFogRangeStart: setFogType:)('testing' basicType costumes knownName nameForViewer renameTo: wantsSteps)('user interface' defaultLabelForInspector)('viewer' assureUniClass belongsToUniClass elementTypeFor:vocabulary: externalName graphicForViewerTab hasUserDefinedSlots infoFor:inViewer: initialTypeForSlotNamed: isPlayerLike newScriptorAround: offerViewerMenuFor:event: renameScript: tileToRefer uniqueNameForReference usableMethodInterfacesIn:)!!PlayWithMe1 class reorganize!('new-morph participation' includeInNewMorphMenu)!!PinSpec class reorganize!('no messages')!!PinSpec reorganize!('accessing' defaultValue isInput isInputOnly isInputOutput isOutput isOutputOnly localReadSelector localWriteSelector modelReadSelector modelReadSelector:modelWriteSelector: modelWriteSelector pinLoc pinLoc: pinName)('initialization' pinName:direction:localReadSelector:localWriteSelector:modelReadSelector:modelWriteSelector:defaultValue:pinLoc:)('variables' hasVariable variableName)!!PinMorph class reorganize!('class initialization' initialize)('new-morph participation' includeInNewMorphMenu)!PinMorph removeSelector: #privateMoveBy:!!PinMorph reorganize!('accessing' pinSpec)('event handling' handlesMouseDown: mouseDown: mouseMove:)('geometry' placeFromSpec position: updateImage wiringEndPoint)('initialization' component:pinSpec: initialize)('submorphs-add/remove' delete)('variables' addModelVariable hasVariable mergeVariableWith: removeModelVariable removeVariableAccess shareVariableOf:)('wires' addWire: canDockWith: connectedPins isIsolated removeWire: startWiring: unwire wireTo:)!!PianoRollNoteMorph class reorganize!('no messages')!!PianoRollNoteMorph reorganize!('accessing' indexInTrack trackIndex)('drawing' drawOn:)('editing' editPitch: gridToNextQuarter gridToPrevQuarter)('event handling' handlesMouseDown: mouseDown: mouseMove: mouseUp:)('initialization' trackIndex:indexInTrack:)('layout' fullBounds)('menu' invokeNoteMenu:)('note playing' noteInScore noteOfDuration: playSound playSound: soundOfDuration:)('selecting' deselect select selectFrom: selectNotes: selected)!!PartsBin class reorganize!('class initialization' initialize)('instance creation' newPartsBinWithOrientation:from:)('thumbnail cache' cacheAllThumbnails cacheThumbnail:forSymbol: clearThumbnailCache thumbnailForInstanceOf: thumbnailForPartsDescription: thumbnailForQuad:)!!IndexTabs class reorganize!('printing' defaultNameStemForInstances)!!GeeBookPageMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!ComponentLayout class reorganize!('no messages')!!PasteUpMorph class reorganize!('class initialization' initialize)('parts bin' descriptionForPartsBin supplementaryPartsDescriptions)('printing' defaultNameStemForInstances)('project' MinCycleLapse: disableDeferredUpdates disableDeferredUpdates: newWorldForProject: newWorldTesting)('scripting' additionsToViewerCategories authoringPrototype)('system startup' shutDown startUp)!!PartsBin reorganize!('dropping/grabbing' morphToDropFrom: wantsDroppedMorph:event:)('initialization' listDirection:quadList:)('naming' innocuousName)!!IndexTabs reorganize!('accessing' highlightColor highlightColor: regularColor regularColor:)('change reporting' ownerChanged)('dropping/grabbing' repelsMorph:event:)('highlighting' highlightColor:regularColor: highlightTab: highlightTabFor: highlightedTab)('initialization' defaultBorderWidth defaultColor initialize)('layout' basicHeight basicWidth fixedWidth: laySubpartsOutInOneRow requiredWidth rowsNoWiderThan: widthImposedByOwner)('selection' selectTab:)('tabs' addTab: addTabFor:font: addTabForBook: tabMorphs)!GeeBookPageMorph removeSelector: #handlesMouseDown:!!GeeBookPageMorph reorganize!('as yet unclassified' geeMail:geeMailRectangle:)('drawing' fullDrawOn:)('event handling' mouseDown:)!!ComponentLayout reorganize!('as yet unclassified' inspectModelInMorphic)('initialization' initialize)('layout' acceptDroppingMorph:event:)('menus' addCustomMenuItems:hand:)('model' createCustomModel)('submorphs-accessing' allKnownNames)!PasteUpMorph removeSelector: #containsCard:!!PasteUpMorph reorganize!('Nebraska' addRemoteClient: convertRemoteClientToBuffered: hasRemoteServer releaseRemoteServer remoteServer remoteServer: removeRemoteClient: transferRemoteServerFrom:)('WiW support' addMorphInLayer: morphicLayerNumber restartWorldCycleWithEvent: shouldGetStepsFrom: validateMouseEvent:)('accessing' assureFlapWidth: flapTab modelOrNil presenter useRoundedCorners)('alarms-scheduler' addAlarm:withArguments:for:at: removeAlarm:for:)('caching' releaseCachedState)('change reporting' invalidRect:from:)('classification' isPlayfieldLike isWorldMorph)('copying' veryDeepCopyWith:)('cursor' cursorWrapped: numberAtCursor rectifyCursor selectedRect valueAtCursor valueAtCursor:)('debug and other' addViewingItemsTo: buildDebugMenu:)('display' gradientFillColor: setGradientColor:)('drawing' drawOn:)('dropping/grabbing' automaticPhraseExpansion dropEnabled justDroppedInto:event: morphToDropFrom: originAtCenter positionNear:forExtent:adjustmentSuggestion: repelsMorph:event: wantsDroppedMorph:event:)('e-toy support' automaticViewing cursor cursor: fenceEnabled isCandidateForAutomaticViewing referencePlayfield)('event handling' dropFiles: handlesKeyboard: handlesMouseDown: keyStroke: morphToGrab: mouseDown: mouseUp: wantsDropFiles: wantsKeyboardFocusFor:)('events-processing' processEvent:using:)('fileIn/out' prepareToBeSaved)('flaps' accommodateFlap: addGlobalFlaps assureFlapTabsFitOnScreen bringFlapTabsToFront correspondingFlapTab deleteAllFlapArtifacts deleteGlobalFlapArtifacts enableGlobalFlaps flapTabs localFlapTabs offsetForAccommodating:onEdge: paintingFlapTab releaseViewers removeAccommodationForFlap:)('genie-processing' allowsGestureStart:)('geometry' extent: gridPoint: position:)('geometry testing' fullContainsPoint:)('gridding' gridModulus gridModulus: gridOrigin gridOrigin: gridSpec gridSpecPut: gridVisible gridVisibleOnOff gridVisibleString griddingOn griddingOnOff griddingString setGridSpec)('halos and balloon help' defersHaloOnClickTo: wantsDirectionHandles wantsHaloFor: wantsHaloFromClick)('initialization' becomeActiveDuring: defaultBorderColor defaultBorderWidth defaultColor initialize newResourceLoaded)('interaction loop' doOneCycleNow)('layout' acceptDroppingMorph:event: addCenteredAtBottom:offset: convertAlignment laySubpartsOutInOneRow layoutChanged)('macpal' currentVocabulary)('menu & halo' addPenMenuItems:hand: addPenTrailsMenuItemsTo: addPlayfieldMenuItems:hand: addScalingMenuItems:hand: addStackMenuItems:hand: addWorldHaloMenuItemsTo:hand: addWorldToggleItemsToHaloMenu: autoExpansionString autoLineLayoutString autoViewingString batchPenTrailsString defineApplicationView defineFactoryView deleteBalloonTarget: fenceEnabledString indicateCursorString isOpenForDragNDropString isPartsBinString mouseOverHalosString originAtCenterString playfieldOptionsMenu presentCardAndStackMenu presentPlayfieldMenu presentViewMenu reformulateUpdatingMenus showApplicationView showExpandedView showFactoryView showFullView showReducedView showThumbnailString transformToShow:)('menus' addCustomMenuItems:hand:)('misc' abandonCostumeHistory allScriptEditors allScriptors alwaysShowThumbnail cachedOrNewThumbnailFrom: cartesianOrigin closedViewerFlapTabs heightForThumbnails hideFlapsOtherThan:ifClingingTo: hideViewerFlaps hideViewerFlapsOtherThanFor: impartPrivatePresenter makeDetachable maxHeightToAvoidThumbnailing maximumThumbnailWidth mouseX mouseY nameForCopyIfAlreadyNamed: padding: roundUpStrays smallThumbnailForPageSorter startRunningAll stepAll stopRunningAll thumbnailForPageSorter unhideHiddenObjects updateStatusForAllScriptEditors viewerFlapTabFor:)('model' createCustomModel model setModel:)('naming' innocuousName)('objects from disk' convertToCurrentVersion:refStream: saveOnFile)('options' autoLineLayout autoLineLayout: automaticViewing: batchPenTrails batchPenTrails: becomeLikeAHolder behaveLikeAHolderString behaveLikeHolder behaveLikeHolder: behavingLikeAHolder fenceEnabled: indicateCursor indicateCursor: isPartsBin: replaceTallSubmorphsByThumbnails resizeToFit resizeToFitString setPartsBinStatusTo: setThumbnailHeight toggleAlwaysShowThumbnail toggleAutoLineLayout toggleAutomaticPhraseExpansion toggleAutomaticViewing toggleBatchPenTrails toggleBehaveLikeAHolder toggleFenceEnabled toggleIndicateCursor toggleIsPartsBin toggleMouseOverHalos toggleOriginAtCenter toggleResizeToFit updateSubmorphThumbnails wantsMouseOverHalos wantsMouseOverHalos:)('painting' backgroundForm backgroundForm: backgroundSketch backgroundSketch: deleteBackgroundPainting makeNewDrawingWithin paintBackground paintingBoundsAround: prepareToPaint prepareToPaint: reasonablePaintingExtent)('parts bin' initializeToStandAlone isPartsBin residesInPartsBin)('pen' addImageToPenTrailsFor: arrowheadsOnAllPens clearTurtleTrails createOrResizeTrailsForm drawPenTrailFor:from:to: liftAllPens lowerAllPens noArrowheadsOnAllPens noteNewLocation:forPlayer: notePenDown:forPlayer:at: trailMorph updateTrailsForm)('printing' printOn:)('project' project releaseSqueakPages storeProjectsAsSegments)('project state' canvas firstHand hands handsDo: isStepping: isStepping:selector: listOfSteppingMorphs stepListSize stepListSummary steppingMorphsNotInWorld viewBox viewBox:)('scripting' abandonOldReferenceScheme adaptedToWorld: allTileScriptingElements currentVocabularyFor: hideAllPlayers modernizeBJProject recreateScripts relaunchAllViewers scriptorForTextualScript:ofPlayer: showAllPlayers)('stepping' cleanseStepList runLocalStepMethods runStepMethods startStepping: startStepping:at:selector:arguments:stepTime: stopStepping: stopStepping:selector:)('stepping and presenter' step)('structure' activeHand world)('submorphs-accessing' allMorphsDo: morphsInFrontOf:overlapping:do:)('submorphs-add/remove' addAllMorphs: addMorphFront:)('testing' stepTime)('undo' clearCommandHistory commandHistory)('update cycle' startBackgroundProcess)('user interface' modelWakeUp)('viewer' defaultNameStemForInstances)('viewing' imposeListViewSortingBy:retrieving: restoreBoundsOfSubmorphs saveBoundsOfSubmorphs scriptSelectorToTriggerFor: showingListView sortSubmorphsBy: viewByIcon viewByName viewBySize viewNonOverlapping viewingByIconString viewingByNameString viewingBySizeString viewingNonOverlappingString viewingNormally)('visual properties' canHaveFillStyles)('world menu' activateObjectsTool addUndoItemsTo: bringWindowsFullOnscreen buildWorldMenu: closeUnchangedWindows collapseAll collapseNonWindows connectRemoteUser connectRemoteUserWithName:picture:andIPAddress: deleteNonWindows detachableScriptingSpace disconnectAllRemoteUsers disconnectRemoteUser drawingClass expandAll extractScreenRegion:andPutSketchInHand: findAChangeSorter: findAFileList: findAMessageNamesWindow: findAPreferencesPanel: findATranscript: findAWindowSatisfying:orMakeOneUsing: findDirtyBrowsers: findDirtyWindows: findWindow: getWorldMenu: grabDrawingFromScreen: grabFloodFromScreen: grabLassoFromScreen: grabRubberBandFromScreen: invokeWorldMenu: keystrokeInWorld: makeNewDrawing: makeNewDrawing:at: newDrawingFromMenu: openRecentSubmissionsBrowser: openScrapsBook: printScriptSummary putUpDesktopMenu: putUpWorldMenu: putUpWorldMenuFromEscapeKey removeAllViewers reportLocalAddress showStatusOfAllScripts yellowButtonClickOnDesktopWithEvent:)('world state' abandonAllHalos abandonVocabularyPreference activeHand: addHand: addMorph:centeredNear: addMorphsAndModel: allNonFlapRelatedSubmorphs assureNotPaintingElse: assureNotPaintingEvent: assuredCanvas beWorldForProject: checkCurrentHandForObjectToPaste checkCurrentHandForObjectToPaste2 chooseClickTarget colorAt:belowMorph: currentNaturalLanguage deEmphasizeViewMVC: deleteAllHalos displayWorld displayWorldAsTwoTone displayWorldNonIncrementally displayWorldSafely doOneCycle doOneCycleInBackground doOneSubCycle dragThroughOnDesktop: embeddedProjectDisplayMode endDrawing: exit flashRects:color: fullRepaintNeeded goBack haloMorphOrNil haloMorphs handleFatalDrawingError: initForProject: install installAsActiveSubprojectIn:at:titled: installAsActiveSubprojectIn:titled: installFlaps installVectorVocabulary jumpToProject nextPage open openWithTitle:cautionOnClose: optimumExtentFromAuthor paintArea paintAreaFor: paintBox paintBoxOrNil patchAt:without:andNothingAbove: pauseEventRecorder previousPage privateOuterDisplayWorld removeHand: repairEmbeddedWorlds repositionFlapsAfterScreenSizeChange restoreDisplay restoreFlapsDisplay restoreMorphicDisplay saveAsWorld sketchEditorOrNil sleep someHalo specialNameInModelFor: standardPlayerHit standardSystemController startSteppingSubmorphsOf: triggerClosingScripts triggerOpeningScripts)('private' privateFullMoveBy: privateMoveBy:)!!PaintInvokingMorph class reorganize!('parts bin' descriptionForPartsBin)('scripting' authoringPrototype)!!PaintInvokingMorph reorganize!('dropping/grabbing' justDroppedInto:event: wantsToBeDroppedInto:)('e-toy support' isCandidateForAutomaticViewing)('initialization' initialize)('parts bin' initializeToStandAlone)!!PaintBoxMorph class reorganize!('as yet unclassified' fixUpPrototype initializeColorChart prototype)('class initialization' initialize)('instance creation' new)!!PaintBoxMorph reorganize!('actions' action actionCursor brush:action:nib:evt: brushable clear:with:evt: colorable currentColor:evt: cursorFor:oldCursor:currentNib:color: deleteCurrentStamp: eyedropper:action:cursor:evt: getColor getNib getSpecial grabFromScreen: indicateColorUnderMouse keep:with:evt: notCurrentlyPainting pickup:action:cursor:evt: pickupForm: pickupForm:evt: plainCursor plainCursor:event: ringColor ringColorFor: scrollStamps:action:evt: setAction:evt: showColor showColorPalette: stampCursorBeCursorFor: stampDeEmphasize stampForm stampHolder stampHolder: takeColor:event: takeColorEvt:from: toggleShapes toggleStamps tool tool:action:cursor:evt: toss:with:evt: undo:with:evt:)('copying' updateReferencesUsing:)('e-toy support' isCandidateForAutomaticViewing)('initialization' addWeakDependent: beStatic createButtons fixupButtons init3 init4 initialize loadColorChooser loadCursors loadOnImage: loadPressedImage: loadoffImage: moveButtons noVeneer notifyWeakDependentsWith:)('menus' addCustomMenuItems:hand:)('other' colorMemory colorMemory: colorPatch focusMorph focusMorph: maxBounds offsetFromMaxBounds rotationTabForm scaleTabForm)('recent colors' fixUpColorPicker fixUpRecentColors mouseDownRecent:with: mouseStillDownRecent:with: mouseUpRecent:with: recentColor:)('user interface' mouseUpBalk:)!!PaintBoxColorPicker class reorganize!('no messages')!!PaintBoxColorPicker reorganize!('accessing' currentColor currentColor:)('drawing' drawOn: ringColor)('event handling' endColorSelection: initMouseHandlers selectColor: startColorSelection:)('initialization' beStatic initialize)!!PDAToDoItem class reorganize!('no messages')!!PDAToDoItem reorganize!('as text' asListItem)('comparing' <=)('day done' dayDone dayDone:)('day posted' dayPosted dayPosted: matchesDate:)('deadline' deadline deadline:)('priority' priority priority:)('result' result result:)!!PDARecurringEvent class reorganize!('as yet unclassified' chooseRecurrence)!!PDARecurringEvent reorganize!('as text' readField:fromString:fields:base:)('as yet unclassified' firstDate: lastDate: recurrence recurrence: validRecurrenceSymbols)('date' matchesDate:)('key' matchesKey:andMatchesDate:)!!PDAPerson class reorganize!('no messages')!!PDAEvent class reorganize!('no messages')!!PDARecord class reorganize!('no messages')!!PDAPerson reorganize!('as text' asListItem)('comparing' <=)('public access' address address: email email: name: phone phone:)('testing' name)!!PDAEvent reorganize!('as text' asListItem)('comparing' <=)('date' date date: matchesDate:)('duration' duration duration:)('time' time time:)!!PDARecord reorganize!('as text' allFieldsWithValuesDo: asListItem asText readField:fromString:fields:base: readFrom: sharedFieldsWithBaseDo: sharedFieldsWithValuesDo:)('comparing' <=)('description' description description:)('key' key key: matchesKey: matchesKey:andMatchesDate: rekey:to:)('other fields' otherFields otherFields:)('printing' printOn:)!!PDA class reorganize!('no messages')!!PDA reorganize!('category' categoryChoices categorySelected chooseFrom:categoryItem: selectCategory:)('currentItem' acceptCurrentItemText: clearUserEditFlag currentItem currentItem: currentItemMenu: currentItemSelection currentItemSelection: currentItemText toggleDescriptionMode updateCurrentItem)('date' selectDate: setDate:fromButton:down:)('example' sampleCategoryList sampleNotes samplePeopleList sampleRecurringEventsList sampleScheduleList sampleToDoList)('initialization' initialize labelString loadDatabase mergeDatabase openAsMorphIn: openMonthView rekeyAllRecordsFrom:to: saveDatabase userCategories:allPeople:allEvents:recurringEvents:allToDoItems:allNotes:dateSelected:)('menus' perform:orSendTo:)('notes' addNote notesList notesListIndex notesListIndex: notesListItems notesMenu: removeNote updateNotesList)('people' addPerson peopleList peopleListIndex peopleListIndex: peopleListItems peopleMenu: removePerson updatePeopleList)('schedule' addEvent addRecurringEvent declareLastDate declarelastDate removeEvent scheduleList scheduleListForDay: scheduleListIndex scheduleListIndex: scheduleListItems scheduleMenu: updateScheduleList)('to do' addToDoItem declareItemDone removeToDoItem toDoList toDoListIndex toDoListIndex: toDoListItems toDoMenu: updateToDoList)('updating' okToChange)!!NullTerminalMorph class reorganize!('no messages')!!NullTerminalMorph reorganize!('drawing' drawOn: forceToFront:)('geometry' extent:)!!MultiResolutionCanvas class reorganize!('no messages')!!ColorPatchCanvas class reorganize!('no messages')!!FormCanvas class reorganize!('instance creation' extent: extent:depth: on:)('testing' test1 test2 test3)!!AlphaBlendingCanvas class reorganize!('no messages')!!ColorMappingCanvas class reorganize!('instance creation' on:)!!Canvas class reorganize!('configuring' filterSelector)!!ByteEncoder class reorganize!('configuring' defaultTarget filterSelector numberDefaultBase)!!FlattenEncoder class reorganize!('configuring' filterSelector)!!NullEncoder class reorganize!('configuring' defaultTarget filterSelector)('creation' stream stream: streamOn: streamOnFile:)('processing' process:)!!MultiResolutionCanvas reorganize!('as yet unclassified' deferredMorphs deferredMorphs: initializeFrom:)('drawing-general' fullDraw:)!!ColorPatchCanvas reorganize!('accessing' doStop doStop: foundMorph foundMorph: stopMorph stopMorph:)('drawing-general' fullDrawMorph:)('drawing-support' clipBy:during: preserveStateDuring: transformBy:clippingTo:during:smoothing: translateBy:during: translateTo:clippingTo:during:)('initialization' reset)('other' translateBy:clippingTo:during:)('private' setForm:)!BalloonCanvas removeSelector: #drawPolygon:color:borderWidth:borderColor:!FormCanvas removeSelector: #transform2By:clippingTo:during:smoothing:!FormCanvas removeSelector: #translateBy:clippingTo:during:!!FormCanvas reorganize!('accessing' allocateForm: clipRect contentsOfArea:into: depth extent form origin shadowColor shadowColor:)('converting' asShadowDrawingCanvas asShadowDrawingCanvas:)('copying' copy copyClipRect: copyOffset: copyOffset:clipRect: copyOrigin:clipRect:)('drawing' fillColor: line:to:brushForm: line:to:width:color: paragraph:bounds:color: point:color: render:)('drawing-general' roundCornersOf:in:during:)('drawing-images' stencil:at:sourceRect:color: warpImage:transform:at:sourceRect:cellSize:)('drawing-ovals' balloonFillOval:fillStyle:borderWidth:borderColor: fillOval:color:borderWidth:borderColor: fillOval:fillStyle:borderWidth:borderColor:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor: drawPolygon:fillStyle:borderWidth:borderColor:)('drawing-rectangles' balloonFillRectangle:fillStyle: fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: infiniteFillRectangle:fillStyle:)('drawing-support' clipBy:during: transformBy:clippingTo:during:smoothing: translateBy:during: translateTo:clippingTo:during:)('drawing-text' drawString:from:to:at:font:color: drawString:from:to:in:font:color:)('initialization' finish reset)('other' asBalloonCanvas flushDisplay forceToScreen: showAt: showAt:invalidRects: warpFrom:toRect:)('printing' printOn:)('testing' isShadowDrawing isVisible:)('private' image:at:sourceRect:rule: image:at:sourceRect:rule:alpha: portClass privateClipRect privatePort privateWarp:transform:at:sourceRect:cellSize: resetGrafPort setClearColor: setFillColor: setForm: setOrigin:clipRect: setPaintColor: setStencilColor:form:)!!AlphaBlendingCanvas reorganize!('accessing' alpha alpha:)('initialization' on:)('private' image:at:sourceRect:rule: mapColor:)!!ColorMappingCanvas reorganize!('accessing' clipRect depth extent form origin)('drawing' line:to:width:color: paragraph:bounds:color:)('drawing-images' stencil:at:color: stencil:at:sourceRect:color:)('drawing-ovals' fillOval:color:borderWidth:borderColor:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor:)('drawing-rectangles' frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor:)('drawing-support' clipBy:during: preserveStateDuring: transformBy:clippingTo:during:smoothing: translateBy:during: translateTo:clippingTo:during:)('drawing-text' drawString:from:to:in:font:color:)('initialization' flush on: reset)('other' translateBy:clippingTo:during:)('testing' isShadowDrawing)('private' image:at:sourceRect:rule: mapColor:)!!Canvas reorganize!('Nebraska/embeddedWorlds' displayIsFullyUpdated transform2By:clippingTo:during:smoothing:)('accessing' clipRect contentsOfArea: contentsOfArea:into: depth extent form origin shadowColor shadowColor:)('converting' asAlphaBlendingCanvas: asShadowDrawingCanvas asShadowDrawingCanvas:)('copying' copy copyClipRect:)('drawing' fillColor: line:to:brushForm: line:to:color: line:to:width:color: line:to:width:color:dashLength:secondColor:secondDashLength:startingOffset: line:to:width:color:stepWidth:secondWidth:secondColor:secondStepWidth: paragraph2:bounds:color: paragraph:bounds:color: point:color: render:)('drawing-general' draw: drawMorph: fullDraw: fullDrawMorph: roundCornersOf:during: roundCornersOf:in:during:)('drawing-images' drawImage:at: drawImage:at:sourceRect: paintImage:at: paintImage:at:sourceRect: stencil:at:color: stencil:at:sourceRect:color: translucentImage:at: translucentImage:at:sourceRect: warpImage:transform: warpImage:transform:at: warpImage:transform:at:sourceRect:cellSize:)('drawing-obsolete' image:at: image:at:rule: imageWithOpaqueWhite:at:)('drawing-ovals' fillOval:color: fillOval:color:borderWidth:borderColor: fillOval:fillStyle: fillOval:fillStyle:borderWidth:borderColor: frameOval:color: frameOval:width:color:)('drawing-polygons' drawPolygon:color:borderWidth:borderColor: drawPolygon:fillStyle: drawPolygon:fillStyle:borderWidth:borderColor:)('drawing-rectangles' fillRectangle:color: fillRectangle:fillStyle: fillRectangle:fillStyle:borderStyle: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor: frameRectangle:color: frameRectangle:width:color:)('drawing-support' cache:using:during: clipBy:during: preserveStateDuring: transformBy:clippingTo:during: transformBy:clippingTo:during:smoothing: translateBy:during: translateTo:clippingTo:during:)('drawing-text' drawString:at: drawString:at:font:color: drawString:from:to:at:font:color: drawString:from:to:in:font:color: drawString:in: drawString:in:font:color: text:at:font:color: text:bounds:font:color:)('initialization' finish flush reset)('other' flushDisplay forceToScreen: translateBy:clippingTo:during:)('testing' doesRoundedCorners isBalloonCanvas isShadowDrawing isVisible: seesNothingOutside:)('private' image:at:sourceRect:rule: image:at:sourceRect:rule:alpha:)!!ByteEncoder reorganize!('accessing' numberDefaultBase)('filter streaming' elementSeparator)('writing' cr print: space tab writeArray: writeAssocation: writeCollection: writeCollectionContents: writeNumber: writeNumber:base: writeObject: writeString:)!!FlattenEncoder reorganize!('filter streaming' elementSeparator)('writing' cr writeArrayedCollection: writeCollection: writeCollectionContents: writeCollectionContents:separator: writeCollectionContents:separator:iterationMessage: writeDictionary: writeDictionaryContents:separator:)!!NullEncoder reorganize!('accessing' close contents target)('initialization' initWithTarget:)('processing' process:)('writing' forward: write: writeObject:)!!NewParagraph class reorganize!('no messages')!!NewParagraph reorganize!('access' adjustedFirstCharacterIndex extent firstCharacterIndex lastCharacterIndex numberOfLines string text textOwner: textStyle textStyle: wantsColumnBreaks wantsColumnBreaks:)('alignment' centered justified leftFlush rightFlush)('composition' OLDcomposeLinesFrom:to:delta:into:priorLines:atY: compose:style:from:in: composeAll composeAllStartingAt: composeLinesFrom:to:delta:into:priorLines:atY: compositionRectangle fixLastWithHeight: recomposeFrom:to:delta: testNewComposeAll)('copying' deepCopy)('display' asParagraphForPostscript caretWidth displayOn:using:at: displaySelectionInLine:on: insertionPointColor selectionColor)('editing' clickAt:for:controller: replaceFrom:to:with:displaying:)('selection' characterBlockAtPoint: characterBlockForIndex: containsPoint: defaultCharacterBlock selectionRects selectionRectsFrom:to: selectionStart:selectionStop:)('private' adjustLineIndicesBy: adjustRightX fastFindFirstLineSuchThat: indentationOfLineIndex:ifBlank: lineIndexForCharacter: lineIndexForPoint: lineIndexOfCharacterIndex: lines moveBy: positionWhenComposed: textStyle:lines:text:)!!NewHandleMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!NewHandleMorph reorganize!('WiW support' morphicLayerNumber)('all' followHand:forEachPointDo:lastPointDo: followHand:forEachPointDo:lastPointDo:withCursor: sensorMode sensorMode:)('dropping/grabbing' justDroppedInto:event: undoGrabCommand)('initialization' initialize)('stepping and presenter' step)('submorphs-add/remove' delete)!!NetworkTerminalMorph class reorganize!('instance creation' connectTo: connectTo:port: openAndConnectTo: openAndConnectTo:port: socketConnectedTo:port:)!!NetworkTerminalMorph reorganize!('as yet unclassified' addScalingMenuItems:hand:)('drawing' areasRemainingToFill: drawOn: forceToFront: updateBackgroundForm)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' commResult: handlesMouseOver: mouseEnter: mouseLeave: sendEvent: sendEventAsIs:)('events-processing' handleKeyDown: handleKeyUp: handleKeystroke: handleMouseDown: handleMouseMove: handleMouseUp: handlerForMouseDown:)('geometry' extent:)('initialization' connection: initialize openInStyle: openScaled)('layout' acceptDroppingMorph:event:)('shutting down' disconnect requestBufferedConnection)('stepping and presenter' step)('testing' stepTime)!!NebraskaServer class reorganize!('as yet unclassified' defaultPort extremelyBigRectangle)('instance creation' new newForWorld: serveWorld: serveWorld:onPort:)!!NebraskaServer reorganize!('accessing' clients)('attributes' extent:depth: numClients sharedWorld)('initialization' destroy initialize initializeForWorld:)('menus' step)('networking' acceptNewConnections acceptNullConnection acceptPhonyConnection addClientFromConnection: backlog processIO pruneDeadConnections startListeningOnPort: stopListening)!!NebraskaDebug class reorganize!('as yet unclassified' at:add: beginStats killStats showAndClearStats: showStats showStats: showStats:from: stopAndShowAll)!!NebraskaDebug reorganize!('no messages')!!NebraskaClient class reorganize!('instance creation' onConnection:)!!NebraskaClient reorganize!('as yet unclassified' backlog currentStatusString)('attributes' canvas hand)('initialization' convertToBuffered destroy initialize:)('network' extent:depth: isConnected processIO)!!MovingEyeMorph class reorganize!('class initialization' initialize)('parts bin' descriptionForPartsBin)!!MovingEyeMorph reorganize!('as yet unclassified' irisPos:)('geometry' extent:)('initialization' defaultColor initialize)('stepping and presenter' step)('testing' stepTime)!!MovieMorph class reorganize!('no messages')!!MovieMorph reorganize!('accessing' form scalePoint scalePoint:)('drawing' drawOn:)('geometry testing' containsPoint:)('initialization' defaultColor initialize)('menu' advanceFrame editDrawing extractFrame: insertIntoMovie: nextFrame playLoop playOnce previousFrame stopPlaying)('menus' addCustomMenuItems:hand:)('rotate scale and flex' rotationDegrees)('stepping and presenter' step)('testing' stepTime)('private' currentFrame insertFrames: setFrame:)!!MovieClipEndMorph class reorganize!('no messages')!!MovieClipStartMorph class reorganize!('no messages')!!MovieFrameSyncMorph class reorganize!('no messages')!!MovieClipEndMorph reorganize!('as yet unclassified' movieFileName:image:player:frameNumber:)('drawing' thumbnailHeight)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: pauseFrom: resetFrom: resumeFrom:)!MovieClipStartMorph removeSelector: #nextSyncEventAfter:inTrack:!!MovieClipStartMorph reorganize!('access' endMorph frameNumber: movieClipPlayer: relatedPlayer scoreEvent)('drawing' colorMargin colorMorph soundTrackHeight soundTrackOnBottom thumbnailHeight)('dropping/grabbing' justDroppedInto:event:)('events' endTime frameAtTick: startTime)('initialization' image:frameNumber: movieFileName:soundTrackFileName:image:player:frameNumber:)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: resetFrom: resumeFrom:)('submorphs-add/remove' delete)('private' buildSoundTrackMorphFor: setEndFrameNumber: setEndFrameNumber:tickTime: setTimeInScore:near:)!!MovieFrameSyncMorph reorganize!('access' frameNumber moviePlayerMorph relatedPlayer)('dropping/grabbing' justDroppedInto:event:)('events' nextSyncEventAfter:inTrack:)('initialization' image:player:frameNumber:)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: justDroppedIntoPianoRoll:event: pauseFrom: resetFrom: resumeFrom:)!!MouseOverHandler class reorganize!('instance creation' new)!!MouseOverHandler reorganize!('event handling' noticeMouseOver:event: processMouseOver:)('initialize-release' initialize)!!MouseClickState class reorganize!('no messages')!!MouseClickState reorganize!('event handling' click doubleClick doubleClickTimeout drag: handleEvent:from:)('initialize' client:click:dblClick:dblClickTime:dblClickTimeout:drag:threshold:event:)!!MouseActionIndicatorMorph class reorganize!('as yet unclassified' world:inner:outer:color:)!!MouseActionIndicatorMorph reorganize!('as yet unclassified' deleteWithSiblings siblings:)('event handling' handlesMouseOver: handlesMouseOverDragging: mouseEnter: mouseEnterDragging:)('initialization' initialize)!!MorphicUnknownEvent class reorganize!('no messages')!!MorphicUnknownEvent reorganize!('accessing' argument argument: position type)('initialize' type:readFrom:)('objects from disk' convertToCurrentVersion:refStream:)('printing' storeOn:)('private' setType:argument: setType:argument:hand:stamp:)!!EToyGateKeeperEntry class reorganize!('new-morph participation' includeInNewMorphMenu)!!ComponentLikeModel class reorganize!('no messages')!!MorphicModel class reorganize!('compilation' categoryForSubclasses chooseNewName compileAccessorsFor: compilePropagationForVarName:slotName:)('compiling' acceptsLoggingOfCompilation wantsChangeSetLogging)('housekeeping' removeUninstantiatedModels)('instance creation' new newBounds:model:slotName:)('new-morph participation' includeInNewMorphMenu)('prototype access' prototype prototype:)('queries' baseUniclass hasPrototype)('subclass creation' newSubclass)('testing' officialClass)!!EToyGateKeeperEntry reorganize!('as yet unclassified' acceptableTypes dateAndTimeStringFrom: fullInfoString getChoice: ipAddress ipAddress: lastIncomingMessageTimeString lastTimeChecked lastTimeChecked: lastTimeCheckedString latestUserName latestUserName: requestAccessOfType: statusReplyReceived: statusReplyReceivedString timeBetweenLastAccessAnd: toggleChoice:)('initialization' initialize)!!ComponentLikeModel reorganize!('components' addPinFromSpec: deleteComponent initComponentIn: initFromPinSpecs initPinSpecs nameMeIn: pinSpecs pinsDo: renameMe showPins)('dropping/grabbing' justDroppedInto:event:)('geometry' extent:)('initialization' duplicate:from:)('naming' choosePartName)('submorphs-add/remove' delete)!MorphicModel removeSelector: #defaultBorderWidth!MorphicModel removeSelector: #instanceVariableValues!!MorphicModel reorganize!('access' model slotName wantsSlot)('accessing' modelOrNil)('caching' releaseCachedState)('classification' isMorphicModel)('compilation' addPartNameLike:withValue: compileAccessForSlot: compileInitMethods compilePropagationMethods nameFor: propagate:as: removeAll slotSelectorFor: use:orMakeModelSelectorFor:in:)('debug and other' installModelIn:)('drag and drop' allowSubmorphExtraction isOpen)('geometry' newBounds: recomputeBounds)('initialization' defaultBorderColor defaultBounds defaultColor duplicate:from: initialize model: model:slotName:)('menu' closeToEdits openToEdits)('menus' addCustomMenuItems:hand:)('naming' choosePartName)('printing' initString)('submorphs-accessing' allKnownNames)('submorphs-add/remove' delete)!!MorphicEventEncoder class reorganize!('instance creation' on:)!!MorphicEventEncoder reorganize!('initialization' connection:)('network I/O' flush processIO requestBufferedConnection sendEvent: sendViewExtent:)!!MorphicEventDispatcher class reorganize!('no messages')!!MorphicEventDispatcher reorganize!('dispatching' dispatchDefault:with: dispatchDropEvent:with: dispatchEvent:with: dispatchMouseDown:with:)!!MorphicEventDecoder class reorganize!('instance creation' on:)!!MorphicEventDecoder reorganize!('handling messages' apply:to: applyEventMessage:to: applyMessagesTo: applyViewExtentMessage:to: processIO)('initialization' connection:)!!DropFilesEvent class reorganize!('no messages')!!DropEvent class reorganize!('no messages')!!MorphicEvent class reorganize!('instance creation' convertObsolete: fromStringArray: readFrom: readFromObsolete: type:readFrom:)!!DropFilesEvent reorganize!('accessing' type)('dispatching' sentTo:)!!DropEvent reorganize!('accessing' contents cursorPoint position type wasHandled wasHandled:)('dispatching' sentTo:)('initialize' copyHandlerState: resetHandlerFields)('printing' printOn:)('testing' isDropEvent)('transforming' transformBy: transformedBy:)('private' setPosition:contents:hand:)!!MorphicEvent reorganize!('accessing' cursorPoint hand timeStamp type wasHandled wasHandled:)('comparing' = hash)('dispatching' sentTo:)('initialize' copyHandlerState: resetHandlerFields type:readFrom:)('object fileIn' convertOctober2000:using:)('objects from disk' convertToCurrentVersion:refStream:)('testing' isDraggingEvent isDropEvent isKeyboard isKeystroke isMorphicEvent isMouse isMouseOver)('transforming' transformedBy:)('private' setHand: setTimeStamp:)!!MorphicAlarm class reorganize!('instance creation' scheduledAt:receiver:selector:arguments:)!!MorphicAlarm reorganize!('accessing' scheduledTime scheduledTime:)('evaluating' value:)!!MorphWorldView class reorganize!('instance creation' convertToMVCWiWPasteUpMorph fullColorWhenInactive fullColorWhenInactive: openOn: openOn:label: openOn:label:cautionOnClose: openOn:label:extent: openOn:label:model: openWorld openWorldWith:labelled:)!!MorphWorldView reorganize!('as yet unclassified' updateSubWindowExtent)('controller access' defaultControllerClass)('deEmphasizing' deEmphasizeView)('displaying' displayView)('updating' update:)('private' computeInsetDisplayBox)!!MorphWorldController class reorganize!('no messages')!!MorphWorldController reorganize!('basic control sequence' controlInitialize controlLoop controlTerminate)('control defaults' controlActivity isControlActive)!!MorphExtension class reorganize!('no messages')!!MorphExtension reorganize!('accessing' actorState actorState: balloonText balloonText: balloonTextSelector balloonTextSelector: eventHandler eventHandler: externalName: isPartsDonor isPartsDonor: locked locked: player player: sticky sticky: visible visible:)('accessing - layout properties' layoutFrame layoutFrame: layoutPolicy layoutPolicy: layoutProperties layoutProperties:)('accessing - other properties' assureOtherProperties hasOtherProperties hasProperty: initializeOtherProperties otherProperties privateOtherProperties: removeOtherProperties removeProperty: setProperty:toValue: sortedPropertyNames valueOfProperty: valueOfProperty:ifAbsent: valueOfProperty:ifAbsentPut:)('copying' copyWeakly updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('initialization' initialize)('object fileIn' convertProperty:toValue:)('objects from disk' comeFullyUpOnReload:)('other' inspectElement isDefault)('printing' printOn:)('viewer' externalName)!!MenuLineMorph class reorganize!('no messages')!!FlashTextMorph class reorganize!('no messages')!!FlashPlayerMorph class reorganize!('project transition' transitionFrom: transitionFrom:to: transitionTo:)('scripting' additionsToViewerCategories)!!FlashSpriteMorph class reorganize!('no messages')!!FlashShapeMorph class reorganize!('instance creation' shape:)!!FlashMorphingMorph class reorganize!('instance creation' from:to:)!!FlashGlyphMorph class reorganize!('no messages')!!FlashButtonMorph class reorganize!('class initialization' initialize)!!FlashCharacterMorph class reorganize!('no messages')!!FlashMorph class reorganize!('instance creation' withAll:)!!MatrixTransformMorph class reorganize!('no messages')!!MarqueeMorph class reorganize!('no messages')!!FishEyeMorph class reorganize!('parts bin' descriptionForPartsBin)!!MagnifierMorph class reorganize!('instance creation' newRound)('parts bin' descriptionForPartsBin supplementaryPartsDescriptions)!!MPEGDisplayMorph class reorganize!('no messages')!!LedTimerMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!LedMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!LedDigitMorph class reorganize!('class initialization' initialize)('new-morph participation' includeInNewMorphMenu)!!LedCharacterMorph class reorganize!('class initialization' initialize)('new-morph participation' includeInNewMorphMenu)!!ImageMorphWithSpotlight class reorganize!('no messages')!!ImageMorph class reorganize!('accessing' defaultForm)('class initialization' initialize)('instance creation' fromString: fromString:font:)('parts bin' descriptionForPartsBin)('scripting' authoringPrototype)!!HeadMorph class reorganize!('no messages')!!HandleMorph class reorganize!('no messages')!!HandMorphForReplay class reorganize!('no messages')!!HandMorph class reorganize!('accessing' doubleClickTime doubleClickTime:)('class initialization' initialize)('new-morph participation' includeInNewMorphMenu)('utilities' attach: newEventRules: showEvents:)!!HaloMorph class reorganize!('class initialization' initialize)!!Flasher class reorganize!('parts bin' descriptionForPartsBin)!!FlashThumbnailMorph class reorganize!('no messages')!!FlashProgressMorph class reorganize!('no messages')!!FaceMorph class reorganize!('no messages')!!EyeMorph class reorganize!('no messages')!!AtomMorph class reorganize!('new-morph participation' includeInNewMorphMenu)!!AlertMorph class reorganize!('no messages')!!EllipseMorph class reorganize!('parts bin' descriptionForPartsBin)!!DrawErrorMorph class reorganize!('no messages')!!DoCommandOnceMorph class reorganize!('no messages')!!CachingMorph class reorganize!('no messages')!!CRStrokeMorph class reorganize!('no messages')!!CRLineMorph class reorganize!('instance creation' from:to:)!!BouncingAtomsMorph class reorganize!('parts bin' descriptionForPartsBin)!!BorderedSubpaneDividerMorph class reorganize!('as yet unclassified' forBottomEdge forTopEdge horizontal vertical)!!BorderedMorph class reorganize!('no messages')!!BackgroundMorph class reorganize!('as yet unclassified' test)!!Morph class reorganize!('class initialization' initialize)('fileIn/Out' fileReaderServicesForFile:suffix: fromFileName: serviceLoadMorphFromFile services)('initialize-release' unload)('instance creation' initializedInstance new newBounds: newBounds:color: newSticky)('misc' morphsUnknownToTheirOwners)('new-morph participation' addPartsDescriptorQuadsTo:if: includeInNewMorphMenu newStandAlone partName:categories:documentation: partName:categories:documentation:sampleImageForm:)('parts bin' supplementaryPartsDescriptions)('scripting' additionsToViewerCategories additionsToViewerCategory: additionsToViewerCategoryBasic additionsToViewerCategoryColorAndBorder additionsToViewerCategoryDragAndDrop additionsToViewerCategoryGeometry additionsToViewerCategoryLayout additionsToViewerCategoryMiscellaneous additionsToViewerCategoryMotion additionsToViewerCategoryObservation additionsToViewerCategoryPenUse additionsToViewerCategoryScripting additionsToViewerCategoryScripts additionsToViewerCategoryTests authoringPrototype helpContributions vectorAdditions)!!MenuLineMorph reorganize!('drawing' drawOn:)('initialization' initialize)('layout' minHeight minWidth)!!FlashTextMorph reorganize!('no messages')!!FlashPlayerMorph reorganize!('accessing' activeMorphs deferred deferred: isStreaming loadedFrames: localBounds localBounds: loopFrames loopFrames: progressValue progressValue:)('classification' isFlashPlayer)('copying' copyMovieFrom:to:)('disk i/o' compress decompress)('drawing' debugDraw drawOn: drawSubmorphsOn: imageFormOfSize:forFrame:)('e-toy support' asWearableCostumeOfExtent: cursor cursor:)('geometry' boundsChangedFrom:to: computeBounds)('geometry testing' containsPoint: fullContainsPoint:)('holder' cursorWrapped: numberAtCursor selectedRect valueAtCursor valueAtCursor:)('initialization' defaultColor initialize openInMVC openInWorld)('initialize' downloadState downloadStateIn: loadInitialFrame makeControls open sourceUrl:)('layout' fullBounds)('menu' drawFastest drawMedium drawNicest openSorter toggleDeferred)('menus' addCustomMenuItems:hand:)('player' shouldRememberCostumes)('project transition' addFillForProjectTarget: beFullScreenTransition: beTransitionFrom: beTransitionFrom:to: beTransitionTo: playProjectTransitionFrom:to:entering: removeFillForProjectTarget: updateProjectFillsFrom:)('stepping' jump10 rewind stepToFrame: stepToFrameForward: stepToFrameSilently:)('submorphs-add/remove' addMorph:)('private' collectActivationKeys: noticeRemovalOf: privateFullMoveBy:)!!FlashSpriteMorph reorganize!('accessing' addActions:atFrame: addLabel:atFrame: addSound:at: frameNumber frameNumber: loadedFrames loadedFrames: loopFrames loopFrames: maxFrames maxFrames: useTimeSync useTimeSync:)('actions' actionPlay actionStop actionTarget: executeActionsAt: getURL:window: gotoFrame: gotoLabel: gotoNextFrame gotoPrevFrame isFrameLoaded:elseSkip: playSoundsAt: stopSounds toggleQuality)('change reporting' invalidRect:from:)('classification' isFlashSprite isMouseSensitive)('copying' copyMovieFrom:to:)('initialization' initialize)('objects from disk' convertToCurrentVersion:refStream:)('stepping' startPlaying stepBackward stepForward stepTime: stepToFrame: stopPlaying)('stepping and presenter' step)('testing' stepTime wantsSteps)('private' getWebBrowser)!FlashShapeMorph removeSelector: #id!!FlashShapeMorph reorganize!('accessing' color: fillForProjectTarget shape shape:)('classification' isFlashShape)('disk i/o' compress decompress)('drawing' drawOn:)('geometry' computeBounds)!!FlashMorphingMorph reorganize!('copying' updateReferencesUsing:)('initialize' extractShapesFrom: from:to:)('stepping' morphTo: stepToFrame:)!!FlashGlyphMorph reorganize!('accessing' color: defaultAALevel)!!FlashButtonMorph reorganize!('accessing' addSound:forState: ownerSprite trackAsMenu:)('balloon help' analyzeActionsForBalloonHelp:)('classification' isFlashButton isMouseSensitive)('event handling' executeActions: executeSounds: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp: on:send: on:sendAll: simulateMouseDown simulateMouseEnter simulateMouseLeave simulateMouseUp)('events-processing' handlerForMouseDown:)('geometry' lookEnable:disable:)('geometry testing' containsPoint:)('initialize' defaultLook: loadInitialFrame overLook: pressLook: sensitiveLook:)('menu' addCustomAction removeActions)('menus' addCustomMenuItems:hand:)('printing' printOn:)!!FlashCharacterMorph reorganize!('accessing' activationKeys depth id id: isSpriteHolder isSpriteHolder:)('classification' isFlashCharacter)('copying' copyMovieFrom:to:)('drawing' fullDrawOn:)('initialization' initialize)('initialize' loadInitialFrame reset)('keyframe data' colorTransform:atFrame: colorTransformAtFrame: colorTransformData depth:atFrame: depthAtFrame: depthData matrix:atFrame: matrixAtFrame: matrixData ratio:atFrame: ratioAtFrame: ratioData removeAllKeyFrameData removeColorMatrixData removeDepthData removeMatrixData removeRatioData removeVisibleData visible:atFrame: visibleAtFrame: visibleData)('menu' addProjectTarget removeProjectTarget)('menus' addCustomMenuItems:hand:)('printing' printOn:)('stepping' stepTime: stepToFrame: stepToNextFrame)('testing' stepTime wantsSteps)('private' activateSprites: isVisibleBetween:and: keyframeData: removeKeyframeData:)!!FlashMorph reorganize!('accessing' activationKeys colorTransform colorTransform: defaultAALevel defaultAALevel: depth depth: flashPlayer id originalFileSize)('classification' isFlashButton isFlashCharacter isFlashMorph isFlashPlayer isFlashShape isFlashSprite isMouseSensitive)('copying' copyExtension copyMovieFrom:to: duplicate)('disk i/o' compress decompress)('drawing' debugDraw drawSubmorphsOn: fullDrawOn:)('dropping/grabbing' aboutToBeGrabbedBy: justDroppedInto:event:)('initialize' loadInitialFrame lockChildren reset unlockChildren)('menu' getSmoothingLevel nextSmoothingLevel showCompressedSize)('menus' addCustomMenuItems:hand:)('printing' printOn:)('rotate scale and flex' keepsTransform)('sound' playFlashSound:)('submorphs-add/remove' delete)!MatrixTransformMorph removeSelector: #isFlexMorph!MatrixTransformMorph removeSelector: #visible!!MatrixTransformMorph reorganize!('accessing' transform:)('change reporting' invalidRect:from:)('drawing' drawOn: drawSubmorphsOn: visible:)('event handling' transformFrom:)('flexing' changeRotationCenter:with: hasNoScaleOrRotation innerAngle lastRotationDegrees lastRotationDegrees: removeFlexShell rotateBy: rotationDegrees: transform)('geometry' boundsChangedFrom:to: computeBounds extent: handleBoundsChange: transformedBy:)('geometry eToy' heading heading: rotationCenter rotationCenter: setDirectionFrom:)('geometry testing' containsPoint: fullContainsPoint:)('halos and balloon help' balloonHelpTextForHandle:)('initialization' initialize)('initialize' asFlexOf:)('layout' fullBounds)('menus' setRotationCenterFrom:)('rotate scale and flex' addFlexShell)('updating' changed)('private' privateFullMoveBy:)!!MarqueeMorph reorganize!('initialization' initialize)('stepping and presenter' step)('testing' stepTime wantsSteps)!!FishEyeMorph reorganize!('geometry' extent:)('initialization' calculateTransform g:max:focus: initialize transformX: transformY:)('magnifying' magnifiedForm)('menu' chooseMagnification chooseMagnification:)('parts bin' initializeToStandAlone)('private' gridSizeFor:)!!MagnifierMorph reorganize!('accessing' borderWidth: hasTranslucentColor)('drawing' drawOn:)('event handling' handlesMouseDown: mouseDown:)('geometry' defaultExtent extent:)('initialization' defaultBorderWidth defaultColor initialize)('magnifying' magnification: magnifiedForm sourcePoint sourceRect sourceRectFrom:)('menu' chooseMagnification chooseMagnification: toggleTrackingPointer trackingPointerString)('menus' addCustomMenuItems:hand:)('round view' isRound toggleRoundString toggleRoundness)('stepping and presenter' step)('testing' stepTime)!!MPEGDisplayMorph reorganize!('accessing' moviePosition moviePosition: repeat repeat: volume volume:)('commands' nextFrame previousFrame rewindMovie setFrameRate startPlaying stopPlaying)('drawing' areasRemainingToFill: drawOn: drawScaledOn:)('file open/close' closeFile mpegFileIsOpen openFileNamed: openMPEGFile)('geometry' extent:)('initialization' initialize)('menu' addSoundtrack createJPEGfromFolderOfFrames createJPEGfromMPEG createJPEGfromSqueakMovie invokeMenu removeAllSoundtracks toggleRepeat)('other' advanceFrame jpegMovieSize: measureMaxFrameRate)('stepping and presenter' step)('testing' stepTime)!!LedTimerMorph reorganize!('accessing' continue pause reset resume)('initialization' initialize)('stepping' updateTime)('stepping and presenter' start step stop)('testing' stepTime)!!LedMorph reorganize!('accessing' chars chars: color: digits digits: flash: highlighted: scrollLoop scrollLoop: string string: stringToLed value:)('drawing' drawOn:)('initialization' defaultColor initialize scrollInit)('layout' layoutChanged)('macpal' flash)('stepping and presenter' step)('testing' stepTime)!!LedDigitMorph reorganize!('accessing' digit digit: highlighted highlighted:)('drawing' drawOn: drawOnFills:)('initialization' defaultColor initialize)!!LedCharacterMorph reorganize!('accessing' char char: highlighted highlighted:)('drawing' drawOn: drawOnFills:)('initialization' defaultColor initialize)!!ImageMorphWithSpotlight reorganize!('accessing' image:)('all' backgroundImage:spotImage:spotShape: spotChanged)('drawing' drawOn:)('stepping and presenter' step)('testing' stepTime)!!ImageMorph reorganize!('accessing' borderStyle: borderWidth: color: form image image: isOpaque isOpaque: setNewImageFrom:)('caching' releaseCachedState)('card in a stack' couldHoldSeparateDataForEachInstance)('drawing' drawOn: drawPostscriptOn:)('geometry' extent:)('initialization' initialize)('menu' changeOpacity opacityString)('menu commands' grabFromScreen readFromFile)('menus' addCustomMenuItems:hand:)('other' newForm: wearCostume:)('parts bin' initializeToStandAlone)('player' currentDataValue variableDocks)('testing' basicType)!HeadMorph removeSelector: #randomSkinColor!!HeadMorph reorganize!('accessing' face face: playEvent:at:)('accessing-private' queue)('furnitures' addAfroHair addBeret addEars addGlasses addHighHat addLargeMustache addRandomFurnitures addShortHair addShortMustache addSpikyHair addWhiteHat randomHairColor)('initialization' defaultColor initialize)('stepping and presenter' step)('testing' stepTime)!!HandleMorph reorganize!('dropping/grabbing' justDroppedInto:event:)('e-toy support' isCandidateForAutomaticViewing)('event handling' keyStroke:)('initialization' initialize)('initialize' forEachPointDo: forEachPointDo:lastPointDo:)('stepping and presenter' startStepping step)('testing' stepTime)!!HandMorphForReplay reorganize!('copying' veryDeepCopyWith:)('cursor' showTemporaryCursor:hotSpotOffset:)('drawing' needsToBeDrawn)('event handling' pauseEventRecorderIn: processEvents)('initialization' initialize recorder:)!!HandMorph reorganize!('accessing' colorForInsets lastEvent mouseOverHandler targetOffset userInitials userPicture userPicture:)('balloon help' balloonHelp balloonHelp: deleteBalloonTarget: removePendingBalloonFor: spawnBalloonFor: triggerBalloonFor:after:)('caching' releaseCachedState)('change reporting' invalidRect:from:)('classification' isHandMorph)('copying' veryDeepCopyWith:)('cursor' cursorBounds showTemporaryCursor: showTemporaryCursor:hotSpotOffset:)('double click support' resetClickState waitForClicksOrDrag:event: waitForClicksOrDrag:event:selectors:threshold:)('drawing' drawOn: fullDrawOn: hasChanged hasUserInformation needsToBeDrawn nonCachingFullDrawOn: restoreSavedPatchOn: savePatchFrom: shadowForm updateCacheCanvas:)('drop shadows' shadowOffset)('event handling' checkForMoreKeyboard cursorPoint flushEvents noticeMouseOver:event: pauseEventRecorderIn: processEvents)('events-processing' handleEvent:)('focus handling' keyboardFocus keyboardFocus: mouseFocus mouseFocus: newKeyboardFocus: newMouseFocus: newMouseFocus:event: releaseAllFoci releaseKeyboardFocus releaseKeyboardFocus: releaseMouseFocus releaseMouseFocus:)('genie' allowsGestureStart:target: disableGenie disableGenieFocus: enableGenie ensureGenieGestureProcessor genieGestureProcessor gestureStart:target: giveGenieChanceToEscape handleEventWithGenieEscaped: isGenieEnabled isGenieRecognizing prepareMouseFocusChangeFrom:to: resetGenie switchGenieEnabled switchGenieFocus: temporaryCursor)('geometry' position position: userInitials:andPicture:)('grabbing/dropping' attachMorph: dropMorph:event: dropMorphs dropMorphs: grabMorph:from: targetOffset:)('halo handling' halo: obtainHalo: releaseHalo: removeHaloFromClick:on: removePendingHaloFor: spawnMagicHaloFor: triggerHaloFor:after:)('halos and balloon help' halo)('initialization' initForEvents initialize interrupted resourceJustLoaded)('layout' fullBounds)('listeners' addEventListener: addKeyboardListener: addListener:to: addMouseListener: eventListeners eventListeners: keyboardListeners keyboardListeners: mouseListeners mouseListeners: removeEventListener: removeKeyboardListener: removeListener:from: removeMouseListener:)('meta-actions' copyToPasteBuffer: grabMorph:)('objects from disk' objectForDataStream:)('paste buffer' objectToPaste pasteBuffer pasteBuffer: pasteMorph)('pen' trailMorph)('scripting' adaptedToWorld:)('updating' changed)('private events' generateDropFilesEvent: generateKeyboardEvent: generateMouseEvent: mouseTrailFrom: moveToEvent: sendEvent:focus: sendEvent:focus:clear: sendFocusEvent:to:clear: sendKeyboardEvent: sendListenEvent:to: sendMouseEvent:)!!HaloMorph reorganize!('WiW support' morphicLayerNumber)('accessing' haloBox: innerTarget isMagicHalo isMagicHalo: magicAlpha magicAlpha: setTarget: target target:)('copying' veryDeepFixupWith: veryDeepInner:)('drawing' drawOn: drawSubmorphsOn:)('dropping/grabbing' startDrag:with:)('event handling' mouseMove: wantsKeyboardFocusFor:)('events' dragTarget: popUpFor:event: popUpMagicallyFor:hand: staysUpWhenMouseIsDownIn: transferHalo:)('events-processing' containsPoint:event: handleListenEvent: rejectsEvent:)('geometry' bounds: position:)('geometry testing' containsPoint:)('halos and balloon help' addSimpleHandlesTo:box:)('handles' addChooseGraphicHandle: addCollapseHandle: addDebugHandle: addDismissHandle: addDragHandle: addDupHandle: addFewerHandlesHandle: addFontEmphHandle: addFontSizeHandle: addFontStyleHandle: addGrabHandle: addGrowHandle: addHelpHandle: addMenuHandle: addPaintBgdHandle: addPoohHandle: addRecolorHandle: addRepaintHandle: addRotateHandle: addScaleHandle: addScriptHandle: addTileHandle: addViewHandle: addViewingHandle: openViewerForTarget:with: positionIn:horizontalPlacement:verticalPlacement: tearOffTileForTarget:with:)('initialization' acceptNameEdit defaultColor initialize)('meta-actions' blueButtonDown: handlerForBlueButtonDown:)('objects from disk' convertToCurrentVersion:refStream:)('stepping' fadeIn fadeInInitially fadeOut fadeOutFinally handleEntered handleLeft localHaloBoundsFor: step)('stepping and presenter')('submorphs-add/remove' delete)('testing' stepTime)('updating' changed)('private' addCircleHandles addDirectionHandles addFullHandles addGraphicalHandle:at:on:send:to: addGraphicalHandleFrom:at: addHandle:on:send:to: addHandleAt:color:icon:on:send:to: addHandleAt:color:on:send:to: addHandles addHandlesForWorldHalos addName addNameBeneath:string: addSimpleHandles addSimpleHandlesForWorldHalos addSimpleSketchMorphHandlesInBox: basicBox basicBoxForSimpleHalos directionArrowLength dismiss doDebug:with: doDirection:with: doDrag:with: doDup:with: doGrab:with: doGrow:with: doMenu:with: doRecolor:with: doRot:with: doScale:with: endInteraction handleAllowanceForIconicHalos handleSize maybeCollapse:with: maybeDismiss:with: maybeDoDup:with: mouseDownInCollapseHandle:with: mouseDownInDimissHandle:with: obtainHaloForEvent:andRemoveAllHandlesBut: positionDirectionShaft: prepareToTrackCenterOfRotation:with: removeAllHandlesBut: setCenterOfRotation:with: setDirection:with: setDismissColor:with: showDirectionHandles: showDirectionHandles:addHandles: showingDirectionHandles simpleFudgeOffset startGrow:with: startRot:with: startScale:with: strokeGrow:with: trackCenterOfRotation:with: trackDirectionArrow:with:)!!Flasher reorganize!('operations' onColor onColor:)('parts bin' initializeToStandAlone)('stepping and presenter' step)('testing' stepTime)!!FlashThumbnailMorph reorganize!('accessing' frameNumber frameNumber: image image: isSelected isSelected: player player:)('drawing' drawOn:)('initialization' initialize)!!FlashProgressMorph reorganize!('accessing' progressColor progressColor: value:)('drawing' drawOn:)('initialization' initialize)('menu' changeProgressColor: changeProgressValue:)('menus' addCustomMenuItems:hand:)('updating' update:)!!FaceMorph reorganize!('accessing' leftEye lips rightEye)('actions' closeEyelids grin happy hideTonge lookAt: lookAtFront lookAtHand lookAtMorph: neutral openEyelids say:)('drawing' drawNoseOn: drawOn:)('geometry' mustachePosition nosePosition)('initialization' defaultColor initialize)('stepping and presenter' step)('testing' stepTime)!!EyeMorph reorganize!('accessing' iris)('actions' closeEyelid dilate: lookAt: lookAtFront lookAtMorph: openEyelid openness:)('initialization' defaultColor initialize)!!AtomMorph reorganize!('as yet unclassified' bounceIn: infected infected: randomPositionIn:maxVelocity: velocity velocity:)('drawing' drawOn:)('initialization' defaultBorderWidth defaultColor initialize)!!AlertMorph reorganize!('accessing' color:)('as yet unclassified' socketOwner:)('initialization' defaultBorderWidth defaultColor initialize)('stepping and presenter' step)('testing' stepTime)('visual properties' canHaveFillStyles)!EllipseMorph removeSelector: #defaultBorderColor!EllipseMorph removeSelector: #initialize!EllipseMorph removeSelector: #initializeToStandAlone!!EllipseMorph reorganize!('accessing' couldHaveRoundedCorners doesBevels)('drawing' areasRemainingToFill: drawOn:)('geometry testing' containsPoint:)('initialization' defaultBorderWidth defaultColor)('testing' canDrawBorder:)('visual properties' canHaveFillStyles)!!DrawErrorMorph reorganize!('drawing' drawOn:)('printing' printOn:)!!DoCommandOnceMorph reorganize!('as yet unclassified' actionBlock: addText:)('initialization' defaultBorderColor defaultBorderWidth initialize openInWorld:)('stepping and presenter' step)('testing' stepTime wantsSteps)!!CachingMorph reorganize!('as yet unclassified' updateCacheCanvas:)('caching' releaseCachedState)('change reporting' invalidRect:from:)('drawing' drawOn: fullDrawOn: imageForm)('initialization' defaultColor initialize)!!CRStrokeMorph reorganize!('adding' addPoint:)('drawing' drawOn:)('initialization' initialize)('private' privateMoveBy:)!!CRLineMorph reorganize!('WiW support' morphicLayerNumber)('accessing' end privateSetStart:end: setStart:end:)('drawing' drawOn:)('initialize-release' initializeFrom:to:)('stepping and presenter' start)('private' getPoint:)!!BouncingAtomsMorph reorganize!('change reporting' invalidRect:from:)('drawing' areasRemainingToFill: drawOn:)('initialization' defaultColor initialize)('menu' setAtomCount startInfection)('menus' addCustomMenuItems:hand:)('other' addAtoms: collisionPairs showInfectionHistory: transmitInfection updateTemperature:)('stepping and presenter' step)('submorphs-add/remove' addMorphFront:)('testing' stepTime)!!BorderedSubpaneDividerMorph reorganize!('as yet unclassified' firstEnter: horizontal resizingEdge resizingEdge: vertical)('initialization' defaultBorderWidth defaultColor initialize)!!BorderedMorph reorganize!('accessing' borderColor borderColor: borderInset borderRaised borderStyle borderStyle: borderWidth borderWidth: doesBevels hasTranslucentColor useRoundedCorners useSquareCorners)('drawing' areasRemainingToFill:)('geometry' acquireBorderWidth:)('initialization' basicInitialize borderInitialize defaultBorderColor defaultBorderWidth initialize)('menu' addBorderStyleMenuItems:hand: changeBorderColor: changeBorderWidth:)('printing' fullPrintOn:)('private' setBorderWidth:borderColor: setColor:borderWidth:borderColor:)!!BackgroundMorph reorganize!('as yet unclassified' slideBy: startRunning stopRunning subBounds)('drawing' drawOn: fullDrawOn:)('initialization' initialize)('layout' fullBounds layoutChanged)('menus' addCustomMenuItems:hand:)('stepping and presenter' step)('testing' stepTime)!Morph removeSelector: #defaultNameStemForInstances!Morph removeSelector: #isMorphicModel!!Morph reorganize!('WiW support' addMorphInFrontOfLayer: addMorphInLayer: eToyRejectDropMorph:event: morphicLayerNumber morphicLayerNumberWithin: randomBoundsFor: shouldGetStepsFrom:)('accessing' actorState actorState: actorStateOrNil adoptPaneColor: balloonText balloonTextSelector balloonTextSelector: beFlap: beSticky beUnsticky borderColor borderColor: borderStyle borderStyle: borderStyleForSymbol: borderWidth borderWidth: borderWidthForRounding color color: colorForInsets couldHaveRoundedCorners eventHandler eventHandler: forwardDirection hasTranslucentColor highlight highlightColor highlightColor: highlightOnlySubmorph: insetColor isFlap isLocked isShared isSticky lock lock: methodCommentAsBalloonHelp modelOrNil player player: presenter raisedColor regularColor regularColor: rememberedColor rememberedColor: resistsRemoval resistsRemoval: scaleFactor setBorderStyle: sqkPage sticky: toggleLocked toggleResistsRemoval toggleStickiness unHighlight unlock unlockContents url userString wantsToBeCachedByHand)('accessing - extension' assureExtension extension hasExtension initializeExtension privateExtension: resetExtension)('accessing - properties' hasProperty: otherProperties removeProperty: setProperties: setProperty:toValue: valueOfProperty: valueOfProperty:ifAbsent: valueOfProperty:ifAbsentPut: valueOfProperty:ifPresentDo:)('button' doButtonAction fire firedMouseUpCode)('button properties' buttonProperties buttonProperties: ensuredButtonProperties hasButtonProperties)('caching' fullLoadCachedState fullReleaseCachedState loadCachedState releaseCachedState)('card in a stack' abstractAModel beAStackBackground becomeSharedBackgroundField containsCard: couldHoldSeparateDataForEachInstance currentDataInstance explainDesignations goToNextCardInStack goToPreviousCardInStack holdsSeparateDataForEachInstance insertAsStackBackground insertCard installAsCurrent: isStackBackground makeHoldSeparateDataForEachInstance newCard reassessBackgroundShape relaxGripOnVariableNames reshapeBackground setAsDefaultValueForNewCard showBackgroundObjects showDesignationsOfObjects showForegroundObjects stack stackDo: stopHoldingSeparateDataForEachInstance tabHitWithEvent: wrapWithAStack)('change reporting' addedOrRemovedSubmorph: colorChangedForSubmorph: invalidRect: invalidRect:from: ownerChanged userSelectedColor:)('classification' demandsBoolean isAlignmentMorph isBalloonHelp isFlapOrTab isFlapTab isFlashMorph isFlexMorph isHandMorph isModalShell isPlayfieldLike isRenderer isStandardViewer isSyntaxMorph isTextMorph isWorldMorph isWorldOrHandMorph)('converting' asDraggableMorph)('copying' copy deepCopy duplicate duplicateMorphCollection: fullCopy updateReferencesUsing: usableSiblingInstance veryDeepCopyWith: veryDeepFixupWith: veryDeepInner:)('creation' asMorph)('debug and other' addDebuggingItemsTo:hand: addMouseActionIndicatorsWidth:color: addMouseUpAction addMouseUpActionWith: addViewingItemsTo: allStringsAfter: altSpecialCursor0 altSpecialCursor1 altSpecialCursor2 altSpecialCursor3 altSpecialCursor3: buildDebugMenu: defineTempCommand deleteAnyMouseActionIndicators handMeTilesToFire inspectArgumentsPlayerInMorphic: inspectOwnerChain installModelIn: mouseUpCodeOrNil ownerChain programmedMouseDown:for: programmedMouseEnter:for: programmedMouseLeave:for: programmedMouseUp:for: programmedMouseUp:for:with: removeMouseUpAction resumeAfterDrawError resumeAfterStepError tempCommand viewMorphDirectly)('drawing' areasRemainingToFill: boundingBoxOfSubmorphs boundsWithinCorners changeClipSubmorphs clipLayoutCells clipLayoutCells: clipSubmorphs clipSubmorphs: clippingBounds doesOwnRotation drawDropHighlightOn: drawDropShadowOn: drawErrorOn: drawMouseDownHighlightOn: drawOn: drawPostscriptOn: drawRolloverBorderOn: drawSubmorphsOn: expandFullBoundsForDropShadow: expandFullBoundsForRolloverBorder: fullDrawOn: hasClipSubmorphsString hide highlightForMouseDown highlightForMouseDown: highlightedForMouseDown imageForm imageForm:forRectangle: imageFormDepth: imageFormForRectangle: imageFormWithout:andStopThere: refreshWorld shadowForm show visible visible:)('drop shadows' addDropShadow addDropShadowMenuItems:hand: changeShadowColor hasDropShadow hasDropShadow: hasDropShadowString hasRolloverBorder hasRolloverBorder: removeDropShadow setShadowOffset: shadowColor shadowColor: shadowOffset shadowOffset: shadowPoint: toggleDropShadow)('dropping/grabbing' aboutToBeGrabbedBy: disableDragNDrop dragEnabled dragEnabled: dragNDropEnabled dragSelectionColor dropEnabled dropEnabled: dropHighlightColor dropSuccessColor enableDrag: enableDragNDrop enableDragNDrop: enableDrop: formerOwner formerOwner: formerPosition formerPosition: grabTransform highlightForDrop highlightForDrop: highlightedForDrop justDroppedInto:event: justGrabbedFrom: nameForUndoWording rejectDropMorphEvent: repelsMorph:event: resetHighlightForDrop separateDragAndDrop slideBackToFormerSituation: slideToTrash: startDrag:with: toggleDragNDrop transportedMorph undoGrabCommand vanishAfterSlidingTo:event: wantsDroppedMorph:event: wantsToBeDroppedInto: wantsToBeOpenedInWorld willingToBeDiscarded)('e-toy support' adaptToWorld: adoptVocabulary: allMorphsAndBookPagesInto: appearsToBeSameCostumeAs: asNumber: asWearableCostume asWearableCostumeOfExtent: automaticViewing changeAllBorderColorsFrom:to: configureForKids containingWindow copyCostumeStateFrom: currentPlayerDo: cursor cursor: decimalPlacesForGetter: defaultValueOrNil defaultVariableName definePath deletePath embedInWindow embeddedInMorphicWindowLabeled: enclosingEditor enforceTileColorPolicy fenceEnabled followPath getNumericValue gridFormOrigin:grid:background:line: isAViewer isCandidateForAutomaticViewing isTileEditor listViewLineForFieldList: makeGraphPaper makeGraphPaperGrid:background:line: mustBeBackmost noteDecimalPlaces:forGetter: noteNegotiatedName:for: objectViewed referencePlayfield rotationStyle rotationStyle: setAsActionInButtonProperties: setNaturalLanguageTo: setNumericValue: setStandardTexture slotSpecifications succeededInRevealing: textureParameters topEditor unlockOneSubpart updateCachedThumbnail wantsRecolorHandle wrappedInWindow: wrappedInWindowWithTitle:)('event handling' click click: cursorPoint doubleClick: doubleClickTimeout: dropFiles: firstClickTimedOut: handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: handlesMouseStillDown: hasFocus keyDown: keyStroke: keyUp: keyboardFocusChange: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseStillDown: mouseStillDownThreshold mouseUp: on:send:to: on:send:to:withValue: removeLink: restoreSuspendedEventHandler startDrag: suspendEventHandler transformFrom: transformFromOutermostWorld transformFromWorld wantsDropFiles: wantsEveryMouseMove wantsKeyboardFocusFor: wouldAcceptKeyboardFocus wouldAcceptKeyboardFocusUponTab)('events-accessing' actionMap updateableActionMap)('events-alarms' addAlarm:after: addAlarm:at: addAlarm:with:after: addAlarm:with:at: addAlarm:with:with:after: addAlarm:with:with:at: addAlarm:withArguments:after: addAlarm:withArguments:at: alarmScheduler removeAlarm: removeAlarm:at:)('events-processing' containsPoint:event: defaultEventDispatcher handleDropFiles: handleDropMorph: handleEvent: handleFocusEvent: handleKeyDown: handleKeyUp: handleKeystroke: handleListenEvent: handleMouseDown: handleMouseEnter: handleMouseLeave: handleMouseMove: handleMouseOver: handleMouseStillDown: handleMouseUp: handleUnknownEvent: handlerForMouseDown: mouseDownPriority processEvent: processEvent:using: rejectDropEvent: rejectsEvent: transformedFrom:)('events-removing' releaseActionMap)('fileIn/out' attachToResource prepareToBeSaved reserveUrl: saveAsResource saveDocPane saveOnURL saveOnURL: saveOnURLbasic updateAllFromResources updateFromResource)('filter streaming' drawOnCanvas: fullDrawPostscriptOn:)('genie-dispatching' blueButtonClickHand:shift: gesture: gestureCode: gestureCommand: gestureKeystrokes: gestureMouseEvent: gestureStrokes: handleGesture: isGestureUndoable: isSpecialCharacterUndoable: modifyGesture:by: undoGesture:)('genie-menu' addGenieMenuItems:hand: changeGestureDictionary hasNotExportedGestureDictionary hasReferencedGestureDictionary inspectGestureDictionary makeOwnCopyOfGestureDictionary makeOwnSubGestureDictionary)('genie-processing' allowsGestureEscape allowsGesturePreprocessing allowsGestureStart: defaultGestureDictionaryOrName disableGestures gestureDictionary gestureDictionaryOrName gestureDictionaryOrName: gestureHandler gestureStart: handlesGestureStart: onGestureSend:to:)('geometry' align:with: bottom bottom: bottomCenter bottomLeft bottomLeft: bottomRight bottomRight: bounds bounds: bounds:from: bounds:in: boundsIn: boundsInWorld center center: extent extent: fullBoundsInWorld globalPointToLocal: gridPoint: griddedPoint: height height: innerBounds left left: leftCenter localPointToGlobal: minimumExtent minimumExtent: nextOwnerPage outerBounds point:from: point:in: pointFromWorld: pointInWorld: position position: positionInWorld positionSubmorphs previousOwnerPage right right: rightCenter screenLocation screenRectangle setConstrainedPosition:hangOut: shiftSubmorphsBy: shiftSubmorphsOtherThan:by: top top: topCenter topLeft topLeft: topRight topRight: transformedBy: width width: worldBounds worldBoundsForHalo)('geometry eToy' addTransparentSpacerOfSize: beTransparent cartesianBoundsTopLeft cartesianXY: color:sees: colorUnder degreesOfFlex forwardDirection: getIndexInOwner goHome heading heading: move:toPosition: referencePosition referencePosition: referencePositionInWorld referencePositionInWorld: rotationCenter rotationCenter: setDirectionFrom: setIndexInOwner: touchesColor: transparentSpacerOfSize: wrap x x: x:y: y y:)('geometry testing' containsPoint: fullContainsPoint: obtrudesBeyondContainer)('halos and balloon help' addHalo addHalo: addHalo:from: addHandlesTo:box: addMagicHaloFor: addOptionalHandlesTo:box: addSimpleHandlesTo:box: addWorldHandlesTo:box: balloonColor balloonColor: balloonFont balloonFont: balloonHelpAligner balloonHelpDelayTime balloonHelpTextForHandle: boundsForBalloon comeToFrontAndAddHalo defaultBalloonColor defaultBalloonFont defersHaloOnClickTo: deleteBalloon editBalloonHelpContent: editBalloonHelpText halo haloClass haloDelayTime hasHalo hasHalo: isLikelyRecipientForMouseOverHalos mouseDownOnHelpHandle: noHelpString okayToAddDismissHandle okayToAddGrabHandle okayToBrownDragEasily okayToExtractEasily okayToResizeEasily okayToRotateEasily removeHalo setBalloonText: setBalloonText:maxLineLength: setCenteredBalloonText: showBalloon: showBalloon:hand: transferHalo:from: wantsBalloon wantsDirectionHandles wantsDirectionHandles: wantsHalo wantsHaloFor: wantsHaloFromClick wantsHaloHandleWithSelector:inHalo: wantsScriptorHaloHandle)('initialization' basicInitialize defaultBounds defaultColor inATwoWayScrollPane initialize intoWorld: openCenteredInWorld openInHand openInMVC openInWindow openInWindowLabeled: openInWindowLabeled:inWorld: openInWorld openInWorld: outOfWorld: resourceJustLoaded standardPalette)('layout' acceptDroppingMorph:event: adjustLayoutBounds doLayoutIn: fullBounds layoutBounds layoutBounds: layoutChanged layoutInBounds: layoutProportionallyIn: minExtent minHeight minHeight: minWidth minWidth: privateFullBounds submorphBounds)('layout-menu' addCellLayoutMenuItems:hand: addLayoutMenuItems:hand: addTableLayoutMenuItems:hand: changeCellInset: changeClipLayoutCells changeDisableTableLayout changeLayoutInset: changeListDirection: changeMaxCellSize: changeMinCellSize: changeNoLayout changeProportionalLayout changeReverseCells changeRubberBandCells changeTableLayout hasClipLayoutCellsString hasDisableTableLayoutString hasNoLayoutString hasProportionalLayoutString hasReverseCellsString hasRubberBandCellsString hasTableLayoutString layoutMenuPropertyString:from:)('layout-properties' assureLayoutProperties assureTableProperties cellInset cellInset: cellPositioning cellPositioning: cellPositioningString: cellSpacing cellSpacing: cellSpacingString: disableTableLayout disableTableLayout: hResizing hResizing: hResizingString: layoutFrame layoutFrame: layoutInset layoutInset: layoutPolicy layoutPolicy: layoutProperties layoutProperties: listCentering listCentering: listCenteringString: listDirection listDirection: listDirectionString: listSpacing listSpacing: listSpacingString: maxCellSize maxCellSize: minCellSize minCellSize: reverseTableCells reverseTableCells: rubberBandCells rubberBandCells: spaceFillWeight spaceFillWeight: vResizeToFit: vResizing vResizing: vResizingString: wrapCentering wrapCentering: wrapCenteringString: wrapDirection wrapDirection: wrapDirectionString:)('macpal' beep: currentVocabulary flash scriptPerformer)('menu' addBorderStyleMenuItems:hand:)('menus' absorbStateFromRenderer: adMiscExtrasTo: addAddHandMenuItemsForHalo:hand: addCopyItemsTo: addCustomHaloMenuItems:hand: addCustomMenuItems:hand: addExportMenuItems:hand: addFillStyleMenuItems:hand: addHaloActionsTo: addPaintingItemsTo:hand: addPlayerItemsTo: addStackItemsTo: addStandardHaloMenuItemsTo:hand: addTitleForHaloMenu: addToggleItemsToHaloMenu: adhereToEdge adhereToEdge: adjustedCenter adjustedCenter: allMenuWordings changeColor changeDirectionHandles changeDragAndDrop chooseNewGraphic chooseNewGraphicCoexisting: chooseNewGraphicFromHalo collapse dismissButton doMenuItem: exportAsBMP exportAsGIF exportAsJPEG hasDirectionHandlesString hasDragAndDropEnabledString helpButton inspectInMorphic inspectInMorphic: lockUnlockMorph lockedString makeNascentScript maybeAddCollapseItemTo: menuItemAfter: menuItemBefore: presentHelp printPSToFile printPSToFileNamed: putOnBackground putOnForeground resetForwardDirection resistsRemovalString setArrowheads setRotationCenter setRotationCenterFrom: setToAdhereToEdge: snapToEdgeIfAppropriate stickinessString transferStateToRenderer: uncollapseSketch)('messenger' affiliatedSelector)('meta-actions' addEmbeddingMenuItemsTo:hand: applyStatusToAllSiblings: beThisWorldsModel blueButtonDown: blueButtonUp: bringAllSiblingsToMe: buildHandleMenu: buildMetaMenu: changeColorTarget:selector:originalColor:hand: copyToPasteBuffer: dismissMorph: duplicateMorph: embedInto: grabMorph: handlerForBlueButtonDown: handlerForMetaMenu: inspectAt:event: invokeMetaMenu: invokeMetaMenuAt:event: makeMultipleSiblings: makeNewPlayerInstance: makeSiblings: makeSiblingsLookLikeMe: maybeDuplicateMorph maybeDuplicateMorph: openAButtonPropertySheet openAPropertySheet openATextPropertySheet potentialEmbeddingTargets resizeFromMenu resizeMorph: saveAsPrototype showActions showHiders subclassMorph)('miscellaneous' setExtentFromHalo:)('naming' choosePartName downshiftedNameOfObjectRepresented innocuousName name: nameForFindWindowFeature nameInModel nameOfObjectRepresented setNamePropertyTo: setNameTo: specialNameInModel tryToRenameTo: updateAllScriptingElements)('object fileIn' convertAugust1998:using: convertNovember2000DropShadow:using:)('objects from disk' convertToCurrentVersion:refStream: objectForDataStream: saveOnFile storeDataOn:)('other' removeAllButFirstSubmorph)('other events' menuButtonMouseEnter: menuButtonMouseLeave:)('parts bin' inPartsBin initializeToStandAlone isPartsBin isPartsDonor isPartsDonor: markAsPartsDonor partRepresented residesInPartsBin)('pen' choosePenColor: choosePenSize getPenColor getPenDown getPenSize liftPen lowerPen penColor: penUpWhile: trailMorph)('piano rolls' addMorphsTo:pianoRoll:eventTime:betweenTime:and: encounteredAtTime:inScorePlayer:atIndex:inEventTrack:secsPerTick: justDroppedIntoPianoRoll:event: pauseFrom: resetFrom: resumeFrom: triggerActionFromPianoRoll)('player' assureExternalName assuredCardPlayer assuredPlayer currentDataValue newPlayerInstance okayToDuplicate shouldRememberCostumes showPlayerMenu variableDocks)('player commands' jumpTo: makeFenceSound set:)('player viewer' openViewerForArgument updateLiteralLabel)('printing' asEPS asPostscript asPostscriptPrintJob clipPostscript colorString: constructorString fullPrintOn: initString morphReport morphReportFor: morphReportFor:on:indent: pagesHandledAutomatically printConstructorOn:indent: printConstructorOn:indent:nodeDict: printOn: printSpecs printSpecs: printStructureOn:indent: reportableSize structureString textToPaste)('rotate scale and flex' addFlexShell addFlexShellIfNecessary keepsTransform newTransformationMorph rotationDegrees)('rounding' cornerStyle: roundedCorners roundedCornersString toggleCornerRounding wantsRoundedCorners)('scripting' asEmptyPermanentScriptor bringTileScriptingElementsUpToDate bringUpToDate categoriesForViewer defaultFloatPrecisionFor: instantiatedUserScriptsDo: isTileLike isTileScriptingElement jettisonScripts makeAllTilesColored makeAllTilesGreen restoreTypeColor scriptEditorFor: selectorsForViewer tearOffTile triggerScript: useUniformTileColor viewAfreshIn:showingScript:at:)('stepping and presenter' arrangeToStartStepping arrangeToStartSteppingIn: isStepping isSteppingSelector: start startStepping startStepping:at:arguments:stepTime: startSteppingIn: startSteppingSelector: step stepAt: stop stopStepping stopSteppingSelector: stopSteppingSelfAndSubmorphs)('structure' activeHand allOwners allOwnersDo: firstOwnerSuchThat: hasOwner: isInWorld morphPreceding: nearestOwnerThat: orOwnerSuchThat: outermostMorphThat: outermostWorldMorph owner ownerThatIsA: ownerThatIsA:orA: pasteUpMorph pasteUpMorphHandlingTabAmongFields primaryHand renderedMorph root rootAt: topPasteUp topRendererOrSelf withAllOwners withAllOwnersDo: world)('submorphs-accessing' allKnownNames allMorphs allMorphsDo: allNonSubmorphMorphs allSubmorphNamesDo: findA: findDeepSubmorphThat:ifAbsent: findDeeplyA: findSubmorphBinary: firstSubmorph hasSubmorphWithProperty: hasSubmorphs indexOfMorphAbove: lastSubmorph morphsAt: morphsAt:behind:unlocked: morphsAt:unlocked: morphsAt:unlocked:do: morphsInFrontOf:overlapping:do: morphsInFrontOverlapping: morphsInFrontOverlapping:do: rootMorphsAt: rootMorphsAtGlobal: shuffleSubmorphs submorphAfter submorphBefore submorphCount submorphNamed: submorphNamed:ifNone: submorphOfClass: submorphThat:ifNone: submorphWithProperty: submorphs submorphsBehind:do: submorphsDo: submorphsInFrontOf:do: submorphsReverseDo: submorphsSatisfying:)('submorphs-add/remove' abandon actWhen actWhen: addAllMorphs: addAllMorphs:after: addMorph: addMorph:after: addMorph:asElementNumber: addMorph:behind: addMorph:fullFrame: addMorph:inFrontOf: addMorphBack: addMorphCentered: addMorphFront: addMorphFront:fromWorldPosition: addMorphFrontFromWorldPosition: addMorphNearBack: comeToFront copyWithoutSubmorph: delete deleteSubmorphsWithProperty: dismissViaHalo goBehind privateDelete removeAllMorphs removeAllMorphsIn: replaceSubmorph:by: submorphIndexOf:)('system primitives' creationStamp)('testing' canDrawAtHigherResolution canDrawBorder: completeModificationHash isFlexed isMorph knownName modificationHash renameTo: shouldDropOnMouseUp stepTime wantsSteps)('text-anchor' addTextAnchorMenuItems:hand: changeDocumentAnchor changeInlineAnchor changeParagraphAnchor hasDocumentAnchorString hasInlineAnchorString hasParagraphAnchorString relativeTextAnchorPosition relativeTextAnchorPosition: textAnchorType textAnchorType:)('texture support' asTexture installAsWonderlandTextureOn: isValidWonderlandTexture isValidWonderlandTexture: mapPrimitiveVertex: wonderlandTexture wonderlandTexture:)('thumbnail' demandsThumbnailing morphRepresented permitsThumbnailing readoutForField: representativeNoTallerThan:norWiderThan:thumbnailHeight: updateThumbnailUrl updateThumbnailUrlInBook:)('undo' commandHistory undoMove:redo:owner:bounds:predecessor:)('updating' changed)('user interface' beep defaultLabelForInspector initialExtent)('viewer' externalName)('visual properties' canHaveFillStyles cornerStyle fillStyle fillStyle: fillWithRamp:oriented: useBitmapFill useDefaultFill useGradientFill useSolidFill)('private' moveWithPenDownBy: moveWithPenDownByRAA: privateAddMorph:atIndex: privateBounds: privateColor: privateDeleteWithAbsolutelyNoSideEffects privateFullBounds: privateFullMoveBy: privateMoveBy: privateOwner: privateRemoveMorph: privateRemoveMorphWithAbsolutelyNoSideEffects: privateSubmorphs privateSubmorphs:)!!EToyHierarchicalTextGizmo class reorganize!('as yet unclassified' example)!!EToyHierarchicalTextGizmo reorganize!('as yet unclassified' addChild addNewChildAfter: addSibling deleteSelectedItem expandAllBelow genericMenu: getList inAWindow notInAWindow topNode:)!!MethodWithInterface class reorganize!('no messages')!!MethodWithInterface reorganize!('access' playerClass)('initialization' convertFromUserScript: initialize isTextuallyCoded playerClass:selector:)('rename' okayToRename renameScript:fromPlayer:)('script editor' allScriptEditors currentScriptEditor: instantiatedScriptEditorForPlayer: recompileScriptFromTilesUnlessTextuallyCoded)('updating' bringUpToDate revertToLastSavedTileVersionFor: saveScriptVersion:)!!MessagePartNode class reorganize!('no messages')!!MessagePartNode reorganize!('no messages')!!LoopbackStringSocket class reorganize!('as yet unclassified' clearStats stats)('instance creation' newPair)!!LoopbackStringSocket reorganize!('I/O' flush isConnected nextOrNil nextPut: processIO)('as yet unclassified' destroy)('initialization' associate:)('private' arraysFromAssociate:)!!LayoutProperties class reorganize!('instance creation' new)!!LayoutProperties reorganize!('accessing' disableTableLayout disableTableLayout: hResizing hResizing: vResizing vResizing:)('converting' asTableLayoutProperties)('initialize' initialize initializeFrom:)('table defaults' cellInset cellPositioning cellSpacing layoutInset listCentering listDirection listSpacing maxCellSize minCellSize reverseTableCells rubberBandCells wrapCentering wrapDirection)('testing' includesTableProperties)!!LayoutPolicy class reorganize!('no messages')!!LayoutPolicy reorganize!('layout' flushLayoutCache layout:in: minExtentOf:in:)('testing' isProportionalLayout isTableLayout)('utilities' indexForInserting:at:in:)!!LayoutFrame class reorganize!('accessing' classVersion)('as yet unclassified' fractions: fractions:offsets: offsets:)!!LayoutFrame reorganize!('accessing' bottomFraction bottomFraction: bottomFraction:offset: bottomOffset bottomOffset: leftFraction leftFraction: leftFraction:offset: leftOffset leftOffset: rightFraction rightFraction: rightFraction:offset: rightOffset rightOffset: topFraction topFraction: topFraction:offset: topOffset topOffset:)('layout' layout:in: minExtentFrom:)('objects from disk' convertToCurrentVersion:refStream: negateBottomRightOffsets)!!LayoutCell class reorganize!('no messages')!!LayoutCell reorganize!('accessing' addExtraSpace: cellSize cellSize: extraSpace extraSpace: hSpaceFill hSpaceFill: nextCell nextCell: size target target: vSpaceFill vSpaceFill:)('collection' do: inject:into:)!!KeyboardBuffer class reorganize!('no messages')!!KeyboardBuffer reorganize!('as yet unclassified' commandKeyPressed controlKeyPressed flushKeyboard keyboard keyboardPeek keyboardPressed leftShiftDown startingEvent:)!!HaloSpec class reorganize!('no messages')!!HaloSpec reorganize!('as yet unclassified' addHandleSelector color horizontalPlacement horizontalPlacement:verticalPlacement:color:iconSymbol:addHandleSelector: iconSymbol verticalPlacement)('printing' printOn:)!!GrafPort class reorganize!('no messages')!!GrafPort reorganize!('accessing' alphaBits: contentsOfArea:into: displayScannerFor:foreground:background:ignoreColorChanges: fillPattern:)('copying' clippedBy: copyBits)('drawing support' fillOval: fillRect:offset: frameOval:borderWidth: frameRect:borderWidth: frameRectBottom:height: frameRectRight:width: image:at:sourceRect:rule: image:at:sourceRect:rule:alpha: stencil:at:sourceRect:)('private' installStrikeFont:foregroundColor:backgroundColor:)!!GeePrinterPage class reorganize!('no messages')!!GeePrinterPage reorganize!('as yet unclassified' pageAsForm pageNumber:bounds: pageThumbnailOfSize: totalPages:)('filter streaming' fullDrawPostscriptOn:)!!GeePrinter class reorganize!('no messages')!!GeePrinter reorganize!('as yet unclassified' allPages bounds computeBounds doPages doPrintPreview doPrintToPrinter drawOn: fullBounds fullDrawOn: geeMail: hOverW pageRectangles pagesHandledAutomatically pasteUp: printSpecs printSpecs: wantsRoundedCorners)('filter streaming' fullDrawPostscriptOn:)!!FontCache class reorganize!('instance creation' new:)!!FontCache reorganize!('initialization' initialize:)('lookups' fontAt: includesFont: indexForNewFont: indexOf:)!!Flaps class reorganize!('construction support' addMorph:asElementNumber:inGlobalFlapSatisfying: addMorph:asElementNumber:inGlobalFlapWithID: addToSuppliesFlap:asElementNumber: deleteMorphsSatisfying:fromGlobalFlapSatisfying:)('flap mechanics' clobberFlapTabList freshFlapsStart reinstateDefaultFlaps removeFlapTab:keepInList:)('menu commands' disableGlobalFlapWithID: disableGlobalFlaps disableGlobalFlaps: enableDisableGlobalFlapWithID: enableGlobalFlapWithID: explainFlaps)('menu support' addIndividualGlobalFlapItemsTo: enableEToyFlaps enableGlobalFlaps globalFlapWithIDEnabledString: setUpSuppliesFlapOnly showSharedFlaps suppressFlapsString)('miscellaneous' automaticFlapLayoutChanged doAutomaticLayoutOfFlapsIfAppropriate enableClassicNavigatorChanged fileOutChanges makeNavigatorFlapResembleGoldenBar orientationForEdge: paintFlapButton removeFromGlobalFlapTabList:)('new flap' addLocalFlap defaultColorForFlapBackgrounds newFlapTitled:onEdge: newFlapTitled:onEdge:inPasteUp:)('predefined flaps' addAndEnableEToyFlaps addNewDefaultSharedFlaps addStandardFlaps initializeStandardFlaps newLoneSuppliesFlap newNavigatorFlap newObjectsFlap newPaintingFlap newSqueakFlap newStackToolsFlap newSuppliesFlap newSuppliesFlapFromQuads:positioning: newToolsFlap newWidgetsFlap quadsDefiningPlugInSuppliesFlap quadsDefiningStackToolsFlap quadsDefiningSuppliesFlap quadsDefiningToolsFlap quadsDefiningWidgetsFlap quadsDeiningScriptingFlap)('replacement' replaceGlobalFlapwithID: replacePartSatisfying:inGlobalFlapSatisfying:with: replacePartSatisfying:inGlobalFlapWithID:with: replaceToolsFlap)('shared flaps' addGlobalFlap: enableOnlyGlobalFlapsWithIDs: globalFlapTab: globalFlapTabOrDummy: globalFlapTabWithID: globalFlapTabs globalFlapTabsIfAny globalFlapTabsWithID: positionNavigatorAndOtherFlapsAccordingToPreference positionVisibleFlapsRightToLeftOnEdge:butPlaceAtLeftFlapsWithIDs: removeDuplicateFlapTabs sharedFlapsAllowed sharedFlapsAlongBottom)!!Flaps reorganize!('no messages')!!EventHandler class reorganize!('fixups' fixAlansOldEventHandlers)!!EventHandler reorganize!('access' allRecipients firstMouseSelector gestureRecipient gestureSelector messageList methodRefList mouseDownSelector mouseStillDownRecipient mouseStillDownSelector mouseUpSelector)('copying' veryDeepFixupWith: veryDeepInner:)('events' click:fromMorph: doubleClick:fromMorph: doubleClickTimeout:fromMorph: gesture:fromMorph: keyStroke:fromMorph: mouseDown:fromMorph: mouseEnter:fromMorph: mouseEnterDragging:fromMorph: mouseLeave:fromMorph: mouseLeaveDragging:fromMorph: mouseMove:fromMorph: mouseStillDown:fromMorph: mouseUp:fromMorph: send:to:withEvent:fromMorph: startDrag:fromMorph:)('fixups' fixAlansOldEventHandlers fixReversedValueMessages replaceSendsIn:with:)('initialization' adaptToWorld: forgetDispatchesTo: on:send:to: on:send:to:withValue:)('objects from disk' convertToCurrentVersion:refStream:)('printing' printOn:)('testing' handlesClickOrDrag: handlesGesture: handlesGestureStart: handlesKeyboard: handlesMouseDown: handlesMouseMove: handlesMouseOver: handlesMouseOverDragging: handlesMouseStillDown: hasGestureRecipient)!!EllipseMidpointTracer class reorganize!('no messages')!!EllipseMidpointTracer reorganize!('computing' stepInY)('initialize' on:)!!EToyTextNodeWrapper class reorganize!('as yet unclassified' with:model:parent:)!!EToyTextNodeWrapper reorganize!('as yet unclassified' addNewChildAfter: addSibling contents delete hasContents parentWrapper:)('converting' asString)!!EToyIncomingMessage class reorganize!('as yet unclassified' forType:send:to: initializeMessageHandlers messageHandlers newObjectFromStream:)('handlers' handleNewChatFrom:sentBy:ipAddress: handleNewFridgeMorphFrom:sentBy:ipAddress: handleNewMorphFrom:sentBy:ipAddress: handleNewMultiChatFrom:sentBy:ipAddress: handleNewSeeDesktopFrom:sentBy:ipAddress: handleNewStatusReplyFrom:sentBy:ipAddress: handleNewStatusRequestFrom:sentBy:ipAddress:)('message types' allTypes registerType: typeAudioChat typeAudioChatContinuous typeFridge typeKeyboardChat typeMorph typeMultiChat typeSeeDesktop typeStatusReply typeStatusRequest unregisterType:)!!EToyIncomingMessage reorganize!('as yet unclassified' incomingMessgage:fromIPAddress:)!!DescriptionForPartsBin class reorganize!('instance creation' formalName:categoryList:documentation:globalReceiverSymbol:nativitySelector: fromQuad:categoryList:)!!DescriptionForPartsBin reorganize!('access' categories documentation formalName globalReceiverSymbol nativitySelector)('initialization' formalName:categoryList:documentation:globalReceiverSymbol:nativitySelector: sampleImageForm sampleImageForm: sampleImageFormOrNil)('printing' printOn:)!!DamageRecorder class reorganize!('instance creation' new)!!DamageRecorder reorganize!('initialization' reset)('recording' doFullRepaint invalidRectsFullBounds: recordInvalidRect:)('testing' updateIsNeeded)!!ComplexProgressIndicator class reorganize!('as yet unclassified' historyReport)!!ComplexProgressIndicator reorganize!('as yet unclassified' addProgressDecoration: backgroundWorldDisplay forkProgressWatcher historyCategory: loadingHistoryAt:add: loadingHistoryDataForKey: targetMorph: withProgressDo:)!!CommandHistory class reorganize!('class initialization' initialize)('instance creation' new)('system startup' forgetAllGrabCommandsFrom: resetAllHistory shutDown:)!!CommandHistory reorganize!('called by programmer' cantUndo promoteToCurrent: purgeAllCommandsSuchThat:)('called from the ui' commandToUndo redoNextCommand undoLastCommand undoOrRedoCommand undoTo)('command history' historyIndexOfLastCommand lastCommand nextCommand resetCommandHistory)('initialize' initialize)('menu' nextCommandToUndo redoEnabled redoMenuWording undoEnabled undoMenuWording undoOrRedoMenuWording)('undo' rememberCommand:)!!Command class reorganize!('class initialization' zapObsolete)('dog simple ui' redoEnabled redoNextCommand undoEnabled undoLastCommand undoRedoButtons)!!Command reorganize!('command execution' doCommand redoCommand undoCommand)('copying' veryDeepFixupWith: veryDeepInner:)('initialization' cmdWording: phase: redoTarget:selector:argument: redoTarget:selector:arguments: undoTarget:selector:argument: undoTarget:selector:arguments:)('parameters' parameterAt: parameterAt:ifAbsent: parameterAt:put:)('printing' printOn:)('private' assuredParameterDictionary cmdWording phase undoTarget)!!CanvasEncoder class reorganize!('as yet unclassified' at:count: beginStats clearTestVars explainTestVars inspectTestVars killStats nameForCode: showStats timeSomeThings)('codes' aaaReadme codeBalloonOval codeBalloonRect codeClip codeExtentDepth codeFont codeForce codeImage codeInfiniteFill codeLine codeOval codePoly codeRect codeReleaseCache codeShadowColor codeStencil codeText codeTransform)('encoding' encodeColor: encodeFillStyle: encodeFont: encodeImage: encodeInteger: encodePoint: encodeRectangle: encodeTransform:)('instance creation' new on:)!!CanvasEncoder reorganize!('clipping and transforming' setClipRect: setTransform: updateTransform:andClipRect:)('connection' backlog connection: disconnect isConnected purgeOutputQueue)('drawing' balloonFillOval:fillStyle:borderWidth:borderColor: balloonFillRectangle:fillStyle: cachingEnabled: drawPolygon:color:borderWidth:borderColor: drawString:from:to:in:font:color: extent:depth: fillOval:color:borderWidth:borderColor: forceToScreen: frameAndFillRectangle:fillColor:borderWidth:borderColor: image:at:sourceRect:rule: image:at:sourceRect:rule:cacheID:newToCache: infiniteFillRectangle:fillStyle: line:to:width:color: purgeCache purgeCacheInner shadowColor: stencil:at:sourceRect:color: testCache: testRectangleFillTiming)('fonts' establishFont: sendFont:atIndex:)('initialization' initialize)('network' destroy flush processIO)('objects from disk' convertToCurrentVersion:refStream:)('private' sendCommand:)!!CanvasDecoder class reorganize!('decoding' decodeColor: decodeFillStyle: decodeFont: decodeImage: decodeInteger: decodePoint: decodePoints: decodeRectangle: decodeTransform:)('instance creation' connection:)!!CanvasDecoder reorganize!('attributes' drawingForm)('decoding' addFontToCache: drawBalloonOval: drawBalloonRect: drawCommand: drawImage: drawInfiniteFill: drawLine: drawOval: drawPoly: drawRect: drawStencil: drawText: extentDepth: forceToScreen:withBlock: processCommand:onForceDo: releaseImage: setClip: setTransform: shadowColor: showSpaceUsed)('initialization' initialize)('network' connection: processIO processIOOnForce:)('shutting down' delete)!!CanvasCharacterScanner class reorganize!('no messages')!!CanvasCharacterScanner reorganize!('accessing' canvas:)('scanning' displayLine:offset:leftInRun:)('stop conditions' cr crossedX endOfRun paddedSpace setStopConditions tab)('private' doesDisplaying setFont textColor:)!!ButtonProperties class reorganize!('as yet unclassified' ellipticalButtonWithText: test1 test2 test3)('instance creation' new)('printing' defaultNameStemForInstances)!!ButtonProperties reorganize!('accessing' actWhen actWhen: actionSelector actionSelector: addTextToButton: adjustPositionsAfterSizeChange arguments arguments: bringUpToDate currentLook currentTextInButton currentTextMorphsInButton establishEtoyLabelWording figureOutScriptSelector isTileScriptingElement lockAnyText mouseDownHaloColor mouseDownHaloColor: mouseDownHaloWidth mouseDownHaloWidth: mouseDownLook: mouseEnterLook: mouseOverHaloColor mouseOverHaloColor: mouseOverHaloWidth mouseOverHaloWidth: privateSetLook:to: setEventHandlers: setLook:to: stateCostumes target target: unlockAnyText visibleMorph: wantsRolloverIndicator wantsRolloverIndicator:)('copying' updateReferencesUsing: veryDeepFixupWith: veryDeepInner:)('events' addMouseOverHalo delayBetweenFirings delayBetweenFirings: displayCostume: doButtonAction doButtonAction: editButtonsScript: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseStillDown: mouseUp: replaceVisibleMorph:)('initialization' adaptToWorld: initialize)('menu' setActWhen setActionSelector setArguments setLabel setPageSound: setPageVisual: setTarget:)('visual properties' updateVisualState:)!!BorderStyle class reorganize!('instance creation' borderStyleChoices borderStyleForSymbol: color:width: complexAltFramed complexAltInset complexAltRaised complexFramed complexInset complexRaised default inset raised simple width: width:color:)!!BorderStyle reorganize!('accessing' baseColor baseColor: color color: colorsAtCorners dotOfSize:forDirection: style width width: widthForRounding)('color tracking' trackColorFrom:)('comparing' = hash)('drawing' drawLineFrom:to:on: frameOval:on: framePolygon:on: framePolyline:on: frameRectangle:on:)('initialize' releaseCachedState)('testing' isBorderStyle isComplex)!!ActorState class reorganize!('no messages')!!ActorState reorganize!('filter streaming' printOnStream:)('initialization' initializeFor:)('other' addPlayerMenuItemsTo:hand: costume)('pen' choosePenColor: choosePenSize defaultPenColor defaultPenSize getPenArrowheads getPenColor getPenDown getPenSize liftPen lowerPen penColor: setPenArrowheads: setPenColor: setPenDown: setPenSize:)('position' fractionalPosition fractionalPosition:)('printing' printOn:)('script instantiations' instantiatedUserScriptsDictionary)!