'From Squeak 2.3 beta of Nov 25, 1998 on 28 December 1998 at 3:35:10 pm'!"Change Set:		InterpTweaksDate:			27 December 1998Author:			Dan IngallsAdds a color map if necessary in BitBlt copy:from:in:fillColor:rule: so that the simulator will display properly even if the simulated display is of different depth.Adds cleanUpContexts to the VM, allowing earlier interpreters to read images that have run with strict stack pointer discipline (2.3 and later).Removes an unneccessary cal on primitiveIndexOf: from findNewMethodInClass: and internalFindNewMethodFixes a bug in primitiveDiv (only triggered by access through perform: or doPrimitive:).Removes a redundant integer test in adjustAllOopsBy."!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts interruptCheckCounter displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClassMask CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero CtxtTempFrameStart DoAssertionChecks Done ExternalObjectsArray FalseObject FloatProto GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SizeMask SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!BitBlt methodsFor: 'copying' stamp: 'di 12/26/1998 15:04'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	sourceForm _ srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	srcForm == nil ifFalse:		[colorMap _ srcForm colormapIfNeededForDepth: destForm depth].	^ self copyBits! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 12/28/1998 10:03'!frameSize	"NOTE:  Versions 2.3 and later use a single (large) context size."	"Answer the size of temporary frame needed to run the receiver."	^ LargeFrame"	(self header noMask: 16r20000)		ifTrue: [^ SmallFrame]		ifFalse: [^ LargeFrame]"! !!ObjectMemory methodsFor: 'initialization' stamp: 'di 12/18/1998 13:25'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	"ar 10/7/1998 - Clear the RootBit of all objects"	| oop header |	"Note: Don't bypass this method even if bytesToShift is zero 		until the RootBit problem has been fixed in the appropriate places."	"bytesToShift = 0 ifTrue: [ ^ nil ]."	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			header _ self longAt: oop.			self longAt: oop put: (header bitAnd: AllButRootBit).			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		oop _ self objectAfter: oop.	].! !!ObjectMemory methodsFor: 'object enumeration' stamp: 'di 12/27/1998 23:17'!lastPointerOf: oop	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader header |	self inline: true.	header _ self baseHeader: oop.	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			^ (CtxtTempFrameStart + (self fetchStackPointerOf: oop)) * 4].		sz _ self sizeBitsOfSafe: oop.		^ sz - BaseHeaderSize  "all pointers"].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/18/1998 08:45'!allocateOrRecycleContext	"Return a recycled context or a newly allocated one if none is available for recycling."	| cntxt |	freeContexts ~= NilContext ifTrue:		[cntxt _ freeContexts.		freeContexts _ self fetchPointer: 0 ofObject: cntxt.		^ cntxt].		cntxt _ self instantiateContext: (self splObj: ClassMethodContext)					sizeInBytes: LargeContextSize.	"Required init -- above does not fill w/nil.  All others get written."	self storePointerUnchecked: 4 "InitialIPIndex" ofObject: cntxt					withValue: nilObj.	^ cntxt! !!ObjectMemory methodsFor: 'allocation' stamp: 'di 12/27/1998 23:34'!recycleContextIfPossible: cntxOop	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss.  The recycled context lists are cleared at every garbage collect."	self inline: true.	"only recycle young contexts (which should be most of them)"	(cntxOop >= youngStart		and: [self isMethodContextHeader: (self baseHeader: cntxOop)])		ifTrue:		[self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeContexts.		freeContexts _ cntxOop].! !!ObjectMemory methodsFor: 'gc -- compaction' stamp: 'di 12/27/1998 23:18'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ (header bitAnd: AllButMarkBitAndTypeMask) << 1.		DoAssertionChecks ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt <= 4 ifTrue:		[(fmt = 3 and: [self isContextHeader: header]) ifTrue:			["contexts end at the stack pointer"			^ (CtxtTempFrameStart + (self fetchStackPointerOf: oop)) * 4].		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]			ifFalse: [ size _ header bitAnd: SizeMask ].		^ size - BaseHeaderSize].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!Interpreter commentStamp: '<historical>' prior: 0!This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.NOTE:  Here follows a list of things to be borne in mind when working on this code, or when making changes for the future.1.  There are a number of things that should be done the next time we plan to release a copletely incompatible image format.  These include unifying the instanceSize field of the class format word -- see instantiateClass:indexableSize:, and unifying the bits of the method primitive index (if we decide we need more than 512, after all) -- see primitiveIndexOf:.  Also, contexts should be given a special format code (see next item).2.  There are several fast checks for contexts (see isContextHeader: and isMethodContextHeader:) which will fail if the compact class indices of BlockContext or MethodContext change.  This is necessary because the oops may change during a compaction when the oops are being adjusted.  It's important to be aware of this when writing a new image using the systemTracer.  A better solution would be to reserve one of the format codes for Contexts only.3.  We have made normal files tolerant to size and positions up to 32 bits.  This has not been done for async files, since they are still experimental.  The code in size, at: and at:put: should work with sizes and indices up to 31 bits, although I have not tested it (di 12/98); it might or might not work with 32-bit sizes.4.  Note that 0 is used in a couple of places as an impossible oop.  This should be changed to a constant that really is impossible (or perhaps there is code somewhere that guarantees it --if so it should be put in this comment).  The places include the method cache and the at cache. !!Interpreter methodsFor: 'contexts' stamp: 'di 12/18/1998 21:38'!isContext: oop header: hdr	"NOTE: anOop is assumed not to be an integer"	| ccIndex theClass |	self inline: true.	ccIndex _ (hdr >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [theClass _ (self classHeader: oop) bitAnd: AllButTypeMask]		ifFalse: ["look up compact class"				theClass _ self fetchPointer: ccIndex - 1							ofObject: (self splObj: CompactClasses)].	^ theClass = (self splObj: ClassMethodContext)		or: [theClass = (self splObj: ClassBlockContext)]! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/27/1998 23:32'!isContextHeader: aHeader	| ccIndex |	self inline: true.	ccIndex _ (aHeader >> 12) bitAnd: 16r1F.	^ ccIndex = 13 or: [ccIndex = 14]! !!Interpreter methodsFor: 'contexts' stamp: 'di 12/27/1998 23:32'!isMethodContextHeader: aHeader	self inline: true.	^ ((aHeader >> 12) bitAnd: 16r1F) = 14! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/26/1998 14:40'!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: false.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self lookupMethodInClass: class.		self addToMethodCacheSel: messageSelector			class: class			method: newMethod			primIndex: primitiveIndex.	].! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/18/1998 08:48'!internalActivateNewMethod	| tmp newContext tempCount argCount |	self inline: true.	tmp _ self headerOf: newMethod.	freeContexts ~= NilContext		ifTrue: [newContext _ freeContexts.				freeContexts _ self fetchPointer: 0 ofObject: newContext]		ifFalse: [self externalizeIPandSP.				newContext _ self allocateOrRecycleContext.				self internalizeIPandSP].	tempCount _ (tmp >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf:			(((LiteralStart + (self literalCountOfHeader: tmp)) * 4) + 1)).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	"Copy the reciever and arguments..."	argCount _ argumentCount.	0 to: argCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: (self internalStackValue: argCount-i)].	"clear remaining temps to nil in case it has been recycled"	tmp _ nilObj.	argCount+1 to: tempCount do:		[:i | self storePointerUnchecked: ReceiverIndex+i ofObject: newContext			withValue: tmp].	self internalPop: argCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self internalNewActiveContext: newContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/26/1998 14:40'!internalFindNewMethod	"Find the compiled method to be run when the current messageSelector is sent to the class 'lkupClass', setting the values of 'newMethod' and 'primitiveIndex'."	| ok | 	self inline: true.	self sharedCodeNamed: 'commonLookup' inCase: 131.	ok _ self lookupInMethodCacheSel: messageSelector class: lkupClass.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self externalizeIPandSP.		self lookupMethodInClass: lkupClass.		self internalizeIPandSP.		self addToMethodCacheSel: messageSelector			class: lkupClass			method: newMethod			primIndex: primitiveIndex].! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 12/27/1998 22:52'!primitiveDiv	| quotient |	quotient _ self doPrimitiveDiv: (self stackValue: 1) by: (self stackValue: 0).	self pop2AndPushIntegerIfOK: quotient! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 23:17'!install: rcvr inAtCache: cache at: atIx string: stringy	"Install the oop of this object in the given cache (at or atPut), along with	its size, format and fixedSize"	| hdr fmt totalLength fixedFields |	self var: #cache declareC: 'int *cache'.	hdr _ self baseHeader: rcvr.	fmt _ (hdr >> 8) bitAnd: 16rF.	(fmt = 3 and: [self isContextHeader: hdr]) ifTrue:		["Contexts must not be put in the atCache, since their size is not constant"		^ self primitiveFail].	totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.	cache at: atIx+AtCacheOop put: rcvr.	stringy ifTrue: [cache at: atIx+AtCacheFmt put: fmt + 16]  "special flag for strings"			ifFalse: [cache at: atIx+AtCacheFmt put: fmt].	cache at: atIx+AtCacheFixedFields put: fixedFields.	cache at: atIx+AtCacheSize put: totalLength - fixedFields.! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:49'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self quickFetchInteger: StackPointerIndex ofObject: array]		ifFalse: [stSize _ totalLength - fixedFields].	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [successFlag _ false.  ^ 0].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 19:49'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields stSize |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [stSize _ self quickFetchInteger: StackPointerIndex ofObject: array]		ifFalse: [stSize _ totalLength - fixedFields].	((self cCoerce: index to: 'unsigned ') >= 1		and: [(self cCoerce: index to: 'unsigned ') <= (self cCoerce: stSize to: 'unsigned ')])		ifTrue: [self subscript: array with: (index + fixedFields) storing: value format: fmt]		ifFalse: [successFlag _ false]! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 12/27/1998 23:17'!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	| hdr fmt totalLength fixedFields |	self inline: true.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	(fmt = 3 and: [self isContextHeader: hdr])		ifTrue: [^ self quickFetchInteger: StackPointerIndex ofObject: oop]		ifFalse: [^ totalLength - fixedFields]! !!Interpreter methodsFor: 'other primitives' stamp: 'di 12/18/1998 12:22'!primitiveSnapshot	| activeProc dataSize rcvr |	"save the state of the current process and save it on the scheduler queue"	self storeContextRegisters: activeContext.	activeProc _		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex		    ofObject: activeProc		  withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	self cleanUpContexts.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 12/27/1998 23:16'!cleanUpContexts	"Sweep memory, nilling out all fields of contexts above the stack pointer."	| oop header fmt sz |	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			header _ self longAt: oop.			fmt _ (header >> 8) bitAnd: 16rF.			(fmt = 3 and: [self isContextHeader: header]) ifTrue:				[sz _ self sizeBitsOf: oop.				(self lastPointerOf: oop) + 4 to: sz - BaseHeaderSize by: 4					do: [:i | self longAt: oop+i put: nilObj]]].		oop _ self objectAfter: oop.	].! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 12/18/1998 12:24'!imageFormatVersion	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."	^ 6502! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 12/18/1998 12:25'!readableFormat: imageVersion	"Anwer true if images of the given format are readable by this interpreter. Allows a virtual machine to accept selected older image formats."	^ (imageVersion = self imageFormatVersion) or: [imageVersion = 6504]! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/28/1998 15:35'!profileSends: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profileSends: 5000"	byteCount _ 0.	MessageTally tallySendsTo: self inBlock: [		self internalizeIPandSP.		self fetchNextBytecode.		[byteCount < nBytecodes] whileTrue:			[self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.			byteCount \\ 100 = 0 ifTrue: [byteCount printString , '  ' displayAt: 0@0]].		self externalizeIPandSP.	] showTree: true.	self close! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 12/22/1998 23:24'!stackDepth	| ctxt n |	ctxt _ activeContext.	n _ 0.	[(ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt)) = nilObj]		whileFalse: [n _ n+1].	^ n! !!ObjectMemory class methodsFor: 'initialization' stamp: 'di 12/18/1998 13:01'!initialize	"ObjectMemory initialize"	"Translation flags (booleans that control code generation via conditional translation):"	DoAssertionChecks _ false.  "generate assertion checks"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	CtxtTempFrameStart _ 6.  "Copy of TempFrameStart in Interp"	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 2500.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !ObjectMemory removeSelector: #internalAllocateOrRecycleContext!Interpreter removeSelector: #isMethodContext:header:!ObjectMemory initialize!