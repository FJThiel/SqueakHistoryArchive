'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5657] on 6 February 2004 at 4:09:06 pm'!"Change Set:		raok-EqualityDate:			10 June 2002Author:			Richard A. O'KeefeProvides useful definitions of #= for Bag and Dictionary.Richard answerd 3 queries from Tom on January 25, 2004 tlk(1):    In your version of the = method, there is no special test for identity. For Bag, the comment says    Two bags are equal if     (a) they are the same 'kind' of thing,     (b) they have the same size,     (c) each element occurs the same number of times in both of themraok: If you managed to create a Bag b which contained an object which ... contained b, then then b = b would loop forever.  An identity test would prevent this.  However, it would not prevent other cases.To clarify this, SequenceableCollection>> = has an identity check,but it doesn't tame the following example:  x <- Array new: 1.  x at: 1 put: x.  y <- Array new: 1.  y at: 1 put: (Array new: 1). (y at: 1) at: 1 put: y.  x = yIf you want to add it, go ahead.  It won't hurt anything.tlk: accept your analysis, didn't addtlk(2): For Dictionary, the comment says Two dictionaries are equal if     (a) they are the same 'kind' of thing,     (b) they have the same set of keys,     (c) for each (common) key they have the same valueraok: Again, an identity test isn't *needed* for anything, doesn'tprevent recursive loops, but is pretty harmless.  If you want toadd an identity test, go ahead.Let's look at Set>> = .  In 3.0 it read    = aSet        (aSet isKindOf: Set) ifFalse: [^false].        self size = aSet size ifFalse: [^false].        self do: [:each | (aSet includes: each) ifFalse: [^false]].        ^trueIn 3.5, it reads    = aSet	self == aSet ifTrue: [^true]. ""stop recursion""	...remainder the same as in 3.0...This change was made by 'tk' on 2001.08.11.  As I've explained above, it DOESN'T in fact stop recursion in general, only sometimes.  And it appears to be impossible to build a set with such a cycle without violating the rules about stability of hash codes.So you might like to add the lines    Imitating Set (tk 2001.08.11), we start with an identity test.     Strictly speaking, you cannot build a cyclic Set or Bag or     Dictionary without violating the hash code stability riterion,     so this should not be needed.  Nor is it actually successful in     its aim; it is possible to build cyclic containers where this     test is not adequate to block recursion.  It is here to soothe     people who were scared by Set>> = .    self == aBag ifTrue: [^true].to Bag>> = and similar lines ending with    self == aDictionary ifTrue: [^true].to Dictionary>> =.tlk: Again, accept your analysis, and didn't make the changetlk (3)	Also in your version, 	Dictionaries do not have to be of exactly the same class to be equal. raok: Recall that we have    Set      IdentitySet      PluggableSet      Dictionary        IdentityDictionary        PluggableDictionary    Bag             *IdentityBag     *PluggableBagI don't know why Squeak doesn't provide IdentityBag and PluggableBag; I have written these classes myself.  So for me, BOTH the Bag and Dictionary equality tests act the same way.  There's a reason for this, which I'll explain shortly.  Take another look at the Set>> = method which is there right now in Squeak.  It faces the same problem as Dictionary:  what about the Identity* and Pluggable* versions? And it adopts the same solution: ignore the problem.  This is not surprising; Dictionary>> = was adapted from Set>> = .Now, what's the reason?  Arguably, two Sets should count as equal only if they use the same equality test for elements, and two Dictionaries should count as equal only if they use the same equality test for keys. So how do we check that?    (self isKindOf: PluggableDictionary) ifTrue: [        (aDictionary isKindOf: PluggableDictionary) ifFalse: [^false].        aDictionary equalBlock = self equalBlock ifFalse: [^false].    ] ifFalse: [    (self isKindOf: IdentityDictionary) ifTrue: [	(aDictionary isKindOf: IdentityDictionary) ifFalse: [^false].    ] ifFalse: [	self class == Dictionary ifFalse: [^false]    ]]or something filthy like that using #class instead of #isKindOf:.But (a) a PluggableDictionary using [:x :y | x = y] uses the same  equality test as a plain Dictionary, but will be  incorrectly  rejected from being equal to one, and similarly       a PluggableDictionary using [:x :y | x == y] uses the same        equality test as an IdentityDictionary, but will never be         regarded as equal to one even when it should be.    (b) worse still, two PluggableDictionary objects with the same        equalBlock (that is, the result of a block expression with        equal free variables) won't be equal, because their locks        will NOT be equal.  To see why, type	[:x | x] = [:y | y]	in a workspace and PrintIt:  the answer is false, even though 	these are the SAME function.    (c) the whole thing breaks horribly as soon as someone adds another  class descending from Dictionary.    (d) Anything even remotely like this would disagree with Set>> =,  and the definition of equality for dictionaries should surely  be similar to the definition of equality for sets.There really isn't any satisfactory way around this; the code Iprovided is the least unsatisfactory way.  Perhaps this discussion should be added to the preamble comment.tlk: Done"!!Bag methodsFor: 'comparing' stamp: 'raok 6/10/2002 15:28'!= aBag	"Two bags are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same size.	 (c) each element occurs the same number of times in both of them".	(aBag isKindOf: Bag) ifFalse: [^false].	self size = aBag size ifFalse: [^false].	contents associationsDo: [:assoc|		(aBag occurrencesOf: assoc key) = assoc value			ifFalse: [^false]].	^true! !!Dictionary methodsFor: 'comparing' stamp: 'raok 6/10/2002 15:29'!= aDictionary	"Two dictionaries are equal if	 (a) they are the same 'kind' of thing.	 (b) they have the same set of keys.	 (c) for each (common) key, they have the same value".	(aDictionary isKindOf: Dictionary) ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self associationsDo: [:assoc|		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value			ifFalse: [^false]].	^true! !