'From Squeak 2.4c of May 10, 1999 on 14 July 1999 at 6:42:02 pm'!!Date commentStamp: 'tk 7/14/1999 18:41' prior: 0!I represent a date.  All two digit years are in the 1900s.  Date arithmetic works from 20000 BC to 20000 AD or more.  Be careful how you create dates from strings.  All dates after ('1 Jan 100' asDate) will be created correctly.  Use (Date newDay: 31 year: 99) before that. It works for negative years also.My printing format consists of an array of six elements.  The first three elements contain the numbers 1, 2, 3, in any order.  1 indicates that the day appears in this position, 2 indicates that the month appears in this position, and 3 indicates that the year appears in this position.	The fourth element is the ascii value of the character separator or the character itself.	The fifth element is the month format, where 1 indicates print as a number, 2 indicates print the first three characters, and 3 indicates print the entire name.	The six element is the year format, where 1 indicates print as a number, and 2 indicates print the number modulo 100.	Examples:		#(1 2 3 32 2 1) prints as 12 Dec 1981		#(2 1 3 $/ 1 2) prints as 12/12/81!!Date methodsFor: 'arithmetic' stamp: 'tk 7/14/1999 17:26'!subtractDate: aDate 	"Answer the number of days between the receiver and aDate."	year = aDate year ifTrue: [^ day - aDate day].	(year > 1900) & (year < 2100) ifTrue: [		(aDate year > 1900) & (aDate year < 2100) ifTrue: ["fast"			^ year - 1 // 4 - (aDate year // 4) + day 				+ aDate daysLeftInYear + (year - 1 - aDate year * 365)]].	^ (Date absoluteDaysToYear: year) + day 		- (Date absoluteDaysToYear: aDate year) - aDate day ! !!Date class methodsFor: 'instance creation' stamp: 'tk 7/14/1999 16:48'!fromDays: dayCount	"Answer an instance of me which is dayCount days after January 1, 1901.  Works for negative days before 1901.  Works over a huge range, both BC and AD."	(dayCount > 0) & (dayCount < 73048 "to year 2099") ifTrue: ["fast case"		^ self newDay: 1 + (dayCount asInteger rem: 1461)				"There are 1461 days in a 4-year cycle. 				2000 is a leap year, so no extra correction is necessary. "			year: 1901 + ((dayCount asInteger quo: 1461) * 4)].	Date yearAndDaysFromDays: dayCount + 693960 "Gregorian days to Jan 1 1901" 		into: [:yyyy :ddd | ^ self newDay: ddd year: yyyy].! !!Date class methodsFor: 'general inquiries' stamp: 'tk 7/14/1999 15:57'!absoluteDaysToYear: gregorianYear	"Computes the number of days from (or until) January 1 of the year 1 A.D. upto (or since) January 1 of a given year. [Alan Lovejoy]"	| days yearDelta quadCenturies centuries quadYears years isInADEra |	days := 0.	isInADEra := gregorianYear > 0.	gregorianYear = 0 ifTrue: [gregorianYear = -1]. "There is no year 0"	isInADEra		ifTrue: [yearDelta := gregorianYear - 1]		ifFalse: [yearDelta := (gregorianYear + 1) negated].	quadCenturies := yearDelta // 400.	yearDelta := yearDelta rem: 400.	centuries := yearDelta // 100.	yearDelta := yearDelta rem: 100.	quadYears := yearDelta // 4.	years := yearDelta rem: 4.	days := (quadCenturies * 146097 "days per quad century") +		(centuries * 36524 "days per century")  +		(quadYears * 1461 "days per quad year") +		(years * 365).	isInADEra ifFalse:			[days := days + 366.  "1 B.C. is a leap year"			days := days negated].	^ days! !!Date class methodsFor: 'general inquiries' stamp: 'tk 7/14/1999 15:03'!leapYear: yearInteger "Answer 1 if the year yearInteger is a leap year; answer 0 if it is not."    | adjustedYear |    adjustedYear := yearInteger > 0        ifTrue: [yearInteger]        ifFalse: [(yearInteger + 1) negated "There is no year 0!!!!"].     (adjustedYear \\ 4 ~= 0 or: [adjustedYear \\ 100 = 0 and: [adjustedYear \\ 400 ~= 0]])        ifTrue: [^0]        ifFalse: [^1]! !!Date class methodsFor: 'general inquiries' stamp: 'tk 7/14/1999 17:15'!yearAndDaysFromDays: days into: aTwoArgBlock	"Compute the Gregorian year, and the day of the year, from the number of days since (or until) January 1 of the year 1 A.D. Return the values in a block.  [Alan Lovejoy]"	| quadCentury year dayInYear isInADEra century quadYear |	dayInYear := days.	isInADEra := days >= 0.	isInADEra		ifTrue: [year := 0]		ifFalse: [dayInYear := dayInYear abs.			dayInYear >= 366 "days per leap year" 				ifTrue: [year := 1.						dayInYear := dayInYear - 366]	"Subtract the year 1 B.C."				ifFalse: [year := 0]].	quadCentury := dayInYear // 146097 "days per quad century".	dayInYear := dayInYear \\ 146097 "days per quad century".	century := dayInYear // 36524 "days per century".	dayInYear := dayInYear \\ 36524 "days per century".	quadYear := dayInYear // 1461 "days per quad year".	dayInYear := dayInYear \\ 1461 "days per quad year".	dayInYear >= 365 "days per standard year" ifTrue: ["e.g., 1 AD or 2 BC"		dayInYear := dayInYear - 365 "days per standard year".		year := year + 1.		dayInYear >= 365 "days per standard year" ifTrue: ["e.g., 2 AD or 3 BC"			dayInYear := dayInYear - 365 "days per standard year".			year := year + 1.			dayInYear >= 365 "days per standard year" ifTrue: ["e.g., 3 AD or 4 BC"				dayInYear := dayInYear - 365 "days per standard year".				year := year + 1.				dayInYear >= 366 "days per leap year" ifTrue: [					"e.g., 4 AD or 5 BC (although this won't occur in the AD case)"					dayInYear := dayInYear - 366 "days per leap year".					year := year + 1]]]].	year := year + (quadCentury * 400) + (century * 100) + (quadYear * 4) + 1.	isInADEra ifFalse: [		year := year negated.		dayInYear > 0 ifTrue: [			(Date leapYear: year) = 1				ifTrue: [dayInYear := 366 "days per leap year" - dayInYear]				ifFalse: [dayInYear := 365 "days per standard year" - dayInYear]]].	^ aTwoArgBlock value: year value: dayInYear+1 "the way Dates do it"! !Date class removeSelector: #fromDaysX:!