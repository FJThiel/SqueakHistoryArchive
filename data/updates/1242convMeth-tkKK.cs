'From Squeak 2.4c of May 10, 1999 on 10 June 1999 at 1:59:53 pm'!Object subclass: #ChangeSet	instanceVariableNames: 'classChanges methodChanges classRemoves methodRemoves name preamble postscript structures superclasses '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Changes'!!ChangeSet commentStamp: 'tk 5/17/1999 15:37' prior: 0!My instances keep track of the changes made to a system, so the user can make an incremental fileOut. The order in which changes are made is not remembered.classChanges:  Dictionary {class name -> Set {eg, #change, #rename, etc}}.methodChanges:  Dictionary {class name -> IdentityDictionary {selector -> {eg, #change, #remove, etc}}.classRemoves:  Set {class name (original)}.methodRemoves:  Dictionary {(Array with: class name with: selector) -> (Array with: source pointer with: category)}.name: a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.structures:    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.  Of all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses:    Dictionary {#Rectangle -> #Object}.  Of all classes in classChanges, and all of their superclasses.	Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).!!ChangeSet methodsFor: 'change management' stamp: 'tk 6/10/1999 12:57'!absorbClass: aClass from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.  If aClass has been removed, aClass is the name instead of the class.  *** Classes renamed in otherChangeSet may have problems"	| info |	aClass class == Symbol ifTrue: [		(otherChangeSet classRemoves includes: aClass "name") ifTrue: [			^ self noteRemovalOf: aClass]].	info _ otherChangeSet classChangeAt: aClass name.	info do: [:each | self atClass: aClass add: each].	self absorbStructureOfClass: aClass from: otherChangeSet.	info _ otherChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	info associationsDo: [:ass |		self atSelector: ass key class: aClass put: ass value].! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/8/1999 16:44'!absorbMethod: selector class: aClass from: aChangeSet	"Absorb into the receiver all the changes for the method in the class in the other change set."	| info |	info _ aChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	self atSelector: selector class: aClass put: (info at: selector).! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/10/1999 12:56'!absorbStructureOfClass: aClass from: otherChangeSet	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSet structures ifNil: [^ self].	(otherChangeSet structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil: [structures _ Dictionary new.		superclasses _ Dictionary new].	sup _ aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [			structures at: sup put: (otherChangeSet structures at: sup).			next _ otherChangeSet superclasses at: sup.			superclasses at: sup put: next.			(sup _ next) = 'nil']	] whileFalse.! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/7/1999 18:56'!addClass: class 	"Include indication that a new class was created."	self atClass: class add: #new.	self addCoherency: class name! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/10/1999 12:58'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now.  *** Classes renamed in otherChangeSet may have problems"	| cls info selector pair |	otherChangeSet changedClassNames do: [:className |	  (cls _ Smalltalk classNamed: className) ifNotNil:		[info _ otherChangeSet classChangeAt: className.		info do: [:each | self atClass: cls add: each].		self absorbStructureOfClass: cls from: otherChangeSet.		info _ otherChangeSet methodChanges at: className 			ifAbsent: [Dictionary new].		info associationsDo: [:assoc |			assoc value == #remove				ifTrue:					[selector _ assoc key.					self removeSelector: selector class: cls.					pair _ otherChangeSet methodRemoves							at: (Array with: cls name with: selector)							ifAbsent: [nil].					pair ifNotNil:						["Retain source code ref if stored"						methodRemoves at: (Array with: cls name with: selector)										put: pair]]				ifFalse: 					[self atSelector: assoc key class: cls put: assoc value]]]].		classRemoves addAll: otherChangeSet classRemoves.	"names of them"! !!ChangeSet methodsFor: 'change management' stamp: 'tk 5/17/1999 15:41'!changeClass: class from: oldClass	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifTrue: 		[			self atClass: class add: #change.			self addCoherency: class name.			self noteClassStructure: oldClass.		]! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/9/1999 19:38'!forgetAllChangesFoundIn: aChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner.	sw rewrote Aug 98."	| cls itsMethodChanges myClassChange |	aChangeSet == self ifTrue: [^ self].	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	classRemoves removeAllFoundIn: aChangeSet classRemoves.	"names of them"	self expungeEmptyClassChangeEntries! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/9/1999 19:54'!noteClassForgotten: className	"Remove from structures if class is not a superclass of some other one we are remembering"	structures ifNil: [^ self].	Smalltalk at: className ifPresent: [:cls |		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [			^ self]]].  "No delete"	structures removeKey: className ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/9/1999 21:51'!noteClassStructure: aClass	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."	| clsName |	aClass ifNil: [^ self].	structures ifNil: [structures _ Dictionary new.				superclasses _ Dictionary new].	clsName _ (aClass name asLowercase beginsWith: 'anobsolete') 		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]		ifFalse: [aClass name].	(structures includesKey: clsName) ifFalse: [		structures at: clsName put: 			((Array with: aClass classVersion), (aClass allInstVarNames)).		superclasses at: clsName put: aClass superclass name].	"up the superclass chain"	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].! !!ChangeSet methodsFor: 'change management' stamp: 'tk 6/9/1999 19:36'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	classChanges removeKey:  cname ifAbsent: [].	methodChanges removeKey:  cname ifAbsent: [].	classRemoves remove:  cname ifAbsent: [].	self noteClassForgotten: cname.! !!ChangeSet methodsFor: 'method changes' stamp: 'tk 6/7/1999 18:57'!changedMessageListAugmented	"Even added classes have all messages in changedMessageList."	^ self changedMessageList asArray! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 6/10/1999 13:57'!checkForConversionMethods	"See if any conversion methods are needed"	| needConversion oldList newList tell choice list need oldVer newVer sel smart restore |	"Check preference"	Preferences objectConversionMethodsAtFileOut ifFalse: [^ self].	structures ifNil: [^ self].	needConversion _ false.	list _ OrderedCollection new.	smart _ SmartRefStream on: (RWBinaryOrTextStream on: '12345').	self changedClasses do: [:class |		need _ (self atClass: class includes: #new) not.		need ifTrue: [			"Also consider renamed classes."			(self atClass: class includes: #rename) ifTrue: [				needConversion _ true.  list add: class].			need _ (self atClass: class includes: #change)].		need ifTrue: [oldList _ structures at: class name 								ifAbsent: [need _ false.  #()]].		need ifTrue: [			newList _ (Array with: class classVersion), (class allInstVarNames).			need _ (oldList ~= newList)].		need ifTrue: [			oldVer _ smart versionSymbol: oldList.			newVer _ smart versionSymbol: newList.			sel _ 'convert',oldVer,':',newVer, ':'.				(Symbol hasInterned: sel ifTrue: [:sym | ]) ifFalse: [				need _ false.				needConversion _ true.				list add: class]].		need ifTrue: [sel _ sel asSymbol.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				needConversion _ true.				list add: class]].		].	needConversion ifTrue: ["Ask user if want to do this"		tell _ 'If there might be instances of ', list asArray printString,		'\in a file full of objects on someone''s disk, please fill in conversion methods.\'			withCRs,		'After you edit the methods, you''ll have to fileOut again.\' withCRs,		'The preference objectConversionMethodsAtFileOut controls this feature.'.		choice _ (PopUpMenu labels: 'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.') startUpWithCaption: tell. 		choice = 4 ifTrue: [Preferences disable: #objectConversionMethodsAtFileOut].		choice = 2 ifTrue: [				list do: [:cls | cls withAllSubclassesDo: [:ccc | 						structures removeKey: ccc name ifAbsent: []]]].		choice ~= 1 ifTrue: [^ self]].	list isEmpty ifTrue: [^ self].	smart structures: structures.	"we will test all classes in structures."	smart superclasses: superclasses.	(restore _ Smalltalk changes) == self ifFalse: [		Smalltalk newChanges: self].	[smart verifyStructure = 'conversion method needed'] whileTrue.		"new method is added to changeSet.  Then filed out with the rest."	restore == self ifFalse: [Smalltalk newChanges: restore].	"tell 'em to fileout again after modifying methods."	self inform: 'Remember to fileOut again after modifying these methods.'.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'tk 5/17/1999 15:57'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time."	| file slips |	self checkForConversionMethods.	Cursor write showWhile:		[file _ FileStream newFileNamed:			(self name, FileDirectory dot, Utilities dateTimeSuffix, 				FileDirectory dot, 'cs') asFileName.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	DeepCopier new checkVariables.	Preferences suppressCheckForSlips ifTrue: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'private' stamp: 'tk 6/7/1999 19:04'!atClass: class add: changeType	(classChanges at: class name				ifAbsent: [					^ classChanges at: class name put: (Set with: changeType)])			add: changeType! !!ChangeSet methodsFor: 'private' stamp: 'tk 6/7/1999 19:05'!atSelector: selector class: class put: changeType	| dict |	(selector==#DoIt) | (selector==#DoItIn:) ifTrue: [^self].	(methodChanges at: class name		ifAbsent: 			[dict _ IdentityDictionary new.			methodChanges at: class name put: dict.			dict])		at: selector put: changeType ! !!ChangeSet methodsFor: 'private' stamp: 'tk 6/7/1999 19:00'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed.  5/15/96 sw"	(self atClass: class includes: #change)		ifTrue:			[stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/10/1999 12:44'!fileOut	"File out the current change set."	myChangeSet fileOut.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'class list' stamp: 'tk 6/8/1999 22:23'!copyClassToOther	"Place these changes in the other changeSet also"	| other |	other _ (parent other: self) changeSet.	(myChangeSet classRemoves includes: currentClassName) ifTrue: [			^ other absorbClass: currentClassName from: myChangeSet].	other absorbClass: self selectedClassOrMetaClass from: myChangeSet.	(parent other: self) showChangeSet: other.! !!ChangeSorter methodsFor: 'class list' stamp: 'tk 6/8/1999 22:23'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	| cls otherSorter otherChangeSet |	self okToChange ifFalse: [^ self beep].	currentClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet == myChangeSet ifTrue: [^ self beep].	(myChangeSet classRemoves includes: currentClassName)		ifTrue:			[otherChangeSet noteRemovalOf: currentClassName]		ifFalse:			[cls _ self selectedClassOrMetaClass.			otherChangeSet absorbClass: cls from: myChangeSet].	otherSorter showChangeSet: otherChangeSet.	self forgetClass! !!ChangeSorter methodsFor: 'message list' stamp: 'tk 6/8/1999 22:24'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	currentSelector ifNotNil: [		other _ (parent other: self) changeSet.		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'tk 6/8/1999 22:24'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self okToChange ifFalse: [^ self beep].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!Class methodsFor: 'class variables' stamp: 'tk 5/17/1999 15:59'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol |	aString first isLowercase		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		subclass scopeHas: symbol			ifTrue: [:temp | 					^ self error: aString 						, ' is already used as a variable name in class ' 						, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		classPool declare: symbol from: Undeclared.		Smalltalk changes changeClass: self from: nil]! !!Metaclass methodsFor: 'initialize-release' stamp: 'tk 5/15/1999 17:15'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				weak: false				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true					wasPresent: true.	"as far as we know"				Smalltalk changes changeClass: newMeta from: self]! !!Metaclass methodsFor: 'class hierarchy' stamp: 'tk 5/24/1999 11:59'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p weak: beWeak classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName].			(oldClass checkForInstVarsOK: instVarString)				ifFalse: [^ false]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					weak: beWeak					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	wasPresent ifFalse: [Smalltalk changes addClass: newClass].	Smalltalk changes changeClass: newClass from: oldClass.	^ newClass! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 6/10/1999 13:59'!writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList	"No method sel was found in newClass.  Ask user to look for the fileIn.  Or help by writing a prototype conversion method.  "| tell choice code keywords newOthers oldOthers copied |choice _ 2.byteStream position = 0 ifFalse: ["an actual file read"	newClass name = oldName 		ifTrue: [tell _ 'The class ', oldName]		ifFalse: [tell _ 'An instance of ', oldName, ' is coming in as an ', newClass name, '.  It'].tell _ tell, ' has different instance variables than before.  It needs a conversion method.  You may:'.choice _ (PopUpMenu labels: 'Find a conversion file on the disk and file it inWrite a conversion method by editing a prototype') startUpWithCaption: tell. ].choice = 1 ifTrue: [PopUpMenu notify: 'After filing in the conversion file, please read-in the object file again.'].	"you need to restart the read-in"choice = 2 ifTrue: [	code _ WriteStream on: (String new: 500).	keywords _ sel keywords.	code nextPutAll: (keywords at: 1); nextPutAll: ' varDict '; 			nextPutAll: (keywords at: 2); nextPutAll: ' smartRefStrm'; cr; tab.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code nextPutAll: '"These variables are automatically stored into the new instance '.	code nextPutAll: copied asArray printString; nextPut: $. .	code cr; tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; cr; cr; tab.	(newOthers size = 0) & (oldOthers size = 0) 		ifTrue: [code nextPutAll: '"Instance variables are the same.  Only the order changed.  This method should work as written."'].	(newOthers size > 0) ifTrue: [code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withCRs].	(oldOthers size > 0) ifTrue: [code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in another variable?"'].	newClass compile: code contents classified: 'object fileIn'.	byteStream position = 0 ifFalse: [		PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'].	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !!SmartRefStream methodsFor: 'accessing' stamp: 'tk 5/19/1999 15:47'!structures: anObject	structures _ anObject! !!SmartRefStream methodsFor: 'accessing' stamp: 'tk 5/19/1999 15:47'!superclasses: anObject	superclasses _ anObject! !ChangeSet removeSelector: #classAboutToChange:!ChangeSet removeSelector: #convertcmcmnpp0:cmcmnppss0:!ChangeSet removeSelector: #allMessagesForAddedClasses!ChangeSet removeSelector: #conversion:!ChangeSet removeSelector: #changeClass:!ChangeSet removeSelector: #isNew:!ReadWriteStream removeSelector: #fileOutChangesFor:!"Postscript:Set the preference to true, so it will ask you to write conversion methods for classes that change shape."Preferences enable: #objectConversionMethodsAtFileOut.!