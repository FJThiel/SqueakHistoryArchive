'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 10:49:28 pm'!"Change Set:		VMSharedCodeDate:			5 December 1998Author:			Dan IngallsFixes a non-fatal bug in bytecodePrimitiveValueWith, and enables sharing of nested labels in C translation.  Also tweaks the changes... menu and adds a missing method for readOnlyFileNamed: in ServerDirectory."!!Interpreter methodsFor: 'contexts' stamp: 'di 12/5/1998 21:48'!internalNewActiveContext: aContext	"The only difference between this method and newActiveContext: is that this method uses internal context registers."	self inline: true.	"self sharedCodeNamed: 'commonNewActiveContext' inCase: 131."	self internalStoreContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self internalFetchContextRegisters: aContext.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/5/1998 21:04'!internalSendSelectorToClass: classPointer	self inline: true.	self sharedCodeNamed: 'commonSendSelector' inCase: 131.	self internalFindNewMethodInClass: classPointer.	self internalExecuteNewMethod.! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/5/1998 15:38'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lkupClass |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	lkupClass _ self fetchClassOf: (self internalStackValue: argumentCount).	self internalSendSelectorToClass: lkupClass! !!Interpreter methodsFor: 'message sending' stamp: 'di 12/5/1998 15:38'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| lkupClass |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	lkupClass _ self superclassOf: (self methodClassOf: method).	self internalSendSelectorToClass: lkupClass! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/5/1998 16:07'!bytecodePrimValue	argumentCount _ 0.	self internalPrimitiveValue.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 12/5/1998 21:01'!bytecodePrimValueWithArg	argumentCount _ 1.	self internalPrimitiveValue.! !!Interpreter methodsFor: 'control primitives' stamp: 'di 12/5/1998 21:28'!internalPrimitiveValue	| newContext blockArgumentCount initialIP |	self inline: true.	self sharedCodeNamed: 'commonPrimitiveValue' inCase: 201.	successFlag _ true.	newContext _ self internalStackValue: argumentCount.	self assertClassOf: newContext is: (self splObj: ClassBlockContext).	blockArgumentCount _ self argumentCountOfBlock: newContext.	self success: (argumentCount = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: newContext) = nilObj]).	successFlag ifTrue:		["This code assumes argCount can only = 0 or 1"		argumentCount = 1 ifTrue:			[self storePointer: TempFrameStart ofObject: newContext				withValue: self internalStackTop].		self internalPop: argumentCount + 1.		initialIP _ self fetchPointer: InitialIPIndex	ofObject: newContext.		self storePointerUnchecked: InstructionPointerIndex ofObject: newContext			withValue: initialIP.		self storeStackPointerValue: argumentCount	inContext: newContext.		self storePointerUnchecked: CallerIndex		ofObject: newContext			withValue: activeContext.		self internalNewActiveContext: newContext] 	ifFalse:		[messageSelector _ self specialSelector: 25+argumentCount.		self normalSend].! !!ScreenController methodsFor: 'nested menus' stamp: 'di 12/5/1998 21:00'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'simple change sorter'			'dual change sorter'			'file out changes'			'create new change set...'			'browse changed methods'			'check for slips'			'browse recent submissions'			'recent change log'			)		lines: #(1 3 7)		selections: #(durableChangesMenuopenSimpleChangeSorter openChangeManagerfileOutChanges newChangeSet browseChangedMessages lookForSlipsbrowseRecentSubmissions browseRecentLog )"ScreenController new changesMenu startUp"! !!ServerDirectory methodsFor: 'file directory' stamp: 'di 12/5/1998 22:37'!readOnlyFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!TCaseStmtNode methodsFor: 'all' stamp: 'di 12/5/1998 22:19'!fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"NOTE: I have made this work for the nested case (ie several shared entry points in the same case, but it does not really work for methods with arguments.  It will work if you are lucky that the outer temp names corresponding to their arguments happen to be the same.  This is currently *fortuitously* the case with internalSendSelectorToClass:, but not with internalNewActiveContext:.  A mechanism coud be added that would add a preamble of the form,	innerSharedTemp = outerTemp;when they differed.  There should at least be a test here.UNTIL THIS IS DONE, THE SHARING OF internalSendSelectorToClass: MAKES THE TRANSLATION PROCESS OPEN TO A VERY CONFUSING POSSIBLE BUG. -di 12/5/98"	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by branches to that single instance of the code."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying _ true.			oldStmts _ node statements asArray.			newStmts _ nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt _ oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts == nil 							ifTrue: [newStmts _ (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection]							ifFalse: [newStmts removeLast "preserve any prior shared entry points - di"].						codeBlockName _ stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TGoToNode new setLabel: codeBlockName).							copying _ false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				] ifFalse: [	"ikp: this permits explicit returns before 'goto aSharedCodeLabel'"					stmt _ oldStmts at: i.					(stmt isLabel and: [stmt label ~= nil]) ifTrue: [newStmts add: stmt].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].! !