'From TeaSqueak3.2 of 19 September 2002 [latest update: #239] on 6 October 2002 at 1:24:54 am'!"Change Set:		ClassBuilderMutate-arDate:			20 September 2002Author:			Andreas RaabOnce and for all fix all the problems with ClassBuilder's mutation process and the handling of obsolete subclasses."!!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 02:57'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass needNew |	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass or not"	needNew _ self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.	needNew ifNil:[^nil]. "some error"	needNew ifFalse:[^oldClass]. "no new class needed"	"Create the new class"	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass.	newClass _ self recompile: false from: oldClass to: newClass mutate: false.	self doneCompiling: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 03:00'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined!! \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass _ self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass _ oldClass.	].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	newClass environment: environ.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	self doneCompiling: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 02:57'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	| newFormat |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	newFormat = oldClass format ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 02:43'!newSubclassOf: newSuper	"Create a new meta and non-meta subclass of newSuper"	| newSuperMeta newMeta |	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	newMeta _ Metaclass new.	newMeta 		superclass: newSuperMeta 		methodDictionary: MethodDictionary new 		format: newSuperMeta format.	^newMeta new! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 02:48'!newSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self newSubclassOf: newSuper].	newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta _ oldClass class.	newMeta _ oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: MethodDictionary new		format: (self computeFormat: oldMeta typeOfClass 					instSize: oldMeta instVarNames size 					forSuper: newSuperMeta					ccIndex: 0);		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 03:16'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newFormat newClass |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass _ self newSubclassOf: newSuper from: oldClass]		ifFalse:[newClass _ oldClass clone].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		self recordClass: oldClass replacedBy: newClass.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 03:12'!recompile: force from: oldClass to: newClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	oldClass == nil ifTrue:[		"newClass has an empty method dictionary		so we don't need to recompile"		Smalltalk changes addClass: newClass.		newClass superclass addSubclass: newClass.		^newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		"No recompilation necessary but we might have added		class vars or class pools so record the change"		Smalltalk changes changeClass: newClass from: oldClass.		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress _ nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress _ nil].		Smalltalk changes changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.	].	^oldClass "now mutated to newClass"! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 9/22/2002 03:11'!mutate: oldClass to: newClass	"Mutate the old class and subclasses into newClass and subclasses.	Note: This method is slightly different from: #mutate:toSuper: since	here we are at the root of reshaping and have two distinct roots."	| newSubclass oldSuper newSuper |	self showProgressFor: oldClass.	oldSuper _ oldClass superclass.	newSuper _ newClass superclass.	oldSuper isObsolete 		ifTrue:[oldSuper removeObsoleteSubclass: oldClass]		ifFalse:[oldSuper removeSubclass: oldClass].	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass|		oldClass removeSubclass: oldSubclass.		newSubclass _ self mutate: oldSubclass toSuper: newClass.		newClass addSubclass: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			oldClass removeObsoleteSubclass: oldSubclass.			newSubclass _ self mutate: oldSubclass toSuper: newClass.			newClass addObsoleteSubclass: newSubclass.		].	].	self update: oldClass to: newClass.	newSuper isObsolete		ifTrue:[newSuper addObsoleteSubclass: newClass]		ifFalse:[newSuper addSubclass: newClass].! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 9/22/2002 02:02'!mutate: oldClass toSuper: newSuper	"Mutate oldClass into a subclass of newSuper possibly using templateClass for redefinition. Recursively update all the subclasses of oldClass, converting any instances during recompilation."	| newClass newSubclass |	self showProgressFor: oldClass.	newClass _ self reshapeClass: oldClass toSuper: newSuper.	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass|		oldClass removeSubclass: oldSubclass.		newSubclass _ self mutate: oldSubclass toSuper: newClass.		newClass addSubclass: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			oldClass removeObsoleteSubclass: oldSubclass.			newSubclass _ self mutate: oldSubclass toSuper: newClass.			newClass addObsoleteSubclass: newSubclass.		].	].	self update: oldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 9/22/2002 03:16'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	"ar 9/22/2002: The following is a left-over from some older code. 	I do *not* know why we uncompact oldClass here. If you do, then 	please let me know so I can put a comment here..."	oldClass becomeUncompact.	instVars _ instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 9/21/2002 15:34'!update: oldClass to: newClass	"Convert oldClass, all its instances and possibly its meta class into newClass, instances of newClass and possibly its meta class. The process is surprisingly simple since we can rely on two assumptions (those are critical):		#1: The method #updateInstancesFrom: will not create any lasting pointers to 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do a become of the old vs. the new instances and therefore it will not create pointers to *new* instances before the #become: which are *old* afterwards)		#2: The non-preemptive execution of the critical piece of code guarantees that nobody can get a hold by 'other means' (such as process interruption and reflection) on the old instances.	Given the above two, we know that after #updateInstancesFrom: there are no pointer to any old instances. After the forwarding become there will be no pointers to the old class or meta class either. Meaning that if we throw in a nice fat GC at the end of the critical block, everything will be gone. There's no need to worry.	"	| meta |	meta _ oldClass isMeta.	"Note: Everything from here on will run without the ability to get interrupted	to prevent any other process to create new instances of the old class."	[		"Convert the instances of oldClass into instances of newClass"		newClass updateInstancesFrom: oldClass.		meta			ifTrue:[oldClass becomeForward: newClass]			ifFalse:[(Array with: oldClass with: oldClass class)						elementsForwardIdentityTo:							(Array with: newClass with: newClass class)].		Smalltalk garbageCollect.	] valueUnpreemptively.! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!addObsoleteSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!obsoleteSubclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass obsoleteSubclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses_nil' for: m logged: false]"! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!removeObsoleteSubclass: aClass	"Do nothing."! !ClassBuilder removeSelector: #fixSuperSendsFrom:!ClassBuilder removeSelector: #fixSuperSendsTo:!ClassBuilder removeSelector: #hasPrimitiveChangeClassTo!ClassBuilder removeSelector: #mutate:to:super:!ClassBuilder removeSelector: #newSubclassOf:type:instanceVariables:from:unsafe:!ClassBuilder removeSelector: #reshapeClass:to:super:!ClassBuilder removeSelector: #tryPrimitiveChangeClassTo:!