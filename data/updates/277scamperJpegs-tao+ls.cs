'From Squeak 2.1 of June 30, 1998 on 17 September 1998 at 4:15:20 am'!"Change Set:		scamperJpegs-tao+lsDate:			17 September 1998Author:			Your NameLinks Tim Olsen's JPEG reader into Scamper.  Includes Tim Olsen's fixes for grayscale images."!!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:31'!downloadState	"download the image"	| doc img |	doc _ url retrieveContents.	doc mainType = 'image' 	ifTrue: [		[ img _ ImageReadWriter 		  formFromStream: (RWBinaryOrTextStream with: doc content) binary reset ] ifError: [ :a :b | Transcript show: a.  image _ nil ].		downloadQueue nextPut: img. ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:21'!initialize	super initialize.	altText _ '[image]'.	self color: Color transparent.	downloadQueue _ SharedQueue new.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 21:43'!setContents	"set up our morphic contents"	| stringMorph imageMorph outlineMorph extent |	self removeAllMorphs.	image		ifNil: [ 			altText = '' ifTrue: [ self extent: 0@0. "don't display anything..." ^self ].			stringMorph _ StringMorph new.			stringMorph contents: altText.			stringMorph position: self position+(2@2).			self addMorph: stringMorph.			outlineMorph _ RectangleMorph new.			outlineMorph borderWidth: 1.			outlineMorph color: Color transparent.			outlineMorph position: self position.			"figure out how big to make the box"			extent _ defaultExtent ifNil: [ 0 @ 0 ].			stringMorph width + 4 > extent x ifTrue: [				extent _ (stringMorph width + 4) @ extent y ].			stringMorph height + 4 > extent y ifTrue: [				extent _ extent x @ (stringMorph height + 4) ].			outlineMorph extent: extent.			self addMorph: outlineMorph.			self extent: outlineMorph extent ]		ifNotNil: [			imageMorph _ ImageMorph new.			imageMorph image: image.			imageMorph position: self position.			self addMorph: imageMorph.			imageMorph extent ~= self extent ifTrue: [				self extent: imageMorph extent ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:19'!stepTime	"this check doesn't need to be frequent"	^500! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| stream |	stream _ FileStream readOnlyFileNamed: fileName.	^self formFromStream: stream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:10'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | aBinaryStream reset. (subclass new on: aBinaryStream) understandsImageFormat]		ifNone: [			(aBinaryStream respondsTo: #close) ifTrue: [ aBinaryStream close ].			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ls 9/15/1998 19:57'!nextImage	| form xStep yStep x y |	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 9/16/1998 19:56'!perScanSetup	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership _ OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | Array new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer _ Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: 32.	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ls 9/17/1998 03:49'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream _ currentComponents at: 1.	ySampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ (ySampleStream nextSample).		bits at: i put: ((y<<16) + (y<<8) + y  max: 1)].	! !!Scamper methodsFor: 'changing page' stamp: 'ls 9/15/1998 21:42'!displayDocument: mimeDocument	"switch to viewing the given MIMEDocument"	| newUrl  newSource handled  formatter fileName file image imageMorph attrib text |	newUrl _ mimeDocument url.	newSource _ mimeDocument.	handled _ false.	"add it to the history"	recentDocuments removeAllSuchThat: [ :d | d url = mimeDocument url ].	recentDocuments addLast: mimeDocument.	recentDocuments size > 20 ifTrue: [ recentDocuments removeFirst ].			newSource mainType = 'image' ifTrue: [		"an image--embed it in a text"		document _ nil.		formattedPage _ [			image _ ImageReadWriter formFromStream: (RWBinaryOrTextStream with: newSource content) binary reset.			imageMorph _ ImageMorph new image: image.			attrib _ TextAnchor new anchoredMorph: imageMorph.			text _ ' * ' asText.			text addAttribute: attrib from: 2 to: 2.			text		] ifError: [ :msg :ctx | msg ].		currentUrl _ newUrl.		pageSource _ newSource content.		handled _ true. 		self status: 'sittin'.		self changed: #currentUrl.			self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.		self changed: #formattedPageSelection.  		"remove it from the history--these thigns are too big!!"		"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."		recentDocuments removeLast.	].	newSource contentType = 'text/html' ifTrue: [		"HTML page--format it"		currentUrl _ newUrl.		pageSource _ newSource content.		self status: 'parsing...'.		document _ (HtmlParser parse: (ReadStream on: pageSource)).		self status: 'laying out...'.		formatter _ HtmlFormatter new.		formatter browser: self.		formatter baseUrl: currentUrl.		document addToFormatter: formatter.		formattedPage _ formatter text.		currentUrl fragment			ifNil: [ currentAnchorLocation _ nil ]			ifNotNil: [ currentAnchorLocation _				formatter anchorLocations 					at: currentUrl fragment asLowercase					ifAbsent: [ nil ] ].		self startDownloadingMorphState: (formatter incompleteMorphs).		handled _ true.		self status: 'sittin'.		self changed: #currentUrl.			self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.		self changed: #formattedPageSelection.  ].	(#('audio/midi' 'audio/x-midi') includes: newSource contentType) ifTrue: [		MIDIFileReader playStream: (RWBinaryOrTextStream with: newSource content) reset binary.		self status: 'sittin'.		handled _ true. ].	(handled not and: [ newSource mainType = 'text']) ifTrue: [		"treat as plain text"		pageSource _ newSource content.		document _ nil.		formattedPage _ pageSource withSqueakLineEndings.		currentUrl _ newUrl.				self status: 'sittin'.		self changed: #currentUrl.		self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.  		handled _ true].	handled ifFalse: [		"offer to save it to a file"		self status: 'sittin'.		(self confirm: 'unkown content-type ', newSource contentType,'--Would you like to save to a file?') ifFalse: [			^self ].		fileName _ ''.		[			fileName _ FillInTheBlank request: 'file to save in' initialAnswer: fileName.			fileName isEmpty ifTrue: [ ^self ].			file _ FileStream fileNamed: fileName.			file == nil		] whileTrue.		file reset.		file binary.		file nextPutAll: newSource content.		file close.	].! !!TextMorph methodsFor: 'accessing' stamp: 'ls 9/15/1998 19:36'!newContents: stringOrText	"Accept new text contents."	| newText |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text _ newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@-1000)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self world ifNotNil: [ 		self world startSteppingSubmorphsOf: self ].! !DownloadingImageMorph removeSelector: #download!DownloadingImageMorph removeSelector: #startDownloading!