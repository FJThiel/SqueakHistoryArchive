'From Squeak2.8alpha of 16 February 2000 [latest update: #1974] on 28 March 2000 at 2:07:23 pm'!"Change Set:		B3DSceneExplorerDate:			28 March 2000Author:			Tobias IsenbergAdds a B3DSceneExplorerMorph with a number of generally useful control elements."!B3DSceneMorph subclass: #AdvancedB3DSceneMorph	instanceVariableNames: 'rotationAngle stepTime isRotating oldPoint '	classVariableNames: ''	poolDictionaries: 'B3DEngineConstants '	category: 'Balloon3D-Demo Morphs'!BorderedMorph subclass: #B3DSceneExplorerMorph	instanceVariableNames: 'wheels frameWidth b3DSceneMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Balloon3D'!BorderedMorph subclass: #WheelMorph	instanceVariableNames: 'target actionSelector factor circular old angle maxAngle lastRedraw '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Balloon3D'!!AdvancedB3DSceneMorph reorganize!('accessing' rotationAngle rotationAngle: scene: stepTime stepTime:)('camera actions' addDolly: addFovAngle: panBy: rotateX: rotateY: rotateZ: updateHeadlight)('drawing' renderOn:)('event handling' handlesMouseDown: mouseDown: mouseMove:)('initialization' createDefaultScene initialize)('properties' beRotating beStill isRotating switchRotationStatus)('stepping' step)!!AdvancedB3DSceneMorph methodsFor: 'accessing' stamp: 'ti 3/24/2000 16:36'!rotationAngle	^rotationAngle! !!AdvancedB3DSceneMorph methodsFor: 'accessing' stamp: 'ti 3/24/2000 16:36'!rotationAngle: aNumber	rotationAngle := aNumber! !!AdvancedB3DSceneMorph methodsFor: 'accessing' stamp: 'ti 3/27/2000 16:55'!scene: aScene	super scene: aScene.	self updateHeadlight.	self changed! !!AdvancedB3DSceneMorph methodsFor: 'accessing' stamp: 'ti 3/24/2000 16:35'!stepTime	^stepTime! !!AdvancedB3DSceneMorph methodsFor: 'accessing' stamp: 'ti 3/24/2000 16:35'!stepTime: aNumber	stepTime := aNumber! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:55'!addDolly: delta	| camera new |	camera := scene defaultCamera.	new := camera position - (camera direction * delta).	camera target = new ifFalse: [		camera position: new].	self updateHeadlight.	self changed.! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:55'!addFovAngle: delta	| camera new |	camera := scene defaultCamera.	new := camera fov + delta.	0 < new ifTrue: [		camera fov: new].	self updateHeadlight.	self changed.! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:54'!panBy: aPoint	| camera pt |	pt := B3DVector3 x: aPoint x y: aPoint y negated z: 0.0. 	camera := scene defaultCamera.	pt := pt * (camera direction length) / 200.	pt := camera asMatrix4x4 inverseTransformation localPointToGlobal: pt.	pt := pt - camera position.	camera position: camera position + pt.	camera target: camera target + pt.	self updateHeadlight.	self changed.! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:55'!rotateX:  angle	| camera matrix |	camera := scene defaultCamera.	matrix := B3DMatrix4x4		rotatedBy: angle		around: ((camera position - camera target) cross: camera up)		centeredAt: camera target.	camera position: (matrix localPointToGlobal: camera position).	camera up: (matrix localPointToGlobal: camera up).	self updateHeadlight.	self changed.! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:55'!rotateY: angle	| camera matrix |	camera := scene defaultCamera.	matrix := B3DMatrix4x4		rotatedBy: angle		around: camera up		centeredAt: camera target.	camera position: (matrix localPointToGlobal: camera position).	self updateHeadlight.	self changed.! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:54'!rotateZ: angle	| camera matrix |	camera := scene defaultCamera.	matrix := B3DMatrix4x4		rotatedBy: angle		around: (camera position - camera target)		centeredAt: camera target.	camera up: (matrix localPointToGlobal: camera up).	self updateHeadlight.	self changed.! !!AdvancedB3DSceneMorph methodsFor: 'camera actions' stamp: 'ti 3/27/2000 16:54'!updateHeadlight	| headLight camera |	camera := scene defaultCamera.	(self scene lights isKindOf: Dictionary)		ifTrue: [headLight := self scene lights at: '$HeadLight$' ifAbsent: []]		ifFalse: [headLight := nil].	headLight ifNotNil: [		headLight			position: camera position;			target: camera target].! !!AdvancedB3DSceneMorph methodsFor: 'drawing' stamp: 'ti 3/24/2000 17:12'!renderOn: aRenderer	aRenderer getVertexBuffer flags: (aRenderer getVertexBuffer flags bitOr: VBTwoSidedLighting).	super renderOn: aRenderer! !!AdvancedB3DSceneMorph methodsFor: 'event handling' stamp: 'ti 3/24/2000 17:01'!handlesMouseDown: evt	evt yellowButtonPressed ifTrue: [^false] ifFalse: [^true]! !!AdvancedB3DSceneMorph methodsFor: 'event handling' stamp: 'ti 3/24/2000 17:02'!mouseDown: evt	oldPoint := evt cursorPoint.	super mouseDown: evt.! !!AdvancedB3DSceneMorph methodsFor: 'event handling' stamp: 'ti 3/24/2000 17:02'!mouseMove: evt	oldPoint ifNil: [^super mouseMove: evt].	((evt redButtonPressed) and: [evt shiftPressed]) ifTrue: [		self panBy: oldPoint - evt cursorPoint.		oldPoint := evt cursorPoint.]! !!AdvancedB3DSceneMorph methodsFor: 'initialization' stamp: 'ti 3/27/2000 10:51'!createDefaultScene	| camera headLight |	super createDefaultScene.	camera _ B3DCamera new.	camera position: 0@0@-6.	camera target: 0@0@0.	camera fov: 15.0.	scene defaultCamera: camera.	headLight := B3DSpotLight new.	headLight position: 0@-1@0.	headLight target: 0@0@0.	headLight lightColor: (B3DMaterialColor color: (Color blue)).	headLight attenuation: (B3DLightAttenuation constant: 1.0 linear: 0.0 squared: 0.0).	headLight minAngle: 5.	headLight maxAngle: 6.	scene lights add: headLight.	scene objects do: [ :object |		object material: nil]! !!AdvancedB3DSceneMorph methodsFor: 'initialization' stamp: 'ti 3/24/2000 17:26'!initialize	super initialize.	self stepTime: 0.	self rotationAngle: 1.	self beRotating.! !!AdvancedB3DSceneMorph methodsFor: 'properties' stamp: 'ti 3/24/2000 16:37'!beRotating	isRotating := true.! !!AdvancedB3DSceneMorph methodsFor: 'properties' stamp: 'ti 3/24/2000 16:37'!beStill	isRotating := false.! !!AdvancedB3DSceneMorph methodsFor: 'properties' stamp: 'ti 3/24/2000 16:37'!isRotating	^isRotating! !!AdvancedB3DSceneMorph methodsFor: 'properties' stamp: 'ti 3/24/2000 16:37'!switchRotationStatus	self isRotating		ifTrue: [self beStill]		ifFalse: [self beRotating]! !!AdvancedB3DSceneMorph methodsFor: 'stepping' stamp: 'ti 3/27/2000 16:55'!step	self isRotating ifTrue: [		scene defaultCamera rotateBy: self rotationAngle.		self updateHeadlight.		self changed.].! !!B3DCamera methodsFor: 'initialize' stamp: 'ti 3/27/2000 17:03'!setClippingPlanesFrom: anObject	"Set the clipping planes from the given object"	| box center radius avgDist |	box _ anObject boundingBox.	center _ (box origin + box corner) * 0.5.	radius _ (center - box origin) length.	avgDist _ (position - center) length.	self farDistance: avgDist + radius.	avgDist > radius 		ifTrue:[self nearDistance:			((((center - position) normalized				dot: (self direction normalized))					* avgDist - radius) max: 1.0e-31)]		ifFalse:[self nearDistance: (self farDistance * 0.00001)].! !!B3DCamera methodsFor: 'converting' stamp: 'ti 3/22/2000 10:46'!asMatrix4x4	| xDir yDir zDir m |	"calculate z vector"	zDir _ self target - self position.	zDir safelyNormalize.	"calculate x vector"	xDir _ self up cross: zDir.	xDir safelyNormalize.	"recalc y vector"	yDir _ zDir cross: xDir.	yDir safelyNormalize.	m := B3DMatrix4x4 new.	m	a11: xDir x;		a12: xDir y;		a13: xDir z;		a14: 0.0;		a21: yDir x;		a22: yDir y;		a23: yDir z;		a24: 0.0;		a31: zDir x;		a32: zDir y;		a33: zDir z;		a34: 0.0;		a41: 0.0;			a42: 0.0;		a43: 0.0;		a44: 1.0.	m := m composeWith: (B3DMatrix4x4 identity setTranslation: self position negated).	^m! !!B3DLightSource methodsFor: 'accessing' stamp: 'ti 3/27/2000 14:21'!spotExponent	"Return the exponent to be used for the spot fall off computation"	^1.0! !!B3DScene methodsFor: 'initialize' stamp: 'ti 3/28/2000 13:14'!from3DS: aDictionary	"Remove the globals from the scene - the remaining objects are	name->sceneObject "	| globals constants ambient texture funkyNormals r1 |	globals _ aDictionary at: #globals.	constants _ globals at: #constants ifAbsent: [Dictionary new].	aDictionary removeKey: #globals.	"Collect the scene objects and assign the names"	objects _ OrderedCollection new.	aDictionary associationsDo: [:assoc | objects add: ((B3DSceneObjectfrom3DS: assoc value)				name: assoc key)].	"Fetch the cameras and set a default camera"	cameras _ globals at: #cameras.	cameras isEmpty		ifTrue: [defaultCamera _ B3DCamera new position: 0 @ 0 @ 0]		ifFalse: [defaultCamera _ cameras at: cameras keysasSortedCollection first].	"Fetch the lights"	lights _ globals at: #lights.	"Add the ambient light if possible.	Note: The name $AMBIENT$ is used in the keyframe section of the 3DS	file. "	ambient _ constants at: 'ambientColor'				ifAbsent: [B3DColor4						r: 0.0						g: 0.0						b: 0.0						a: 0.0].	ambient ifNotNil: [lights at: '$AMBIENT$' put: (B3DAmbientLightcolor: ambient)].	"Fetch the background color"	clearColor _ constants at: 'backgroundColor' ifAbsent: [Color white].	"Fetch the materials and replace names in sceneObjects by actual	materials "	materials _ globals at: #materials.	"Compute the per vertex normals"	funkyNormals _ self confirm: 'Do you want funky normals instead ofaccurate normals?(It will give the model a somewhat strange, but interesting look)'.	'Computing vertex normals'		displayProgressAt: Sensor cursorPoint		from: 0		to: objects size		during: [:bar | objects				doWithIndex:					[:obj :index |					bar value: index.					obj material ifNotNil: [objmaterial: (materials at: obj material ifAbsent: [])].					funkyNormals						ifTrue: [obj geometrycomputeFunkyVertexNormals]						ifFalse: [obj geometryvertexNormals]]].	(self confirm: 'Do you want to use a texture with the model?')		ifTrue:			[Utilities informUser: 'Choose a rectangle withinteresting stuff'				during:					[r1 _ Rectangle originFromUser: 128@ 128.					Sensor waitNoButton].			texture _ B3DTexture fromDisplay: r1.			texture wrap: true.			texture interpolate: false.			texture envMode: 0].	objects do: [:obj | obj texture ifNotNil: [obj texture: texture]]! !!B3DScene methodsFor: 'initialize' stamp: 'ti 3/28/2000 13:11'!withoutQuestionsFrom3DS: aDictionary	"Remove the globals from the scene - the remaining objects are	name->sceneObject "	| globals constants ambient texture funkyNormals |	globals _ aDictionary at: #globals.	constants _ globals at: #constants ifAbsent: [Dictionary new].	aDictionary removeKey: #globals.	"Collect the scene objects and assign the names"	objects _ OrderedCollection new.	aDictionary associationsDo: [:assoc | objects add: ((B3DSceneObjectfrom3DS: assoc value)				name: assoc key)].	"Fetch the cameras and set a default camera"	cameras _ globals at: #cameras.	cameras isEmpty		ifTrue: [defaultCamera _ B3DCamera new position: 0 @ 0 @ 0]		ifFalse: [defaultCamera _ cameras at: cameras keysasSortedCollection first].	"Fetch the lights"	lights _ globals at: #lights.	"Add the ambient light if possible.	Note: The name $AMBIENT$ is used in the keyframe section of the 3DS	file. "	ambient _ constants at: 'ambientColor'				ifAbsent: [B3DColor4						r: 0.0						g: 0.0						b: 0.0						a: 0.0].	ambient ifNotNil: [lights at: '$AMBIENT$' put: (B3DAmbientLightcolor: ambient)].	"Fetch the background color"	clearColor _ constants at: 'backgroundColor' ifAbsent: [Color white].	"Fetch the materials and replace names in sceneObjects by actual	materials "	materials _ globals at: #materials.	"Compute the per vertex normals"	funkyNormals _ false.	'Computing vertex normals'		displayProgressAt: Sensor cursorPoint		from: 0		to: objects size		during: [:bar | objects				doWithIndex:					[:obj :index |					bar value: index.					obj material ifNotNil: [objmaterial: (materials at: obj material ifAbsent: [])].					funkyNormals						ifTrue: [obj geometrycomputeFunkyVertexNormals]						ifFalse: [obj geometryvertexNormals]]].	objects do: [:obj | obj texture ifNotNil: [obj texture: texture]]! !!B3DScene methodsFor: 'accessing' stamp: 'ti 3/21/2000 11:57'!cameras	^cameras! !!B3DScene class methodsFor: 'instance creation' stamp: 'ti 3/21/2000 15:05'!withoutQuestionsFrom3DS: aDictionary	^self new withoutQuestionsFrom3DS: aDictionary! !!B3DSceneExplorerMorph commentStamp: '<historical>' prior: 0!Main comment stating the purpose of this class and relevant relationship to other classes.Possible useful expressions for doIt or printIt.Structure: instVar1		type -- comment about the purpose of instVar1 instVar2		type -- comment about the purpose of instVar2Any further useful comments about the general approach of this implementation.!!B3DSceneExplorerMorph reorganize!('accessing' scene scene:)('actions' openThreeDSFile selectNewCamera selectNewCamera: switchRotationStatus updateSceneWithDefaults: updateUpVectorForCamera:)('change reporting' layoutChanged)('drawing' drawOn:)('event handling' handlesMouseDown: mouseDown:)('initialization' initialize)('menus' addCustomMenuItems: addCustomMenuItems:hand: rotationString yellowButtonMenu)('visual properties' defaultColor)!!B3DSceneExplorerMorph methodsFor: 'accessing' stamp: 'ti 3/24/2000 17:16'!scene	^b3DSceneMorph scene! !!B3DSceneExplorerMorph methodsFor: 'accessing' stamp: 'ti 3/24/2000 17:04'!scene: aScene	b3DSceneMorph scene: aScene.! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ti 3/21/2000 15:08'!openThreeDSFile	| menu result newFileString myScene |	menu := StandardFileMenu oldFileMenu: (FileDirectory default).	result := menu startUpWithCaption: 'Select 3DS model file ...'.	result ifNotNil: [			newFileString := (result directory pathName),(result directory pathNameDelimiter asString),(result name).		myScene := (B3DScene withoutQuestionsFrom3DS: (ThreeDSParser parseFileNamed: newFileString)).		myScene := self updateSceneWithDefaults: myScene.		self scene: myScene.		self updateUpVectorForCamera: self scene defaultCamera.].! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ti 3/21/2000 15:11'!selectNewCamera	| menu sel |	((self scene cameras isNil) or: [self scene cameras size = 0]) ifTrue: [		(SelectionMenu selections: #('OK'))			startUpWithCaption: 'No cameras defined!!'.		^self].	menu _ SelectionMenu		selections: self scene cameras keys asArray.	sel := menu startUp.	sel ifNotNil: [		self scene defaultCamera: (self scene cameras at: sel) copy.		self updateUpVectorForCamera: self scene defaultCamera.		self changed.]! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ti 3/21/2000 14:28'!selectNewCamera: aCameraString	aCameraString ifNotNil: [		self scene defaultCamera: (self scene cameras at: aCameraString) copy.		self updateUpVectorForCamera: self scene defaultCamera.		self changed.]! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ti 3/24/2000 17:04'!switchRotationStatus	b3DSceneMorph switchRotationStatus! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ti 3/24/2000 17:34'!updateSceneWithDefaults: myScene	| headLight mat |	myScene lights at: 'Ambient1' put: (B3DAmbientLight color: (Color gray: 0.2)).	headLight := B3DSpotLight new.	headLight position: myScene defaultCamera position.	headLight target: myScene defaultCamera target.	headLight lightColor: (B3DMaterialColor color: (Color gray: 0.7)).	headLight attenuation: (B3DLightAttenuation constant: 1.0 linear: 0.0 squared: 0.0).	headLight minAngle: 80.	headLight maxAngle: 90.	myScene lights at: '$HeadLight$' put: headLight copy.	mat := B3DMaterial new.	mat diffusePart: (Color gray: 0.25).	mat ambientPart: (Color gray: 0.01).	myScene objects do: [:o|		o material: mat].	^myScene! !!B3DSceneExplorerMorph methodsFor: 'actions' stamp: 'ti 3/21/2000 12:46'!updateUpVectorForCamera: aCamera	| oldUp |	oldUp := aCamera up.	aCamera up:		((aCamera direction cross: oldUp) cross: (aCamera direction))! !!B3DSceneExplorerMorph methodsFor: 'change reporting' stamp: 'ti 3/24/2000 17:11'!layoutChanged	| ctrl |	super layoutChanged.	b3DSceneMorph ifNil: [^self].	b3DSceneMorph extent: (self extent - ((frameWidth * 2)@(frameWidth * 2))).	b3DSceneMorph position: (self bounds origin + ((frameWidth)@(frameWidth))).	wheels ifNil: [^self].	wheels isEmpty ifTrue: [^self].	ctrl := wheels at: #fov ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			self bounds corner -				ctrl extent - 				(frameWidth@((frameWidth - ctrl extent y) / 2) rounded)].	ctrl := wheels at: #dolly ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			self bounds corner -				ctrl extent - 				((((frameWidth - ctrl extent x) / 2) rounded)@frameWidth)].	ctrl := wheels at: #rotX ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			(self bounds origin x + (((frameWidth - ctrl extent x) / 2) rounded))@(self bounds corner y - ctrl extent y - frameWidth)].	ctrl := wheels at: #rotY ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			(self bounds origin x + frameWidth)@(self bounds corner y - ctrl extent y - (((frameWidth - ctrl extent y) / 2) rounded))].	ctrl := wheels at: #rotZ ifAbsent: [nil].	ctrl ifNotNil: [		ctrl position:			self bounds origin +			((((frameWidth - ctrl extent x) / 2) rounded)@frameWidth)].! !!B3DSceneExplorerMorph methodsFor: 'drawing' stamp: 'ti 3/24/2000 17:27'!drawOn: aCanvas	super drawOn: aCanvas.	aCanvas fillRectangle: (self bounds insetBy: frameWidth) color: Color black.! !!B3DSceneExplorerMorph methodsFor: 'event handling' stamp: 'ti 3/24/2000 17:13'!handlesMouseDown: evt	^evt yellowButtonPressed! !!B3DSceneExplorerMorph methodsFor: 'event handling' stamp: 'ti 3/24/2000 17:14'!mouseDown: evt	evt yellowButtonPressed ifTrue: [		self yellowButtonMenu.		^super mouseDown: evt].! !!B3DSceneExplorerMorph methodsFor: 'initialization' stamp: 'ti 3/24/2000 17:23'!initialize	| ctrl |	super initialize.	self extent: 300@300.	self borderRaised.	color := Color gray: 0.8.	frameWidth := 25.	b3DSceneMorph := AdvancedB3DSceneMorph new.	self addMorphFront: b3DSceneMorph.		wheels := Dictionary new.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #addFovAngle:.	ctrl factor: -0.07.	ctrl setBalloonText: 'FOV'.	self addMorphFront: ctrl.	wheels at: #fov put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #addDolly:.	ctrl factor: 0.005.	ctrl beVertical.	ctrl setBalloonText: 'Dolly'.	self addMorphFront: ctrl.	wheels at: #dolly put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #rotateZ:.	ctrl beVertical.	ctrl setBalloonText: 'z Axis'.	self addMorphFront: ctrl.	wheels at: #rotZ put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #rotateY:.	ctrl setBalloonText: 'y Axis'.	self addMorphFront: ctrl.	wheels at: #rotY put: ctrl.	ctrl := WheelMorph new.	ctrl target: b3DSceneMorph.	ctrl actionSelector: #rotateX:.	ctrl beVertical.	ctrl setBalloonText: 'x Axis'.	self addMorphFront: ctrl.	wheels at: #rotX put: ctrl.! !!B3DSceneExplorerMorph methodsFor: 'menus' stamp: 'ti 3/22/2000 19:05'!addCustomMenuItems: aCustomMenu	(aCustomMenu isKindOf: MenuMorph)		ifTrue: [aCustomMenu addUpdating: #rotationString action: #switchRotationStatus]		ifFalse: [aCustomMenu add: 'swich rotation status' action: #switchRotationStatus].	aCustomMenu add: 'open 3DS file' action: #openThreeDSFile.	aCustomMenu add: 'select new camera' action: #selectNewCamera.! !!B3DSceneExplorerMorph methodsFor: 'menus' stamp: 'ti 3/22/2000 18:51'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self addCustomMenuItems: aCustomMenu.! !!B3DSceneExplorerMorph methodsFor: 'menus' stamp: 'ti 3/24/2000 17:04'!rotationString	^b3DSceneMorph isRotating		ifTrue: ['stop rotating']		ifFalse: ['start rotating']! !!B3DSceneExplorerMorph methodsFor: 'menus' stamp: 'ti 3/22/2000 18:57'!yellowButtonMenu	| menu sel |	menu _ CustomMenu new.	menu title: self class name.	self addCustomMenuItems: menu.	sel := menu startUp.	sel ifNotNil: [self perform: sel]! !!B3DSceneExplorerMorph methodsFor: 'visual properties' stamp: 'ti 3/21/2000 14:45'!defaultColor	^Color gray! !!WheelMorph reorganize!('accessing' actionSelector actionSelector: angle angle: factor factor: maxAngle maxAngle: target target:)('drawing' drawOn:)('event handling' doTargetAction: handlesMouseDown: mouseDown: mouseMove:)('initialization' initialize)('private' addAngle:)('properties' beCircular beHorizontal beLinear beVertical isCircular isHorizontal isLinear isVertical)!!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:56'!actionSelector	^ actionSelector! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:57'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:32'!angle	^angle! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:33'!angle: aNumber	angle := aNumber! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 17:02'!factor	^factor! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 17:03'!factor: aFloat	factor := aFloat! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:35'!maxAngle	^maxAngle! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/19/2000 11:35'!maxAngle: aNumber	maxAngle := aNumber! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:47'!target	^target! !!WheelMorph methodsFor: 'accessing' stamp: 'ti 3/13/2000 12:48'!target: aTargetObject	target := aTargetObject! !!WheelMorph methodsFor: 'drawing' stamp: 'bf 3/24/2000 10:55'!drawOn: aCanvas	| interval delta frame x0 x1 y0 y1 deltaX deltaY  hilitColor shadowColor |	super drawOn: aCanvas.		"border & background"	borderColor isColor		ifTrue: [hilitColor _ shadowColor _ borderColor]		ifFalse: [hilitColor := color lighter lighter.			shadowColor := color darker darker].	frame := self innerBounds insetBy: 2.	aCanvas frameAndFillRectangle: frame fillColor: color		borderWidth: 1 topLeftColor: hilitColor bottomRightColor: shadowColor.	frame _ frame insetBy: (borderColor isColor ifTrue: [1] ifFalse: [2]).	x0 := frame origin x.	x1 := frame corner x.	y0 := frame origin y.	y1 := frame corner y.	deltaX := (x1 - x0) / 2.	deltaY := (y1 - y0) / 2.	interval := 10.	delta := self angle \\ interval.	1 to: (self maxAngle / (2 * interval)) rounded do: [ :i |		| x y |		self isHorizontal ifTrue: [			x := x0 + deltaX - (((i * interval + delta) * (2 * Float pi / 360.0)) cos * deltaX).			aCanvas fillRectangle: (Rectangle origin: (x-1)@y0 corner: x@y1) color: hilitColor.			borderColor isColor ifFalse:				 [aCanvas fillRectangle: (Rectangle origin: x@y0 corner: (x+1)@y1) color: shadowColor]]		ifFalse: [			y := y0 + deltaY - (((i * interval + delta) * (2 * Float pi / 360.0)) cos * deltaY).			aCanvas fillRectangle: (Rectangle origin: x0@(y-1) corner: x1@y) color: hilitColor.			borderColor isColor ifFalse:				 [aCanvas fillRectangle: (Rectangle origin: x0@y corner: x1@(y+1)) color: shadowColor]]]! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/19/2000 17:03'!doTargetAction: cursorPoint	| new delta |	self isHorizontal		ifTrue: [new := cursorPoint x]		ifFalse: [new := cursorPoint y].	delta := new - old.	delta isZero ifTrue: [^self].	self addAngle: delta.	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: (Array with: (delta * self factor))]].	old := new.! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/19/2000 14:50'!handlesMouseDown: evt	^true! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/14/2000 18:09'!mouseDown: evt	self isHorizontal		ifTrue: [old := evt cursorPoint x]		ifFalse: [old := evt cursorPoint y].! !!WheelMorph methodsFor: 'event handling' stamp: 'ti 3/19/2000 14:51'!mouseMove: evt	(evt anyButtonPressed)		ifTrue: [self doTargetAction: evt cursorPoint]! !!WheelMorph methodsFor: 'initialization' stamp: 'ti 3/23/2000 11:52'!initialize	super initialize.	self target: nil.	self actionSelector: #flash.	self angle: 0.	self maxAngle: 360.	self factor: 1.0.	self extent: 100@18.	self beCircular.	self borderColor: #raised.	self borderWidth: 1.	self color: Color lightGray.	lastRedraw := 0.! !!WheelMorph methodsFor: 'private' stamp: 'ti 3/20/2000 15:58'!addAngle: aNumber	| new |	new := self angle + aNumber.	self isCircular ifTrue: [new := new \\ self maxAngle].	self angle: new.	lastRedraw := lastRedraw + aNumber.	(lastRedraw abs > 2) ifTrue: [		lastRedraw := 0.		self changed]! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:18'!beCircular	circular := true! !!WheelMorph methodsFor: 'properties' stamp: 'bf 3/23/2000 18:34'!beHorizontal	self isHorizontal		ifFalse: [self extent: self extent transposed] ! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:19'!beLinear	circular := false! !!WheelMorph methodsFor: 'properties' stamp: 'bf 3/23/2000 18:34'!beVertical	self isHorizontal		ifTrue: [self extent: self extent transposed] ! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:19'!isCircular	^circular! !!WheelMorph methodsFor: 'properties' stamp: 'bf 3/23/2000 18:26'!isHorizontal	^ bounds isWide! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/20/2000 13:19'!isLinear	^circular not! !!WheelMorph methodsFor: 'properties' stamp: 'ti 3/22/2000 19:12'!isVertical	^self isHorizontal not! !!WheelMorph class methodsFor: 'examples' stamp: 'ti 3/24/2000 17:33'!example	"See B3DSceneExplorerMorph>>initialize for usage."	"WheelMorph example"	B3DSceneExplorerMorph new openInWorld! !