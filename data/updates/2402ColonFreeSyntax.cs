'From Squeak2.8alpha of 12 January 2000 [latest update: #2204] on 2 June 2000 at 11:38:28 am'!"Change Set:		ColonFreeSyntaxDate:			5 June 2000Author:			Dan IngallsThis changeSet allows Squeak to read and display a new syntax in all browsers, while retaining full ST-80 compatibility in the sources file and other fileOuts.The printAlternateSyntax preference is coopted to enable or disable this capability.A new parser, DialectParser (see its class comment) is used to parse the new syntax, and a new printStream, DialectStream is used to print the new syntax.  While it might have been better to duplicate the entire parseNode hierarchy, the current hierarchy is maintained and each print method tests its printStream for which dialect to print.FileIn this file, and set the printAlternateSyntax preference to try it out.Please note that this syntax does NOT necessarily embody the ideals of the author.  It DOES, however, eliminate several sources of unfamiliar punctuation, and it ALSO suggests a system for presenting and accepting an alternative syntax while leaving fileOuts and the changes file in Smalltalk-80 format."!TextStream subclass: #DialectStream	instanceVariableNames: 'dialect '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!MethodNode subclass: #DialectMethodNode	instanceVariableNames: 'dialect '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!DialectMethodNode commentStamp: '<historical>' prior: 0!The purpose of this class is to carry along with theinformation in a regular method node the further information that it was parsed from an laternate dialect of Squeak.  Which dialect that was is carried as a symbol in the dialect variable.!Parser subclass: #DialectParser	instanceVariableNames: 'dialect '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!CompiledMethod methodsFor: 'comparing' stamp: 'di 4/24/2000 11:47'!= method	| myLits otherLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(myLits _ self literals) = (otherLits _ method literals) ifFalse:		[myLits size = otherLits size ifFalse: [^ false].		"Dont bother checking FFI and named primitives"		(#(117 120) includes: self primitive) ifTrue: [^ true].		"Might be a minor mismatch of Floats"		myLits with: otherLits do:			[:lit :other | lit isNumber				ifTrue: [(lit closeTo: other) ifFalse: [^ false]]				ifFalse: [(lit = other) ifFalse: [^ false]]]].	^ true! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 5/30/2000 21:26'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString  st80str |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	Smalltalk assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	(methodNode isKindOf: DialectMethodNode)		ifTrue:		["This source was parsed from an alternate syntax.		We must convert to ST80 before logging it."		st80str _ (DialectStream dialect: #ST80 contents: [:strm | methodNode printOn: strm])						asString.		remoteString _ RemoteString newString: st80str						onFileNumber: fileIndex toFile: file]		ifFalse:		[remoteString _ RemoteString newString: sourceStr						onFileNumber: fileIndex toFile: file].	file nextChunkPut: ' '; flush.	self checkOKToAdd: sourceStr size at: remoteString position.	self setSourcePosition: remoteString position inFile: fileIndex! !!Compiler methodsFor: 'public access' stamp: 'di 4/5/2000 09:48'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileText]! !!Compiler methodsFor: 'public access' stamp: 'di 4/24/2000 07:46'!parse: textOrStream in: aClass notifying: req	"Compile the argument, textOrStream, with respect to the class, aClass, 	and answer the MethodNode that is the root of the resulting parse tree. 	Notify the argument, req, if an error occurs. The failBlock is defaulted to 	an empty block."	^ self parse: textOrStream in: aClass notifying: req dialect: false! !!Compiler methodsFor: 'public access' stamp: 'di 4/24/2000 07:45'!parse: textOrStream in: aClass notifying: req dialect: useDialect	"Compile the argument, textOrStream, with respect to the class, aClass, 	and answer the MethodNode that is the root of the resulting parse tree. 	Notify the argument, req, if an error occurs. The failBlock is defaulted to 	an empty block."	self from: textOrStream class: aClass context: nil notifying: req.	^ ((useDialect and: [Preferences printAlternateSyntax])		ifTrue: [DialectParser]		ifFalse: [Parser]) new			parse: sourceStream			class: class			noPattern: false			context: context			notifying: requestor			ifFail: []! !!Debugger methodsFor: 'code pane' stamp: 'di 4/24/2000 07:49'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i methodNode pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[methodNode _ self selectedClass compilerClass new			parse: contents in: self selectedClass			notifying: nil dialect: true.		sourceMap _ methodNode sourceMap.		tempNames _ methodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	sourceMap size = 0 ifTrue: [^1 to: 0].	pc_ self selectedContext pc -		((externalInterrupt and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!DialectStream methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 08:48'!dialect	^ dialect! !!DialectStream methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 08:48'!setDialect: dialectSymbol	dialect _ dialectSymbol! !!DialectStream methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 15:36'!withColor: colorSymbol emphasis: emphasisSymbol do: aBlock	^ self withAttributes: {TextColor color: (Color perform: colorSymbol).							TextEmphasis perform: emphasisSymbol}		do: aBlock! !!DialectStream methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 15:47'!withStyleFor: elementType do: aBlock"	true ifTrue:		[^ self withAttributes: (Preferences syntaxAttributesFor: elementType) do: aBlock]."	"Here's a direct implementation without all the preferences stuff."	elementType == #temporaryVariable ifTrue:		[^ self withColor: #magenta emphasis: #bold do: aBlock].	elementType == #methodArgument ifTrue:		[^ self withColor: #magenta emphasis: #italic do: aBlock].	elementType == #blockArgument ifTrue:		[^ self withColor: #magenta emphasis: #italic do: aBlock].	elementType == #comment ifTrue:		[^ self withColor: #red emphasis: #normal do: aBlock].	elementType == #variable ifTrue:		[^ self withColor: #blue emphasis: #bold do: aBlock].	elementType == #literal	 ifTrue:		[^ self withColor: #brown emphasis: #normal do: aBlock].	elementType == #keyword ifTrue:		[^ self withColor: #black emphasis: #normal do: aBlock].! !!DialectStream class methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 09:49'!dialect: dialectSymbol contents: blockWithArg 	| stream |	stream _ self on: (Text new: 400).	stream setDialect: dialectSymbol.	blockWithArg value: stream.	^ stream contents! !!ParseNode methodsFor: 'testing' stamp: 'di 4/5/2000 11:14'!isLiteral	^ false! !!ParseNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^ self].	aStream withStyleFor: #comment		do: [1 to: comment size do: 				[:index | 				index > 1 ifTrue: [aStream crtab: indent].				aStream nextPut: $".				thisComment _ comment at: index.				self printSingleComment: thisComment					on: aStream					indent: indent.				aStream nextPut: $"]].	comment _ nil! !!ParseNode methodsFor: 'printing' stamp: 'di 4/19/2000 11:58'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: '{'.	aStream nextPutAll: ((DialectStream dialect: #ST80								contents: [:strm | self printOn: strm indent: 0])							asString).	aStream nextPutAll: '}'! !!AssignmentNode methodsFor: 'printing' stamp: 'di 4/23/2000 22:20'!printOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: [aStream nextPutAll: 'set '.				variable printOn: aStream indent: level.				aStream nextPutAll: ' to '.				value printOn: aStream indent: level + 2]		ifFalse: [variable printOn: aStream indent: level.				aStream nextPutAll: ' _ '.				value printOn: aStream indent: level + 2]! !!AssignmentNode methodsFor: 'printing' stamp: 'di 4/25/2000 13:52'!printOn: aStream indent: level precedence: p	(aStream dialect = #SQ00			ifTrue: [p < 3]			ifFalse: [p < 4])		ifTrue: [aStream nextPutAll: '('.				self printOn: aStream indent: level.				aStream nextPutAll: ')']		ifFalse: [self printOn: aStream indent: level]! !!BlockNode methodsFor: 'printing' stamp: 'di 4/24/2000 08:44'!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	arguments do: 		[:arg | 		aStream dialect = #SQ00			ifTrue: [aStream nextPutAll: 'set '.					aStream withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key].					aStream nextPutAll: '. ']			ifFalse: [aStream nextPutAll: ':'.					aStream withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key].					aStream space]].	aStream dialect = #SQ00 ifFalse: [aStream nextPutAll: '| '].	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue: [aStream crtab: level]! !!BlockNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:49'!printOn: aStream indent: level	"statements size <= 1 ifFalse: [aStream crtab: level]."	aStream nextPut: $[.	self printArgumentsOn: aStream indent: level.	self printTemporariesOn: aStream indent: level.	self printStatementsOn: aStream indent: level.	aStream nextPut: $]! !!BlockNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:09'!printTemporariesOn: aStream indent: level	(temporaries == nil or: [temporaries size = 0])		ifFalse: 			[aStream nextPut: $|.			temporaries do: 				[:arg | 				aStream					space;					withStyleFor: #temporaryVariable						do: [aStream nextPutAll: arg key]].			aStream nextPutAll: ' | '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!CascadeNode methodsFor: 'printing' stamp: 'di 4/25/2000 19:17'!printOn: aStream indent: level precedence: p 	p > 0 ifTrue: [aStream nextPut: $(].	messages first printReceiver: receiver on: aStream indent: level.	1 to: messages size do: 		[:i | (messages at: i) printOn: aStream indent: level.		i < messages size ifTrue: 				[aStream nextPut: $;.				messages first precedence >= 2 ifTrue: [aStream crtab: level + 1]]].	p > 0 ifTrue: [aStream nextPut: $)]! !!LiteralNode methodsFor: 'testing' stamp: 'di 4/5/2000 11:13'!isLiteral	^ true! !!LiteralNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:10'!printOn: aStream indent: level	(key isMemberOf: Association)		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###';					 	nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##';						nextPutAll: key key]]		ifFalse:			[aStream withStyleFor: #literal					do: [key storeOn: aStream]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 6/2/2000 09:48'!noteSpecialSelector: selectorSymbol	" special > 0 flags specially treated messages. "	"Deconvert initial keywords from SQ2K"	(special _ #(:test:ifTrue: :test:ifFalse: :test:ifTrue:ifFalse: :test:ifFalse:ifTrue:) 					indexOf: selectorSymbol) > 0		ifTrue: [^ self].	special _ MacroSelectors indexOf: selectorSymbol.! !!MessageNode methodsFor: 'printing' stamp: 'di 4/24/2000 10:32'!printCaseOn: aStream indent: level 	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode _ arguments first.	otherwise _ arguments last.	(arguments size = 1 or: [otherwise isJustCaseError])		ifTrue: [otherwise _ nil].	receiver		printOn: aStream		indent: level		precedence: 3.	aStream dialect = #SQ00 ifTrue: [aStream nextPutAll: ' caseOf (']		ifFalse: [aStream nextPutAll: ' caseOf: '].	braceNode isVariableReference ifTrue: [braceNode printOn: aStream indent: level]		ifFalse: 			[aStream nextPutAll: '{';				 crtab: level + 1.			braceNode				casesForwardDo: 					[:keyNode :valueNode :last | 					keyNode printOn: aStream indent: level + 1.					aStream nextPutAll: ' -> '.					valueNode isComplex						ifTrue: 							[aStream crtab: level + 2.							extra _ 1]						ifFalse: [extra _ 0].					valueNode printOn: aStream indent: level + 1 + extra.					last ifTrue: [aStream nextPut: $}]						ifFalse: [aStream nextPut: $.;								 crtab: level + 1]]].	aStream dialect = #SQ00 ifTrue: [aStream nextPutAll: ')'].	otherwise isNil		ifFalse: 			[aStream dialect = #SQ00 ifTrue: [aStream crtab: level + 1;					 nextPutAll: ' otherwise (']				ifFalse: [aStream crtab: level + 1;						 nextPutAll: ' otherwise: '].			otherwise isComplex				ifTrue: 					[aStream crtab: level + 2.					extra _ 1]				ifFalse: [extra _ 0].			otherwise printOn: aStream indent: level + 1 + extra.			aStream dialect = #SQ00 ifTrue: [aStream nextPutAll: ')']]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:20'!printIfNil: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:20'!printIfNilNotNil: aStream indent: level	self printReceiver: receiver ifNilReceiver on: aStream indent: level.	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^ self printKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 5/31/2000 23:11'!printIfOn: aStream indent: level	aStream dialect = #SQ00 ifTrue:		["Convert to if-then-else"		(arguments last isJust: NodeNil) ifTrue:			[aStream nextPutAll: 'test '.			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments last isJust: NodeFalse) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #and: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments first isJust: NodeNil) ifTrue:			[aStream nextPutAll: 'test '.			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)						on: aStream indent: level].		(arguments first isJust: NodeTrue) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #or: arguments: (Array with: arguments last)						on: aStream indent: level].		aStream nextPutAll: 'test '.		self printParenReceiver: receiver on: aStream indent: level + 1.		^ self printKeywords: #ifTrue:ifFalse: arguments: arguments						on: aStream indent: level].	receiver printOn: aStream indent: level + 1 precedence: precedence.	(arguments last isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^ self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^ self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 6/2/2000 10:11'!printKeywords: key arguments: args on: aStream indent: level	| keywords indent noColons arg kwd hasBrackets doCrTab |	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	noColons _ aStream dialect = #SQ00 and: [keywords first endsWith: ':'].	doCrTab _ args size > 2 or:		[{receiver} , args			inject: false			into: [:was :thisArg |				was or: [(thisArg isKindOf: BlockNode)					or: [(thisArg isKindOf: MessageNode) and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do:		[:i | arg _ args at: i.  kwd _ keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		noColons			ifTrue: [aStream nextPutAll: kwd allButLast; space.					hasBrackets _ (arg isKindOf: BlockNode) or: [arg isKindOf: BlockNode].					hasBrackets ifFalse: [aStream nextPutAll: '(']]			ifFalse: [aStream nextPutAll: kwd; space].		arg printOn: aStream indent: level + 1 + indent			 	precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		noColons			ifTrue: [hasBrackets ifFalse: [aStream nextPutAll: ')']]]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/2/2000 09:46'!printOn: aStream indent: level	| printer leadingKeyword |	special > 0 ifTrue: [printer _ MacroPrinters at: special].	(special > 0)		ifTrue: [self perform: printer with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [leadingKeyword _ selector key keywords first.						aStream nextPutAll: leadingKeyword; space.						self printReceiver: receiver on: aStream indent: level.						self printKeywords: (selector key allButFirst: leadingKeyword size + 1) arguments: arguments							on: aStream indent: level]				ifFalse: [self printReceiver: receiver on: aStream indent: level.						self printKeywords: selector key arguments: arguments							on: aStream indent: level]]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/30/2000 23:17'!printOn: strm indent: level precedence: outerPrecedence	| parenthesize |	parenthesize _ precedence > outerPrecedence		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].	parenthesize		ifTrue: [strm nextPutAll: '('.				self printOn: strm indent: level.				strm nextPutAll: ')']		ifFalse: [self printOn: strm indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/31/2000 23:10'!printParenReceiver: rcvr on: aStream indent: level						aStream nextPutAll: '('.	rcvr printOn: aStream indent: level.	aStream nextPutAll: ')'! !!MessageNode methodsFor: 'printing' stamp: 'di 5/30/2000 23:06'!printReceiver: rcvr on: aStream indent: level						rcvr ifNil: [^ self].	"Force parens around keyword receiver of kwd message"	(precedence = 3 and: [aStream dialect = #SQ00])		ifTrue: [rcvr printOn: aStream indent: level precedence: precedence - 1]		ifFalse: [rcvr printOn: aStream indent: level precedence: precedence]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:19'!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'di 5/1/2000 23:19'!printWhileOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	(arguments first isJust: NodeNil) ifTrue:			[selector _ SelectorNode new					key: (selector key == #whileTrue:						ifTrue: [#whileTrue] ifFalse: [#whileFalse])					code: #macro.			arguments _ Array new].	^ self 		printKeywords: selector key		arguments: arguments		on: aStream		indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 5/2/2000 00:16'!test	3 > 4 ifTrue: [4+5 between: 6 and: 7]			ifFalse: [4 between: 6+5 and: 7-2]! !!MethodNode methodsFor: 'converting' stamp: 'di 4/13/2000 21:09'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ (DialectStream dialect: #ST80 contents: [:strm | self printOn: strm])		asString! !!MethodNode methodsFor: 'converting' stamp: 'di 4/5/2000 10:07'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ DialectStream		dialect: (Preferences printAlternateSyntax ifTrue: [#SQ00] ifFalse: [#ST80])		contents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'printing' stamp: 'di 6/1/2000 14:02'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream nextPutAll: kwd allButLast; nextPutAll: ' (']					ifFalse: [aStream nextPutAll: kwd; space].				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream nextPutAll: ') ']					ifFalse: [aStream space]]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	(temporaries size > 0 or: [aStream dialect == #SQ00]) ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | 						aStream nextPutAll: temp key.						aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!DialectMethodNode methodsFor: 'as yet unclassified' stamp: 'di 4/13/2000 20:46'!setDialect: dialectSymbol	dialect _ dialectSymbol! !!DialectMethodNode methodsFor: 'as yet unclassified' stamp: 'di 4/13/2000 21:31'!test: arg1 with: arg2 	^ 3 between: arg1 and: arg2! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'di 4/5/2000 08:36'!browseWithPrettyPrint	^ self printAlternateSyntax or: [self valueOfFlag: #browseWithPrettyPrint]! !!Scanner methodsFor: 'expression types' stamp: 'di 4/23/2000 22:15'!checkpoint	"Return a copy of all changeable state.  See revertToCheckpoint:"	^ {self clone. source clone. currentComment copy}! !!Scanner methodsFor: 'expression types' stamp: 'di 4/23/2000 22:11'!revertToCheckpoint: checkpoint	"Revert to the state when checkpoint was made."	| myCopy |	myCopy _ checkpoint first.	1 to: self class instSize do:		[:i | self instVarAt: i put: (myCopy instVarAt: i)].	source _ checkpoint second.	currentComment _ checkpoint third! !!Scanner methodsFor: 'expression types' stamp: 'di 6/2/2000 08:41'!scanLitVec	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanLitVec]				ifFalse: 					[tokenType = #word | (tokenType = #keyword) | (tokenType = #colon)						ifTrue: 							[self scanLitWord]						ifFalse:							[(token == #- 									and: [(typeTable at: hereChar asciiValue) = #xDigit])								ifTrue: 									[self scanToken.									token _ token negated]]].			s nextPut: token.			self scanToken].	token _ s contents! !!Scanner methodsFor: 'multi-character scans' stamp: 'di 4/22/2000 16:36'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type == #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			["Allow any number of embedded colons in literal symbols"			(typeTable at: hereChar asciiValue) == #xColon]				whileTrue: [buffer nextPut: self step].			tokenType _ #keyword]		ifFalse: 			[tokenType _ #word].	token _ buffer contents! !!Parser methodsFor: 'public access' stamp: 'di 4/5/2000 17:00'!parseArgsAndTemps: aString notifying: req 	"Parse the argument, aString, notifying req if an error occurs. Otherwise, 	answer a two-element Array containing Arrays of strings (the argument 	names and temporary variable names)."	(req notNil and: [Preferences printAlternateSyntax]) ifTrue:		[^ (self as: DialectParser) parseArgsAndTemps: aString notifying: req].	aString == nil ifTrue: [^#()].	doitFlag _ false.		"Don't really know if a doit or not!!"	^self initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2) , self temporaries]! !!Parser methodsFor: 'expression types' stamp: 'di 4/5/2000 08:27'!keylessMessagePartTest: level repeat: repeat! !!Parser methodsFor: 'expression types'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [hereType == #word						ifTrue: 							[start _ self startOfNextToken.							selector _ self advance.							args _ #().							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'expression types' stamp: 'di 5/30/2000 22:06'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	encoder _ encoderToUse.	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	prim _ doit ifTrue: [0] ifFalse: [self primitive].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim! !!Parser methodsFor: 'expression types' stamp: 'di 5/30/2000 21:59'!newMethodNode	^ MethodNode new! !!Parser methodsFor: 'expression types' stamp: 'di 4/5/2000 16:52'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[selector nextPutAll: self advance.					args addLast: (encoder bindArg: self argumentName)].			^ {selector contents asSymbol. args. 3}].	^ self expected: 'Message pattern'! !!Parser methodsFor: 'scanning' stamp: 'di 4/18/2000 13:26'!endOfLastToken	^ prevMark + prevToken - 1! !!Parser methodsFor: 'error handling' stamp: 'di 4/24/2000 14:35'!expected: aString 	"Notify a problem at token 'here'."	tokenType == #doIt ifTrue: [hereMark _ hereMark + 1].	hereType == #doIt ifTrue: [hereMark _ hereMark + 1].	^ self notify: aString , ' expected' at: hereMark + requestorOffset! !!Parser methodsFor: 'public access' stamp: 'di 5/30/2000 22:08'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of 	a parse tree. Parsing is done with respect to the argument, class, to find 	instance, class, and pool variables; and with respect to the argument, 	ctxt, to find temporary variables. Errors in parsing are reported to the 	argument, req, if not nil; otherwise aBlock is evaluated. The argument 	noPattern is a Boolean that is true if the the sourceStream does not 	contain a method header (i.e., for DoIts)."	 | meth repeatNeeded myStream parser |	(req notNil and: [Preferences printAlternateSyntax])		ifTrue: [parser _ self as: DialectParser]		ifFalse: [parser _ self].	myStream _ sourceStream.	[repeatNeeded _ false.	parser init: myStream notifying: req failBlock: [^ aBlock value].	doitFlag _ noPattern.	failBlock_ aBlock.	[meth _ parser method: noPattern context: ctxt				encoder: (Encoder new init: class context: ctxt notifying: parser)] 		on: ParserRemovedUnusedTemps 		do: 			[repeatNeeded _ true.			myStream _ ReadStream on: requestor text string].	repeatNeeded] whileTrue.	encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	^ meth! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/23/2000 22:18'!assignment: varNode	" 'set' (var) 'to' (expression) => AssignmentNode."	| loc |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	varNode nowHasDef.	self advance.  " to "	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ AssignmentNode new				variable: varNode				value: parseNode				from: encoder.	^ true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/23/2000 23:31'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables checkpoint |	variableNodes _ OrderedCollection new.	"Gather parameters."	[checkpoint _ self checkpoint.	(self matchToken: 'set')		and: [tokenType == #period				ifTrue: [true]				ifFalse: [self revertToCheckpoint: checkpoint. false]]]		whileTrue: [variableNodes addLast: (encoder autoBind: self argumentName).					(self match: #period) ifFalse: [^ self expected: 'Period']].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^ self expected: 'Period or right bracket'].	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/22/2000 17:11'!expression	^ self expressionWithInitialKeyword: ''! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 5/31/2000 12:03'!expressionWithInitialKeyword: kwdIfAny	| checkpoint |	(hereType == #word and: [here = 'set' and: [tokenType == #word]]) ifTrue:			["Parse assignment statement 'set' var 'to' expression"			checkpoint _ self checkpoint.			self advance.			token = 'to'				ifTrue: [^ self assignment: self variable]				ifFalse: [self revertToCheckpoint: checkpoint]].	(hereType == #word and: [tokenType == #leftParenthesis])		ifTrue: ["It's an initial keyword."				kwdIfAny isEmpty ifFalse: [self error: 'compiler logic error'].				^ self expressionWithInitialKeyword: ':' , self advance , ':'].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true initialKeyword: kwdIfAny)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/25/2000 22:36'!matchKeyword	"Return true if we are looking at a keyword (and its argument)."	hereType == #word ifFalse: [^ false].	tokenType == #leftParenthesis ifTrue: [^ true].	tokenType == #leftBracket ifTrue: [^ true].	tokenType == #leftBrace ifTrue: [^ true].	^ false! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/22/2000 16:56'!messagePart: level repeat: repeat	^ self messagePart: level repeat: repeat initialKeyword: ''! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/25/2000 22:46'!messagePart: level repeat: repeat initialKeyword: kwdIfAny	| start receiver selector args precedence words keywordStart |	[receiver _ parseNode.	(self matchKeyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			selector nextPutAll: kwdIfAny.			args _ OrderedCollection new.			words _ OrderedCollection new.			[self matchKeyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance , ':'.					words addLast: (keywordStart to: hereMark + self previousTokenSize + requestorOffset).					self primaryExpression ifFalse: [^ self expected: 'Argument'].					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [(hereType == #word							and: [(#(leftParenthesis leftBracket leftBrace) includes: tokenType) not])						ifTrue: 							[start _ self startOfNextToken.							selector _ self advance.							args _ #().							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 5/30/2000 22:01'!newMethodNode	^ DialectMethodNode new setDialect: #SQ00! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 4/5/2000 17:02'!parseArgsAndTemps: aString notifying: req 	"Parse the argument, aString, notifying req if an error occurs. Otherwise, 	answer a two-element Array containing Arrays of strings (the argument 	names and temporary variable names)."	aString == nil ifTrue: [^#()].	doitFlag _ false.		"Don't really know if a doit or not!!"	^self initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2) , self temporaries]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/1/2000 07:41'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector checkpoint |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	"NOTE: there is now an ambiguity between	keywordSelector (argName)	and	unarySelector (first expression).	We do our best here."	(hereType == #word and: [tokenType == #leftParenthesis]) ifTrue:		[checkpoint _ self checkpoint.  "in case we have to back out"		selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #word and: [tokenType == #leftParenthesis]]				whileTrue: 					[selector nextPutAll: self advance , ':'.  "selector part"					self advance.  "open paren"					(args size = 0 and: [tokenType ~~ #rightParenthesis]) ifTrue:						["This is really a unary selector on a method that						begins with a parenthesized expression.  Back out now"						self revertToCheckpoint: checkpoint.						^ {self advance asSymbol. {}. 1}].					args addLast: (encoder bindArg: self argumentName).			(self match: #rightParenthesis)						ifFalse: [^ self expected: 'right parenthesis']].			^ {selector contents asSymbol. args. 3}].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	^ self expected: 'Message pattern'! !!SelectorNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printOn: aStream indent: level 	"nb: this method is seemingly never reached"	aStream withStyleFor: #keyword		do: [aStream nextPutAll: key]! !!String methodsFor: 'converting' stamp: 'di 4/22/2000 16:05'!keywords	"Answer an array of the keywords that compose the receiver."	| kwd char keywords |	keywords _ Array streamContents:		[:kwds | kwd _ WriteStream on: (String new: 16).		1 to: self size do:			[:i |			kwd nextPut: (char _ self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		kwd isEmpty ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords _ keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords _ keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'system primitives' stamp: 'di 4/22/2000 12:36'!numArgs	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess |	firstChar _ self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		[firstChar isUppercase ifTrue: [ ^ -1 ].		numColons _ 0. 		self do: [ :ch |			ch tokenish ifFalse: [ ^ -1 ].			(ch = $:) ifTrue: [numColons _ numColons + 1] ].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess _ 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess _ 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!VariableNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printOn: aStream indent: level 	aStream withStyleFor: #variable		do: [aStream nextPutAll: name].! !!TempVariableNode methodsFor: 'printing' stamp: 'di 4/5/2000 15:11'!printOn: aStream indent: level 	aStream withStyleFor: #temporaryVariable			do: [aStream nextPutAll: name]! !DialectParser removeSelector: #method:context:!DialectParser removeSelector: #parse:class:noPattern:context:notifying:ifFail:!Parser removeSelector: #method:context:!!DialectParser commentStamp: 'di 6/7/2000 11:10' prior: 0!This Parser is part of a package designed to allow for experiments with alternatives to ST-80 syntax.  The particular alternative offered by this parser eliminates colons, left-arrows and up-arrows, and adds prefix keywords for common control constructs.ST-80									SQ-00-------									-------a + b between: c and: c + 4				a + b between (c) and (c + 4)a _ 3.0									Set a to 3.0^ self size + 3							Return self size + 3a > b									Test (a > b)	ifTrue: ['greater']						ifTrue ['greater']	ifFalse: ['less']							ifFalse ['less']1 to: 9 do:								Repeat (1) to (9) do	[:i | Transcript cr; show: i]				[Set i. | Transcript cr; show (i)]The use of prefix keywords is currently ad-hoc;  in other words they are built into the parser, and there is not a way to define a method pattern to include a prefix keyword.  Most of the work has been done to support this, though, as selectors can now have the form	#:prefix:kwd1:kwd2:and they will respond appropriately to #keywords and #numArgs.A test method in the class ensures that every method in the system can be pretty-printed in the alternative syntax, and that compiling the resulting text produces exactly the same bytecodes as the original method.!!AssignmentNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:32'!printOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Set '].				variable printOn: aStream indent: level.				aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: ' to '].				value printOn: aStream indent: level + 2]		ifFalse: [variable printOn: aStream indent: level.				aStream nextPutAll: ' _ '.				value printOn: aStream indent: level + 2]! !!BlockNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:24'!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	arguments do: 		[:arg | 		aStream dialect = #SQ00			ifTrue: [aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Set '].					aStream withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key].					aStream nextPutAll: '. ']			ifFalse: [aStream nextPutAll: ':'.					aStream withStyleFor: #blockArgument						do: [aStream nextPutAll: arg key].					aStream space]].	aStream dialect = #SQ00 ifFalse: [aStream nextPutAll: '| '].	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue: [aStream crtab: level]! !!CompiledMethod methodsFor: 'comparing' stamp: 'di 6/6/2000 17:53'!= method	| myLits otherLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(myLits _ self literals) = (otherLits _ method literals) ifFalse:		[myLits size = otherLits size ifFalse: [^ false].		"Dont bother checking FFI and named primitives"		(#(117 120) includes: self primitive) ifTrue: [^ true].		myLits with: otherLits do:			[:lit1 :lit2 | lit1 = lit2 ifFalse:			[(lit1 isMemberOf: Association)			ifTrue:				["Associations match if value is equal, since associations				used for super may have key = nil or name of class."				lit1 value == lit2 value ifFalse: [^ false]]			ifFalse:				[(lit1 isMemberOf: Float)				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^ false]]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]].	^ true! !!Compiler methodsFor: 'public access' stamp: 'sw 11/7/1999 00:11'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileString]! !!DialectStream methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 10:46'!withStyleFor: elementType do: aBlock	"For each element type, associate a color and emphasis"	elementType == #temporaryVariable ifTrue:		[^ self withColor: #magenta emphasis: #bold do: aBlock].	elementType == #methodArgument ifTrue:		[^ self withColor: #magenta emphasis: #italic do: aBlock].	elementType == #blockArgument ifTrue:		[^ self withColor: #magenta emphasis: #italic do: aBlock].	elementType == #comment ifTrue:		[^ self withColor: #red emphasis: #normal do: aBlock].	elementType == #variable ifTrue:		[^ self withColor: #blue emphasis: #bold do: aBlock].	elementType == #literal	 ifTrue:		[^ self withColor: #brown emphasis: #normal do: aBlock].	elementType == #keyword ifTrue:		[^ self withColor: #black emphasis: #bold do: aBlock].	elementType == #prefixKeyword ifTrue:		[^ self withColor: #black emphasis: #bold do: aBlock].	elementType == #setOrReturn ifTrue:		[^ self withColor: #black emphasis: #bold do: aBlock].	^ self withColor: #black emphasis: #normal do: aBlock! !!MessageNode methodsFor: 'initialize-release' stamp: 'di 6/6/2000 23:24'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selNode key.	selector _ selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'initialize-release' stamp: 'di 6/6/2000 23:27'!receiver: rcvr selector: aSelector arguments: args precedence: p from: encoder 	"Compile."	| theSelector |	self receiver: rcvr		arguments: args		precedence: p.	aSelector = #:Repeat:do:		ifTrue: [theSelector _ #do:]		ifFalse: [theSelector _ aSelector].	self noteSpecialSelector: theSelector.	(self transform: encoder)		ifTrue: 			[selector isNil				ifTrue: [selector _ SelectorNode new 							key: (MacroSelectors at: special)							code: #macro]]		ifFalse: 			[selector _ encoder encodeSelector: theSelector.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 6/6/2000 23:39'!noteSpecialSelector: selectorSymbol	" special > 0 denotes specially treated messages. "	"Deconvert initial keywords from SQ2K"	special _ #(:Test:ifTrue: :Test:ifFalse: :Test:ifTrue:ifFalse: :Test:ifFalse:ifTrue:				and: or:				:Until:do: :While:do: whileFalse whileTrue				:Repeat:to:do: :Repeat:to:by:do:				) indexOf: selectorSymbol.	special > 0 ifTrue: [^ self].	special _ MacroSelectors indexOf: selectorSymbol.! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:10'!printIfOn: aStream indent: level	aStream dialect = #SQ00 ifTrue:		["Convert to if-then-else"		(arguments last isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments last isJust: NodeFalse) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #and: arguments: (Array with: arguments first)						on: aStream indent: level].		(arguments first isJust: NodeNil) ifTrue:			[aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].			self printParenReceiver: receiver on: aStream indent: level + 1.			^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)						on: aStream indent: level].		(arguments first isJust: NodeTrue) ifTrue:			[self printReceiver: receiver on: aStream indent: level.			^ self printKeywords: #or: arguments: (Array with: arguments last)						on: aStream indent: level].		aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Test '].		self printParenReceiver: receiver on: aStream indent: level + 1.		^ self printKeywords: #ifTrue:ifFalse: arguments: arguments						on: aStream indent: level].	receiver printOn: aStream indent: level + 1 precedence: precedence.	(arguments last isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^ self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^ self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:08'!printKeywords: key arguments: args on: aStream indent: level	| keywords indent noColons arg kwd hasBrackets doCrTab |	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	noColons _ aStream dialect = #SQ00 and: [keywords first endsWith: ':'].	doCrTab _ args size > 2 or:		[{receiver} , args			inject: false			into: [:was :thisArg |				was or: [(thisArg isKindOf: BlockNode)					or: [(thisArg isKindOf: MessageNode) and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do:		[:i | arg _ args at: i.  kwd _ keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		noColons			ifTrue: [aStream withStyleFor: #keyword						do: [aStream nextPutAll: kwd allButLast; space].					hasBrackets _ (arg isKindOf: BlockNode) or: [arg isKindOf: BlockNode].					hasBrackets ifFalse: [aStream nextPutAll: '(']]			ifFalse: [aStream nextPutAll: kwd; space].		arg printOn: aStream indent: level + 1 + indent			 	precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		noColons			ifTrue: [hasBrackets ifFalse: [aStream nextPutAll: ')']]]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:26'!printOn: aStream indent: level	| printer leadingKeyword |	special > 0 ifTrue: [printer _ MacroPrinters at: special].	(special > 0)		ifTrue: [self perform: printer with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [leadingKeyword _ selector key keywords first.						aStream nextPutAll: leadingKeyword; space.						self printReceiver: receiver on: aStream indent: level.						self printKeywords: (selector key allButFirst: leadingKeyword size + 1) arguments: arguments							on: aStream indent: level]				ifFalse: [(aStream dialect = #SQ00 and: [selector key == #do:])						ifTrue: ["Add prefix keyword"								aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].								self printParenReceiver: receiver on: aStream indent: level + 1]						ifFalse: [self printReceiver: receiver on: aStream indent: level].						self printKeywords: selector key arguments: arguments							on: aStream indent: level]]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 08:28'!printParenReceiver: rcvr on: aStream indent: level						(rcvr isKindOf: BlockNode) ifTrue:		[^ rcvr printOn: aStream indent: level].	aStream nextPutAll: '('.	rcvr printOn: aStream indent: level.	aStream nextPutAll: ')'! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:11'!printToDoOn: aStream indent: level	| limitNode |	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #prefixKeyword do: [aStream nextPutAll: 'Repeat '].				self printParenReceiver: receiver on: aStream indent: level + 1]		ifFalse: [self printReceiver: receiver on: aStream indent: level].	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:11'!printWhileOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #prefixKeyword						do: [aStream nextPutAll: (selector key == #whileTrue:									ifTrue: ['While '] ifFalse: ['Until '])].				self printParenReceiver: receiver on: aStream indent: level + 1.				self printKeywords: #do: arguments: arguments					on: aStream indent: level]		ifFalse: [self printReceiver: receiver on: aStream indent: level.				(arguments first isJust: NodeNil) ifTrue:						[selector _ SelectorNode new								key: (selector key == #whileTrue:									ifTrue: [#whileTrue] ifFalse: [#whileFalse])								code: #macro.						arguments _ Array new].				self printKeywords: selector key arguments: arguments					on: aStream indent: level]! !!MethodNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:21'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream withStyleFor: #keyword								do: [aStream nextPutAll: kwd allButLast].							aStream nextPutAll: ' (']					ifFalse: [aStream nextPutAll: kwd; space].				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				(aStream dialect = #SQ00 and: [kwd endsWith: ':'])					ifTrue: [aStream nextPutAll: ') ']					ifFalse: [aStream space]]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | 						aStream nextPutAll: temp key.						aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!Parser methodsFor: 'scanning' stamp: 'di 6/7/2000 08:44'!matchReturn	^ self match: #upArrow! !!Parser methodsFor: 'expression types' stamp: 'di 6/7/2000 08:45'!statements: argNodes innerBlock: inner	| stmts returns start more blockComment |	stmts _ OrderedCollection new.	"give initial comment to block, since others trail statements"	blockComment _ currentComment.	currentComment _ nil.	returns _ false.	more _ hereType ~~ #rightBracket.	[more]		whileTrue: 		[start _ self startOfNextToken.		(returns _ self matchReturn)			ifTrue: 				[self expression					ifFalse: [^self expected: 'Expression to return'].				self addComment.				stmts addLast: (parseNode isReturningIf					ifTrue: [parseNode]					ifFalse: [ReturnNode new							expr: parseNode							encoder: encoder							sourceRange: (start to: self endOfLastToken)])]			ifFalse: 				[self expression					ifTrue: 						[self addComment.						stmts addLast: parseNode]					ifFalse: 						[self addComment.						stmts size = 0							ifTrue: 								[stmts addLast: 									(encoder encodeVariable:										(inner ifTrue: ['nil'] ifFalse: ['self']))]]].		returns 			ifTrue: 				[self match: #period.				(hereType == #rightBracket or: [hereType == #doIt])					ifFalse: [^self expected: 'End of block']].		more _ returns not and: [self match: #period]].	parseNode _ BlockNode new				arguments: argNodes				statements: stmts				returns: returns				from: encoder.	parseNode comment: blockComment.	^ true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 11:21'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables checkpoint |	variableNodes _ OrderedCollection new.	"Gather parameters."	[checkpoint _ self checkpoint.	(self matchToken: 'Set')		and: [tokenType == #period				ifTrue: [true]				ifFalse: [self revertToCheckpoint: checkpoint. false]]]		whileTrue: [variableNodes addLast: (encoder autoBind: self argumentName).					(self match: #period) ifFalse: [^ self expected: 'Period']].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^ self expected: 'Period or right bracket'].	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 09:51'!expressionWithInitialKeyword: kwdIfAny	| checkpoint |	(hereType == #word and: [here = 'Set' and: [tokenType == #word]]) ifTrue:			["Parse assignment statement 'Set' var 'to' expression"			checkpoint _ self checkpoint.			self advance.			token = 'to'				ifTrue: [^ self assignment: self variable]				ifFalse: [self revertToCheckpoint: checkpoint]].	self matchKeyword		ifTrue: ["It's an initial keyword."				kwdIfAny isEmpty ifFalse: [self error: 'compiler logic error'].				^ self expressionWithInitialKeyword: ':' , self advance , ':'].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true initialKeyword: kwdIfAny)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 08:44'!matchReturn	^ self matchToken: 'Return'! !!DialectParser methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 08:15'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector checkpoint |	doitFlag _ fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	"NOTE: there is now an ambiguity between	keywordSelector (argName) -and- unarySelector (first expression).	Also, there is an amibuity (if there are no temp declarations) between	keywordSelector (argName) -and- PrefixKeyword (some expression).	We use duct tape for now."	(hereType == #word and: [tokenType == #leftParenthesis]) ifTrue:		[checkpoint _ self checkpoint.  "in case we have to back out"		selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #word				and: [tokenType == #leftParenthesis				and: [here first isLowercase						or: [(#('Test' 'Repeat' 'Return') includes: here) not]]]]				whileTrue: 					[selector nextPutAll: self advance , ':'.  "selector part"					self advance.  "open paren"					(args size = 0 and: [tokenType ~~ #rightParenthesis]) ifTrue:						["This is really a unary selector on a method that						begins with a parenthesized expression.  Back out now"						self revertToCheckpoint: checkpoint.						^ {self advance asSymbol. {}. 1}].					args addLast: (encoder bindArg: self argumentName).			(self match: #rightParenthesis)						ifFalse: [^ self expected: 'right parenthesis']].			^ {selector contents asSymbol. args. 3}].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	^ self expected: 'Message pattern'! !!DialectParser class methodsFor: 'as yet unclassified' stamp: 'di 6/7/2000 09:32'!test    "DialectParser test""PrettyPrints the source for every method in the system in the alternative syntax, and then compiles that source and verifies that it generates identical code.  No changes are actually made to the system.  At the time of this writing, only two methods caused complaints (reported in Transcript and displayed in browse window after running):	BalloonEngineSimulation circleCosTable and	BalloonEngineSimulation circleSinTable.These are not errors, but merely a case of Floats embedded in literal arrays, and thus not specially checked for roundoff errors.Note that if an error or interruption occurs during execution of this method, the alternativeSyntax preference will be left on.NOTE:  Some methods may not compare properly until the system has been recompiled once.  Do this by executing...		Smalltalk recompileAllFrom: 'AARDVAARK'."	 | newCodeString methodNode oldMethod newMethod badOnes n heading |	Preferences enable: #printAlternateSyntax.	badOnes _ OrderedCollection new.	Transcript clear.	Smalltalk forgetDoIts.'Formatting and recompiling all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allClassesDo:  "{MethodNode} do:"  "<- to check one class"		[:nonMeta |  "Transcript cr; show: nonMeta name."		{nonMeta. nonMeta class} do:		[:cls |		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil decorated: Preferences colorWhenPrettyPrinting.			heading _ cls organization categoryOfElement: selector.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: (SyntaxError new category: heading)						ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			"Transcript cr; show: cls name , ' ' , selector."			oldMethod = newMethod ifFalse:				[Transcript cr; show: '***' , cls name , ' ' , selector.				oldMethod size = newMethod size ifFalse:					[Transcript show: ' difft size'].				oldMethod header = newMethod header ifFalse:					[Transcript show: ' difft header'].				oldMethod literals = newMethod literals ifFalse:					[Transcript show: ' difft literals'].				Transcript endEntry.				badOnes add: cls name , ' ' , selector]]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'.	Preferences disable: #printAlternateSyntax.! !!Preferences class methodsFor: 'standard preferences' stamp: 'di 6/7/2000 10:53'!colorWhenPrettyPrinting	^ self printAlternateSyntax or: [self valueOfFlag: #colorWhenPrettyPrinting]! !!ReturnNode methodsFor: 'printing' stamp: 'di 6/7/2000 10:24'!printOn: aStream indent: level	aStream dialect = #SQ00		ifTrue: ["Add prefix keyword"				aStream withStyleFor: #setOrReturn do: [aStream nextPutAll: 'Return '].				expr printOn: aStream indent: level]		ifFalse: [aStream nextPutAll: '^ '.				expr printOn: aStream indent: level].	expr printCommentOn: aStream indent: level.! !Preferences class removeSelector: #syntaxAttributesFor:!