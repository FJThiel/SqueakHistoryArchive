SimpleClientSocket subclass: #HTTPSocket	instanceVariableNames: 'headerTokens headers responseCode '	classVariableNames: 'HTTPBlabEmail HTTPPort HTTPProxy ParamDelimiters '	poolDictionaries: ''	category: 'Network-Protocols'!!HTTPSocket commentStamp: 'ls 9/8/1998 21:38' prior: 0!HTTPSockets support HTTP requests, either directly or via an HTTP proxy server. An HTTPSocket saves the parse of the last ASCII header it saw, to avoid having to parse it repeatedly.The real action is in httpGet:accept:.  See the examples in the class, especially httpFileInNewChangeSet: and httpShowGif:.!]style[(206 15 45 23 5 13)f1,f1LHTTPSocket class httpGet:accept:;,f1,f1LHTTPSocket class httpFileInNewChangeSet:;,f1,f1LHTTPSocket class httpShowGif:;!!HTTPSocket methodsFor: 'all' stamp: 'ls 8/14/1998 10:17'!contentType	| type i |	type _ self getHeader: 'content-type' default: nil.	type ifNil: [ ^nil ].	type _ type withBlanksTrimmed.	i _ type indexOf: $;.	i = 0 ifTrue: [ ^type ].	^(type copyFrom: 1 to: i-1) withBlanksTrimmed	! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:37'!getHeader: name 	^self getHeader: name  default: nil! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:36'!getHeader: name  default: defaultValue	^headers at: name  ifAbsent: [ defaultValue ]! !!HTTPSocket methodsFor: 'all'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 7/4/1998 19:01'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close"	| buf response bytesRead |	buf _ String new: (length ifNil: [ 2000 ]).	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: (length ifNil: [ 2000 ]).	[(length isNil ifTrue: [ true ] ifFalse: [response position < length]) 	 & (self dataAvailable | self isConnected)] 	whileTrue: [		[self waitForDataUntil: (Socket deadlineSecs: 5)] whileFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: (length isNil ifTrue: [ buf size ] ifFalse: [ length - response size ]). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed']). 	"response text.	is already a text stream"	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/13/1998 00:33'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines _ headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine _ lines first.	lines _ lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode _ (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines _ OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers _ Dictionary new.	foldedLines do: [ :line |		i _ line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ]..! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:41'!responseCode	^responseCode! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!HTTPSocket class	instanceVariableNames: ''!!HTTPSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:30'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxy _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/4/97 16:11'!httpFileIn: url	"Do a regular file-in of a file that is served from a web site.  If the file contains an EToy, then open it.  Might just be code instead.  tk 7/23/97 17:10"	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones.  The server does not have to know about the .sqo extension in order to send your file.  (We do not need a new MIME type and .sqo does not have to be registered with the server.)"	"	HTTPSocket httpFileIn: 'www.webPage.com/~kaehler2/sample.etoy'	 "	"	HTTPSocket httpFileIn: '206.18.68.12/squeak/car.sqo'	 "	"	HTTPSocket httpFileIn: 'jumbo/tedk/sample.etoy'	 "	| doc eToyHolder |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	eToyHolder _ doc fileInObjectAndCode.	eToyHolder ifNotNil: [eToyHolder open].	"Later may want to return it, instead of open it"! !!HTTPSocket class methodsFor: 'examples' stamp: 'di 5/6/1998 16:40'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk_test.cs'	 "	| doc |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	ChangeSorter newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 11/4/97 08:25'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 4/24/1998 08:10'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| serverName serverAddr s header length bare page list firstData aStream newURL |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	"For now, may not put :80 or other port number in a url.  Use setHTTPPort:"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [		page _ 'http://', serverName, page.		"put back together"		serverName _ HTTPProxy].		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: serverName.				^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: HTTPPort.  "80 is normal"	(s waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: serverName.  s destroy.		^ 'Server ',serverName,' is not responding'].	Transcript cr; show: serverName; cr.	s sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', 		CrLf.	"blank line"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	"Find the length"	length _ s contentsLength: header.	"saves the headerTokens"	length ifNil: [		(newURL _ s redirect) ifNotNil: [			s destroy.			^ self httpGet: newURL accept: mimeType].		Transcript cr; show: 'Some kind of Error'.		s destroy.   ^ header].		aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ aStream	"String with just the data"! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:40'!httpGet: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:28'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/4/1998 00:36'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil  accept: mimeType! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:28'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/30/1998 16:23'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index first connectToHost connectToPort type argsString newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ HTTPPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [		argsString _ WriteStream on: String new.		argsString nextPut: $?.		first _ true.		args associationsDo: [ :assoc |			assoc value do: [ :value |				first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].				argsString nextPutAll: assoc key encodeForHTTP.				argsString nextPut: $=.				argsString nextPutAll: value encodeForHTTP. ] ].		argsString _ argsString contents.		page _ page, argsString ].	HTTPProxy isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxy.			connectToPort _ HTTPPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	header isEmpty ifTrue: [ ^'no header' ].	"dig out some headers"	sock header: header.	length _ sock getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ sock getHeader: 'content-type'.	sock responseCode first = $3 ifTrue: [		newUrl _ sock getHeader: 'location'.		newUrl ifNotNil: [ 			Transcript show: 'redirecting to ', newUrl; cr.			sock destroy.			^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].	aStream _ sock getRestOfBuffer: firstData totalLength: length.	sock destroy.	"Always OK to destroy!!" 	^ MIMEDocument contentType: type content: aStream contents url: url! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/15/97 12:07'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc _ self httpGet: url accept: 'image/gif'.	doc class == String ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg _ Smalltalk gifReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 5/26/1998 21:23'!httpPost: url accept: mimeType  with: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	(serverName includes: $:) ifFalse: [ port _ HTTPPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [		page _ 'http://', serverName, page.		"put back together"		serverName _ HTTPProxy].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ false.	argsDict associationsDo: [ :assoc |		first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].		argsStream nextPutAll: assoc key encodeForHTTP.		argsStream nextPut: $=.		argsStream nextPutAll: assoc value encodeForHTTP.	].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		CrLf.	"blank line"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	"Find the length"	length _ s contentsLength: header.	"saves the headerTokens"	length ifNil: [		Transcript cr; show: 'Some kind of Error'.		s destroy.   ^ header].		aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ aStream contents	"String with just the data"! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:40'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'lrs 5/16/98 17:16'!httpPost: url with: argsDict	^self httpPost: url accept: nil with: argsDict! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 8/3/1998 22:36'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 9/5/1998 18:36'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ HTTPPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxy.		port _ HTTPPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 5/4/1998 17:00'!httpShowChunk: url	"From a Swiki server, get a text chunk in the changes file.  Show its text in a window with style.  Vertical bar separates class and selector.  BE SURE TO USE ; instead of : in selectors!!"	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Socket|Comment'	 "	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Point|class|x;y;'	"	| doc text |	doc _ (self httpGet: url accept: 'application/octet-stream')."	doc size = 0 ifTrue: [doc _ 'The server does not seem to be responding']."	doc class == String ifTrue: [text _ doc] ifFalse: [text _ doc nextChunkText].	(StringHolder new contents: text) openLabel: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/15/97 12:18'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file. See examples in httpGif:."	| nameTokens |	nameTokens _ url findTokens: '/'.	FormView open: (self httpGif: url) named: nameTokens last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 5/4/1998 17:01'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	(StringHolder new contents: doc) openLabel: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k_t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'jm 9/15/97 12:06'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxy _ nil.	HTTPPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'jm 9/15/97 12:06'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxy _ nil.		HTTPPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxy _ proxyServerName.	HTTPPort _ portNum.	HTTPPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPPort ifNil: [HTTPPort _ 80].! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 9/15/97 11:10'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response |	[tryBlock value] whileFalse: [		response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: troubleString.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !HTTPSocket initialize!HTTPSocket subclass: #FTPSocket	instanceVariableNames: 'portNum dataSocket readAhead '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!FTPSocket commentStamp: 'ls 9/8/1998 21:38' prior: 0!A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!]style[(259 1 89 23 2 29 2 30 27 6 74)f1,f1-,f1,f1LServerDirectory openFTP;,f1,f1LServerDirectory getFileNamed:;,f1,f1LServerDirectory putFile:named:;,f1,f1b,f1!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket	^ dataSocket! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket: dd	dataSocket _ dd! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 21:56'!getAllData	"Reel in all data until the server closes the connection.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:20'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:40'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/13/1998 09:54'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."        | resp what all |        readAhead size > 0                ifTrue: [resp _ readAhead removeFirst]  "response already came in"                ifFalse: [                        all _ self getResponseUpTo: CrLf.                        resp _ all at: 1.       "150 Opening binary mode data conn"                        readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].        Transcript show: resp; cr.        resp size > 0                 ifTrue: [                        resp first isDigit ifFalse: [ ^self lookFor: beginning ].  "we're in the middle of a line, not the end." #XXX. "this should be fixed..."                        (resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"                        (resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"                        "((resp at: 1) isDigit) & ((resp at: 1) digitValue < 4) ifTrue: [^ self lookFor: beginning]."                                "the way I used to detect comments"                        ]                ifFalse: [resp _ '[timeout]'].        what _ (PopUpMenu labels: 'OK\ debug ' withCRs)                 startUpWithCaption: 'Server reported this error:\' withCRs, resp.        what = 2 ifTrue: [self halt].        self destroy.        ^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum	^ portNum! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum: anInteger	portNum _ anInteger! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:59'!responseCheck	"If data is waiting, do a responseOK to catch any error reports."	self dataAvailable ifTrue: [^ self responseOK].	^ true	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:28'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 					startUpWithCaption: 'Server reported this error:\' withCRs, resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 4/26/1998 09:33'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Return true if OK, the error string if not."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	Transcript show: resp; cr.	resp size > 0 		ifTrue: [((resp at: 1) == $5) | ((resp at: 1) == $4) ifFalse: [^ true]]  "All is well"		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !SimpleClientSocket subclass: #POPSocket	instanceVariableNames: 'serverAddress serverName userName password progressObservers '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!POPSocket commentStamp: 'ls 9/8/1998 21:38' prior: 0!Post Office Protocol.  This is used to download email over the network, usually from an intermittent connection.  To see how to use it, see POPSocket classe>>example.!!POPSocket methodsFor: 'private-initialization' stamp: 'ls 9/7/1998 05:27'!initialize	super initialize.	progressObservers _ IdentitySet new.! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:14'!addProgressObserver: anObserver	"progress will be sent to anObserver.  anObserver should respond to show:, endEntry, cr....  Transcript things"	progressObservers add: anObserver! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!password: aString	"set the password to use"	password _ aString ! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:22'!serverName: aString	"set the server name to connect to"	serverName _ aString! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!userName: aString	"set the username to use"	userName _ aString! !!POPSocket methodsFor: 'private' stamp: 'ls 9/7/1998 05:15'!reportToObservers: aString	"send aString to all observers"	progressObservers do: [ :observer |		observer show: aString ].! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 05:23'!connectToPOP	"connect to the POP server"	| address |	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find the address for ', serverName	].	self flag: #xxx.  "doesn't notice login errors"	self reportToObservers: '---------- Connecting ----------', String cr.	self connectTo: address port: 110.  "110 is the POP3 port number"	self waitForConnectionUntil: POPSocket standardDeadline.	self reportToObservers: self getResponse.	self sendCommand: 'USER ', userName.	self reportToObservers: self getResponse.	self sendCommand: 'PASS ', password.	self reportToObservers: self getResponse.! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 06:07'!deleteMessage: num	"delete the numbered message"	self sendCommand: 'DELE ', num printString.	self reportToObservers: self getResponse.! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 05:30'!disconnectFromPOP	| t |	self reportToObservers: 'closing connection', String cr.	self sendCommand: 'QUIT'.	t _ Time millisecondsToRun: [self closeAndDestroy].	self reportToObservers: 		'---------- Connection Closed ---------- (',(t // 1000) asString,' secs)',		String cr.! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 06:07'!messagesDo: aBlock	"perform aBlock on each message text.  Delete the message iff aBlock's value is #deleteIt"	| thisMessage |	1 to: self numMessages do: [ :num |		thisMessage _ self retrieveMessage: num.		(aBlock value: thisMessage) == #deleteIt ifTrue: [			self deleteMessage: num.		].	].	! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 06:02'!numMessages	"query the number of messages that are in the POP mailbox"	| response answerString |	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [ 		"ERROR"		^0 ].	[			answerString _ (response findTokens: Character separators) second.		^answerString asNumber asInteger	] ifError: [ :a :b |		"parsing error"		^0	]! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 06:04'!retrieveMessage: number	"retrieve the numbered message"	| response |	self sendCommand: 'RETR ', number printString.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [		self error: 'error: ', response ].	^self getMultilineResponse.! !!POPSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 05:21'!zzcloseAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isConnected ifTrue: [				self close.  "close this end"				"(self waitForDisconnectionUntil: (Socket deadlineSecs: 60))					ifFalse: [ self primSocketAbortConnection: socketHandle].""-- removed wait since it always seemed to time out --"				].			self destroy].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!POPSocket class	instanceVariableNames: ''!!POPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/7/1998 06:10'!example	"POPSocket example"	| ps messages |	ps _ POPSocket new.	ps serverName: (FillInTheBlank request: 'POP server').	ps userName: (FillInTheBlank request: 'POP username').	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [ :messageText |		messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/19/1998 22:43'!getMessagesNotifying: aProgressReporter andForEachDo: aBlock	|  s |		self initializeNetwork.	s _ self createIfFail: [self error: 'For some reason I could not create a POP socket'].	^s getMessagesNotifying: aProgressReporter andForEachDo: aBlock.! !SimpleClientSocket subclass: #SMTPSocket	instanceVariableNames: 'smtpServerAddress smtpServerName smtpUserName '	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/26/1998 19:40'!checkResponseFor: validResponses notifying: aProgressReporter	| response |	response _ self getResponse.	aProgressReporter show: response.	validResponses do: [ :each | (response beginsWith: each) ifTrue: [^response]].	aProgressReporter show: '**ERROR - expected ',validResponses asString; cr.			self halt.	^response! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 21:33'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isConnected ifTrue: [				self close.  "close this end""-- removed wait since it always seemed to time out --"				].			self destroy].! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/26/1998 19:42'!connectToSMTPNotifying: aProgressReporter	| preferences |	preferences _ EmailPreferences new.	smtpServerName := preferences at: #smtpServerName.	smtpServerName ifNotNil: [		smtpServerAddress _ NetNameResolver addressForName: smtpServerName timeout: 15.		smtpServerAddress = nil ifTrue: [			self error: 'Could not find the address for ', smtpServerName		].		smtpUserName := preferences at: #smtpUserName.	].	smtpServerAddress ifNil: [		smtpServerAddress _ NetNameResolver promptUserForHostAddress.		smtpUserName _ FillInTheBlank			request: 'What is your email name?'			initialAnswer: 'johnm'.	].		aProgressReporter show: '---------- Connecting ----------'; cr.	self connectTo: smtpServerAddress port: 25.  "25 is the SMTP port number"	self waitForConnectionUntil: SMTPSocket standardDeadline.	self checkResponseFor: #('220 ') notifying: aProgressReporter.	self sendCommand: 'HELO ', (smtpUserName copyUpTo: $@).	self checkResponseFor: #('250 ') notifying: aProgressReporter.! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 14:10'!convertToQuotedPrintable: lines	|  newLines |	newLines _ OrderedCollection new.	lines do: [ :aString | 		self convertToQuotedPrintable: aString addTo: newLines.	].	^newLines! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 16:38'!convertToQuotedPrintable: aString addTo: lines	| newLine newString breakPoint |	aString isEmpty ifTrue: [^lines add: aString].	newLine _ WriteStream on: ''.	aString do: [ :char | 		(self mustBeQuoted: char) ifTrue: [			newLine 				nextPut: $=;				nextPutAll: char hex.		] ifFalse: [			newLine nextPut: char		].	].	newString _ newLine contents.	(#(9 32) includes: newString last asciiValue) ifTrue: [		newString _ (newString copyFrom: 1 to: newString size - 1),				'=',newString last hex	].	[newString size > 72] whileTrue: [		breakPoint _ newString findBreakPointWithMaxLength: 72.		breakPoint = 0 ifTrue: [breakPoint _ 72].		(newString at: breakPoint) = $= ifTrue: [breakPoint _ breakPoint - 1].		lines add: (newString copyFrom: 1 to: breakPoint),'='.		newString _ newString copyFrom: breakPoint + 1 to: newString size.	].	lines add: newString.	^lines! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 02:11'!disconnectFromSMTPNotifying: aProgressReporter	| t |	aProgressReporter show: 'closing connection'; cr.	self sendCommand: 'QUIT'.	t _ Time millisecondsToRun: [self closeAndDestroy].	aProgressReporter 		show: '---------- Connection Closed ---------- (',(t // 1000) asString,' secs)'; 		cr; 		endEntry.! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 13:39'!mustBeQuoted: aCharacter	| val |	val _ aCharacter asciiValue.	val = 9 ifTrue: [^false].	val < 32 ifTrue: [^true].	val = 61 ifTrue: [^true].	^val > 126! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/1998 14:09'!prepareMessageText: aMessage	| in lines requiresQuotedPrintable headers |	headers _ OrderedCollection new.	requiresQuotedPrintable _ false.	in _ ReadStream on: aMessage messageTextForSend.	lines _ OrderedCollection new.	in linesDo: [ :thisLine |		lines add: thisLine.		requiresQuotedPrintable _ requiresQuotedPrintable or: [			self requiresQuotedPrintable: thisLine		]	].	headers 		add: 'Subject: ',(aMessage subject copyWithout: Character cr);		add: 'MIME-Version: 1.0';		add: 'X-Mailer: eekMail 1.0'.	requiresQuotedPrintable ifTrue: [		lines _ self convertToQuotedPrintable: lines.		headers add: 'Content-Transfer-Encoding: quoted-printable'	].	lines _ lines collect: [ :each | 		(each size > 0 and: [each first = $.]) ifTrue: [			'.',each		] ifFalse: [			each		].	].	^headers, #(''), lines! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 18:44'!requiresQuotedPrintable: aString	aString isEmpty ifTrue: [^false].	aString size > 500 ifTrue: [^true].	(#(9 32) includes: aString last asciiValue) ifTrue: [^true].	aString do: [ :ch | (self mustBeQuoted: ch) ifTrue: [^true]].	^false! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/1998 17:35'!sendMessages: aCollection notifying: aProgressReporter andForEachDo: aBlock	Socket initializeNetwork.	self connectToSMTPNotifying: aProgressReporter.	aCollection do: [ :msg |		self sendCommand: 'MAIL FROM: ',smtpUserName.		self checkResponseFor: #('250 ') notifying: aProgressReporter. 		msg eachRecipientAddressDo: [ :eachRecipient |			self sendCommand: 'RCPT TO: ',eachRecipient.			self checkResponseFor: #('250 ' '251 ') notifying: aProgressReporter. 		].		self sendCommand: 'DATA'.		self checkResponseFor: #('354 ') notifying: aProgressReporter.		(self prepareMessageText: msg) do: [ :eachLine | 			self sendCommand: eachLine.		]. 		self sendCommand: '.'.		self checkResponseFor: #('250 ') notifying: aProgressReporter.	].	self disconnectFromSMTPNotifying: aProgressReporter.! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 20:48'!sendTestMessageNotifying: aProgressReporter andForEachDo: aBlock	| |	Socket initializeNetwork.	self connectToSMTPNotifying: aProgressReporter.	self sendCommand: 'MAIL FROM: <arning@charm.net>'.	self checkResponseFor: #('250 ') notifying: aProgressReporter. 	self sendCommand: 'RCPT TO: <arning@charm.net>'.	self checkResponseFor: #('250 ' '251 ') notifying: aProgressReporter. 	self sendCommand: 'DATA'.	self checkResponseFor: #('354 ') notifying: aProgressReporter. 	self sendCommand: 'Subject: test message'. 	self sendCommand: ''. 	self sendCommand: 'Hello, Bob'.  	self sendCommand: ''. 	self sendCommand: '.'.	self checkResponseFor: #('250 ') notifying: aProgressReporter.	self disconnectFromSMTPNotifying: aProgressReporter.! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/27/1998 20:25'!simulate: aCommand notifying: aProgressReporter 	aProgressReporter show: aCommand; cr.! !!SMTPSocket methodsFor: 'as yet unclassified' stamp: 'RAA 7/27/1998 20:19'!simulateSendMessages: aCollection notifying: aProgressReporter andForEachDo: aBlock	aCollection do: [ :msg |		self simulate: 'MAIL FROM: ',smtpUserName notifying: aProgressReporter. 		msg eachRecipientAddressDo: [ :eachRecipient |			self simulate: 'RCPT TO: ',eachRecipient notifying: aProgressReporter. 		].		self simulate: 'DATA' notifying: aProgressReporter.		(self prepareMessageText: msg) do: [ :eachLine | 			self simulate: eachLine notifying: aProgressReporter.		]. 		self simulate: '.' notifying: aProgressReporter.	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMTPSocket class	instanceVariableNames: ''!!SMTPSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 02:12'!sendMessages: aCollection notifying: aProgressReporter andForEachDo: aBlock	|  s |		self initializeNetwork.	s _ self createIfFail: [self error: 'For some reason I could not create a SMTP socket'].	^s sendMessages: aCollection notifying: aProgressReporter andForEachDo: aBlock! !!SMTPSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/1998 02:26'!test"SMTPSocket test"	| progressStream |	progressStream _ EmailTranscriptStream open.	SMTPSocket 		sendMessages: #() 		notifying: progressStream 		andForEachDo: [ :text :totalCount |		].	progressStream closeIn: 3.! !