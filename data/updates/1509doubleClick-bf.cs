'From Squeak 2.5 of August 6, 1999 [latest update: #1499] on 28 September 1999 at 6:15:36 pm'!"Change Set:		doubleClick-bfDate:			28 September 1999Author:			Bert Freudenberg (& sw)Enhances the method dispatch protocol for double-click so that if a morph registers for double-click and the ensuing mouse sequence is neither a double-click nor a single-click, the morph will subsequently be sent a sequence of #drag: calls, first with an attached mouseDown event, next with a series of mouseMove events, and finally with a mouseUp event.Extends DoubleClickExample to demonstrate use of methods click: and drag:.*  On single click, changes border color.  *  Adds balloons to show what's going on.*  Improves the #drag: behavior so mouseMove: needn't be used at all."!RectangleMorph subclass: #DoubleClickExample	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!DoubleClickExample commentStamp: 'sw 9/28/1999 17:27' prior: 0!Illustrates the double-click capabilities of Morphic.If you have a kind of morph you wish to have respond specially to a double-click, it should:(1)  Respond "true" to #handlesMouseDown:(2)  In its mouseDown: method, send #waitForClicksOrDrag:event: to the hand.(3)  Reimplement #click: to react to single-clicked mouse-down.(4)  Reimplement #doubleClick: to make the appropriate response to a double-click.(5)  Reimplement #drag: to react to non-clicks.  This message is sent continuously until the button is released.  You can check the event argument to react differently on the first, intermediate, and last calls.!!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1999 16:51'!balloonText	^ 'Double-click on me to change my color; single-click on me to change border color;hold mouse down within me to grow (if I''m red) or shrink (if I''m blue).'! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1999 16:46'!click: evt	self showBalloon: 'click'.	self borderColor: (self borderColor = Color black ifTrue: [Color yellow] ifFalse: [Color black])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'bf 9/28/1999 20:55'!doubleClick: evt	self showBalloon: 'doubleClick'.	self color: ((color = Color blue) ifTrue: [Color red] ifFalse: [Color blue])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1999 17:21'!drag: evt	"We'll get a mouseDown first, some mouseMoves, and a mouseUp event last"	| oldCenter |	evt isMouseDown ifTrue:		[self showBalloon: 'drag (mouse down)'.		self world displayWorld.		(Delay forMilliseconds: 750) wait].	evt isMouseUp ifTrue:		[self showBalloon: 'drag (mouse up)'].	(evt isMouseUp or: [evt isMouseDown]) ifFalse:		[self showBalloon: 'drag (mouse still down)'].	(self containsPoint: evt cursorPoint)		ifFalse: [^ self].	oldCenter _ self center.	color = Color red		ifTrue:			[self extent: self extent + (1@1)]		ifFalse:			[self extent: ((self extent - (1@1)) max: (16@16))].	self center: oldCenter! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'bf 9/28/1999 17:20'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt! !!HandMorph methodsFor: 'double click support' stamp: 'bf 9/28/1999 21:00'!checkForDoubleClick: evt	"Process the given mouse event to detect a click, double-click, or drag."	| t |	clickState = #dragging ifTrue:		[clickClient drag: evt.		evt isMouseMove ifFalse: [self resetClickState].		^ self].	t _ Time millisecondClockValue - firstClickTime.	clickState = #firstClickDown ifTrue:		[(t > DoubleClickTime or:		 [(evt cursorPoint - firstClickEvent cursorPoint) r > 15]) ifTrue:			["consider it a drag if hand moves or timeout expires"			clickClient drag: firstClickEvent.			clickState _ #dragging.			^ self].		evt isMouseUp ifTrue:			[clickState _ #firstClickUp.			^ self]].	clickState = #firstClickUp ifTrue:		[evt isMouseDown ifTrue:			[clickClient doubleClick: firstClickEvent.			^ self resetClickState].		t > DoubleClickTime ifTrue:			[clickClient click: firstClickEvent.			^ self resetClickState]]! !!HandMorph methodsFor: 'double click support' stamp: 'sw 9/28/1999 17:37'!waitForClicksOrDrag: aMorph event: evt	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	clickClient _ aMorph.	clickState _ #firstClickDown.	firstClickEvent _ evt.	firstClickTime _ Time millisecondClockValue.! !DoubleClickExample removeSelector: #mouseMove:!