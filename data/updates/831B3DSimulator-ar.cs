'From Squeak 2.3 of January 14, 1999 on 18 April 1999 at 8:14:32 am'!"Change Set:		B3DSimulator-arDate:			18 April 1999Author:			Andreas RaabThis change set contains the Balloon rasterizer simulation."!Object subclass: #B3DActiveEdgeTable	instanceVariableNames: 'start stop array '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DFillList	instanceVariableNames: 'firstFace lastFace '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DPrimitiveEdge	instanceVariableNames: 'v0 v1 leftFace rightFace flags xValue yValue zValue nLines xIncrement zIncrement '	classVariableNames: 'DepthScale FixedScale FixedToInt '	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DPrimitiveEdgeList	instanceVariableNames: 'tally array '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DPrimitiveFace	instanceVariableNames: 'v0 v1 v2 prevFace nextFace leftEdge rightEdge flags majorDx majorDy minorDx minorDy oneOverArea dzdx dzdy minZ maxZ texture attributes '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DPrimitiveFaceAttributes	instanceVariableNames: 'nextAttr value dvdx dvdy '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DPrimitiveObject	instanceVariableNames: 'next prev texture bounds minZ maxZ start faces vertices '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!Object subclass: #B3DScanner	instanceVariableNames: 'aet fillList added lastIntersection nextIntersection objects spanBuffer bitBlt nFaces maxFaces maxEdges '	classVariableNames: 'DebugMode FlagContinueLeftEdge FlagContinueRightEdge FlagEdgeLeftMajor FlagEdgeRightMajor FlagFaceActive FlagFaceInitialized '	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!B3DVertexRasterizer subclass: #B3DSimulRasterizer	instanceVariableNames: 'canvas scanner '	classVariableNames: ''	poolDictionaries: ''	category: 'Balloon-3D-Simulator'!!ArrayedCollection methodsFor: 'sorting' stamp: 'ar 4/3/1999 21:31'!isSortedBy: aBlock	"Return true if the receiver is sorted by the given criterion."	| lastEl el |	self isEmpty ifTrue:[^true].	lastEl _ self first.	2 to: self size do: [:i |		el _ self at: i.		(aBlock value: lastEl value: el) ifFalse:[^false].		lastEl _ el].	^ true! !!B3DActiveEdgeTable methodsFor: 'initialize' stamp: 'ar 4/4/1999 20:55'!initialize	array _ Array new: 100.	start _ 0.	stop _ 0.! !!B3DActiveEdgeTable methodsFor: 'accessing' stamp: 'ar 4/6/1999 02:21'!at: index	^array at: index! !!B3DActiveEdgeTable methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:48'!first	^array at: 1! !!B3DActiveEdgeTable methodsFor: 'accessing' stamp: 'ar 4/6/1999 23:20'!indexOf: anEdge	1 to: stop do:[:i| (array at: i) = anEdge ifTrue:[^i]].	^0! !!B3DActiveEdgeTable methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:48'!last	^array at: stop! !!B3DActiveEdgeTable methodsFor: 'accessing' stamp: 'ar 4/3/1999 05:28'!size	^stop! !!B3DActiveEdgeTable methodsFor: 'accessing' stamp: 'ar 4/6/1999 03:51'!xValues	^(array copyFrom: 1 to: stop) collect:[:e| e xValue]! !!B3DActiveEdgeTable methodsFor: 'streaming' stamp: 'ar 4/3/1999 05:28'!atEnd	^start >= stop! !!B3DActiveEdgeTable methodsFor: 'streaming' stamp: 'ar 4/3/1999 05:28'!next	"Return the next entry from the AET and advance start"	^array at: (start _ start + 1)! !!B3DActiveEdgeTable methodsFor: 'streaming' stamp: 'ar 4/5/1999 23:24'!peek	"Peek the next entry from the AET"	^array at: (start + 1)! !!B3DActiveEdgeTable methodsFor: 'streaming' stamp: 'ar 4/3/1999 05:28'!reset	start _ 0.! !!B3DActiveEdgeTable methodsFor: 'merging' stamp: 'ar 4/4/1999 21:52'!mergeEdgesFrom: inputList	"Merge all the edges from the given input list in the AET"	| srcIndex dstIndex outIndex srcEdge dstEdge |	srcIndex _ inputList size.	srcIndex = 0 ifTrue:[^self].	dstIndex _ stop.	"Make room for adding the stuff"	[stop + srcIndex > array size] whileTrue:[self grow].	"Adjust size"	stop _ stop + srcIndex.	"If the receiver is empty, simply copy the stuff"	dstIndex = 0 ifTrue:[		1 to: srcIndex do:[:i| array at: i put: (inputList at: i)].		^self].	"Merge inputList by walking backwards through the AET and checking each edge."	outIndex _ dstIndex+srcIndex.	srcEdge _ inputList at: srcIndex.	dstEdge _ array at: dstIndex.	[true] whileTrue:[		srcEdge xValue >= dstEdge xValue ifTrue:[			"Insert srcEdge"			array at: outIndex put: srcEdge.			srcIndex _ srcIndex - 1.			srcIndex = 0 ifTrue:[^self].			srcEdge _ inputList at: srcIndex.		] ifFalse:[			"Insert dstEdge"			array at: outIndex put: dstEdge.			dstIndex _ dstIndex - 1.			dstIndex = 0 ifTrue:[				1 to: srcIndex do:[:i| array at: i put: (inputList at: i)].				^self].			dstEdge _ array at: dstIndex.		].		outIndex _ outIndex-1.	].! !!B3DActiveEdgeTable methodsFor: 'removing' stamp: 'ar 4/5/1999 03:15'!removeFirst	stop _ stop - 1.	array replaceFrom: start to: stop with: array startingAt: start+1.	start _ start - 1.	array at: stop+1 put: nil.! !!B3DActiveEdgeTable methodsFor: 'sorting' stamp: 'ar 4/3/1999 05:27'!resortFirst	"Resort the first entry in the active edge table"	| edge xValue leftEdge newIndex |	start = 1 ifTrue:[^self]. "Nothing to do"	"Fetch the edge to test."	edge _ array at: start.	xValue _ edge xValue.	"Fetch the next edge left to it."	leftEdge _ array at: start-1.	leftEdge xValue <= xValue ifTrue:[^self]. "Okay."	"Move the edge left to its correct insertion point."	newIndex _ start.	[newIndex > 1 and:[(leftEdge _ array at: newIndex-1) xValue > xValue]]		whileTrue:[	array at: newIndex put: leftEdge.					newIndex _ newIndex - 1].	array at: newIndex put: edge.! !!B3DActiveEdgeTable methodsFor: 'testing' stamp: 'ar 4/4/1999 21:21'!isEmpty	^stop = 0! !!B3DActiveEdgeTable methodsFor: 'enumerating' stamp: 'ar 4/5/1999 02:19'!do: aBlock	1 to: stop do:[:i| aBlock value: (array at: i)].! !!B3DActiveEdgeTable methodsFor: 'private' stamp: 'ar 4/5/1999 02:19'!asArray	^array copyFrom: 1 to: stop! !!B3DActiveEdgeTable methodsFor: 'private' stamp: 'ar 4/3/1999 05:25'!grow	| newArray |	newArray _ array species new: array size + 100. "Grow linearly"	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array _ newArray.! !!B3DActiveEdgeTable class methodsFor: 'instance creation' stamp: 'ar 4/4/1999 04:27'!new	^super new initialize! !!B3DFillList methodsFor: 'initialize' stamp: 'ar 4/4/1999 04:28'!initialize	self reset.! !!B3DFillList methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:39'!first	^firstFace! !!B3DFillList methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:49'!last	^lastFace! !!B3DFillList methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:31'!reset	firstFace _ lastFace _ nil.! !!B3DFillList methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:00'!searchForNewTopAtX: xValue y: yValue	"A top face ended with no known right face.	We have to search the fill list for the face with the smallest z value.	Note: In theory, this should only happen on *right* boundaries of meshes	and thus not affect performance too much. Having the fillList sorted by	its minimal z value should help, too."	| face topFace topZ faceZ floatX floatY |	self isEmpty ifTrue:[^self]. "No top"	floatX _ xValue / 4096.0.	floatY _ yValue.	face _ self first.	topFace _ face.	topZ _ face zValueAtX: floatX y: floatY.	[face _ face nextFace.	face == nil] whileFalse:[		face minZ > topZ ifTrue:[			"Done. Everything else is behind."			self remove: topFace.			self addFront: topFace.			^self].		faceZ _ face zValueAtX: floatX y: floatY.		faceZ < topZ ifTrue:[			topZ _ faceZ.			topFace _ face]].	self remove: topFace.	self addFront: topFace.! !!B3DFillList methodsFor: 'accessing' stamp: 'ar 4/4/1999 23:53'!size	| n face |	n _ 0.	face _ firstFace.	[face == nil] whileFalse:[		n _ n + 1.		face _ face nextFace.	].	^n! !!B3DFillList methodsFor: 'adding' stamp: 'ar 4/5/1999 20:38'!addBack: aFace	"Add the given face as a non-front face (e.g., insert it after the front face).	Make sure that the receiver stays sorted by the minimal z values of faces."	| minZ midZ face |	firstFace == nil ifTrue:[^self error:'Inserting a back face with no front face'].	minZ _ aFace minZ.	"Quick optimization for insertion at end"	(firstFace == lastFace or:[minZ >= lastFace minZ]) ifTrue:[^self addLast: aFace].	"Try an estimation for how to search"	midZ _ (firstFace nextFace minZ + lastFace minZ) * 0.5.	minZ <= midZ ifTrue:[		"Search front to back"		face _ firstFace nextFace.		[face minZ < minZ] whileTrue:[face _ face nextFace].	] ifFalse:[		"Search back to front"		face _ lastFace prevFace. "Already checked for lastFace minZ < face minZ"		[face minZ > minZ] whileTrue:[face _ face prevFace].		face _ face nextFace.	].	self insert: aFace before: face.! !!B3DFillList methodsFor: 'adding' stamp: 'ar 4/18/1999 08:04'!addFirst: aFace	firstFace isNil		ifTrue:[lastFace _ aFace]		ifFalse:[firstFace prevFace: aFace].	aFace nextFace: firstFace.	aFace prevFace: nil.	firstFace _ aFace.	B3DScanner doDebug ifTrue:[self validate].! !!B3DFillList methodsFor: 'adding' stamp: 'ar 4/5/1999 20:41'!addFront: aFace	"Add the given face as the new front face.	Make sure the sort order stays okay."	| backFace minZ tempFace |	firstFace == lastFace ifFalse:["firstFace == lastFace denotes 0 or 1 elements"		backFace _ firstFace nextFace.		minZ _ firstFace minZ.		[backFace notNil and:[backFace minZ < minZ]] 			whileTrue:[backFace _ backFace nextFace].		"backFace contains the face before which firstFace has to be added"		firstFace nextFace == backFace ifFalse:[			tempFace _ firstFace.			self remove: tempFace.			backFace == nil 				ifTrue:[self addLast: tempFace]				ifFalse:[self insert: tempFace before: backFace].		].	].	^self addFirst: aFace! !!B3DFillList methodsFor: 'adding' stamp: 'ar 4/18/1999 08:04'!addLast: aFace	lastFace isNil		ifTrue:[firstFace _ aFace]		ifFalse:[lastFace nextFace: aFace].	aFace prevFace: lastFace.	aFace nextFace: nil.	lastFace _ aFace.	B3DScanner doDebug ifTrue:[self validate].! !!B3DFillList methodsFor: 'adding' stamp: 'ar 4/18/1999 08:04'!insert: aFace before: nextFace	"Insert the given face before nextFace."	B3DScanner doDebug ifTrue:[		(self includes: nextFace) ifFalse:[^self error:'Face not in collection'].		(self includes: aFace) ifTrue:[^self error:'Face already in collection'].	].	aFace nextFace: nextFace.	aFace prevFace: nextFace prevFace.	aFace prevFace nextFace: aFace.	nextFace prevFace: aFace.	B3DScanner doDebug ifTrue:[self validate].! !!B3DFillList methodsFor: 'removing' stamp: 'ar 4/18/1999 08:04'!remove: aFace	(B3DScanner doDebug and:[(self includes: aFace) not]) 		ifTrue:[^self error:'Face not in list'].	B3DScanner doDebug ifTrue:[self validate].	aFace prevFace isNil		ifTrue:[firstFace _ aFace nextFace]		ifFalse:[aFace prevFace nextFace: aFace nextFace].	aFace nextFace isNil		ifTrue:[lastFace _ aFace prevFace]		ifFalse:[aFace nextFace prevFace: aFace prevFace].	^aFace! !!B3DFillList methodsFor: 'enumerating' stamp: 'ar 4/18/1999 08:03'!do: aBlock	| face |	B3DScanner doDebug ifTrue:[self validate].	face _ firstFace.	[face == nil] whileFalse:[		aBlock value: face.		face _ face nextFace.	].! !!B3DFillList methodsFor: 'testing' stamp: 'ar 4/5/1999 01:58'!includes: aFace	| face |	face _ firstFace.	[face == nil] whileFalse:[		face == aFace ifTrue:[^true].		face _ face nextFace.	].	^false! !!B3DFillList methodsFor: 'testing' stamp: 'ar 4/3/1999 00:49'!isEmpty	^firstFace == nil! !!B3DFillList methodsFor: 'private' stamp: 'ar 4/5/1999 03:54'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$(;		print: self size;		nextPut: $).! !!B3DFillList methodsFor: 'private' stamp: 'ar 4/5/1999 20:27'!validate	| face |	(firstFace == nil and:[lastFace == nil]) ifTrue:[^self].	firstFace prevFace == nil ifFalse:[^self error:'Bad list'].	lastFace nextFace == nil ifFalse:[^self error:'Bad list'].	face _ firstFace.	[face == lastFace] whileFalse:[face _ face nextFace].	self validateSortOrder.! !!B3DFillList methodsFor: 'private' stamp: 'ar 4/5/1999 20:39'!validateSortOrder	| backFace |	firstFace == lastFace ifTrue:[^self]. "0 or 1 element"	backFace _ firstFace nextFace.	[backFace nextFace == nil] whileFalse:[		backFace minZ <= backFace nextFace minZ ifFalse:[^self error:'Sorting error'].		backFace _ backFace nextFace.	].! !!B3DFillList class methodsFor: 'instance creation' stamp: 'ar 4/4/1999 04:27'!new	^super new initialize! !!B3DPrimitiveEdge methodsFor: 'initialize' stamp: 'ar 4/3/1999 04:25'!from: vtx0 to: vtx1	(vtx0 sortsBefore: vtx1) 		ifTrue:[v0 _ vtx0. v1 _ vtx1]		ifFalse:[v1 _ vtx0. v0 _ vtx1].! !!B3DPrimitiveEdge methodsFor: 'initialize' stamp: 'ar 4/18/1999 08:05'!initializePass1	"Assume: v0 sortsBefore: v1"	xValue _ v0 windowPosX.	yValue _ v0 windowPosY.	zValue _ v0 rasterPosZ.	xIncrement _ (v1 windowPosX - v0 windowPosX) // nLines.	zIncrement _ (v1 rasterPosZ - v0 rasterPosZ) / nLines.! !!B3DPrimitiveEdge methodsFor: 'initialize' stamp: 'ar 4/4/1999 21:34'!v0: vtx0 v1: vtx1	v0 _ vtx0.	v1 _ vtx1.	flags _ 0.	nLines _ (vtx1 windowPosY bitShift: -12) - (vtx0 windowPosY bitShift: -12).! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/4/1999 02:41'!flags	^flags! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/4/1999 02:41'!flags: aNumber	flags _ aNumber! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:33'!leftFace	^leftFace! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:33'!leftFace: aFace	leftFace _ aFace! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 03:25'!nLines	^nLines! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 03:25'!nLines: aNumber	nLines _ aNumber! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:33'!rightFace	^rightFace! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:33'!rightFace: aFace	rightFace _ aFace.! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/4/1999 20:58'!vertex0	^v0! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/4/1999 20:58'!vertex1	^v1! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/6/1999 23:21'!xIncrement		^xIncrement! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:48'!xValue	^xValue! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/5/1999 22:25'!xValue: aNumber	xValue _ aNumber! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:48'!yValue	^yValue! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:48'!zValue	^zValue! !!B3DPrimitiveEdge methodsFor: 'accessing' stamp: 'ar 4/6/1999 01:23'!zValue: aNumber	zValue _ aNumber! !!B3DPrimitiveEdge methodsFor: 'processing' stamp: 'ar 4/5/1999 02:45'!stepToNextLine	"Step to the next scan line"	xValue _ xValue + xIncrement.	yValue _ yValue + 4096.	zValue _ zValue + zIncrement.! !!B3DPrimitiveEdge methodsFor: 'printing' stamp: 'ar 4/4/1999 23:35'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$(;		print: (v0 windowPos bitShiftPoint:-12);		nextPutAll:' - ';		print: (v1 windowPos bitShiftPoint: -12);		nextPutAll:' nLines = ';		print: nLines;		nextPut:$).! !Smalltalk renameClassNamed: #B3DInsertionList as: #B3DPrimitiveEdgeList!!B3DPrimitiveEdgeList methodsFor: 'initialize' stamp: 'ar 4/4/1999 01:38'!initialize	array _ Array new: 100.	tally _ 0.! !!B3DPrimitiveEdgeList methodsFor: 'initialize' stamp: 'ar 4/4/1999 21:20'!reset	1 to: tally do:[:i| array at: i put: nil].	tally _ 0.! !!B3DPrimitiveEdgeList methodsFor: 'accessing' stamp: 'ar 4/4/1999 21:42'!at: index	^array at: index! !!B3DPrimitiveEdgeList methodsFor: 'accessing' stamp: 'ar 4/4/1999 21:01'!first	^array at: 1! !!B3DPrimitiveEdgeList methodsFor: 'accessing' stamp: 'ar 4/4/1999 21:42'!size	^tally! !!B3DPrimitiveEdgeList methodsFor: 'accessing' stamp: 'ar 4/6/1999 03:58'!xValues	^(array copyFrom: 1 to: tally) collect:[:e| e xValue]! !!B3DPrimitiveEdgeList methodsFor: 'adding' stamp: 'ar 4/4/1999 23:44'!add: edge1 and: edge2 beforeIndex: index	tally+1 >= array size ifTrue:[self grow].	tally+2 to: index+2 by: -1 do:[:i|array at: i put: (array at:i-2)].	"array replaceFrom: index+2 to: tally+2 with: array startingAt: index."	array at: index put: edge1.	array at: index+1 put: edge2.	tally _ tally + 2.! !!B3DPrimitiveEdgeList methodsFor: 'adding' stamp: 'ar 4/4/1999 23:45'!add: edge beforeIndex: index	tally = array size ifTrue:[self grow].	tally+1 to: index+1 by: -1 do:[:i|array at: i put: (array at:i-1)].	"array replaceFrom: index+1 to: tally+1 with: array startingAt: index."	array at: index put: edge.	tally _ tally + 1! !!B3DPrimitiveEdgeList methodsFor: 'enumerating' stamp: 'ar 4/5/1999 02:27'!do: aBlock	1 to: tally do:[:i| aBlock value: (array at: i)].! !!B3DPrimitiveEdgeList methodsFor: 'enumerating' stamp: 'ar 4/4/1999 01:39'!xValue: xValue from: firstIndex do: aBlock	"Enumerate the entries in the insertion list starting at the given first index.	Evaluate aBlock with the entries having the requested x value. Return the index	after the last element touched."	| edge |	firstIndex to: tally do:[:i|		edge _ array at: i.		edge xValue = xValue ifFalse:[^i].		aBlock value: edge.	].	^tally+1! !!B3DPrimitiveEdgeList methodsFor: 'testing' stamp: 'ar 4/4/1999 23:09'!isEmpty	^tally = 0! !!B3DPrimitiveEdgeList methodsFor: 'sorting' stamp: 'ar 4/5/1999 01:41'!firstIndexForInserting: xValue	"Return the first possible index for inserting an object with the given xValue"	| index |	index _ self indexForInserting: xValue.	[index > 1 and:[(array at: index-1) xValue = xValue]]		whileTrue:[index _ index-1].	^index! !!B3DPrimitiveEdgeList methodsFor: 'sorting' stamp: 'ar 4/5/1999 01:41'!indexForInserting: xValue	"Return the appropriate index for inserting the given x value"	| index low high |	low _ 1.	high _ tally.	[index _ high + low // 2.	low > high]		whileFalse:[			(array at: index) xValue <= xValue				ifTrue: [low _ index + 1]				ifFalse: [high _ index - 1]].	^low! !!B3DPrimitiveEdgeList methodsFor: 'private' stamp: 'ar 4/4/1999 01:38'!grow	| newArray |	newArray _ array species new: array size + 100.	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array _ newArray.! !!B3DPrimitiveEdgeList class methodsFor: 'instance creation' stamp: 'ar 4/4/1999 04:27'!new	^super new initialize! !!B3DPrimitiveFace methodsFor: 'initialize' stamp: 'ar 4/5/1999 18:29'!initializeDepthBounds	"Compute minZ/maxZ"	v0 rasterPosZ <= v1 rasterPosZ ifTrue:[		v1 rasterPosZ <= v2 rasterPosZ			ifTrue:[minZ _ v0 rasterPosZ. maxZ _ v2 rasterPosZ]			ifFalse:[v0 rasterPosZ <= v2 rasterPosZ						ifTrue:[minZ _ v0 rasterPosZ. maxZ _ v1 rasterPosZ]						ifFalse:[minZ _ v2 rasterPosZ. maxZ _ v1 rasterPosZ]].	] ifFalse:[		v2 rasterPosZ <= v1 rasterPosZ			ifTrue:[minZ _ v2 rasterPosZ. maxZ _ v0 rasterPosZ]			ifFalse:[v0 rasterPosZ <= v2 rasterPosZ						ifTrue:[minZ _ v1 rasterPosZ. maxZ _ v2 rasterPosZ]						ifFalse:[minZ _ v1 rasterPosZ. maxZ _ v0 rasterPosZ]].	].! !!B3DPrimitiveFace methodsFor: 'initialize' stamp: 'ar 4/8/1999 04:32'!initializePass1	"Assume: v0 sortsBefore: v1 sortsBefore: v2"	| area majorDz minorDz |	self initializeDepthBounds. "Compute minZ/maxZ"	"Compute the major and minor reference edges"	majorDx _ v2 rasterPosX - v0 rasterPosX.	majorDy _ v2 rasterPosY - v0 rasterPosY.	minorDx _ v1 rasterPosX - v0 rasterPosX.	minorDy _ v1 rasterPosY - v0 rasterPosY.	"Compute the inverse area of the face"	area _ (majorDx * minorDy) - (minorDx * majorDy).	((area > -0.001) and:[area < 0.001])		ifTrue:[oneOverArea _ 0.0]		ifFalse:[oneOverArea _ 1.0 / area].	"Compute dzdx and dzdy"	majorDz _ v2 rasterPosZ - v0 rasterPosZ.	minorDz _ v1 rasterPosZ - v0 rasterPosZ.	dzdx _ oneOverArea * ((majorDz * minorDy) - (minorDz * majorDy)).	dzdy _ oneOverArea * ((majorDx * minorDz) - (majorDz * minorDx)).! !!B3DPrimitiveFace methodsFor: 'initialize' stamp: 'ar 4/18/1999 06:35'!initializePass2	"The receiver is about to be drawn.	Initialize all the attributes deferred until now."	| majorDv minorDv dvdx dvdy w0 w1 w2 baseValue rAttr gAttr bAttr aAttr wAttr sAttr tAttr |	"Red"	majorDv _ v2 redValue - v0 redValue.	minorDv _ v1 redValue - v0 redValue.	dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).	dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).	attributes _ rAttr _ B3DPrimitiveFaceAttributes new.	rAttr value: v0 redValue; dvdx: dvdx; dvdy: dvdy.	"Green"	majorDv _ v2 greenValue - v0 greenValue.	minorDv _ v1 greenValue - v0 greenValue.	dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).	dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).	gAttr _ B3DPrimitiveFaceAttributes new.	gAttr value: v0 greenValue; dvdx: dvdx; dvdy: dvdy.	rAttr nextAttr: gAttr.	"Blue"	majorDv _ v2 blueValue - v0 blueValue.	minorDv _ v1 blueValue - v0 blueValue.	dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).	dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).	bAttr _ B3DPrimitiveFaceAttributes new.	bAttr value: v0 blueValue; dvdx: dvdx; dvdy: dvdy.	gAttr nextAttr: bAttr.	"Alpha"	majorDv _ v2 alphaValue - v0 alphaValue.	minorDv _ v1 alphaValue - v0 alphaValue.	dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).	dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).	aAttr _ B3DPrimitiveFaceAttributes new.	aAttr value: v0 alphaValue; dvdx: dvdx; dvdy: dvdy.	bAttr nextAttr: aAttr.	"W part"	texture == nil ifFalse:[		w0 _ v0 rasterPosW. w1 _ v1 rasterPosW. w2 _ v2 rasterPosW.		majorDv _ w2 - w0.		minorDv _ w1 - w0.		dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).		dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).		wAttr _ B3DPrimitiveFaceAttributes new.		wAttr value: w0; dvdx: dvdx; dvdy: dvdy.		aAttr nextAttr: wAttr.		baseValue _ v0 texCoordS * w0.		majorDv _ (v2 texCoordS * w2) - baseValue.		minorDv _ (v1 texCoordS * w1) - baseValue.		dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).		dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).		sAttr _ B3DPrimitiveFaceAttributes new.		sAttr value: baseValue; dvdx: dvdx; dvdy: dvdy.		wAttr nextAttr: sAttr.		baseValue _ v0 texCoordT * w0.		majorDv _ (v2 texCoordT * w2) - baseValue.		minorDv _ (v1 texCoordT * w1) - baseValue.		dvdx _ oneOverArea * ((majorDv * minorDy) - (minorDv * majorDy)).		dvdy _ oneOverArea * ((majorDx * minorDv) - (majorDv * minorDx)).		tAttr _ B3DPrimitiveFaceAttributes new.		tAttr value: baseValue; dvdx: dvdx; dvdy: dvdy.		sAttr nextAttr: tAttr.	].! !!B3DPrimitiveFace methodsFor: 'initialize' stamp: 'ar 4/4/1999 21:54'!v0: vtx0 v1: vtx1 v2: vtx2	v0 _ vtx0.	v1 _ vtx1.	v2 _ vtx2.	flags _ 0.! !!B3DPrimitiveFace methodsFor: 'initialize' stamp: 'ar 4/7/1999 01:01'!validateDepthSetup	oneOverArea = 0.0 ifTrue:[^self].	(v0 rasterPosZ - (self zValueAtX: v0 rasterPosX y: v0 rasterPosY)) abs >= 1.0e-10 		ifTrue:[self error:'Depth problem'].	(v1 rasterPosZ - (self zValueAtX: v1 rasterPosX y: v1 rasterPosY)) abs >= 1.0e-10 		ifTrue:[self error:'Depth problem'].	(v2 rasterPosZ - (self zValueAtX: v2 rasterPosX y: v2 rasterPosY)) abs >= 1.0e-10 		ifTrue:[self error:'Depth problem'].! !!B3DPrimitiveFace methodsFor: 'initialize' stamp: 'ar 4/3/1999 21:24'!validateVertexOrder	(v0 sortsBefore: v1) ifFalse:[self error:'Vertex order problem'].	(v0 sortsBefore: v2) ifFalse:[self error:'Vertex order problem'].	(v1 sortsBefore: v2) ifFalse:[self error:'Vertex order problem'].! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/6/1999 22:40'!attributes	^attributes! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 04:13'!dzdx	^dzdx! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 04:13'!dzdy	^dzdy! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:34'!flags	^flags! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:34'!flags: anInteger	flags _ anInteger! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 19:05'!leftEdge	^leftEdge! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 19:06'!leftEdge: anEdge	leftEdge _ anEdge! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 18:22'!maxZ	^maxZ! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 18:21'!minZ	^minZ! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:33'!nextFace	^nextFace! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:34'!nextFace: aFace	nextFace _ aFace! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 19:03'!oneOverArea	^oneOverArea! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:33'!prevFace	^prevFace! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 00:34'!prevFace: aFace	prevFace _ aFace! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 19:05'!rightEdge	^rightEdge! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/5/1999 19:06'!rightEdge: anEdge	rightEdge _ anEdge! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:20'!texture	^texture! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:20'!texture: aTexture	texture _ aTexture! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 21:32'!vertex0	^v0! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 21:32'!vertex1	^v1! !!B3DPrimitiveFace methodsFor: 'accessing' stamp: 'ar 4/3/1999 21:32'!vertex2	^v2! !!B3DPrimitiveFace methodsFor: 'processing' stamp: 'ar 4/18/1999 06:34'!attrValue: attr atX: xValue y: yValue	"Return the value of the attribute at position xValue@yValue"	^attr valueAtX: (xValue - v0 rasterPosX) y: (yValue - v0 rasterPosY).! !!B3DPrimitiveFace methodsFor: 'processing' stamp: 'ar 4/8/1999 04:31'!zValueAtX: xValue y: yValue	"Return the z value of the receiver at position xValue@yValue"	^v0 rasterPosZ +		(yValue - v0 rasterPosY * dzdy) +		(xValue - v0 rasterPosX * dzdx)! !!B3DPrimitiveFace methodsFor: 'printing' stamp: 'ar 4/5/1999 01:22'!printOn: aStream	super printOn: aStream.	aStream		nextPut:$(;		print: (v0 windowPos bitShiftPoint:-12);		nextPutAll:' - ';		print: (v1 windowPos bitShiftPoint: -12);		nextPutAll:' - ';		print: (v2 windowPos bitShiftPoint: -12);		nextPut:$).! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:33'!dvdx	^dvdx! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:33'!dvdx: aNumber	dvdx _ aNumber! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:33'!dvdy	^dvdy! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:33'!dvdy: aNumber	dvdy _ aNumber! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:32'!nextAttr	^nextAttr! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:32'!nextAttr: attr	nextAttr _ attr.! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:32'!value	^value! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:32'!value: aNumber	value _ aNumber! !!B3DPrimitiveFaceAttributes methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:34'!valueAtX: xValue y: yValue	"Return the value of the attribute at position xValue@yValue"	^value + (yValue * dvdy) + (xValue * dvdx)! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:43'!bounds	^bounds! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 04:49'!faces	^faces! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 04:49'!faces: anArray	faces _ anArray! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:44'!nextObj	^next! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:44'!nextObj: obj	next _ obj! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:44'!prevObj	^prev! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:45'!prevObj: obj	prev _ obj! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:56'!texture	^texture! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 06:56'!texture: aTexture	texture _ aTexture! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 04:49'!vertices	^vertices! !!B3DPrimitiveObject methodsFor: 'accessing' stamp: 'ar 4/18/1999 04:49'!vertices: anArray	vertices _ anArray! !!B3DPrimitiveObject methodsFor: 'processing' stamp: 'ar 4/18/1999 05:44'!mapVertices: viewport	"Map all the vertices in the receiver"	| xOfs yOfs xScale yScale w x y z scaledX scaledY first |	xOfs _ (viewport origin x + viewport corner x) * 0.5 - 0.5.	yOfs _ (viewport origin y + viewport corner y) * 0.5 - 0.5.	xScale _ (viewport corner x - viewport origin x) * 0.5.	yScale _ (viewport corner y - viewport origin y) * -0.5.	bounds _ 16r3FFFFFFF asPoint extent: 0@0.	minZ _ maxZ _ 0.0.	first _ true.	vertices do:[:vtx|		w _ vtx rasterPosW.		w = 0.0 ifFalse:[w _ 1.0 / w].		x _ vtx rasterPosX * w * xScale + xOfs.		y _ vtx rasterPosY * w * yScale + yOfs.		z _ vtx rasterPosZ * w.		vtx rasterPosW: w.		vtx rasterPosZ: z.		scaledX _ (x * 4096.0) asInteger.		scaledY _ (y * 4096.0) asInteger.		vtx windowPosX: scaledX.		vtx windowPosY: scaledY.		true ifTrue:[			vtx rasterPosX: scaledX / 4096.0.			vtx rasterPosY: scaledY / 4096.0.		] ifFalse:[			vtx rasterPosX: x.			vtx rasterPosY: y.		].		first ifTrue:[			bounds _ scaledX@scaledY extent: 0@0.			minZ _ maxZ _ z.			first _ false.		] ifFalse:[			bounds _ bounds encompass: scaledX@scaledY.			minZ _ minZ min: z. 			maxZ _ maxZ max: z.		].	].	bounds _ (bounds origin bitShiftPoint: -12) corner: (bounds corner bitShiftPoint: -12).! !!B3DPrimitiveObject methodsFor: 'processing' stamp: 'ar 4/18/1999 05:12'!setupVertexOrder	faces do:[:face| self setupVertexOrder: face].! !!B3DPrimitiveObject methodsFor: 'processing' stamp: 'ar 4/18/1999 05:10'!setupVertexOrder: face	| p1 p2 i1 i2 i3 p3  |	i1 _ face p1Index.	i2 _ face p2Index.	i3 _ face p3Index.	p1 _ vertices at: i1.	p2 _ vertices at: i2.	p3 _ vertices at: i3.	(p1 sortsBefore: p2) ifTrue:[		(p2 sortsBefore: p3) ifTrue:[			face p1Index: i1; p2Index: i2; p3Index: i3.		] ifFalse:[			(p1 sortsBefore: p3)				ifTrue:[face p1Index: i1; p2Index: i3; p3Index: i2]				ifFalse:[face p1Index: i3; p2Index: i1; p3Index: i2]		].	] ifFalse:[		(p1 sortsBefore: p3) ifTrue:[			face p1Index: i2; p2Index: i1; p3Index: i3.		] ifFalse:[			(p2 sortsBefore: p3)				ifTrue:[face p1Index: i2; p2Index: i3; p3Index: i1]				ifFalse:[face p1Index: i3; p2Index: i2; p3Index: i1]		]	].	B3DScanner doDebug ifTrue:[		p1 _ vertices at: face p1Index.		p2 _ vertices at: face p2Index.		p3 _ vertices at: face p3Index.		((p1 sortsBefore: p2) and:[(p2 sortsBefore: p3) and:[p1 sortsBefore: p3]])			ifFalse:[self error:'Vertex order problem'].	].! !!B3DPrimitiveObject methodsFor: 'processing' stamp: 'ar 4/18/1999 05:13'!sortInitialFaces	faces _ faces sortBy:[:face1 :face2| (vertices at: face1 p1Index) sortsBefore: (vertices at: face2 p1Index)].! !!B3DPrimitiveObject methodsFor: 'initialize' stamp: 'ar 4/18/1999 05:22'!reset	start _ 0.! !!B3DPrimitiveObject methodsFor: 'streaming' stamp: 'ar 4/18/1999 05:26'!atEnd	^start >= faces size! !!B3DPrimitiveObject methodsFor: 'streaming' stamp: 'ar 4/18/1999 06:55'!next	| iFace face |	iFace _ faces at: (start _ start + 1).	face _ B3DPrimitiveFace new.	face 		v0: (vertices at: iFace p1Index)		v1: (vertices at: iFace p2Index)		v2: (vertices at: iFace p3Index).	face texture: texture.	face initializePass1.	B3DScanner doDebug ifTrue:[		face validateVertexOrder.		face validateDepthSetup].	^face! !!B3DPrimitiveObject methodsFor: 'streaming' stamp: 'ar 4/18/1999 05:25'!peekY	^(vertices at: (faces at: start+1) p1Index) windowPosY! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/18/1999 06:26'!texCoordS	^self floatAt: 7! !!B3DPrimitiveVertex methodsFor: 'rasterizer-support' stamp: 'ar 4/18/1999 06:26'!texCoordT	^self floatAt: 8! !!B3DRenderEngine class methodsFor: 'accessing' stamp: 'ar 4/18/1999 05:27'!rasterizer	"Return the rasterizer to use with this engine"	^B3DSimulRasterizer! !!B3DScanner methodsFor: 'initialize' stamp: 'ar 4/18/1999 07:59'!initialize	aet _ B3DActiveEdgeTable new.	fillList _ B3DFillList new.	added _ B3DPrimitiveEdgeList new.	lastIntersection _ B3DPrimitiveEdge new.	nextIntersection _ B3DPrimitiveEdge new.	objects _ OrderedCollection new.! !!B3DScanner methodsFor: 'initialize' stamp: 'ar 4/18/1999 05:21'!setupObjects	"Set up the list of objects (e.g., triangle inputs)	by creating a linked list of objects which is sorted by the initial	yValue of the tris."	| lastObj |	objects _ objects sortBy: [:obj1 :obj2| obj1 bounds origin sortsBefore: obj2 bounds origin].	lastObj _ nil.	objects do:[:nextObj|		nextObj reset.		nextObj prevObj: lastObj.		lastObj == nil ifFalse:[lastObj nextObj: nextObj].		lastObj _ nextObj.	].	lastObj == nil ifFalse:[lastObj nextObj: nil].! !!B3DScanner methodsFor: 'public' stamp: 'ar 4/18/1999 05:15'!addObject: primObj	objects add: primObj.! !!B3DScanner methodsFor: 'public' stamp: 'ar 4/18/1999 05:29'!bitBlt: aBitBlt	bitBlt _ aBitBlt.! !!B3DScanner methodsFor: 'public' stamp: 'ar 4/18/1999 07:55'!mainLoop	| yValue nextObjY nextEdgeY obj activeStart passiveStart scaledY |	objects size = 0 ifTrue:[^self]. "No input"	self setupObjects. "Sort objects and create linked list"	nFaces _ maxFaces _ maxEdges _ 0.	"Pre-fetch first object to start from"	activeStart _ passiveStart _ objects at: 1.	yValue _ nextEdgeY _ nextObjY _ passiveStart bounds origin y.	[activeStart == nil and:[passiveStart == nil and:[aet isEmpty]]] whileFalse:[		"Add new objects if necessary"		yValue = nextObjY ifTrue:[			"Make sure we add edges from newly created objects"			nextEdgeY _ nextObjY.			"Add new objects"			[passiveStart notNil and:[passiveStart bounds origin y = nextObjY]]				whileTrue:[passiveStart _ passiveStart nextObj].			passiveStart == nil 				ifTrue:[nextObjY _ 99999]"Some large value"				ifFalse:[nextObjY _ passiveStart bounds origin y]. 		]. "End of adding new objects"		"Add new edges if necessary"		yValue = nextEdgeY ifTrue:[			nextEdgeY _ nextObjY bitShift: 12. "Some VERY large value"			scaledY _ (yValue+1) bitShift: 12.			obj _ activeStart.			[obj == passiveStart] whileFalse:[				[obj atEnd not and:[obj peekY < scaledY]]					whileTrue:[self addEdgesFromFace: obj next at: yValue].				obj atEnd ifTrue:[					obj == activeStart						ifTrue:[activeStart _ obj nextObj]						ifFalse:[obj prevObj nextObj: obj nextObj].				] ifFalse:[obj peekY < nextEdgeY ifTrue:[nextEdgeY _ obj peekY]].				obj _ obj nextObj.			].			nextEdgeY _ (nextEdgeY bitShift: -12).		].		added isEmpty ifFalse:[			"Merge new edges into AET"			"Note: These may be lower half edges."			B3DScanner doDebug ifTrue:[self validateAETOrder].			aet mergeEdgesFrom: added.			B3DScanner doDebug ifTrue:[				self validateAETOrder.				self validateEdgesFrom: aet].			added reset. "Clean up the list"		].		"This is the core loop."		"[yValue < nextEdgeY and:[added isEmpty and:[aet isEmpty not]]] whileTrue:["			B3DScanner doDebug ifTrue:[yValue printString displayAt: 0@0].			"gather stats"			maxEdges _ maxEdges max: aet size.			maxFaces _ maxFaces max: nFaces.			"Scan out the AET"			aet isEmpty ifFalse:[				self clearSpanBufferAt: yValue.				self scanAETAt: yValue.				self drawSpanBufferAt: yValue.				"Advance to next y and update AET"			].			yValue _ yValue + 1.			aet isEmpty ifFalse:[self updateAETAt: yValue].		"]."	].	nFaces = 0 ifFalse:[self error: nFaces printString,' remaining faces'].! !!B3DScanner methodsFor: 'public' stamp: 'ar 4/18/1999 05:31'!resetObjects	objects _ OrderedCollection new.! !!B3DScanner methodsFor: 'public' stamp: 'ar 4/18/1999 05:28'!spanBuffer: aBitmap	spanBuffer _ aBitmap.! !!B3DScanner methodsFor: 'aet adding' stamp: 'ar 4/18/1999 08:14'!addEdgesFromFace: face at: yValue	"Add the two top edges from the given face to the aet.	The top edges are (v0-v1) and (v0-v2) where (v0-v1) is 	the 'upper' half-edge of the triangle"	| xValue index needMajor needMinor majorEdge minorEdge |	face oneOverArea = 0.0 ifTrue:[^self].	needMinor _ needMajor _ true. "We need both edges"	majorEdge _ minorEdge _ nil.	xValue _ face vertex0 windowPosX.	"Search the insertion list to merge the edges of the face"	index _ added firstIndexForInserting: xValue.	index _ added xValue: xValue from: index do:[:edge|		(edge rightFace == nil and:[			"Note: edge vertex0 == face vertex0 should be the case for most meshes.				But since it is advantegous for the scanner to have two faces per edge				we're also checking for the actual vertex values."			edge vertex0 == face vertex0 or:[				edge vertex0 rasterPos = face vertex0 rasterPos]]) ifTrue:[			"This edge is a possible candidate for adding the face"			(needMajor and:["See above comment"				edge vertex1 == face vertex2 or:[					edge vertex1 rasterPos = face vertex2 rasterPos]]) ifTrue:[				majorEdge _ edge.				edge rightFace: face.				edge flags: (edge flags bitOr: FlagEdgeRightMajor).				nFaces _ nFaces + 1.				needMinor ifFalse:[					^self adjustFace: face major: majorEdge minor: minorEdge]. "Done."				needMajor _ false.			] ifFalse:[				(needMinor and:["See above comment"					edge vertex1 == face vertex1 or:[						edge vertex1 rasterPos = face vertex1 rasterPos]]) ifTrue:[					minorEdge _ edge.					edge rightFace: face.					edge flags: (edge flags bitOr: FlagContinueRightEdge).					needMajor ifFalse:[						^self adjustFace: face major: majorEdge minor: minorEdge]. "Done."					needMinor _ false.				].			].		].	].	"Need to add new edges.	NOTE: index already points to the right point for insertion."	needMajor ifTrue:[		majorEdge _ B3DPrimitiveEdge new.		majorEdge v0: face vertex0 v1: face vertex2.		majorEdge nLines = 0 ifTrue:[^self]. "Horizontal edge"		majorEdge leftFace: face.		majorEdge initializePass1.		majorEdge flags: (majorEdge flags bitOr: FlagEdgeLeftMajor).		nFaces _ nFaces + 1.	].	needMinor ifTrue:[		minorEdge _ B3DPrimitiveEdge new.		minorEdge v0: face vertex0 v1: face vertex1.		minorEdge leftFace: face.		minorEdge flags: FlagContinueLeftEdge.		"Note: If the (upper) minor edge is horizontal, use the lower one.		Note: The lower minor edge cannot be horizontal if the major one isn't"		minorEdge nLines = 0 ifTrue:[			needMajor ifTrue:[added add: majorEdge beforeIndex: index].			minorEdge _ self addLowerEdge: minorEdge fromFace: face.			minorEdge nLines = 0 ifTrue:[self error:'Minor edge is horizontal'].			^self adjustFace: face major: majorEdge minor: minorEdge].		minorEdge flags: FlagContinueLeftEdge.		minorEdge initializePass1.		minorEdge xValue = xValue ifFalse:[self error:'Problem with minor edge'].		minorEdge nLines = 0 ifTrue:[self error:'Minor edge is horizontal'].	].	needMajor & needMinor ifTrue:[		added add: majorEdge and: minorEdge beforeIndex: index.	] ifFalse:[		needMajor			ifTrue:[added add: majorEdge beforeIndex: index]			ifFalse:[added add: minorEdge beforeIndex: index].	].	^self adjustFace: face major: majorEdge minor: minorEdge.! !!B3DScanner methodsFor: 'aet adding' stamp: 'ar 4/18/1999 05:56'!addLowerEdge: oldEdge fromFace: face	"Add the lower edge (v1-v2) from the given face.	Return the newly created edge."	| index minorEdge xValue |	xValue _ face vertex1 windowPosX.	index _ added firstIndexForInserting: xValue.	index _ added xValue: xValue from: index do:[:edge|		(edge rightFace == nil and:[			"See the comment in #addEdgesFromFace:at:"			(edge vertex0 == face vertex1 and:[edge vertex1 == face vertex2]) or:[			edge vertex0 rasterPos = face vertex1 rasterPos and:[				edge vertex1 rasterPos = face vertex2 rasterPos]]]) ifTrue:[				"Adjust the left or right edge of the face"				face leftEdge == oldEdge					ifTrue:[face leftEdge: edge]					ifFalse:[face rightEdge: edge].				edge rightFace: face.				^edge			].	].	"Need to add new edge.	NOTE: index already points to the right point for insertion."	minorEdge _ B3DPrimitiveEdge new.	minorEdge v0: face vertex1 v1: face vertex2.	minorEdge nLines = 0 ifTrue:[^self]. "Horizontal"	"Adjust left/right edge of the face"	face leftEdge == oldEdge		ifTrue:[face leftEdge: minorEdge]		ifFalse:[face rightEdge: minorEdge].	minorEdge leftFace: face.	minorEdge initializePass1.	added add: minorEdge beforeIndex: index.	^minorEdge! !!B3DScanner methodsFor: 'aet adding' stamp: 'ar 4/8/1999 03:02'!adjustFace: face major: majorEdge minor: minorEdge	"Set the left/right edge of the face to the appropriate edges"	(majorEdge == nil or:[minorEdge == nil]) 		ifTrue:[^self error:'Edges must be non-nil'].	majorEdge xValue = minorEdge xValue ifTrue:[		"Most likely case. Both edges start at the same point.		Use dx/dy slope for determining which one is left and which one is right.		NOTE: 	We have this already computed during face>>initializePass1.				The value to use is the x increment at each scan line.		NOTE2: 	There is also a border case when minorEdge is actually the lower				edge of the triangle. If both xValues are equal, then the triangle				is degenerate (e.g., it's area is zero) in which case the meaning of				'left' or 'right' does not matter at all (and can thus be handled				by this simple test)."		majorEdge xIncrement <= minorEdge xIncrement			ifTrue:[	face leftEdge: majorEdge.					face rightEdge: minorEdge]			ifFalse:[	face leftEdge: minorEdge.					face rightEdge: majorEdge].	] ifFalse:[		"If the x values are not equal, simply use the edge with the smaller x value as 'left' edge"		majorEdge xValue < minorEdge xValue 			ifTrue:[	face leftEdge: majorEdge.					face rightEdge: minorEdge]			ifFalse:[	face leftEdge: minorEdge.					face rightEdge: majorEdge].	].! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/18/1999 05:57'!adjustIntersectionsAt: yValue from: topEdge	"The top face has changed. Adjust for possible intersections in the same scan line."	| frontFace backFace |	frontFace _ fillList first.	"If frontFace is nil then the fillList is empty.	If frontFace nextFace is nil then there is only one face in the list."	(frontFace == nil or:[frontFace nextFace == nil]) ifTrue:[^self].	"Now, search the fill list until we reach the first face with minZ > face maxZ.	Note that we have a linked list and can thus start from frontFace nextFace 	until we reach the end of the face list (nil)."	backFace _ frontFace nextFace.	[backFace == nil] whileFalse:[		(self checkIntersectionOf: frontFace with: backFace at: yValue edge: topEdge)			ifFalse:[^self]. "Aborted."		backFace _ backFace nextFace.	].! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/13/1999 01:00'!checkIntersectionOf: frontFace with: backFace at: yValue edge: leftEdge	"Compute the possible intersection of frontFace and backFace at the given y value.	Store the earliest intersection in nextIntersection. Return false if the face enumeration	should be aborted, true otherwise. leftEdge is the edge defining the left-most boundary	for possible intersections (e.g., all intersections have to be >= leftEdge xValue)"	| floatX floatY frontZ backZ xValue rightX |	backFace minZ >= frontFace maxZ ifTrue:[^false]. "Abort. Everything behind will be further away."	"Check for shared edge of faces"	frontFace leftEdge == backFace leftEdge ifTrue:[^true]. "Proceed."	frontFace rightEdge == backFace rightEdge ifTrue:[^true]. "Proceed."	"Check for newly created front face"	(frontFace leftEdge xValue bitShift: -12) = 		(frontFace rightEdge xValue bitShift: -12) ifTrue:[^false]. "Abort"	"Check for newly created back face"	(backFace leftEdge xValue bitShift: -12) = 		(backFace rightEdge xValue bitShift: -12) ifTrue:[^true]. "Proceed"	"Compute the z value of either frontFace or backFace depending on whose	right edge x value is less (so we test a point that is inside both faces)"	floatY _ yValue.	frontFace rightEdge xValue <= backFace rightEdge xValue ifTrue:[		"Use frontFace rightEdge as reference value"		frontZ _ frontFace rightEdge zValue.		rightX _ frontFace rightEdge xValue.		floatX _ rightX / 4096.0.		backZ _ backFace zValueAtX: floatX y: floatY.	] ifFalse:[		"Use backFace rightEdge as reference value"		backZ _ backFace rightEdge zValue.		rightX _ backFace rightEdge xValue.		floatX _ rightX / 4096.0.		frontZ _ frontFace zValueAtX: floatX y: floatY.	].	backZ < frontZ ifTrue:[		"Found a possible intersection."		xValue _ self computeIntersectionOf: frontFace with: backFace at: yValue ifError: leftEdge xValue.		"The following tests for numerical inaccuracies"		xValue > rightX ifTrue:[xValue _ rightX].		xValue < leftEdge xValue ifTrue:[			"In theory, this cannot happen. We may, however, have slight			numerical inaccuracies here, too. Conceptually, we treat these			intersections as if they occured immediately at the same 			fractional pixel in the scan line."			xValue _ leftEdge xValue].		(xValue bitShift: -12) = (leftEdge xValue bitShift: -12) ifTrue:[			"Intersections at the same pixel are ignored. Process it at the next pixel.			NOTE: This step is incredibly important!! It is by ignoring intersections			at the same pixel that we can never run in an endless repetition of			intersections at the same pixel value."			xValue _ (leftEdge xValue bitShift: -12) + 1 bitShift: 12.		].		xValue < nextIntersection xValue ifTrue:[			nextIntersection xValue: xValue.			nextIntersection leftFace: frontFace.			nextIntersection rightFace: backFace.		].	].	^true "proceed"! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/8/1999 03:14'!computeIntersectionOf: frontFace with: backFace at: yValue ifError: errorValue	"Compute the z intersection at the given y value"	| dx1 dz1 dx2 dz2 px pz det det2 |	dx1 _ frontFace rightEdge xValue - frontFace leftEdge xValue.	dz1 _ frontFace rightEdge zValue - frontFace leftEdge zValue.	dx2 _ backFace rightEdge xValue - backFace leftEdge xValue.	dz2 _ backFace rightEdge zValue - backFace leftEdge zValue.	px _ backFace leftEdge xValue - frontFace leftEdge xValue.	pz _ backFace leftEdge zValue - frontFace leftEdge zValue.	"Solve the linear equation using cramers rule"	det _ (dx1 * dz2) - (dx2 * dz1).	det = 0.0 ifTrue:[^errorValue].	"det1 _ (dx1 * pz) - (px * dz1)."	det2 _ (px * dz2) - (pz * dx2).	"det1 _ det1 / det."	det2 _ det2 / det.	^frontFace leftEdge xValue + (dx1 * det2) truncated! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/8/1999 03:15'!isOnTop: edge at: yValue	"Return true if the edge is on top of the current front face"	| topFace floatX floatY |	topFace _ fillList first.	topFace == nil ifTrue:[^true].	"Note: It is important to return true if the edge is shared by the top face"	(edge leftFace == topFace or:[edge rightFace == topFace]) ifTrue:[^true].	floatX _ edge xValue / 4096.0.	floatY _ yValue.	^edge zValue < (fillList first zValueAtX: floatX y:  floatY).! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/18/1999 07:23'!scanAETAt: yValue	"Scan out and draw the active edge table"	| leftEdge rightEdge tmp |	aet reset.	aet atEnd ifTrue:[^nil].	"Note the following is debug code that allows restarting this method	without getting confused by the face flags. In release mode, having	faces in the fillList here would be either an error or due to clipping	at the right boundary."	fillList do:[:face| face flags: (face flags bitXor: FlagFaceActive)].	fillList reset.	nextIntersection xValue: 16r3FFFFFFF. "Out of reach"	leftEdge _ aet next.	"No do the AET scan"	[aet atEnd] whileFalse:[		"The left edge here is always a top edge. Toggle its fills."		self toggleTopFillsOf: leftEdge at: yValue.		"After we got a new top face we have to adjust possible intersections."		self adjustIntersectionsAt: yValue from: leftEdge. 		"Search for the next top edge, which will be the right boundary."		rightEdge _ self searchForNewTopEdgeFrom: leftEdge at: yValue.		"And fill the stuff"		self fillFrom: leftEdge to: rightEdge at: yValue.		leftEdge _ rightEdge.		"Use a new intersection edge if necessary"		leftEdge == nextIntersection ifTrue:[			tmp _ nextIntersection.			nextIntersection _ lastIntersection.			lastIntersection _ tmp].		nextIntersection xValue: 16r3FFFFFFF "Must be waaaay off to the right ;-)"	].	self toggleBackFillsOf: leftEdge at: yValue validate: false.	fillList isEmpty ifFalse:[self error:'FillList not empty'].! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/18/1999 05:59'!searchForNewTopEdgeFrom: leftEdge at: yValue	"Find the next top edge in the AET. 	Note: We have to make sure that intersection edges are returned appropriately."	| edge topFace |	topFace _ fillList first.	topFace == nil ifTrue:[^aet next]. "Next edge must be top"	[aet atEnd] whileFalse:[		"Check if we have an intersection first."		nextIntersection xValue <= aet peek xValue ifTrue:[^nextIntersection].		edge _ aet next.		"Check if the edge is on top"		(self isOnTop: edge at: yValue) ifTrue:[^edge].		"If the edge is not on top, toggle the (back) fills of it"		self toggleBackFillsOf: edge at: yValue validate: true.	].	^nil! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/7/1999 04:40'!toggleBackFillsOf: edge at: yValue validate: aBool	"Toggle the faces of the (back) edge"	| face |	face _ edge leftFace.	(face flags anyMask: FlagFaceActive)		ifTrue:[	(aBool and:[face == fillList first]) ifTrue:[self error:'Not a back face'].				fillList remove: face]		ifFalse:[	fillList addBack: face.				"Check for possible intersections of back and front face"				self checkIntersectionOf: fillList first					with: face at: yValue edge: edge].	face flags: (face flags bitXor: FlagFaceActive).	face _ edge rightFace.	face == nil ifTrue:[^self].	(face flags anyMask: FlagFaceActive)		ifTrue:[	(aBool and:[face == fillList first]) ifTrue:[self error:'Not a back face'].				fillList remove: face]		ifFalse:[	fillList addBack: face.				"Check for possible intersections of back and front face"				self checkIntersectionOf: fillList first					with: face at: yValue edge: edge].	face flags: (face flags bitXor: FlagFaceActive).! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/5/1999 23:44'!toggleIntersectionEdge: edge	"Toggle the faces of the given intersection edge.	This is a *very* special case."	fillList first == edge leftFace ifFalse:[^self error:'Left face of intersection edge not top face'].	fillList remove: edge rightFace.	fillList addFront: edge rightFace. ! !!B3DScanner methodsFor: 'aet scanning' stamp: 'ar 4/18/1999 06:01'!toggleTopFillsOf: edge at: yValue	"Toggle the faces of the (new top) edge.	We must carefully treat each of the following cases:		1) rightFace notNil (e.g., two faces)			a) rightFace active ~= leftFace active				=> simply swap leftFace and rightFace in the face list			b) rightFace active not & leftFace active not				=> edge defines new boundary entry; check for minimal dxdz and insert in order			c) rightFace active & leftFace active				=> edge defines boundary exit; search all faces for minimal z value		2) rightFace isNil (e.g., single face)			a) leftFace active				=> edge defines boundary exit; see 1c)			b) leftFace active not				=> edge defines boundary entry; simply put it on top.	"	| leftFace rightFace xorMask noTest |	edge == lastIntersection 		ifTrue:[^self toggleIntersectionEdge: edge].	noTest _ true.	leftFace _ edge leftFace.	rightFace _ edge rightFace.	rightFace == nil ifTrue:[		(leftFace flags anyMask: FlagFaceActive)			ifTrue:[	leftFace == fillList first | noTest ifFalse:[self error:'Oops'].					fillList remove: leftFace.					fillList searchForNewTopAtX: edge xValue y: yValue]			ifFalse:[	fillList addFront: leftFace].		leftFace flags: (leftFace flags bitXor: FlagFaceActive).		^self].	"rightFace notNil"	xorMask _ leftFace flags bitXor: rightFace flags.	(xorMask anyMask: FlagFaceActive) ifTrue:[		"Simply swap"		(leftFace flags anyMask: FlagFaceActive)			ifTrue:[	leftFace == fillList first | noTest ifFalse:[self error:'Oops'].					fillList remove: leftFace.					fillList addFront: rightFace]			ifFalse:[	rightFace == fillList first | noTest ifFalse:[self error:'Oops'].					fillList remove: rightFace.					fillList addFront: leftFace].	] ifFalse:["rightFace active = leftFace active"		(leftFace flags anyMask: FlagFaceActive) ifTrue:[			(leftFace == fillList or:[rightFace == fillList first]) | noTest ifFalse:[self error:'Oops'].			fillList remove: leftFace.			fillList remove: rightFace.			fillList searchForNewTopAtX: edge xValue y: yValue.		] ifFalse:[			leftFace dzdx <= rightFace dzdx				ifTrue:[	fillList addFront: leftFace.						fillList addBack: rightFace]				ifFalse:[	fillList addFront: rightFace.						fillList addBack: leftFace].		].	].	leftFace flags: (leftFace flags bitXor: FlagFaceActive).	rightFace flags: (rightFace flags bitXor: FlagFaceActive).! !!B3DScanner methodsFor: 'aet updating' stamp: 'ar 4/18/1999 06:02'!updateAETAt: yValue	"Advance all entries in the AET by one scan line step"	| edge count |	aet reset.	[aet atEnd] whileFalse:[		edge _ aet next.		count _ edge nLines - 1.		count = 0 ifTrue:[			"Remove the edge from the AET.			If the continuation flag is set, create new (lower) edge(s)."			(edge vertex1 windowPosY bitShift: -12) = yValue				ifFalse:[self error:'Edge exceeds range'].			aet removeFirst.			(edge flags anyMask: FlagContinueLeftEdge)				ifTrue:[self addLowerEdge: edge fromFace: edge leftFace].			(edge flags anyMask: FlagContinueRightEdge) 				ifTrue:[self addLowerEdge: edge fromFace: edge rightFace].			(edge flags anyMask: FlagEdgeLeftMajor)				ifTrue:[nFaces _ nFaces - 1].			(edge flags anyMask: FlagEdgeRightMajor)				ifTrue:[nFaces _ nFaces - 1].		] ifFalse:[			"Edge continues. Adjust the number of scan lines remaining			and update the incremental values. Make sure that the sorting			order of the AET is not getting confused."			edge nLines: count. "# of scan lines"			edge stepToNextLine. "update incremental values"			aet resortFirst. "make sure edge is sorted right"		].	].! !!B3DScanner methodsFor: 'span drawing' stamp: 'ar 4/18/1999 05:45'!clearSpanBufferAt: yValue	spanBuffer primFill: 0.! !!B3DScanner methodsFor: 'span drawing' stamp: 'ar 4/18/1999 06:46'!drawSpanBufferAt: yValue	| leftX rightX |	leftX _ aet first xValue bitShift: -12.	rightX _ aet last xValue bitShift: -12.	bitBlt copyBitsFrom: leftX to: rightX at: yValue.! !!B3DScanner methodsFor: 'span drawing' stamp: 'ar 4/18/1999 06:55'!fillFrom: leftEdge to: rightEdge at: yValue	| face |	leftEdge xValue >= rightEdge xValue ifTrue:[^self]. "Nothing to do"	face _ fillList first.	face == nil ifTrue:[^self].	face texture == nil		ifTrue:[self rgbFill: face from: leftEdge to: rightEdge at: yValue]		ifFalse:[self rgbstwFill: face from: leftEdge to: rightEdge at: yValue]! !!B3DScanner methodsFor: 'span drawing' stamp: 'ar 4/18/1999 06:48'!rgbFill: face from: leftEdge to: rightEdge at: yValue	"Using only RGB (no alpha no textures)"	| leftX rightX floatY floatX rValue gValue bValue pv rAttr gAttr bAttr |	"Note: We always sample at pixel centers.	If the edges do not include this pixel center, do nothing.	Otherwise fill from leftX to rightX, including both pixels."	leftX _ (leftEdge xValue bitShift: -12) + 1.	rightX _ rightEdge xValue bitShift: -12.	leftX < 0 ifTrue:[leftX _ 0].	rightX >= spanBuffer size ifTrue:[rightX _ spanBuffer size-1].	leftX > rightX ifTrue:[^self].	B3DScanner doDebug ifTrue:[		"Sanity check."		(face leftEdge xValue > leftEdge xValue)			ifTrue:[				(face rightEdge xValue < rightEdge xValue)					ifTrue:[self error:'Filling outside face']					ifFalse:[self error:'Filling left of face'].		] ifFalse:[(face rightEdge xValue < rightEdge xValue)						ifTrue:[self error:'Filling right of face']].	].	(face flags anyMask: FlagFaceInitialized) ifFalse:[		face initializePass2.		face flags: (face flags bitOr: FlagFaceInitialized)].	"@@: Sampling problem!!"	floatY _ yValue + 0.5.	floatX _ leftX.	rAttr _ face attributes.	gAttr _ rAttr nextAttr.	bAttr _ gAttr nextAttr.	rValue _ (face attrValue: rAttr atX: floatX y: floatY).	gValue _ (face attrValue: gAttr atX: floatX y: floatY).	bValue _ (face attrValue: bAttr atX: floatX y: floatY).	[leftX <= rightX] whileTrue:[		rValue _ rValue min: 255.0 max: 0.0.		gValue _ gValue min: 255.0 max: 0.0.		bValue _ bValue min: 255.0 max: 0.0.		pv _ (bValue truncated) +				(gValue truncated bitShift: 8) +					(rValue truncated bitShift: 16).		spanBuffer at: (leftX _ leftX+1) put: (pv bitOr: 4278190080).		rValue _ rValue + rAttr dvdx.		gValue _ gValue + gAttr dvdx.		bValue _ bValue + bAttr dvdx].! !!B3DScanner methodsFor: 'span drawing' stamp: 'ar 4/18/1999 07:22'!rgbstwFill: face from: leftEdge to: rightEdge at: yValue	"Using only RGB & STW (no alpha)"	| leftX rightX floatY floatX rValue gValue bValue pv rAttr gAttr bAttr aAttr wAttr sAttr tAttr wValue sValue tValue texColor |	"Note: We always sample at pixel centers.	If the edges do not include this pixel center, do nothing.	Otherwise fill from leftX to rightX, including both pixels."	leftX _ (leftEdge xValue bitShift: -12) + 1.	rightX _ rightEdge xValue bitShift: -12.	leftX < 0 ifTrue:[leftX _ 0].	rightX >= spanBuffer size ifTrue:[rightX _ spanBuffer size-1].	leftX > rightX ifTrue:[^self].	B3DScanner doDebug ifTrue:[		"Sanity check."		(face leftEdge xValue > leftEdge xValue)			ifTrue:[				(face rightEdge xValue < rightEdge xValue)					ifTrue:[self error:'Filling outside face']					ifFalse:[self error:'Filling left of face'].		] ifFalse:[(face rightEdge xValue < rightEdge xValue)						ifTrue:[self error:'Filling right of face']].	].	(face flags anyMask: FlagFaceInitialized) ifFalse:[		face initializePass2.		face flags: (face flags bitOr: FlagFaceInitialized)].	"@@: Sampling problem!!"	floatY _ yValue + 0.5.	floatX _ leftX.	rAttr _ face attributes.	gAttr _ rAttr nextAttr.	bAttr _ gAttr nextAttr.	aAttr _ bAttr nextAttr.	wAttr _ aAttr nextAttr.	sAttr _ wAttr nextAttr.	tAttr _ sAttr nextAttr.	rValue _ (face attrValue: rAttr atX: floatX y: floatY).	gValue _ (face attrValue: gAttr atX: floatX y: floatY).	bValue _ (face attrValue: bAttr atX: floatX y: floatY).	wValue _ (face attrValue: wAttr atX: floatX y: floatY).	sValue _ (face attrValue: sAttr atX: floatX y: floatY).	tValue _ (face attrValue: tAttr atX: floatX y: floatY).	[leftX <= rightX] whileTrue:[		rValue _ rValue min: 255.0 max: 0.0.		gValue _ gValue min: 255.0 max: 0.0.		bValue _ bValue min: 255.0 max: 0.0.		texColor _ self textureColor: face texture atS: (sValue / wValue) atT: (tValue / wValue).		pv _ (bValue * texColor blue) truncated +				((gValue * texColor green) truncated bitShift: 8) +					((rValue * texColor red) truncated bitShift: 16).		spanBuffer at: (leftX _ leftX+1) put: (pv bitOr: 4278190080).		rValue _ rValue + rAttr dvdx.		gValue _ gValue + gAttr dvdx.		bValue _ bValue + bAttr dvdx.		wValue _ wValue + wAttr dvdx.		sValue _ sValue + sAttr dvdx.		tValue _ tValue + tAttr dvdx].! !!B3DScanner methodsFor: 'span drawing' stamp: 'ar 4/18/1999 07:23'!textureColor: aTexture atS: sValue atT: tValue	"Return the interpolated color of the given texture at s/t"	| w h fragS fragT sIndex tIndex peeker tex00 tex01 tex10 tex11 sFrac tFrac mixed |	w _ aTexture width.	h _ aTexture height.	fragS _ w * sValue.	fragT _ h * tValue.	sIndex _ fragS truncated.	tIndex _ fragT truncated.	peeker _ BitBlt bitPeekerFromForm: aTexture.	tex00 _ (peeker pixelAt: (sIndex \\ w)@(tIndex \\ h)) asColorOfDepth: aTexture depth.	tex01 _ (peeker pixelAt: (sIndex+1 \\ w)@(tIndex \\ h)) asColorOfDepth: aTexture depth.	tex10 _ (peeker pixelAt: (sIndex \\ w)@(tIndex+1 \\ h)) asColorOfDepth: aTexture depth.	tex11 _ (peeker pixelAt: (sIndex+1 \\ w)@(tIndex+1 \\ h)) asColorOfDepth: aTexture depth.	sFrac _ fragS \\ 1.0.	tFrac _ fragT \\ 1.0.	mixed _ ((1.0 - tFrac) * (((1.0 - sFrac) * tex00 asB3DColor) + (sFrac * tex01 asB3DColor))) +			(tFrac * (((1.0 - sFrac) * tex10 asB3DColor) + (sFrac * tex11 asB3DColor))).	^mixed! !!B3DScanner methodsFor: 'misc' stamp: 'ar 4/6/1999 03:49'!validateAETOrder	| last next |	aet isEmpty ifTrue:[^self].	aet reset.	last _ aet next.	[aet atEnd] whileFalse:[		next _ aet next.		last xValue <= next xValue ifFalse:[^self error:'AET is broken'].		last _ next].! !!B3DScanner methodsFor: 'misc' stamp: 'ar 4/7/1999 05:20'!validateEdgesFrom: aCollection	"aCollection must contain two entries for each face."	| faceNum face faces |	faceNum _ 0.	aCollection do:[:edge|		edge leftFace ifNil:[self error:'Bad edge'] ifNotNil:[faceNum _ faceNum + 1].		edge rightFace ifNotNil:[faceNum _ faceNum + 1].	].	faceNum \\ 2 = 0 ifTrue:[^self].	faces _ Bag new.	aCollection do:[:edge|		face _ edge leftFace.		faces add: face.		(aet indexOf: face leftEdge) = 0 ifTrue:[self error:'Left edge not in AET'].		(aet indexOf: face rightEdge) = 0 ifTrue:[self error:'Right edge not in AET'].		face _ edge rightFace.		face == nil ifFalse:[			faces add: face.			(aet indexOf: face leftEdge) = 0 ifTrue:[self error:'Left edge not in AET'].			(aet indexOf: face rightEdge) = 0 ifTrue:[self error:'Right edge not in AET'].		].	].	self error:'Something *IS* wrong here'.! !!B3DScanner class methodsFor: 'class initialization' stamp: 'ar 4/8/1999 18:30'!initialize	"B3DScanner initialize"	FlagContinueLeftEdge _ 1.	FlagContinueRightEdge _ 2.	FlagEdgeLeftMajor _ 4.	FlagEdgeRightMajor _ 8.	FlagFaceActive _ 1.	FlagFaceInitialized _ 2.! !!B3DScanner class methodsFor: 'instance creation' stamp: 'ar 4/4/1999 04:27'!new	^super new initialize! !!B3DScanner class methodsFor: 'accessing' stamp: 'ar 4/18/1999 07:24'!doDebug	^DebugMode == true! !!B3DScanner class methodsFor: 'accessing' stamp: 'ar 4/18/1999 07:25'!doDebug: aBool	"B3DScanner doDebug: true"	"B3DScanner doDebug: false"	DebugMode _ aBool.! !!B3DSimulRasterizer methodsFor: 'initialize' stamp: 'ar 4/18/1999 04:34'!canvas: aCanvas	| bb span sourceForm destForm |	canvas _ aCanvas.	span _ Bitmap new: 2048.	sourceForm _ Form extent: span size@1 depth: 32 bits: span.	destForm _ aCanvas form.	bb _ BitBlt toForm: destForm.	bb sourceForm: sourceForm.	bb colorMap: (sourceForm colormapIfNeededForDepth: destForm depth).	bb combinationRule: 34 "Form paint". "Later we'll change this to 34 for alpha blending"	bb clipRect: (aCanvas clipRect translateBy: aCanvas origin).	bb destX: 0; destY: 0; sourceX: 0; sourceY: 0; width: 1; height: 1.	scanner spanBuffer: span.	scanner bitBlt: bb.! !!B3DSimulRasterizer methodsFor: 'initialize' stamp: 'ar 4/18/1999 04:35'!flush	self mainLoop.! !!B3DSimulRasterizer methodsFor: 'initialize' stamp: 'ar 4/18/1999 04:36'!initialize	super initialize.	scanner _ B3DScanner new.! !!B3DSimulRasterizer methodsFor: 'initialize' stamp: 'ar 4/18/1999 04:36'!reset	super reset.	scanner _ B3DScanner new.! !!B3DSimulRasterizer methodsFor: 'accessing' stamp: 'ar 4/18/1999 04:36'!viewport: vp	canvas == nil		ifTrue:[super viewport: vp]		ifFalse:[super viewport: (vp translateBy: canvas origin)].	viewport toggleYScale.! !!B3DSimulRasterizer methodsFor: 'testing' stamp: 'ar 4/18/1999 04:36'!needsClip	^true! !!B3DSimulRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 07:32'!clearViewport: aColor	canvas ifNotNil:[canvas fillRectangle: viewport color: aColor asColor]! !!B3DSimulRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 04:48'!loadVerticesFrom: vb	| out vtxArray |	vtxArray _ vb vertexArray.	out _ Array new: vb vertexCount.	1 to: vb vertexCount do:[:i|		out at: i put: (vtxArray at: i).	].	^out! !!B3DSimulRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 05:31'!mainLoop	scanner mainLoop.	scanner resetObjects.! !!B3DSimulRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 07:34'!processIndexedQuads: vb	| vtxArray out idx1 idxArray idx2 idx3 face obj idx4 |	vtxArray _ self loadVerticesFrom: vb.	idxArray _ vb indexArray.	out _ WriteStream on: (B3DIndexedTriangleArray new: vb indexCount // 3 * 2).	1 to: vb indexCount by: 4 do:[:i|		idx1 _ idxArray at: i.		idx2 _ idxArray at: i+1.		idx3 _ idxArray at: i+2.		idx4 _ idxArray at: i+3.		idx1 = 0 ifFalse:[			face _ B3DIndexedTriangle with: idx1 with: idx2 with: idx3.			out nextPut: face.			face _ B3DIndexedTriangle with: idx3 with: idx4 with: idx1.			out nextPut: face].	].	obj _ B3DPrimitiveObject new.	obj faces: out contents.	obj vertices: vtxArray.	obj texture: texture.	obj mapVertices: viewport.	obj setupVertexOrder.	obj sortInitialFaces.	scanner addObject: obj.! !!B3DSimulRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 06:55'!processIndexedTriangles: vb	| vtxArray out idx1 idxArray idx2 idx3 face obj |	vtxArray _ self loadVerticesFrom: vb.	idxArray _ vb indexArray.	out _ WriteStream on: (B3DIndexedTriangleArray new: vb indexCount // 3).	1 to: vb indexCount by: 3 do:[:i|		idx1 _ idxArray at: i.		idx2 _ idxArray at: i+1.		idx3 _ idxArray at: i+2.		idx1 = 0 ifFalse:[			face _ B3DIndexedTriangle with: idx1 with: idx2 with: idx3.			out nextPut: face].	].	obj _ B3DPrimitiveObject new.	obj faces: out contents.	obj vertices: vtxArray.	obj texture: texture.	obj mapVertices: viewport.	obj setupVertexOrder.	obj sortInitialFaces.	scanner addObject: obj.! !!B3DSimulRasterizer methodsFor: 'processing' stamp: 'ar 4/18/1999 07:56'!processPolygon: vb	| vtxArray out face obj |	vtxArray _ self loadVerticesFrom: vb.	out _ WriteStream on: (B3DIndexedTriangleArray new: vtxArray size - 2).	3 to: vb vertexCount do:[:i|		face _ B3DIndexedTriangle with: 1 with: i-1 with: i.		out nextPut: face.	].	obj _ B3DPrimitiveObject new.	obj faces: out contents.	obj vertices: vtxArray.	obj texture: texture.	obj mapVertices: viewport.	obj setupVertexOrder.	obj sortInitialFaces.	scanner addObject: obj.! !!Point methodsFor: 'point functions' stamp: 'ar 4/18/1999 05:17'!sortsBefore: otherPoint	"Return true if the receiver sorts before the other point"	^y = otherPoint y		ifTrue:[x <= otherPoint x]		ifFalse:[y <= otherPoint y]! !!Point methodsFor: 'private' stamp: 'ar 4/4/1999 00:40'!bitShiftPoint: bits	x _ x bitShift: bits.	y _ y bitShift: bits.! !B3DActiveEdgeTable removeSelector: #xValue:from:do:!B3DActiveEdgeTable removeSelector: #indexForInserting:!B3DActiveEdgeTable removeSelector: #firstIndexForInserting:!B3DActiveEdgeTable removeSelector: #add:!B3DActiveEdgeTable removeSelector: #add:and:!B3DActiveEdgeTable removeSelector: #lastIndexForInserting:!B3DPrimitiveFace removeSelector: #gValueAtX:y:!B3DPrimitiveFace removeSelector: #rValueAtX:y:!B3DPrimitiveFace removeSelector: #aValueAtX:y:!B3DPrimitiveFace removeSelector: #bValueAtX:y:!B3DPrimitiveFace removeSelector: #wValueAtX:y:!B3DPrimitiveFace removeSelector: #setupVertexOrder!B3DPrimitiveFace removeSelector: #validateRGBASetup!B3DPrimitiveFaceAttributes removeSelector: #dbdx!B3DPrimitiveFaceAttributes removeSelector: #dbdy:!B3DPrimitiveFaceAttributes removeSelector: #wValue!B3DPrimitiveFaceAttributes removeSelector: #dgdx!B3DPrimitiveFaceAttributes removeSelector: #rValue:!B3DPrimitiveFaceAttributes removeSelector: #dwdx:!B3DPrimitiveFaceAttributes removeSelector: #drdy:!B3DPrimitiveFaceAttributes removeSelector: #gValue:!B3DPrimitiveFaceAttributes removeSelector: #drdy!B3DPrimitiveFaceAttributes removeSelector: #dady:!B3DPrimitiveFaceAttributes removeSelector: #dbdx:!B3DPrimitiveFaceAttributes removeSelector: #dadx!B3DPrimitiveFaceAttributes removeSelector: #dwdy:!B3DPrimitiveFaceAttributes removeSelector: #dbdy!B3DPrimitiveFaceAttributes removeSelector: #dadx:!B3DPrimitiveFaceAttributes removeSelector: #drdx!B3DPrimitiveFaceAttributes removeSelector: #aValue!B3DPrimitiveFaceAttributes removeSelector: #bValue:!B3DPrimitiveFaceAttributes removeSelector: #dady!B3DPrimitiveFaceAttributes removeSelector: #bValue!B3DPrimitiveFaceAttributes removeSelector: #gValue!B3DPrimitiveFaceAttributes removeSelector: #aValue:!B3DPrimitiveFaceAttributes removeSelector: #dwdx!B3DPrimitiveFaceAttributes removeSelector: #dgdx:!B3DPrimitiveFaceAttributes removeSelector: #dgdy:!B3DPrimitiveFaceAttributes removeSelector: #dgdy!B3DPrimitiveFaceAttributes removeSelector: #drdx:!B3DPrimitiveFaceAttributes removeSelector: #rValue!B3DPrimitiveFaceAttributes removeSelector: #wValue:!B3DPrimitiveFaceAttributes removeSelector: #dwdy!B3DScanner removeSelector: #trulyFill:from:to:at:!B3DScanner removeSelector: #faces:!B3DScanner removeSelector: #noAlphaFill:from:to:at:!B3DScanner removeSelector: #validateFaceEdges!B3DScanner removeSelector: #stopAndDrawAt:!B3DScanner removeSelector: #wFill:from:to:at:!B3DScanner removeSelector: #searchNewTopAtX:y:!B3DScanner removeSelector: #clearLineAt:!B3DScanner removeSelector: #maxX!B3DScanner removeSelector: #printStats!B3DScanner initialize!B3DSimulRasterizer removeSelector: #convertTriangleVB:!B3DSimulRasterizer removeSelector: #process:!B3DSimulRasterizer removeSelector: #mapVertexBuffer:!Smalltalk removeClassNamed: #B3DInputList!Smalltalk removeClassNamed: #B3DSimulEngine!