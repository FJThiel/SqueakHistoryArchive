'From Squeakland 3.8.5976 of 25 August 2004 [latest update: #348] on 1 November 2004 at 11:29:46 am'!"Change Set:		specificEvents-nkDate:			1 November 2004Author:			Ned KonzMakes the display and availability of event triggers limited to the events that this morph could actually receive.For instance, we'd been displaying events like sourceConnected for all morphs, when in fact only Connectors could receive them.Also clarifies some of the event help texts.Derived frtom Squeakland update 0367specificEvents-nk.cs, but this variant includes only code for non-Connectors-specific classes."!!AlansTextPlusMorph class methodsFor: '*customevents-class initialization' stamp: 'nk 11/1/2004 07:48'!initialize	"AlansTextPlusMorph initialize"	ScriptingSystem addCustomEventFor: self named: #scrolledIntoView help: 'when I am scrolled into view in a GeeMailMorph' targetMorphClass: Morph.	ScriptingSystem addCustomEventFor: self named: #scrolledOutOfView help: 'when I am scrolled out of view in a GeeMailMorph'  targetMorphClass: Morph.! !!ScriptEditorMorph methodsFor: '*customevents-other' stamp: 'nk 11/1/2004 08:13'!explainStatusAlternatives	(StringHolder new contents: (ScriptingSystem statusHelpStringFor: playerScripted))		openLabel: 'Script Status' translated! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 11/1/2004 08:13'!explainStatusAlternatives	"Open a little window that explains the various status 	alternatives "	(StringHolder new contents: (ScriptingSystem statusHelpStringFor: player))		openLabel: 'Script Status' translated! !!ScriptInstantiation methodsFor: '*customevents-status control' stamp: 'nk 11/1/2004 07:53'!presentScriptStatusPopUp	"Put up a menu of status alternatives and carry out the request"	| reply  m menu submenu |	menu _ MenuMorph new.	self addStatusChoices: #( normal " -- run when called" ) toMenu: menu.	self addStatusChoices: 		#(	paused 		"ready to run all the time"			ticking			"run all the time" )		toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati copyFrom: 1 to: 3) toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati allButFirst: 3) toMenu: menu.	self addStatusChoices: 		#(opening			"when I am being opened"			closing			"when I am being closed" )		toMenu: menu.		submenu _ MenuMorph new.	self addStatusChoices: (ScriptingSystem globalCustomEventNamesFor: player) toSubMenu: submenu forMenu: menu.	menu add: 'more... ' translated subMenu: submenu.	(Preferences allowEtoyUserCustomEvents) ifTrue: [		submenu addLine.		self addStatusChoices: ScriptingSystem userCustomEventNames toSubMenu: submenu forMenu: menu.		submenu addLine.		self addStatusChoices:			(Array streamContents: [ :s | s nextPut: { 'define a new custom event'. #defineNewEvent }.			ScriptingSystem userCustomEventNames isEmpty				ifFalse: [ s nextPut: { 'delete a custom event'. #deleteCustomEvent } ]])			toSubMenu: submenu forMenu: menu ].		menu addLine.	self addStatusChoices: #(		('what do these mean?'explainStatusAlternatives)		('apply my status to all siblings' assignStatusToAllSiblings) ) toMenu: menu.	menu addTitle: 'When should this script run?' translated.	menu submorphs last delete.	menu invokeModal.		reply := menu modalSelection.	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply == #assignStatusToAllSiblings ifTrue: [^ self assignStatusToAllSiblings].	reply == #defineNewEvent ifTrue: [ ^self defineNewEvent ].	reply == #deleteCustomEvent ifTrue: [ ^self deleteCustomEvent ].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m _ player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs]! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 11/1/2004 07:47'!addCustomEventFor: registrantClass named: aSymbol help: helpString targetMorphClass: targetClass	| registration |	registration _ self customEventsRegistry at: aSymbol ifAbsentPut: [ IdentityDictionary new ].	registration at: registrantClass put: { helpString. targetClass }.! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 11/1/2004 08:19'!customEventNamesAndHelpStringsFor: aPlayer	| retval help helpStrings morph |	morph := aPlayer costume renderedMorph.	retval := SortedCollection sortBlock: [ :a :b | a first < b first ].	self customEventsRegistry		keysAndValuesDo: [ :k :v |			helpStrings := Array streamContents: [ :hsStream |				v keysAndValuesDo: [ :registrant :array |					(morph isKindOf: array second) ifTrue: [						help := String streamContents: [ :stream |										v size > 1											ifTrue: [ stream nextPut: $(;													nextPutAll: array second name;													nextPut: $);													space ].										stream nextPutAll: array first ].						hsStream nextPut: help ]]].			helpStrings isEmpty ifFalse: [retval add: { k. helpStrings } ]].	^ retval! !!StandardScriptingSystem methodsFor: '*customevents-custom events' stamp: 'nk 11/1/2004 07:56'!globalCustomEventNamesFor: aPlayer	| morph names |	morph := aPlayer costume renderedMorph.	names := SortedCollection new.	self customEventsRegistry keysAndValuesDo: [ :k :v |		(v anySatisfy: [ :array | morph isKindOf: array second ])			ifTrue: [ names add: k ]].	^names asArray! !!StandardScriptingSystem methodsFor: '*customevents-help dictionary' stamp: 'nk 11/1/2004 08:21'!statusHelpStringFor: aPlayer	^String streamContents: [ :stream |		stream nextPutAll: 'normal -- run when calledpaused -- ready to run all the timeticking -- run all the timemouseDown -- run when mouse goes down on memouseStillDown -- while mouse still downmouseUp -- when mouse comes back upmouseEnter -- when mouse enters my bounds, button upmouseLeave -- when mouse exits my bounds, button upmouseEnterDragging -- when mouse enters my bounds, button downmouseLeaveDragging -- when mouse exits my bounds, button downopening -- when I am being openedclosing -- when I am being closed' translated."'keyStroke -- run when user hits a key' "	stream cr; cr; nextPutAll: 'More events:' translated; cr.	(self customEventNamesAndHelpStringsFor: aPlayer) do: [ :array |		stream cr;		nextPutAll: array first;		nextPutAll: ' -- '.		array second do: [ :help | stream nextPutAll: help translated ]			separatedBy: [ stream nextPutAll: ' or ' translated ]].	(Preferences allowEtoyUserCustomEvents) ifTrue: [	self userCustomEventNames isEmpty ifFalse: [		stream cr; cr; nextPutAll: 'User custom events:' translated; cr.		self currentWorld userCustomEventsRegistry keysAndValuesDo: [ :key :value |			stream cr; nextPutAll: key; nextPutAll: ' -- '; nextPutAll: value ]]]]! !StandardScriptingSystem removeSelector: #addCustomEventFor:named:help:!StandardScriptingSystem removeSelector: #customEventNamesAndHelpStrings!StandardScriptingSystem removeSelector: #statusHelpString!AlansTextPlusMorph initialize!"Postscript:Reset the event registrations with the new format."AlansTextPlusMorph initialize.!