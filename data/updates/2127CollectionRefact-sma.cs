'From Squeak2.8alpha of 4 February 2000 [latest update: #2098] on 12 May 2000 at 6:18:36 pm'!!Object methodsFor: 'converting' stamp: 'sma 5/12/2000 17:39'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!BlockContext methodsFor: 'controlling' stamp: 'sma 5/12/2000 13:22'!repeat	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."	[self value. true] whileTrue! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:33'!anyOne	"Answer a representative sample of the receiver. This method can	be helpful when needing to preinfer the nature of the contents of 	semi-homogeneous collections."	self emptyCheck.	self do: [:each | ^ each]! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:41'!capacity	"Answer the current capacity of the receiver."	^ self size! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:34'!size	"Answer how many elements the receiver contains."	| tally |	tally _ 0.	self do: [:each | tally _ tally + 1].	^ tally! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:21'!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:26'!addAll: aCollection 	"Include all the elements of aCollection as the receiver's elements. Answer 	aCollection. Actually, any object responding to #do: can be used as argument."	aCollection do: [:each | self add: each].	^ aCollection! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:23'!addIfNotPresent: anObject	"Include anObject as one of the receiver's elements, but only if there	is no such element already. Anwser anObject."	(self includes: anObject) ifFalse: [self add: anObject].	^ anObject! !!Collection methodsFor: 'comparing' stamp: 'sma 5/12/2000 12:08'!hash	"A default hash function for any collection.  Note that this method is 	insensitive to contents when the size is greater than 10, so critical 	applications that compare many large collections of the same length 	will want to refine this behavior."	| hash |	hash _ self species hash.	self size <= 10 ifTrue: [self do: [:elem | hash _ hash bitXor: elem hash]].	^ hash bitXor: self size hash! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array _ Array new: self size.	index _ 0.	self do: [:each | array at: (index _ index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:10'!asBag	"Answer a Bag whose elements are the elements of the receiver."	^ Bag withAll: self! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver.	Implementation note: Cannot use ''ByteArray withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array _ ByteArray new: self size.	index _ 0.	self do: [:each | array at: (index _ index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:26'!asCharacterSet	"Answer a CharacterSet whose elements are the unique elements of the receiver.	The reciever should only contain characters."	^ CharacterSet newFrom: self! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:43'!asOrderedCollection	"Answer an OrderedCollection whose elements are the elements of the	receiver. The order in which elements are added depends on the order	in which the receiver enumerates its elements. In the case of unordered	collections, the ordering is not necessarily the same for multiple 	requests for the conversion."	^ self as: OrderedCollection! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:29'!asSet	"Answer a Set whose elements are the unique elements of the receiver."	^ Set withAll: self! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:44'!asSortedCollection	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is the default less than or equal."	^ self as: SortedCollection! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:46'!asSortedCollection: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection _ SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 14:41'!copyWith: newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	^ self copy		add: newElement;		yourself! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 14:43'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self reject: [:each | each = oldElement]"Examples:	'fred the bear' copyWithout: $e	#(2 3 4 5 5 6) copyWithout: 5"! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 18:08'!copyWithoutAll: aCollection	"Answer a copy of the receiver that does not contain any elements 	equal to those in aCollection."	^ self reject: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:45'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:51'!collect: collectBlock thenSelect: selectBlock	"Utility method to improve readability."	^ (self collect: collectBlock) select: selectBlock! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum _ 0.	self do: [:each | (aBlock value: each) ifTrue: [sum _ sum + 1]].	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:20'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 17:52'!difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:57'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst _ true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst _ false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:59'!do: aBlock without: anItem 	"Enumerate all elements in the receiver. 	Execute aBlock for those elements that are not equal to the given item"	^ self do: [:each | anItem = each ifFalse: [aBlock value: each]]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 17:52'!intersection: aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:59'!select: selectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 17:54'!union: aCollection	"Answer the set theoretic union of two collections."	^ self asSet addAll: aCollection; yourself! !!Collection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 12:07'!contents	^ self! !!Collection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 12:08'!flattenOnStream: aStream 	^ aStream writeCollection: self! !!Collection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 12:07'!write: anObject 	^ self add: anObject! !!Collection methodsFor: 'printing' stamp: 'sma 5/12/2000 12:02'!printOn: aStream 	"Append a sequence of characters that identify the receiver to aStream."	aStream nextPutAll: self class name; space; nextPut: $(.	self do: [:each | aStream print: each; space].	aStream nextPut: $)! !!Collection methodsFor: 'private' stamp: 'sma 5/12/2000 11:22'!errorNotFound: anObject	"Actually, this should raise a special Exception not just an error."	self error: 'Object is not in the collection.'! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:22'!remove: oldObject 	"Remove oldObject from the receiver's elements. Answer oldObject 	unless no element is equal to oldObject, in which case, raise an error.	ArrayedCollections cannot respond to this message."	^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:14'!remove: oldObject ifAbsent: anExceptionBlock 	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject. ArrayedCollections cannot 	respond to this message."	self subclassResponsibility! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:14'!removeAll: aCollection 	"Remove each element of aCollection from the receiver. If successful for 	each, answer aCollection. Otherwise create an error notification.	ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:16'!removeAllFoundIn: aCollection 	"Remove each element of aCollection which is present in the receiver 	from the receiver. Answer aCollection. No error is raised if an element	isn't found. ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each ifAbsent: []].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:19'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element and remove all that elements from	the receiver for that aBlock evaluates to true.  Use a copy to enumerate 	collections whose order changes when an element is removed (i.e. Sets)."	self copy do: [:each | (aBlock value: each) ifTrue: [self remove: each]]! !!Collection methodsFor: 'testing' stamp: 'sma 5/12/2000 14:07'!includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^ self anySatisfy: [:each | each = anObject]! !!Collection methodsFor: 'testing' stamp: 'sma 5/12/2000 17:49'!notEmpty	"Answer whether the receiver contains any elements."	^ self isEmpty not! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 17:23'!at: index 	self errorNotKeyed! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 17:23'!at: index put: anObject 	self errorNotKeyed! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:35'!size	"Answer how many elements the receiver contains."	| tally |	tally _ 0.	contents do: [:each | tally _ tally + each].	^ tally! !!Bag methodsFor: 'adding' stamp: 'sma 5/12/2000 17:18'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject."	^ self add: newObject withOccurrences: 1! !!Bag methodsFor: 'adding' stamp: 'sma 5/12/2000 17:20'!add: newObject withOccurrences: anInteger 	"Add newObject anInteger times to the receiver. Answer newObject."	contents at: newObject put: (contents at: newObject ifAbsent: [0]) + anInteger.	^ newObject! !!Bag methodsFor: 'converting' stamp: 'sma 5/12/2000 14:34'!asBag	^ self! !!Bag methodsFor: 'converting' stamp: 'sma 5/12/2000 14:30'!asSet	"Answer a set with the elements of the receiver."	^ contents keys! !!Bag methodsFor: 'copying' stamp: 'sma 5/12/2000 14:53'!copy	^ self shallowCopy setContents: contents copy! !!Bag methodsFor: 'private' stamp: 'sma 5/12/2000 14:49'!setContents: aDictionary	contents _ aDictionary! !!Bag methodsFor: 'removing' stamp: 'sma 5/12/2000 14:32'!remove: oldObject ifAbsent: exceptionBlock 	"Refer to the comment in Collection|remove:ifAbsent:."	| count |	count _ contents at: oldObject ifAbsent: [^ exceptionBlock value].	count = 1		ifTrue: [contents removeKey: oldObject]		ifFalse: [contents at: oldObject put: count - 1].	^ oldObject! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 19:58'!with: anObject 	"Answer an instance of me containing anObject."	^ self new		add: anObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:01'!with: firstObject with: secondObject 	"Answer an instance of me containing the two arguments as elements."	^ self new		add: firstObject;		add: secondObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:03'!with: firstObject with: secondObject with: thirdObject 	"Answer an instance of me containing the three arguments as elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	"Answer an instance of me, containing the four arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer an instance of me, containing the six arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		add: sixthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:07'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size)		addAll: aCollection;		yourself! !!Collection class methodsFor: 'private' stamp: 'sma 5/12/2000 12:31'!randomForPicking	^ RandomForPicking! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 13:31'!new	^ self new: 4! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 14:49'!new: nElements	^ super new setContents: (Dictionary new: nElements)! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:17'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ self withAll: aCollection"Examples:	Bag newFrom: {1. 2. 3. 3}	{1. 2. 3. 3} as: Bag"! !!Integer methodsFor: 'truncation and round off' stamp: 'sma 5/12/2000 12:35'!atRandom	"Answer a random integer from 1 to self.  This implementation uses a	shared generator. Heavy users should their own implementation or use	Interval>atRandom: directly."	^ self atRandom: Collection randomForPicking! !!Integer methodsFor: 'truncation and round off' stamp: 'sma 5/12/2000 12:35'!atRandom: aGenerator	"Answer a random integer from 1 to self picked from aGenerator."	^ aGenerator nextInt: self! !!Random methodsFor: 'initialization' stamp: 'sma 5/12/2000 12:29'!seed: anInteger 	seed _ anInteger! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:25'!next	"Answer a random Float in the interval [0 to 1)."	^ (seed _ self nextValue) / m! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:45'!next: anInteger	^ self next: anInteger into: (Array new: anInteger)! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:46'!next: anInteger into: anArray	1 to: anInteger do: [:index | anArray at: index put: self next].	^ anArray! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:25'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]."	^ (self next * anInteger) truncated + 1! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:42'!check: nDice	"Roll some dice, WoD-style."	^ self check: nDice difficulty: 6! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:47'!check: nAttack against: nDefend	"Roll some dice, WoD-style."	^ self check: nAttack against: nDefend difficulty: 6! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:46'!check: nAttack against: nDefend difficulty: diff	"Roll some dice, WoD-style."	| attacks defends |	attacks _ self check: nAttack difficulty: diff.	attacks < 0 ifTrue: [^ attacks].	defends _ self check: nDefend difficulty: diff.	^ attacks - defends min: 0! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:42'!check: nDice difficulty: diff	"Roll some dice, WoD-style."	| result die |	result _ 0.	nDice timesRepeat: 		[(die _ self nextInt: 10) = 1			ifTrue: [result _ result - 1]			ifFalse: [die >= diff ifTrue: [result _ result + 1]]].	^ result! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:48'!diceToken: stream	"Private. Mini scanner, see #roll:"	stream atEnd ifTrue: [^ nil].	stream peek isDigit ifTrue: [^ Number readFrom: stream].	^ stream next asLowercase! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:37'!roll: diceString	"Roll some dice, DnD-style, according to this mini-grammar:		dice _ epxr {pm expr}		pm _ '+' | '-'		expr _ num | num dD | dD numP | num dD numP		dD _ 'd' | 'D'		num _ digit+		numP _ num | '%'"	| stream op result dice range res token |	stream _ diceString readStream.	result _ 0.	op _ #+.	[token _ self diceToken: stream.	token isNumber		ifTrue: [dice _ token.				token _ self diceToken: stream]		ifFalse: [token == $d			ifTrue: [dice _ 1]			ifFalse: [res _ 0]].	token == $d		ifTrue: [token _ self diceToken: stream.				token isNumber					ifTrue: [range _ token.							token _ self diceToken: stream]					ifFalse: [token == $%						ifTrue: [range _ 100.								token _ self diceToken: stream]						ifFalse: [range _ 6]].				res _ 0.				dice timesRepeat: [res _ res + (self nextInt: range)]].	result _ result perform: op with: res.	token ifNil: [^ result].	(token == $+ or: [token == $-])		ifFalse: [self error: 'unknown token ' , token].	op _ token asSymbol] repeat! !!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:28'!nextValue	"This method generates random instances of Integer 	in the interval	0 to 16r7FFFFFFF. This method does NOT update the seed; repeated sends	answer the same value.	The algorithm is described in detail in 'Random Number Generators: 	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller 	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988)."	| lo hi aLoRHi answer |	hi _ (seed quo: q) asFloat.	lo _ seed - (hi * q).  " = seed rem: q"  	aLoRHi _ (a * lo) - (r * hi).	answer _ (aLoRHi > 0.0)		ifTrue:  [aLoRHi]		ifFalse: [aLoRHi + m].	^ answer! !!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:43'!seed	^ seed! !!Random class methodsFor: 'examples' stamp: 'sma 5/12/2000 12:39'!example	"If you just want a quick random integer, use:		10 atRandom	Every integer interval can give a random number:		(6 to: 12) atRandom	SequenceableCollections can give randomly selected elements:		'pick one of these letters randomly' atRandom	SequenceableCollections also respond to shuffled, as in:		($A to: $Z) shuffled	The correct way to use class Random is to store one in 	an instance or class variable:		myGenerator _ Random new.	Then use it every time you need another number between 0.0 and 1.0 (excluding)		myGenerator next	You can also generate a positive integer		myGenerator nextInt: 10"! !!Random class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 12:36'!new	^ super new initialize! !!Random class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 12:41'!seed: anInteger	^ self new initialize seed: anInteger! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:00'!after: target	"Answer the element after target.  Raise an error if target is not	in the receiver, or if there are no elements after it."	^ self after: target ifAbsent: [self errorNotFound: target]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:02'!after: target ifAbsent: exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| index |	index _ self indexOf: target.	^ index == 0		ifTrue: [exceptionBlock value]		ifFalse: [index = self size 			ifTrue: [self errorLastObject: target]			ifFalse: [self at: index + 1]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:33'!anyOne	^ self first! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:11'!at: index ifAbsent: exceptionBlock 	"Answer the element at my position index. If I do not contain an element 	at index, answer the result of evaluating the argument, exceptionBlock."	(index between: 1 and: self size) ifTrue: [^ self at: index].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:14'!atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	| newCollection |	newCollection _ self species new: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:17'!atAll: aCollection put: anObject 	"Put anObject at every index specified by the elements of aCollection."	aCollection do: [:index | self at: index put: anObject].	^ anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:18'!atAll: indexArray putAll: valueArray	"Store the elements of valueArray into the slots	of this collection selected by indexArray."	indexArray with: valueArray do: [:index :value | self at: index put: value].	^ valueArray! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:36'!atRandom	"Answer a random element of the receiver.  Uses a shared random 	number generator owned by class Collection.  If you use this a lot, 	define your own instance of Random and use #atRandom:.  Causes 	an error if self has no elements."	^ self atRandom: Collection randomForPicking"Examples:	#('one' 'or' 'the' 'other') atRandom	(1 to: 10) atRandom	'Just pick one of these letters at random' atRandom"! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:50'!atRandom: aGenerator	"Answer a random element of the receiver.  Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers 	because only you use the generator.  Causes an error if self has no 	elements."	^ self at: (aGenerator nextInt: self size)! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:51'!atWrap: index 	"Answer the index'th element of the receiver.  If index is out of bounds,	let it wrap around from the end to the beginning until it is in bounds."	^ self at: index - 1 \\ self size + 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:52'!atWrap: index put: value	"Store value into the index'th element of the receiver.  If index is out	of bounds, let it wrap around from the end to the beginning until it 	is in bounds. Answer value."	^ self at: index  - 1 \\ self size + 1 put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:04'!before: target	"Answer the receiver's element immediately before target. Raise an	error if target is not an element of the receiver, or if there are no 	elements before it (i.e. it is the first element)."	^ self before: target ifAbsent: [self errorNotFound: target]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 18:06'!before: target ifAbsent: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| index |	index _ self indexOf: target.	^ index == 0		ifTrue: [exceptionBlock value]		ifFalse: [index == 1 			ifTrue: [self errorFirstObject: target]			ifFalse: [self at: index - 1]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:57'!fifth	"Answer the fifth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 5! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:59'!first	"Answer the first element of the receiver.	Raise an error if there are not enough elements."	self emptyCheck.	^ self at: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:58'!fourth	"Answer the fourth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 4! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:00'!last	"Answer the last element of the receiver.	Raise an error if the collection is empty."	self emptyCheck.	^ self at: self size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:58'!second	"Answer the second element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 2! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:59'!sixth	"Answer the sixth element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 6! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:58'!third	"Answer the third element of the receiver.	Raise an error if there are not enough elements."	^ self checkedAt: 3! !!SequenceableCollection methodsFor: 'comparing' stamp: 'sma 5/12/2000 14:04'!= otherCollection 	"Answer true if the receiver is equivalent to the otherCollection.	First test for identity, then rule out different species and sizes of	collections. As a last resort, examine each element of the receiver	and the otherCollection."	self == otherCollection ifTrue: [^ true].	self species == otherCollection species ifFalse: [^ false].	^ self hasEqualElements: otherCollection! !!SequenceableCollection methodsFor: 'comparing' stamp: 'sma 5/12/2000 14:04'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(size _ self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:32'!asArray	"Answer an Array whose elements are the elements of the receiver."	^ Array withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:36'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver."	^ ByteArray withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 12:51'!readStream	^ ReadStream on: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:56'!reverse	^ self reversed! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 12:52'!writeStream	^ WriteStream on: self! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 5/12/2000 12:36'!shuffled	^ self shuffledBy: Collection randomForPicking"Examples:	($A to: $Z) shuffled"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:46'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new: self size.	1 to: self size do:		[:index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:56'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	1 to: self size do:		[:index |		index = 1 ifFalse: [separatorBlock value].		elementBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 18:11'!from: start to: stop do: aBlock	"Evaluate aBlock for all elements between start and stop (inclusive)."	start to: stop do: [:index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 18:13'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys (aka indices) and values."	1 to: self size do: [:index | aBlock value: index value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 18:14'!upTo: anObject	^ self copyFrom: 1 to: (self indexOf: anObject ifAbsent: [self size + 1]) - 1! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 13:57'!checkedAt: index	index > self size ifTrue: [self error: 'not enough elements'].	^ self at: index! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 18:06'!errorFirstObject: anObject	self error: 'specified object is first object'! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 18:03'!errorLastObject: anObject	self error: 'specified object is last object'! !!SequenceableCollection methodsFor: 'testing' stamp: 'sma 5/12/2000 14:08'!includes: anObject	"Answer whether anObject is one of the receiver's elements."	^ (self indexOf: anObject) ~= 0! !!ArrayedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:36'!size	"Answer how many elements the receiver contains."	<primitive: 62>	^ self basicSize! !!ArrayedCollection methodsFor: 'adding' stamp: 'sma 5/12/2000 14:09'!add: newObject	self shouldNotImplement! !!ArrayedCollection methodsFor: 'filter streaming' stamp: 'sma 5/12/2000 14:20'!flattenOnStream: aStream 	aStream writeArrayedCollection: self! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 18:18'!asSortedArray	self isSorted ifTrue: [^ self asArray].	^ super asSortedArray! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:19'!isSorted	"Return true if the receiver is sorted by the given criterion.	Optimization for isSorted: [:a :b | a <= b]."	| lastElm elm |	lastElm _ self first.	2 to: self size do: 		[:index | 		elm _ self at: index.		lastElm <= elm ifFalse: [^ false].		lastElm _ elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:19'!isSortedBy: aBlock	"Return true if the receiver is sorted by the given criterion."	| lastElm elm |	lastElm _ self first.	2 to: self size do: 		[:index | 		elm _ self at: index.		(aBlock value: lastElm value: elm) ifFalse: [^ false].		lastElm _ elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:28'!mergeFirst: first middle: middle last: last into: dst by: aBlock	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 	of the receiver into the range [first..last] of dst."	| i1 i2 val1 val2 out |	i1 _ first.	i2 _ middle + 1.	val1 _ self at: i1.	val2 _ self at: i2.	out _ first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue:		[(aBlock value: val1 value: val2)			ifTrue: [dst at: (out _ out + 1) put: val1.					val1 _ self at: (i1 _ i1 + 1)]			ifFalse: [dst at: (out _ out + 1) put: val2.					i2 _ i2 + 1.					i2 <= last ifTrue: [val2 _ self at: i2]]].	"copy the remaining elements"	i1 <= middle		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:25'!mergeSortFrom: startIndex to: stopIndex by: aBlock	"Sort the given range of indices using the mergesort algorithm.	Mergesort is a worst-case O(N log N) sorting algorithm that usually	does only half as many comparisons as heapsort or quicksort."	"Details: recursively split the range to be sorted into two halves,	mergesort each half, then merge the two halves together. An extra 	copy of the data is used as temporary storage and successive merge 	phases copy data back and forth between the receiver and this copy.	The recursion is set up so that the final merge is performed into the	receiver, resulting in the receiver being completely sorted."	self size <= 1 ifTrue: [^ self].  "nothing to do"	startIndex = stopIndex ifTrue: [^ self].	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. "bad start index"	self assert: [stopIndex <= self size]. "bad stop index"	self		mergeSortFrom: startIndex		to: stopIndex 		src: self clone 		dst: self 		by: aBlock! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:26'!mergeSortFrom: first to: last src: src dst: dst by: aBlock	"Private. Split the range to be sorted in half, sort each half, and 	merge the two half-ranges into dst."	| middle |	first = last ifTrue: [^ self].	middle _ (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:22'!sort	"Sort this array into ascending order using the '<=' operator."	self sort: [:a :b | a <= b]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:21'!sort: aSortBlock 	"Sort this array using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one."	self		mergeSortFrom: 1		to: self size		by: aSortBlock! !!Array methodsFor: 'converting' stamp: 'sma 5/12/2000 17:32'!asArray	"Answer with the receiver itself."	^ self! !!Array methodsFor: 'printing' stamp: 'sma 5/12/2000 14:11'!isLiteral	^ self allSatisfy: [:each | each isLiteral]! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:37'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size) replaceFrom: 1 to: aCollection size with: aCollection! !!Bitmap methodsFor: 'printing' stamp: 'sma 5/12/2000 12:03'!printOn: aStream	aStream		nextPutAll: 'a Bitmap of length ';		print: self size! !!ByteArray methodsFor: 'converting' stamp: 'sma 5/12/2000 17:35'!asByteArray	^ self! !!Heap methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:37'!size	"Answer how many elements the receiver contains."	^ tally! !!Interval methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:38'!size	"Answer how many elements the receiver contains."	step < 0		ifTrue: [start < stop				ifTrue: [^ 0]				ifFalse: [^ stop - start // step + 1]]		ifFalse: [stop < start				ifTrue: [^ 0]				ifFalse: [^ stop - start // step + 1]]! !!OrderedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:42'!capacity	"Answer the current capacity of the receiver."	^ array size! !!OrderedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:39'!size	"Answer how many elements the receiver contains."	^ lastIndex - firstIndex + 1! !!OrderedCollection methodsFor: 'adding' stamp: 'sma 5/12/2000 11:26'!addAll: aCollection 	"Add each element of aCollection at my end. Answer	aCollection."	^ self addAllLast: aCollection! !!OrderedCollection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:24'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element and remove all that elements from	the receiver for that aBlock evaluates to true."	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[(aBlock value: (array at: index))				ifTrue: [self removeIndex: index]				ifFalse: [index _ index + 1]]! !!OrderedCollection methodsFor: 'private' stamp: 'sma 5/12/2000 11:20'!find: oldObject	| index |	index _ firstIndex.	[index <= lastIndex and: [oldObject ~= (array at: index)]]		whileTrue: [index _ index + 1].	index <= lastIndex		ifTrue: [^ index]		ifFalse: [self errorNotFound: oldObject]! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:41'!new	^ self new: 10! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:42'!new: anInteger 	^ super new setCollection: (Array new: anInteger)! !!Set methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:40'!capacity	"Answer the current capacity of the receiver."	^ array size! !!Set methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:34'!someElement	"Deprecated. Use anyOne."	^ self anyOne! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:28'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:29'!add: newObject withOccurrences: anInteger	^ self add: newObject! !!Set methodsFor: 'copying' stamp: 'sma 5/12/2000 14:54'!copy	^ self shallowCopy withArray: array shallowCopy! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:49'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newSet |	newSet _ Set new: self size.	array do: [:each | each ifNotNil: [newSet add: (aBlock value: each)]].	^ newSet! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 14:36'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: array size do:		[:index |		| each |		(each _ array at: index) ifNotNil: [aBlock value: each]]! !!Set methodsFor: 'removing' stamp: 'sma 5/12/2000 14:45'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self copy		remove: oldElement ifAbsent: [];		yourself! !!Set methodsFor: 'testing' stamp: 'sma 5/12/2000 14:46'!occurrencesOf: anObject 	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:59'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| assoc |	assoc _ array at: (self findElementOrNil: key).	assoc ifNil: [^ aBlock value].	^ assoc value! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:01'!at: key ifAbsentPut: aBlock 	"Return the value at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."	^ self at: key ifAbsent: [self at: key put: aBlock value]! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:00'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index _ self findElementOrNil: key.	assoc _ array at: index.	assoc		ifNil: [self atNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!WeakRegistry methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:40'!size	^ self protected: [valueDictionary size]! !String removeSelector: #asByteArray!String removeSelector: #size!Set removeSelector: #addIfNotPresent:!Set removeSelector: #asArray!!Set reorganize!('accessing' capacity size someElement)('adding' add: add:withOccurrences:)('converting' asSet)('copying' copy)('enumerating' collect: do: doWithIndex:)('objects from disk' comeFullyUpOnReload:)('private' array atNewIndex:put: findElementOrNil: fixCollisionsFrom: fullCheck grow growSize init: keyAt: noCheckAdd: rehash scanFor: swap:with: withArray:)('removing' copyWithout: remove:ifAbsent:)('testing' = hasContentsInExplorer includes: occurrencesOf:)!OrderedCollection removeSelector: #after:!OrderedCollection removeSelector: #before:!OrderedCollection removeSelector: #copyWithout:!OrderedCollection removeSelector: #copyWithoutAll:!OrderedCollection removeSelector: #errorFirstObject!OrderedCollection removeSelector: #errorLastObject!OrderedCollection removeSelector: #errorNotFound!LinkedList removeSelector: #size!!ArrayedCollection reorganize!('accessing' size)('adding' add:)('filter streaming' flattenOnStream:)('printing' storeOn:)('private' defaultElement storeElementsFrom:to:on:)('sorting' asSortedArray isSorted isSortedBy: mergeFirst:middle:last:into:by: mergeSortFrom:to:by: mergeSortFrom:to:src:dst:by: sort sort:)!SequenceableCollection removeSelector: #asSortedArray!SequenceableCollection removeSelector: #copyWithout:!SequenceableCollection removeSelector: #copyWithoutAll:!SequenceableCollection removeSelector: #size!!SequenceableCollection reorganize!('accessing' after: after:ifAbsent: allButFirst allButLast anyOne at:ifAbsent: atAll: atAll:put: atAll:putAll: atAllPut: atPin: atRandom atRandom: atWrap: atWrap:put: before: before:ifAbsent: fifth first fourth from:to:put: identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last middle replaceAll:with: replaceFrom:to:with: replaceFrom:to:with:startingAt: second sixth swap:with: third)('comparing' = hasEqualElements: hash)('converting' @ asArray asByteArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray isSequenceable readStream reverse reversed writeStream)('copying' , copyAfterLast: copyAt:put: copyFrom:to: copyLast: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithoutFirst forceTo:paddingWith: shallowCopy shuffled shuffledBy: sortBy:)('enumerating' asDigitsToPower:do: collect: collect:from:to: collectWithIndex: combinations:atATimeDo: do: do:separatedBy: do:without: doWithIndex: findFirst: findLast: from:to:do: keysAndValuesDo: pairsCollect: pairsDo: permutationsDo: reverseDo: reverseWith:do: select: upTo: with:collect: with:do: withIndexCollect: withIndexDo:)('private' asDigitsAt:in:do: checkedAt: combinationsAt:in:after:do: copyReplaceAll:with:asTokens: errorFirstObject: errorLastObject: errorOutOfBounds permutationsStartingAt:do:)('removing' remove:ifAbsent:)('testing' includes:)!!Random class reorganize!('examples' example)('instance creation' new seed:)('testing' bucketTest: theItsCompletelyBrokenTest)!!Random reorganize!('initialization' initialize seed:)('accessing' next next: next:into: nextInt:)('die rolling' check: check:against: check:against:difficulty: check:difficulty: diceToken: roll:)('private' nextValue seed)!Bag removeSelector: #setDictionary!Bag removeSelector: #setDictionary:!!Bag reorganize!('accessing' at: at:put: cumulativeCounts size sortedCounts sortedElements)('adding' add: add:withOccurrences:)('converting' asBag asSet)('copying' copy)('enumerating' do:)('private' setContents:)('removing' remove:ifAbsent:)('testing' includes: occurrencesOf:)!Collection removeSelector: #errorNotFound!Collection removeSelector: #maxSize!!Collection reorganize!('accessing' anyOne capacity size)('adapting' adaptToCollection:andSend: adaptToNumber:andSend: adaptToPoint:andSend: adaptToString:andSend:)('adding' add: add:withOccurrences: addAll: addIfNotPresent:)('arithmetic' * + - / // \\)('comparing' hash)('converting' asArray asBag asByteArray asCharacterSet asOrderedCollection asSet asSortedArray asSortedCollection asSortedCollection:)('copying' copyWith: copyWithout: copyWithoutAll:)('enumerating' anySatisfy: associationsDo: collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: difference: do: do:separatedBy: do:without: inject:into: intersection: reject: select: select:thenCollect: union:)('filter streaming' contents flattenOnStream: write:)('math functions' abs average ceiling floor log max median min negated range reciprocal rounded sqrt squared sum truncated)('printing' printOn: storeOn:)('private' emptyCheck errorEmptyCollection errorNoMatch errorNotFound: errorNotKeyed toBraceStack:)('removing' remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat:)('testing' includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isCollection isEmpty isEmptyOrNil isSequenceable notEmpty occurrencesOf:)!