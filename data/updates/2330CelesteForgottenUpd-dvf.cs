'From Squeak2.8alpha of 4 February 2000 [latest update: #2310] on 12 June 2000 at 1:00:38 pm'!"Change Set:		146CelesteForgottenUpd-dvfDate:			11 June 2000Author:			Daniel VainsencherUse tailored PluggableSets and PluggableDictionaries to speed up Celeste.Fix the buttons list creation to includes 'Custom Move F.' option."!!CategoriesFile methodsFor: 'categories access' stamp: 'dvf 6/10/2000 18:32'!addCategory: categoryName 	"Add a new category, if it doesn't already exist."	(self categories includes: categoryName)		ifFalse: [categories at: categoryName put: PluggableSet integerSet]! !!CategoriesFile methodsFor: 'categories access' stamp: 'dvf 6/10/2000 18:32'!file: messageID inCategory: categoryName 	"Add the given message ID to the given category. The target category  	must be a real category, not a pseudo-category."	categoryName = '.unclassified.' | categoryName = '.all.' ifTrue: [^ self].	(categories includesKey: categoryName)		ifFalse: [categories at: categoryName put: PluggableSet integerSet].	(categories at: categoryName)		add: messageID! !!CategoriesFile methodsFor: 'categories access' stamp: 'dvf 6/10/2000 19:21'!renameCategory: oldName to: newName 	"Rename the given category."	| oldEntry |	oldName = '.all.' | oldName = '.unclassified.' | (self categories includes: newName) ifTrue: [^ self].	"can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [PluggableSet integerSet].	categories at: newName put: oldEntry! !!CategoriesFile methodsFor: 'read-write' stamp: 'dvf 6/10/2000 18:33'!readFrom: aFileStream 	"Read the categories from the given FileStream."	| name categorySize messageIDs |	categories _ Dictionary new: 64.	aFileStream binary; position: 0.	[aFileStream atEnd]		whileFalse: 			[name _ aFileStream ascii; nextString.			categorySize _ aFileStream binary; nextWord.			messageIDs _ PluggableSet integerSet.			categorySize timesRepeat: [messageIDs add: aFileStream nextInt32].			categories at: name put: messageIDs]! !!Celeste class methodsFor: 'instance creation' stamp: 'dvf 6/11/2000 01:42'!buildButtonsFor: model 	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b sw |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	sw _ Switch new.	b _ buttonViewClass on: (sw onAction: [model subjectFilterOn: sw];				 offAction: [model subjectFilterOff]).	b label: 'Subj. F.';		borderWidth: 1.	b setBalloonText: 'Show messages with specific Subject: line content'.	buttons add: b.	sw _ Switch new.	b _ buttonViewClass on: (sw onAction: [model fromFilterOn: sw];				 offAction: [model fromFilterOff]).	b label: 'From F.';		borderWidth: 1.	b setBalloonText: 'Show messages with specific From: line content'.	buttons add: b.	b _ buttonViewClass				on: model				getState: #isCustomFilterOn				action: #customFilterOn.	b label: 'Custom F.';		borderWidth: 1.		b setBalloonText: 'Show messages which match a generalized custom filter'.	buttons add: b.b _ buttonViewClass				on: model				getState: nil				action: #customFilterMove.	b label: 'Custom F. Move';	 borderWidth: 1.	b setBalloonText: 'Move messages which match a custom filter to appropriate category'.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model compose]);			 action: #turnOn;			 label: 'New';			 borderWidth: 1.	b setBalloonText: 'Compose a new message'.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model reply]);			 action: #turnOn;			 label: 'Reply';			 borderWidth: 1.	b setBalloonText: 'Reply to the selected message'.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model forward]);			 action: #turnOn;			 label: 'Forward';			 borderWidth: 1.	b setBalloonText: 'Forward the selected message'.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model moveAgain]);			 action: #turnOn;			 label: 'Move Again';			 borderWidth: 1.	b setBalloonText: 'Move the selected message to the same category as previously'.	buttons add: b.	b _ buttonViewClass new model: (Button new onAction: [model deleteMessage]);			 action: #turnOn;			 label: 'Delete';			 borderWidth: 1.	b setBalloonText: 'Delete the selected message'.	buttons add: b.	^ buttons! !!Collection methodsFor: 'enumerating' stamp: 'dvf 6/10/2000 18:32'!groupBy: keyBlock having: selectBlock 	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock. keyBlock should return an Integer."	| result key |	result _ PluggableDictionary integerDictionary.	self do: 		[:e | 		key _ keyBlock value: e.		(result includesKey: key)			ifFalse: [result at: key put: OrderedCollection new].		(result at: key)			add: e].	^ result _ result select: selectBlock! !!IndexFile methodsFor: 'read-write' stamp: 'dvf 6/11/2000 01:02'!readFrom: aStream messageFile: messageFile 	"Initialize myself from the given text stream. It is assumed that the 	.index file was written in order of ascending message timestamps, 	although this method is only less efficient, not incorrect, if this is not 	the case."	| sorted lastTime msgID entry |	msgDictionary _ PluggableDictionary integerDictionary.	timeSortedEntries _ (SortedCollection new: 1000)				sortBlock: [:m1 :m2 | m1 value time <= m2 value time].	sorted _ true.	lastTime _ nil.	[aStream atEnd]		whileFalse: 			[msgID _ MailDB readIntegerLineFrom: aStream.			entry _ IndexFileEntry						readFrom: aStream						messageFile: messageFile						msgID: msgID.			msgDictionary at: msgID put: entry.			timeSortedEntries addLast: (Association key: msgID value: entry).			(sorted & lastTime notNil and: [lastTime > entry time])				ifTrue: [sorted _ false].			lastTime _ entry time].	sorted ifFalse: [timeSortedEntries reSort]! !!MailDB methodsFor: 'housekeeping' stamp: 'dvf 6/10/2000 18:33'!findDuplicates	"MailDB someInstance findDuplicates"	| msgsAtTime duplicates msgsBySize similarMessages textCache first second text1 text2 |	duplicates _ PluggableSet integerSet.	msgsAtTime _ ((self messagesIn: '.all.')				collect: [:e | indexFile at: e])				groupBy: [:e | e time]				having: [:arr | arr size > 1].	msgsAtTime		associationsDo: 			[:assoc | 			msgsBySize _ assoc value groupBy: [:e | e textLength]						having: [:arr | arr size > 1].			msgsBySize				associationsDo: 					[:assoc2 | 					similarMessages _ assoc2 value.					textCache _ PluggableDictionary integerDictionary.					similarMessages combinations: 2						atATimeDo: 							[:each | 							first _ each first.							second _ each second.							((first likelyEqual: second)								and: 									[text1 _ textCache at: first msgID ifAbsentPut: [(self getMessage: first msgID) bodyText].									text2 _ textCache at: second msgID ifAbsentPut: [(self getMessage: second msgID) bodyText].									text1 = text2])								ifTrue: [duplicates add: second msgID]]]].	^ duplicates asArray! !