'From Squeak 2.4c of May 10, 1999 on 6 July 1999 at 10:16:47 am'!"Change Set:		paintFixes-swDate:			6 July 1999Author:			Scott Wallace*  Paintbox position appropriate even when painting world in unlimitedPaintArea mode.*  Only one painting experience allowed at a time.*  If no paintbox is found when a painting gesture is received (because it got dismissed by halo, for example), one is hastily put up.*  There is now support for keeping the paintbox in a flap, though the resulting effect was not very satisfactory and hence you need to perform a magical incantation to set things up for this to happen."!!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 6/30/1999 20:51'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette |	(self world findA: SketchEditorMorph) ifNotNil:		[^ self inform: 'Sorry, you can only paint oneobject at a time'].	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 7/1/1999 12:15'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| aPaintBox newPaintBoxBounds worldBounds requiredWidth newOrigin aPosition aPal aTab |	(aTab _ self world paintingFlapTab) ifNotNil:		[aTab showFlap.		^ self initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: nil].	aPaintBox _ self world paintBox.	worldBounds _ self world bounds.	requiredWidth _ aPaintBox width.	aPosition _ (aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[boundsToUse topRight].	newOrigin _ ((aPosition x  + requiredWidth <= worldBounds right) or: [Preferences unlimitedPaintArea])			ifTrue:  "will fit to right of aPasteUpMorph"				[aPosition]			ifFalse:  "won't fit to right, try left"				[boundsToUse topLeft - (requiredWidth @ 0)].	newPaintBoxBounds _ (newOrigin extent: aPaintBox extent) translatedToBeWithin: worldBounds.		self initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: newPaintBoxBounds origin! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 6/25/1999 21:46'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	"NB: if aPosition is nil, then it's assumed that the paintbox is obtained from a flap or some such, so do nothing special regarding a palette in this case.  The palette needs already to be in the world for this to work."	| w  |	(w _ aPasteUpMorph world) addMorphFront: self.	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	palette _ w paintBox.	aPosition ifNotNil:		[w addMorphFront: palette.  "bring to front"		palette position: aPosition].	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 7/1/1999 21:34'!cancelOutOfPainting	self delete.	dimForm ifNotNil: [dimForm delete].	emptyPicBlock ifNotNil: [emptyPicBlock value].	"note no args to block!!"	hostView ifNotNil: [hostView changed].	^ nil! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 6/30/1999 20:45'!verifyState	"We are sure we will make a mark now.  Make sure the palette has not changed state while we were away.  If so, end this action and start another one.  6/11/97 19:52 tk  action, currentColor, brush"	"Install the brush, color, (replace mode), and cursor."	palette isInWorld ifFalse:		[self world addMorphFront: palette].  "It happens.  might want to position it also"			action == palette getSpecial ifFalse: [		self invalidRect: rotationButton bounds.	"snap these back"		rotationButton position: bounds topCenter - (6@0).		"later adjust by button width?"		self invalidRect: rotationButton bounds.		self invalidRect: scaleButton bounds.		scaleButton position: bounds rightCenter - ((scaleButton width)@6).		self invalidRect: scaleButton bounds.		action == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"		^ action _ self prepareToPaint].	action == #paint: ifTrue: [		currentNib = palette getNib ifFalse: [			currentNib _ palette getNib.			"Change the nib on the cursor (Hand)"			"get it to one bit depth.  For speed, instead of going through 				a colorMap every time ."			brush _ Form extent: currentNib extent depth: 1.			brush offset: (0@0) - (brush extent // 2).			currentNib displayOn: brush at: (0@0 - currentNib offset).			paintingFormPen sourceForm: brush]].	action == #erase: ifFalse: [	 	currentColor = palette getColor ifFalse: [			currentColor _ palette getColor.			"Change the color of the nib on the cursor (Hand)"			paintingFormPen color: currentColor.			currentColor isTransparent 				ifTrue: [					paintingFormPen combinationRule: Form erase1bitShape.					paintingFormPen color: Color black]				ifFalse: [paintingFormPen combinationRule: Form paint]]]		ifTrue: [palette getNib width = brush width ifFalse: [self erasePrep]].	"it changed"	action == #stamp: ifTrue: [		stampForm _ palette stampForm.	"get the current form"		stampForm ifNil: [self error: 'no stamp']].! !