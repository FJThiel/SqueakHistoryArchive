'From Squeak 2.3 beta of Nov 25, 1998 on 4 January 1999 at 1:25:56 am'!"Change Set:		Translucency-diDate:			1 January 1999Author:			Dan IngallsA number of cleanups and completions for translucency...Fixes center line in translucent ellipses due to double display.Fixes damage remaining in translucent RectangleMorphs.Makes translucency work right in 32 bits.Makes translucency work right in 16 bits.Makes hand shadow use translucency in 16 and 32 bits.Makes curves show shadow correctly.Made translucent shadows work for sketches and images.Made color chooser use prior alpha.Plus a couple of other improvements...When hand is solid rect, only paint drop-shadow in areas outside - faster.Improved determination of when hand cache is not translucent.When deactivate a window, report less damage by displayWorld after change.Make windows white in 1- and 2-bit depths"!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX foregroundColor backgroundColor lastSourceDepth fillBlt lineHeight paragraph paragraphColor morphicOffset ignoreColorChanges alpha '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!BitBlt subclass: #GrafPort	instanceVariableNames: 'lastColor alpha '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!BitBlt methodsFor: 'copying' stamp: 'di 12/31/1998 14:38'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 96>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'di 1/4/1999 01:14'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 96>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!Color methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ false! !!Color methodsFor: 'queries' stamp: 'di 1/3/1999 12:23'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ false! !!DisplayScanner methodsFor: 'private' stamp: 'di 1/4/1999 00:34'!alphaBits: a	alpha _ a! !!DisplayScanner methodsFor: 'private' stamp: 'di 1/4/1999 00:39'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31])		ifTrue: [alpha == nil					ifTrue: [self copyBitsTranslucent: 255]					ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!blendAlpha	"Answer the integer denoting BitBlt's blend-with-constant-alpha rule."	^ 30! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!paintAlpha	"Answer the integer denoting BitBlt's paint-with-constant-alpha rule."	^ 31! !!FormCanvas commentStamp: '<historical>' prior: 0!Note that when shadowDrawing is true, shadowStipple may be either a color, for a solid shadow of the given color, or it may be a stipple used to simulate gray shading when the display cannot support alpha blending.!!FormCanvas methodsFor: 'drawing' stamp: 'di 1/4/1999 00:17'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC borderRule |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [fillC == nil ifTrue: [^ self].  "both border and fill are transparent"				borderC _ nil.				rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor.				borderRule _ self drawRule: Form over color: borderColor].	port combinationRule: (self drawRule: Form over color: c).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC		borderRule: borderRule.! !!FormCanvas methodsFor: 'drawing' stamp: 'di 1/3/1999 22:42'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"draw the border of the rectangle"	borderColor isTransparent ifFalse:		[port combinationRule: (self drawRule: Form over color: borderColor).		(r area > 10000 or: [fillColor isTranslucent])			ifTrue: [port frameRect: (r translateBy: origin)						borderWidth: borderWidth						borderColor: (self drawColor: borderColor)]			ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle						than to compute and fill the border rects"					port fillRect: r						color: (self drawColor: borderColor)						offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse:		[port combinationRule: (self drawRule: Form over color: fillColor).		port fillRect: (r insetBy: borderWidth)			color: (self drawColor: fillColor)			offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'di 1/3/1999 21:17'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	shadowDrawing		ifTrue: [port colorMap: (Color maskingMap: aForm depth);					fillColor: shadowStipple]		ifFalse: [port colorMap: (aForm colormapIfNeededForDepth: form depth);					fillColor: nil].	port image: aForm at: aPoint + origin sourceRect: sourceRect		rule: (self drawRule: rule color: Color black)! !!FormCanvas methodsFor: 'drawing' stamp: 'di 12/31/1998 13:20'!stencil: stencilForm at: aPoint color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	port colorMap: (Color maskingMap: stencilForm depth).	port stencil: stencilForm		at: aPoint + origin		fillColor: (self drawColor: aColor)		rule: (self drawRule: Form paint color: aColor)! !!FormCanvas methodsFor: 'private' stamp: 'di 1/3/1999 15:30'!drawColor: aColor	^ shadowDrawing		ifTrue: [shadowStipple]		ifFalse: [aColor]! !!FormCanvas methodsFor: 'private' stamp: 'di 1/4/1999 00:57'!drawRule: someRule color: color	"Answer the BitBlt combination rule for the given default rule and color."	shadowDrawing		ifTrue:		[form depth < 16 ifTrue: [^ Form paint].  "Stipple merge in non-RGB"		form depth = 16 ifTrue:			[(shadowStipple isColor and: [shadowStipple isTranslucent]) ifFalse:				[^ Form paint  "no translucency"].			port alphaBits: shadowStipple privateAlpha.  "Simple alpha in 16 bits"			someRule = Form paint ifTrue: [^ Form paintAlpha]								ifFalse: [^ Form blendAlpha]].		^ Form blend  "Real alpha blend in 32 bits"]		ifFalse:		[form depth < 16 ifTrue: [^ someRule  "no RGB"].		(color isColor and: [color isTranslucent]) ifFalse: [^ someRule  "no translucency"].		form depth = 16 ifTrue:			[port alphaBits: color privateAlpha.  "Simple alpha in 16 bits"			someRule = Form paint ifTrue: [^ Form paintAlpha]								ifFalse: [^ Form blendAlpha]].		^ Form blend  "Real alpha blend in 32 bits"]! !!FormCanvas methodsFor: 'private' stamp: 'di 1/3/1999 12:54'!setForm: aForm	self reset.	form _ aForm.	port _ GrafPort toForm: form.! !!FormCanvas methodsFor: 'private' stamp: 'di 1/3/1999 20:46'!setShadowDrawing	| screen blackWord |	shadowDrawing _ true.	"Build a 50% stipple of black for the given depth."	form depth >= 16		ifTrue: [shadowStipple _ Color black alpha: 0.5]		ifFalse: [screen _ Color pixelScreenForDepth: form depth.				blackWord _ Color black pixelWordForDepth: form depth.				shadowStipple _ (screen collect: [:maskWord | maskWord bitAnd: blackWord])]! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 20:48'!alpha: a	"Internal alpha is BitBlt's 0-255"	self alphaBits: (255.0*a) asInteger! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 20:44'!alphaBits: a	alpha _ a! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 13:08'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31])		ifTrue: [alpha == nil					ifTrue: [self copyBitsTranslucent: 255]					ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !!GrafPort methodsFor: 'all' stamp: 'di 1/4/1999 00:36'!displayScannerFor: para foreground: foreColor background: backColor		rule: rule halftone: halftone ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setDestForm: destForm sourceForm: destForm			fillColor: halftone combinationRule: rule			destOrigin: 0@0 sourceOrigin: 0@0			extent: 0@0 clipRect: self clipRect;		alphaBits: alpha! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 23:49'!fillOval: rect color: fillColor borderWidth: borderWidth borderColor: borderColor	"Possible future optimizations:	Ä Compute an inset rectangle - if clipRect inside, then just paint with fillCOlor!!	Ä Note quadrants of clipRect, and only run code for those quadrants."	"NOTE: for some reason this crashes (!!) using the direct calls to copyBitsTranslucent.		There may be some sort of stack balance problem there."	| wp fillTone w borderTone centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dxs dx prevLeft left translucent borderAlpha |	rect area <= 0 ifTrue: [^ self].	translucent _ combinationRule >= 30 and: [combinationRule <= 31].	(translucent and: [borderColor isColor])		ifTrue: [borderAlpha _ borderColor privateAlpha]		ifFalse: [borderAlpha _ 255].	wp _ borderWidth asPoint.	sourceForm _ nil. 	height _ 1.	fillColor == nil		ifTrue: [fillTone _ nil]		ifFalse: [self fillColor: fillColor.  fillTone _ halftoneForm].	(((w _ wp x) * wp y) = 0 or: [borderColor == nil])		ifTrue: [borderTone _ nil]		ifFalse: [self fillColor: borderColor.  borderTone _ halftoneForm].	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	dxs _ Array new: maxy + 1.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		dxs at: dy+1 put: dx.		fillTone == nil ifFalse:			[halftoneForm _ fillTone.			height _ 1.			width _ dx + dx + centerXBias + 1.			destX _ centerX - centerXBias - dx.			destY _ centerY - centerYBias - dy.			"translucent" false			ifTrue: [self copyBitsTranslucent: alpha.					(dy = 0 and: [centerYBias = 0]) ifFalse:						["avoid double display for translucency"						destY _ centerY + dy.						self copyBitsTranslucent: alpha]]			ifFalse: [self copyBits.					(dy = 0 and: [centerYBias = 0]) ifFalse:						["avoid double display for translucency"						destY _ centerY + dy.						self copyBits]]]].	"Now do the border, using the same x values"	borderTone ifNil: [^ self].	(translucent and: [borderColor isColor])		ifTrue: [alpha _ borderColor privateAlpha]		ifFalse: [alpha _ 255].	prevLeft _ centerX.	maxy to: 0 by: -1 do: [:dy |		dx _ dxs at: dy+1.		halftoneForm _ borderTone.		height _ wp y.		left _ centerX - centerXBias - dx.		width _ prevLeft - left + w.		destX _ left.		destY _ centerY - centerYBias - dy.		"translucent" false		ifTrue: [self copyBitsTranslucent: borderAlpha.				destX _ centerX + dx + 1 - width.				self copyBitsTranslucent: borderAlpha.				destY _ centerY + dy - height + 1.				self copyBitsTranslucent: borderAlpha.				destX _ left.				self copyBitsTranslucent: borderAlpha.				prevLeft _ left]		ifFalse: [self copyBits.				destX _ centerX + dx + 1 - width.				self copyBits.				destY _ centerY + dy - height + 1.				self copyBits.				destX _ left.				self copyBits.				prevLeft _ left]].! !!GrafPort methodsFor: 'all' stamp: 'di 1/4/1999 00:16'!fillOval: rect color: fillColor borderWidth: borderWidth borderColor: borderColor borderRule: borderRule	"Possible future optimizations:	Ä Compute an inset rectangle - if clipRect inside, then just paint with fillCOlor!!	Ä Note quadrants of clipRect, and only run code for those quadrants."	"NOTE: for some reason this crashes (!!) using the direct calls to copyBitsTranslucent.		There may be some sort of stack balance problem there."	| wp fillTone w borderTone centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dxs dx prevLeft left |	rect area <= 0 ifTrue: [^ self].	wp _ borderWidth asPoint.	sourceForm _ nil. 	height _ 1.	fillColor == nil		ifTrue: [fillTone _ nil]		ifFalse: [self fillColor: fillColor.  fillTone _ halftoneForm].	(((w _ wp x) * wp y) = 0 or: [borderColor == nil])		ifTrue: [borderTone _ nil]		ifFalse: [self fillColor: borderColor.  borderTone _ halftoneForm].	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	dxs _ Array new: maxy + 1.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		dxs at: dy+1 put: dx.		fillTone == nil ifFalse:			[halftoneForm _ fillTone.			height _ 1.			width _ dx + dx + centerXBias + 1.			destX _ centerX - centerXBias - dx.			destY _ centerY - centerYBias - dy.			self copyBits.			(dy = 0 and: [centerYBias = 0]) ifFalse:				["avoid double display for translucency"				destY _ centerY + dy.				self copyBits]]].	"Now do the border, using the same x values"	borderTone ifNil: [^ self].	combinationRule _ borderRule.	borderColor isColor		ifTrue: [alpha _ borderColor privateAlpha]		ifFalse: [alpha _ 255].	prevLeft _ centerX.	maxy to: 0 by: -1 do: [:dy |		dx _ dxs at: dy+1.		halftoneForm _ borderTone.		height _ wp y.		left _ centerX - centerXBias - dx.		width _ prevLeft - left + w.		destX _ left.		destY _ centerY - centerYBias - dy.		self copyBits.		destX _ centerX + dx + 1 - width.		self copyBits.		destY _ centerY + dy - height + 1.		self copyBits.		destX _ left.		self copyBits.		prevLeft _ left].! !!GrafPort methodsFor: 'all' stamp: 'di 1/3/1999 13:08'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm _ aForm.	combinationRule_ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!GrafPort methodsFor: 'all' stamp: 'di 12/31/1998 14:31'!stencil: stencilForm at: aPoint fillColor: aColor rule: rule	"Paint using aColor wherever stencilForm has non-zero pixels, and using the given combination rule"	self sourceForm: stencilForm;		fillColor: aColor;		combinationRule: rule;		destOrigin: aPoint;		sourceRect: stencilForm boundingBox.	self copyBits! !!Morph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:25'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	^ color isColor and: [color isTranslucentColor]! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:24'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	(color isColor and: [color isTranslucentColor]) ifTrue: [^ true].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue: [^ true].	^ false! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 1/1/1999 22:55'!areasRemainingToFill: aRectangle	(color isColor and: [color isTranslucent]) ifTrue: [^ Array with: aRectangle].	(borderWidth > 0 and: [borderColor isColor and: [borderColor isTranslucent]])		ifTrue: [^ aRectangle areasOutside: self innerBounds]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 1/1/1999 22:57'!updateTargetColor	| oldColor alphaColor |	(target ~~ nil		and: [(target respondsTo: #color)		and: [(oldColor _ target color) isColor and: [oldColor isTranslucent]]])		ifTrue: [alphaColor _ selectedColor alpha: oldColor alpha]		ifFalse: [alphaColor _ selectedColor].	(target ~~ nil and: [selector ~~ nil]) ifTrue: [		selector numArgs = 2			ifTrue: [target perform: selector with: alphaColor with: sourceHand]			ifFalse: [target perform: selector with: alphaColor]].! !!GradientFillMorph methodsFor: 'all' stamp: 'di 1/3/1999 12:24'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	(color isColor and: [color isTranslucentColor]) ifTrue: [^ true].	(fillColor2 isColor and: [fillColor2 isTranslucentColor]) ifTrue: [^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:45'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds shadowCanvas f1 |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvasDepth: aCanvas depth.	(cacheCanvas == nil or: [aCanvas depth = 1]) ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	cachedCanvasHasHoles		ifTrue: ["Have to draw the real shadow of the form"				shadowCanvas image: cacheCanvas form at: subBnds origin]		ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"				(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:					[:r | shadowCanvas fillRectangle: r color: Color black]].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: subBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:44'!nonCachingFullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	| shadowCanvas shadowForm |	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	shadowForm _ self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."	shadowCanvas image: shadowForm at: shadowForm offset.  "draw shadows"	submorphs reverseDo: [:m | m fullDrawOn: aCanvas].  "draw morphs in front of shadows"	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:12'!shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m bounds]).	canvas _ (FormCanvas extent: bnds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bnds topLeft negated.	submorphs reverseDo: [:m | m fullDrawOn: canvas].  "draw shadows"	^ canvas form offset: bnds topLeft! !!HandMorph methodsFor: 'drawing' stamp: 'di 1/3/1999 15:45'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| subBnds rectList c |	depth >= 16 ifTrue:		["Check for real translucency -- can't be cached in a form"		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: subBnds extent depth: depth.		c _ cacheCanvas copyOffset: subBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: subBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c]].! !!SystemWindow methodsFor: 'geometry' stamp: 'di 1/3/1999 21:42'!extent: newExtent	| inner labelRect |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: self paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	self setBoundsOfPaneMorphs.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'top window' stamp: 'di 12/31/1998 10:41'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	self submorphsDo: [:m | m lock].	self world displayWorld "clean damage now, so dont merge this rect with new top"! !!SystemWindow methodsFor: 'panes' stamp: 'di 1/3/1999 21:44'!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		color: self paneColor;		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!SystemWindow methodsFor: 'panes' stamp: 'di 1/3/1999 21:42'!paneColor	Display depth > 2 ifTrue: [^ Color colorFrom: model defaultBackgroundColor].	^ Color white! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ alpha < 255! !!TranslucentColor methodsFor: 'queries' stamp: 'di 1/3/1999 12:22'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ alpha > 0! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTransparent	^ alpha = 0! !!TransparentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:34'!alpha	^ 0,0! !!TransparentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:34'!isTranslucent	^ true! !!TransparentColor methodsFor: 'queries' stamp: 'di 1/3/1999 12:23'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ false! !!WorldMorph methodsFor: 'drawing' stamp: 'di 12/31/1998 10:31'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r translateBy: viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !FormCanvas removeSelector: #drawRule:!FormCanvas removeSelector: #drawRule:color:borderColor:!