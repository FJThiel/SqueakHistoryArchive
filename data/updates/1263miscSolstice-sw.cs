'From Squeak 2.4c of May 10, 1999 on 21 June 1999 at 4:56:00 pm'!"Change Set:		miscSolstice-swDate:			21 June 1999Author:			Scott WallaceA miscellany of small changes on a long day.* Shift-click on the debug halo handle immediately inspects object.* Find-window forces its title onto screen.* Removes morph.assuredExtension and switches its one caller over to calling assureExtension.* Removes an outdated reference to TabTokenMorph.* Suppress sound while creating a new parts bin.* In EventHandler's printOn: msg, gives an indication of recipients (assists in debugging).* Adds  5-arg and 6-arg variants of with:with:... to Collection (now unifiorm with ArrayedCollection).* Reorganizes ScriptEvaluatorMorph methods."!!Collection class methodsFor: 'instance creation' stamp: 'sw 6/10/1999 13:42'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the 5 arguments as the elements."	| newCollection |	newCollection _ self new.	newCollection add: firstObject.	newCollection add: secondObject.	newCollection add: thirdObject.	newCollection add: fourthObject.	newCollection add: fifthObject.	^ newCollection! !!Collection class methodsFor: 'instance creation' stamp: 'sw 6/10/1999 13:41'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer an instance of me, containing the 6 arguments as the elements."	| newCollection |	newCollection _ self new.	newCollection add: firstObject.	newCollection add: secondObject.	newCollection add: thirdObject.	newCollection add: fourthObject.	newCollection add: fifthObject.	newCollection add: sixthObject.	^ newCollection! !!EventHandler methodsFor: 'access' stamp: 'sw 6/10/1999 13:34'!allRecipients	"Answer a list, without duplication, of all the objects serving as recipients to any of the events I handle.  Intended for debugging/documentation use only"	| aList |	aList _ OrderedCollection with: mouseDownRecipient with: mouseStillDownRecipient with: mouseUpRecipient with: mouseEnterRecipient with: mouseLeaveRecipient.	aList addAll: (OrderedCollection with:  mouseEnterDraggingRecipient with: mouseLeaveDraggingRecipient with: keyStrokeRecipient).	^ (aList copyWithout: nil) asSet asArray! !!EventHandler methodsFor: 'access' stamp: 'sw 6/10/1999 13:36'!printOn: aStream	| aVal recipients |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'keyStrokeSelector') do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: '; ', aName, '=', aVal]].	(recipients _ self allRecipients) size > 0 ifTrue:		[aStream nextPutAll: ' recipients: '.		recipients printOn: aStream]! !!Morph methodsFor: 'drawing' stamp: 'sw 6/9/1999 22:36'!visible: aBoolean	extension ifNil: [aBoolean ifTrue: [^ self]].	self visible == aBoolean ifTrue: [^ self].	self assureExtension visible: aBoolean.	self changed! !!HaloMorph methodsFor: 'private' stamp: 'sw 6/21/1999 14:51'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	evt shiftPressed ifTrue: 		[self delete.		^ innerTarget inspectInMorphic].	menu _ evt hand buildDebugHandleMenuFor: innerTarget.	menu addTitle: innerTarget externalName.	evt hand invokeMenu: menu event: evt.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 5/10/1999 15:42'!findWindow	"Present a menu of window titles, and activate the one that gets chosen.	Collapsed windows appear below line, expand if chosen."	| menu expanded collapsed |	menu _ MenuMorph new.	expanded _ SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed not].	collapsed _ SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed].	(expanded isEmpty & collapsed isEmpty) ifTrue: [^ self beep].	(expanded asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do:		[:w | menu add: w label target: w action: #activateAndForceLabelToShow.			w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	expanded isEmpty | collapsed isEmpty ifFalse: [menu addLine].	(collapsed asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do: 		[:w | menu add: w label target: w action: #collapseOrExpand.		w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	menu addTitle: 'find window'.		self invokeMenu: menu event: lastEvent! !!ScriptEvaluatorMorph reorganize!('initialization' initializeFor:)('drag and drop' acceptDroppingMorph:event: insertTileRow:after: rowInsertionIndexFor: wantsDroppedMorph:)('display' setDefaultBorderCharacteristics)('stepping' step)!!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 5/5/1999 16:03'!newStandardPartsBin	"StandardPartsBin _ nil.  self currentWorld presenter createStandardPartsBin"	StandardPartsBin ifNil:		[BookMorph turnOffSoundWhile:			[StandardPartsBin _ Presenter new newStandardPartsBinTitled: 'objects' includeControls: false]].	^ StandardPartsBin fullCopy! !!SystemWindow methodsFor: 'top window' stamp: 'sw 5/10/1999 15:42'!activateAndForceLabelToShow	self activate.	bounds top < 0 ifTrue:		[self position: (self position x @ 0)]! !!TabSorterMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/9/1999 23:15'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse appearanceMorph oldTop aMenu |	tabsToUse _ OrderedCollection new.	rejects _ OrderedCollection new.	pageHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: BookMorph) ifTrue:			[toAdd _ SorterTokenMorph forMorph: m].		(m isKindOf: SorterTokenMorph) ifTrue:			[toAdd _ m morphRepresented.			(toAdd referent isKindOf: MenuMorph) ifTrue:				[(aMenu _ toAdd referent) setProperty: #paletteMenu toValue: true.				((aMenu submorphs size > 1) and: [(aMenu submorphs second isKindOf: MenuItemMorph) and: [aMenu submorphs second contents = 'dismiss this menu']])					ifTrue:						[aMenu submorphs first delete.   "delete title"						aMenu submorphs first delete.   "delete stay-up item"						(aMenu submorphs first isKindOf: MenuLineMorph) ifTrue:							[aMenu submorphs first delete]]].			toAdd removeAllMorphs.			toAdd addMorph: (appearanceMorph _ m submorphs first).			appearanceMorph position: toAdd position.			appearanceMorph lock.			toAdd fitContents].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[tabsToUse add: toAdd]].	tabsToUse size == 0 ifTrue: [^ self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	book tabsMorph color: pageHolder color.	oldTop _ self topRendererOrSelf.  "in case some maniac has flexed the sorter"	oldOwner _ oldTop owner.	oldTop delete.	oldOwner addMorphFront: book! !!UpdatingBooleanStringMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/16/1999 13:30'!mouseDown: evt	self color: Color red! !Morph removeSelector: #assuredExtension!