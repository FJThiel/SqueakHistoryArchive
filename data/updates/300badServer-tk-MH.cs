'From Squeak 2.2beta of Sept 16, 1998 on 22 September 1998 at 2:47:02 pm'!!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 11:39'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 12:24'!getRestOfBuffer: beginning	"We don't know the length.  Keep going until connection is closed.  Part of it has already been received.  Response is of type text, not binary."	| buf response bytesRead |	response _ RWBinaryOrTextStream on: (String new: 2000).	response nextPutAll: beginning.	buf _ String new: 2000.	[self isConnected | self dataAvailable] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifTrue: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 				startingAt: 1 count: buf size. 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 14:35'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf _ String new: length.	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response size). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed']). 	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 14:29'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index first connectToHost connectToPort type argsString newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [		argsString _ WriteStream on: String new.		argsString nextPut: $?.		first _ true.		args associationsDo: [ :assoc |			assoc value do: [ :value |				first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].				argsString nextPutAll: assoc key encodeForHTTP.				argsString nextPut: $=.				argsString nextPutAll: value encodeForHTTP. ] ].		argsString _ argsString contents.		page _ page, argsString ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !