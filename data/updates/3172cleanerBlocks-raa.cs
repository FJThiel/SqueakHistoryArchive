'From Squeak2.9alpha of 17 July 2000 [latest update: #3229] on 5 January 2001 at 11:02:18 am'!"Change Set:		cleanerBlocksDate:			5 January 2001Author:			Bob ArningTry to clean up handling of blocks which are exported in ImageSegments. Previously, a warning message would be generated when such a block was reloaded if the receiver of the block had changed shape. Changes are:1. When exporting the segment, warn if blocks are being written which actually reference instance variables. Ideally one would stop and fix things so that this did not happen.2. When loading the segment, only issue the warning if blocks actually refer to an instance variable. Otherwise be silent.Two places that often exhibited the problem (the alarms and stepList of WorldState) are updaed via the postscript to use cleaner blocks.Assisting in this process is AbstractInstructionPrinter which can be the basis for other general examinations of bytecodes without getting all tangled up in the intricacies of instruction decoding.Also, if the change set is empty, suppress the question about whether to include it in the exported segment."!Object subclass: #AbstractInstructionPrinter	instanceVariableNames: 'bingo '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!AbstractInstructionPrinter commentStamp: '<historical>' prior: 0!My job is to make it easier to scan bytecodes for specific actions, e.g. any instance variable reference.BlockContext allInstances collect: [ :x |	{x. x hasInstVarRef}].!AbstractInstructionPrinter subclass: #InstVarRefLocator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!AbstractInstructionPrinter methodsFor: 'initialize-release' stamp: 'RAA 1/5/2001 08:43'!interpretNextInstructionUsing: aScanner 		bingo _ false.	aScanner interpretNextInstructionFor: self.	^bingo! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!blockReturnTop	"Print the Return Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!doDup	"Print the Duplicate Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!doPop	"Print the Remove Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:31'!jump: offset	"Print the Unconditional Jump bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:32'!jump: offset if: condition 	"Print the Conditional Jump bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!methodReturnConstant: value 	"Print the Return Constant bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!methodReturnReceiver	"Print the Return Self bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!methodReturnTop	"Print the Return Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!popIntoLiteralVariable: anAssociation 	"Print the Remove Top Of Stack And Store Into Literal Variable bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!popIntoReceiverVariable: offset 	"Print the Remove Top Of Stack And Store Into Instance Variable 	bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:33'!popIntoTemporaryVariable: offset 	"Print the Remove Top Of Stack And Store Into Temporary Variable 	bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!pushActiveContext	"Print the Push Active Context On Top Of Its Own Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!pushConstant: value	"Print the Push Constant, value, on Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!pushLiteralVariable: anAssociation	"Print the Push Contents Of anAssociation On Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!pushReceiver	"Print the Push Active Context's Receiver on Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!pushReceiverVariable: offset	"Print the Push Contents Of the Receiver's Instance Variable Whose Index 	is the argument, offset, On Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!pushTemporaryVariable: offset	"Print the Push Contents Of Temporary Variable Whose Index Is the 	argument, offset, On Top Of Stack bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!send: selector super: supered numArgs: numberArguments	"Print the Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!storeIntoLiteralVariable: anAssociation 	"Print the Store Top Of Stack Into Literal Variable Of Method bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!storeIntoReceiverVariable: offset 	"Print the Store Top Of Stack Into Instance Variable Of Method bytecode."! !!AbstractInstructionPrinter methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:34'!storeIntoTemporaryVariable: offset 	"Print the Store Top Of Stack Into Temporary Variable Of Method 	bytecode."! !!BlockContext methodsFor: 'accessing' stamp: 'RAA 1/5/2001 08:50'!hasInstVarRef	"Answer whether the receiver references an instance variable."	| method scanner end printer |	home ifNil: [^false].	method _ self method.	"Determine end of block from long jump preceding it"	end _ (method at: startpc-2)\\16-4*256 + (method at: startpc-1) + startpc - 1.	scanner _ InstructionStream new method: method pc: startpc.	printer _ InstVarRefLocator new.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 1/5/2001 10:26'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements world naughtyBlocks goodToGo |	Smalltalk forgetDoIts.  	1 to: 5 do: [:ii | ((rootArray at: ii) respondsTo: #isCurrentProject) ifTrue: [					world _ rootArray at: ii]].	world ifNotNil: [world presenter flushPlayerListCache].	"old and outside guys"	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	"refs _ dummy references."	arrayOfRoots _ self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements _ dummy blockers.	dummy project ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy _ nil.	"force GC?"		naughtyBlocks _ arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	naughtyBlocks isEmpty ifFalse: [		goodToGo _ PopUpMenu			confirm: 'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?' 			trueChoice: 'keep going' 			falseChoice: 'stop and take a look'.		goodToGo ifFalse: [			naughtyBlocks inspect.			self halt.		].	].	"Creation of the segment happens here"	"try using one-quarter of memory to publish (will get bumped later)"	self copyFromRoots: arrayOfRoots sizeHint: (Smalltalk garbageCollect // 4 // 4) areUnique: true.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	symbolHolder.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 1/5/2001 09:53'!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object sets receiverClasses inSeg reorder |	object _ segment.	sets _ OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses _ IdentitySet new.	reorder _ (Smalltalk endianness) ~~ 		((segment first bitShift: -24) asCharacter == $d ifTrue: [#big] ifFalse: [#little]).	inSeg _ true.	[object _ object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg _ false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: Set) ifTrue: [sets add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class				]			].				(reorder and: [(object class == SoundBuffer) & inSeg]) ifTrue: [object swapHalves]]. 		object == 0] whileFalse.	sets do: [:each | each rehash].	"our purpose"	^ receiverClasses	"our secondary job"! !!InstVarRefLocator methodsFor: 'as yet unclassified' stamp: 'RAA 1/5/2001 08:46'!popIntoReceiverVariable: offset 	bingo _ true! !!InstVarRefLocator methodsFor: 'as yet unclassified' stamp: 'RAA 1/5/2001 08:46'!pushReceiverVariable: offset	bingo _ true! !!InstVarRefLocator methodsFor: 'as yet unclassified' stamp: 'RAA 1/5/2001 08:46'!storeIntoReceiverVariable: offset 	bingo _ true! !!MethodContext methodsFor: 'accessing' stamp: 'RAA 1/5/2001 09:45'!hasInstVarRef	"Answer whether the receiver references an instance variable."	| scanner end printer |	scanner _ InstructionStream on: method.	printer _ InstVarRefLocator new.	end _ self method endPC.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!Project methodsFor: 'file in/out' stamp: 'RAA 1/5/2001 10:59'!exportSegmentFileName: aFileName directory: aDirectory	| exportChangeSet |	"An experimental version to fileout a changeSet first so that a project can contain its own classes"	"Store my project out on the disk as an *exported* ImageSegment.  Put all outPointers in a form that can be resolved in the target image.  Name it <project name>.extSeg.	Player classes are included automatically."	exportChangeSet _ nil.	(changeSet notNil and: [changeSet isEmpty not]) ifTrue: [		(self confirm: 'Would you like to include all the changes in the change setas part of this publishing operation?') ifTrue: [			exportChangeSet _ changeSet		].	].	^ self 		exportSegmentWithChangeSet: exportChangeSet		fileName: aFileName 		directory: aDirectory! !!WorldState methodsFor: 'initialization' stamp: 'RAA 1/5/2001 10:47'!initialize	hands _ Array new.	damageRecorder_ DamageRecorder new.	stepList _ Heap sortBlock: self stepListSortBlock.	lastStepTime _ 0.	lastAlarmTime _ 0.! !!WorldState methodsFor: 'initialization' stamp: 'RAA 1/5/2001 10:46'!stepListSortBlock	^[ :stepMsg1 :stepMsg2 | stepMsg1 scheduledTime <= stepMsg2 scheduledTime]! !!WorldState methodsFor: 'object fileIn' stamp: 'RAA 1/5/2001 10:51'!convertAlarms		alarms ifNotNil: [alarms sortBlock: self alarmSortBlock].	"ensure cleaner block"! !!WorldState methodsFor: 'object fileIn' stamp: 'RAA 1/5/2001 10:48'!convertStepList	"Convert the old-style step list (an Array of Arrays) into the new-style StepMessage heap"	| newList wakeupTime morphToStep |	(stepList isKindOf: Heap) ifTrue:[		^stepList sortBlock: self stepListSortBlock	"ensure that we have a cleaner block"	].	newList _ Heap sortBlock: self stepListSortBlock.	stepList do:[:entry|		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		newList add: (			StepMessage				scheduledAt: wakeupTime				stepTime: nil				receiver: morphToStep				selector: #stepAt:				arguments: nil).	].	stepList _ newList.! !!WorldState methodsFor: 'object fileIn' stamp: 'RAA 1/5/2001 10:51'!convertToCurrentVersion: varDict refStream: smartRefStrm		"Convert the old to new step lists"	self convertStepList.	self convertAlarms.	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!WorldState methodsFor: 'alarms' stamp: 'RAA 1/5/2001 10:45'!alarmSortBlock	^[ :alarm1 :alarm2 | alarm1 scheduledTime < alarm2 scheduledTime]! !!WorldState methodsFor: 'alarms' stamp: 'RAA 1/5/2001 10:46'!alarms	^alarms ifNil: [alarms _ Heap sortBlock: self alarmSortBlock]! !"Postscript:Ensure that the step list and alarms are using cleaner blocks."WorldState allInstancesDo: [ :each | each convertAlarms; convertStepList].!