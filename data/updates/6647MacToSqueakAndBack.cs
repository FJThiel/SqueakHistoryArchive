'From Squeak3.8gamma of ''24 November 2004'' [latest update: #6643] on 10 April 2005 at 7:16:22 pm'!"Change Set:		MacToSqueakAndBackDate:			10 April 2005Author:			Andreas RaabThe current implementations and uses of #squeakToIso and #isoToSqueak are broken. They still assume that the internal encoding of Squeak is MacRoman (which it no longer is) and will therefore cause problems when clients still use these methods.This change set acknowledges the changed realities by making isoToSqueak and squeakToIso no-ops and rather introduce macToSqueak and squeakToMac (which, under the old regime, would have been the no-ops)."!!AbstractString methodsFor: 'internet' stamp: 'ar 4/9/2005 22:16'!isoToSqueak	^self "no longer needed"! !!AbstractString methodsFor: 'internet' stamp: 'ar 4/10/2005 15:58'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	^ self collect: [:each | each macToSqueak]! !!AbstractString methodsFor: 'internet' stamp: 'ar 4/9/2005 22:16'!squeakToIso	^self "no longer needed"! !!AbstractString methodsFor: 'internet' stamp: 'ar 4/10/2005 15:55'!squeakToMac	"Convert the receiver from Squeak to MacRoman encoding"	^ self collect: [:each | each squeakToMac]! !!Character methodsFor: 'converting' stamp: 'ar 4/9/2005 22:15'!isoToSqueak 	^self "no longer needed"! !!Character methodsFor: 'converting' stamp: 'ar 4/10/2005 16:05'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue _ #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 255 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 253 254 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'converting' stamp: 'ar 4/9/2005 22:16'!squeakToIso	^self "no longer needed"! !!Character methodsFor: 'converting' stamp: 'ar 4/10/2005 16:05'!squeakToMac	"Convert the receiver from Squeak to MacRoman encoding."	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	^ Character value: (#(		173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183	"80-8F"		184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217	"90-9F"		202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248	"A0-AF"		161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 	"B0-BF"		203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 	"C0-CF"		245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167	"D0-DF"		136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149	"E0-EF"		253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216	"F0-FF"	) at: value - 127)! !!CP1250ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:09'!fromSystemClipboard: aString	| result converter |	result := WriteStream on: (String new: aString size).	converter := CP1250TextConverter new.	aString do: [:each |		result nextPut: (converter toSqueak: each macToSqueak) asCharacter.	].	^ result contents.! !!CP1250ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:05'!toSystemClipboard: aString	| result converter r |	aString isAsciiString ifTrue: [^ aString asOctetString]. "optimization"	result _ WriteStream on: (String new: aString size).	converter _ CP1250TextConverter new.	aString do: [:each |		r _ converter fromSqueak: each.		r charCode < 255 ifTrue: [		result nextPut: r squeakToMac]].	^ result contents.! !!CP1250InputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	"Input from the Czech keyboard under Windows doesn't correspond to cp-1250 or iso-8859-2 encoding!!"	| keyValue |	keyValue := evtBuf third.	^ converter toSqueak: keyValue asCharacter macToSqueak.! !!MacRomanClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!fromSystemClipboard: aString	^ aString macToSqueak.! !!MacRomanClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:05'!toSystemClipboard: aString	| result |	aString isOctetString ifTrue: [^ aString asOctetString squeakToMac].	result _ WriteStream on: (String new: aString size).	aString do: [:each | each asciiValue < 256 ifTrue: [result nextPut: each squeakToMac]].	^ result contents.! !!MacRomanInputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	^ keyValue asCharacter macToSqueak.! !!MacRomanTextConverter methodsFor: 'conversion' stamp: 'ar 4/10/2005 16:10'!nextFromStream: aStream 	| character1 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 _ aStream basicNext.	character1 isNil ifTrue: [^ nil].	character1 charCode = 165 ifTrue: [^ (Character value: 183)].	^ character1 macToSqueak.! !!MacRomanTextConverter methodsFor: 'conversion' stamp: 'ar 4/10/2005 16:05'!nextPut: aCharacter toStream: aStream 	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	aStream basicNextPut: aCharacter squeakToMac.! !!MacUnicodeInputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	keyValue < 256 ifTrue: [^ (Character value: keyValue) macToSqueak].	"Smalltalk systemLanguage charsetClass charFromUnicode: keyValue."	^ Unicode value: keyValue.! !!SymbolInputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	| keyValue |	keyValue := evtBuf third.	evtBuf fifth > 1 ifTrue: [^ keyValue asCharacter macToSqueak].	^ (self symbolKeyValueToUnicode: keyValue) asCharacter.! !!Text methodsFor: 'converting' stamp: 'ar 4/9/2005 22:16'!isoToSqueak	^self "no longer needed"! !!Text methodsFor: 'converting' stamp: 'ar 4/10/2005 15:58'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	^ self class new setString: string macToSqueak setRuns: runs copy! !!Text methodsFor: 'converting' stamp: 'ar 4/9/2005 22:16'!squeakToIso	^self "no longer needed"! !!Text methodsFor: 'converting' stamp: 'ar 4/10/2005 15:56'!squeakToMac	"Convert the receiver from Squeak to MacRoman encoding"	^ self class new setString: string squeakToMac setRuns: runs copy! !!TTFontReader methodsFor: 'private' stamp: 'ar 4/10/2005 16:10'!macToWin: index	^ (index - 1) asCharacter macToSqueak asciiValue + 1! !!TTFontReader methodsFor: 'private' stamp: 'ar 4/10/2005 16:11'!winToMac: index	^ (index - 1) asCharacter squeakToMac asciiValue + 1! !!WinGB2312ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:09'!fromSystemClipboard: aString	^ aString squeakToMac convertFromSystemString.! !!WinGB2312ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:09'!toSystemClipboard: text	| string |	"self halt."	string _ text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string "hmm"].	^ string convertToSystemString squeakToMac.! !!WinGB2312InputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	| firstCharacter secondCharacter peekEvent char1Value keyValue pressType type stream multiCharacter |	keyValue := evtBuf third.	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	char1Value _ (Character value: keyValue) macToSqueak asciiValue.	((char1Value > 127 and: [char1Value < 160])		or: [char1Value > 223 and: [char1Value < 253]]) ifFalse: [			^ keyValue asCharacter.		].	peekEvent _ sensor peekEvent.	"peekEvent printString displayAt: 0@0."	(peekEvent notNil and: [(peekEvent at: 4) = EventKeyDown])		ifTrue: [sensor nextEvent.			peekEvent _ sensor peekEvent].	(type = #keystroke			and: [peekEvent notNil					and: [(peekEvent at: 1)								= EventTypeKeyboard							and: [(peekEvent at: 4)									= EventKeyChar]]])		ifTrue: [			firstCharacter _ char1Value asCharacter.			secondCharacter _ (peekEvent at: 3) asCharacter macToSqueak.			stream _ ReadStream on: (String with: firstCharacter with: secondCharacter).			multiCharacter _ converter nextFromStream: stream.			multiCharacter isOctetCharacter ifFalse: [				sensor nextEvent.			].			^ multiCharacter.		].	^ keyValue asCharacter.! !!WinKSX1001ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:09'!fromSystemClipboard: aString	^ aString squeakToMac convertFromSystemString.! !!WinKSX1001ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:09'!toSystemClipboard: text	| string |	"self halt."	string _ text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string "hmm"].	^ string convertToSystemString squeakToMac.! !!WinKSX1001InputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	| firstCharacter secondCharacter peekEvent char1Value keyValue pressType type stream multiCharacter |	keyValue := evtBuf third.	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	char1Value _ (Character value: keyValue) macToSqueak asciiValue.	((char1Value > 127 and: [char1Value < 160])		or: [char1Value > 223 and: [char1Value < 253]]) ifFalse: [			^ keyValue asCharacter.		].	peekEvent _ sensor peekEvent.	"peekEvent printString displayAt: 0@0."	(peekEvent notNil and: [(peekEvent at: 4) = EventKeyDown])		ifTrue: [sensor nextEvent.			peekEvent _ sensor peekEvent].	(type = #keystroke			and: [peekEvent notNil					and: [(peekEvent at: 1)								= EventTypeKeyboard							and: [(peekEvent at: 4)									= EventKeyChar]]])		ifTrue: [			firstCharacter _ char1Value asCharacter.			secondCharacter _ (peekEvent at: 3) asCharacter macToSqueak.			stream _ ReadStream on: (String with: firstCharacter with: secondCharacter).			multiCharacter _ converter nextFromStream: stream.			multiCharacter isOctetCharacter ifFalse: [				sensor nextEvent.			].			^ multiCharacter.		].	^ keyValue asCharacter.! !!WinShiftJISClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!fromSystemClipboard: aString	^ aString macToSqueak convertFromSystemString! !!WinShiftJISClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:09'!toSystemClipboard: text	| string |	"self halt."	string _ text asString.	string isAsciiString ifTrue: [^ string asOctetString].	string isOctetString ifTrue: [^ string "hmm"].	^ string convertToSystemString squeakToMac.! !!WinShiftJISInputInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 16:10'!nextCharFrom: sensor firstEvt: evtBuf	| firstCharacter secondCharacter peekEvent char1Value keyValue pressType type stream multiCharacter |	keyValue := evtBuf third.	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	char1Value _ (Character value: keyValue) macToSqueak asciiValue.	(char1Value < 16r81) ifTrue: [^ keyValue asCharacter].	(char1Value > 16rA0 and: [char1Value < 16rE0]) ifTrue: [^ ShiftJISTextConverter basicNew katakanaValue: char1Value].	peekEvent _ sensor peekEvent.	"peekEvent printString displayAt: 0@0."	(peekEvent notNil and: [(peekEvent at: 4) = EventKeyDown])		ifTrue: [sensor nextEvent.			peekEvent _ sensor peekEvent].	(type = #keystroke			and: [peekEvent notNil					and: [(peekEvent at: 1)								= EventTypeKeyboard							and: [(peekEvent at: 4)									= EventKeyChar]]])		ifTrue: [			firstCharacter _ char1Value asCharacter.			secondCharacter _ (peekEvent at: 3) asCharacter macToSqueak.			stream _ ReadStream on: (String with: firstCharacter with: secondCharacter).			multiCharacter _ converter nextFromStream: stream.			multiCharacter isOctetCharacter ifFalse: [				sensor nextEvent.			].			^ multiCharacter.		].	^ keyValue asCharacter.! !TTFontDescription removeSelector: #migrateSqueakToIso!StrikeFont removeSelector: #migrateSqueakToIso!