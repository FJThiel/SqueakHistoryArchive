'From Squeak3.2alpha of 2 October 2001 [latest update: #4543] on 25 November 2001 at 2:10:45 pm'!"Change Set:		Morphic-Chess-arDate:			25 November 2001Author:			Andreas RaabA long-term project of mine has always been to write a nice little chess program for Squeak. But since I haven't done anything on it in the last few months I'm just going to throw it at the community to see if someone is interested in doing a bit more. It's a playing ... but not well :-( So, go get it from the objects tool and improve it!!"Smalltalk at: #ChessConstants put: Dictionary new.!Object subclass: #ChessBoard	instanceVariableNames: 'whitePlayer blackPlayer activePlayer userAgent searchAgent generator hashKey hashLock '	classVariableNames: 'HashKeys HashLocks '	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessBoard commentStamp: '<historical>' prior: 0!This class represents the chess board itself.!ChessBoard class	instanceVariableNames: ''!Object variableWordSubclass: #ChessHistoryTable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessHistoryTable commentStamp: '<historical>' prior: 0!This class is a history table for our 'killer heuristic'. It remembers moves that have proven effective in the past and is later used to prioritize newly generated moves according to the effectiveness of the particular move in the past.!ChessHistoryTable class	instanceVariableNames: ''!BorderedMorph subclass: #ChessMorph	instanceVariableNames: 'board history redoList animateMove autoPlay '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessMorph commentStamp: '<historical>' prior: 0!This class defines the user interface for a fine game of chess.!ChessMorph class	instanceVariableNames: ''!Object subclass: #ChessMove	instanceVariableNames: 'movingPiece capturedPiece sourceSquare destinationSquare type value bestMove '	classVariableNames: 'BasicMoveMask EvalTypeAccurate EvalTypeLowerBound EvalTypeUpperBound ExtractPromotionShift MoveCaptureEnPassant MoveCaptureOrdinary MoveCastlingKingSide MoveCastlingQueenSide MoveDoublePush MoveNormal MovePromotionBishop MovePromotionKnight MovePromotionQueen MovePromotionRook MoveResign MoveStaleMate NoPromotionMask NullMove PromotionMask PromotionShift '	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessMove commentStamp: '<historical>' prior: 0!I represent a particular move in the chess game.!ChessMove class	instanceVariableNames: ''!Object subclass: #ChessMoveGenerator	instanceVariableNames: 'myPlayer myPieces itsPieces castlingStatus enpassantSquare forceCaptures moveList firstMoveIndex lastMoveIndex streamList streamListIndex attackSquares kingAttack '	classVariableNames: 'EmptyPieceMap '	poolDictionaries: 'ChessConstants '	category: 'Morphic-Games-Chess'!!ChessMoveGenerator commentStamp: '<historical>' prior: 0!This class generates moves for any given board. It's speed is critical - for each new position all moves need to be generated in that position. It may be worthwhile to make give this class a little plugin support at some time.!ReadStream subclass: #ChessMoveList	instanceVariableNames: 'startIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessMoveList commentStamp: '<historical>' prior: 0!An optimized representation of a set of moves - mainly there to avoid excessive allocation (and garbage collections) in a few critical places.!ImageMorph subclass: #ChessPieceMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games-Chess'!Object subclass: #ChessPlayer	instanceVariableNames: 'board pieces opponent castlingRookSquare enpassantSquare castlingStatus materialValue numPawns positionalValue '	classVariableNames: ''	poolDictionaries: 'ChessConstants '	category: 'Morphic-Games-Chess'!!ChessPlayer commentStamp: '<historical>' prior: 0!This class represents a player in the game, including its pieces and the current value of the player's position.!ChessPlayer class	instanceVariableNames: ''!Object subclass: #ChessPlayerAI	instanceVariableNames: 'board boardList boardListIndex player historyTable transTable generator random variations activeVariation bestVariation nodesVisited ttHits stamp alphaBetaCuts startTime ply myMove myProcess stopThinking bestMove '	classVariableNames: 'AlphaBetaGiveUp AlphaBetaIllegal AlphaBetaMaxVal AlphaBetaMinVal ValueAccurate ValueBoundary ValueLowerBound ValueThreshold ValueUpperBound '	poolDictionaries: 'ChessConstants '	category: 'Morphic-Games-Chess'!!ChessPlayerAI commentStamp: '<historical>' prior: 0!I am the AI that will beat you eventually. Well, maybe not today ... BUT MY TIME WILL COME!!!!!!!ChessPlayerAI class	instanceVariableNames: ''!Object subclass: #ChessTTEntry	instanceVariableNames: 'value valueType depth hashLock timeStamp '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessTTEntry commentStamp: '<historical>' prior: 0!This class represents an entry in the transposition table, storing the value (plus some maintenance information) of some position.!Object subclass: #ChessTranspositionTable	instanceVariableNames: 'array used collisions '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Games-Chess'!!ChessTranspositionTable commentStamp: '<historical>' prior: 0!The transposition table is a lookup cache for positions in a game that occur through transpositions in move. As an example, the same position is obtained by the moves:	1. e2-e4		Nb8-c6	2. d2-d4and	1. d2-d4		Nb8-c6	2. e2-e4An extremely large number of search branches can be cut off immediately by recognizing that the current position is just the transposition of another one. The transposition table is one of the techniques that actually make modern chess programs good enough to compete with or even beat humans.!ChessTranspositionTable class	instanceVariableNames: ''!!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:04'!initialize	generator ifNil:[generator _ ChessMoveGenerator new initialize].	searchAgent ifNil:[searchAgent _ ChessPlayerAI new initialize].	self resetGame.! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/9/2001 03:50'!initializeNewBoard	self resetGame.	whitePlayer addWhitePieces.	blackPlayer addBlackPieces.! !!ChessBoard methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:19'!resetGame	hashKey _ hashLock _ 0.	whitePlayer _ ChessPlayer new initialize.	blackPlayer _ ChessPlayer new initialize.	whitePlayer opponent: blackPlayer.	whitePlayer board: self.	blackPlayer opponent: whitePlayer.	blackPlayer board: self.	activePlayer _ whitePlayer.	searchAgent reset: self.	userAgent ifNotNil:[userAgent gameReset].! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 23:02'!activePlayer	^activePlayer! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:41'!blackPlayer	^blackPlayer! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/10/2001 06:15'!generator	^generator! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:04'!searchAgent	^searchAgent! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:04'!searchAgent: anAgent	searchAgent _ anAgent.! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/12/2001 22:53'!statusString	^searchAgent statusString! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/9/2001 03:49'!userAgent	^userAgent! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:19'!userAgent: anObject	userAgent _ anObject.! !!ChessBoard methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:41'!whitePlayer	^whitePlayer! !!ChessBoard methodsFor: 'moving' stamp: 'ar 10/18/2001 20:19'!movePieceFrom: sourceSquare to: destSquare	| move |	searchAgent isThinking ifTrue:[^self].	move _ (activePlayer findPossibleMovesAt: sourceSquare) contents		detect:[:any| any destinationSquare = destSquare].	self nextMove: move.	searchAgent activePlayer: activePlayer.! !!ChessBoard methodsFor: 'moving' stamp: 'ar 8/9/2001 11:40'!nextMove: aMove	activePlayer applyMove: aMove.	userAgent ifNotNil:[userAgent completedMove: aMove white: activePlayer isWhitePlayer].	activePlayer == whitePlayer		ifTrue:[activePlayer _ blackPlayer]		ifFalse:[activePlayer _ whitePlayer].	activePlayer prepareNextMove.! !!ChessBoard methodsFor: 'moving' stamp: 'ar 8/25/2001 00:33'!nullMove	activePlayer == whitePlayer		ifTrue:[activePlayer _ blackPlayer]		ifFalse:[activePlayer _ whitePlayer].	activePlayer prepareNextMove.! !!ChessBoard methodsFor: 'moving' stamp: 'ar 8/9/2001 22:16'!undoMove: aMove	activePlayer == whitePlayer		ifTrue:[activePlayer _ blackPlayer]		ifFalse:[activePlayer _ whitePlayer].	activePlayer undoMove: aMove.	userAgent ifNotNil:[userAgent undoMove: aMove white: activePlayer isWhitePlayer].! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/9/2001 04:14'!copy	^self shallowCopy postCopy! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/24/2001 18:28'!copyBoard: aBoard	"Copy all volatile state from the given board"	whitePlayer copyPlayer: aBoard whitePlayer.	blackPlayer copyPlayer: aBoard blackPlayer.	aBoard activePlayer isWhitePlayer		ifTrue:[activePlayer _ whitePlayer]		ifFalse:[activePlayer _ blackPlayer].	hashKey _ aBoard hashKey.	hashLock _ aBoard hashLock.	userAgent _ nil.! !!ChessBoard methodsFor: 'copying' stamp: 'ar 8/9/2001 17:35'!postCopy	whitePlayer == activePlayer ifTrue:[		whitePlayer _ whitePlayer copy.		blackPlayer _ blackPlayer copy.		activePlayer _ whitePlayer.	] ifFalse:[		whitePlayer _ whitePlayer copy.		blackPlayer _ blackPlayer copy.		activePlayer _ blackPlayer.	].	whitePlayer opponent: blackPlayer.	blackPlayer opponent: whitePlayer.	whitePlayer board: self.	blackPlayer board: self.	self userAgent: nil.! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 8/9/2001 23:45'!hashKey	^hashKey! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 8/9/2001 23:45'!hashLock	^hashLock! !!ChessBoard methodsFor: 'hashing' stamp: 'ar 10/18/2001 20:20'!updateHash: piece at: square from: player	| index |	player == whitePlayer ifTrue:[index _ piece] ifFalse:[index _ piece + 6].	hashKey _ hashKey bitXor: ((HashKeys at: index) at: square).	hashLock _ hashLock bitXor: ((HashLocks at: index) at: square).! !!ChessBoard methodsFor: 'printing' stamp: 'ar 8/24/2001 18:25'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: hashKey; space; print: hashLock;		nextPut: $).! !!ChessBoard class methodsFor: 'class initialization' stamp: 'ar 8/9/2001 23:44'!initialize	"ChessGame initialize"	self initializeHashKeys.! !!ChessBoard class methodsFor: 'class initialization' stamp: 'ar 10/18/2001 23:22'!initializeHashKeys	"ChessGame initialize"	| random |	HashKeys _ Array new: 12.	1 to: HashKeys size do:[:i| HashKeys at: i put: (WordArray new: 64)].	HashLocks _ Array new: 12.	1 to: HashLocks size do:[:i| HashLocks at: i put: (WordArray new: 64)].	random _ Random seed: 23648646.	1 to: 12 do:[:i|		1 to: 64 do:[:j|			(HashKeys at: i) at: j put: (random nextInt: SmallInteger maxVal) - 1.			(HashLocks at: i) at: j put: (random nextInt: SmallInteger maxVal) - 1.		].	].! !!ChessHistoryTable methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:18'!atAllPut: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!ChessHistoryTable methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:18'!clear	self atAllPut: 0.! !!ChessHistoryTable methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:18'!addMove: aMove	| index |	index _ (aMove sourceSquare bitShift: 6) + aMove destinationSquare.	self at: index put: (self at: index + 1)! !!ChessHistoryTable methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:18'!sorts: move1 before: move2	^(self at: (move1 sourceSquare bitShift: 6) + move1 destinationSquare) >		(self at: (move2 sourceSquare bitShift: 6) + move2 destinationSquare)! !!ChessHistoryTable class methodsFor: 'instance creation' stamp: 'ar 8/9/2001 17:50'!new	^self new: 4096+64! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 10/18/2001 21:01'!addButtonRow	| r m |	r _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; color: Color transparent.	r addMorphBack: (self buttonName: '  New  ' action: #newGame).	r addMorphBack: (self buttonName: '  Help  ' action: #findBestMove).	r addMorphBack: (self buttonName: '  Play  ' action: #thinkAndMove).	r addMorphBack: (self buttonName: '  Auto  ' action: #autoPlay).	r addMorphBack: (self buttonName: '  Undo  ' action: #undoMove).	r addMorphBack: (self buttonName: '  Redo  ' action: #redoMove).	r addMorphBack: (self buttonName: '  Quit  ' action: #delete).	r disableTableLayout: true.	r align: r bounds topLeft with: self layoutBounds topLeft.	self addMorphFront: r.	m _ UpdatingStringMorph on: self selector: #statusString.	m useStringFormat.	m disableTableLayout: true.	m align: m bounds topLeft with: r fullBounds bottomLeft.	self addMorphFront: m.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:34'!addSquares	| white black square index |	white _ Color white.	black _ Color lightGray.	index _ 0.	#(		(	' '	'a'	'b'	'c'	'd'	'e'	'f'	'g'	'h'	' ')		(	'1'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'2'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'3'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'4'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'5'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'6'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	'7'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	' ')		(	'8'	'W'	'B'	'W'	'B'	'W'	'B'	'W'	'B'	' ')		(	' '	' '	' '	' '	' '	' '	' '	' '	' '	' ')	) do:[:file|		file do:[:sq|		square _ self newSquare.		square borderWidth: 0.		(sq = 'W' or:[sq = 'B']) ifTrue:[			square color: (sq = 'W' ifTrue:[white] ifFalse:[black]).			square borderColor: Color red.			square setProperty: #squarePosition toValue: (index _ index + 1).			square setNameTo: 				(String with: ($a asInteger + (index - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (index -1 bitShift: -3)) asCharacter).			square on: #mouseEnter send: #showMoves:from: to: self.			square on: #mouseEnterDragging send: #dragSquareEnter:from: to: self.			square on: #mouseLeaveDragging send: #dragSquareLeave:from: to: self.		] ifFalse:["decoration"			square color: Color transparent.			sq = ' ' ifFalse:[				square addMorphCentered: (StringMorph contents: sq asUppercase font: Preferences windowTitleFont emphasis: 1).			].		].		square extent: 40@40.		self addMorphBack: square.	]].! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 12:25'!buttonFillStyle	| fill |	fill _ GradientFillStyle ramp: {		0.0 -> (Color r: 0.05 g: 0.5 b: 1.0). 		1.0 -> (Color r: 0.85 g: 0.95 b: 1.0)}.	fill origin: (0@0).	fill direction: 40@10.	fill radial: false.	^ fill! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 12:18'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol;		color: (Color gray: 0.8);  "old color"		fillStyle: self buttonFillStyle;		borderWidth: 0;		borderColor: #raised.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 10/18/2001 21:01'!initialize	| fs |	super initialize.	animateMove _ false.	autoPlay _ false.	self borderWidth: 5.	self extent: 410@410.	fs _ GradientFillStyle ramp: {		0.0 -> (Color r: 0.05 g: 0.5 b: 1.0). 		1.0 -> (Color r: 0.85 g: 0.95 b: 1.0)}.	fs origin: self bounds origin; direction: (self extent).	fs radial: false.	self fillStyle: fs.	self borderColor: #raised.	self cornerStyle: #rounded.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight; wrapDirection: #bottomToTop.	self addSquares.	self addButtonRow.	self newGame.! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/10/2001 10:22'!newPiece: piece white: isWhite	| index selector m |	index _ piece.	isWhite ifFalse:[index _ index + 6].	selector _ #(			whitePawnImage		whiteKnightImage		whiteBishopImage		whiteRookImage		whiteQueenImage		whiteKingImage		blackPawnImage		blackKnightImage		blackBishopImage		blackRookImage		blackQueenImage		blackKingImage) at: index.	m _ ChessPieceMorph new image: (self class perform: selector).	m setProperty: #isWhite toValue: isWhite.	m setProperty: #piece toValue: piece.	^m! !!ChessMorph methodsFor: 'initialize' stamp: 'ar 8/8/2001 22:53'!newSquare	^BorderedMorph new "or anyone alike"! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/8/2001 23:59'!areasRemainingToFill: x	^x areasOutside: self bounds! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:46'!asSquare: aPoint	self squaresDo:[:sq| (sq bounds containsPoint: aPoint) ifTrue:[^sq valueOfProperty: #squarePosition]].	^nil! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:34'!atSquare: square	^submorphs detect:[:any| (any valueOfProperty: #squarePosition) = square] ifNone:[nil]! !!ChessMorph methodsFor: 'geometry' stamp: 'ar 8/10/2001 11:34'!squaresDo: aBlock	^submorphs do:[:m| (m hasProperty: #squarePosition) ifTrue:[aBlock value: m]].! !!ChessMorph methodsFor: 'events' stamp: 'ar 10/18/2001 20:21'!showMoves: evt from: aMorph	| square |	square _ aMorph valueOfProperty: #squarePosition.	square ifNotNil:[^self showMovesAt: square].! !!ChessMorph methodsFor: 'events' stamp: 'ar 10/18/2001 20:13'!showMovesAt: square	| list |	board ifNil:[^self].	board searchAgent isThinking ifTrue:[^self].	self squaresDo:[:m| m borderWidth: 0].	list _ board activePlayer findValidMovesAt: square.	list isEmpty ifTrue:[^self].	(self atSquare: square) borderWidth: 1.	list do:[:move|		(self atSquare: move destinationSquare) borderWidth: 1.	].! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 8/10/2001 11:50'!acceptDroppingMorph: aMorph event: anEvent	| destSquare sourceSquare |	sourceSquare _ aMorph valueOfProperty: #chessBoardSourceSquare.	aMorph removeProperty: #chessBoardSourceSquare.	destSquare _ self asSquare: aMorph center.	"!!!!!! ACTUAL MOVE HAPPENS INDIRECTLY !!!!!!"	(self atSquare: sourceSquare) addMorphCentered: aMorph.	destSquare ifNil:[^self].	self movePieceFrom: sourceSquare to: destSquare.	self showMovesAt: destSquare.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!dragPiece: evt from: aMorph	board searchAgent isThinking ifTrue:[^self].	self submorphsDo:[:m| m borderWidth: 0].	aMorph setProperty: #chessBoardSourceSquare toValue: (aMorph owner valueOfProperty: #squarePosition).	evt hand grabMorph: aMorph.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!dragSquareEnter: evt from: aMorph	"Note: #wantsDroppedMorph: will validate move"	board ifNil:[^self].	evt hand hasSubmorphs ifFalse:[^self].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifFalse:[^self].	aMorph borderWidth: 1.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:10'!dragSquareLeave: evt from: aMorph	board ifNil:[^self].	evt hand hasSubmorphs ifFalse:[^self].	aMorph borderWidth: 0.! !!ChessMorph methodsFor: 'drag and drop' stamp: 'ar 10/18/2001 20:11'!wantsDroppedMorph: aMorph event: anEvent	| sourceSquare destSquare |	(aMorph valueOfProperty: #chessBoard) == self ifFalse:[^false].	board ifNil:[^true].	sourceSquare _ aMorph valueOfProperty: #chessBoardSourceSquare.	destSquare _ self asSquare: aMorph bounds center.	destSquare ifNil:[^false].	^board activePlayer isValidMoveFrom: sourceSquare to: destSquare! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/10/2001 11:35'!addedPiece: piece at: square white: isWhite	| m |	m _ self newPiece: piece white: isWhite.	m on: #mouseDown send: #dragPiece:from: to: self.	m setProperty: #chessBoard toValue: self.	(self atSquare: square) removeAllMorphs; addMorphCentered: m.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:11'!completedMove: aMove white: aBool	board ifNil:[^self].	history addLast: aMove.	self validateGamePosition.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:13'!finishedGame: result	"		0 - white lost		0.5 - draw		1 - white won	"	board _ nil.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/10/2001 11:33'!gameReset	self squaresDo:[:m| m removeAllMorphs; borderWidth: 0]! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:43'!movedPiece: piece from: sourceSquare to: destSquare	| sourceMorph destMorph sourcePos destPos w startTime nowTime deltaTime |	sourceMorph _ (self atSquare: sourceSquare) firstSubmorph.	destMorph _ self atSquare: destSquare.	animateMove ifTrue:[		sourcePos _ sourceMorph boundsInWorld center.		destPos _ destMorph boundsInWorld center.		(w _ self world) ifNotNil:[			w addMorphFront: sourceMorph.			sourceMorph addDropShadow.			sourceMorph shadowColor: (Color black alpha: 0.5).			deltaTime _ (sourcePos dist: destPos) * 10 asInteger.			startTime _ Time millisecondClockValue.			[nowTime _ Time millisecondClockValue.			nowTime - startTime < deltaTime] whileTrue:[				sourceMorph center: sourcePos + (destPos - sourcePos * (nowTime - startTime) // deltaTime) asIntegerPoint.				w displayWorldSafely].			sourceMorph removeDropShadow.		].	].	destMorph removeAllMorphs.	destMorph addMorphCentered: sourceMorph.	animateMove _ false.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:47'!removedPiece: piece at: square	animateMove ifFalse:[		(self atSquare: square) removeAllMorphs.	].! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 8/9/2001 03:40'!replacedPiece: oldPiece with: newPiece at: square white: isWhite	self removedPiece: oldPiece at: square.	self addedPiece: newPiece at: square white: isWhite! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:13'!undoMove: aMove white: aBool	board ifNil:[^self].	redoList addLast: aMove.	self validateGamePosition.! !!ChessMorph methodsFor: 'game callbacks' stamp: 'ar 10/18/2001 20:23'!validateGamePosition	"This method does nothing but validating what you see (on screen) is what you get (from the board)."	| square piece isWhite p |	1 to: 64 do:[:idx|		square _ self atSquare: idx.		square hasSubmorphs 			ifTrue:[piece _ square firstSubmorph valueOfProperty: #piece.					isWhite _ square firstSubmorph valueOfProperty: #isWhite]			ifFalse:[piece _ 0. isWhite _ nil].		p _ board whitePlayer pieceAt: idx.		idx = board whitePlayer castlingRookSquare ifTrue:[p _ ChessPlayer rook].		isWhite == true ifTrue:[			p = piece ifFalse:[self error:'White broken'].		] ifFalse:[p = 0 ifFalse:[self error:'White broken']].		p _ board blackPlayer pieceAt: idx.		idx = board blackPlayer castlingRookSquare ifTrue:[p _ ChessPlayer rook].		isWhite == false ifTrue:[			p = piece ifFalse:[self error:'White broken'].		] ifFalse:[p = 0 ifFalse:[self error:'White broken']].	].! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 21:02'!autoPlay	autoPlay _ autoPlay not.	autoPlay ifTrue:[self thinkAndMove].! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:18'!findBestMove	| move |	board searchAgent isThinking ifTrue:[^self].	Cursor wait showWhile:[move _ board searchAgent think].	self inform: 'I suggest: ', move printString.	^move! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:19'!movePieceFrom: sourceSquare to: destSquare	board ifNil:[^self].	board searchAgent isThinking ifTrue:[^self].	board movePieceFrom: sourceSquare to: destSquare.	board searchAgent startThinking.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 22:38'!newGame	board ifNil:[board _ ChessBoard new].	board initialize.	board userAgent: self.	board initializeNewBoard.	history _ OrderedCollection new.	redoList _ OrderedCollection new.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:13'!redoMove	"Redo the last undone move"	redoList isEmpty ifTrue:[^self].	board nextMove: redoList removeLast.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:19'!thinkAndMove	board searchAgent isThinking ifTrue:[^self].	board searchAgent startThinking.! !!ChessMorph methodsFor: 'playing' stamp: 'ar 10/18/2001 20:11'!undoMove	"Undo the last move"	board ifNil:[^self].	history isEmpty ifTrue:[^self].	board undoMove: history removeLast.! !!ChessMorph methodsFor: 'other stuff' stamp: 'ar 8/10/2001 11:34'!rotateBoard	self listDirection = #leftToRight		ifTrue:[^self listDirection: #topToBottom; wrapDirection: #leftToRight].	self listDirection = #topToBottom		ifTrue:[^self listDirection: #rightToLeft; wrapDirection: #topToBottom].	self listDirection = #rightToLeft		ifTrue:[^self listDirection: #bottomToTop; wrapDirection: #rightToLeft].	self listDirection = #bottomToTop		ifTrue:[^self listDirection: #leftToRight; wrapDirection: #bottomToTop].! !!ChessMorph methodsFor: 'other stuff' stamp: 'ar 10/18/2001 20:10'!statusString	board ifNil:[^''].	^board statusString! !!ChessMorph methodsFor: 'stepping' stamp: 'ar 10/18/2001 21:02'!step	| move |	board searchAgent isThinking ifTrue:[		move _ board searchAgent thinkStep.		move ifNotNil:[			animateMove _ true.			board movePieceFrom: move sourceSquare 					to: move destinationSquare].	] ifFalse:[		autoPlay ifTrue:[board searchAgent startThinking].	].! !!ChessMorph methodsFor: 'stepping' stamp: 'ar 8/12/2001 21:10'!stepTime	^0! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:18'!blackBishopImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 21053440 0 0 21053440 0 0 4538368 0 0 88489984 0 0 357978112 0 0 357994496 0 0 1431675904 0 1 1452647424 0 1 1452631040 0 5 1789487360 0 5 1789483264 0 5 1452628224 0 21 1452627200 0 21 1452626944 0 21 1431655424 0 21 1431655424 0 21 1431655424 0 21 1431654400 0 21 1431654400 0 5 1431654400 0 5 1431650304 0 1 1431650304 0 1 2863284224 0 1 2863284224 0 0 1431633920 0 0 445644800 0 1 1431650304 0 1 1789476864 0 1 1789476864 0 1 1431650304 0 0 20971520 0 0 89128960 0 0 357826560 0 21840 1414858069 0 349525 1410684245 1342177280 344085 1074091009 1342177280 262144 0 268435456 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:18'!blackKingImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 0 0 0 4194304 0 0 22020096 0 0 4194304 0 0 89391104 0 0 111411200 0 1398016 107216981 1426063360 22369600 107218261 1430257664 22456660 107222362 2772434944 89740885 111416741 1498415104 90527125 1162892885 1448083456 93672805 1095850325 1448083456 362108249 1431656790 2522087424 362190169 1435854230 2522087424 362190422 1452643686 2522087424 362112598 1431672169 1448345600 362112597 2505463146 2522087424 93760085 2505463145 1448083456 93678165 2526434665 1448083456 93673045 1704351141 1498415104 90527317 1700353429 1498415104 23418261 1700353429 1497366528 22631829 1499027029 1497366528 22631829 1503221333 1698693120 5657957 1503222101 1694498816 1463653 1499026773 2483027968 1414485 1499026774 1409286144 354986 2841291433 1342177280 87381 1431655765 1073741824 21845 1431655765 0 5802 2863311508 0 6485 1431655780 0 6485 1521046884 0 6485 1431655780 0 6826 2863311524 0 5461 1431655764 0 0 0 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackKnightImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 268435456 0 1 335544320 0 1 335544320 0 1 1430257664 0 0 1431568384 0 1 1431650304 0 21 1432704000 0 342 2774160704 0 1370 1767216464 0 5461 2505402708 0 21845 1431656021 0 87381 1431655829 0 349525 1431655781 1073741824 1398101 1431672149 1342177280 1398101 1431672153 1342177280 5592405 1431983446 1409286144 5592405 1343576406 1409286144 22369600 1402197 2483027968 26543360 5920085 2768240640 22287360 5593685 1694498816 22040576 23766357 1694498816 81920 89478485 1698693120 0 89478485 1698693120 0 357913941 1765801984 0 1431655765 1765801984 0 1431655765 1766850560 1 1431655765 1498415104 5 1431655765 1498415104 21 1431655765 1498415104 21 1431655765 1498415104 21 1431655765 1498415104 85 1431655765 1498415104 341 1431655765 1498415104 341 1431655765 1498415104 1365 1431655765 1498415104 1365 1431655765 1431306240 1365 1431655765 1431306240 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackPawnImage	^((ColorForm	extent: 40@40	depth: 1	fromArray: #( 0 0 15360 0 32256 0 32256 0 32256 0 32256 0 32256 0 15360 0 65280 0 262080 0 65280 0 32256 0 32256 0 65280 0 65280 0 65280 0 130944 0 262080 0 262080 0 524256 0 524256 0 524256 0 524256 0 524256 0 524256 0 524256 0 262080 0 262080 0 262080 0 130944 0 65280 0 65280 0 524256 0 4194300 0 8388606 0 16777215 0 33554431 2147483648 33554431 2147483648 33554431 2147483648 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032)  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackQueenImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 0 0 0 5242880 0 0 5242880 0 0 1048576 0 320 4194324 0 320 5242900 0 64 5242896 0 64 5242896 0 64 5242896 0 80 5242960 0 83886160 5242960 0 83886160 5242960 1310720 16777300 5243216 1310720 4194388 22282576 1048576 4194388 22282576 4194304 5242964 22282576 4194304 5505109 22283600 20971520 1310805 22283600 88080384 1376341 22283600 88080384 1392725 1096029520 356515840 1392725 1096029520 356515840 1396821 1096029520 1430257664 1397845 1431655761 1426063360 349269 1431655761 1426063360 349525 1431655765 1426063360 349525 1431655765 1426063360 349525 1431655765 1426063360 349525 1521112405 1426063360 88746 2773854890 1409286144 91477 1453938005 2483027968 27285 1436898666 2415919104 23125 1521112410 1342177280 6826 2773854890 1073741824 5461 1431655765 1073741824 21845 1431655765 1342177280 21845 1431655765 1342177280 0 0 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!blackRookImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357826560 0 349184 357826645 1073741824 349184 357826645 1073741824 349184 357826645 1073741824 349525 1431655765 1073741824 436906 2863311530 1073741824 349526 1431721301 1073741824 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1706 2863311504 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1706 2863311504 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1366 1431721296 0 1706 2863311504 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1365 1448432976 0 1706 2863311504 0 23210 2863311525 0 27306 2863311529 0 87381 1431655765 1073741824 436906 2863311530 2415919104 436906 2863311530 2415919104 349525 1431655765 1342177280 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteBishopImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 16842752 0 0 88424448 0 0 88424448 0 0 89473024 0 0 378966016 0 0 1520865280 0 1 1789240320 0 1 2842256384 0 5 2842321920 0 6 2505462784 0 22 2505479168 0 26 2842338304 0 26 2842338304 0 26 2842338304 0 26 2863309824 0 26 2863309824 0 26 2863309824 0 26 2863309824 0 26 2863305728 0 22 2863304704 0 6 2863288320 0 5 2863284224 0 1 1431650304 0 1 1431650304 0 1 1768505344 0 1 1768505344 0 1 1768505344 0 1 1431650304 0 5 2863284224 0 5 1431654400 0 0 104857600 0 0 374341632 0 0 1498677248 0 87381 1701139797 1073741824 1419946 2488969898 1409286144 349525 1343575381 1342177280 1310720 0 335544320 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteKingImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 22020096 0 0 93585408 0 0 111411200 0 0 93585408 0 0 362020864 0 1397760 447021077 1409286144 5940480 425263450 2768240640 23767376 429458858 2839543808 94721684 425268885 1448083456 110536037 426072410 2794455040 379234921 1499818410 2777939968 442149466 1431676586 2846097408 443198102 2526451305 1772355584 443116133 2842319449 1772355584 443111785 2841270937 2846097408 443193769 1785293465 2577661952 442866090 1789504149 1503920128 443110826 1785309845 2846097408 376083882 1499048598 2845048832 106603946 2573838938 2777677824 110799274 2594548330 2794455040 110799210 2594613610 2794455040 93760106 2523310506 2521825280 27699802 2774968746 2587885568 23440026 2795939242 1497366528 6908570 2795939497 1694498816 5925546 2795940521 2751463424 1463637 1453675861 2483027968 371301 2506447274 1342177280 87641 2590415189 1073741824 26261 1431655845 0 21850 2774182229 0 21930 2505484885 0 21866 2842339669 0 22165 1431655829 0 21850 2863311189 0 21845 1431655765 0 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteKnightImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 1073741824 0 16 1342177280 0 20 1342177280 0 5 1430257664 0 6 2857713664 0 6 2862956544 0 22 2863223808 0 346 2863306048 0 1445 1789569360 0 22166 1521134164 0 91813 1789569685 0 367274 2863245989 1073741824 1469098 2862983845 1342177280 1682090 2863049385 1342177280 5679786 2863048362 1409286144 22718890 2861996714 1409286144 27961706 2775210410 2499805184 95070809 1432708522 2499805184 111503701 22455978 2503999488 378889472 27957930 2773483520 374969344 94988970 2773483520 88428544 106343082 2773483520 84295680 359312042 2840592384 344064 1521134250 2840592384 1 1789569706 2840592384 1 2863311530 2840854528 5 2863311530 2857631744 22 2863311530 2857631744 26 2863311530 2857631744 90 2863311530 2857631744 106 2863311530 2857631744 362 2863311530 2857631744 1450 2863311530 2857631744 1706 2863311530 2857631744 5802 2863311530 2857631744 6826 2863311530 2857631744 23210 2863311530 2857631744 21845 1431655765 1431568384 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whitePawnImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357826560 0 0 446955520 0 0 1520762880 0 0 1789460480 0 0 1520762880 0 0 378798080 0 0 1431633920 0 1 1789476864 0 21 2863289344 0 85 1431655680 0 0 446955520 0 0 1520762880 0 0 1789460480 0 0 1789460480 0 1 1789476864 0 5 2863288320 0 6 2863304704 0 22 2863305728 0 26 2863309824 0 90 2863310080 0 106 2863311104 0 106 2863311104 0 106 2863311104 0 90 2863310080 0 26 2863309824 0 26 2863309824 0 22 2863305728 0 6 2863304704 0 5 2863288320 0 1 1789476864 0 0 1789460480 0 341 1520784704 0 1450 2505484880 0 22186 2863311509 0 92842 2863311529 1073741824 109226 2863311530 1073741824 109226 2863311530 1073741824 87381 1431655765 1073741824 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteQueenImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 0 0 0 5242880 0 0 22282240 0 0 5242880 0 64 5242896 0 336 5242964 0 336 5242964 0 64 5242896 0 64 5242896 0 80 5242960 0 80 22282320 0 83886160 27525200 1310720 352321620 27525456 1376256 88080484 27525520 1376256 20971620 27525520 5242880 5242981 27526544 5242880 5505129 27526800 22020096 6553705 27526800 93323264 6619241 1101272720 105906176 6881386 1168448144 373293056 5849194 1185487504 440401920 1724522 1453939344 1514143744 1740906 2527685265 1782579200 1741930 2527685265 2856321024 1746282 2863311509 2856321024 1747306 2863311510 2856321024 1485482 2863311530 2839543808 436906 2863311530 2835349504 436906 2505403050 2835349504 365909 1515869525 1694498816 87466 2773854885 1409286144 21850 2841029205 1342177280 21866 2505403029 1342177280 21845 1521112405 1342177280 27306 2863311530 2415919104 27306 2863311530 2415919104 92842 2863311530 2483027968 87381 1431655765 1409286144 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'accessing' stamp: 'ar 8/10/2001 09:19'!whiteRookImage	^((ColorForm	extent: 40@40	depth: 2	fromArray: #( 0 0 0 0 357892096 0 87360 447283221 1409286144 109120 447283226 2751463424 109120 447283226 2751463424 109141 1521046874 2751463424 109226 2863311530 2751463424 87381 1431655765 1409286144 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 341 1431655764 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 341 1431655764 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 426 1789553316 0 341 1431655764 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 426 2859117220 0 5461 1431655765 0 23210 2863311529 1073741824 27306 2863311530 1073741824 87381 1431655765 1342177280 371370 2863311530 2483027968 436906 2863311530 2751463424 349525 1431655765 1409286144 0 0 0)	offset: 0@0)	colorsFromArray: #(#( ) #(0.0 0.0 0.032) #(1.0 1.0 1.0) #( )  ))! !!ChessMorph class methodsFor: 'parts bin' stamp: 'ar 8/13/2001 22:33'!descriptionForPartsBin	^ self partName: 	'Chess'		categories:		#('Games')		documentation:	'A fine game of chess'! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:19'!captureEnPassant: aPiece from: startSquare to: endSquare	movingPiece _ capturedPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCaptureEnPassant.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!checkMate: aPiece	movingPiece _ aPiece.	sourceSquare _ 0.	destinationSquare _ 0.	type _ MoveResign.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!doublePush: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveDoublePush.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!init	movingPiece _ sourceSquare _ destinationSquare _ 1.	type _ MoveNormal.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!move: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveNormal.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!move: aPiece from: startSquare to: endSquare capture: capture	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	capturedPiece _ capture.	type _ MoveNormal.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!moveCastlingKingSide: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCastlingKingSide.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:19'!moveCastlingQueenSide: aPiece from: startSquare to: endSquare	movingPiece _ aPiece.	sourceSquare _ startSquare.	destinationSquare _ endSquare.	type _ MoveCastlingQueenSide.	capturedPiece _ 0.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/24/2001 23:08'!moveEncoded: encodedMove	destinationSquare _ encodedMove bitAnd: 255.	sourceSquare _ (encodedMove bitShift: -8) bitAnd: 255.	movingPiece _ (encodedMove bitShift: -16) bitAnd: 255.	capturedPiece _ (encodedMove bitShift: -24) bitAnd: 255.	type _ MoveNormal.! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!promote: move to: promotion	movingPiece _ move movingPiece.	capturedPiece _ move capturedPiece.	sourceSquare _ move sourceSquare.	destinationSquare _ move destinationSquare. 	type _ move moveType.	type _ type bitOr: (promotion bitShift: PromotionShift).! !!ChessMove methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:20'!staleMate: aPiece	movingPiece _ aPiece.	sourceSquare _ 0.	destinationSquare _ 0.	type _ MoveStaleMate.	capturedPiece _ 0.! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/24/2001 22:48'!bestMove	^nil! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!capturedPiece	^capturedPiece! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!capturedPiece: aValue	^capturedPiece _ aValue! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!destinationSquare	^destinationSquare! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!destinationSquare: aValue	^destinationSquare _ aValue! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/24/2001 22:48'!encodedMove	"Return an integer encoding enough of a move for printing"	^destinationSquare + 		(sourceSquare bitShift: 8) +		(movingPiece bitShift: 16) +		(capturedPiece bitShift: 24)! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:32'!moveType	^type! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:32'!moveType: aType	^type _ aType! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:06'!movingPiece	^movingPiece! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!movingPiece: aValue	^movingPiece _ aValue! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:25'!promotion	^type bitShift: ExtractPromotionShift! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/7/2001 22:07'!sourceSquare	^sourceSquare! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/12/2001 21:24'!sourceSquare: aValue	^sourceSquare _ aValue! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/9/2001 18:03'!value	^value! !!ChessMove methodsFor: 'accessing' stamp: 'ar 8/9/2001 18:03'!value: newValue	value _ newValue! !!ChessMove methodsFor: 'comparing' stamp: 'ar 8/7/2001 22:11'!= aMove	movingPiece = aMove movingPiece ifFalse:[^false].	capturedPiece = aMove capturedPiece ifFalse:[^false].	type = aMove type ifFalse:[^false].	sourceSquare = aMove sourceSquare ifFalse:[^false].	destinationSquare = aMove destinationSquare ifFalse:[^false].	^true! !!ChessMove methodsFor: 'comparing' stamp: 'ar 8/7/2001 22:12'!hash	^((movingPiece hash bitXor: capturedPiece hash) bitXor:		(sourceSquare hash bitXor: destinationSquare hash)) bitXor: type hash! !!ChessMove methodsFor: 'printing' stamp: 'ar 8/9/2001 18:06'!moveString	^String streamContents:[:aStream|		aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: movingPiece).		aStream nextPutAll: (String with: ($a asInteger + (sourceSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (sourceSquare -1 bitShift: -3)) asCharacter).		capturedPiece = 0 ifTrue:[			aStream nextPutAll: '-'.		] ifFalse:[			aStream nextPutAll: 'x'.			aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: capturedPiece).		].		aStream nextPutAll: (String with: ($a asInteger + (destinationSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (destinationSquare -1 bitShift: -3)) asCharacter).	].! !!ChessMove methodsFor: 'printing' stamp: 'ar 8/9/2001 15:38'!printOn: aStream	super printOn: aStream.	aStream nextPutAll:'('.	aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: movingPiece).	aStream nextPutAll: (String with: ($a asInteger + (sourceSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (sourceSquare -1 bitShift: -3)) asCharacter).	capturedPiece = 0 ifTrue:[		aStream nextPutAll: '-'.	] ifFalse:[		aStream nextPutAll: 'x'.		aStream nextPutAll: (#('' 'N' 'B' 'R' 'Q' 'K') at: capturedPiece).	].	aStream nextPutAll: (String with: ($a asInteger + (destinationSquare - 1 bitAnd: 7)) asCharacter with: ($1 asInteger + (destinationSquare -1 bitShift: -3)) asCharacter).	aStream nextPutAll:')'.! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:05'!basicMoveMask	^BasicMoveMask! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/24/2001 23:07'!decodeFrom: encodedMove	^self new moveEncoded: encodedMove! !!ChessMove class methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:50'!initialize	"ChessMove initialize"	MoveNormal _ 1.	MoveDoublePush _ 2.	MoveCaptureEnPassant _ 3.	MoveCastlingKingSide _ 4.	MoveCastlingQueenSide _ 5.	MoveResign _ 6.	MoveStaleMate _ 7.	BasicMoveMask _ 15.	PromotionShift _ 4.	ExtractPromotionShift _  0 - PromotionShift.	EvalTypeAccurate _ 0.	EvalTypeUpperBound _ 1.	EvalTypeLowerBound _ 2.	NullMove _ 0.! !!ChessMoveGenerator methodsFor: 'initialize' stamp: 'ar 8/24/2001 15:55'!initialize	EmptyPieceMap ifNil:[		EmptyPieceMap _ ByteArray new: 256.		2 to: 7 do:[:i| EmptyPieceMap at: i put: 1]].	streamList _ Array new: 100. "e.g., 100 plies"	1 to: streamList size do:[:i| streamList at: i put: (ChessMoveList on: #())].	moveList _ Array new: streamList size * 30. "avg. 30 moves per ply"	1 to: moveList size do:[:i| moveList at: i put: (ChessMove new init)].	firstMoveIndex _ lastMoveIndex _ streamListIndex _ 0.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/10/2001 22:31'!attackSquares	^attackSquares! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 21:31'!findAllPossibleMovesFor: player	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| piece actions square |	myPlayer _ player.	myPieces _ player pieces.	itsPieces _ player opponent pieces.	castlingStatus _ player castlingStatus.	enpassantSquare _ player opponent enpassantSquare.	firstMoveIndex = lastMoveIndex ifFalse:[self error:'I am confused'].	kingAttack _ nil.	myPlayer isWhitePlayer ifTrue:[		actions _ #(	moveWhitePawnAt: moveKnightAt: moveBishopAt:					moveRookAt: moveQueenAt: moveWhiteKingAt:).	] ifFalse:[		actions _ #(	moveBlackPawnAt: moveKnightAt: moveBishopAt:					moveRookAt: moveQueenAt: moveBlackKingAt:).	].	square _ 0.	[square < 64] whileTrue:[		"Note: The following is only to skip empty fields efficiently.		It could well be replaced by going through each field and test it		for zero but this is *much* faster."		square _ String findFirstInString: myPieces inSet: EmptyPieceMap startingAt: square+1.		square = 0 ifTrue:[^self moveList].		piece _ myPieces at: square.		self perform: (actions at: piece) with: square.		kingAttack ifNotNil:[^self moveList].	].	^self moveList! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:01'!findAttackSquaresFor: player	"Mark all the fields of a board that are attacked by the given player.	The pieces attacking a field are encoded as (1 << Piece) so that we can	record all types of pieces that attack the square."	| move square piece attack list |	forceCaptures _ false.	attackSquares ifNil:[attackSquares _ ByteArray new: 64].	attackSquares atAllPut: 0.	list _ self findAllPossibleMovesFor: player.	[move _ list next.	move == nil] whileFalse:[		square _ move destinationSquare.		piece _ move movingPiece.		attack _ attackSquares at: square.		attack _ attack bitOr: (1 bitShift: piece).		attackSquares at: square put: attack.	].	self recycleMoveList: list.	^attackSquares! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 15:59'!findPossibleMovesFor: player	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	forceCaptures _ false.	^self findAllPossibleMovesFor: player.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 20:58'!findPossibleMovesFor: player at: square	"Find all possible moves at the given square. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| piece action |	forceCaptures _ false.	myPlayer _ player.	myPieces _ player pieces.	itsPieces _ player opponent pieces.	castlingStatus _ player castlingStatus.	enpassantSquare _ player opponent enpassantSquare.	firstMoveIndex = lastMoveIndex ifFalse:[self error:'I am confused'].	kingAttack _ nil.	piece _ myPieces at: square.	piece = 0 ifFalse:[		action _ #(movePawnAt:					moveKnightAt:					moveBishopAt:					moveRookAt:					moveQueenAt:					moveKingAt:) at: piece.		self perform: action with: square.	].	^self moveList! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:00'!findQuiescenceMovesFor: player	"Find all the quiescence moves (that is moves capturing pieces)"	forceCaptures _ true.	^self findAllPossibleMovesFor: player.! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/10/2001 22:32'!kingAttack	^kingAttack! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:37'!moveList	| list |	kingAttack ifNotNil:[		lastMoveIndex _ firstMoveIndex.		^nil].	list _ streamList at: (streamListIndex _ streamListIndex + 1).	list on: moveList from: firstMoveIndex+1 to: lastMoveIndex.	firstMoveIndex _ lastMoveIndex.	^list! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 21:25'!profileGenerationFor: player	| list |	Smalltalk garbageCollect.	MessageTally spyOn:[		1 to: 100000 do:[:i|			list _ self findPossibleMovesFor: player.			self recycleMoveList: list].	].! !!ChessMoveGenerator methodsFor: 'public' stamp: 'ar 8/24/2001 16:31'!recycleMoveList: aChessMoveList	(streamList at: streamListIndex) == aChessMoveList ifFalse:[^self error:'I am confused'].	streamListIndex _ streamListIndex - 1.	firstMoveIndex _ lastMoveIndex _ aChessMoveList startIndex - 1.! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveBishopAt: square	| moves |	moves _ BishopMoves at: square.	1 to: moves size do:[:i|		self movePiece: Bishop along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:30'!moveBlackKingAt: square	| capture |	(KingMoves at: square) do:[:destSquare|		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: King from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].			].		].	].	forceCaptures ifTrue:[^self].	"now consider castling"	self canCastleBlackKingSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingKingSide: King from: square to: square+2.	].	self canCastleBlackQueenSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingQueenSide: King from: square to: square-2.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:32'!moveKingAt: square	myPlayer isWhitePlayer		ifTrue:[^self moveWhiteKingAt: square]		ifFalse:[^self moveBlackKingAt: square]! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 15:56'!moveKnightAt: square	| capture moves destSquare |	moves _ KnightMoves at: square.	1 to: moves size do:[:i|		destSquare _ moves at: i.		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: Knight from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ (moveList at: lastMoveIndex)].			].		].	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:16'!movePawnAt: square	"Pawns only move in one direction so check for which direction to use"	myPlayer isWhitePlayer		ifTrue:[^self moveWhitePawnAt: square]		ifFalse:[^self moveBlackPawnAt: square]! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 15:57'!movePiece: piece along: rayList at: square	| destSquare capture |	1 to: rayList size do:[:i|		destSquare _ rayList at: i.		(myPieces at: destSquare) = 0 ifFalse:[^self].		capture _ itsPieces at: destSquare.		(forceCaptures and:[capture = 0]) ifFalse:[			(moveList at: (lastMoveIndex _ lastMoveIndex + 1))				move: piece from: square to: destSquare capture: capture.			capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].		].		capture = 0 ifFalse:[^self].	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveQueenAt: square	| moves |	moves _ RookMoves at: square.	1 to: moves size do:[:i|		self movePiece: Queen along: (moves at: i) at: square.	].	moves _ BishopMoves at: square.	1 to: moves size do:[:i|		self movePiece: Queen along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/22/2001 15:19'!moveRookAt: square	| moves |	moves _ RookMoves at: square.	1 to: moves size do:[:i|		self movePiece: Rook along: (moves at: i) at: square.	].! !!ChessMoveGenerator methodsFor: 'moves-general' stamp: 'ar 8/24/2001 21:30'!moveWhiteKingAt: square	| capture |	(KingMoves at: square) do:[:destSquare|		(myPieces at: destSquare) = 0 ifTrue:[			capture _ itsPieces at: destSquare.			(forceCaptures and:[capture = 0]) ifFalse:[				(moveList at: (lastMoveIndex _ lastMoveIndex + 1))					move: King from: square to: destSquare capture: capture.				capture = King ifTrue:[kingAttack _ moveList at: lastMoveIndex].			].		].	].	forceCaptures ifTrue:[^self].	"now consider castling"	self canCastleWhiteKingSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingKingSide: King from: square to: square+2.	].	self canCastleWhiteQueenSide ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			moveCastlingQueenSide: King from: square to: square-2.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:58'!blackPawnCaptureAt: square direction: dir	| destSquare move piece |	destSquare _ square-8-dir.	piece _ itsPieces at: destSquare.	piece = 0 ifFalse:[		(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))			move: Pawn from: square to: destSquare capture: piece.		piece = King ifTrue:[kingAttack _ move].		destSquare <= 8 "a promotion"			ifTrue:[self promotePawn: move].	].	"attempt an en-passant capture"	enpassantSquare = destSquare ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			captureEnPassant: Pawn from: square to: destSquare.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 22:05'!blackPawnPushAt: square	| destSquare move |	"Try to push this pawn"	destSquare _ square-8.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))		move: Pawn from: square to: destSquare.	destSquare <= 8 "a promotion (can't be double-push so get out)"		ifTrue:[^self promotePawn: move].	"Try to double-push if possible"	square > 48 ifFalse:[^self].	destSquare _ square-16.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(moveList at: (lastMoveIndex _ lastMoveIndex + 1))		doublePush: Pawn from: square to: destSquare.! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/22/2001 15:22'!moveBlackPawnAt: square	"Pawns only move in one direction so check for which direction to use"	forceCaptures ifFalse:[self blackPawnPushAt: square].	(square bitAnd: 7) = 1		ifFalse:[self blackPawnCaptureAt: square direction: 1].	(square bitAnd: 7) = 0 		ifFalse:[self blackPawnCaptureAt: square direction: -1].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/22/2001 15:22'!moveWhitePawnAt: square	"Pawns only move in one direction so check for which direction to use"	forceCaptures ifFalse:[self whitePawnPushAt: square].	(square bitAnd: 7) = 0 		ifFalse:[self whitePawnCaptureAt: square direction: 1].	(square bitAnd: 7) = 1 		ifFalse:[self whitePawnCaptureAt: square direction: -1].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:57'!promotePawn: move	"Duplicate the given move and embed all promotion types"	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Knight.	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Bishop.	(moveList at: (lastMoveIndex _ lastMoveIndex + 1)) promote: move to: Rook.	move promote: move to: Queen.! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 15:56'!whitePawnCaptureAt: square direction: dir	| destSquare move piece |	destSquare _ square+8+dir.	piece _ itsPieces at: destSquare.	piece = 0 ifFalse:[		(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))			move: Pawn from: square to: destSquare capture: piece.		piece = King ifTrue:[kingAttack _ move].		destSquare > 56 "a promotion"			ifTrue:[self promotePawn: move].	].	"attempt an en-passant capture"	enpassantSquare = destSquare ifTrue:[		(moveList at: (lastMoveIndex _ lastMoveIndex + 1))			captureEnPassant: Pawn from: square to: destSquare.	].! !!ChessMoveGenerator methodsFor: 'moves-pawns' stamp: 'ar 8/24/2001 22:06'!whitePawnPushAt: square	"Pawns only move in one direction so check for which direction to use"	| destSquare move |	"Try to push this pawn"	destSquare _ square+8.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(move _ moveList at: (lastMoveIndex _ lastMoveIndex + 1))		move: Pawn from: square to: destSquare.	destSquare > 56 "a promotion (can't be double-push so get out)"		ifTrue:[^self promotePawn: move].	"Try to double-push if possible"	square <= 16 ifFalse:[^self].	destSquare _ square+16.	(myPieces at: destSquare) = 0 ifFalse:[^self].	(itsPieces at: destSquare) = 0 ifFalse:[^self].	(moveList at: (lastMoveIndex _ lastMoveIndex + 1))		doublePush: Pawn from: square to: destSquare.! !!ChessMoveGenerator methodsFor: 'support' stamp: 'ar 8/24/2001 21:34'!canCastleBlackKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	^(myPieces at: 62) + (myPieces at: 63) + (itsPieces at: 62) + (itsPieces at: 63) = 0! !!ChessMoveGenerator methodsFor: 'support' stamp: 'ar 8/24/2001 21:34'!canCastleBlackQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	^(myPieces at: 58) +  (myPieces at: 59) +  (myPieces at: 60) +		(itsPieces at: 58) + (itsPieces at: 59) + (itsPieces at: 60) 			= 0! !!ChessMoveGenerator methodsFor: 'support' stamp: 'ar 8/24/2001 21:35'!canCastleWhiteKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	^(myPieces at: 6) + (myPieces at: 7) + (itsPieces at: 6) + (itsPieces at: 7) = 0! !!ChessMoveGenerator methodsFor: 'support' stamp: 'ar 8/24/2001 21:35'!canCastleWhiteQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse:[^false].	"Quickly check if all the squares are zero"	^(myPieces at: 2) +  (myPieces at: 3) +  (myPieces at: 4) +		(itsPieces at: 2) + (itsPieces at: 3) + (itsPieces at: 4) 			= 0! !!ChessMoveList methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:32'!contents	^collection copyFrom: startIndex to: readLimit! !!ChessMoveList methodsFor: 'accessing' stamp: 'ar 8/24/2001 16:11'!startIndex	^startIndex! !!ChessMoveList methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:16'!sort: i to: j using: sorter	"Sort elements i through j of self to be nondescending according to sorter."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ collection at: i.	dj _ collection at: j.	(sorter sorts: di before: dj) ifFalse:["i.e., should di precede dj?"		collection swap: i with: j.		tt _ di. di _ dj. dj _ tt].	n > 2 ifTrue:["More than two elements."		ij _ (i + j) // 2.  "ij is the midpoint of i and j."		 dij _ collection at: ij.  "Sort di,dij,dj.  Make dij be their median."		 (sorter sorts: di before: dij) ifTrue:["i.e. should di precede dij?"			(sorter sorts: dij before: dj) "i.e., should dij precede dj?"				ifFalse:[collection swap: j with: ij.					 	dij _ dj].		] ifFalse:[  "i.e. di should come after dij"			collection swap: i with: ij.			 dij _ di		].		n > 3 ifTrue:["More than three elements."			"Find k>i and l<j such that dk,dij,dl are in reverse order.			Swap k and l.  Repeat this procedure until k and l pass each other."			 k _ i.  l _ j.			[				[l _ l - 1.  k <= l and: [sorter sorts: dij before: (collection at: l)]]					whileTrue.  "i.e. while dl succeeds dij"				[k _ k + 1.  k <= l and: [sorter sorts: (collection at: k) before: dij]]					whileTrue.  "i.e. while dij succeeds dk"				k <= l			] whileTrue:[collection swap: k with: l]. 			"Now l<k (either 1 or 2 less), and di through dl are all less than 			or equal to dk through dj.  Sort those two segments."			self sort: i to: l using: sorter.			self sort: k to: j using: sorter]].! !!ChessMoveList methodsFor: 'sorting' stamp: 'ar 8/24/2001 16:32'!sortUsing: historyTable	^self sort: startIndex to: readLimit using: historyTable! !!ChessMoveList methodsFor: 'private' stamp: 'ar 8/24/2001 16:10'!on: aCollection from: firstIndex to: lastIndex	startIndex _ firstIndex.	^super on: aCollection from: firstIndex to: lastIndex.! !!ChessPieceMorph methodsFor: 'drag and drop' stamp: 'ar 8/10/2001 11:35'!wantsToBeDroppedInto: aMorph	^aMorph isKindOf: ChessMorph! !!ChessPlayer methodsFor: 'initialize' stamp: 'ar 8/24/2001 18:20'!initialize	"ChessPlayer initialize"	pieces _ ByteArray new: 64.	materialValue _ 0.	positionalValue _ 0.	numPawns _ 0.	enpassantSquare _ 0.	castlingRookSquare _ 0.	castlingStatus _ 0.! !!ChessPlayer methodsFor: 'initialize' stamp: 'ar 8/10/2001 00:37'!prepareNextMove	"Clear enpassant square and reset any pending extra kings"	enpassantSquare _ 0.	castlingRookSquare = 0 ifFalse:[pieces at: castlingRookSquare put: Rook].	castlingRookSquare _ 0.! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:40'!board	^board! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:40'!board: aBoard	board _ aBoard! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 00:52'!castlingRookSquare	^castlingRookSquare! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:03'!castlingStatus	^castlingStatus! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 01:58'!enpassantSquare	^enpassantSquare! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 17:56'!materialValue	^materialValue! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/9/2001 17:56'!numPawns	^numPawns! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:35'!opponent	^opponent! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/8/2001 22:35'!opponent: aPlayer	opponent _ aPlayer! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 00:38'!pieceAt: square	"Return the piece at the given square"	^pieces at: square! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/10/2001 02:00'!pieces	^pieces! !!ChessPlayer methodsFor: 'accessing' stamp: 'ar 8/24/2001 18:17'!userAgent	^board userAgent! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/10/2001 00:44'!canCastleKingSide	(castlingStatus bitAnd: CastlingEnableKingSide) = 0 ifFalse:[^false].	self isWhitePlayer ifTrue:[		(pieces at: 6) = 0 ifFalse:[^false].		(pieces at: 7) = 0 ifFalse:[^false].		(opponent pieceAt: 6) = 0 ifFalse:[^false].		(opponent pieceAt: 7) = 0 ifFalse:[^false].	] ifFalse:[		(pieces at: 62) = 0 ifFalse:[^false].		(pieces at: 63) = 0 ifFalse:[^false].		(opponent pieceAt: 62) = 0 ifFalse:[^false].		(opponent pieceAt: 63) = 0 ifFalse:[^false].	].	^true! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/10/2001 00:45'!canCastleQueenSide	(castlingStatus bitAnd: CastlingEnableQueenSide) = 0 ifFalse:[^false].	self isWhitePlayer ifTrue:[		(pieces at: 2) = 0 ifFalse:[^false].		(pieces at: 3) = 0 ifFalse:[^false].		(pieces at: 4) = 0 ifFalse:[^false].		(opponent pieceAt: 2) = 0 ifFalse:[^false].		(opponent pieceAt: 3) = 0 ifFalse:[^false].		(opponent pieceAt: 4) = 0 ifFalse:[^false].	] ifFalse:[		(pieces at: 58) = 0 ifFalse:[^false].		(pieces at: 59) = 0 ifFalse:[^false].		(pieces at: 60) = 0 ifFalse:[^false].		(opponent pieceAt: 58) = 0 ifFalse:[^false].		(opponent pieceAt: 59) = 0 ifFalse:[^false].		(opponent pieceAt: 60) = 0 ifFalse:[^false].	].	^true! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/9/2001 19:45'!isValidMove: move	"Is the given move actually valid for the receiver?	If the receiver's king can't be taken after applying the move, it is."	| copy |	copy _ board copy.	copy nextMove: move.	^copy activePlayer findPossibleMoves notNil! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/10/2001 02:47'!isValidMoveFrom: sourceSquare to: destSquare	| move |	move _ (self findValidMovesAt: sourceSquare)			detect:[:any| any destinationSquare = destSquare] ifNone:[nil].	^move notNil! !!ChessPlayer methodsFor: 'testing' stamp: 'ar 8/9/2001 01:23'!isWhitePlayer	^board whitePlayer == self! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/10/2001 23:26'!evaluate	^self evaluateMaterial + self evaluatePosition! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/9/2001 20:37'!evaluateMaterial	"Compute the board's material balance, from the point of view of the side	player.  This is an exact clone of the eval function in CHESS 4.5"	| total diff value |	self materialValue = opponent materialValue ifTrue:[^0]. "both sides are equal"	total _ self materialValue + opponent materialValue.	diff _ self materialValue - opponent materialValue.	value _ (2400 min: diff) + 		((diff * (12000 - total) * self numPawns) // (6400 * (self numPawns + 1))).	^value! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/24/2001 16:02'!evaluatePosition	"Compute the board's positional balance, from the point of view of the side player."	^positionalValue - opponent positionalValue! !!ChessPlayer methodsFor: 'evaluation' stamp: 'ar 8/24/2001 15:57'!positionalValue	"Evaluate our current position"	^positionalValue! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 00:36'!applyCastleKingSideMove: move	self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.	self movePiece: Rook from: move sourceSquare+3 to: (castlingRookSquare _ move sourceSquare+1).	pieces at: castlingRookSquare put: King.	castlingStatus _ castlingStatus bitOr: CastlingDone.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 00:33'!applyCastleQueenSideMove: move	self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.	self movePiece: Rook from: move sourceSquare-4 to: (castlingRookSquare _ move sourceSquare-1).	pieces at: castlingRookSquare put: King.	castlingStatus _ castlingStatus bitOr: CastlingDone.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 01:58'!applyDoublePushMove: move	enpassantSquare _ (move sourceSquare + move destinationSquare) bitShift: -1.	"Above means: the field between start and destination"	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 22:26'!applyEnpassantMove: move	opponent removePiece: move capturedPiece at: move destinationSquare - 		(self isWhitePlayer ifTrue:[8] ifFalse:[-8]).	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/10/2001 02:46'!applyMove: move	"Apply the given move"	| action |	"Apply basic move"	action _ #(			applyNormalMove:			applyDoublePushMove:			applyEnpassantMove:			applyCastleKingSideMove:			applyCastleQueenSideMove:			applyResign:			applyStaleMate:		) at: (move moveType bitAnd: ChessMove basicMoveMask).	self perform: action with: move.	"Promote if necessary"	self applyPromotion: move.	"Maintain castling status"	self updateCastlingStatus: move.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 00:54'!applyNormalMove: move	| piece |	(piece _ move capturedPiece) = EmptySquare 		ifFalse:[opponent removePiece: piece at: move destinationSquare].	^self movePiece: move movingPiece from: move sourceSquare to: move destinationSquare.! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 22:20'!applyPromotion: move	| piece |	piece _ move promotion.	piece = 0 ifFalse:[self replacePiece: move movingPiece with: piece at: move destinationSquare].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/24/2001 18:18'!applyResign: move	"Give up."	self userAgent ifNotNil:[		self isWhitePlayer 			ifTrue:[self userAgent finishedGame: 0]			ifFalse:[self userAgent finishedGame: 1].	].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/24/2001 18:18'!applyStaleMate: move	"Itsa draw."	self userAgent ifNotNil:[self userAgent finishedGame: 0.5].! !!ChessPlayer methodsFor: 'moving' stamp: 'ar 8/9/2001 02:11'!updateCastlingStatus: move	"Cannot castle when king has moved"	(move movingPiece = King) 		ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableAll].	"See if a rook has moved"	(move movingPiece = Rook) ifFalse:[^self].	self isWhitePlayer ifTrue:[		(move sourceSquare = 1) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableQueenSide].		(move sourceSquare = 8) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableKingSide].	] ifFalse:[		(move sourceSquare = 57) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableQueenSide].		(move sourceSquare = 64) 			ifTrue:[^castlingStatus _ castlingStatus bitOr: CastlingDisableKingSide].	].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:22'!undoCastleKingSideMove: move	self prepareNextMove. "in other words, remove extra kings"	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	self movePiece: Rook from: move sourceSquare+1 to: move sourceSquare+3.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:22'!undoCastleQueenSideMove: move	self prepareNextMove. "in other words, remove extra kings"	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	self movePiece: Rook from: move sourceSquare-1 to: move sourceSquare-4.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:24'!undoDoublePushMove: move	enpassantSquare _ 0.	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 08:42'!undoEnpassantMove: move	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	opponent addPiece: move capturedPiece at: move destinationSquare - 		(self isWhitePlayer ifTrue:[8] ifFalse:[-8]).! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 03:18'!undoMove: move	"Undo the given move"	| action |	self undoPromotion: move.	"Apply basic move"	action _ #(			undoNormalMove:			undoDoublePushMove:			undoEnpassantMove:			undoCastleKingSideMove:			undoCastleQueenSideMove:			undoResign:			undoStaleMate:		) at: (move moveType bitAnd: ChessMove basicMoveMask).	self perform: action with: move.! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/10/2001 08:41'!undoNormalMove: move	| piece |	self movePiece: move movingPiece from: move destinationSquare to: move sourceSquare.	(piece _ move capturedPiece) = EmptySquare 		ifFalse:[opponent addPiece: piece at: move destinationSquare].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:20'!undoPromotion: move	| piece |	piece _ move promotion.	piece = 0 ifFalse:[self replacePiece: piece with: move movingPiece at: move destinationSquare].! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:27'!undoResign: move! !!ChessPlayer methodsFor: 'undo' stamp: 'ar 8/9/2001 22:27'!undoStaleMate: move! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:04'!findPossibleMoves	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findPossibleMovesFor: self.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:06'!findPossibleMovesAt: square	"Find all possible moves at the given square. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findPossibleMovesFor: self at: square.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/24/2001 16:06'!findQuiescenceMoves	"Find all possible moves. This method does not check if the move is legal, e.g., if the king of the player is under attack after the move. If the opponent is check mate (e.g., the king could be taken in the next move) the method returns nil. If the game is stale mate (e.g., the receiver has no move left) this method returns an empty array."	| moveList moves |	moveList _ board generator findQuiescenceMovesFor: self.	moveList ifNil:[^nil].	moves _ moveList contents collect:[:move| move copy].	board generator recycleMoveList: moveList.	^moves! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/10/2001 03:09'!findValidMoves	"Find all the valid moves"	| moveList |	moveList _ self findPossibleMoves ifNil:[^nil].	^moveList select:[:move| self isValidMove: move].! !!ChessPlayer methodsFor: 'moves-general' stamp: 'ar 8/10/2001 03:09'!findValidMovesAt: square	"Find all the valid moves"	| moveList |	moveList _ (self findPossibleMovesAt: square) ifNil:[^nil].	^moveList select:[:move| self isValidMove: move].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/8/2001 22:25'!addBlackPieces	self initialize.	49 to: 56 do:[:i| self addPiece: Pawn at: i].	self addPiece: Rook at: 57.	self addPiece: Knight at: 58.	self addPiece: Bishop at: 59.	self addPiece: Queen at: 60.	self addPiece: King at: 61.	self addPiece: Bishop at: 62.	self addPiece: Knight at: 63.	self addPiece: Rook at: 64.! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!addPiece: piece at: square	pieces at: square put: piece.	materialValue _ materialValue + (PieceValues at: piece).	positionalValue _ positionalValue + ((PieceCenterScores at: piece) at: square).	piece = Pawn ifTrue:[numPawns _ numPawns + 1].	board updateHash: piece at: square from: self.	self userAgent ifNotNil:[self userAgent addedPiece: piece at: square white: self isWhitePlayer].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/8/2001 22:24'!addWhitePieces	self addPiece: Rook at: 1.	self addPiece: Knight at: 2.	self addPiece: Bishop at: 3.	self addPiece: Queen at: 4.	self addPiece: King at: 5.	self addPiece: Bishop at: 6.	self addPiece: Knight at: 7.	self addPiece: Rook at: 8.	9 to: 16 do:[:i| self addPiece: Pawn at: i].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!movePiece: piece from: sourceSquare to: destSquare	| score |	score _ PieceCenterScores at: piece.	positionalValue _ positionalValue - (score at: sourceSquare).	positionalValue _ positionalValue + (score at: destSquare).	pieces at: sourceSquare put: 0.	pieces at: destSquare put: piece.	board updateHash: piece at: sourceSquare from: self.	board updateHash: piece at: destSquare from: self.	self userAgent ifNotNil:[self userAgent movedPiece: piece from: sourceSquare to: destSquare].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!removePiece: piece at: square	pieces at: square put: 0.	materialValue _ materialValue - (PieceValues at: piece).	positionalValue _ positionalValue - ((PieceCenterScores at: piece) at: square).	piece = Pawn ifTrue:[numPawns _ numPawns - 1].	board updateHash: piece at: square from: self.	self userAgent ifNotNil:[self userAgent removedPiece: piece at: square].! !!ChessPlayer methodsFor: 'adding/removing' stamp: 'ar 8/24/2001 18:18'!replacePiece: oldPiece with: newPiece at: square	pieces at: square put: newPiece.	materialValue _ materialValue - (PieceValues at: oldPiece) + (PieceValues at: newPiece).	positionalValue _ positionalValue - ((PieceCenterScores at: oldPiece) at: square).	positionalValue _ positionalValue + ((PieceCenterScores at: newPiece) at: square).	oldPiece = Pawn ifTrue:[numPawns _ numPawns - 1].	newPiece = Pawn ifTrue:[numPawns _ numPawns + 1].	board updateHash: oldPiece at: square from: self.	board updateHash: newPiece at: square from: self.	self userAgent ifNotNil:[self userAgent replacedPiece: oldPiece with: newPiece at: square white: self isWhitePlayer].! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/9/2001 04:10'!copy	^self shallowCopy postCopy! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/24/2001 18:02'!copyPlayer: aPlayer	"Copy all the volatile state from aPlayer"	castlingRookSquare _ aPlayer castlingRookSquare.	enpassantSquare _ aPlayer enpassantSquare.	castlingStatus _ aPlayer castlingStatus.	materialValue _ aPlayer materialValue.	numPawns _ aPlayer numPawns.	positionalValue _ aPlayer positionalValue.	pieces replaceFrom: 1 to: pieces size with: aPlayer pieces startingAt: 1.! !!ChessPlayer methodsFor: 'copying' stamp: 'ar 8/10/2001 05:16'!postCopy	pieces _ pieces clone.! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 23:28'!initialize	"ChessPlayer initialize"	Smalltalk declare: #ChessConstants from: Undeclared.	ChessConstants == nil ifTrue:[ChessConstants _ Dictionary new].	self initializeConstants.	self initializeCastlingConstants.	self initializePieceValues.	self initializeMoves.	self initializeCenterScores.! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 01:47'!initializeBishopMoves	"ChessPlayer initialize"	| index moveList1 moveList2 moveList3 moveList4 px py |	ChessConstants declare: #BishopMoves from: Undeclared.	BishopMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList1 _ moveList2 _ moveList3 _ moveList4 _ #().			1 to: 7 do:[:k|				px _ i + k. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList1 _ moveList1 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList2 _ moveList2 copyWith: (py * 8) + px + 1].				px _ i + k. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList3 _ moveList3 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList4 _ moveList4 copyWith: (py * 8) + px + 1].			].			BishopMoves at: index put: {moveList1. moveList2. moveList3. moveList4}.		].	].! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/24/2001 21:03'!initializeCastlingConstants	"ChessPlayer initialize"	#(CastlingDone CastlingDisableKingSide CastlingDisableQueenSide CastlingDisableAll CastlingEnableKingSide CastlingEnableQueenSide) do:[:sym|		ChessConstants declare: sym from: Undeclared.	].	CastlingDone _ 1.	CastlingDisableKingSide _ 2.	CastlingDisableQueenSide _ 4.	CastlingDisableAll _ CastlingDisableQueenSide bitOr: CastlingDisableKingSide.	CastlingEnableKingSide _ CastlingDone bitOr: CastlingDisableKingSide.	CastlingEnableQueenSide _ CastlingDone bitOr: CastlingDisableQueenSide.! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/11/2001 18:29'!initializeCenterScores	"ChessPlayer initialize"	ChessConstants declare: #PieceCenterScores from: Undeclared.	PieceCenterScores _ Array new: 6.	1 to: 6 do:[:i| PieceCenterScores at: i put: (ByteArray new: 64)].	PieceCenterScores at: Knight put:		#(			-4	0	0	0	0	0	0	-4			-4	0	2	2	2	2	0	-4			-4	2	3	2	2	3	2	-4			-4	1	2	5	5	2	2	-4			-4	1	2	5	5	2	2	-4			-4	2	3	2	2	3	2	-4			-4	0	2	2	2	2	0	-4			-4	0	0	0	0	0	0	-4		).	PieceCenterScores at: Bishop put:		#(			-2	-2	-2	-2	-2	-2	-2	-2			-2	0	0	0	0	0	0	-2			-2	0	1	1	1	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	1	1	1	0	-2			-2	0	0	0	0	0	0	-2			-2	-2	-2	-2	-2	-2	-2	-2		).	PieceCenterScores at: Queen put:		#(			-3	0	0	0	0	0	0	-3			-2	0	0	0	0	0	0	-2			-2	0	1	1	1	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	2	2	1	0	-2			-2	0	1	1	1	1	0	-2			-2	0	0	0	0	0	0	-2			-3	0	0	0	0	0	0	-3		).! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 01:48'!initializeConstants	"ChessPlayer initialize"	#(		(EmptySquare 0)		(Pawn 1)		(Knight 2).		(Bishop 3)		(Rook 4)		(Queen 5)		(King 6)	) do:[:spec|		ChessConstants declare: spec first from: Undeclared.		ChessConstants at: spec first put: spec last.	].! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 01:49'!initializeKingMoves	"ChessPlayer initialize"	| index px py moveList |	ChessConstants declare: #KingMoves from: Undeclared.	KingMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList _ #().			#( (-1 -1) (0 -1) (1 -1) (-1 0) (1 0) (-1 1) (0 1) (1 1)) do:[:spec|				px _ i + spec first.				py _ j + spec last.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList _ moveList copyWith: (py * 8) + px + 1]].			KingMoves at: index put: moveList		].	].! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 01:49'!initializeKnightMoves	"ChessPlayer initialize"	| index px py moveList |	ChessConstants declare: #KnightMoves from: Undeclared.	KnightMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList _ #().			#( (-2 -1) (-1 -2) (1 -2) (2 -1) (-2 1) (-1 2) (1 2) (2 1)) do:[:spec|				px _ i + spec first.				py _ j + spec last.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList _ moveList copyWith: (py * 8) + px + 1]].			KnightMoves at: index put: moveList		].	].! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/8/2001 18:59'!initializeMoves	"ChessPlayer initialize"	self initializeKnightMoves.	self initializeRookMoves.	self initializeBishopMoves.	self initializeKingMoves.! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 01:51'!initializePieceValues	ChessConstants declare: #PieceValues from: Undeclared.	PieceValues _ Array new: 6.	PieceValues at: Pawn put: 100.	PieceValues at: Knight put: 300.	PieceValues at: Bishop put: 350.	PieceValues at: Rook put: 500.	PieceValues at: Queen put: 900.	PieceValues at: King put: 2000.! !!ChessPlayer class methodsFor: 'class initialization' stamp: 'ar 8/10/2001 01:49'!initializeRookMoves	"ChessPlayer initialize"	| index moveList1 moveList2 moveList3 moveList4 px py |	ChessConstants declare: #RookMoves from: Undeclared.	RookMoves _ Array new: 64 withAll: #().	0 to: 7 do:[:j|		0 to: 7 do:[:i|			index _ (j * 8) + i + 1.			moveList1 _ moveList2 _ moveList3 _ moveList4 _ #().			1 to: 7 do:[:k|				px _ i + k. py _ j.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList1 _ moveList1 copyWith: (py * 8) + px + 1].				px _ i. py _ j + k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList2 _ moveList2 copyWith: (py * 8) + px + 1].				px _ i - k. py _ j.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList3 _ moveList3 copyWith: (py * 8) + px + 1].				px _ i. py _ j - k.				((px between: 0 and: 7) and:[py between: 0 and: 7]) ifTrue:[					moveList4 _ moveList4 copyWith: (py * 8) + px + 1].			].			RookMoves at: index put: {moveList1. moveList2. moveList3. moveList4}.		].	].! !!ChessPlayer class methodsFor: 'accessing' stamp: 'ar 8/9/2001 19:53'!king	^King! !!ChessPlayer class methodsFor: 'accessing' stamp: 'ar 8/10/2001 01:00'!rook	^Rook! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 8/12/2001 21:15'!activePlayer: aPlayer	player _ aPlayer.	board _ player board.	generator _ board generator.	self reset.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/20/2001 14:28'!initialize	historyTable _ ChessHistoryTable new.	"NOTE: transposition table is initialized only when we make the first move. It costs a little to do all the entries and the garbage collections so we do it only when we *really* need it."	transTable _ nil.	random _ Random new.	nodesVisited _ ttHits _ alphaBetaCuts _ stamp _ 0.	variations _ Array new: 11.	1 to: variations size do:[:i| 		variations at: i put: (Array new: variations size).		(variations at: i) atAllPut: 0].	bestVariation _ Array new: variations size.	bestVariation atAllPut: 0.	activeVariation _ Array new: variations size.	activeVariation atAllPut: 0.	self reset.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:36'!initializeTranspositionTable	"Initialize the transposition table. Note: For now we only use 64k entries since they're somewhat space intensive. If we should get a serious speedup at some point we may want to increase the transposition table - 256k seems like a good idea; but right now 256k entries cost us roughly 10MB of space. So we use only 64k entries (2.5MB of space).	If you have doubts about the size of the transition table (e.g., if you think it's too small or too big) then modify the value below and have a look at ChessTranspositionTable>>clear which can print out some valuable statistics.	"	transTable _ ChessTranspositionTable new: 16. "1 << 16 entries"! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 22:35'!reset	transTable ifNotNil:[transTable clear].	historyTable clear.! !!ChessPlayerAI methodsFor: 'initialize' stamp: 'ar 10/18/2001 20:52'!reset: aBoard	self reset.	boardList ifNil:[		boardList _ Array new: 100.		1 to: boardList size do:[:i| boardList at: i put: (aBoard copy userAgent: nil)].		boardListIndex _ 0].	board _ aBoard.! !!ChessPlayerAI methodsFor: 'accessing' stamp: 'ar 10/20/2001 14:30'!statusString	| av count |	^String streamContents:[:s|		(myMove == #none or:[myMove == nil]) ifFalse:[			s print: myMove value * 0.01; space.		].		av _ bestVariation.		count _ av at: 1.		count > 0 ifFalse:[			av _ activeVariation.			count _ av at: 1].		count > 0 ifFalse:[			s nextPutAll:'***'.			av _ variations at: 1.			count _ av at: 1.			count > 3 ifTrue:[count _ 3]].		2 to: count + 1 do:[:index|			s nextPutAll: (ChessMove decodeFrom: (av at: index)) moveString.			s space].		s nextPut:$[.		s print: nodesVisited."		s nextPut:$|.		s print: ttHits.		s nextPut: $|.		s print: alphaBetaCuts."		s nextPut:$].	].! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 14:29'!copyVariation: move	| av mv count |	count _ 0.	av _ variations at: ply+1.	ply < 9 ifTrue:[		mv _ variations at: ply+2.		count _ mv at: 1.		av replaceFrom: 3 to: count+2 with: mv startingAt: 2].	av at: 1 put: count+1.	av at: 2 put: move encodedMove.! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 14:32'!mtdfSearch: theBoard score: estimate depth: depth	"An implementation of the MTD(f) algorithm. See:		http://www.cs.vu.nl/~aske/mtdf.html	"	| beta move value low high goodMove |	value _ estimate.	low _ AlphaBetaMinVal.	high _ AlphaBetaMaxVal.	[low >= high] whileFalse:[		beta _ value = low ifTrue:[value + 1] ifFalse:[beta _ value].		move _ self searchMove: theBoard depth: depth alpha: beta-1 beta: beta.		stopThinking ifTrue:[^move].		move ifNil:[^move].		value _ move value.		value < beta 			ifTrue:[high _ value] 			ifFalse:[				"NOTE: It is important that we do *NOT* return a move from a search which didn't reach the beta goal (e.g., value < beta). This is because all it means is that we didn't reach beta and the move returned is not the move 'closest' to beta but just one that triggered cut-off. In other words, if we'd take a move which value is less than beta it could mean that this move is a *LOT* worse than beta."				low _ value.				goodMove _ move.				activeVariation 					replaceFrom: 1 					to: activeVariation size 					with: (variations at: 1) 					startingAt: 1.			].	].	^goodMove! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 17:12'!negaScout: theBoard depth: depth alpha: initialAlpha beta: initialBeta	"Modified version to return the move rather than the score"	| move score alpha bestScore moveList newBoard beta goodMove a b notFirst |	self assert:[initialAlpha < initialBeta].	ply < 10 ifTrue:[(variations at: ply+1) at: 1 put: 0].	ply _ 0.	alpha _ initialAlpha.	beta _ initialBeta.	bestScore _ AlphaBetaMinVal.	"Generate new moves"	moveList _ generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil:[^nil].	moveList size = 0 ifTrue:[		generator recycleMoveList: moveList.		^nil].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	a _ alpha.	b _ beta.	notFirst _ false.	[(move _ moveList next) == nil] whileFalse:[		newBoard _ (boardList at: ply+1) copyBoard: theBoard.		newBoard nextMove: move.		"Search recursively"		"Search recursively"		ply _ ply + 1.		score _ 0 - (self ngSearch: newBoard depth: depth-1 alpha: 0-b beta: 0-a).		(notFirst and:[score > a and:[score < beta and:[depth > 1]]]) ifTrue:[			score _ 0 - (self ngSearch: newBoard depth: depth-1 alpha: 0-beta beta: 0-score).		].		notFirst _ true.		ply _ ply - 1.		stopThinking ifTrue:[			generator recycleMoveList: moveList.			^move].		score = AlphaBetaIllegal ifFalse:[			score > bestScore ifTrue:[				ply < 10 ifTrue:[self copyVariation: move].				goodMove _ move copy.				goodMove value: score.				activeVariation replaceFrom: 1 to: activeVariation size with: (variations at: 1) startingAt: 1.				bestScore _ score].			"See if we can cut off the search"			score > a ifTrue:[				a _ score.				a >= beta ifTrue:[					transTable storeBoard: theBoard						value: score type: (ValueBoundary bitOr: (ply bitAnd: 1))						depth: depth stamp: stamp.					historyTable addMove: move.					alphaBetaCuts _ alphaBetaCuts + 1.					generator recycleMoveList: moveList.					^goodMove]].			b _ a + 1.		].	].	transTable storeBoard: theBoard		value: bestScore type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth stamp: stamp.	generator recycleMoveList: moveList.	^goodMove! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 17:13'!ngSearch: theBoard depth: depth alpha: initialAlpha beta: initialBeta	"A basic alpha-beta algorithm; based on negaMax rather than from the text books"	| move score alpha entry bestScore moveList newBoard beta a b notFirst |	self assert:[initialAlpha < initialBeta].	ply < 10 ifTrue:[(variations at: ply+1) at: 1 put: 0].	depth = 0 ifTrue:[^self quiesce: theBoard alpha: initialAlpha beta: initialBeta].	nodesVisited _ nodesVisited + 1.	"See if there's already something in the transposition table. If so, skip the entire search."	entry _ transTable lookupBoard: theBoard.	alpha _ initialAlpha.	beta _ initialBeta.	(entry == nil or:[entry depth < depth]) ifFalse:[		ttHits _ ttHits + 1.		(entry valueType bitAnd: 1) = (ply bitAnd: 1) 			ifTrue:[beta _ entry value max: initialBeta]			ifFalse:[alpha _ (0 - entry value) max: initialAlpha].		beta > initialBeta ifTrue:[^beta].		alpha >= initialBeta ifTrue:[^alpha].	].	bestScore _ AlphaBetaMinVal.	"Generate new moves"	moveList _ generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil:[^0-AlphaBetaIllegal].	moveList size = 0 ifTrue:[		generator recycleMoveList: moveList.		^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	a _ alpha.	b _ beta.	notFirst _ false.	[(move _ moveList next) == nil] whileFalse:[		newBoard _ (boardList at: ply+1) copyBoard: theBoard.		newBoard nextMove: move.		"Search recursively"		ply _ ply + 1.		score _ 0 - (self ngSearch: newBoard depth: depth-1 alpha: 0-b beta: 0-a).		(notFirst and:[score > a and:[score < beta and:[depth > 1]]]) ifTrue:[			score _ 0 - (self ngSearch: newBoard depth: depth-1 alpha: 0-beta beta: 0-score).		].		notFirst _ true.		ply _ ply - 1.		stopThinking ifTrue:[			generator recycleMoveList: moveList.			^score].		score = AlphaBetaIllegal ifFalse:[			score > bestScore ifTrue:[				ply < 10 ifTrue:[self copyVariation: move].				bestScore _ score].			score > a ifTrue:[				a _ score.				a >= beta ifTrue:[					transTable storeBoard: theBoard						value: score type: (ValueBoundary bitOr: (ply bitAnd: 1))						depth: depth stamp: stamp.					historyTable addMove: move.					alphaBetaCuts _ alphaBetaCuts + 1.					generator recycleMoveList: moveList.					^score]].			b _ a + 1.		].	].	transTable storeBoard: theBoard		value: bestScore type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 14:44'!quiesce: theBoard alpha: initialAlpha beta: initialBeta	"A variant of alpha-beta considering only captures and null moves to obtain a quiet position, e.g. one that is unlikely to change heavily in the very near future."	| move score alpha entry bestScore moveList newBoard beta |	self assert:[initialAlpha < initialBeta].	ply < 10 ifTrue:[(variations at: ply+1) at: 1 put: 0].	nodesVisited _ nodesVisited + 1.	"See if there's already something in the transposition table."	entry _ transTable lookupBoard: theBoard.	alpha _ initialAlpha.	beta _ initialBeta.	(entry == nil) ifFalse:[		ttHits _ ttHits + 1.		(entry valueType bitAnd: 1) = (ply bitAnd: 1) 			ifTrue:[beta _ entry value max: initialBeta]			ifFalse:[alpha _ (0 - entry value) max: initialAlpha].		beta > initialBeta ifTrue:[^beta].		alpha >= initialBeta ifTrue:[^alpha].	].	ply < 2 ifTrue:[		"Always generate moves if ply < 2 so that we don't miss a move that		would bring the king under attack (e.g., make an invalid move)."		moveList _ generator findQuiescenceMovesFor: theBoard activePlayer.		moveList ifNil:[^0-AlphaBetaIllegal]].	"Evaluate the current position, assuming that we have a non-capturing move."	bestScore _ theBoard activePlayer evaluate.	"TODO: What follows is clearly not the Right Thing to do. The score we just evaluated doesn't take into account that we may be under attack at this point. I've seen it happening various times that the static evaluation triggered a cut-off which was plain wrong in the position at hand.	There seem to be three ways to deal with the problem. #1 is just deepen the search. If we go one ply deeper we will most likely find the problem (although that's not entirely certain). #2 is to improve the evaluator function and make it so that the current evaluator is only an estimate saying if it's 'likely' that a non-capturing move will do. The more sophisticated evaluator should then take into account which pieces are under attack. Unfortunately that could make the AI play very passive, e.g., avoiding situations where pieces are under attack even if these attacks are outweighed by other factors. #3 would be to insert a null move here to see *if* we are under attack or not (I've played with this) but for some reason the resulting search seemed to explode rapidly. I'm uncertain if that's due to the transposition table being too small (I don't *really* think so but it may be) or if I've just got something else wrong."	bestScore > alpha ifTrue:[		alpha _ bestScore.		bestScore >= beta ifTrue:[			moveList ifNotNil:[generator recycleMoveList: moveList].			^bestScore]].	"Generate new moves"	moveList ifNil:[		moveList _ generator findQuiescenceMovesFor: theBoard activePlayer.		moveList ifNil:[^0-AlphaBetaIllegal]].	moveList size = 0 ifTrue:[		generator recycleMoveList: moveList.		^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move _ moveList next) == nil] whileFalse:[		newBoard _ (boardList at: ply+1) copyBoard: theBoard.		newBoard nextMove: move.		"Search recursively"		ply _ ply + 1.		score _ 0 - (self quiesce: newBoard alpha: 0-beta beta: 0-alpha).		stopThinking ifTrue:[			generator recycleMoveList: moveList.			^score].		ply _ ply - 1.		score = AlphaBetaIllegal ifFalse:[			score > bestScore ifTrue:[				ply < 10 ifTrue:[self copyVariation: move].				bestScore _ score].			"See if we can cut off the search"			score > alpha ifTrue:[				alpha _ score.				score >= beta ifTrue:[					transTable storeBoard: theBoard						value: score type: (ValueBoundary bitOr: (ply bitAnd: 1))						depth: 0 stamp: stamp.					historyTable addMove: move.					alphaBetaCuts _ alphaBetaCuts + 1.					generator recycleMoveList: moveList.					^bestScore				].			].		].	].	transTable storeBoard: theBoard		value: bestScore type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: 0 stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 14:29'!search: theBoard depth: depth alpha: initialAlpha beta: initialBeta	"A basic alpha-beta algorithm; based on negaMax rather than from the text books"	| move score alpha entry bestScore moveList newBoard beta |	self assert:[initialAlpha < initialBeta].	ply < 10 ifTrue:[(variations at: ply+1) at: 1 put: 0].	depth = 0 ifTrue:[^self quiesce: theBoard alpha: initialAlpha beta: initialBeta].	nodesVisited _ nodesVisited + 1.	"See if there's already something in the transposition table. If so, skip the entire search."	entry _ transTable lookupBoard: theBoard.	alpha _ initialAlpha.	beta _ initialBeta.	(entry == nil or:[entry depth < depth]) ifFalse:[		ttHits _ ttHits + 1.		(entry valueType bitAnd: 1) = (ply bitAnd: 1) 			ifTrue:[beta _ entry value max: initialBeta]			ifFalse:[alpha _ (0 - entry value) max: initialAlpha].		beta > initialBeta ifTrue:[^beta].		alpha >= initialBeta ifTrue:[^alpha].	].	bestScore _ AlphaBetaMinVal.	"Generate new moves"	moveList _ generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil:[^0-AlphaBetaIllegal].	moveList size = 0 ifTrue:[		generator recycleMoveList: moveList.		^bestScore].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move _ moveList next) == nil] whileFalse:[		newBoard _ (boardList at: ply+1) copyBoard: theBoard.		newBoard nextMove: move.		"Search recursively"		ply _ ply + 1.		score _ 0 - (self search: newBoard depth: depth-1 alpha: 0-beta beta: 0-alpha).		stopThinking ifTrue:[			generator recycleMoveList: moveList.			^score].		ply _ ply - 1.		score = AlphaBetaIllegal ifFalse:[			score > bestScore ifTrue:[				ply < 10 ifTrue:[self copyVariation: move].				bestScore _ score].			"See if we can cut off the search"			score > alpha ifTrue:[				alpha _ score.				score >= beta ifTrue:[					transTable storeBoard: theBoard						value: score type: (ValueBoundary bitOr: (ply bitAnd: 1))						depth: depth stamp: stamp.					historyTable addMove: move.					alphaBetaCuts _ alphaBetaCuts + 1.					generator recycleMoveList: moveList.					^bestScore				].			].		].	].	transTable storeBoard: theBoard		value: bestScore type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth stamp: stamp.	generator recycleMoveList: moveList.	^bestScore! !!ChessPlayerAI methodsFor: 'searching' stamp: 'ar 10/20/2001 14:29'!searchMove: theBoard depth: depth alpha: initialAlpha beta: initialBeta	"Modified version to return the move rather than the score"	| move score alpha bestScore moveList newBoard beta goodMove |	self assert:[initialAlpha < initialBeta].	ply < 10 ifTrue:[(variations at: ply+1) at: 1 put: 0].	ply _ 0.	alpha _ initialAlpha.	beta _ initialBeta.	bestScore _ AlphaBetaMinVal.	"Generate new moves"	moveList _ generator findPossibleMovesFor: theBoard activePlayer.	moveList ifNil:[^nil].	moveList size = 0 ifTrue:[		generator recycleMoveList: moveList.		^nil].	"Sort move list according to history heuristics"	moveList sortUsing: historyTable.	"And search"	[(move _ moveList next) == nil] whileFalse:[		newBoard _ (boardList at: ply+1) copyBoard: theBoard.		newBoard nextMove: move.		"Search recursively"		ply _ ply + 1.		score _ 0 - (self search: newBoard depth: depth-1 alpha: 0-beta beta: 0-alpha).		stopThinking ifTrue:[			generator recycleMoveList: moveList.			^move].		ply _ ply - 1.		score = AlphaBetaIllegal ifFalse:[			score > bestScore ifTrue:[				ply < 10 ifTrue:[self copyVariation: move].				goodMove _ move copy.				goodMove value: score.				bestScore _ score].			"See if we can cut off the search"			score > alpha ifTrue:[				alpha _ score.				score >= beta ifTrue:[					transTable storeBoard: theBoard						value: score type: (ValueBoundary bitOr: (ply bitAnd: 1))						depth: depth stamp: stamp.					historyTable addMove: move.					alphaBetaCuts _ alphaBetaCuts + 1.					generator recycleMoveList: moveList.					^goodMove				].			].		].	].	transTable storeBoard: theBoard		value: bestScore type: (ValueAccurate bitOr: (ply bitAnd: 1))		depth: depth stamp: stamp.	generator recycleMoveList: moveList.	^goodMove! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:14'!isThinking	^myProcess notNil! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:15'!startThinking	self isThinking ifTrue:[^self].	self activePlayer: board activePlayer.	self thinkStep.! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/18/2001 20:15'!think	| move |	self isThinking ifTrue:[^nil].	self startThinking.	[(move _ self thinkStep) == nil] whileTrue.	^move! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/20/2001 17:08'!thinkProcess	| score theMove depth |	stopThinking _ false.	score _ board activePlayer evaluate.	depth _ 1.	stamp _ stamp + 1.	ply _ 0.	historyTable clear.	transTable clear.	startTime _ Time millisecondClockValue.	nodesVisited _ ttHits _ alphaBetaCuts _ 0.	bestVariation at: 1 put: 0.	activeVariation at: 1 put: 0.	[nodesVisited < 50000] whileTrue:[false ifTrue:[		theMove _ self mtdfSearch: board score: score depth: depth.] ifFalse:[		theMove _ self negaScout: board depth: depth alpha: AlphaBetaMinVal beta: AlphaBetaMaxVal.].		theMove ifNil:[^myProcess _ nil].		stopThinking ifTrue:[^myProcess _ nil].		myMove _ theMove.		bestVariation replaceFrom: 1 to: bestVariation size with: activeVariation startingAt: 1.		score _ theMove value.		depth _ depth + 1.	].	myProcess _ nil.! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/21/2001 00:49'!thinkStep	transTable ifNil:[self initializeTranspositionTable].	myProcess == nil ifTrue:[		myMove _ #none.		false ifTrue:[			self thinkProcess.			^myMove].		myProcess _ [self thinkProcess] forkAt: Processor userBackgroundPriority.		myProcess suspend.		^nil	].	myProcess resume.	(Delay forMilliseconds: 50) wait.	myProcess ifNil:[^myMove == #none ifTrue:[nil] ifFalse:[myMove]].	myProcess suspend.	"Do we have a valid move?"	myMove == #none ifTrue:[^nil]. "no"	"Did we time out?"	Time millisecondClockValue - startTime > self timeToThink ifTrue:[		"Yes. Abort and return current move."		stopThinking _ true.		myProcess resume.		[myProcess == nil] whileFalse:[			(Delay forMilliseconds: 10) wait.		].		^myMove == #none ifTrue:[nil] ifFalse:[myMove]].	"Keep thinking"	^nil! !!ChessPlayerAI methodsFor: 'thinking' stamp: 'ar 10/21/2001 01:12'!timeToThink	"Return the number of milliseconds we're allowed to think"	^5000! !!ChessPlayerAI class methodsFor: 'class initialization' stamp: 'ar 8/12/2001 14:39'!initialize	"ChessPlayerAI initialize"	AlphaBetaGiveUp _ -29990.	AlphaBetaIllegal _ -31000.	AlphaBetaMaxVal _ 30000.	AlphaBetaMinVal _ -30000.	ValueAccurate _ 2.	ValueBoundary _ 4.	ValueLowerBound _ 4.	ValueUpperBound _ 5.	ValueThreshold _ 200.! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:36'!clear	value _ valueType _ timeStamp _ depth _ -1.! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:05'!depth	^depth! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 10/19/2001 00:04'!depth: aNumber	depth _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!hashLock	^hashLock! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!hashLock: aNumber	hashLock _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!timeStamp	^timeStamp! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/8/2001 09:14'!timeStamp: aNumber	timeStamp _ aNumber! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!value	^value! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!value: newValue	value _ newValue! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!valueType	^valueType! !!ChessTTEntry methodsFor: 'accessing' stamp: 'ar 8/10/2001 19:37'!valueType: newType	valueType _ newType! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:38'!clear	| entry |	"Set the following to true for printing information about the fill rate and number of collisions. The transposition table should have *plenty* of free space (it should rarely exceed 30% fill rate) and *very* few collisions (those require us to evaluate positions repeatedly that we've evaluated before -- bad idea!!)"	false ifTrue:[		used position > 0 ifTrue:[			'entries used:	', 				used position printString,				' (', (used position * 100 // array size) printString,'%)	'			 displayAt: 0@0.		].		collisions > 0 ifTrue:[			'collisions:		', 				collisions printString,				' (', (collisions * 100 // array size) printString,'%)	'			displayAt: 0@15.		].	].	used position: 0.	[(entry _ used next) == nil] whileFalse:[entry clear].	used resetToStart.	collisions _ 0.! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:28'!initialize: nBits	"Initialize the receiver using 1<<nBits entries. See also ChessPlayerAI>>initializeTranspositionTable."	| entry |	array _ Array new: 1 << nBits.	used _ ReadWriteStream on: (Array new: 50000). "<- will grow if not sufficient!!"	entry _ ChessTTEntry new clear.	1 to: array size do:[:i| array at: i put: entry clone].	collisions _ 0.	Smalltalk garbageCollect. "We *really* want them old here"! !!ChessTranspositionTable methodsFor: 'initialize' stamp: 'ar 10/18/2001 23:32'!storeBoard: aBoard value: value type: valueType depth: depth stamp: timeStamp	| key entry |	key _ aBoard hashKey bitAnd: array size - 1.	entry _ array at: key + 1.	entry valueType = -1 		ifTrue:[used nextPut: entry]		ifFalse:[entry hashLock = aBoard hashLock ifFalse:[collisions _ collisions + 1]].	(entry valueType = -1 		or:[entry depth <= depth		or:[entry timeStamp < timeStamp]]) ifFalse:[^self].	entry hashLock: aBoard hashLock.	entry value: value.	entry valueType: valueType.	entry depth: depth.	entry timeStamp: timeStamp.! !!ChessTranspositionTable methodsFor: 'lookup' stamp: 'ar 8/12/2001 14:06'!lookupBoard: aBoard	| key entry |	key _ aBoard hashKey bitAnd: array size - 1.	entry _ array at: key + 1.	entry ifNil:[^nil].	entry valueType = -1 ifTrue:[^nil].	entry hashLock = aBoard hashLock ifFalse:[^nil].	^entry! !!ChessTranspositionTable class methodsFor: 'instance creation' stamp: 'ar 8/8/2001 09:15'!new: bits	^self basicNew initialize: bits! !ChessPlayerAI initialize!ChessPlayer initialize!ChessMove initialize!ChessBoard initialize!