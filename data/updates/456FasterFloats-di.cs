'From Squeak 2.3 beta of Nov 25, 1998 on 5 December 1998 at 12:46:12 pm'!"Change Set:		FasterFloatsDate:			29 November 1998Author:			Dan IngallsThis changeSet generally reworks internal arithmetic.	Makes Float operations a bit faster by speeding up loadFloatOrInt,		and by receiving the args from the bytecodePrim routine.	Allows Float compares to use the booleanCheat	Eliminates the confusing (and slow) failSpecialPrim:, and checkIntegerResult:From:.NOTE: These changes were developed together with several others and so may not work in isolation."!!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!pixelWordFor: depth filledWith: pixelValue	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| halfword |	depth = 32 ifTrue: [^ pixelValue].	depth = 16		ifTrue: [halfword _ pixelValue]		ifFalse: [halfword _ pixelValue * 					(#(16rFFFF				"replicates at every bit"						16r5555 -			"replicates every 2 bits"						16r1111 - - -			"replicates every 4 bits"						16r0101) at: depth)	"replicates every 8 bits"].	^ halfword bitOr: (halfword bitShift: 16)! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 11/27/1998 11:19'!fetchClassOf: oop	| ccIndex |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ ^ self splObj: ClassInteger ].	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: ["look up compact class"				^ self fetchPointer: ccIndex - 1					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)		].! !!ObjectMemory methodsFor: 'interpreter access' stamp: 'di 11/27/1998 11:18'!fetchClassOfNonInt: oop	| ccIndex |	self inline: true.	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: ["look up compact class"				^ self fetchPointer: ccIndex - 1					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)]! !!Interpreter methodsFor: 'utilities' stamp: 'di 11/27/1998 21:20'!loadFloatOrIntFrom: floatOrInt	"If floatOrInt is an integer, then convert it to a C double float and return it.	If it is a Float, then load its value and return it.	Otherwise fail -- ie return with successFlag set to false."	self inline: true.	self returnTypeC: 'double'.	(self isIntegerObject: floatOrInt) ifTrue:		[^ self cCode: '((double) (floatOrInt >> 1))'].	(self fetchClassOfNonInt: floatOrInt) = (self splObj: ClassFloat)		ifTrue: [^ self floatValueOf: floatOrInt].	successFlag _ false! !!Interpreter methodsFor: 'contexts' stamp: 'di 11/30/1998 12:31'!pop2AndPushIntegerIfOK: integerResult	successFlag ifTrue:		[(self isIntegerValue: integerResult)			ifTrue: [self pop: 2 thenPush: (self integerObjectOf: integerResult)]			ifFalse: [successFlag _ false]]! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/30/1998 10:37'!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ nil "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatAdd: rcvr toArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ nil "success"]].	messageSelector _ self specialSelector: 0.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 12:02'!bytecodePrimBitAnd	successFlag _ true.	self externalizeIPandSP.	self primitiveBitAnd.	self internalizeIPandSP.	successFlag ifTrue: [^ nil "success"].	messageSelector _ self specialSelector: 14.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 12:03'!bytecodePrimBitOr	successFlag _ true.	self externalizeIPandSP.	self primitiveBitOr.	self internalizeIPandSP.	successFlag ifTrue: [^ nil "success"].	messageSelector _ self specialSelector: 15.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 12:05'!bytecodePrimBitShift	successFlag _ true.	self externalizeIPandSP.	self primitiveBitShift.	self internalizeIPandSP.	successFlag ifTrue: [^ nil "success"].	messageSelector _ self specialSelector: 12.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 10:04'!bytecodePrimDiv	| quotient |	successFlag _ true.	quotient _ self doPrimitiveDiv: (self internalStackValue: 1)							by: (self internalStackValue: 0).	successFlag ifTrue:		[self internalPop: 2 thenPush: (self integerObjectOf: quotient).		^ nil "success"].	messageSelector _ self specialSelector: 13.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/30/1998 09:09'!bytecodePrimDivide	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue:					[result _ rcvr // arg.  "generates C / operation"					(self isIntegerValue: result) ifTrue:						[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ nil "success"]]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatDivide: rcvr byArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ nil "success"]].	messageSelector _ self specialSelector: 9.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:39'!bytecodePrimEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr = arg].	successFlag _ true.	bool _ self primitiveFloatEqual: rcvr toArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 6.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:40'!bytecodePrimGreaterOrEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr >= arg].	successFlag _ true.	bool _ self primitiveFloatLess: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 5.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:40'!bytecodePrimGreaterThan	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr > arg].	successFlag _ true.	bool _ self primitiveFloatGreater: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 3.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:40'!bytecodePrimLessOrEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr <= arg].	successFlag _ true.	bool _ self primitiveFloatGreater: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 4.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:41'!bytecodePrimLessThan	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr < arg].	successFlag _ true.	bool _ self primitiveFloatLess: rcvr thanArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool].	messageSelector _ self specialSelector: 2.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 09:50'!bytecodePrimMakePoint	successFlag _ true.	self externalizeIPandSP.	self primitiveMakePoint.	self internalizeIPandSP.	successFlag ifTrue: [^ nil "success"].	messageSelector _ self specialSelector: 11.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 10:03'!bytecodePrimMod	| mod |	successFlag _ true.	mod _ self doPrimitiveMod: (self internalStackValue: 1)							by: (self internalStackValue: 0).	successFlag ifTrue:		[self internalPop: 2 thenPush: (self integerObjectOf: mod).		^ nil "success"].	messageSelector _ self specialSelector: 10.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/30/1998 08:33'!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [rcvr _ self integerValueOf: rcvr.				arg _ self integerValueOf: arg.				result _ rcvr * arg.				((arg = 0 or: [(result // arg) = rcvr])					and: [self isIntegerValue: result])					ifTrue: [self internalPop: 2 thenPush: (self integerObjectOf: result).							^ nil]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatMultiply: rcvr byArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ nil "success"]].	messageSelector _ self specialSelector: 8.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/27/1998 15:41'!bytecodePrimNotEqual	| rcvr arg bool |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue:		[^ self booleanCheat: rcvr ~= arg].	successFlag _ true.	bool _ self primitiveFloatEqual: rcvr toArg: arg.	successFlag ifTrue:		[^ self booleanCheat: bool not].	messageSelector _ self specialSelector: 7.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 12:07'!bytecodePrimPointX	successFlag _ true.	self externalizeIPandSP.	self primitivePointX.	self internalizeIPandSP.	successFlag ifTrue: [^ nil "success"].	messageSelector _ self specialSelector: 30.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/29/1998 12:07'!bytecodePrimPointY	successFlag _ true.	self externalizeIPandSP.	self primitivePointY.	self internalizeIPandSP.	successFlag ifTrue: [^ nil "success"].	messageSelector _ self specialSelector: 31.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/28/1998 15:11'!bytecodePrimSize	"See the comment in bytePrimitiveAt"	| sz rcvr |	rcvr _ self internalStackValue: 0.	(self okStreamArrayClass: (self fetchClassOf: rcvr)) ifTrue:		[sz _ self stSizeOf: rcvr.		successFlag ifTrue:			[(self isIntegerValue: sz)				ifTrue: [self internalPop: 1 thenPush: (self integerObjectOf: sz)]				ifFalse: [self externalizeIPandSP.						self pop: 1 thenPush: (self positive32BitIntegerFor: sz).						self internalizeIPandSP].			^ nil "success"]].	messageSelector _ self specialSelector: 18.	argumentCount _ 0.	self normalSend! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 11/30/1998 09:09'!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).				(self isIntegerValue: result) ifTrue:					[self internalPop: 2						thenPush: (self integerObjectOf: result).					^ nil "success"]]		ifFalse: [successFlag _ true.				self externalizeIPandSP.				self primitiveFloatSubtract: rcvr fromArg: arg.				self internalizeIPandSP.				successFlag ifTrue: [^ nil "success"]].	messageSelector _ self specialSelector: 1.	argumentCount _ 1.	self normalSend! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:38'!checkBooleanResult: result	successFlag		ifTrue: [self pushBool: result]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:26'!checkIntegerResult: integerResult	(successFlag and: [self isIntegerValue: integerResult])		ifTrue: [self pushInteger: integerResult]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 11:22'!doPrimitiveDiv: rcvr by: arg	"Rounds negative results towards negative infinity, rather than zero."	| result posArg posRcvr integerRcvr integerArg |	(self areIntegers: rcvr and: arg)		ifTrue: [integerRcvr _ self integerValueOf: rcvr.				integerArg _ self integerValueOf: arg.				self success: integerArg ~= 0]		ifFalse: [self primitiveFail].	successFlag ifFalse: [^ 1 "fail"].	integerRcvr > 0		ifTrue: [integerArg > 0					ifTrue: [result _ integerRcvr // integerArg]					ifFalse: ["round negative result toward negative infinity"							posArg _ 0 - integerArg.							result _ 0 - ((integerRcvr + (posArg - 1)) // posArg)]]		ifFalse: [posRcvr _ 0 - integerRcvr.				integerArg > 0					ifTrue: ["round negative result toward negative infinity"							result _ 0 - ((posRcvr + (integerArg - 1)) // integerArg)]					ifFalse: [posArg _ 0 - integerArg.							result _ posRcvr // posArg]].	self success: (self isIntegerValue: result).	^ result! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 10:02'!doPrimitiveMod: rcvr by: arg	| integerResult integerRcvr integerArg |	(self areIntegers: rcvr and: arg)		ifTrue: [integerRcvr _ self integerValueOf: rcvr.				integerArg _ self integerValueOf: arg.				self success: integerArg ~= 0]		ifFalse: [self primitiveFail].	successFlag ifFalse: [^ 1 "fail"].	integerResult _ integerRcvr \\ integerArg.	"ensure that the result has the same sign as the integerArg"	integerArg < 0		ifTrue: [integerResult > 0			ifTrue: [integerResult _ integerResult + integerArg]]		ifFalse: [integerResult < 0			ifTrue: [integerResult _ integerResult + integerArg]].	self success: (self isIntegerValue: integerResult).	^ integerResult! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:13'!primitiveAdd	self pop2AndPushIntegerIfOK: (self stackIntegerValue: 1) + (self stackIntegerValue: 0)! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 12:02'!primitiveBitAnd	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitAnd: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 12:02'!primitiveBitOr	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitOr: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/29/1998 12:04'!primitiveBitShift 	| integerReceiver integerArgument shifted |	integerArgument _ self popInteger.	integerReceiver _ self popPos32BitInteger.	successFlag ifTrue: [		integerArgument >= 0 ifTrue: [			"Left shift -- must fail if we lose bits beyond 32"			self success: integerArgument <= 31.			shifted _ integerReceiver << integerArgument.			self success: (shifted >> integerArgument) = integerReceiver.		] ifFalse: [			"Right shift -- OK to lose bits"			self success: integerArgument >= -31.			shifted _ integerReceiver bitShift: integerArgument.		].	].	successFlag		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 13:18'!primitiveBitXor	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitXor: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:34'!primitiveDiv	| quotient |	quotient _ self doPrimitiveDiv: (self stackIntegerValue: 1)							by: (self stackIntegerValue: 0).	self pop2AndPushIntegerIfOK: quotient! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:25'!primitiveDivide	| integerReceiver integerArgument |	integerReceiver _ self stackIntegerValue: 1.	integerArgument _ self stackIntegerValue: 0.	(integerArgument ~= 0 and: [integerReceiver \\ integerArgument = 0])		ifTrue: [self pop2AndPushIntegerIfOK: integerReceiver // integerArgument]		ifFalse: [self primitiveFail]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveEqual	| integerReceiver integerArgument result |	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ self compare31or32Bits: integerReceiver equal: integerArgument.	self checkBooleanResult: result! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveGreaterOrEqual	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver >= integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveGreaterThan	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver > integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveLessOrEqual	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver <= integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveLessThan	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver < integerArgument! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/28/1998 16:43'!primitiveMakePoint	| integerReceiver integerArgument |	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	successFlag		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:36'!primitiveMod	| mod |	mod _ self doPrimitiveMod: (self stackValue: 1) by: (self stackValue: 0).	self pop2AndPushIntegerIfOK: mod! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:27'!primitiveMultiply	| integerRcvr integerArg integerResult |	integerRcvr _ self stackIntegerValue: 1.	integerArg _ self stackIntegerValue: 0.	successFlag ifTrue:		[integerResult _ integerRcvr * integerArg.		"check for C overflow by seeing if computation is reversible"		((integerArg = 0) or: [(integerResult // integerArg) = integerRcvr])			ifTrue: [self pop2AndPushIntegerIfOK: integerResult]			ifFalse: [self primitiveFail]]! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/27/1998 15:43'!primitiveNotEqual	| integerReceiver integerArgument result |	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.	self checkBooleanResult: result! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:19'!primitiveQuo	"Rounds negative results towards zero."	| integerRcvr integerArg integerResult |	integerRcvr _ self stackIntegerValue: 1.	integerArg _ self stackIntegerValue: 0.	self success: integerArg ~= 0.	successFlag ifTrue: [		integerRcvr > 0 ifTrue: [			integerArg > 0 ifTrue: [				integerResult _ integerRcvr // integerArg.			] ifFalse: [				integerResult _ 0 - (integerRcvr // (0 - integerArg)).			].		] ifFalse: [			integerArg > 0 ifTrue: [				integerResult _ 0 - ((0 - integerRcvr) // integerArg).			] ifFalse: [				integerResult _ (0 - integerRcvr) // (0 - integerArg).			].		]].	self pop2AndPushIntegerIfOK: integerResult! !!Interpreter methodsFor: 'arithmetic primitives' stamp: 'di 11/30/1998 10:13'!primitiveSubtract	self pop2AndPushIntegerIfOK: (self stackIntegerValue: 1) - (self stackIntegerValue: 0)! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:45'!primitiveFloatAdd	^ self primitiveFloatAdd: (self stackValue: 1) toArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:10'!primitiveFloatAdd: rcvrOop toArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr + arg)].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:45'!primitiveFloatDivide	^ self primitiveFloatDivide: (self stackValue: 1) byArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:30'!primitiveFloatDivide: rcvrOop byArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self push: (self floatObjectOf: rcvr // arg)  "generates C / operation"]].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:48'!primitiveFloatEqual	| bool |	bool _ self primitiveFloatEqual: (self stackValue: 1) toArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:18'!primitiveFloatEqual: rcvrOop toArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [^ rcvr = arg]! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:42'!primitiveFloatGreater: rcvrOop thanArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [^ rcvr > arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:40'!primitiveFloatGreaterOrEqual	| bool |	bool _ self primitiveFloatLess: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool not].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:52'!primitiveFloatGreaterThan	| bool |	bool _ self primitiveFloatGreater: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:21'!primitiveFloatLess: rcvrOop thanArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [^ rcvr < arg].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:49'!primitiveFloatLessOrEqual	| bool |	bool _ self primitiveFloatGreater: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool not].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:51'!primitiveFloatLessThan	| bool |	bool _ self primitiveFloatLess: (self stackValue: 1) thanArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:46'!primitiveFloatMultiply	^ self primitiveFloatMultiply: (self stackValue: 1) byArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:30'!primitiveFloatMultiply: rcvrOop byArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr * arg)].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 14:49'!primitiveFloatNotEqual	| bool |	bool _ self primitiveFloatEqual: (self stackValue: 1) toArg: self stackTop.	successFlag ifTrue: [self pop: 2. self pushBool: bool not].! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:46'!primitiveFloatSubtract	^ self primitiveFloatSubtract: (self stackValue: 1) fromArg: self stackTop! !!Interpreter methodsFor: 'float primitives' stamp: 'di 11/27/1998 11:30'!primitiveFloatSubtract: rcvrOop fromArg: argOop	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self pop: 2.		self push: (self floatObjectOf: rcvr - arg)].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 11/28/1998 15:15'!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr)		ifTrue: [self primitiveFail]  "integers have no indexable fields"		ifFalse: [sz _ self stSizeOf: rcvr].	successFlag ifTrue:		[self pop: 1 thenPush: (self positive32BitIntegerFor: sz)]! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 11/29/1998 12:06'!primitivePointX	| rcvr | 	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'object access primitives' stamp: 'di 11/29/1998 12:08'!primitivePointY	| rcvr | 	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1]! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'di 11/27/1998 12:14'!primitiveFloatDivide: rcvrOop byArg: argOop	"NOTE: This method had to be overridden due to the use of // in super"	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvr _ self loadFloatOrIntFrom: rcvrOop.	arg _ self loadFloatOrIntFrom: argOop.	successFlag ifTrue: [		self success: arg ~= 0.0.		successFlag ifTrue: [			self pop: 2.			self push: (self floatObjectOf: rcvr / arg)  " / overrides // "]].! !Interpreter removeSelector: #checkIntegerResult:from:!Interpreter removeSelector: #checkBooleanResult:from:!InterpreterSimulator removeSelector: #primitiveFloatDivide!