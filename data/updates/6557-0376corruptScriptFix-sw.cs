'From Squeakland 3.8.5976 of 25 August 2004 [latest update: #375] on 15 December 2004 at 8:48:48 pm'!"Change Set:		corruptScriptFix-swDate:			15 December 2004Author:			Scott WallaceFixes up certain damaged etoy projects -- request 'attempt misc repairs' from the authoring-tools menu to invoke.*  uniclassScripts that have nil scriptEditors are expunged.*  uniclassScripts that have nil scriptedClasses are fixed up.*  scriptEditors whose scriptNames conflict with the selector of the uniclassScript that holds on to them are fixed up."!!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 12/15/2004 20:48'!attemptCleanupReporting: whetherToReport	"Try to fix up some bad things that are known to occur in some etoy projects we've seen. If the whetherToReport parameter is true, an informer is presented after the cleanups"	| fixes |	fixes _ 0.	ActiveWorld ifNotNil:		[(ActiveWorld submorphs select:			[:m | (m isKindOf: ScriptEditorMorph) and: [m submorphs isEmpty]]) do:				[:m | m delete.  fixes _ fixes + 1]].	TransformationMorph allSubInstancesDo:		[:m | (m player notNil and: [m renderedMorph ~~ m])			ifTrue:				[m renderedMorph visible ifFalse:					[m renderedMorph visible: true.  fixes _ fixes + 1]]].	(Player class allSubInstances select: [:cl | cl isUniClass]) do:		[:aUniclass |			fixes _ fixes + aUniclass cleanseScripts].	self presenter flushPlayerListCache; allExtantPlayers.	whetherToReport ifTrue:		[self inform: fixes printString, ' [or more] repair(s) made']"ActiveWorld attemptCleanupReporting: true.ActiveWorld attemptCleanupReporting: false."! !!Player class methodsFor: 'housekeeping' stamp: 'sw 12/15/2004 20:43'!cleanseScripts	"Fix up various known structure errors in the uniclass relating to the scripts dctionary.  Answer the number of fixes made."	| errs ed |	scripts ifNil: [scripts _ IdentityDictionary new].	errs _ 0.	(scripts includesKey: nil) ifTrue: [errs _ errs + 1.  scripts removeKey: nil].	scripts keysAndValuesDo: 		[:sel :uniclassScript |			uniclassScript				ifNil:					[errs _ errs + 1.					Transcript cr; show: ' fix type 1, nil scripts key'.					scripts removeKey: sel]				ifNotNil:					[(ed _ uniclassScript currentScriptEditor)						ifNil:							[errs _ errs + 1.							Transcript cr; show: ' fix type 2, sel = ', sel.							self someInstance removeScriptWithSelector: uniclassScript selector.]						ifNotNil:							[uniclassScript playerClassPerSe								ifNil:									[errs _ errs + 1.									Transcript cr; show: ' fix type 3, sel = ', sel.									uniclassScript playerClass: self selector:  sel]								ifNotNil:									[(ed scriptName ~= uniclassScript selector) ifTrue:										[errs _ errs + 1.										ed restoreScriptName: sel.										Transcript cr; show: ' fix type 4, sel = ', sel.]]]]].	^ errs! !!Presenter methodsFor: 'intialize' stamp: 'sw 12/13/2004 16:58'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList objectsReferredToByTiles |	playerList ifNotNil:		[^ playerList].	fullList _ associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNilDo: [:ed |						objectsReferredToByTiles _ ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList _ (fullList asSet asSortedCollection:			[:a :b | a externalName < b externalName]) asArray! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 12/15/2004 15:19'!printOn: aStream	^ aStream nextPutAll: 'ScriptEditor for #', scriptName asString, ' player: ', playerScripted externalName! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 12/15/2004 20:37'!restoreScriptName: aScriptName	"For fixup only..."	scriptName _ aScriptName! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 12/15/2004 15:15'!printOn: aStream	aStream nextPutAll: 'A UniclassScript - selector: ', selector printString, ' scriptEditor: ', currentScriptEditor printString! !!UniclassScript methodsFor: 'access' stamp: 'sw 12/15/2004 20:46'!playerClass	"Answer the playerClass associated with the receiver"	^ playerClass ifNil:		[playerClass _ currentScriptEditor playerScripted ifNotNil: [currentScriptEditor playerScripted class]]! !!UniclassScript methodsFor: 'access' stamp: 'sw 12/15/2004 16:42'!playerClassPerSe	"Answer the current value of the playerClass inst var."	^ playerClass! !